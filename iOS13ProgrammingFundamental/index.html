<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>iOS 13 Programming Fundamentals with Swift</title></head><body><div class="calibre" id="calibre_link-2382">
<div id="calibre_link-2888" class="calibre1"><nav data-type="toc" {http://www.idpf.org/2007/ops}type="toc" id="calibre_link-2889" class="calibre2"><ol class="calibre3"><li data-type="preface" class="calibre4"><a href="#calibre_link-2383" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Preface</a><ol class="calibre6">















<li data-type="sect1" class="calibre4"><a href="#calibre_link-2384" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Scope of This Book</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2385" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From the Programming iOS 4 Preface</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2386" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Versions</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2387" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Acknowledgments</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2388" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conventions Used in This Book</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2389" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Using Code Examples</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2390" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Oâ€™Reilly Online Learning</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2391" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to Contact Us</a></li>







</ol></li>
<li data-type="part" class="calibre4"><a href="#calibre_link-2392" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">I. Language</a><ol class="calibre6">








<li data-type="chapter" class="calibre4"><a href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">1. The Architecture of Swift</a><ol class="calibre7">










<li data-type="sect1" class="calibre4"><a href="#calibre_link-2394" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2395" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Everything Is an Object?</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2396" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Three Flavors of Object Type</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2397" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2398" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2399" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2400" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Scope and Lifetime</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2401" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Members</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2402" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Namespaces</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2403" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2404" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2405" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Instances?</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2406" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Keyword self</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2407" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2408" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Design</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">2. Functions</a><ol class="calibre7">










<li data-type="sect1" class="calibre4"><a href="#calibre_link-2409" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a><ol class="calibre7">


























































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2410" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Void Return Type and Parameters</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2411" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Signature</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2412" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2413" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overloading</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2414" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Default Parameter Values</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2415" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2416" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ignored Parameters</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2417" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modifiable Parameters</a><ol class="calibre7">










































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2418" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Calling Objective-C with Modifiable Parameters</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2419" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Called by Objective-C with Modifiable Parameters</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2420" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reference Type Modifiable Parameters</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2421" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function in Function</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2422" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Recursion</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2423" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2424" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a><ol class="calibre7">


































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2425" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Using Anonymous Functions Inline</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2426" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2427" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Define-and-Call</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2428" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closures</a><ol class="calibre7">

































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2429" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Closures Improve Code</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2430" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Returning Function</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2431" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closure Setting a Captured Variable</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2432" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closure Preserving Captured Environment</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Escaping Closures</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2434" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Curried Functions</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2435" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function References and Selectors</a><ol class="calibre7">






































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2436" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Reference Scope</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2437" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a></li>





</ol></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">3. Variables and Simple Types</a><ol class="calibre7">












<li data-type="sect1" class="calibre4"><a href="#calibre_link-2438" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2439" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2440" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variable Initializer</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2441" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a><ol class="calibre7">

























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2442" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Properties</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2443" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2444" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Setter Observers</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2445" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a><ol class="calibre7">














<li data-type="sect2" class="calibre4"><a href="#calibre_link-2446" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Singleton</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2447" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization of Instance Properties</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2448" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Built-In Simple Types</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2449" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2450" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Numbers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2451" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2452" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2453" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2454" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2455" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a></li>





</ol></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">4. Object Types</a><ol class="calibre7">












<li data-type="sect1" class="calibre4"><a href="#calibre_link-2456" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a><ol class="calibre7">



















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2457" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2458" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Properties</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2459" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2460" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2461" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested Object Types</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2462" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a><ol class="calibre7">









































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2463" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2464" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Values</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2465" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Case Iteration</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2466" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Initializers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2467" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Properties</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2468" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2469" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Enums?</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2470" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Structs</a><ol class="calibre7">













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2471" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Initializers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2472" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Properties</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2473" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-95" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2474" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Classes</a><ol class="calibre7">














<li data-type="sect2" class="calibre4"><a href="#calibre_link-65" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Value Types and Reference Types</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2475" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2476" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Initializers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2477" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Deinitializer</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2478" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Properties</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2479" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static/Class Members</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2480" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2481" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Casting</a><ol class="calibre7">























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2482" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Casting Down</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2483" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2484" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Optionals</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2485" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridging to Objective-C</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2486" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type References</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2487" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2488" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2489" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type as Value</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2490" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Summary of Type Terminology</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2491" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparing Types</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2492" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a><ol class="calibre7">




































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2493" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Protocols?</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2494" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2495" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Type Testing and Casting</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2496" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Declaring a Protocol</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2497" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Composition</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2498" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Protocols</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-55" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2499" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2500" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Literal Convertibles</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2501" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a><ol class="calibre7">
























































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2502" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2503" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Contradictory Resolution is Impossible</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2504" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2505" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2506" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Invariance</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2507" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Type Chains</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2508" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2509" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a><ol class="calibre7">












































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2510" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Protocols</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2511" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2512" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Umbrella Types</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2513" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Any</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2514" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">AnyObject</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2515" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">AnyClass</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2516" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Collection Types</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2517" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2518" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2519" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>





</ol></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">5. Flow Control and More</a><ol class="calibre7">










<li data-type="sect1" class="calibre4"><a href="#calibre_link-2520" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a><ol class="calibre7">























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2521" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Branching</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2522" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loops</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2523" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Jumping</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2524" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a><ol class="calibre7">


















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2525" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Private and Fileprivate</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2526" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2527" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy Rules</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2528" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Introspection</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-60" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2529" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2530" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2531" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2532" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Miscellaneous Swift Language Features</a><ol class="calibre7">















<li data-type="sect2" class="calibre4"><a href="#calibre_link-61" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Synthesized Protocol Implementations</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2533" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key Paths</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2534" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dynamic Membership</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2535" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2536" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Custom String Interpolation</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2537" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-96" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Builders</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2538" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Result</a></li>





</ol></li>







</ol></li>









</ol></li>
<li data-type="part" class="calibre4"><a href="#calibre_link-2539" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">II. IDE</a><ol class="calibre6">








<li data-type="chapter" class="calibre4"><a href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">6. Anatomy of an Xcode Project</a><ol class="calibre7">













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2540" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2541" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Project Window</a><ol class="calibre7">





















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2542" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2543" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2544" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Editor</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2545" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Project File and Dependents</a><ol class="calibre7">















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2546" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Contents of the Project Folder</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2547" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Groups</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2548" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Target</a><ol class="calibre7">





















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2549" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Phases</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2550" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Settings</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2551" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Configurations</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2552" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Schemes and Destinations</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2553" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a><ol class="calibre7">



























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2554" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Settings</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2555" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2556" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2557" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Resources</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2558" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Code Files</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2559" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2560" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The App Launch Process</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2561" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Entry Point</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-69" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2562" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">App Without a Storyboard</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2563" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">7. Nib Files</a><ol class="calibre7">




























<li data-type="sect1" class="calibre4"><a href="#calibre_link-2564" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Editor Interface</a><ol class="calibre7">
















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2565" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2566" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Canvas</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2567" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2568" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Nib</a><ol class="calibre7">

























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2569" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a View Controller</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2570" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Main View</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2571" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a View Manually</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2572" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Connections</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2573" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Outlets</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2574" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2575" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatically Configured Nibs</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-67" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Outlets</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2576" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deleting an Outlet</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2577" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">More Ways to Create Outlets</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2578" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Outlet Collections</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2579" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2580" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">More Ways to Create Actions</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2581" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Actions</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2582" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Connections Between Nibs &mdash; Not!</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2583" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-54" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">8. Documentation</a><ol class="calibre7">













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2584" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Documentation Window</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2585" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Documentation Pages</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2586" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Quick Help</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2587" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Symbol Declarations</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2588" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Header Files</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2589" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Sample Code</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2590" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Internet Resources</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">9. Life Cycle of a Project</a><ol class="calibre7">










<li data-type="sect1" class="calibre4"><a href="#calibre_link-2591" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Environmental Dependencies</a><ol class="calibre7">












<li data-type="sect2" class="calibre4"><a href="#calibre_link-2592" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional Compilation</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2593" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Permissible Runtime Environment</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2594" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2595" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2596" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arguments and Environment Variables</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2597" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2598" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing and Navigating Your Code</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2599" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Text Editing Preferences</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2600" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Multiple Selection</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2601" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autocompletion and Placeholders</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2602" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Snippets</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2603" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Refactoring and Structure Editing</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2604" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Fix-it and Live Syntax Checking</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2605" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2606" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Finding</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2607" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running in the Simulator</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2608" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2609" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2610" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Xcode Debugger</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2611" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a><ol class="calibre7">



























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2612" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2613" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Interface Tests</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2614" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Test Plans</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2615" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Clean</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2616" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running on a Device</a><ol class="calibre7">













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2617" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Obtaining a Developer Program Membership</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2618" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2619" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2620" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Manual Signing</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2621" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running the App</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2622" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Managing Development Certificates and Devices</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2623" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Profiling</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2624" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Gauges</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-91" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2625" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instruments</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2626" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Localization</a><ol class="calibre7">



















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2627" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2628" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing Localization</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2629" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution</a><ol class="calibre7">












<li data-type="sect2" class="calibre4"><a href="#calibre_link-2630" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Making an Archive</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2631" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Certificate</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2632" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Profile</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2633" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution for Testing</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2634" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Final App Preparations</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2635" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Screenshots and Video Previews</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2636" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2637" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a></li>





</ol></li>







</ol></li>









</ol></li>
<li data-type="part" class="calibre4"><a href="#calibre_link-2638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">III. Cocoa</a><ol class="calibre6">








<li data-type="chapter" class="calibre4"><a href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">10. Cocoa Classes</a><ol class="calibre7">












<li data-type="sect1" class="calibre4"><a href="#calibre_link-2639" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2640" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Categories and Extensions</a><ol class="calibre7">












<li data-type="sect2" class="calibre4"><a href="#calibre_link-2641" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Swift Uses Extensions</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2642" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How You Use Extensions</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2643" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Cocoa Uses Categories</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2644" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a><ol class="calibre7">







































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2645" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2646" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Informal Protocols</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2647" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a><ol class="calibre7">
















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2648" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSRange</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2649" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNotFound</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2650" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2651" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2652" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2653" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2654" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSData</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2655" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSMeasurement and Friends</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2656" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2657" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2658" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDictionary and NSMutableDictionary</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2659" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2660" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSIndexSet</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2661" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNull</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2662" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2663" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Lists</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2664" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2665" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a><ol class="calibre7">



































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2666" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Accessors</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2667" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2668" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Outlets Work</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2669" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Key Paths</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2670" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Uses of Key&ndash;Value Coding</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2671" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">KeyPath Notation</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2672" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Secret Life of NSObject</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">11. Cocoa Events</a><ol class="calibre7">
















<li data-type="sect1" class="calibre4"><a href="#calibre_link-2673" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reasons for Events</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2674" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2675" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a><ol class="calibre7">























<li data-type="sect2" class="calibre4"><a href="#calibre_link-2676" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Receiving a Notification</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2677" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unregistering</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2678" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Posting a Notification</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2679" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Timer</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2680" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegation</a><ol class="calibre7">













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2681" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Delegation</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2682" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implementing Delegation</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2683" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Data Sources</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2684" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a><ol class="calibre7">





































<li data-type="sect2" class="calibre4"><a href="#calibre_link-2685" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Responder Chain</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2686" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nil-Targeted Actions</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2687" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing</a><ol class="calibre7">




















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2688" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Registration and Notification</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2689" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unregistering</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2690" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing Example</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2691" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swamped by Events</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2692" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delayed Performance</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">12. Memory Management</a><ol class="calibre7">














<li data-type="sect1" class="calibre4"><a href="#calibre_link-2693" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2694" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2695" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">What ARC Is and What It Does</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2696" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Cocoa Objects Manage Memory</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2697" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autorelease Pool</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2698" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Instance Properties</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2699" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2700" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unusual Memory Management Situations</a><ol class="calibre7">











<li data-type="sect2" class="calibre4"><a href="#calibre_link-2701" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2702" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">KVO Observers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2703" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Timers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2704" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-94" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Loading and Memory Management</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2705" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of CFTypeRefs</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2706" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Memory Management Policies</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2707" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a></li>







</ol></li>














<li data-type="chapter" class="calibre4"><a href="#calibre_link-50" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">13. Communication Between Objects</a><ol class="calibre7">










<li data-type="sect1" class="calibre4"><a href="#calibre_link-2708" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility Through an Instance Property</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2709" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility by Instantiation</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2710" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a><ol class="calibre7">



















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2711" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility by Relationship</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2712" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global Visibility</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2713" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications and Key&ndash;Value Observing</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2714" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2715" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>







</ol></li>














<li data-type="appendix" class="calibre4"><a href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">A. C, Objective-C, and Swift</a><ol class="calibre7">












<li data-type="sect1" class="calibre4"><a href="#calibre_link-2716" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The C Language</a><ol class="calibre7">



















<li data-type="sect2" class="calibre4"><a href="#calibre_link-2717" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Data Types</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2718" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Enums</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2719" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Structs</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2720" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2721" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Arrays</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2722" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Functions</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2723" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C</a><ol class="calibre7">













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2724" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2725" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and Swift Objects</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2726" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2727" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2728" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Methods</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2729" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Initializers and Factories</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2730" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2731" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">CFTypeRefs</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2732" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Blocks</a></li>













<li data-type="sect2" class="calibre4"><a href="#calibre_link-2733" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">API Markup</a></li>





</ol></li>













<li data-type="sect1" class="calibre4"><a href="#calibre_link-2734" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>







</ol></li>









</ol></li>
<li data-type="index" class="calibre4"><a href="#calibre_link-2735" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Index</a></li>
</ol></nav>
</div>
</div>


<div class="calibre" id="calibre_link-2749">
<div id="calibre_link-2890" class="calibre1"><section data-type="titlepage" {http://www.idpf.org/2007/ops}type="titlepage" data-pdf-bookmark="iOS 13 Programming Fundamentals with Swift" class="calibre8 pcalibre4"><div class="preface" id="calibre_link-2891">
<h1 class="calibre9">iOS 13 Programming Fundamentals with Swift</h1>

<p class="edition">Sixth Edition</p>

<p class="subtitle" data-type="subtitle" {http://www.idpf.org/2007/ops}type="subtitle">Swift, Xcode, and Cocoa Basics</p>

<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2892">With Early Release ebooks, you get books in their earliest form&mdash;the authorâ€™s raw and unedited content as they write&mdash;so you can take advantage of these technologies long before the official release of these titles.</div>
</aside>

<p class="author">Matt Neuburg</p>
</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2736">
<div id="calibre_link-2893" class="calibre1"><section data-type="copyright-page" {http://www.idpf.org/2007/ops}type="copyright-page" data-pdf-bookmark="iOS 13 Programming Fundamentals with Swift, Fifth Edition" class="calibre2"><div class="preface" id="calibre_link-2894">
<h1 class="calibre10">iOS 13 Programming Fundamentals with Swift, Fifth Edition</h1>

<p class="author1">by Matt Neuburg</p>

<p class="author1">Copyright Â© 2019 Matt Neuburg. All rights reserved.</p>

<p class="author1">Printed in the United States of America.</p>

<p class="author1">Published by <span class="publishername">Oâ€™Reilly Media, Inc.</span>, 1005 Gravenstein Highway North, Sebastopol, CA 95472.</p>

<p class="author1">Oâ€™Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (<a href="http://oreilly.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">http://oreilly.com</a>). For more information, contact our corporate/institutional sales department: 800-998-9938 or <span data-type="email" class="publishername"><em class="calibre11">corporate@oreilly.com</em></span>.</p>

<ul class="stafflist">
	<li class="calibre12"><span class="publishername">Editor: </span>Rachel Roumeliotis</li>
	<li class="calibre12"><span class="publishername">Production Editor: </span>Kristen Brown</li>
	<li class="calibre12"><span class="publishername">Proofreader: </span>Oâ€™Reilly Production Services</li>
	<li class="calibre12"><span class="publishername">Indexer: </span>Matt Neuburg</li>
	<li class="calibre12"><span class="publishername">Cover Designer: </span>Karen Montgomery</li>
	<li class="calibre12"><span class="publishername">Interior Designer: </span>David Futato</li>
	<li class="calibre12"><span class="publishername">Illustrator: </span>Matt Neuburg</li>
</ul>

<ul class="stafflist">
	<li class="calibre12"><span class="publishername">April 2015:</span> First Edition</li>
	<li class="calibre12"><span class="publishername">October 2015:</span> Second Edition</li>
	<li class="calibre12"><span class="publishername">October 2016:</span> Third Edition</li>
	<li class="calibre12"><span class="publishername">October 2017:</span> Fourth Edition</li>
	<li class="calibre12"><span class="publishername">September 2018:</span> Fifth Edition</li>
	<li class="calibre12"><span class="publishername">October 2019:</span> Sixth Edition</li>
</ul>

<div class="preface">
<h1 class="calibre10">Revision History for the Sixth Edition</h1>

<ul class="stafflist">
	<li class="calibre12"><span class="publishername">2019-07-24:</span> First release</li>
</ul>
</div>

<p class="author1">See <a href="http://oreilly.com/catalog/errata.csp?isbn=9781492074533" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">http://oreilly.com/catalog/errata.csp?isbn=9781492074533</a> for release details.</p>

<div class="preface">
<p class="author1">The Oâ€™Reilly logo is a registered trademark of Oâ€™Reilly Media, Inc. <em class="calibre11">iOS 13 Programming Fundamentals with Swift</em>, the image of a harp seal, and related trade dress are trademarks of Oâ€™Reilly Media, Inc.</p>

<p class="author1">While the publisher and the author have used good faith efforts to ensure that the information and instructions contained in this work are accurate, the publisher and the author disclaim all responsibility for errors or omissions, including without limitation responsibility for damages resulting from the use of or reliance on this work. Use of the information and instructions contained in this work is at your own risk. If any code samples or other technology this work contains or describes is subject to open source licenses or the intellectual property rights of others, it is your responsibility to ensure that your use thereof complies with such licenses and/or rights.</p>
</div>

<div class="preface">
<p class="author1">ISBN: 978-1-492-07453-3</p>

<p class="author1">[LSI]</p>
</div>
</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2744">
<div id="calibre_link-2895" class="calibre1"><section data-type="preface" {http://www.idpf.org/2007/ops}type="preface" data-pdf-bookmark="Preface" class="calibre2"><div class="preface" id="calibre_link-2383">
<h1 class="calibre13">Preface</h1>


<p class="author1">With the arrival of Swift 5 in early 2019, the stamp of maturity has been placed upon the Swift language. When Swift was introduced to the public in 2014, it was a sort second-class citizen. The Cocoa frameworks that give an iOS app its functionality expect to be spoken to in Objective-C, and several megabytes of libraries had to be included in every Swift app, effectively containing the whole of the Swift language and translating everything into Objective-C. But Swift 5 introduces ABI stability, which means that, starting in iOS 10.2, the Swift language has become part of the system. Swift is now on a par with Objective-C, and Swift apps are smaller and faster.</p>

<p class="author1">When Swift first appeared, I immediately translated my own existing iOS apps into Swift, and found them easier to undertand and maintain than their Objective-C originals. Objective-C is a powerful language with some remarkable capabilities, but it is safe to say that the vast majority of new iOS programmers will adopt Swift. It is a superb language to learn, even (perhaps especially) if youâ€™ve never programmed before, and is the easiest and clearest way to program iOS. Swift has these salient features:</p>
<dl class="calibre14">
<dt class="calibre15">Object-orientation</dt>
<dd class="calibre16">
<p class="calibre17">Swift is a modern, object-oriented language. It is <em class="calibre11">purely</em> object-oriented: â€œEverything is an object.â€</p>
</dd>
<dt class="calibre15">Clarity</dt>
<dd class="calibre16">
<p class="calibre17">Swift is easy to read and easy to write. Its syntax is clear, consistent, and explicit, with few hidden shortcuts and minimal syntactic trickery.</p>
</dd>
<dt class="calibre15">Safety</dt>
<dd class="calibre16">
<p class="calibre17">Swift enforces strong typing to ensure that it knows, and that you know, what the type of every object reference is at every moment.</p>
</dd>
<dt class="calibre15">Economy</dt>
<dd class="calibre16">
<p class="calibre17">Swift is a fairly small language, providing some basic types and functionalities and no more. The rest must be provided by your code, or by libraries of code that you use &mdash; such as Cocoa.</p>
</dd>
<dt class="calibre15">Memory management</dt>
<dd class="calibre16">
<p class="calibre17">Swift manages memory automatically. You will rarely have to concern yourself with memory management.</p>
</dd>
<dt class="calibre15">Cocoa compatibility</dt>
<dd class="calibre16">
<p class="calibre17">The Cocoa APIs are written primarily in C and Objective-C. Swift is explicitly designed to interface with most of the Cocoa APIs.</p>
</dd>
</dl>

<p class="author1">Even when your code is in Swift, some awareness of Objective-C (including C) can be useful. The Foundation and Cocoa APIs are still written in C and Objective-C. In order to interact with them, you might have to know what those languages would expect.<a data-type="indexterm" data-primary="API" id="calibre_link-147" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
Therefore in this book I describe Objective-C in enough detail to allow you to read it when you encounter it in the documentation and on the Internet, and I occasionally show some Objective-C code. <a data-type="xref" href="#calibre_link-2638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Part&nbsp;III</a>, on Cocoa, is largely about learning to think the way Objective-C thinks &mdash; because the structure and behavior of the Cocoa APIs are fundamentally based on Objective-C. And the book ends with an appendix that details how Swift and Objective-C communicate with one another, as well as explaining how your app can be written partly in Swift and partly in Objective-C.</p>






<section data-type="sect1" data-pdf-bookmark="The Scope of This Book" class="calibre2"><div class="preface" id="calibre_link-2384">
<h1 class="calibre18">The Scope of This Book</h1>

<p class="author1">This book is intended to accompany and precede <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" href="http://shop.oreilly.com/product/0636920208662.do"><em class="calibre11">Programming iOS 13</em></a>, which picks up where this book leaves off.
If writing an iOS program is like building a house of bricks, this book teaches you what a brick is and how to handle it, while <em class="calibre11">Programming iOS 13</em> shows you some actual bricks and tells you how to assemble them.</p>

<p class="author1">When you have read this book, youâ€™ll know about Swift, Xcode, and the underpinnings of the Cocoa framework, and you will be ready to proceed directly to <em class="calibre11">Programming iOS 13</em>. Conversely, <em class="calibre11">Programming iOS 13</em> assumes a knowledge of this book; it begins, like Homerâ€™s <em class="calibre11">Iliad</em>, in the middle of the story, with the reader jumping with all four feet into views and view controllers, and with a knowledge of the language and the Xcode IDE already presupposed. If you started reading <em class="calibre11">Programming iOS 13</em> and wondered about such unexplained matters as Swift language basics, the <code class="calibre19">UIApplicationMain</code> function, the nib-loading mechanism, Cocoa patterns of delegation and notification, and retain cycles, wonder no longer &mdash; I didnâ€™t explain them there because I do explain them here.</p>

<p class="author1">This book doesnâ€™t show how to write any particularly interesting iOS apps, but it does constantly use my own real apps and real programming situations to illustrate and motivate its explanations, as it teaches you the underlying basis of iOS programming.
It has three parts:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-2392" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Part&nbsp;I</a> introduces the Swift language, from the ground up &mdash; I do not assume that you know any other programming languages. My way of teaching Swift is different from other treatments, such as Appleâ€™s; it is systematic and Euclidean, with pedagogical building blocks piled on one another in what I regard as the most helpful order. At the same time, I have tried to confine myself to the essentials. Swift is not a big language, but it has some subtle and unusual corners that you probably donâ€™t need to know about.
Also, I never mention Swift playgrounds<a data-type="indexterm" data-primary="playgrounds" id="calibre_link-1697" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> or the REPL<a data-type="indexterm" data-primary="REPL" id="calibre_link-1897" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. My focus here is real-life iOS programming, and my explanation of Swift concentrates on the practical aspects of the language that actually come into play in the course of programming iOS.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-2539" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Part&nbsp;II</a> turns to Xcode, the world in which all iOS programming ultimately takes place. It explains what an Xcode project is and how it is transformed into an app, and how to work comfortably and nimbly with Xcode to consult the documentation and to write, navigate, and debug code, as well as how to bring your app through the subsequent stages of running on a device and submission to the App Store. There is also a chapter on nibs and the nib editor (Interface Builder), including outlets and actions as well as the mechanics of nib loading (but such specialized topics as autolayout constraints in the nib are postponed to the other book).</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-2638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Part&nbsp;III</a> introduces the Cocoa Touch framework. The Foundation and UIKit frameworks, and other frameworks that they entail, constitute Cocoa, which provides the underlying functionality that any iOS app needs to have. To use a framework effectively, you have to think the way the framework thinks, put your code where the framework expects it, and fulfill many obligations imposed on you by the framework. Also, Cocoa uses Objective-C, so you need to know how your Swift code will interface with Cocoaâ€™s features and behaviors. Cocoa provides important foundational classes and adds linguistic and architectural devices such as categories, protocols, delegation, and notifications, as well as the pervasive responsibilities of memory management. Key&ndash;value coding and key&ndash;value observing are also discussed here.</p>

<p class="calibre17">The last chapter of <a data-type="xref" href="#calibre_link-2638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Part&nbsp;III</a> is about the general problem of how objects can refer to one another in an iOS program. In addition to the traditional Cocoa-based solutions, I also discuss the new Swift Combine framework. Also, in June of 2019, Apple introduced SwiftUI<a data-type="indexterm" data-primary="SwiftUI" id="calibre_link-2174" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. It constitutes an alternative to UIKit and Cocoa, with a completely different programming paradigm for constructing apps. I do not teach SwiftUI in this book &mdash; that would require another entire book &mdash; but I do explain its chief linguistic features, and I talk about its solutions to the problem of communicating between objects within an iOS app and how they differ from Cocoa patterns.</p>
</li>
</ul>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="From the Programming iOS 4 Preface" class="calibre2"><div class="preface" id="calibre_link-2385">
<h1 class="calibre18">From the Programming iOS 4 Preface</h1>

<p class="author1">The popularity of the iPhone, with its largely free or very inexpensive apps, and the subsequent popularity of the iPad, have brought and will continue to bring into the fold many new programmers who see programming for these devices as worthwhile and doable, even though they may not have felt the same way about OS X. Appleâ€™s own annual WWDC developer conventions have reflected this trend, with their emphasis shifted from OS X to iOS instruction.</p>

<p class="author1">The widespread eagerness to program iOS, however, though delightful on the one hand, has also fostered a certain tendency to try to run without first learning to walk. iOS gives the programmer mighty powers that can seem as limitless as imagination itself, but it also has fundamentals. I often see questions online from programmers who are evidently deep into the creation of some interesting app, but who are stymied in a way that reveals quite clearly that they are unfamiliar with the basics of the very world in which they are so happily cavorting.</p>

<p class="author1">It is this state of affairs that has motivated me to write this book, which is intended to ground the reader in the fundamentals of iOS.
Here I have attempted to marshal and expound, in what I hope is a pedagogically helpful and instructive yet ruthlessly Euclidean and logical order, the principles and elements on which sound iOS programming rests. My hope, as with my previous books, is that you will both read this book cover to cover (learning something new often enough to keep you turning the pages) and keep it by you as a handy reference.</p>

<p class="author1">This book is not intended to disparage Appleâ€™s own documentation and example projects. They are wonderful resources and have become more wonderful as time goes on. I have depended heavily on them in the preparation of this book. But I also find that they donâ€™t fulfill the same function as a reasoned, ordered presentation of the facts. The online documentation must make assumptions as to how much you already know; it canâ€™t guarantee that youâ€™ll approach it in a given order. And online documentation is more suitable to reference than to instruction. A fully written example, no matter how well commented, is difficult to follow; it demonstrates, but it does not teach.</p>

<p class="author1">A book, on the other hand, has numbered chapters and sequential pages; I can assume you know views before you know view controllers for the simple reason that Part I precedes Part II. And along with facts, I also bring to the table a degree of experience, which I try to communicate to you. Throughout this book youâ€™ll find me referring to â€œcommon beginner mistakesâ€; in most cases, these are mistakes that I have made myself, in addition to seeing others make them. I try to tell you what the pitfalls are because I assume that, in the course of things, you will otherwise fall into them just as naturally as I did as I was learning. Youâ€™ll also see me construct many examples piece by piece or extract and explain just one tiny portion of a larger app. It is not a massive finished program that teaches programming, but an exposition of the thought process that developed that program. It is this thought process, more than anything else, that I hope you will gain from reading this book.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Versions" class="calibre2"><div class="preface" id="calibre_link-2386">
<h1 class="calibre18">Versions</h1>

<p class="author1">This book is geared to Swift 5.1, iOS 13, and Xcode 11.</p>

<p class="author1">In general, only very minimal attention is given to earlier versions of iOS and Xcode. Earlier versions can be very different from the current version, and it would be impossible to go into detail about all that has changed over the years. Besides, that information is readily and compendiously available in my earlier books. Recent innovations are called out clearly. The book does contain some advice about backward compatibility (especially in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>).</p>

<p class="author1">I generally give method names in Swift, in the style of a function reference (as described in <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>) &mdash; that is, the name plus parentheses containing the parameter labels followed by colon. Now and then, if a method is already under discussion and there is no ambiguity, Iâ€™ll use the bare name. In a few places, such as <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>, where the Objective-C language is explicitly under discussion, I use Objective-C method names.</p>

<p class="author1">I have tried to keep my code up-to-date right up to the moment when the manuscript left my hands; but if, at some future time, a new version of Xcode is released along with a new version of Swift, some of the code in this book, and even some information about Swift itself, might be slightly incorrect. Please make allowances, and be prepared to compensate.</p>

<p class="author1">Screenshots of Xcode were taken using Xcode 11 under macOS 10.14 Mojave. The interface on 10.15 Catalina is slightly different from the screenshots (especially if youâ€™re using â€œdark modeâ€), but this difference will be minimal and shouldnâ€™t cause any confusion.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Acknowledgments" class="calibre2"><div class="preface" id="calibre_link-2387">
<h1 class="calibre18">Acknowledgments</h1>

<p class="author1">My thanks go first and foremost to the people at Oâ€™Reilly Media who have made writing a book so delightfully easy: Rachel Roumeliotis, Sarah Schneider, Kristen Brown, Dan Fauxsmith, Adam Witwer, and Sanders Kleinfeld come particularly to mind. And letâ€™s not forget my first and long-standing editor, Brian Jepson, whose influence is present throughout.</p>

<p class="author1">As in the past, I have been greatly aided by some fantastic software, whose excellences I have appreciated at every moment of the process of writing this book. I should like to mention, in particular:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">git (<a href="http://git-scm.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://git-scm.com</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">Sourcetree (<a href="http://www.sourcetreeapp.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.sourcetreeapp.com</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">TextMate (<a href="http://macromates.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://macromates.com</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">AsciiDoc (<a href="http://www.methods.co.nz/asciidoc" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.methods.co.nz/asciidoc</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">Asciidoctor (<a href="http://asciidoctor.org" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://asciidoctor.org</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">BBEdit (<a href="http://barebones.com/products/bbedit" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://barebones.com/products/bbedit</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">EasyFind (<a href="https://www.devontechnologies.com/support/download" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://www.devontechnologies.com/support/download</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">Snapz Pro X (<a href="http://www.ambrosiasw.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.ambrosiasw.com</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">GraphicConverter (<a href="http://www.lemkesoft.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.lemkesoft.com</em></a>)</p>
</li>
<li class="calibre12">
<p class="calibre17">OmniGraffle (<a href="http://www.omnigroup.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.omnigroup.com</em></a>)</p>
</li>
</ul>

<p class="author1">The book was typed and edited entirely on my faithful Unicomp Model M keyboard (<a href="http://pckeyboard.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://pckeyboard.com</em></a>), without which I could never have done so much writing over so long a period so painlessly. For more about my physical work environment, see <a href="http://matt.neuburg.usesthis.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://matt.neuburg.usesthis.com</em></a>.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Conventions Used in This Book" class="calibre2"><div class="preface" id="calibre_link-2388">
<h1 class="calibre18">Conventions Used in This Book</h1>

<p class="author1">The following typographical conventions are used in this book:</p>
<dl class="calibre14">
<dt class="calibre15"><em class="calibre11">Italic</em></dt>
<dd class="calibre16">
<p class="calibre17">Indicates new terms, URLs, email addresses, filenames, and file extensions.</p>
</dd>
<dt class="calibre15"><code class="calibre19">Constant width</code></dt>
<dd class="calibre16">
<p class="calibre17">Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</p>
</dd>
<dt class="calibre15"><strong class="calibre20"><code class="calibre21">Constant width bold</code></strong></dt>
<dd class="calibre16">
<p class="calibre17">Shows commands or other text that should be typed literally by the user.</p>
</dd>
<dt class="calibre15"><em class="calibre11"><code class="calibre22">Constant width italic</code></em></dt>
<dd class="calibre16">
<p class="calibre17">Shows text that should be replaced with user-supplied values or by values determined by context.</p>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">This element signifies a tip or suggestion.</p>
</div>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">This element signifies a general note.</p>
</div>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">This element indicates a warning or caution.</p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Using Code Examples" class="calibre2"><div class="preface" id="calibre_link-2389">
<h1 class="calibre18">Using Code Examples</h1>

<p class="author1">Supplemental material (code examples, exercises, etc.) is available for download at <a href="http://github.com/mattneub/Programming-iOS-Book-Examples" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://github.com/mattneub/Programming-iOS-Book-Examples</em></a>.</p>

<p class="author1">This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless youâ€™re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from Oâ€™Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your productâ€™s documentation does require permission.</p>

<p class="author1">We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: â€œ<em class="calibre11">iOS 13 Programming Fundamentals with Swift</em> by Matt Neuburg
(Oâ€™Reilly). Copyright 2019 Matt Neuburg, 978-1-492-07453-3.â€</p>

<p class="author1">If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a href="mailto:permissions@oreilly.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">permissions@oreilly.com</em></a>.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Oâ€™Reilly Online Learning" class="calibre2"><div class="preface" id="calibre_link-2390">
<h1 class="calibre18">Oâ€™Reilly Online Learning</h1>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">For almost 40 years, <a href="http://oreilly.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">Oâ€™Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</p>
</div>

<p class="author1">Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform. Oâ€™Reillyâ€™s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from Oâ€™Reilly and 200+ other publishers. For more information, please visit <a href="http://oreilly.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://oreilly.com</em></a>.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="How to Contact Us" class="calibre2"><div class="preface" id="calibre_link-2391">
<h1 class="calibre18">How to Contact Us</h1>

<p class="author1">Please address comments and questions concerning this book to the publisher:</p>
<ul class="stafflist">
  <li class="calibre12">Oâ€™Reilly Media, Inc.</li>
  <li class="calibre12">1005 Gravenstein Highway North</li>
  <li class="calibre12">Sebastopol, CA 95472</li>
  <li class="calibre12">800-998-9938 (in the United States or Canada)</li>
  <li class="calibre12">707-829-0515 (international or local)</li>
  <li class="calibre12">707-829-0104 (fax)</li>
</ul>

<p class="author1">We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a href="http://bit.ly/ios13-prog-fundamentals" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://bit.ly/ios13-prog-fundamentals</em></a>.</p>

<p class="author1">To comment or ask technical questions about this book, send email to <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" href="mailto:bookquestions@oreilly.com"><em class="calibre11">bookquestions@oreilly.com</em></a>.</p>

<p class="author1">For more information about our books, courses, conferences, and news, see our website at <a href="http://www.oreilly.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.oreilly.com</em></a>.</p>

<p class="author1">Find us on Facebook: <a href="http://facebook.com/oreilly" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://facebook.com/oreilly</em></a></p>

<p class="author1">Follow us on Twitter: <a href="http://twitter.com/oreillymedia" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://twitter.com/oreillymedia</em></a></p>

<p class="author1">Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.youtube.com/oreillymedia</em></a></p>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2737">
<div id="calibre_link-2896" class="calibre1"><div data-type="part" {http://www.idpf.org/2007/ops}type="part" class="preface" data-pdf-bookmark="Part I. Language" id="calibre_link-2392">
<h1 class="calibre27"><span class="label">Part I. </span>Language</h1>

<div class="preface">
<p class="author1">This part of the book teaches the Swift language, from the ground up. The description is rigorous and orderly. Here youâ€™ll become sufficiently conversant with Swift to be comfortable with it, so that you can proceed to the practical business of actual <span class="publishername">programming</span>.</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a> surveys the structure of a Swift program, both physically and conceptually. Youâ€™ll learn how Swift code files are organized, and youâ€™ll be introduced to the most important underlying concepts of the object-oriented Swift language: variables and functions, scopes and namespaces, object types and their instances.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a> explores Swift functions. We start with the basics of how functions are declared and called; then we discuss parameters &mdash; external parameter names, default parameters, and variadic parameters. Then we dive deep into the power of Swift functions, with an explanation of functions inside functions, functions as first-class values, anonymous functions, functions as closures, curried functions, and function references and selectors.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a> starts with Swift variables &mdash; their scope and lifetime, and how they are declared and initialized, along with features such as computed variables and setter observers. Then some important built-in Swift types are introduced, including Booleans, numbers, strings, ranges, tuples, and Optionals.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> is all about Swift object types &mdash; classes, structs, and enums. It explains how these three object types work, and how you declare, instantiate, and use them. Then it proceeds to polymorphism and casting, protocols, generics, and extensions. The chapter concludes with a discussion of Swiftâ€™s umbrella types, such as Any and AnyObject, and collection types &mdash; Array, Dictionary, and Set (including option sets).</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> is a miscellany. We start with Swiftâ€™s flow control structures for branching, looping, and jumping, including error handling. Then I describe Swift access control (privacy), introspection (reflection), and how to create your own operators. Next I talk about Swift memory management. The chapter ends with a survey of some recently added Swift language features: synthesized protocol implementations, key paths, dynamic members, property wrappers, custom string interpolation, reverse generics, function builders, and Result.</p>
</li>
</ul>
</div>











































































</div>
</div>
</div>


<div class="calibre" id="calibre_link-2745">
<div id="calibre_link-2897" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 1. The Architecture of Swift" class="calibre2"><div class="preface" id="calibre_link-2393">
<h1 class="calibre13"><span class="label">Chapter 1. </span>The Architecture of Swift</h1>


<p class="author1">It will be useful at the outset for you to have a general sense of how the Swift language is constructed and what a Swift-based iOS program looks like. This chapter will survey the overall architecture and nature of the Swift language. Subsequent chapters will fill in the details.<a data-type="indexterm" data-primary="Swift" id="calibre_link-2168" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Ground of Being" class="calibre2"><div class="preface" id="calibre_link-2394">
<h1 class="calibre18">Ground of Being</h1>

<p class="author1">A complete Swift command is a <em class="calibre11">statement</em>. A Swift text file consists of multiple <em class="calibre11">lines</em> of text. Line breaks are meaningful. The typical layout of a program is one statement, one line:<a data-type="indexterm" data-primary="statement" id="calibre_link-2067" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="line" id="calibre_link-1230" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">print("hello")
print("world")</pre>

<p class="author1">(The <code class="calibre19">print</code> command provides instant feedback in the Xcode console.)<a data-type="indexterm" data-primary="print" data-seealso="logging" id="calibre_link-1721" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can combine more than one statement on a line, but then you need to put a <span class="publishername">semicolon</span> between them:<a data-type="indexterm" data-primary="semicolon" id="calibre_link-1989" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">print("hello"); print("world")</pre>

<p class="author1">You are free to put a semicolon at the end of a statement that is last or alone on its line, but no one ever does (except out of habit, because C and Objective-C <em class="calibre11">require</em> the semicolon):</p>

<pre data-type="programlisting" class="calibre28">print("hello");
print("world");</pre>

<p class="author1">Conversely, a single statement can be broken into multiple lines, to prevent long statements from becoming long lines. But you should try to do this at sensible places so as not to confuse Swift. For example, after an opening parenthesis is a good place:</p>

<pre data-type="programlisting" class="calibre28">print(
    "world")</pre>

<p class="author1">Comments are everything after two slashes in a line (so-called C++-style comments):<a data-type="indexterm" data-primary="comments" id="calibre_link-484" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">print("world") // this is a comment, so Swift ignores it</pre>

<p class="author1">You can also enclose comments in <code class="calibre19">/*...*/</code>, as in C. Unlike C, C-style comments can be nested.</p>

<p class="author1">Many constructs in Swift use curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-579" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> as delimiters:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        print("woof")
    }
}</pre>

<p class="author1">By convention, the contents of curly braces are preceded and followed by line breaks and are indented for clarity, as shown in the preceding code. Xcode will help impose this convention, but the truth is that Swift doesnâ€™t care, and layouts like this are legal (and are sometimes more convenient):</p>

<pre data-type="programlisting" class="calibre28">class Dog { func bark() { print("woof") }}</pre>

<p class="author1">Swift is a <em class="calibre11">compiled</em> language. This means that your code must <em class="calibre11">build</em> &mdash; passing through the compiler and being turned from text into some lower-level form that a computer can understand &mdash; before it can <em class="calibre11">run</em> and actually do the things it says to do. The Swift compiler is very strict; in the course of writing a program, you will often try to build and run, only to discover that you canâ€™t even build in the first place, because the compiler will flag some <em class="calibre11">error</em>, which you will have to fix if you want the code to run. Less often, the compiler will let you off with a <em class="calibre11">warning</em>; the code can run, but in general you should take warnings seriously and fix whatever they are telling you about. The strictness of the compiler is one of Swiftâ€™s greatest strengths, and provides your code with a large measure of audited correctness even before it ever runs.<a data-type="indexterm" data-primary="compiler" id="calibre_link-497" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="compile error" id="calibre_link-495" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" id="calibre_link-787" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="warnings, compiler" id="calibre_link-2360" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The Swift compilerâ€™s error and warning messages range from the insightful to the obtuse to the downright misleading. You will sometimes know that <em class="calibre11">something</em> is wrong with a line of code, but the Swift compiler will not be telling you clearly exactly <em class="calibre11">what</em> is wrong or even <em class="calibre11">where</em> in the line to focus your attention. My advice in these situations is to pull the line apart into several lines of simpler code until you reach a point where you can guess what the issue is. Try to love the compiler despite the occasional unhelpful nature of its messages. Remember, it knows more than you do, even if it is sometimes rather inarticulate about its knowledge.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Everything Is an Object?" class="calibre2"><div class="preface" id="calibre_link-2395">
<h1 class="calibre18">Everything Is an Object?</h1>

<p class="author1">In Swift, â€œeverything is an object.â€ Thatâ€™s a boast common to various modern object-oriented languages, but what does it mean? Well, that depends on what you mean by â€œobjectâ€ &mdash; and what you mean by â€œeverything.â€<a data-type="indexterm" data-primary="objects" data-seealso="object types" id="calibre_link-1548" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Letâ€™s start by stipulating that an object, roughly speaking, is something you can send a message to. A message, roughly speaking, is an imperative instruction. For example, you can give commands to a dog: â€œBark!â€ â€œSit!â€ In this analogy, those phrases are messages, and the dog is the object to which you are sending those messages.<a data-type="indexterm" data-primary="messages" id="calibre_link-1323" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In Swift, the syntax of message-sending is <em class="calibre11">dot-notation</em>. We start with the object; then thereâ€™s a dot (a period); then thereâ€™s the message. (Some messages are also followed by parentheses, but ignore them for now; the full syntax of message-sending is one of those details weâ€™ll be filling in later.) This is valid Swift syntax:<a data-type="indexterm" data-primary="dot-notation" id="calibre_link-703" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">fido.bark()
rover.sit()</pre>

<p class="author1">By the way, a dot is also another good place to break up a long line (<em class="calibre11">before</em> the dot):</p>

<pre data-type="programlisting" class="calibre28">fido
    .bark()</pre>

<p class="author1">The idea of <em class="calibre11">everything</em> being an object is a way of suggesting that even â€œprimitiveâ€ linguistic entities can be sent messages. Take, for example, <code class="calibre19">1</code>. It appears to be a literal digit and no more. It will not surprise you, if youâ€™ve ever used any programming language, that you can say things like this in Swift:</p>

<pre data-type="programlisting" class="calibre28">let sum = 1 + 2</pre>

<p class="author1">But it <em class="calibre11">is</em> surprising to find that <code class="calibre19">1</code> can be followed by a dot and a message. This is legal and meaningful in Swift (donâ€™t worry about what it actually means):</p>

<pre data-type="programlisting" class="calibre28">let s = 1.description</pre>

<p class="author1">But we can go further. Return to that innocent-looking <code class="calibre19">1 + 2</code> from our earlier code. It turns out that this is actually a kind of syntactic trickery, a convenient way of expressing and hiding whatâ€™s really going on. Just as <code class="calibre19">1</code> is actually an object, <code class="calibre19">+</code> is actually a message; but itâ€™s a message with special syntax (<em class="calibre11">operator</em> syntax). In Swift, every noun is an object, and every verb is a message.<a data-type="indexterm" data-primary="operator syntax" id="calibre_link-1557" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Perhaps the ultimate acid test for whether something is an object in Swift is whether you can modify it. An object type can be <em class="calibre11">extended</em> in Swift, meaning that you can define your own messages on that type. For example, you canâ€™t normally send the <code class="calibre19">sayHello</code> message to a number. But you can change a number type so that you can:</p>

<pre data-type="programlisting" class="calibre28">extension Int {
    func sayHello() {
        print("Hello, I'm \(self)")
    }
}
1.sayHello() // outputs: "Hello, I'm 1"</pre>

<p class="author1">In Swift, then, <code class="calibre19">1</code> is an object. In some languages, such as Objective-C, it clearly is not; it is a â€œprimitiveâ€ or <em class="calibre11">scalar</em> built-in data type. So the distinction being drawn here is between object types on the one hand and scalars on the other. In Swift, there are no scalars; <em class="calibre11">all</em> types are ultimately object types. Thatâ€™s what â€œeverything is an objectâ€ really means.<a data-type="indexterm" data-primary="scalars" id="calibre_link-1944" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Three Flavors of Object Type" class="calibre2"><div class="preface" id="calibre_link-2396">
<h1 class="calibre18">Three Flavors of Object Type</h1>

<p class="author1">If you know Objective-C or some other object-oriented language, you may be surprised by Swiftâ€™s notion of what <em class="calibre11">kind</em> of object <code class="calibre19">1</code> is. In many languages, such as Objective-C, an object is a <em class="calibre11">class</em> or an instance of a class (Iâ€™ll explain later what an instance is). Swift has classes, but <code class="calibre19">1</code> in Swift is not a class or an instance of a class: the type of <code class="calibre19">1</code>, namely Int, is a <em class="calibre11">struct</em>, and <code class="calibre19">1</code> is an instance of a struct. And Swift has yet another kind of thing you can send messages to, called an <em class="calibre11">enum</em>.<a data-type="indexterm" data-primary="flavors (of object type)" id="calibre_link-871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="flavors" id="calibre_link-1493" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So Swift has three kinds of object type: classes, structs, and enums. I like to refer to these as the three <em class="calibre11">flavors</em> of object type. Exactly how they differ from one another will emerge in due course. But they are all very definitely object types, and their similarities to one another are far stronger than their differences. For now, just bear in mind that these three flavors exist.</p>

<p class="author1">(The fact that a struct or enum is an object type in Swift will surprise you particularly if you know Objective-C. Objective-C has structs and enums, but they are not objects. Swift structs, in particular, are much more important and pervasive than Objective-C structs. This difference between how Swift views structs and enums and how Objective-C views them can matter when you are talking to Cocoa.)</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Variables" class="calibre2"><div class="preface" id="calibre_link-2397">
<h1 class="calibre18">Variables</h1>

<p class="author1">A variable is a <em class="calibre11">name</em> for an object. Technically, it <em class="calibre11">refers</em> to an object; it is an object <em class="calibre11">reference</em>. Nontechnically, you can think of it as a shoebox into which an object is placed. The object may undergo changes, or it may be replaced inside the shoebox by another object, but the name has an integrity all its own. The object to which the variable refers is the variableâ€™s <em class="calibre11">value</em>.<a data-type="indexterm" data-primary="variables" id="calibre_link-2315" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="reference" id="calibre_link-1861" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In Swift, no variable comes implicitly into existence; all variables must be <em class="calibre11">declared</em>. If you need a name for something, you must say â€œIâ€™m creating a name.â€ You do this with one of two keywords: <code class="calibre19">let</code> or <code class="calibre19">var</code>. In Swift, declaration is usually accompanied by <em class="calibre11">initialization</em> &mdash; you use an equal sign to give the variable a value immediately, as part of the declaration. These are both variable declarations (and initializations):<a data-type="indexterm" data-primary="initialization" id="calibre_link-1071" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="declaration" id="calibre_link-2320" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="initialization" id="calibre_link-2327" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let one = 1
var two = 2</pre>

<p class="author1">Once the name exists, you are free to use it. For example, we can change the value of <code class="calibre19">two</code> to be the same as the value of <code class="calibre19">one</code>:</p>

<pre data-type="programlisting" class="calibre28">let one = 1
var two = 2
two = one</pre>

<p class="author1">The last line of that code uses both the name <code class="calibre19">one</code> and the name <code class="calibre19">two</code> declared in the first two lines: the name <code class="calibre19">one</code>, on the right side of the equal sign, is used merely to <em class="calibre11">refer</em> to the value inside the shoebox <code class="calibre19">one</code> (namely <code class="calibre19">1</code>); but the name <code class="calibre19">two</code>, on the left side of the equal sign, is used to <em class="calibre11">replace</em> the value inside the shoebox <code class="calibre19">two</code>. Before saying <code class="calibre19">two = one</code>, the value of <code class="calibre19">two</code> was <code class="calibre19">2</code>; afterward, it is <code class="calibre19">1</code>.</p>

<p class="author1">A statement with a variable name on the left side of an equal sign is called an <em class="calibre11">assignment</em>, and the equal sign is the <em class="calibre11">assignment operator</em>. The equal sign is not an assertion of equality, as it might be in an algebraic formula; it is a command. It means: â€œGet the value of whatâ€™s on the right side of me, and use it to replace the value of whatâ€™s on the left side of me.â€<a data-type="indexterm" data-primary="assignment" id="calibre_link-217" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="equal sign" id="calibre_link-769" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The two kinds of variable declaration differ in that a name declared with <code class="calibre19">let</code> <em class="calibre11">cannot have its initial value replaced</em>. A variable declared with <code class="calibre19">let</code> is a <em class="calibre11">constant</em>; its value is assigned once and stays. This wonâ€™t even compile:<a data-type="indexterm" data-primary="constants" id="calibre_link-538" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="let" id="calibre_link-1220" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="var" id="calibre_link-2312" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let one = 1
var two = 2
one = two // compile error</pre>

<p class="author1">It is always possible to declare a name with <code class="calibre19">var</code> to give yourself the most flexibility, but if you know youâ€™re never going to replace the initial value of a variable, itâ€™s better to use <code class="calibre19">let</code>, as this permits Swift to behave more efficiently &mdash; in fact, the Swift compiler will call your attention to any case of your using <code class="calibre19">var</code> where you could have used <code class="calibre19">let</code>, offering to change it for you.</p>

<p class="author1">Variables also have a <em class="calibre11">type</em>. This type is established when the variable is declared and <em class="calibre11">can never change</em>. For example, this wonâ€™t compile:<a data-type="indexterm" data-primary="variables" data-secondary="type" id="calibre_link-2338" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="of variable" id="calibre_link-2238" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var two = 2
two = "hello" // compile error</pre>

<p class="author1">Once <code class="calibre19">two</code> is declared and initialized as <code class="calibre19">2</code>, it is a number (properly speaking, an Int) and it must always be so. You can replace its value with <code class="calibre19">1</code> because thatâ€™s also an Int, but you canâ€™t replace its value with <code class="calibre19">"hello"</code> because thatâ€™s a string (properly speaking, a String) &mdash; and a String is not an Int.</p>

<p class="author1">Variables literally have a life of their own &mdash; more accurately, a <em class="calibre11">lifetime</em> of their own. As long as a variable exists, it keeps its value alive. Thus, a variable can be not only a way of conveniently <em class="calibre11">naming</em> something, but also a way of <em class="calibre11">preserving</em> it. Iâ€™ll have more to say about that later.<a data-type="indexterm" data-primary="lifetime" id="calibre_link-1225" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="lifetime" id="calibre_link-2330" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">By convention, type names such as String or Int (or Dog) start with a capital letter; variable names start with a small letter. <em class="calibre11">Do not violate this convention.</em> If you do, your code might still compile and run just fine, but I will personally send agents to your house to remove your kneecaps in the dead of night.<a data-type="indexterm" data-primary="capitalization" id="calibre_link-335" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Functions" class="calibre2"><div class="preface" id="calibre_link-2398">
<h1 class="calibre18">Functions</h1>

<p class="author1">Executable code, like <code class="calibre19">fido.bark()</code> or <code class="calibre19">one = two</code> or <code class="calibre19">print("hello")</code>, cannot go just anywhere in your program. Failure to appreciate this fact is a common beginner mistake, and can result in a mysterious compile error message such as â€œExpected declaration.â€</p>

<p class="author1">In general, executable code must live inside the body of a <em class="calibre11">function</em>. A function is a batch of code that can be told, as a batch, to run. Its body is delimited by curly braces. Typically, a function has a name, and it gets that name through a function declaration. Function declaration syntax is another of those details that will be filled in later, but hereâ€™s an example:<a data-type="indexterm" data-primary="code" data-secondary="location" id="calibre_link-435" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" id="calibre_link-898" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="declaration" id="calibre_link-911" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="expected declaration" id="calibre_link-793" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="expressions are not allowed" id="calibre_link-794" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func go() {
    let one = 1
    var two = 2
    two = one
}</pre>

<p class="author1">That describes a sequence of things to do &mdash; declare <code class="calibre19">one</code>, declare <code class="calibre19">two</code>, change the value of <code class="calibre19">two</code> to match the value of <code class="calibre19">one</code> &mdash; and it gives that sequence a <em class="calibre11">name</em>, <code class="calibre19">go</code>; but it doesnâ€™t <em class="calibre11">perform</em> the sequence. The sequence is performed when someone <em class="calibre11">calls</em> the function. Thus, we might say, elsewhere:<a data-type="indexterm" data-primary="calling a function" id="calibre_link-330" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="calling" id="calibre_link-907" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">go()</pre>

<p class="author1">That is a command to the <code class="calibre19">go</code> function that it should actually run. But again, that command is itself executable code, so it cannot live on its own either. It might live in the body of a different function:</p>

<pre data-type="programlisting" class="calibre28">func doGo() {
    go()
}</pre>

<p class="author1">But wait! This is getting a little nutty. That, too, is just a function declaration; to run it, someone must call <code class="calibre19">doGo</code> by saying <code class="calibre19">doGo()</code> &mdash; and thatâ€™s executable code too. This seems like some kind of infinite regression; it looks like none of our code will <em class="calibre11">ever</em> run. If all executable code has to live in a function, who will tell <em class="calibre11">any</em> function to run? The initial impetus must come from somewhere.</p>

<p class="author1">In real life, fortunately, this regression problem doesnâ€™t arise. Remember that your goal is ultimately to write an iOS app. Thus, your app will be run on an iOS device (or the Simulator) by a runtime that already wants to call certain functions. So you start by writing special functions that you know the runtime itself will call. That gives your app a way to get started and gives you places to put functions that will be called by the runtime at key moments.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Swift also has a special rule that a file called <em class="calibre11">main.swift</em>, exceptionally, <em class="calibre11">can</em> have executable code at its top level, outside any function body, and this is the code that actually runs when the program runs. You can construct your app with a <em class="calibre11">main.swift</em> file, but in general you wonâ€™t need to. In the rest of this chapter Iâ€™ll assume that we are not in a <em class="calibre11">main.swift</em> file.<a data-type="indexterm" data-primary="main.swift file" id="calibre_link-1261" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Structure of a Swift File" class="calibre2"><div class="preface" id="calibre_link-2399">
<h1 class="calibre18">The Structure of a Swift File</h1>

<p class="author1">A Swift program can consist of one file or many files. In Swift, a file is a meaningful unit, and there are definite rules about the structure of the Swift code that can go inside it. Only certain things can go at the top level of a Swift file &mdash; chiefly the following:<a data-type="indexterm" data-primary="file, Swift, structure" id="calibre_link-852" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="top level" id="calibre_link-2219" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Module <code class="calibre19">import</code> statements</dt>
<dd class="calibre16">
<p class="calibre17">A module is an even higher-level unit than a file. A module can consist of multiple files, and these can all see each other automatically. Your appâ€™s files belong to a single module and can see each other. But a module canâ€™t see another module without an <code class="calibre19">import</code> statement. For example, that is how you are able to talk to Cocoa in an iOS program: the first line of your file says <code class="calibre19">import UIKit</code>.<a data-type="indexterm" data-primary="modules" id="calibre_link-1359" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="import statement" id="calibre_link-1046" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Variable declarations</dt>
<dd class="calibre16">
<p class="calibre17">A variable declared at the top level of a file is a <em class="calibre11">global</em> variable: all code in any file will be able to see and access it, without explicitly sending a message to any object.<a data-type="indexterm" data-primary="global variables" id="calibre_link-980" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="global" id="calibre_link-2324" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Function declarations</dt>
<dd class="calibre16">
<p class="calibre17">A function declared at the top level of a file is a <em class="calibre11">global</em> function: all code in any file will be able to see and call it, without explicitly sending a message to any object.<a data-type="indexterm" data-primary="global functions" id="calibre_link-976" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="global" id="calibre_link-917" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Object type declarations</dt>
<dd class="calibre16">
<p class="calibre17">The declaration for a class, a struct, or an enum.</p>
</dd>
</dl>

<p class="author1">For example, this is a legal Swift file containing at its top level (just to demonstrate that it can be done) an <code class="calibre19">import</code> statement, a variable declaration, a function declaration, a class declaration, a struct declaration, and an enum declaration:</p>

<pre data-type="programlisting" class="calibre28">import UIKit
var one = 1
func changeOne() {
}
class Manny {
}
struct Moe {
}
enum Jack {
}</pre>

<p class="author1">Thatâ€™s a very silly and mostly empty example, but remember, our goal is to survey the parts of the language and the structure of a file, and the example shows them.</p>

<p class="author1">So much for the top level of a file. But now letâ€™s talk about what can go inside the curly braces that we see in our example. It turns out that they, too, can all have variable declarations, function declarations, and object type declarations within them! Indeed, <em class="calibre11">any</em> structural curly braces can contain such declarations.</p>

<p class="author1">But what about executable code? Youâ€™ll notice that I did <em class="calibre11">not</em> say that executable code can go at the top level of a file. Thatâ€™s because it canâ€™t! <em class="calibre11">Only a function body can contain executable code.</em> A statement like <code class="calibre19">one = two</code> or <code class="calibre19">print("hello")</code> is executable code, and canâ€™t go at the top level of a file. But in our previous example, <code class="calibre19">func changeOne()</code> is a function declaration, so executable code <em class="calibre11">can</em> go inside its curly braces, because they constitute a function body:</p>

<pre data-type="programlisting" class="calibre28">var one = 1
// executable code can't go here!
func changeOne() {
    let two = 2 // executable code
    one = two   // executable code
}</pre>

<p class="author1">Similarly, executable code canâ€™t go directly inside the curly braces that accompany the <code class="calibre19">class Manny</code> declaration; thatâ€™s the top level of a class declaration, not a function body. But a class declaration can contain a function declaration, and that function declaration <em class="calibre11">can</em> contain executable code:</p>

<pre data-type="programlisting" class="calibre28">class Manny {
    let name = "manny"
    // executable code can't go here!
    func sayName() {
        print(name) // executable code
    }
}</pre>

<p class="author1">To sum up, <a data-type="xref" href="#calibre_link-2746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;1-1</a> is a legal Swift file, schematically illustrating the structural possibilities. (Ignore the hanky-panky with the <code class="calibre19">name</code> variable declaration inside the enum declaration for Jack; enum top-level variables have some special rules that Iâ€™ll explain later.)</p>
<div id="calibre_link-2746" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 1-1. </span>Schematic structure of a legal Swift file</h5>

<pre data-type="programlisting" class="calibre31">import UIKit
var one = 1
func changeOne() {
    let two = 2
    func sayTwo() {
        print(two)
    }
    class Klass {}
    struct Struct {}
    enum Enum {}
    one = two
}
class Manny {
    let name = "manny"
    func sayName() {
        print(name)
    }
    class Klass {}
    struct Struct {}
    enum Enum {}
}
struct Moe {
    let name = "moe"
    func sayName() {
        print(name)
    }
    class Klass {}
    struct Struct {}
    enum Enum {}
}
enum Jack {
    var name : String {
        return "jack"
    }
    func sayName() {
        print(name)
    }
    class Klass {}
    struct Struct {}
    enum Enum {}
}</pre>
</div>

<p class="author1">Obviously, we can recurse down as far we like: we could have a class declaration containing a class declaration containing a class declaration, and so on. But Iâ€™m sure you have the idea by now, so thereâ€™s no point illustrating further.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Scope and Lifetime" class="calibre2"><div class="preface" id="calibre_link-2400">
<h1 class="calibre18">Scope and Lifetime</h1>

<p class="author1">In a Swift program, things have a <em class="calibre11">scope</em>. This refers to their ability to be seen by other things. Things are nested inside of other things, making a nested hierarchy of things. The rule is that things can see things <em class="calibre11">at their own level and at a higher level containing them</em>. The levels are:<a data-type="indexterm" data-primary="scope" id="calibre_link-1954" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A module is a scope.</p>
</li>
<li class="calibre12">
<p class="calibre17">A file is a scope.</p>
</li>
<li class="calibre12">
<p class="calibre17">Curly braces are a scope.</p>
</li>
</ul>

<p class="author1">When something is declared, it is declared at some level within that hierarchy. Its place in the hierarchy &mdash; its scope &mdash; determines whether it can be seen by other things.<a data-type="indexterm" data-primary="visibility" data-see="scope" id="calibre_link-2898" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Look again at <a data-type="xref" href="#calibre_link-2746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;1-1</a>. Inside the declaration of Manny is a <code class="calibre19">name</code> variable declaration and a <code class="calibre19">sayName</code> function declaration; the code <em class="calibre11">inside</em> <code class="calibre19">sayName</code>â€™s curly braces can see things <em class="calibre11">outside</em> those curly braces <em class="calibre11">at a higher containing level</em>, and can therefore see the <code class="calibre19">name</code> variable. Similarly, the code inside the body of the <code class="calibre19">changeOne</code> function can see the <code class="calibre19">one</code> variable declared at the top level of the file; indeed, <em class="calibre11">everything</em> throughout this file can see the <code class="calibre19">one</code> variable declared at the top level of the file.</p>

<p class="author1">Scope is thus a very important way of <em class="calibre11">sharing information</em>. Two different functions declared inside Manny would <em class="calibre11">both</em> be able to see the <code class="calibre19">name</code> declared at Mannyâ€™s top level. Code inside Jack and code inside Moe can <em class="calibre11">both</em> see the <code class="calibre19">one</code> declared at the fileâ€™s top level.</p>

<p class="author1">Things also have a <em class="calibre11">lifetime</em>, which is effectively equivalent to their scope. A thing lives as long as its surrounding scope lives. Thus, in <a data-type="xref" href="#calibre_link-2746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;1-1</a>, the variable <code class="calibre19">one</code> lives as long as the file lives &mdash; namely, as long the program runs. It is global <em class="calibre11">and persistent</em>. But the variable <code class="calibre19">name</code> declared at the top level of Manny exists only so long as a Manny instance exists (Iâ€™ll talk in a moment about what that means).</p>

<p class="author1">Things declared at a deeper level live even shorter lifetimes. Consider this code: <a data-type="indexterm" data-primary="lifetime" data-seealso="scope" id="calibre_link-1226" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func silly() {
    if true {
        class Cat {}
        var one = 1
        one = one + 1
    }
}</pre>

<p class="author1">That code is silly, but itâ€™s legal: remember, I said that variable declarations, function declarations, and object type declarations can appear in <em class="calibre11">any</em> structural curly braces. In that code, the class Cat and the variable <code class="calibre19">one</code> will not even come into existence until someone calls the <code class="calibre19">silly</code> function, and even then they will exist only during the brief instant that the path of code execution passes through the if construct. So, suppose the function <code class="calibre19">silly</code> is called; the path of execution then enters the if construct. Here, Cat is declared and comes into existence; then <code class="calibre19">one</code> is declared and comes into existence; then the executable line <code class="calibre19">one = one + 1</code> is executed; and then the scope ends &mdash; and both Cat and <code class="calibre19">one</code> vanish in a puff of smoke. And throughout their brief lives, Cat and <code class="calibre19">one</code> were completely invisible to the rest of the program. (Do you see why?)</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Object Members" class="calibre2"><div class="preface" id="calibre_link-2401">
<h1 class="calibre18">Object Members</h1>

<p class="author1">Inside the three object types (class, struct, and enum), things declared at the top level have special names, mostly for historical reasons. Letâ€™s use the Manny class as an <span class="publishername">example</span>:</p>

<pre data-type="programlisting" class="calibre28">class Manny {
    let name = "manny"
    func sayName() {
        print(name)
    }
}</pre>

<p class="author1">In that code:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><code class="calibre19">name</code> is a variable declared at the top level of an object declaration, so it is called a <em class="calibre11">property</em> of that object.<a data-type="indexterm" data-primary="properties" id="calibre_link-1740" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">sayName</code> is a function declared at the top level of an object declaration, so it is called a <em class="calibre11">method</em> of that object.<a data-type="indexterm" data-primary="methods" data-seealso="functions" id="calibre_link-1329" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">Things declared at the top level of an object declaration &mdash; properties, methods, and any objects declared at that level &mdash; are collectively the <em class="calibre11">members</em> of that object. Members have a special significance, because they define the <em class="calibre11">messages</em> you are allowed to send to that object!<a data-type="indexterm" data-primary="members" id="calibre_link-1276" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Namespaces" class="calibre2"><div class="preface" id="calibre_link-2402">
<h1 class="calibre18">Namespaces</h1>

<p class="author1">A <em class="calibre11">namespace</em> is a named region of a program. The names of things inside a namespace cannot be reached by things outside it without somehow first passing through the barrier of <em class="calibre11">saying</em> that regionâ€™s name. This is a good thing because it allows the same name to be used in different places without a conflict. Clearly, namespaces and scopes are closely related notions.<a data-type="indexterm" data-primary="namespaces" id="calibre_link-1377" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Namespaces help to explain the significance of declaring an object at the top level of an object, like this:</p>

<pre data-type="programlisting" class="calibre28">class Manny {
    class Klass {}
}</pre>

<p class="author1">This way of declaring Klass makes Klass a <em class="calibre11">nested type</em>. It effectively â€œhidesâ€ Klass inside Manny. Manny is a namespace! Code <em class="calibre11">inside</em> Manny can see (and say) Klass directly. But code outside Manny canâ€™t do that. It has to specify the namespace <em class="calibre11">explicitly</em> in order to pass through the barrier that the namespace represents. To do so, it must say Mannyâ€™s name first, followed by a dot, followed by the term Klass. In short, it has to say <code class="calibre19">Manny.Klass</code>.<a data-type="indexterm" data-primary="nested types" id="calibre_link-1386" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The namespace does not, of itself, provide secrecy or privacy; itâ€™s a convenience. Thus, in <a data-type="xref" href="#calibre_link-2746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;1-1</a>, I gave Manny a Klass class, and I also gave Moe a Klass class. But they donâ€™t conflict, because they are in different namespaces, and I can differentiate them, if necessary, as <code class="calibre19">Manny.Klass</code> and <code class="calibre19">Moe.Klass</code>.</p>

<p class="author1">It will not have escaped your attention that the syntax for diving explicitly into a namespace is the message-sending dot-notation<a data-type="indexterm" data-primary="dot-notation" id="calibre_link-704" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> syntax. They are, in fact, the same thing.</p>

<p class="author1">In effect, message-sending allows you to see into scopes you canâ€™t see into otherwise. Code inside Moe canâ€™t <em class="calibre11">automatically</em> see the Klass declared inside Manny, but it <em class="calibre11">can</em> see it by taking one easy extra step, namely by speaking of <code class="calibre19">Manny.Klass</code>. It can do <em class="calibre11">that</em> because it <em class="calibre11">can</em> see Manny (because Manny is declared at a level that code inside Moe can see).</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Modules" class="calibre2"><div class="preface" id="calibre_link-2403">
<h1 class="calibre18">Modules</h1>

<p class="author1">The top-level namespaces are <em class="calibre11">modules</em>. Your app is a module and hence a namespace; that namespaceâ€™s name is, by default, the name of the app. For example, if my app is called <code class="calibre19">MyApp</code>, then if I declare a class Manny at the top level of a file, that classâ€™s <em class="calibre11">real</em> name is <code class="calibre19">MyApp.Manny</code>. But I donâ€™t usually need to use that real name, because my code is already inside the same namespace, and can see the name <code class="calibre19">Manny</code> directly.<a data-type="indexterm" data-primary="modules" id="calibre_link-1360" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">When you import a module, all the top-level declarations of <em class="calibre11">that</em> module become visible to your code as well, without your having to use the moduleâ€™s namespace explicitly to refer to them. For example, Cocoaâ€™s Foundation framework, where NSString lives, is a module. When you program iOS, you will say <code class="calibre19">import Foundation</code> (or, more likely, youâ€™ll say <code class="calibre19">import UIKit</code>, which itself imports Foundation), thus allowing you to speak of NSString without saying <code class="calibre19">Foundation.NSString</code>. But you <em class="calibre11">could</em> say <code class="calibre19">Foundation.NSString</code>, and if you were so silly as to declare a different NSString in your own module, you would <em class="calibre11">have</em> to say <code class="calibre19">Foundation.NSString</code>, in order to differentiate them.<a data-type="indexterm" data-primary="frameworks" id="calibre_link-889" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Foundation framework" id="calibre_link-887" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swift itself is defined in a module &mdash; the Swift module. But you donâ€™t have to import it, because your code <em class="calibre11">always implicitly imports the Swift module</em>. You could make this explicit by starting a file with the line <code class="calibre19">import Swift</code>; there is no need to do this, but it does no harm either.</p>

<p class="author1">That fact is important, because it solves a major mystery: where do things like <code class="calibre19">print</code> come from, and why is it possible to use them outside of any message to any object? <code class="calibre19">print</code> is in fact a function declared at the top level of the Swift module, and your code can see the Swift moduleâ€™s top-level declarations because it imports Swift. The <code class="calibre19">print</code> function thus becomes, as far as your code is concerned, an ordinary top-level function like any other; it is global to your code, and your code can speak of it without specifying its namespace. You <em class="calibre11">can</em> specify its namespace &mdash; it is perfectly legal to say things like <code class="calibre19">Swift.print("hello")</code> &mdash; but you probably never will, because thereâ€™s no name conflict to resolve, unless you create such a conflict by declaring a competing <code class="calibre19">print</code> function of your own.<a data-type="indexterm" data-primary="global functions" id="calibre_link-977" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="global" id="calibre_link-918" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="top level" data-seealso="global" id="calibre_link-2220" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">You can actually <em class="calibre11">see</em> the Swift top-level declarations and read and study them, and this can be a useful thing to do. For example, to see the declaration of <code class="calibre19">print</code>, Command-Control-click the term <code class="calibre19">print</code> in your code.
Behold, there are some Swift top-level declarations! You wonâ€™t see any executable Swift <em class="calibre11">code</em> here, but you will see the declarations for various available Swift terms, including <code class="calibre19">print</code>.<a data-type="indexterm" data-primary="Swift header" id="calibre_link-2171" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="header files" data-secondary="Swift" id="calibre_link-1015" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Instances" class="calibre2"><div class="preface" id="calibre_link-2404">
<h1 class="calibre18">Instances</h1>

<p class="author1">Object types &mdash; class, struct, and enum &mdash; have an important feature in common: they can be <em class="calibre11">instantiated</em>. In effect, when you declare an object type, you are only defining a <em class="calibre11">type</em>. To instantiate a type is to make a thing &mdash; an <em class="calibre11">instance</em> &mdash; of that type.<a data-type="indexterm" data-primary="instantiation" id="calibre_link-1139" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="creating an instance" id="calibre_link-575" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" id="calibre_link-1113" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" id="calibre_link-1114" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, I can declare a Dog class, and I can give my class a method:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        print("woof")
    }
}</pre>

<p class="author1">But I donâ€™t actually have any Dog objects in my program yet. I have merely described the <em class="calibre11">type</em> of thing a Dog <em class="calibre11">would</em> be if I had one. To get an actual Dog, I have to <em class="calibre11">make</em> one. The process of making an actual Dog object whose type is the Dog class is the process of instantiating Dog. The result is a new object &mdash; a Dog instance.</p>

<p class="author1">In Swift, instances can be created by using the object typeâ€™s name as a function name and calling the function. This involves using parentheses. When you append parentheses to the name of an object type, you are sending a very special kind of message to that object type: Instantiate yourself!<a data-type="indexterm" data-primary="parentheses" data-secondary="instantiating an object type" id="calibre_link-1678" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So now Iâ€™m going to make a Dog instance:<a data-type="indexterm" data-primary="instances" data-secondary="creation" id="calibre_link-1118" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()</pre>

<p class="author1">Thereâ€™s a lot going on in that code! I did two things. I instantiated Dog, thus causing me to end up with a Dog instance. I also put that Dog instance into a shoebox called <code class="calibre19">fido</code> &mdash; I declared a variable and initialized the variable by assigning my new Dog instance to it. Now <code class="calibre19">fido</code> <em class="calibre11">is a Dog instance</em>. (Moreover, because I used <code class="calibre19">let</code>, <code class="calibre19">fido</code> will always be this same Dog instance. I could have used <code class="calibre19">var</code> instead, but even then, <span class="publishername">initializing</span> <code class="calibre19">fido</code> as a Dog instance would mean <code class="calibre19">fido</code> could only be some Dog instance after that.)</p>

<p class="author1">Now that I have a Dog instance, I can send <em class="calibre11">instance messages</em> to it. And what do you suppose they are? They are Dogâ€™s properties and methods! For example:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.bark()</pre>

<p class="author1">That code is legal. Not only that, it is effective: it actually does cause <code class="calibre19">"woof"</code> to appear in the console. I made a Dog and I made it bark! (See <a data-type="xref" href="#calibre_link-2747" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;1-1</a>.)</p>

<figure class="calibre32"><div id="calibre_link-2747" class="figure">
<img src="images/000025.png" alt="ios8 0102" class="calibre33" />
<h6 class="calibre34"><span class="publishername">Figure 1-1. </span>Making an instance and calling an instance method</h6>
</div>
</figure>

<p class="author1">Thereâ€™s an important lesson here, so let me pause to emphasize it. By default, properties and methods are <em class="calibre11">instance</em> properties and methods. You canâ€™t use them as messages to the object type itself; you have to have an <em class="calibre11">instance</em> to send those messages to. As things stand, this is illegal and wonâ€™t compile:<a data-type="indexterm" data-primary="properties" data-secondary="instance" id="calibre_link-1761" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="instance" id="calibre_link-1336" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instance" data-secondary="methods" id="calibre_link-1107" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instance" data-secondary="properties" id="calibre_link-1109" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">Dog.bark() // compile error</pre>

<p class="author1">It is possible to declare a function <code class="calibre19">bark</code> in such a way that saying <code class="calibre19">Dog.bark()</code> <em class="calibre11">is</em> legal, but that would be a different kind of function &mdash; a <em class="calibre11">class</em> function or a <em class="calibre11">static</em> function &mdash; and you would need to say so when you declare it.<a data-type="indexterm" data-primary="class" data-secondary="members" id="calibre_link-362" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static members" id="calibre_link-2068" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The same thing is true of properties. To illustrate, letâ€™s give Dog a <code class="calibre19">name</code> property:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
}</pre>

<p class="author1">That allows me to set a Dogâ€™s <code class="calibre19">name</code>, but it needs to be an <em class="calibre11">instance</em> of Dog:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.name = "Fido"</pre>

<p class="author1">It is possible to declare a property <code class="calibre19">name</code> in such a way that saying <code class="calibre19">Dog.name</code> is legal, but that would be a different kind of property &mdash; a <em class="calibre11">class</em> property or a <em class="calibre11">static</em> property &mdash; and you would need to say so when you declare it.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Why Instances?" class="calibre2"><div class="preface" id="calibre_link-2405">
<h1 class="calibre18">Why Instances?</h1>

<p class="author1">Even if there were no such thing as an instance, an object type is itself an object. We know this because it is possible to send a message to an object type
(the phrase <code class="calibre19">Manny.Klass</code> is a case in point).
Why, then, do instances exist at all?</p>

<p class="author1">The answer has mostly to do with the nature of instance properties. The <em class="calibre11">value</em> of an instance property is defined with respect to <em class="calibre11">a particular instance</em>. This is where instances get their real usefulness and power.</p>

<p class="author1">Consider again our Dog class. Iâ€™ll give it a <code class="calibre19">name</code> property and a <code class="calibre19">bark</code> method; remember, these are an instance property and an instance method:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    func bark() {
        print("woof")
    }
}</pre>

<p class="author1">A Dog instance comes into existence with a blank <code class="calibre19">name</code> (an empty string). But its <code class="calibre19">name</code> property is a <code class="calibre19">var</code>, so once we have any Dog instance, we can assign to its <code class="calibre19">name</code> a new String value:</p>

<pre data-type="programlisting" class="calibre28">let dog1 = Dog()
dog1.name = "Fido"</pre>

<p class="author1">We can also ask for a Dog instanceâ€™s <code class="calibre19">name</code>:</p>

<pre data-type="programlisting" class="calibre28">let dog1 = Dog()
dog1.name = "Fido"
print(dog1.name) // "Fido"</pre>

<p class="author1">The important thing is that we can make more than one Dog instance, and that two different Dog instances can have two different <code class="calibre19">name</code> property values (<a data-type="xref" href="#calibre_link-2748" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;1-2</a>):</p>

<pre data-type="programlisting" class="calibre28">let dog1 = Dog()
dog1.name = "Fido"
let dog2 = Dog()
dog2.name = "Rover"
print(dog1.name) // "Fido"
print(dog2.name) // "Rover"</pre>

<figure class="calibre32"><div id="calibre_link-2748" class="figure">
<img src="images/000033.png" alt="ios9 0103" class="calibre35" />
<h6 class="calibre34"><span class="publishername">Figure 1-2. </span>Two dogs with different property values</h6>
</div>
</figure>

<p class="author1">Note that a Dog instanceâ€™s <code class="calibre19">name</code> property has nothing to do with the name of the variable to which a Dog instance is assigned. The variable is just a shoebox. You can pass an instance from one shoebox to another. But the instance itself maintains its own internal integrity:</p>

<pre data-type="programlisting" class="calibre28">let dog1 = Dog()
dog1.name = "Fido"
var dog2 = Dog()
dog2.name = "Rover"
print(dog1.name) // "Fido"
print(dog2.name) // "Rover"
dog2 = dog1
print(dog2.name) // "Fido"</pre>

<p class="author1">That code didnâ€™t change Roverâ€™s <code class="calibre19">name</code>; it changed which dog was inside the <code class="calibre19">dog2</code> shoebox, replacing Rover with Fido.</p>

<p class="author1">The full power of object-based programming has now emerged. There is a Dog object type which defines <em class="calibre11">what it is to be a Dog</em>. Our declaration of Dog says that any and every Dog instance has a <code class="calibre19">name</code> property and a <code class="calibre19">bark</code> method. But each Dog instance can have its own <code class="calibre19">name</code> property <em class="calibre11">value</em>.
So multiple instances of the same object type behave alike &mdash; both Fido and Rover can bark, and will do so when they are sent the <code class="calibre19">bark</code> message &mdash; but they are different instances and can have different property values: Fidoâ€™s <code class="calibre19">name</code> is <code class="calibre19">"Fido"</code> while Roverâ€™s <code class="calibre19">name</code> is <code class="calibre19">"Rover"</code>.</p>

<p class="author1">An instance is responsible not only for the values but also for the <em class="calibre11">lifetimes</em> of its properties. Suppose we bring a Dog instance into existence and assign to its <code class="calibre19">name</code> property the value <code class="calibre19">"Fido"</code>. Then this Dog instance is keeping the string <code class="calibre19">"Fido"</code> alive just so long as we do not replace the value of its <code class="calibre19">name</code> with some other value &mdash; and just so long as this instance lives.</p>

<p class="author1">In short, an instance is both code and data. The code it gets from its type and in a sense is shared with all other instances of that type, but the data belong to it alone. The data can persist as long as the instance persists. The instance has, at every moment, a <em class="calibre11">state</em> &mdash; the complete collection of its own personal property values. An instance is a device for <em class="calibre11">maintaining state</em>. Itâ€™s a box for storage of data.<a data-type="indexterm" data-primary="state" data-secondary="instance" id="calibre_link-2064" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="state" id="calibre_link-1134" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Keyword self" class="calibre2"><div class="preface" id="calibre_link-2406">
<h1 class="calibre18">The Keyword self</h1>

<p class="author1">An instance is an object, and an object is the recipient of messages. Thus, an instance needs a way of sending a message to itself. This is made possible by the keyword <code class="calibre19">self</code>. This word can be used wherever an instance of the appropriate type is expected.<a data-type="indexterm" data-primary="self" id="calibre_link-1974" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="messages" data-secondary="to self" id="calibre_link-1327" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s say I want to keep the thing that a Dog says when it barks, such as <code class="calibre19">"woof"</code>, in a property. Then in my implementation of <code class="calibre19">bark</code> I need to refer to that property. I can do it like this:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var whatADogSays = "woof"
    func bark() {
        print(self.whatADogSays)
    }
}</pre>

<p class="author1">Similarly, letâ€™s say I want to write an instance method <code class="calibre19">speak</code> which is merely a synonym for <code class="calibre19">bark</code>. My <code class="calibre19">speak</code> implementation can consist of simply calling my own <code class="calibre19">bark</code> method. I can do it like this:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var whatADogSays = "woof"
    func bark() {
        print(self.whatADogSays)
    }
    func speak() {
        self.bark()
    }
}</pre>

<p class="author1">Observe that the term <code class="calibre19">self</code> in that example appears only in instance methods. When an instanceâ€™s code says <code class="calibre19">self</code>, it is referring to <em class="calibre11">this</em> instance. If the expression <code class="calibre19">self.name</code> appears in a Dog instance methodâ€™s code, it means the <code class="calibre19">name</code> of <em class="calibre11">this</em> Dog instance, the one whose code is running at that moment.<a data-type="indexterm" data-primary="self" data-secondary="in instance methods" id="calibre_link-1979" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">It turns out that every use of the word <code class="calibre19">self</code> Iâ€™ve just illustrated is optional. You can omit it and all the same things will happen:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var whatADogSays = "woof"
    func bark() {
        print(whatADogSays)
    }
    func speak() {
        bark()
    }
}</pre>

<p class="author1">The reason is that if you omit the message recipient and the message youâ€™re sending can be sent to <code class="calibre19">self</code>, the compiler supplies <code class="calibre19">self</code> as the messageâ€™s recipient under the hood. However, I never do that (except by mistake). As a matter of style, I like to be explicit in my use of <code class="calibre19">self</code>. I find code that omits <code class="calibre19">self</code> harder to read and understand. And there are situations where you <em class="calibre11">must</em> say <code class="calibre19">self</code>, so I prefer to use it whenever Iâ€™m allowed to.<a data-type="indexterm" data-startref="idxinstances" id="calibre_link-1115" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Privacy" class="calibre2"><div class="preface" id="calibre_link-2407">
<h1 class="calibre18">Privacy</h1>

<p class="author1">Earlier, I said that a namespace is not, of itself, an insuperable barrier to accessing the names inside it. But such a barrier is sometimes desirable. For example, not all data stored by an instance is intended for alteration by, or even visibility to, another instance. And not every instance method is intended to be called by other instances. Any decent object-based programming language needs a way to endow its object members with <em class="calibre11">privacy</em> &mdash; a way of making it harder for other objects to see those members if they are not supposed to be seen.<a data-type="indexterm" data-primary="privacy" id="calibre_link-1725" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Consider, for example:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var whatADogSays = "woof"
    func bark() {
        print(self.whatADogSays)
    }
    func speak() {
        print(self.whatADogSays)
    }
}</pre>

<p class="author1">Here, other objects can come along and change my property <code class="calibre19">whatADogSays</code>. Since that property is used by both <code class="calibre19">bark</code> and <code class="calibre19">speak</code>, we could easily end up with a Dog that, when told to <code class="calibre19">bark</code>, says <code class="calibre19">"meow"</code>. That seems somehow undesirable:</p>

<pre data-type="programlisting" class="calibre28">let dog1 = Dog()
dog1.whatADogSays = "meow"
dog1.bark() // meow</pre>

<p class="author1">You might reply: Well, silly, why did you declare <code class="calibre19">whatADogSays</code> with <code class="calibre19">var</code>? Declare it with <code class="calibre19">let</code> instead. Make it a constant! Now no one can change it:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    let whatADogSays = "woof"
    func bark() {
        print(self.whatADogSays)
    }
    func speak() {
        print(self.whatADogSays)
    }
}</pre>

<p class="author1">That is a good answer, but it is not quite good enough. There are two problems. Suppose I want a Dog instance <em class="calibre11">itself</em> to be able to change <em class="calibre11">its own</em> <code class="calibre19">whatADogSays</code> &mdash; by assigning to <code class="calibre19">self.whatADogSays</code>. Then <code class="calibre19">whatADogSays</code> <em class="calibre11">has</em> to be a <code class="calibre19">var</code>; otherwise, even the instance itself canâ€™t change it. Also, suppose I donâ€™t want any other object to <em class="calibre11">know</em> what this Dog says, except by calling <code class="calibre19">bark</code> or <code class="calibre19">speak</code>. Even when declared with <code class="calibre19">let</code>, other objects can still <em class="calibre11">read</em> the value of <code class="calibre19">whatADogSays</code>. Maybe I donâ€™t like that.</p>

<p class="author1">To solve this problem, Swift provides the <code class="calibre19">private</code> keyword. Iâ€™ll talk later about all the ramifications of this keyword, but for now itâ€™s enough to know that it exists:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    private var whatADogSays = "woof"
    func bark() {
        print(self.whatADogSays)
    }
    func speak() {
        print(self.whatADogSays)
    }
}</pre>

<p class="author1">Now <code class="calibre19">name</code> is a public property, but <code class="calibre19">whatADogSays</code> is a private property: it canâ€™t be seen by other types of object. A Dog instance can speak of <code class="calibre19">self.whatADogSays</code>, but a Cat instance with a reference to a Dog instance as <code class="calibre19">fido</code> cannot say <code class="calibre19">fido.whatADogSays</code>. The important lesson here is that object members are public by default, and if you want privacy, you have to ask for it.<a data-type="indexterm" data-primary="properties" data-secondary="private" id="calibre_link-1771" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To sum up: A class declaration defines a namespace. This namespace requires that other objects use an extra level of dot-notation to refer to whatâ€™s inside the namespace, but other objects <em class="calibre11">can</em> still refer to whatâ€™s inside the namespace; the namespace does not, in and of itself, close any doors of visibility. The <code class="calibre19">private</code> keyword lets you close those doors.</p>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2899">
<h5 class="calibre36">Reserved Words</h5>
<p class="calibre37">Certain terms, like <code class="calibre19">class</code> and <code class="calibre19">func</code> and <code class="calibre19">var</code> and <code class="calibre19">let</code> and <code class="calibre19">if</code> and <code class="calibre19">private</code> and <code class="calibre19">import</code>, are <em class="calibre11">reserved</em> in Swift; they are part of the language. That means you canâ€™t use them as <em class="calibre11">identifiers</em> &mdash; as the name of a class, a function, or a variable, for example. If you try to do so, youâ€™ll get a compile error.<a data-type="indexterm" data-primary="identifiers and reserved words" id="calibre_link-1033" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="reserved words" id="calibre_link-1905" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre37">To force a reserved word to be an identifier, surround it by backticks (<code class="calibre19">`</code>). This (extraordinarily confusing) code is legal:</p>

<pre data-type="programlisting" class="calibre38">class `func` {
    func `if`() {
        let `class` = 1
    }
}</pre>
</div>
</aside>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Design" class="calibre2"><div class="preface" id="calibre_link-2408">
<h1 class="calibre18">Design</h1>

<p class="author1">Instances do not come into being by magic. You have to instantiate a type in order to obtain an instance. Much of the action of your program, therefore, will consist of instantiating types. And of course you will want those instances to persist, so you will also assign each newly created instance to a variable as a shoebox to hold it, name it, and give it a lifetime. The instance will <em class="calibre11">persist</em> according to the lifetime of the variable that refers to it. And the instance will be <em class="calibre11">visible</em> to other instances according to the scope of the variable that refers to it.</p>

<p class="author1">Much of the art of object-based programming involves giving instances a sufficient lifetime and making them visible to one another. You will often put an instance into a particular shoebox &mdash; assigning it to a particular variable, declared at a certain scope &mdash; exactly so that, thanks to the rules of variable lifetime and scope, this instance will <em class="calibre11">persist</em> long enough to keep being useful to your program while it will still be needed, and so that other code can <em class="calibre11">get a reference</em> to this instance and talk to it later.</p>

<p class="author1">Planning how youâ€™re going to create instances, and working out the lifetimes and communication between those instances, may sound daunting. Fortunately, in real life, when youâ€™re programming iOS, the framework will provide scaffolding for you. Before you write a single line of code, the framework ensures that your app, as it launches, is given some instances that will persist for the lifetime of the app, providing the basis of your appâ€™s visible interface and giving you an initial place to put your own instances and give them sufficiently long lifetimes.</p>

<p class="author1">What about the question of what object types your program will need in the first place, and what methods and properties they should have? This is not as much of a worry as you might suppose. Swift itself supplies a library of powerful and useful object types. Moreover, much of your code when youâ€™re programming iOS will be focused on the details of real-world interface objects, such as labels and buttons that that the user can see and tap, and the framework will make it clear what object types and facilities it offers for this purpose, and will provide ways to ensure the appropriate persistence and visibility of the associated instances.</p>

<p class="author1">What the framework cannot tell you is how to design the underlying business logic of whatever your app does behind the scenes. This is where you will have the most freedom, and thus the most difficulty arriving at an appropriate architecture of object types, functionalities, and relationships. These will not be easy decisions, and there are no clear-cut answers. Object-based programming is an art; and allowing your program (and your thinking) to evolve as you write code, discovering new needs and issues, is an art within that art, which I call <em class="calibre11">growing a program</em>. All individuals and teams develop their own way of meeting the long-term challenges involved.</p>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2750">
<div id="calibre_link-2900" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 2. Functions" class="calibre2"><div class="preface" id="calibre_link-56">
<h1 class="calibre13"><span class="label">Chapter 2. </span>Functions</h1>


<p class="author1">Nothing is so characteristic of Swift syntax as the way you declare and call functions. Probably nothing is so important, either! As I said in <a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>, all your executable code is going to be in functions; they are where the action is.<a data-type="indexterm" data-primary="functions" id="calibre_link-899" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Function Parameters and Return Value" class="calibre2"><div class="preface" id="calibre_link-2409">
<h1 class="calibre18">Function Parameters and Return Value</h1>

<p class="author1">Remember those imaginary machines for processing miscellaneous stuff that you drew in your math textbook in elementary school? You know the ones I mean: with a funnel-like â€œhopperâ€ at the top, and then a bunch of gears and cranks, and then a tube at the bottom where something is produced. A function works like that: you feed some stuff in, the stuff is processed in accordance with what this particular machine does, and something is produced. The stuff that goes in is the input; what comes out is the output. More technically, a function that expects input has <em class="calibre11">parameters</em>; a function that produces output has a <em class="calibre11">result</em>.</p>

<p class="author1">Hereâ€™s the declaration for a silly but valid function that expects two Int values, adds them together, and produces that sum:<a data-type="indexterm" data-primary="functions" data-secondary="declaration" id="calibre_link-912" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" id="calibre_link-1664" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="result of a function" id="calibre_link-1918" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of functions" id="calibre_link-626" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="result" id="calibre_link-929" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="input" id="calibre_link-1104" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="output" id="calibre_link-1644" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func sum (_ x:Int, _ y:Int) -&gt; Int {
    let result = x + y
    return result
}</pre>

<p class="author1">The syntax here is very strict and well-defined, and you canâ€™t use Swift unless you understand it perfectly. Letâ€™s pause to appreciate it in full detail. Iâ€™ll break the first line into pieces so that I can call them out individually:</p>

<pre data-type="programlisting" class="calibre28">func sum                      <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2758" href="#calibre_link-2751"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    (_ x:Int, _ y:Int)        <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2759" href="#calibre_link-2752"><img src="images/000008.png" alt="2" class="calibre39" /></a><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2760" href="#calibre_link-2753"><img src="images/000029.png" alt="3" class="calibre39" /></a>
    -&gt; Int {                  <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2761" href="#calibre_link-2754"><img src="images/000014.png" alt="4" class="calibre39" /></a><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2762" href="#calibre_link-2755"><img src="images/000021.png" alt="5" class="calibre39" /></a>
        let result = x + y    <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2763" href="#calibre_link-2756"><img src="images/000010.png" alt="6" class="calibre39" /></a>
        return result         <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2764" href="#calibre_link-2757"><img src="images/000034.png" alt="7" class="calibre39" /></a>
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2751" href="#calibre_link-2758"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The declaration starts with the keyword <code class="calibre19">func</code>, followed by the <em class="calibre11">name</em> of this function; here, itâ€™s <code class="calibre19">sum</code>. This is the name that must be used in order to <em class="calibre11">call</em> the function &mdash; that is, in order to run the code that the function contains.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2752" href="#calibre_link-2759"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The name of the function is followed by its <em class="calibre11">parameter list</em>.<a data-type="indexterm" data-primary="parameter list" id="calibre_link-1661" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> It consists, minimally, of parentheses. If this function takes parameters (input), they are listed inside the parentheses, separated by a comma. Each parameter has a strict format: the <em class="calibre11">name</em> of the parameter, a colon, and the <em class="calibre11">type</em> of the parameter.<a data-type="indexterm" data-primary="parentheses" data-secondary="declaring a function" id="calibre_link-1677" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="colon" data-secondary="parameter name" id="calibre_link-465" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="parameters" id="calibre_link-478" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2753" href="#calibre_link-2760"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">This particular function declaration also has an underscore (<code class="calibre19">_</code>) and a space before each parameter name in the parameter list. Iâ€™m not going to explain that underscore yet, but I need it for the example, so just trust me for now.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2754" href="#calibre_link-2761"><img src="images/000014.png" alt="4" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">If the function is to return a value, then after the parentheses is an arrow operator (<code class="calibre19">-&gt;</code>) followed by the <em class="calibre11">type</em> of value that this function will return.<a data-type="indexterm" data-primary="arrow operator" id="calibre_link-209" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="return value" id="calibre_link-932" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="return" data-secondary="value of function" id="calibre_link-1935" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2755" href="#calibre_link-2762"><img src="images/000021.png" alt="5" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Then we have curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-580" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> enclosing the <em class="calibre11">body</em> of the function &mdash; its actual code.<a data-type="indexterm" data-primary="body of a function" id="calibre_link-264" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="body" id="calibre_link-904" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2756" href="#calibre_link-2763"><img src="images/000010.png" alt="6" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Within the curly braces, in the function body, the variables defined as the parameter names have sprung to life, with the types specified in the parameter list.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2757" href="#calibre_link-2764"><img src="images/000034.png" alt="7" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">If the function is to return a value, it must do so with the keyword <code class="calibre19">return</code> followed by that value. And, not surprisingly, the type of that value must match the type declared earlier for the return value (after the arrow operator).<a data-type="indexterm" data-primary="return" id="calibre_link-1930" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
</dl>

<p class="author1">Here are some further points to note about the parameters and return type of our function:</p>
<dl class="calibre14">
<dt class="calibre15">Parameters</dt>
<dd class="calibre16">
<p class="calibre17">Our <code class="calibre19">sum</code> function expects two parameters &mdash; an Int, to which it gives the name <code class="calibre19">x</code>, and another Int, to which it gives the name <code class="calibre19">y</code>. The function body code wonâ€™t run unless code elsewhere calls this function and actually passes values of the specified types for its parameters. If I try to call this function <em class="calibre11">without</em> providing a value for each of these two parameters, or if either of the values I provide is <em class="calibre11">not</em> an Int, the compiler will stop me with an error.</p>

<p class="calibre17">In the body of the function, therefore, we can confidently use those values, referring to them by those names, certain that they will exist as specified by our parameter list.
The parameter names <code class="calibre19">x</code> and <code class="calibre19">y</code>, indeed, are defined just so that the parameter values <em class="calibre11">can</em> be referred to within the function body. The parameter declaration is thus a kind of variable declaration: we are declaring variables <code class="calibre19">x</code> and <code class="calibre19">y</code> for use inside this function. With regard to their scope, these variables are local (<em class="calibre11">internal</em>) to the function; <em class="calibre11">only</em> the function body can see them, and they are different from any other <code class="calibre19">x</code> and <code class="calibre19">y</code> that may be used in other functions or at a higher level of scope. <a data-type="indexterm" data-primary="internal parameter names" id="calibre_link-1151" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="internal parameter names" id="calibre_link-922" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" data-secondary="internal names" id="calibre_link-1672" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Return type</dt>
<dd class="calibre16">
<p class="calibre17">The last statement of our <code class="calibre19">sum</code> functionâ€™s body returns the value of a variable called <code class="calibre19">result</code>; this variable was created by adding two Int values together, so it is an Int, which is what this function is supposed to produce. If I try to return a String (<code class="calibre19">return "howdy"</code>), or if I omit the return statement altogether, the compiler will stop me with an error.</p>

<p class="calibre17">The keyword <code class="calibre19">return</code> actually does <em class="calibre11">two</em> things. It <em class="calibre11">returns</em> the accompanying value, and it also <em class="calibre11">halts</em> execution of the function. It is permitted for more lines of code to follow a return statement, but the compiler will warn if this means that those lines can never be executed.</p>

<p class="calibre17">A function that returns a value must contain a return statement, so if its body consists of just a single statement, it must <em class="calibre11">be</em> the return statement. New in Swift 5.1, the keyword <code class="calibre19">return</code> can be omitted in that situation. This is mostly to facilitate the SwiftUI domain-specific language, and in general I like to say <code class="calibre19">return</code> explicitly, but in some situations it does feel more elegant to omit it.<a data-type="indexterm" data-primary="return" data-secondary="omitting" id="calibre_link-1932" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">You can thus view the function declaration before the curly braces as a <em class="calibre11">contract</em> about what kinds of values will be used as input and about what kind of output will be produced. According to this contract, the function <em class="calibre11">expects</em> a certain number of parameters, each of a certain type, and <em class="calibre11">yields</em> a certain type of result. Everything must correspond to this contract. The function body, inside the curly braces, can use the parameters as local variables. The returned value must match the declared return type.</p>

<p class="author1">The same contract applies to code elsewhere that <em class="calibre11">calls</em> this function. Hereâ€™s some code that calls our <code class="calibre19">sum</code> function:<a data-type="indexterm" data-primary="functions" data-secondary="calling" id="calibre_link-908" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="calling a function" id="calibre_link-331" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let z = sum(4,5)</pre>

<p class="author1">Focus your attention on the right side of the equal sign &mdash; <code class="calibre19">sum(4,5)</code>. Thatâ€™s the function call. How is it constructed? It uses the <em class="calibre11">name</em> of the function; that name is followed by <em class="calibre11">parentheses</em>; and inside those parentheses, separated by a comma, are the <em class="calibre11">values</em> to be passed to each of the functionâ€™s parameters. Technically, these values are called <em class="calibre11">arguments</em>. Here, Iâ€™m using literal Int values, but Iâ€™m perfectly free to use Int variables instead; the only requirement is that I use things that have the correct type:<a data-type="indexterm" data-primary="arguments" id="calibre_link-174" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parentheses" data-secondary="calling a function" id="calibre_link-1675" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="arguments" id="calibre_link-472" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let x = 4
let y = 5
let z = sum(y,x)</pre>

<p class="author1">In that code, I purposely used the names <code class="calibre19">x</code> and <code class="calibre19">y</code> for the variables whose values are passed as arguments, and I purposely reversed them in the call, to emphasize that these names have <em class="calibre11">nothing to do</em> with the names <code class="calibre19">x</code> and <code class="calibre19">y</code> inside the function parameter list and the function body. Argument names do not magically make their way to the function. Their <em class="calibre11">values</em> are all that matter; their values are the arguments.</p>

<p class="author1">What about the value returned by the function? That value is magically <em class="calibre11">substituted</em> for the function call, at the point where the function call is made. It happens that in the preceding code, the result is 9. So the last line is exactly as if I had said:</p>

<pre data-type="programlisting" class="calibre28">let z = 9</pre>

<p class="author1">The programmer and the compiler both know what type of thing this function returns, so they also know where it is and isnâ€™t legal to call this function. Itâ€™s fine to call this function as the initialization part of the declaration of the variable <code class="calibre19">z</code>, just as it would be to use <code class="calibre19">9</code> as the initialization part of that declaration: in both cases, we have an Int, and so <code class="calibre19">z</code> ends up being declared as an Int. But it would not be legal to write this:</p>

<pre data-type="programlisting" class="calibre28">let z = sum(4,5) + "howdy" // compile error</pre>

<p class="author1">Because <code class="calibre19">sum</code> returns an Int, thatâ€™s the same as trying to add an Int to a String &mdash; and by default, you canâ€™t do that in Swift.</p>

<p class="author1">Observe that it is legal to ignore the value returned from a function call:</p>

<pre data-type="programlisting" class="calibre28">sum(4,5)</pre>

<p class="author1">That code is rather silly in this particular situation, because we have made our <code class="calibre19">sum</code> function go to all the trouble of adding 4 and 5 for us and we have then thrown away the answer without capturing or using it. The compiler knows this, and will warn that we are failing to use the result of our function call. Nevertheless, a warning is not an error; that code is legal. There are, in fact, lots of situations where it is perfectly reasonable to ignore the value returned from a function call; in particular, the function may do other things (technically called <em class="calibre11">side effects</em>) in addition to returning a value, and the purpose of your call to that function may be those other things.<a data-type="indexterm" data-primary="side effects" id="calibre_link-2026" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If youâ€™re ignoring a function call result deliberately, you can silence the compiler warning by assigning the function call to <code class="calibre19">_</code> (a variable without a name) &mdash; for example, <code class="calibre19">_&nbsp;=&nbsp;sum(4,5)</code>. Alternatively, if the function being called is your own, you can prevent the warning by marking the function declaration with <code class="calibre19">@discardableResult</code>.<a data-type="indexterm" data-primary="result of a function" data-secondary="ignoring" id="calibre_link-1919" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="result" data-tertiary="ignoring" id="calibre_link-930" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="underscore" data-secondary="assignment to" id="calibre_link-2269" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>

<p class="author1">If you can call <code class="calibre19">sum</code> wherever you can use an Int, and if the parameters of <code class="calibre19">sum</code> have to be Int values, doesnâ€™t that mean you can call <code class="calibre19">sum</code> inside a call to <code class="calibre19">sum</code>? Of course it does! This is perfectly legal (and reasonable):</p>

<pre data-type="programlisting" class="calibre28">let z = sum(4,sum(5,6))</pre>

<p class="author1">The only arguments against writing code like that are that you might confuse yourself and that it might make things harder to debug later. But technically itâ€™s legal and quite normal.</p>








<section data-type="sect2" data-pdf-bookmark="Void Return Type and Parameters" class="calibre2"><div class="preface" id="calibre_link-2410">
<h2 class="calibre42">Void Return Type and Parameters</h2>

<p class="author1">Letâ€™s return to our function declaration. With regard to a functionâ€™s parameters and return type, there are two degenerate cases that allow us to express a function declaration more briefly:<a data-type="indexterm" data-primary="Void" id="calibre_link-2357" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">A function without a return type</dt>
<dd class="calibre16">
<p class="calibre17">No law says that a function <em class="calibre11">must</em> return a value. A function may be declared to return <em class="calibre11">no</em> value. In that case, there are three ways to write the declaration: you can write it as returning Void; you can write it as returning <code class="calibre19">()</code>, an empty pair of parentheses; or you can omit the arrow operator and the return type entirely. These are all legal:<a data-type="indexterm" data-primary="parentheses" data-secondary="signifying Void" id="calibre_link-1683" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func say1(_ s:String) -&gt; Void { print(s) }
func say2(_ s:String) -&gt; () { print(s) }
func say3(_ s:String) { print(s) }</pre>

<p class="calibre17">If a function returns no value, then its body need not contain a return statement. If it does contain a return statement, it will consist of the word <code class="calibre19">return</code> alone, and its purpose will be purely to end execution of the function at that point.</p>

<p class="calibre17">A call to a function that returns no value is made purely for the functionâ€™s side effects; it has no useful return value that can be made part of a larger expression, so the statement that calls the function will usually consist of the function call and nothing else.</p>
</dd>
<dt class="calibre15">A function without any parameters</dt>
<dd class="calibre16">
<p class="calibre17">No law says that a function <em class="calibre11">must</em> take any parameters. If it doesnâ€™t, the parameter list in the function declaration can be completely empty. But you canâ€™t omit the parameter list parentheses themselves! They will be present in the function declaration, after the functionâ€™s name:</p>

<pre data-type="programlisting" class="calibre28">func greet() -&gt; String { return "howdy" }</pre>

<p class="calibre17">Just as you cannot omit the parentheses (the parameter list) from a function <em class="calibre11">declaration</em>, you cannot omit the parentheses from a function <em class="calibre11">call</em>. Those parentheses will be empty if the function takes no parameters, but they must be present. For example:</p>

<pre data-type="programlisting" class="calibre28">let greeting = greet()</pre>

<p class="calibre17">Notice the parentheses!</p>
</dd>
</dl>

<p class="author1">A function can lack both a return value and parameters; these are all ways of expressing the same thing:</p>

<pre data-type="programlisting" class="calibre28">func greet1() -&gt; Void { print("howdy") }
func greet2() -&gt; () { print("howdy") }
func greet3() { print("howdy") }</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Function Signature" class="calibre2"><div class="preface" id="calibre_link-2411">
<h2 class="calibre42">Function Signature</h2>

<p class="author1">If we ignore the parameter names in the function declaration, we can completely characterize a function by the <em class="calibre11">types</em> of its inputs and its output. To do so, we write the parameter types in parentheses, followed by the arrow operator and the output type, like this:<a data-type="indexterm" data-primary="functions" data-secondary="signature" id="calibre_link-934" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="signature of a function" id="calibre_link-2027" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">(Int, Int) -&gt; Int</pre>

<p class="author1">That is a legal expression in Swift; it is the <em class="calibre11">signature</em> of a function. In this case, itâ€™s the signature of a function that takes two Int parameters and returns an Int. In fact, itâ€™s the signature of our <code class="calibre19">sum</code> function! Of course, there can be other functions that take two Int parameters and return an Int &mdash; and thatâ€™s just the point. This signature characterizes <em class="calibre11">all</em> functions that have this number of parameters, of these types, and that return a result of this type. A functionâ€™s signature is, in effect, <em class="calibre11">its</em> type &mdash; the type <em class="calibre11">of the function</em>. The fact that functions have types will be of great importance later on.</p>

<p class="author1">The signature of a function must include both the parameter list (without parameter names) and the return type, even if one or both of those is empty; the signature of a function that takes no parameters and returns no value may be written <code class="calibre19">() -&gt; Void</code> or <code class="calibre19">() -&gt; ()</code>.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="External Parameter Names" class="calibre2"><div class="preface" id="calibre_link-2412">
<h1 class="calibre18">External Parameter Names</h1>

<p class="author1">A function can <em class="calibre11">externalize</em> the names of its parameters. The external names must then appear in a call to the function as <em class="calibre11">labels</em> to the arguments. There are several reasons why this is a good thing:<a data-type="indexterm" data-primary="functions" data-secondary="external parameter names" id="calibre_link-915" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="external parameter names" id="calibre_link-837" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" data-secondary="external names" id="calibre_link-1666" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="labels" data-secondary="function call" id="calibre_link-1197" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="labels in function calls" data-seealso="external parameter names" id="calibre_link-1201" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">It clarifies the purpose of each argument; an argument label can give a clue as to how that argument contributes to the behavior of the function.</p>
</li>
<li class="calibre12">
<p class="calibre17">It distinguishes one function from another; two functions with the same name (before the parentheses) and the same signature, but with different external parameter names, are two distinct functions.</p>
</li>
<li class="calibre12">
<p class="calibre17">It helps Swift to interface with Objective-C and Cocoa, where method parameters nearly always have external names.</p>
</li>
</ul>

<p class="author1">External parameter names are so standard in Swift that thereâ€™s a rule: by default, <em class="calibre11">all</em> parameter names are externalized <em class="calibre11">automatically</em>, using the internal name as the external name. Thus, if you want a parameter name to be externalized, and if you want the external name to be the same as the internal name, <em class="calibre11">do nothing</em> &mdash; that will happen all by itself.</p>

<p class="author1">If you want to depart from the default behavior, you can do either of the following in your function declaration:</p>
<dl class="calibre14">
<dt class="calibre15">Change the name of an external parameter</dt>
<dd class="calibre16">
<p class="calibre17">If you want the external name of a parameter to be different from its internal name, precede the internal name with the external name and a space.</p>
</dd>
<dt class="calibre15">Suppress the externalization of a parameter</dt>
<dd class="calibre16">
<p class="calibre17">To suppress a parameterâ€™s external name, precede the internal name with an underscore and a space.</p>
</dd>
</dl>

<p class="author1">That explains my declaration <code class="calibre19">func sum (_ x:Int, _ y:Int) -&gt; Int</code> at the start of this chapter: I was suppressing the externalization of the parameter names, so as not to have to explain argument labels at the outset.<a data-type="indexterm" data-primary="underscore" data-secondary="argument label" id="calibre_link-2268" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s the declaration for a function that concatenates a string with itself a given number of times:</p>

<pre data-type="programlisting" class="calibre28">func echoString(_ s:String, times:Int) -&gt; String {
    var result = ""
    for _ in 1...times { result += s }
    return result
}</pre>

<p class="author1">That functionâ€™s first parameter has an internal name only, but its second parameter has an external name, which will be the same as its internal name, namely <code class="calibre19">times</code>. And hereâ€™s how to call it:</p>

<pre data-type="programlisting" class="calibre28">let s = echoString("hi", times:3)</pre>

<p class="author1">In the call, as you can see, the external name precedes the argument as a label, separated by a colon.<a data-type="indexterm" data-primary="colon" data-secondary="argument label" id="calibre_link-460" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Now letâ€™s say that in our <code class="calibre19">echoString</code> function we prefer to use <code class="calibre19">times</code> purely as an external name for the second parameter, with a different name &mdash; say, <code class="calibre19">n</code> &mdash; as the internal name. And letâ€™s strip the <code class="calibre19">string</code> off the functionâ€™s name (before the parentheses) and make it the external name of the first parameter. Then the declaration would look like this:</p>

<pre data-type="programlisting" class="calibre28">func echo(string s:String, times n:Int) -&gt; String {
    var result = ""
    for _ in 1...n { result += s }
    return result
}</pre>

<p class="author1">In the body of that function, there is now no <code class="calibre19">times</code> variable available; <code class="calibre19">times</code> is purely an external name, for use as a label in the call. The internal name is <code class="calibre19">n</code>, and thatâ€™s the name the code refers to. And hereâ€™s how to call it:</p>

<pre data-type="programlisting" class="calibre28">let s = echo(string:"hi", times:3)</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The existence of external names doesnâ€™t mean that the call can use a different parameter order from the declaration. For example, our <code class="calibre19">echo(string:times:)</code> expects a String parameter and an Int parameter, <em class="calibre11">in that order</em>. The order canâ€™t be different in the call, even though the label might appear to disambiguate which argument goes with which parameter.</p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Overloading" class="calibre2"><div class="preface" id="calibre_link-2413">
<h1 class="calibre18">Overloading</h1>

<p class="author1">In Swift, function <em class="calibre11">overloading</em> is legal (and common). This means that two functions with exactly the same name, <em class="calibre11">including</em> their external parameter names, can coexist as long as they have different signatures.(Two functions with the same name before the parentheses but <em class="calibre11">different</em> external parameter names do <em class="calibre11">not</em> constitute a case of overloading; they are simply two different functions with two different names.)<a data-type="indexterm" data-primary="overloading" id="calibre_link-1648" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="overloading" id="calibre_link-926" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, these two functions can coexist:</p>

<pre data-type="programlisting" class="calibre28">func say (_ what:String) {
}
func say (_ what:Int) {
}</pre>

<p class="author1">The reason overloading works is that Swift has strict typing. A String parameter is not an Int parameter. Swift can tell them apart both in the declaration and in a function call. Thus, Swift knows unambiguously that <code class="calibre19">say("what")</code> is different from <code class="calibre19">say(1)</code>, and it knows <em class="calibre11">which</em> <code class="calibre19">say</code> function each is calling.</p>

<p class="author1">Overloading works for the return type as well. Two functions with the same name and parameter types can have different return types. But the context of the call must disambiguate; that is, it must be clear what return type the caller is expecting.</p>

<p class="author1">For example, these two functions can coexist:</p>

<pre data-type="programlisting" class="calibre28">func say() -&gt; String {
    return "one"
}
func say() -&gt; Int {
    return 1
}</pre>

<p class="author1">But now you canâ€™t call <code class="calibre19">say</code> like this:</p>

<pre data-type="programlisting" class="calibre28">let result = say() // compile error</pre>

<p class="author1">The call is ambiguous, and the compiler tells you so.<a data-type="indexterm" data-primary="errors, compiler" data-secondary="ambiguous" id="calibre_link-788" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The call must be used in a context where the expected return type is clear. For example, suppose we have another function that is not overloaded, and that expects a String parameter:</p>

<pre data-type="programlisting" class="calibre28">func giveMeAString(_ s:String) {
    print("thanks!")
}</pre>

<p class="author1">Then <code class="calibre19">giveMeAString(say())</code> is legal, because only a String can go in this spot, so we must be calling the <code class="calibre19">say</code> that returns a String. Similarly:</p>

<pre data-type="programlisting" class="calibre28">let result = say() + "two"</pre>

<p class="author1">Only a String can be â€œaddedâ€ to a String, so this must be the <code class="calibre19">say</code> that returns a String.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Default Parameter Values" class="calibre2"><div class="preface" id="calibre_link-2414">
<h1 class="calibre18">Default Parameter Values</h1>

<p class="author1">A parameter can have a default value. This means that the caller can omit the parameter entirely, supplying no argument for it; the value will then be the default.<a data-type="indexterm" data-primary="parameters" data-secondary="default values" id="calibre_link-1665" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="default parameter values" id="calibre_link-913" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To specify a default value in a function declaration, append <code class="calibre19">=</code> and the default value after the parameter type:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func say(_ s:String, times:Int = 1) {
        for _ in 1...times {
            print(s)
        }
    }
}</pre>

<p class="author1">In effect, there are now <em class="calibre11">two</em> functions, one with a single unlabeled parameter, the other with an additional <code class="calibre19">times:</code> parameter. If you just want to say something once, you can call the <code class="calibre19">say</code> that takes a single unlabeled argument:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
d.say("woof") // same as d.say("woof", times:1)</pre>

<p class="author1">If you want repetition, call the <code class="calibre19">say</code> that takes a <code class="calibre19">times:</code> parameter:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
d.say("woof", times:3)</pre>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Variadic Parameters" class="calibre2"><div class="preface" id="calibre_link-2415">
<h1 class="calibre18">Variadic Parameters</h1>

<p class="author1">A parameter can be <em class="calibre11">variadic</em>. This means that the caller can supply as many values of this parameterâ€™s type as desired, separated by a comma; the function body will receive these values as an array.<a data-type="indexterm" data-primary="parameters" data-secondary="variadic" id="calibre_link-1674" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variadic parameters" id="calibre_link-2343" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="variadic parameters" id="calibre_link-940" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="variadics" id="calibre_link-483" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To indicate in a function declaration that a parameter is variadic, follow it with three dots, like this:</p>

<pre data-type="programlisting" class="calibre28">func sayStrings(_ arrayOfStrings:String ...) {
    for s in arrayOfStrings { print(s) }
}</pre>

<p class="author1">And hereâ€™s how to call it:</p>

<pre data-type="programlisting" class="calibre28">sayStrings("hey", "ho", "nonny nonny no")</pre>

<p class="author1">The global <code class="calibre19">print</code> function takes a variadic first parameter, so you can output multiple values with a single command:<a data-type="indexterm" data-primary="print" id="calibre_link-1722" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">print("Manny", 3, true) // Manny 3 true</pre>

<p class="author1">The <code class="calibre19">print</code> functionâ€™s default parameters dictate further details of the output. The default <code class="calibre19">separator:</code> (for when you provide multiple values) is a space, and the default <code class="calibre19">terminator:</code> is a newline; you can change either or both:</p>

<pre data-type="programlisting" class="calibre28">print("Manny", "Moe", separator:", ", terminator:", ")
print("Jack")
// output is "Manny, Moe, Jack" on one line</pre>

<p class="author1">A function can declare a maximum of one variadic parameter (because otherwise it might be impossible to determine where the list of values ends).</p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Unfortunately, thereâ€™s a hole in the Swift language: thereâ€™s no way to convert an array into a comma-separated list of arguments (comparable to splatting<a data-type="indexterm" data-primary="splatting" id="calibre_link-2052" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> in <span class="publishername">Ruby</span>). If what youâ€™re starting with is an array of some type, you canâ€™t use it where a variadic of that type is expected.</p>
</div>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2901">
<h5 class="calibre36">Initializers Are Functions</h5>
<p class="calibre37">In <a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>, I declared a Dog class and instantiated it, creating a Dog instance, by saying <code class="calibre19">Dog()</code>. When you do this, you are actually calling a function &mdash; a special function called an <em class="calibre11">initializer</em>. This particular initializer function takes no parameters; hence the parentheses are empty. But an initializer is a function like any other, so it can have parameters, external parameter names, default parameter values, overloading, and so forth.
<a data-type="indexterm" data-primary="initializers" id="calibre_link-1082" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="creating an instance" id="calibre_link-576" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="creation" id="calibre_link-1119" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instantiation" id="calibre_link-1140" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parentheses" data-secondary="instantiating an object type" id="calibre_link-1679" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre37">In <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> Iâ€™ll explain how initializers are declared and implemented. For now, itâ€™s enough to know that initializers are functions, and that the syntax for calling them (and thus for creating an instance) is the same as the syntax for any other function call. Whatâ€™s special is only that the parentheses follow the name of the type weâ€™re instantiating.</p>

<p class="calibre37">Swift built-in types tend to have lots of initializers (and in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> youâ€™ll learn how to give your own types lots of initializers). For example, we can create a string like this:</p>

<pre data-type="programlisting" class="calibre38">let s = String(repeating: "ho", count: 2)</pre>

<p class="calibre37">After that, <code class="calibre19">s</code> is the string <code class="calibre19">"hoho"</code>. And there are many other String initializers, each providing another way to make a String.</p>
</div>
</aside>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Ignored Parameters" class="calibre2"><div class="preface" id="calibre_link-2416">
<h1 class="calibre18">Ignored Parameters</h1>

<p class="author1">A parameter whose local name is an underscore is ignored. The caller must supply an argument, but it has no name within the function body and cannot be referred to there. For example:<a data-type="indexterm" data-primary="parameters" data-secondary="ignoring" id="calibre_link-1671" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="ignored parameters" id="calibre_link-921" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="underscore" data-secondary="parameter name" id="calibre_link-2272" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func say(_ s:String, times:Int, loudly _:Bool) {</pre>

<p class="author1">No <code class="calibre19">loudly</code> parameter makes its way into the function body, but the caller must still provide it:</p>

<pre data-type="programlisting" class="calibre28">say("hi", times:3, loudly:true)</pre>

<p class="author1">Whatâ€™s the purpose of this feature? It isnâ€™t to satisfy the compiler, because the compiler doesnâ€™t complain if a parameter is never referred to in the function body. I use it primarily as a kind of note to myself, a way of saying, â€œYes, I know there is a parameter here, and I am deliberately not using it for anything.â€</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Modifiable Parameters" class="calibre2"><div class="preface" id="calibre_link-2417">
<h1 class="calibre18">Modifiable Parameters</h1>

<p class="author1">In the body of a function, a parameter is essentially a local variable. By default, itâ€™s a variable implicitly declared with <code class="calibre19">let</code>. You canâ€™t assign to it:<a data-type="indexterm" data-primary="parameters" data-secondary="modifiable" id="calibre_link-1673" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="modifiable parameters" id="calibre_link-925" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func say(_ s:String, times:Int, loudly:Bool) {
    loudly = true // compile error
}</pre>

<p class="author1">If your code needs to assign to a parameter name within the body of a function, declare a <code class="calibre19">var</code> local variable inside the function body and assign the parameter value to it; your local variable can even have the same name as the parameter:</p>

<pre data-type="programlisting" class="calibre28">func say(_ s:String, times:Int, loudly:Bool) {
    var loudly = loudly
    loudly = true // no problem
}</pre>

<p class="author1">In that code, <code class="calibre19">loudly</code> is a local variable; assigning to it doesnâ€™t change the value of any variable outside the function body. However, it is also possible to configure a parameter in such a way that assigning to it <em class="calibre11">does</em> modify the value of a variable outside the function body! One typical use case is that you want your function to return more than one result. For example, here Iâ€™ll write a rather advanced function that removes all occurrences of a given character from a given string and returns the number of occurrences that were removed:</p>

<pre data-type="programlisting" class="calibre28">func removeCharacter(_ c:Character, from s:String) -&gt; Int {
    var s = s
    var howMany = 0
    while let ix = s.firstIndex(of:c) {
        s.remove(at:ix)
        howMany += 1
    }
    return howMany
}</pre>

<p class="author1">And you call it like this:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let result = removeCharacter("l", from:s) // 2</pre>

<p class="author1">Thatâ€™s nice, but the <em class="calibre11">original</em> string, <code class="calibre19">s</code>, is still <code class="calibre19">"hello"</code>! In the function body, we removed all occurrences of the character from the <em class="calibre11">local</em> copy of the String parameter.</p>

<p class="author1">If we want a function to alter the <em class="calibre11">original</em> value of an argument passed to it, we must do the following:<a data-type="indexterm" data-primary="inout" id="calibre_link-1103" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="address operator" id="calibre_link-125" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The type of the parameter we intend to modify must be declared <code class="calibre19">inout</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">When we call the function, the variable holding the value to be modified must be declared with <code class="calibre19">var</code>, not <code class="calibre19">let</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Instead of passing the variable as an argument, we must pass its <em class="calibre11">address</em>. This is done by preceding its name with an ampersand (<code class="calibre19">&amp;</code>).</p>
</li>
</ul>

<p class="author1">Our <code class="calibre19">removeCharacter(_:from:)</code> now looks like this:</p>

<pre data-type="programlisting" class="calibre28">func removeCharacter(_ c:Character, from s: inout String) -&gt; Int {
    var howMany = 0
    while let ix = s.firstIndex(of:c) {
        s.remove(at:ix)
        howMany += 1
    }
    return howMany
}</pre>

<p class="author1">And our call to <code class="calibre19">removeCharacter(_:from:)</code> now looks like this:</p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let result = removeCharacter("l", from:&amp;s)</pre>

<p class="author1">After the call, <code class="calibre19">result</code> is 2 <em class="calibre11">and</em> <code class="calibre19">s</code> is <code class="calibre19">"heo"</code>. Notice the ampersand before the name <code class="calibre19">s</code> when we pass it as the <code class="calibre19">from:</code> argument. It is required; if you omit it, the compiler will stop you. I like this requirement, because it forces us to acknowledge explicitly to the compiler, and to ourselves, that weâ€™re about to do something potentially dangerous: weâ€™re letting this function, as a side effect, modify a value outside of itself.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">When a function with an <code class="calibre19">inout</code> parameter is called, the variable whose address was passed as argument to that parameter is <em class="calibre11">always</em> set, even if the function makes no changes to that parameter.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Calling Objective-C with Modifiable Parameters" class="calibre2"><div class="preface" id="calibre_link-2418">
<h2 class="calibre42">Calling Objective-C with Modifiable Parameters</h2>

<p class="author1">You may encounter variations on this pattern when youâ€™re using Cocoa. The Cocoa APIs are written in C and Objective-C, so instead of the Swift term <code class="calibre19">inout</code>, youâ€™ll probably see some mysterious type such as UnsafeMutablePointer. From your point of view as the caller, however, itâ€™s the same thing: youâ€™ll prepare a <code class="calibre19">var</code> variable and pass its address.<a data-type="indexterm" data-primary="pointers" id="calibre_link-1701" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="UnsafeMutablePointer" id="calibre_link-2291" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For instance, consider the problem of learning a UIColorâ€™s RGBA components. There are four such components: the colorâ€™s red, green, blue, and alpha values. A function that, given a UIColor, returned the components of that color, would need to return four values at once &mdash; and that is something that Objective-C cannot do. So a different strategy is used. The UIColor method <code class="calibre19">getRed(_:green:blue:alpha:)</code> returns only a Bool reporting whether the component extraction succeeded. Instead of returning the actual components, it says: â€œYou hand me four CGFloats <em class="calibre11">as arguments</em>, and I will <em class="calibre11">modify</em> them for you so that they are the results of this operation.â€ Hereâ€™s roughly how the declaration for <code class="calibre19">getRed(_:green:blue:alpha:)</code> appears in Swift:</p>

<pre data-type="programlisting" class="calibre28">func getRed(_ red: UnsafeMutablePointer&lt;CGFloat&gt;,
    green: UnsafeMutablePointer&lt;CGFloat&gt;,
    blue: UnsafeMutablePointer&lt;CGFloat&gt;,
    alpha: UnsafeMutablePointer&lt;CGFloat&gt;) -&gt; Bool</pre>

<p class="author1">How would you call this function? The parameters are each an UnsafeMutablePointer to a CGFloat. Youâ€™ll create four <code class="calibre19">var</code> CGFloat variables beforehand, giving them each some value even though that value will be replaced when you call <code class="calibre19">getRed(_:green:blue:alpha:)</code>. Youâ€™ll pass the addresses of those variables as arguments. Those variables are where the component values will be after the call; and youâ€™ll probably be so sure that the component extraction will succeed, that you wonâ€™t even bother to capture the callâ€™s actual result:</p>

<pre data-type="programlisting" class="calibre28">let c = UIColor.purple
var r : CGFloat = 0
var g : CGFloat = 0
var b : CGFloat = 0
var a : CGFloat = 0
c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)
// now r, g, b, a are 0.5, 0.0, 0.5, 1.0</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Called by Objective-C with Modifiable Parameters" class="calibre2"><div class="preface" id="calibre_link-2419">
<h2 class="calibre42">Called by Objective-C with Modifiable Parameters</h2>

<p class="author1">Sometimes, Cocoa will call <em class="calibre11">your</em> function with an UnsafeMutablePointer parameter, and <em class="calibre11">you</em> will want to change its value. To do this, you cannot assign directly to it, as we did with the <code class="calibre19">inout</code> variable <code class="calibre19">s</code> in our implementation of <code class="calibre19">remove(from:character:)</code>. Youâ€™re talking to Objective-C, not to Swift, and this is an UnsafeMutablePointer, not an <code class="calibre19">inout</code> parameter. The technique here is to assign to the UnsafeMutablePointerâ€™s <code class="calibre19">pointee</code> property. Here (without further explanation) is an example from my own code:<a data-type="indexterm" data-primary="pointee" id="calibre_link-1698" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func popoverPresentationController(
    _ popoverPresentationController: UIPopoverPresentationController,
    willRepositionPopoverTo rect: UnsafeMutablePointer&lt;CGRect&gt;,
    in view: AutoreleasingUnsafeMutablePointer&lt;UIView&gt;) {
        view.pointee = self.button2
        rect.pointee = self.button2.bounds
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Reference Type Modifiable Parameters" class="calibre2"><div class="preface" id="calibre_link-2420">
<h2 class="calibre42">Reference Type Modifiable Parameters</h2>

<p class="author1">There is one very common situation where your function can modify a parameter <em class="calibre11">without</em> declaring it as <code class="calibre19">inout</code> &mdash; namely, when the parameter is an <em class="calibre11">instance of a class</em>. This is a special feature of classes, as opposed to the other two object type flavors, enum and struct. String isnâ€™t a class; itâ€™s a struct. Thatâ€™s why we had to use <code class="calibre19">inout</code> in order to modify a String parameter. So Iâ€™ll illustrate by declaring a Dog class with a <code class="calibre19">name</code> property:<a data-type="indexterm" data-primary="instances" data-secondary="mutating" id="calibre_link-1129" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutating an instance" id="calibre_link-1366" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="instances" data-tertiary="mutating" id="calibre_link-383" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
}</pre>

<p class="author1">Hereâ€™s a function that takes a Dog instance parameter and a String, and sets that Dog instanceâ€™s <code class="calibre19">name</code> to that String. Notice that no <code class="calibre19">inout</code> is involved:</p>

<pre data-type="programlisting" class="calibre28">func changeName(of d:Dog, to newName:String) {
    d.name = newName
}</pre>

<p class="author1">Hereâ€™s how to call it. We pass a Dog instance <em class="calibre11">directly</em>:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
d.name = "Fido"
print(d.name) // "Fido"
changeName(of:d, to:"Rover")
print(d.name) // "Rover"</pre>

<p class="author1">We were able to change a property of our Dog instance <code class="calibre19">d</code>, even though it wasnâ€™t passed as an <code class="calibre19">inout</code> parameter, and even though it was declared originally with <code class="calibre19">let</code>, not <code class="calibre19">var</code>. This appears to be an exception to the rules about modifying parameters &mdash; but it isnâ€™t. Itâ€™s a feature of class instances, namely that they are themselves mutable. In <code class="calibre19">changeName(of:to:)</code>, we didnâ€™t actually attempt to assign <em class="calibre11">a different Dog instance</em> to the parameter. To do that, the Dog parameter <em class="calibre11">would</em> need to be declared <code class="calibre19">inout</code> (and <code class="calibre19">d</code> would have to be declared with <code class="calibre19">var</code> and we would have to pass its address as argument).</p>

<p class="author1">Technically, we say that classes are <em class="calibre11">reference types</em>, whereas the other object type flavors are <em class="calibre11">value types</em>. When you pass an instance of a struct as an argument to a function, you effectively wind up with a <em class="calibre11">separate copy</em> of the struct instance. <span class="publishername">But when</span> you pass an instance of a class as an argument to a function, you <span class="publishername">pass a reference</span> to the class instance <em class="calibre11">itself</em>. Iâ€™ll discuss this topic in more detail later (<a data-type="xref" href="#calibre_link-65" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œValue Types and Reference Typesâ€</a>).</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Function in Function" class="calibre2"><div class="preface" id="calibre_link-2421">
<h1 class="calibre18">Function in Function</h1>

<p class="author1">A function can be declared anywhere, including inside the body of a function. A function declared in the body of a function (also called a <em class="calibre11">local function</em>) is available to be called by later code within the same scope, but is completely invisible elsewhere.<a data-type="indexterm" data-primary="functions" data-secondary="local" id="calibre_link-923" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="function in function" id="calibre_link-896" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">This feature is an elegant architecture for functions whose sole purpose is to assist another function. If only function A ever needs to call function B, function B might as well be packaged inside function A.</p>

<p class="author1">Hereâ€™s a typical example from one of my apps (Iâ€™ve omitted everything except the structure):</p>

<pre data-type="programlisting" class="calibre28">func checkPair(_ p1:Piece, and p2:Piece) -&gt; Path? {
    // ...
    func addPathIfValid(_ midpt1:Point, _ midpt2:Point) {
        // ...
    }
    for y in -1..._yct {
        addPathIfValid((pt1.x,y),(pt2.x,y))
    }
    for x in -1..._xct {
        addPathIfValid((x,pt1.y),(x,pt2.y))
    }
    // ...
}</pre>

<p class="author1">What Iâ€™m doing in the first for loop (<code class="calibre19">for y</code>) and what Iâ€™m doing in the second for loop (<code class="calibre19">for x</code>) are the same &mdash; but with a different set of starting values. We could write out the functionality in full inside each for loop, but that would be an unnecessary and confusing repetition. (Such a repetition would violate the principle often referred to as <em class="calibre11">DRY</em>, for â€œDonâ€™t Repeat Yourself.â€) To prevent that repetition, we could refactor the repeated code into an instance method to be called by both for loops, but that exposes this functionality more broadly than we need, as it is called <em class="calibre11">only</em> by these two for loops inside <code class="calibre19">checkPair</code>. A local function is the perfect compromise.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Local functions are really local variables with function values (a notion that Iâ€™ll explain later in this chapter). Therefore, a local function canâ€™t have the same name as a local variable in the same scope, and two local functions canâ€™t have the same name as one another in the same scope.</p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Recursion" class="calibre2"><div class="preface" id="calibre_link-2422">
<h1 class="calibre18">Recursion</h1>

<p class="author1">A function can call itself. This is called <em class="calibre11">recursion</em>. Recursion seems a little scary, rather like jumping off a cliff, because of the danger of creating an infinite loop; but if you write the function correctly, you will always have a â€œstopperâ€ condition that handles the degenerate case and prevents the loop from being infinite:<a data-type="indexterm" data-primary="recursion" id="calibre_link-1856" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="recursion" id="calibre_link-927" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func countDownFrom(_ ix:Int) {
    print(ix)
    if ix &gt; 0 { // stopper
        countDownFrom(ix-1) // recurse!
    }
}
countDownFrom(5) // 5, 4, 3, 2, 1, 0</pre>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Function As Value" class="calibre2"><div class="preface" id="calibre_link-2423">
<h1 class="calibre18">Function As Value</h1>

<p class="author1">If youâ€™ve never used a programming language where functions are first-class citizens, perhaps youâ€™d better sit down now, because what Iâ€™m about to tell you might make you feel a little faint: In Swift, a function <em class="calibre11">is</em> a first-class citizen. This means that a function can be used wherever a value can be used. A function can be assigned to a variable; a function can be passed as an argument in a function call; a function can be returned as the result of a function.<a data-type="indexterm" data-primary="functions" data-secondary="values" id="calibre_link-939" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" data-secondary="functions as" id="calibre_link-1670" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="functions as value of" id="calibre_link-2323" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="type" id="calibre_link-938" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="of function" id="calibre_link-2234" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swift has strict typing. You can assign a value to a variable or pass a value into or out of a function only if it is the right <em class="calibre11">type</em> of value. In order for a function to be used as a value, the function needs to <em class="calibre11">have</em> a type. And indeed it does: a functionâ€™s <em class="calibre11">signature</em> is its type.</p>

<p class="author1">The chief purpose of using a function as a value is so that this function can later be called without a definite knowledge of <em class="calibre11">what</em> function it is. Hereâ€™s the worldâ€™s simplest (and silliest) example, just to show the syntax and structure:</p>

<pre data-type="programlisting" class="calibre28">func doThis(_ f:() -&gt; ()) {
    f()
}</pre>

<p class="author1">That is a function <code class="calibre19">doThis</code> that takes one parameter (and returns no value). The parameter, <code class="calibre19">f</code>, is itself a function! How do we know? Well, look at its type (after the colon): it is <code class="calibre19">()&nbsp;-&gt;&nbsp;()</code>. Thatâ€™s a function signature; in particular, it is the signature of a function that takes no parameters and returns no value.</p>

<p class="author1">The function <code class="calibre19">doThis</code>, then, expects as its parameter a function, which it names <code class="calibre19">f</code>. Then, within its body, <code class="calibre19">doThis</code> <em class="calibre11">calls</em> the function <code class="calibre19">f</code> that it received as its parameter, by saying <code class="calibre19">f()</code>. So <code class="calibre19">doThis</code> is merely a function that trivially calls another function. But it does this without knowing in advance <em class="calibre11">what</em> function it is going to call. Thatâ€™s the power of functions being first-class citizens.</p>

<p class="author1">Having declared the function <code class="calibre19">doThis</code>, how would you call it? Youâ€™d need to pass it a function as argument. Hereâ€™s one way to do that:</p>

<pre data-type="programlisting" class="calibre28">func doThis(_ f:() -&gt; ()) {
    f()
}
func whatToDo() { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2767" href="#calibre_link-2765"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    print("I did it")
}
doThis(whatToDo) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2768" href="#calibre_link-2766"><img src="images/000008.png" alt="2" class="calibre39" /></a></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2765" href="#calibre_link-2767"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">First, we declare a function (<code class="calibre19">whatToDo</code>) <em class="calibre11">of the proper type</em> &mdash; a function that takes no parameters and returns no value.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2766" href="#calibre_link-2768"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Then, we call <code class="calibre19">doThis</code>, passing as argument a <em class="calibre11">function reference</em> &mdash; in effect, the bare name of the function. Notice that we are not <em class="calibre11">calling</em> <code class="calibre19">whatToDo</code> here; we are <em class="calibre11">passing</em> it.</p></dd>
</dl>

<p class="author1">Sure enough, this works: we pass <code class="calibre19">whatToDo</code> as argument to <code class="calibre19">doThis</code>; <code class="calibre19">doThis</code> calls the function that it receives as its parameter; and the string <code class="calibre19">"I did it"</code> appears in the console.</p>

<p class="author1">Obviously, that example, while demonstrating a remarkable ability of the Swift language, is far from compelling, because the outcome in practice is no different from what would have happened if we had simply called <code class="calibre19">whatToDo</code> directly. But in real life, encapsulating function-calling in a function can reduce repetition and opportunity for error. Moreover, a function may call its parameter function in some special way; for example, it might call it after doing other things, or at some later time.</p>

<p class="author1">Hereâ€™s a case from my own code. A common thing to do in Cocoa is to draw an image, directly, in code. One way of doing this involves four steps:</p>

<pre data-type="programlisting" class="calibre28">let size = CGSize(width:45, height:20)
UIGraphicsBeginImageContextWithOptions(size, false, 0) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2773" href="#calibre_link-2769"><img src="images/000019.png" alt="1" class="calibre39" /></a>
let p = UIBezierPath(
    roundedRect: CGRect(x:0, y:0, width:45, height:20), cornerRadius: 8)
p.stroke() <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2774" href="#calibre_link-2770"><img src="images/000008.png" alt="2" class="calibre39" /></a>
let result = UIGraphicsGetImageFromCurrentImageContext()! <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2775" href="#calibre_link-2771"><img src="images/000029.png" alt="3" class="calibre39" /></a>
UIGraphicsEndImageContext() <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2776" href="#calibre_link-2772"><img src="images/000014.png" alt="4" class="calibre39" /></a></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2769" href="#calibre_link-2773"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Open an image context.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2770" href="#calibre_link-2774"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Draw into the context.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2771" href="#calibre_link-2775"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Extract the image.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2772" href="#calibre_link-2776"><img src="images/000014.png" alt="4" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Close the image context.</p></dd>
</dl>

<p class="author1">That works &mdash; in this case, it generates an image of a rounded rectangle &mdash; but itâ€™s ugly. The sole purpose of all that code is to obtain <code class="calibre19">result</code>, the image; but that purpose is buried in all the other code. At the same time, everything except for the two lines involving the UIBezierPath <code class="calibre19">p</code> (step 2) is boilerplate; every time I do this in any app, step 1, step 3, and step 4 are exactly the same. Moreover, I live in mortal fear of forgetting a step; for example, if I were to omit step 4 by mistake, the universe would explode.</p>

<p class="author1">Since the only thing thatâ€™s different every time I draw is step 2, step 2 is the only part I should have to write out! The entire problem is solved by writing a utility function expressing the boilerplate:</p>

<pre data-type="programlisting" class="calibre28">func imageOfSize(_ size:CGSize, _ whatToDraw:() -&gt; ()) -&gt; UIImage {
    UIGraphicsBeginImageContextWithOptions(size, false, 0)
    whatToDraw()
    let result = UIGraphicsGetImageFromCurrentImageContext()!
    UIGraphicsEndImageContext()
    return result
}</pre>

<p class="author1">My <code class="calibre19">imageOfSize</code> utility is so useful that I declare it at the top level of a file, where all my files can see it. To make an image, I can perform step 2 (the actual drawing) in a function and pass that function as argument to the <code class="calibre19">imageOfSize</code> utility:</p>

<pre data-type="programlisting" class="calibre28">func drawing() {
    let p = UIBezierPath(
        roundedRect: CGRect(x:0, y:0, width:45, height:20),
        cornerRadius: 8)
    p.stroke()
}
let image = imageOfSize(CGSize(width:45, height:20), drawing)</pre>

<p class="author1">Now <em class="calibre11">that</em> is a beautifully expressive and clear way to turn drawing instructions into an image.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Evidently Apple agrees with my criticism of <code class="calibre19">UIGraphicsBeginImageContextWithOptions</code>, because in iOS 10 a new class was introduced, UIGraphicsImageRenderer, that expresses itself using syntax similar to my <code class="calibre19">imageOfSize</code>. Nevertheless, Iâ€™ll continue using <code class="calibre19">imageOfSize</code> in this chapter, because it illustrates important aspects of Swift functions.</p>
</div>

<p class="author1">The Cocoa API is full of situations where youâ€™ll pass a function to be called by the runtime in some special way or at some later time. Some common Cocoa situations even involve passing <em class="calibre11">two</em> functions. For instance, when you perform view animation, youâ€™ll often pass one function prescribing the action to be animated and another function saying what to do afterward:</p>

<pre data-type="programlisting" class="calibre28">func whatToAnimate() { // self.myButton is a button in the interface
    self.myButton.frame.origin.y += 20
}
func whatToDoLater(finished:Bool) {
    print("finished: \(finished)")
}
UIView.animate(withDuration:0.4,
    animations: whatToAnimate, completion: whatToDoLater)</pre>

<p class="author1">That means: Change the frame origin (that is, the position) of this button in the interface, but do it over time (four-tenths of a second); and then, when thatâ€™s finished, print a log message in the console saying whether the animation was performed or not.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The Cocoa documentation will often describe a function to be passed in this way as a <em class="calibre11">handler</em>, and will refer it as a <em class="calibre11">block</em>, because thatâ€™s the Objective-C syntactic construct needed here. In Swift, itâ€™s a function.<a data-type="indexterm" data-primary="blocks" data-secondary="C" id="calibre_link-261" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-primary="handlers" data-seealso="functions" id="calibre_link-996" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2902">
<h5 class="calibre36">Type Aliases Can Clarify Function Types</h5>
<p class="calibre37">To make function type specifiers clearer, we can take advantage of Swiftâ€™s type alias feature to give a function type a name. The name can be descriptive, and the possibly confusing arrow operator notation is avoided. For example, if we say <code class="calibre19">typealias VoidVoidFunction = () -&gt; ()</code>, we can then say <code class="calibre19">VoidVoidFunction</code> wherever we need to specify a function type with that signature:<a data-type="indexterm" data-primary="type alias" id="calibre_link-2244" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">typealias VoidVoidFunction = () -&gt; ()
func dothis(_ f:VoidVoidFunction) {
    f()
}</pre>
</div>
</aside>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Anonymous Functions" class="calibre2"><div class="preface" id="calibre_link-2424">
<h1 class="calibre18">Anonymous Functions</h1>

<p class="author1">Consider once again this example:<a data-type="indexterm" data-primary="functions" data-secondary="anonymous" id="calibre_link-901" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="anonymous functions" id="calibre_link-132" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func whatToAnimate() { // self.myButton is a button in the interface
    self.myButton.frame.origin.y += 20
}
func whatToDoLater(finished:Bool) {
    print("finished: \(finished)")
}
UIView.animate(withDuration:0.4,
    animations: whatToAnimate, completion: whatToDoLater)</pre>

<p class="author1">Thereâ€™s a slight bit of ugliness in that code. Iâ€™m declaring functions <code class="calibre19">whatToAnimate</code> and <code class="calibre19">whatToDoLater</code>, just because I want to pass those functions in the last line. But I donâ€™t really need the <em class="calibre11">names</em> <code class="calibre19">whatToAnimate</code> and <code class="calibre19">whatToDoLater</code> for anything, except to refer to them in the last line; neither the names nor the functions will ever be used again. In my call to <code class="calibre19">UIView.animate(withDuration:animations:completion:)</code>, it would be nice to be able to pass just the <em class="calibre11">body</em> of those functions <em class="calibre11">without</em> a declared name.</p>

<p class="author1">We can do that. A nameless function body is called an <em class="calibre11">anonymous</em> function, and is legal and common in Swift. To form an anonymous function, you do two things:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Create the function body itself, including the surrounding curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-581" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, but with no function declaration.</p>
</li>
<li class="calibre4">
<p class="calibre17">If necessary, express the functionâ€™s parameter list and return type as the first thing <em class="calibre11">inside</em> the curly braces, followed by the keyword <code class="calibre19">in</code>.<a data-type="indexterm" data-primary="parameter list" data-secondary="in anonymous function" id="calibre_link-1662" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="anonymous functions" data-secondary="parameter list and return type" id="calibre_link-136" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="return" data-secondary="value of anonymous function" id="calibre_link-1934" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="in" id="calibre_link-1048" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>

</ol>

<p class="author1">Letâ€™s practice by transforming our named function declarations into anonymous functions. Hereâ€™s the named function declaration for <code class="calibre19">whatToAnimate</code>:</p>

<pre data-type="programlisting" class="calibre28">func whatToAnimate() {
    self.myButton.frame.origin.y += 20
}</pre>

<p class="author1">Hereâ€™s an anonymous function that does the same thing. Notice how Iâ€™ve moved the parameter list and return type inside the curly braces:</p>

<pre data-type="programlisting" class="calibre28">{
    () -&gt; () in
    self.myButton.frame.origin.y += 20
}</pre>

<p class="author1">Hereâ€™s the named function declaration for <code class="calibre19">whatToDoLater</code>:</p>

<pre data-type="programlisting" class="calibre28">func whatToDoLater(finished:Bool) {
    print("finished: \(finished)")
}</pre>

<p class="author1">Hereâ€™s an anonymous function that does the same thing:</p>

<pre data-type="programlisting" class="calibre28">{
    (finished:Bool) -&gt; () in
    print("finished: \(finished)")
}</pre>








<section data-type="sect2" data-pdf-bookmark="Using Anonymous Functions Inline" class="calibre2"><div class="preface" id="calibre_link-2425">
<h2 class="calibre42">Using Anonymous Functions Inline</h2>

<p class="author1">Now that we know how to make anonymous functions, letâ€™s use them. The point where we need the functions is the point where weâ€™re passing the second and third arguments to <code class="calibre19">animate(withDuration:animations:completion:)</code>. We can create and pass anonymous functions <em class="calibre11">right at that point</em>, like this:</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        () -&gt; () in
        self.myButton.frame.origin.y += 20
    },
    completion: {
        (finished:Bool) -&gt; () in
        print("finished: \(finished)")
    }
)</pre>

<p class="author1">We can make the same improvement in the way we call the <code class="calibre19">imageOfSize</code> function from the preceding section. Earlier, we called that function like this:</p>

<pre data-type="programlisting" class="calibre28">func drawing() {
    let p = UIBezierPath(
        roundedRect: CGRect(x:0, y:0, width:45, height:20),
        cornerRadius: 8)
    p.stroke()
}
let image = imageOfSize(CGSize(width:45, height:20), drawing)</pre>

<p class="author1">We now know, however, that we donâ€™t need to declare the <code class="calibre19">drawing</code> function separately. We can call <code class="calibre19">imageOfSize</code> with an anonymous function:</p>

<pre data-type="programlisting" class="calibre28">let image = imageOfSize(CGSize(width:45, height:20), {
    () -&gt; () in
    let p = UIBezierPath(
        roundedRect: CGRect(x:0, y:0, width:45, height:20),
        cornerRadius: 8)
    p.stroke()
})</pre>

<p class="author1">Anonymous functions are very commonly used in Swift, so make sure you can read and write that code!</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Anonymous Function Abbreviated Syntax" class="calibre2"><div class="preface" id="calibre_link-2426">
<h2 class="calibre42">Anonymous Function Abbreviated Syntax</h2>

<p class="author1">Anonymous functions are so common and so important in Swift that some shortcuts for writing them are provided:<a data-type="indexterm" data-primary="anonymous functions" data-secondary="abbreviated syntax" id="calibre_link-133" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Omission of the return type</dt>
<dd class="calibre16">
<p class="calibre17">If the anonymous functionâ€™s return type is already known to the compiler, you can omit the arrow operator and the specification of the return type:</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        () in // *
        self.myButton.frame.origin.y += 20
    }, completion: {
        (finished:Bool) in // *
        print("finished: \(finished)")
})</pre>

<p class="calibre17">(Occasionally the compiler will fail to infer the anonymous functionâ€™s return type, even though you think it should be obvious, and will give a compile error. If that happens, just donâ€™t use this shortcut: supply an <code class="calibre19">in</code> expression with an explicit return type.)<a data-type="indexterm" data-primary="errors, compiler" data-secondary="unable to infer return type" id="calibre_link-803" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Omission of the <code class="calibre19">in</code> expression when there are no parameters</dt>
<dd class="calibre16">
<p class="calibre17">If the anonymous function takes no parameters, and if the return type can be omitted, the <code class="calibre19">in</code> expression itself can be omitted:</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: { // *
        self.myButton.frame.origin.y += 20
    }, completion: {
        (finished:Bool) in
        print("finished: \(finished)")
})</pre>
</dd>
<dt class="calibre15">Omission of the parameter types</dt>
<dd class="calibre16">
<p class="calibre17">If the anonymous function takes parameters and their types are already known to the compiler, the types can be omitted:</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        self.myButton.frame.origin.y += 20
    }, completion: {
        (finished) in // *
        print("finished: \(finished)")
})</pre>
</dd>
<dt class="calibre15">Omission of the parentheses</dt>
<dd class="calibre16">
<p class="calibre17">If the parameter types are omitted, the parentheses around the parameter list can be omitted:</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        self.myButton.frame.origin.y += 20
    }, completion: {
        finished in // *
        print("finished: \(finished)")
})</pre>
</dd>
<dt class="calibre15">Omission of the <code class="calibre19">in</code> expression even when there are parameters</dt>
<dd class="calibre16">
<p class="calibre17">If the return type can be omitted, and if the parameter types are already known to the compiler, you can omit the <code class="calibre19">in</code> expression and refer to the parameters directly within the body of the anonymous function by using the magic names <code class="calibre19">$0</code>, <code class="calibre19">$1</code>, and so on, in order:</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        self.myButton.frame.origin.y += 20
    }, completion: {
        print("finished: \($0)") // *
})</pre>
</dd>
<dt class="calibre15">Omission of the parameter names</dt>
<dd class="calibre16">
<p class="calibre17">If the anonymous function body doesnâ€™t need to refer to a parameter, you can substitute an underscore for its name in the parameter list in the <code class="calibre19">in</code> expression:<a data-type="indexterm" data-primary="underscore" data-secondary="parameter name" data-tertiary="anonymous function" id="calibre_link-2274" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        self.myButton.frame.origin.y += 20
    }, completion: {
        _ in // *
        print("finished!")
})</pre>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If an anonymous function takes parameters, you <em class="calibre11">must</em> acknowledge all of them somehow. You can omit the <code class="calibre19">in</code> expression and use the parameters by the magic names <code class="calibre19">$0</code> and so on. Or you can keep the <code class="calibre19">in</code> expression and give the parameters names or ignore them with underscores. But you canâ€™t omit the <code class="calibre19">in</code> expression and <em class="calibre11">not</em> use the parameters by their magic names! If you do, your code wonâ€™t compile.</p>
</div>
<dl class="calibre14">
<dt class="calibre15">Omission of the function argument label</dt>
<dd class="calibre16">
<p class="calibre17">If, as will just about always be the case, your anonymous function is the <em class="calibre11">last</em> argument being passed in this function call, you can close the function call with a right parenthesis <em class="calibre11">before</em> this last argument, and then put just the anonymous function body <em class="calibre11">without a label</em> (this is called a <em class="calibre11">trailing function</em>):<a data-type="indexterm" data-primary="trailing function" id="calibre_link-2222" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="trailing" id="calibre_link-937" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="anonymous functions" data-secondary="trailing" id="calibre_link-139" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration:0.4,
    animations: {
        self.myButton.frame.origin.y += 20
    }) { // *
        _ in
        print("finished!")
}</pre>
</dd>
<dt class="calibre15">Omission of the calling function parentheses</dt>
<dd class="calibre16">
<p class="calibre17">If you use the trailing function syntax, and if the function you are calling takes no parameters other than the function you are passing to it, you can omit the empty parentheses from the call. This is the <em class="calibre11">only</em> situation in which you can omit the parentheses from a function call! To illustrate, Iâ€™ll declare and call a different function:<a data-type="indexterm" data-primary="parameter list" data-secondary="omitting" id="calibre_link-1663" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func doThis(_ f:() -&gt; ()) {
    f()
}
doThis { // no parentheses!
    print("Howdy")
}</pre>
</dd>
<dt class="calibre15">Omission of the keyword <code class="calibre19">return</code></dt>
<dd class="calibre16">
<p class="calibre17">If the anonymous function body consists of exactly one statement consisting of returning a value with the keyword <code class="calibre19">return</code>, the keyword <code class="calibre19">return</code> can be omitted (and in this situation, I like to do so):<a data-type="indexterm" data-primary="return" data-secondary="omitting" id="calibre_link-1933" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func greeting() -&gt; String {
    return "Howdy"
}
func performAndPrint(_ f:()-&gt;String) {
    let s = f()
    print(s)
}
performAndPrint {
    greeting() // meaning: return greeting()
}</pre>
</dd>
</dl>

<p class="author1">When writing anonymous functions, you will frequently find yourself taking advantage of all the omissions you are permitted. In addition, youâ€™ll sometimes shorten the <em class="calibre11">layout</em> of the code (though not the code itself) by putting the whole anonymous function together with the function call <em class="calibre11">on one line</em>. Thus, Swift code involving anonymous functions can be extremely compact.</p>

<p class="author1">Hereâ€™s a typical example. We start with an array of Int values and generate a new array consisting of all those values multiplied by 2, by calling the <code class="calibre19">map(_:)</code> instance method. The <code class="calibre19">map(_:)</code> method of an array takes a function that takes one parameter of the same type as the arrayâ€™s elements, and returns a new value; here, our array is made of Int values, and we are passing to the <code class="calibre19">map(_:)</code> method a function that takes one Int parameter and returns an Int. We could write out the whole function, like this:</p>

<pre data-type="programlisting" class="calibre28">let arr = [2, 4, 6, 8]
func doubleMe(i:Int) -&gt; Int {
    return i*2
}
let arr2 = arr.map(doubleMe) // [4, 8, 12, 16]</pre>

<p class="author1">That, however, is not very Swifty. We donâ€™t need the name <code class="calibre19">doubleMe</code> for anything else, so this may as well be an anonymous function:</p>

<pre data-type="programlisting" class="calibre28">let arr = [2, 4, 6, 8]
let arr2 = arr.map ({
    (i:Int) -&gt; Int in
    return i*2
})</pre>

<p class="author1">Now letâ€™s abbreviate our anonymous function. Its parameter type is known in advance, so we donâ€™t need to specify that. Its return type is known by inspection of the function body, so we donâ€™t need to specify that. Thereâ€™s just one parameter and we are going to use it, so we donâ€™t need the <code class="calibre19">in</code> expression as long we refer to the parameter as <code class="calibre19">$0</code>. Our function body consists of just one statement, and it is a return statement, so we can omit <code class="calibre19">return</code>. And <code class="calibre19">map(_:)</code> doesnâ€™t take any other parameters, so we can omit the parentheses and follow the name directly with a trailing function:</p>

<pre data-type="programlisting" class="calibre28">let arr = [2, 4, 6, 8]
let arr2 = arr.map{$0*2}</pre>

<p class="author1">It doesnâ€™t get any Swiftier than that!</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Define-and-Call" class="calibre2"><div class="preface" id="calibre_link-2427">
<h1 class="calibre18">Define-and-Call</h1>

<p class="author1">A pattern thatâ€™s surprisingly common in Swift is to define an anonymous function and call it, all in one move:<a data-type="indexterm" data-primary="anonymous functions" data-secondary="define-and-call" id="calibre_link-135" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="define-and-call" id="calibre_link-637" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="define-and-call" id="calibre_link-914" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">{
    // ... code goes here
}()</pre>

<p class="author1">Notice the parentheses after the curly braces! The curly braces <em class="calibre11">define</em> an anonymous function body; the parentheses <em class="calibre11">call</em> that anonymous function. I call this construct <em class="calibre11">define-and-call.</em></p>

<p class="author1">Using define-and-call, an action can be taken at the point where it is needed, rather than in a series of preparatory steps. For example, hereâ€™s a common Cocoa situation where we create and configure an NSMutableParagraphStyle and then use it as an argument in a call to the NSMutableAttributedString method <code class="calibre19">addAttribute(_:value:range:)</code>, like this:</p>

<pre data-type="programlisting" class="calibre28">let para = NSMutableParagraphStyle()
para.headIndent = 10
para.firstLineHeadIndent = 10
// ... more configuration of para ...
content.addAttribute( // content is an NSMutableAttributedString
    .paragraphStyle,
    value:para,
    range:NSRange(location:0, length:1))</pre>

<p class="author1">I find that code ugly. We donâ€™t need <code class="calibre19">para</code> except to pass it as the <code class="calibre19">value:</code> argument within the call to <code class="calibre19">addAttribute(_:value:range:)</code>, so it would be much nicer to create and configure it right there within the call, as the <code class="calibre19">value:</code> argument itself. That sounds like an anonymous function &mdash; except that the <code class="calibre19">value:</code> parameter is not a function, but an NSMutableParagraphStyle object. We can solve the problem by providing, as the <code class="calibre19">value:</code> argument, an anonymous function that <em class="calibre11">produces</em> an NSMutableParagraphStyle object <em class="calibre11">and calling it</em> so that it <em class="calibre11">does</em> produce an NSMutableParagraphStyle object:</p>

<pre data-type="programlisting" class="calibre28">content.addAttribute(
    .paragraphStyle,
    value: {
        let para = NSMutableParagraphStyle()
        para.headIndent = 10
        para.firstLineHeadIndent = 10
        // ... more configuration of para ...
        return para
    }(),
    range:NSRange(location:0, length:1))</pre>

<p class="author1">Iâ€™ll demonstrate some further uses of define-and-call in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Closures" class="calibre2"><div class="preface" id="calibre_link-2428">
<h1 class="calibre18">Closures</h1>

<p class="author1">Swift functions are <em class="calibre11">closures</em>. This means they can <em class="calibre11">capture</em> references to external variables in scope within the body of the function. What do I mean by that? Well, recall from <a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a> that code in curly braces constitutes a scope, and this code can â€œseeâ€ variables and functions declared in a surrounding scope. For example:<a data-type="indexterm" data-primary="captured variable references" id="calibre_link-337" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="closures" id="calibre_link-909" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-secondary="captured variable references" id="calibre_link-405" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-seealso="anonymous functions" id="calibre_link-403" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var whatThisDogSays = "woof" <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2779" href="#calibre_link-2777"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    func bark() {
        print(self.whatThisDogSays) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2780" href="#calibre_link-2778"><img src="images/000008.png" alt="2" class="calibre39" /></a>
    }
}</pre>

<p class="author1">In that code:</p>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2777" href="#calibre_link-2779"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The variable <code class="calibre19">whatThisDogSays</code> is <em class="calibre11">external</em> to the function: it is <em class="calibre11">declared outside</em> the body of the function, and yet is <em class="calibre11">in scope</em> for the body of the function, so that the code inside the body of the function can see it.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2778" href="#calibre_link-2780"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The code inside the body of the function <em class="calibre11">refers</em> to the external variable <code class="calibre19">whatThisDogSays</code> &mdash; it says, explicitly, <code class="calibre19">whatThisDogSays</code>.</p></dd>
</dl>

<p class="author1">So far, so good; but we now know that the function <code class="calibre19">bark</code> can be passed as a value. In effect, it can travel from one environment to another. When it does, what happens to that reference to <code class="calibre19">whatThisDogSays</code>? Letâ€™s find out:</p>

<pre data-type="programlisting" class="calibre28">func doThis(_ f : () -&gt; ()) {
    f()
}
let d = Dog()
d.whatThisDogSays = "arf"
let barkFunction = d.bark
doThis(barkFunction) // arf</pre>

<p class="author1">We run that code, and <code class="calibre19">"arf"</code> appears in the console!</p>

<p class="author1">Perhaps that result doesnâ€™t seem very surprising to you. But think about it. We do not directly <em class="calibre11">call</em> <code class="calibre19">d.bark()</code>. We make a Dog instance and <em class="calibre11">pass</em> its <code class="calibre19">bark</code> function as a value into the function <code class="calibre19">doThis</code>. There, it is called. Now, <code class="calibre19">whatThisDogSays</code> is an instance property of a particular Dog. Inside the function <code class="calibre19">doThis</code> there is no <code class="calibre19">whatThisDogSays</code>. Indeed, inside the function <code class="calibre19">doThis</code> there is no Dog instance! Nevertheless the call <code class="calibre19">f()</code> still works. The function <code class="calibre19">d.bark</code>, as it is passed around, evidently <em class="calibre11">carries</em> the variable <code class="calibre19">whatThisDogSays</code> along with itself.</p>

<p class="author1">But thereâ€™s more. Iâ€™ll change the example by moving the line where we set <code class="calibre19">d.whatThisDogSays</code> to <em class="calibre11">after</em> we assign <code class="calibre19">d.bark</code> into our variable <code class="calibre19">barkFunction</code>:</p>

<pre data-type="programlisting" class="calibre28">func doThis(_ f : () -&gt; ()) {
    f()
}
let d = Dog()
let barkFunction = d.bark     <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2785" href="#calibre_link-2781"><img src="images/000019.png" alt="1" class="calibre39" /></a>
doThis(barkFunction) // woof  <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2786" href="#calibre_link-2782"><img src="images/000008.png" alt="2" class="calibre39" /></a>
d.whatThisDogSays = "arf"     <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2787" href="#calibre_link-2783"><img src="images/000029.png" alt="3" class="calibre39" /></a>
doThis(barkFunction) // arf   <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2788" href="#calibre_link-2784"><img src="images/000014.png" alt="4" class="calibre39" /></a></pre>

<p class="author1">What just happened?</p>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2781" href="#calibre_link-2785"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">We assigned <code class="calibre19">d.bark</code> to <code class="calibre19">barkFunction</code>, once and for all; after that, we never changed <code class="calibre19">barkFunction</code>.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2782" href="#calibre_link-2786"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">At that time, <code class="calibre19">d.whatThisDogSays</code> was <code class="calibre19">"woof"</code>, so we passed <code class="calibre19">barkFunction</code> into <code class="calibre19">doThis</code> and got <code class="calibre19">"woof"</code>.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2783" href="#calibre_link-2787"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">We then changed <code class="calibre19">d.whatThisDogSays</code> to <code class="calibre19">"arf"</code>. We didnâ€™t change <code class="calibre19">barkFunction</code>.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2784" href="#calibre_link-2788"><img src="images/000014.png" alt="4" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">We passed <code class="calibre19">barkFunction</code> into <code class="calibre19">doThis</code> again, and this time we got <code class="calibre19">"arf"</code>!</p></dd>
</dl>

<p class="author1">After creating both <code class="calibre19">d</code> and <code class="calibre19">barkFunction</code>, changing a property of the Dog <code class="calibre19">d</code> changes the output of calling <code class="calibre19">barkFunction</code>! How can this be? Evidently, after step 1, when <code class="calibre19">d.bark</code> has been assigned to <code class="calibre19">barkFunction</code>, <em class="calibre11">both</em> our Dog variable <code class="calibre19">d</code> <em class="calibre11">and</em> the function <code class="calibre19">barkFunction</code> are holding references to the same Dog instance. This is because <code class="calibre19">d.bark</code>, which we assigned to <code class="calibre19">barkFunction</code>, refers to <code class="calibre19">self</code>, which <em class="calibre11">is</em> the Dog instance. Thatâ€™s what we mean when we say that a function is a closure and that it <em class="calibre11">captures</em> external variables referred to in its body.</p>








<section data-type="sect2" data-pdf-bookmark="How Closures Improve Code" class="calibre2"><div class="preface" id="calibre_link-2429">
<h2 class="calibre42">How Closures Improve Code</h2>

<p class="author1">You can use the fact that functions are closures to make your code more general, and hence more useful. To illustrate, here, once again, is my earlier example of a function that accepts drawing instructions and performs them to generate an image:</p>

<pre data-type="programlisting" class="calibre28">func imageOfSize(_ size:CGSize, _ whatToDraw:() -&gt; ()) -&gt; UIImage {
    UIGraphicsBeginImageContextWithOptions(size, false, 0)
    whatToDraw()
    let result = UIGraphicsGetImageFromCurrentImageContext()!
    UIGraphicsEndImageContext()
    return result
}</pre>

<p class="author1">As you know, we can call <code class="calibre19">imageOfSize</code> with a trailing anonymous function:</p>

<pre data-type="programlisting" class="calibre28">let image = imageOfSize(CGSize(width:45, height:20)) {
    let p = UIBezierPath(
        roundedRect: CGRect(x:0, y:0, width:45, height:20),
        cornerRadius: 8)
    p.stroke()
}</pre>

<p class="author1">That code, however, contains an annoying repetition. This is a call to create an image of a given size consisting of a rounded rectangle of that size. We are repeating the size; the pair of numbers <code class="calibre19">45,20</code> appears twice. Thatâ€™s silly. Letâ€™s prevent the repetition by putting the size into a variable at the outset:</p>

<pre data-type="programlisting" class="calibre28">let sz = CGSize(width:45, height:20)
let image = imageOfSize(sz) {
    let p = UIBezierPath(
        roundedRect: CGRect(origin:CGPoint.zero, size:sz),
        cornerRadius: 8)
    p.stroke()
}</pre>

<p class="author1">The variable <code class="calibre19">sz</code>, declared outside our anonymous function at a higher level, is visible inside it. Thus we can refer to it inside the anonymous function &mdash; and we do so. The anonymous function is just a function body; it wonâ€™t be <em class="calibre11">executed</em> until <code class="calibre19">imageOfSize</code> calls it. Nevertheless, in the fourth line, in the expression <code class="calibre19">CGRect(origin:CGPoint.zero, size:sz)</code>, when we refer to <code class="calibre19">sz</code> from inside the function body, we capture its value <em class="calibre11">now</em>, because the function body is a closure.
Thus, when <code class="calibre19">imageOfSize</code> calls <code class="calibre19">whatToDraw</code>, and <code class="calibre19">whatToDraw</code> turns out to be a function whose body refers to a variable <code class="calibre19">sz</code>, thereâ€™s no problem, even though there is no <code class="calibre19">sz</code> anywhere in the neighborhood of <code class="calibre19">imageOfSize</code>.</p>

<p class="author1">Now letâ€™s go further. So far, weâ€™ve been hard-coding the size of the desired rounded rectangle. Imagine, though, that creating images of rounded rectangles of various sizes is something we do often. It would make sense to package this code up as a function, where <code class="calibre19">sz</code> is not a fixed value but a parameter; the function will then return the image:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangle(_ sz:CGSize) -&gt; UIImage {
    let image = imageOfSize(sz) {
        let p = UIBezierPath(
            roundedRect: CGRect(origin:CGPoint.zero, size:sz),
            cornerRadius: 8)
        p.stroke()
    }
    return image
}</pre>

<p class="author1">Incredibly, that works! The parameter <code class="calibre19">sz</code> that arrives into <code class="calibre19">makeRoundedRectangle</code> is no longer a hard-coded value; we donâ€™t know what it will be. Nevertheless, when <code class="calibre19">makeRoundedRectangle</code> is called, <code class="calibre19">sz</code> <em class="calibre11">will</em> have a value, and the anonymous function captures <code class="calibre19">sz</code>, so when <code class="calibre19">imageOfSize</code> calls the anonymous function, <code class="calibre19">sz</code> inside that function will have the <code class="calibre19">sz</code> value that was passed to <code class="calibre19">makeRoundedRectangle</code>.</p>

<p class="author1">Our code is becoming beautifully compact. To call <code class="calibre19">makeRoundedRectangle</code>, supply a size; an image is returned. Thus, I can perform the call, obtain the image, and display that image, all in one move, like this (<code class="calibre19">self.iv</code> is a UIImageView in the interface):</p>

<pre data-type="programlisting" class="calibre28">self.iv.image = makeRoundedRectangle(CGSize(width:45, height:20))</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Function Returning Function" class="calibre2"><div class="preface" id="calibre_link-2430">
<h2 class="calibre42">Function Returning Function</h2>

<p class="author1">But now letâ€™s go even further! Instead of returning an image, our function can return <em class="calibre11">a function</em> that makes rounded rectangles <em class="calibre11">of the specified size</em>. If youâ€™ve never seen a function returned as a value from a function, you may now be gasping for breath. But a function, after all, can be used as a value. We have already passed a function <em class="calibre11">into</em> a function as an argument in the function call; now we are going to receive a function <em class="calibre11">from</em> a function call as its result:<a data-type="indexterm" data-primary="functions" data-secondary="returned from function" id="calibre_link-933" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="return" data-secondary="function from function" id="calibre_link-1931" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-secondary="returned from function" id="calibre_link-410" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; () -&gt; UIImage { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2792" href="#calibre_link-2789"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    func f () -&gt; UIImage { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2793" href="#calibre_link-2790"><img src="images/000008.png" alt="2" class="calibre39" /></a>
        let im = imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: 8)
            p.stroke()
        }
        return im
    }
    return f <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2794" href="#calibre_link-2791"><img src="images/000029.png" alt="3" class="calibre39" /></a>
}</pre>

<p class="author1">Letâ€™s analyze that code slowly:</p>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2789" href="#calibre_link-2792"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The declaration is the hardest part. What on earth is the type (signature) of this function <code class="calibre19">makeRoundedRectangleMaker</code>? It is <code class="calibre19">(CGSize) -&gt; () -&gt; UIImage</code>. That expression has <em class="calibre11">two</em> arrow operators. To understand it, keep in mind that everything after each arrow operator is the type of a returned value. So <code class="calibre19">makeRoundedRectangleMaker</code> is a function that takes a CGSize parameter and returns a <code class="calibre19">() -&gt; UIImage</code>. Okay, and whatâ€™s a <code class="calibre19">() -&gt; UIImage</code>? We already know that: itâ€™s a function that takes no parameters and returns a UIImage. So <code class="calibre19">makeRoundedRectangleMaker</code> is a function that takes a CGSize parameter and returns <em class="calibre11">a function</em> &mdash; a function that itself, when called with <em class="calibre11">no</em> parameters, will return a UIImage.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2790" href="#calibre_link-2793"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Now here we are in the body of the function <code class="calibre19">makeRoundedRectangleMaker</code>, and our first step is to declare a function (a function-in-function, or local function) of precisely the type we intend to return, namely, one that takes no parameters and returns a UIImage. Here, weâ€™re naming this function <code class="calibre19">f</code>. The way this function works is simple and familiar: it calls <code class="calibre19">imageOfSize</code>, passing it an anonymous function that makes an image of a rounded rectangle (<code class="calibre19">im</code>) &mdash; and then it returns the image.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2791" href="#calibre_link-2794"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Finally, we <em class="calibre11">return</em> the function we just made (<code class="calibre19">f</code>). We have thus fulfilled our contract: we said we would return a function that takes no parameters and returns a UIImage, and we do so.</p></dd>
</dl>

<p class="author1">But perhaps you are still gazing open-mouthed at <code class="calibre19">makeRoundedRectangleMaker</code>, wondering how you would ever call it and what you would get if you did. Letâ€™s try it:</p>

<pre data-type="programlisting" class="calibre28">let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20))</pre>

<p class="author1">What is the variable <code class="calibre19">maker</code> after that code runs? Itâ€™s a <em class="calibre11">function</em> &mdash; a function that takes no parameters and that, when called, produces the image of a rounded rectangle of size <code class="calibre19">45,20</code>. You donâ€™t believe me? Iâ€™ll prove it &mdash; by <em class="calibre11">calling</em> the function that is now the value of <code class="calibre19">maker</code>:</p>

<pre data-type="programlisting" class="calibre28">let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20))
self.iv.image = maker()</pre>

<p class="author1">Now that youâ€™ve gotten over your stunned surprise at the notion of a function that produces a function as its result, turn your attention once again to the implementation of <code class="calibre19">makeRoundedRectangleMaker</code> and letâ€™s analyze it again, a different way. Remember, I didnâ€™t write that function to show you that a function can produce a function. I wrote it to illustrate closures! Letâ€™s think about how the environment gets captured:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; () -&gt; UIImage {
    func f () -&gt; UIImage {
        let im = imageOfSize(sz) { // *
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz), // *
                cornerRadius: 8)
            p.stroke()
        }
        return im
    }
    return f
}</pre>

<p class="author1">The function <code class="calibre19">f</code> takes no parameters. Yet, twice within the function body of <code class="calibre19">f</code> (Iâ€™ve marked the places with asterisk comments), there are references to a size value <code class="calibre19">sz</code>. The body of the function <code class="calibre19">f</code> can see <code class="calibre19">sz</code>, the parameter of the surrounding function <code class="calibre19">makeRoundedRectangleMaker</code>, because it is in a surrounding scope. The function <code class="calibre19">f</code> <em class="calibre11">captures</em> the reference to <code class="calibre19">sz</code> at the time <code class="calibre19">makeRoundedRectangleMaker</code> is called, and <em class="calibre11">keeps</em> that reference when <code class="calibre19">f</code> is returned and assigned to <code class="calibre19">maker</code>:</p>

<pre data-type="programlisting" class="calibre28">let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20))</pre>

<p class="author1">That is why <code class="calibre19">maker</code> is now a function that, when it is called, creates and returns an image of the particular size <code class="calibre19">45,20</code> even though it itself will be called <em class="calibre11">with no parameters</em>. The knowledge of what size of image to produce has been <em class="calibre11">baked into</em> the function referred to by <code class="calibre19">maker</code>. Looking at it another way, <code class="calibre19">makeRoundedRectangleMaker</code> is a <em class="calibre11">factory</em> for creating a whole family of functions similar to <code class="calibre19">maker</code>, each of which produces an image of one particular size. Thatâ€™s a dramatic illustration of the power of closures.<a data-type="indexterm" data-primary="factory" data-secondary="for functions" id="calibre_link-841" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Before I leave <code class="calibre19">makeRoundedRectangleMaker</code>, Iâ€™d like to rewrite it in a Swiftier fashion. Within <code class="calibre19">f</code>, there is no need to create <code class="calibre19">im</code> and then return it; we can return the result of calling <code class="calibre19">imageOfSize</code> directly:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; () -&gt; UIImage {
    func f () -&gt; UIImage {
        return imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: 8)
            p.stroke()
        }
    }
    return f
}</pre>

<p class="author1">But there is no need to declare <code class="calibre19">f</code> and then return it either; it can be an anonymous function and we can return it directly:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; () -&gt; UIImage {
    return {
        return imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: 8)
            p.stroke()
        }
    }
}</pre>

<p class="author1">But our anonymous function consists of just one statement, returning the result of the call to <code class="calibre19">imageOfSize</code>. (The anonymous function parameter to <code class="calibre19">imageOfSize</code> consists of multiple statements, but the <code class="calibre19">imageOfSize</code> call itself is still just one Swift statement.) Thus there is no need to say <code class="calibre19">return</code>:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; () -&gt; UIImage {
    return {
        imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: 8)
            p.stroke()
        }
    }
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Closure Setting a Captured Variable" class="calibre2"><div class="preface" id="calibre_link-2431">
<h2 class="calibre42">Closure Setting a Captured Variable</h2>

<p class="author1">The power that a closure gets through its ability to capture its environment is even greater than Iâ€™ve shown so far. If a closure captures a reference to a variable outside itself, and if that variable is settable, <em class="calibre11">the closure can set the variable</em>.<a data-type="indexterm" data-primary="captured variable references" data-secondary="setting" id="calibre_link-339" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-secondary="captured variable references" data-tertiary="setting" id="calibre_link-407" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s say Iâ€™ve declared this simple function. All it does is to accept a function that takes an Int parameter, and to call that function with an argument of 100:</p>

<pre data-type="programlisting" class="calibre28">func pass100 (_ f:(Int) -&gt; ()) {
    f(100)
}</pre>

<p class="author1">Now, look closely at this code and try to guess what will happen when we run it:</p>

<pre data-type="programlisting" class="calibre28">var x = 0
print(x) // ?
func setX(newX:Int) {
    x = newX
}
pass100(setX)
print(x) // ?</pre>

<p class="author1">The first <code class="calibre19">print(x)</code> call obviously produces <code class="calibre19">0</code>. The second <code class="calibre19">print(x)</code> call produces <code class="calibre19">100</code>! The <code class="calibre19">pass100</code> function has reached into my code and <em class="calibre11">changed</em> the value of my variable <code class="calibre19">x</code>. Thatâ€™s because the function <code class="calibre19">setX</code> that I passed to <code class="calibre19">pass100</code> contains a reference to <code class="calibre19">x</code>; not only does it contain it, but it captures it; not only does it capture it, but it sets its value. That <code class="calibre19">x</code> <em class="calibre11">is my <code class="calibre22">x</code></em>. Thus, <code class="calibre19">pass100</code> was able to set my <code class="calibre19">x</code> just as readily as I would have set it by calling <code class="calibre19">setX</code> directly.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Closure Preserving Captured Environment" class="calibre2"><div class="preface" id="calibre_link-2432">
<h2 class="calibre42">Closure Preserving Captured Environment</h2>

<p class="author1">When a closure captures its environment, it <em class="calibre11">preserves</em> that environment <em class="calibre11">even if nothing else does</em>. Hereâ€™s an example calculated to blow your mind &mdash; a function that modifies a function:<a data-type="indexterm" data-primary="captured variable references" data-secondary="preserving" id="calibre_link-338" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-secondary="captured variable references" data-tertiary="preserving" id="calibre_link-406" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func countAdder(_ f: @escaping () -&gt; ()) -&gt; () -&gt; () {
    var ct = 0
    return {
        ct = ct + 1
        print("count is \(ct)")
        f()
    }
}</pre>

<p class="author1">The function <code class="calibre19">countAdder</code> accepts a function as its parameter and returns a function as its result. (Iâ€™ll explain the <code class="calibre19">@escaping</code> attribute in the next section.) The function that it returns calls the function that it accepts, with a little bit added: it increments a variable and reports the result. So now try to guess what will happen when we run this code:</p>

<pre data-type="programlisting" class="calibre28">func greet () {
    print("howdy")
}
let countedGreet = countAdder(greet)
countedGreet() // ?
countedGreet() // ?
countedGreet() // ?</pre>

<p class="author1">What weâ€™ve done here is to take a function <code class="calibre19">greet</code>, which prints <code class="calibre19">"howdy"</code>, and pass it through <code class="calibre19">countAdder</code>. What comes out the other side of <code class="calibre19">countAdder</code> is a new function, which weâ€™ve named <code class="calibre19">countedGreet</code>. We then call <code class="calibre19">countedGreet</code> three times. Hereâ€™s what appears in the console:</p>

<pre data-type="programlisting" class="calibre28">count is 1
howdy
count is 2
howdy
count is 3
howdy</pre>

<p class="author1">Clearly, <code class="calibre19">countAdder</code> has added to the functionality of the function that was passed into it <em class="calibre11">the ability to report how many times it is called</em>. Now ask yourself: Where on earth is the variable that maintains this count? Inside <code class="calibre19">countAdder</code>, it was a local variable <code class="calibre19">ct</code>. But it isnâ€™t declared inside the anonymous function that <code class="calibre19">countAdder</code> returns. Thatâ€™s deliberate! If it <em class="calibre11">were</em> declared inside the anonymous function, we would be setting <code class="calibre19">ct</code> to <code class="calibre19">0</code> every time <code class="calibre19">countedGreet</code> is called &mdash; we wouldnâ€™t be counting. Instead, <code class="calibre19">ct</code> is initialized to <code class="calibre19">0</code> once <em class="calibre11">and then captured</em> by the anonymous function. This variable is thus preserved as part of the <em class="calibre11">environment</em> of <code class="calibre19">countedGreet</code> &mdash; it is <em class="calibre11">outside</em> <code class="calibre19">countedGreet</code> in some mysterious environment-preserving world, so that it can be incremented every time <code class="calibre19">countedGreet</code> is called.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Escaping Closures" class="calibre2"><div class="preface" id="calibre_link-2433">
<h2 class="calibre42">Escaping Closures</h2>

<p class="author1">If a function passed around as a value will be preserved for later execution, rather than being called directly, it is a closure that captures and preserves its environment <em class="calibre11">over time</em>. Thatâ€™s called an <em class="calibre11">escaping</em> closure. In some situations, the functionâ€™s type must be explicitly marked <code class="calibre19">@escaping</code>. The compiler will detect violations of this rule, so if you find the rule confusing, donâ€™t worry about it; just let the compiler enforce it for you.<a data-type="indexterm" data-primary="escaping" id="calibre_link-807" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-secondary="escaping" id="calibre_link-408" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So, for example, this function is legal because it receives a function and calls it directly:</p>

<pre data-type="programlisting" class="calibre28">func funcCaller(f:() -&gt; ()) {
    f()
}</pre>

<p class="author1">And this function is legal, even though it returns a function to be executed later, because it also <em class="calibre11">creates</em> that function internally. The function that it returns <em class="calibre11">is</em> an escaping closure, but the type of the functionâ€™s returned value does not have to be marked as <code class="calibre19">@escaping</code>:</p>

<pre data-type="programlisting" class="calibre28">func funcMaker() -&gt; () -&gt; () {
    return { print("hello world") }
}</pre>

<p class="author1">But this function is illegal. It receives a function as a parameter <em class="calibre11">and</em> returns that function to be executed later:</p>

<pre data-type="programlisting" class="calibre28">func funcPasser(f:() -&gt; ()) -&gt; () -&gt; () { // compile error
    return f
}</pre>

<p class="author1">The solution is to mark the type of the incoming parameter <code class="calibre19">f</code> as <code class="calibre19">@escaping</code>, and the compiler will prompt you to do so:</p>

<pre data-type="programlisting" class="calibre28">func funcPasser(f:@escaping () -&gt; ()) -&gt; () -&gt; () {
    return f
}</pre>

<p class="author1">A secondary feature of escaping closures is that, whenever you refer to a property or method of <code class="calibre19">self</code> within the function body, the compiler will insist that you say <code class="calibre19">self</code> explicitly. Thatâ€™s because such a reference <em class="calibre11">captures</em> <code class="calibre19">self</code>, and the compiler wants you to acknowledge this fact by <em class="calibre11">saying</em> <code class="calibre19">self</code>.<a data-type="indexterm" data-primary="self" data-secondary="in escaping functions" id="calibre_link-1975" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxclosures" id="calibre_link-404" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Curried Functions" class="calibre2"><div class="preface" id="calibre_link-2434">
<h1 class="calibre18">Curried Functions</h1>

<p class="author1">Return once more to <code class="calibre19">makeRoundedRectangleMaker</code>:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; () -&gt; UIImage {
    return {
        imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: 8)
            p.stroke()
        }
    }
}</pre>

<p class="author1">Thereâ€™s something I donâ€™t like about this method: the size of the rounded rectangle that it creates is a parameter (<code class="calibre19">sz</code>), but the <code class="calibre19">cornerRadius</code> of the rounded rectangle is hard-coded as <code class="calibre19">8</code>. Iâ€™d like the ability to pass a value for the corner radius as part of the call. I can think of two ways to do that. One is to give <code class="calibre19">makeRoundedRectangleMaker</code> itself another parameter:<a data-type="indexterm" data-primary="functions" data-secondary="curried" id="calibre_link-910" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="currying" id="calibre_link-592" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize, _ r:CGFloat) -&gt; () -&gt; UIImage {
    return {
        imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: r)
            p.stroke()
        }
    }
}</pre>

<p class="author1">And we would then call it like this:</p>

<pre data-type="programlisting" class="calibre28">let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20), 8)</pre>

<p class="author1">But thereâ€™s another way. The function that we are returning from <code class="calibre19">makeRoundedRectangleMaker</code> takes no parameters. Instead, <em class="calibre11">it</em> could take the extra parameter:</p>

<pre data-type="programlisting" class="calibre28">func makeRoundedRectangleMaker(_ sz:CGSize) -&gt; (CGFloat) -&gt; UIImage {
    return { r in
        imageOfSize(sz) {
            let p = UIBezierPath(
                roundedRect: CGRect(origin:CGPoint.zero, size:sz),
                cornerRadius: r)
            p.stroke()
        }
    }
}</pre>

<p class="author1">Now <code class="calibre19">makeRoundedRectangleMaker</code> returns a function that, itself, takes one parameter, so we must remember to supply that when we call it:</p>

<pre data-type="programlisting" class="calibre28">let maker = makeRoundedRectangleMaker(CGSize(width:45, height:20))
self.iv.image = maker(8)</pre>

<p class="author1">If we donâ€™t need to conserve <code class="calibre19">maker</code> for anything, we can of course do all that in one line &mdash; a function call that yields a function which we immediately call to obtain our image:</p>

<pre data-type="programlisting" class="calibre28">self.iv.image = makeRoundedRectangleMaker(CGSize(width:45, height:20))(8)</pre>

<p class="author1">When a function returns a function that takes a parameter in this way, it is called a <em class="calibre11">curried</em> function (after the computer scientist Haskell Curry).</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Function References and Selectors" class="calibre2"><div class="preface" id="calibre_link-2435">
<h1 class="calibre18">Function References and Selectors</h1>

<p class="author1">When you want to refer to a function by name &mdash; for example, in order to pass it as argument to another function &mdash; you can often use its bare name. Thatâ€™s what Iâ€™ve been doing throughout this chapter, in examples like this:<a data-type="indexterm" data-primary="references" data-secondary="to functions" id="calibre_link-1870" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="reference" id="calibre_link-928" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func whatToAnimate() { // self.myButton is a button in the interface
    self.myButton.frame.origin.y += 20
}
func whatToDoLater(finished:Bool) {
    print("finished: \(finished)")
}
UIView.animate(withDuration:0.4,
    animations: whatToAnimate, completion: whatToDoLater) // *</pre>

<p class="author1">A bare name like <code class="calibre19">whatToAnimate</code> or <code class="calibre19">whatToDoLater</code> is a <em class="calibre11">function reference</em>. Use of the bare name as a function reference is legal when itâ€™s unambiguous: thus, in this particular context, thereâ€™s only one function called <code class="calibre19">whatToDoLater</code> in scope, and Iâ€™m using its name as argument in a function call where the parameter type is known (namely, <code class="calibre19">(Bool) -&gt; ()</code>).</p>

<p class="author1">But now consider the following situation. Just as I can pass a function as an argument, I can assign a function as a value to a variable. And suppose I have <em class="calibre11">two</em> functions with the same name, one that takes a parameter, and one that doesnâ€™t:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        print("woof")
    }
    func bark(_ loudly:Bool) {
        if loudly {
            print("WOOF")
        } else {
            self.bark()
        }
    }
    func test() {
        let barkFunction = bark // compile error
        // ...
    }
}</pre>

<p class="author1">That code wonâ€™t compile, because the bare name <code class="calibre19">bark</code> is ambiguous in this context: which <code class="calibre19">bark</code> method does it refer to? To solve this problem, Swift provides a notation allowing you to refer to a function more precisely. This notation has two parts:</p>
<dl class="calibre14">
<dt class="calibre15">Full name</dt>
<dd class="calibre16">
<p class="calibre17">The full name of a Swift function is the name that precedes the parentheses, plus parentheses containing the external names of its parameters, each followed by colon. If the external name of a parameter is suppressed, we represent its external name as an underscore.<a data-type="indexterm" data-primary="underscore" data-secondary="parameter name" id="calibre_link-2273" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> For example, a function declared <code class="calibre19">func say(_&nbsp;s:String, times:Int)</code> has the full name <code class="calibre19">say(_:times:)</code>.</p>
</dd>
<dt class="calibre15">Signature</dt>
<dd class="calibre16">
<p class="calibre17">The signature of a Swift function may be appended to its bare name (or full name) with the keyword <code class="calibre19">as</code>. For example, a function declared <code class="calibre19">func say(_&nbsp;s:String, times:Int)</code> may be referred to as <code class="calibre19">say as (String,Int) -&gt; ()</code>.</p>
</dd>
</dl>

<p class="author1">In our <code class="calibre19">bark</code> example, use of the full name solves the problem if the function to which we want a reference is the one that takes a parameter:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        // ... as before ...
    }
    func bark(loudly:Bool) {
        // ... as before ...
    }
    func test() {
        let barkFunction = bark(_:) // fine
    }
}</pre>

<p class="author1">But use of the full name <em class="calibre11">doesnâ€™t</em> solve the problem if the function to which we want a reference is the one that takes <em class="calibre11">no</em> parameters, because in that case the full name is the bare name, which is exactly whatâ€™s ambiguous in this context. Use of the signature solves the problem:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        // ... as before ...
    }
    func bark(loudly:Bool) {
        // ... as before ...
    }
    func test() {
        let barkFunction = bark as () -&gt; () // fine
    }
}</pre>

<p class="author1">Obviously, an explicit signature is needed also when a function is <em class="calibre11">overloaded</em>:</p>

<pre data-type="programlisting" class="calibre28">class Dog{
    func bark() {
    }
    func bark(_ loudly:Bool) {
    }
    func bark(_ times:Int) {
    }
    func test() {
        let barkFunction = bark(_:) // compile error
    }
}</pre>

<p class="author1">Here, we have said that we want the <code class="calibre19">bark</code> that takes one parameter, but there are <em class="calibre11">two</em> such <code class="calibre19">bark</code> functions, one whose parameter is a Bool, the other whose parameter is an Int. The signature disambiguates (and we can use the bare name):</p>

<pre data-type="programlisting" class="calibre28">let barkFunction = bark as (Int) -&gt; () // "times", not "loudly"</pre>








<section data-type="sect2" data-pdf-bookmark="Function Reference Scope" class="calibre2"><div class="preface" id="calibre_link-2436">
<h2 class="calibre42">Function Reference Scope</h2>

<p class="author1">In the foregoing examples of function references, there was no need to tell the compiler <em class="calibre11">where</em> the function is defined. Thatâ€™s because the function is already in scope at the point where the function reference appears. If you can <em class="calibre11">call</em> the function without supplying further information, you can form the function <em class="calibre11">reference</em> without supplying further information.</p>

<p class="author1">However, a function reference <em class="calibre11">can</em> supply further information about where a function is defined; and sometimes it <em class="calibre11">must</em> do so. This is done by prefixing an instance or class to the function reference, using dot-notation. For example, there are situations where the compiler would force you to use <code class="calibre19">self</code> to call a function; in those situations, you will have to use <code class="calibre19">self</code> to refer to the function as well:<a data-type="indexterm" data-primary="dot-notation" data-secondary="function references" id="calibre_link-705" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
    }
    func bark(_ loudly:Bool) {
    }
    func test() {
        let f = {
            return self.bark(_:) // self required here
        }
    }
}</pre>

<p class="author1">To form a function reference to an instance method of another type, you have two choices. If you have on hand an instance of that type, you can use dot-notation with a reference to that instance:</p>

<pre data-type="programlisting" class="calibre28">class Cat {
    func purr() {
    }
}
class Dog {
    let cat = Cat()
    func test() {
        let purrFunction = cat.purr
    }
}</pre>

<p class="author1">The other possibility is to use <em class="calibre11">the type</em> with dot-notation (this works even if the function is an instance method):</p>

<pre data-type="programlisting" class="calibre28">class Cat {
    func purr() {
    }
}
class Dog {
    func bark() {
    }
    func test() {
        let barkFunction = Dog.bark // legal but not necessary
        let purrFunction = Cat.purr
    }
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Selectors" class="calibre2"><div class="preface" id="calibre_link-2437">
<h2 class="calibre42">Selectors</h2>

<p class="author1">In Objective-C, a selector is a kind of method reference. In iOS programming, you might have to call a Cocoa method that wants a selector as one of its parameters; typically, this parameter will be named either <code class="calibre19">selector:</code> or <code class="calibre19">action:</code>. Usually, such a method also requires that you provide a <em class="calibre11">target</em> (an object reference); the idea is that the runtime can later call the method by turning the selector into a message and sending that message to that target.<a data-type="indexterm" data-primary="selectors" id="calibre_link-1972" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="selectors" id="calibre_link-1351" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="crash" data-secondary="unrecognized selector" id="calibre_link-571" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Unfortunately, this architecture can be extremely risky. The reason is that to form the selector, it is necessary to construct a string representing a methodâ€™s Objective-C name. If you construct that string incorrectly, then when the time comes to send the message to the target, the runtime will find that the target canâ€™t handle that message, because it has no such method, and the app comes to a violent and premature halt, dumping into the console the dreaded phrase â€œunrecognized selector.â€</p>

<p class="author1">For example, hereâ€™s a typical recipe for failure:</p>

<pre data-type="programlisting" class="calibre28">class ViewController : UIViewController {
    @IBOutlet var button : UIButton!
    func viewDidLoad() {
        super.viewDidLoad()
        self.button.addTarget( // prepare to crash!
            self, action: "buttonPressed", for: .touchUpInside)
    }
    @objc func buttonPressed(_ sender: Any) {
        // ...
    }
}</pre>

<p class="author1">In that code, <code class="calibre19">self.button</code> is a button in the interface, and we are configuring it by calling <code class="calibre19">addTarget(action:for:)</code>, so that when the button is tapped, our <code class="calibre19">buttonPressed</code> method will be called. But we are configuring it incorrectly! Unfortunately, <code class="calibre19">"buttonPressed"</code> is <em class="calibre11">not</em> the Objective-C name of our <code class="calibre19">buttonPressed</code> method; the correct name would have been <code class="calibre19">"buttonPressed:"</code>, with a colon. (Iâ€™ll explain why in <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>.) Therefore, our app will crash when the user taps that button.</p>

<p class="author1">The point is that if you donâ€™t know the rules for forming a selector string &mdash; or even if you do, but you make a typing mistake &mdash; an â€œunrecognized selectorâ€ crash is likely to result. Humans are fallible, and therefore â€œunrecognized selectorâ€ crashes have historically been extremely common among iOS programmers. The Swift compiler, however, is <em class="calibre11">not</em> fallible in this way. Therefore, Swift provides a way to let the compiler form the selector for you, by means of <code class="calibre19">#selector</code> syntax.</p>

<p class="author1">To ask the compiler to form an Objective-C selector for you, you use <code class="calibre19">#selector(...)</code> with a function reference inside the parentheses. Thus, we would rewrite our button action example like this:</p>

<pre data-type="programlisting" class="calibre28">class ViewController : UIViewController {
    @IBOutlet var button : UIButton!
    func viewDidLoad() {
        super.viewDidLoad()
        self.button.addTarget(
            self, action: #selector(buttonPressed), for: .touchUpInside)
    }
    @objc func buttonPressed(_ sender: Any) {
        // ...
    }
}</pre>

<p class="author1">When you use that notation, two wonderful things happen:</p>
<dl class="calibre14">
<dt class="calibre15">The compiler validates the function reference</dt>
<dd class="calibre16">
<p class="calibre17">If your function reference isnâ€™t valid, your code wonâ€™t even compile. The compiler also checks that this function is exposed to Objective-C; thereâ€™s no point forming a selector for a method that Objective-C canâ€™t see, as your app would crash if Objective-C were to try to call such a method. To ensure Objective-C visibility, the method may need to be marked with the <code class="calibre19">@objc</code> attribute; the compiler will enforce this requirement.<a data-type="indexterm" data-primary="objc" id="calibre_link-1478" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">The compiler forms the Objective-C selector for you</dt>
<dd class="calibre16">
<p class="calibre17">If your code compiles, the actual selector that will be passed into this parameter is guaranteed to be correct. <em class="calibre11">You</em> might form the selector incorrectly, but the compiler wonâ€™t! Thus, it is impossible that the resulting selector should fail to match the method, and there is no chance of an â€œunrecognized selectorâ€ crash.</p>
</dd>
</dl>

<p class="author1">Very rarely, you still might need to create a selector manually. To do so, you can use a string, or you can instantiate Selector with the string as argument &mdash; for example, <code class="calibre19">Selector("woohoo:")</code>.</p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">You can still crash, even with <code class="calibre19">#selector</code> syntax, by sending an action message to the <em class="calibre11">wrong target</em>. In the preceding example, if you changed <code class="calibre19">self</code>, the first argument of the <code class="calibre19">addTarget</code> call, to <code class="calibre19">self.button</code>, youâ€™d crash at runtime with â€œunrecognized selectorâ€ &mdash; because the <code class="calibre19">buttonPressed</code> method is declared in ViewController, not in UIButton. Unfortunately, the compiler wonâ€™t help you with this kind of mistake.<a data-type="indexterm" data-startref="idxfunctions" id="calibre_link-900" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>





</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2795">
<div id="calibre_link-2903" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 3. Variables and Simple Types" class="calibre2"><div class="preface" id="calibre_link-58">
<h1 class="calibre13"><span class="label">Chapter 3. </span>Variables and Simple Types</h1>


<p class="author1">A variable is a named â€œshoeboxâ€ whose contained value must be of a single well-defined type. Every variable must be explicitly and formally declared. To put a value into the shoebox, thus causing the variable name to <em class="calibre11">refer</em> to that value, you <em class="calibre11">assign</em> the value to the variable. The variable name becomes a <em class="calibre11">reference</em> to that value.<a data-type="indexterm" data-primary="reference" id="calibre_link-1862" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">This chapter goes into detail about declaration and initialization of variables. It <span class="publishername">then discusses</span> all the primary built-in Swift simple types. (I mean â€œsimpleâ€ as opposed <span class="publishername">to collections;</span> the primary built-in collection types are discussed at the end of <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>.)<a data-type="indexterm" data-primary="variables" id="calibre_link-2316" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Variable Scope and Lifetime" class="calibre2"><div class="preface" id="calibre_link-2438">
<h1 class="calibre18">Variable Scope and Lifetime</h1>

<p class="author1">A variable not only gives its referent a name; it also, by virtue of <em class="calibre11">where</em> it is declared, endows its referent with a particular scope (visibility) and lifetime. (See <a data-type="xref" href="#calibre_link-2400" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œScope and Lifetimeâ€</a>.) Assigning a value to a variable is a way of ensuring that this value can be <em class="calibre11">seen</em> by code that needs to see it and that it <em class="calibre11">persists</em> long enough to serve its purpose.<a data-type="indexterm" data-primary="variables" data-secondary="scope" id="calibre_link-2334" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="lifetime" id="calibre_link-2331" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="scope" data-secondary="variable" id="calibre_link-1958" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> There are three distinct levels of variable scope and lifetime: <a data-type="indexterm" data-primary="properties" data-seealso="variables" id="calibre_link-1741" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Global variables</dt>
<dd class="calibre16">
<p class="calibre17">A global variable, or simply a <em class="calibre11">global</em>, is a variable declared at the top level of a Swift file. A global variable lives as long as the file lives, which is as long as the program runs. A global variable is visible everywhere (thatâ€™s what â€œglobalâ€ means). It is visible to all code within the <em class="calibre11">same</em> file, because it is at top level; any other code in the same file is therefore at the same level or at a lower contained level of scope. Moreover, it is visible (by default) to all code within any <em class="calibre11">other</em> file in the same module, because Swift files in the same module can automatically see one another, and hence can see one anotherâ€™s top levels:<a data-type="indexterm" data-primary="variables" data-secondary="global" id="calibre_link-2325" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="global variables" id="calibre_link-981" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// File1:
let globalVariable = "global"
class Dog {
    func printGlobal() {
        print(globalVariable) // *
    }
}
// File2:
class Cat {
    func printGlobal() {
        print(globalVariable) // *
    }
}</pre>
</dd>
<dt class="calibre15">Properties</dt>
<dd class="calibre16">
<p class="calibre17">A <em class="calibre11">property</em> is a variable declared at the top level of an object type declaration (an enum, struct, or class). There are two kinds of properties: instance properties and static/class properties.</p>
<div class="preface"><dl class="calibre14">
<dt class="calibre15">Instance properties</dt>
<dd class="calibre16">
<p class="calibre17">By default, a property is an <em class="calibre11">instance</em> property. Its value can differ for each instance of this object type, as I explained in <a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>. Its lifetime is the same as the lifetime of the instance. An instance comes into existence through deliberate instantiation of an object type; the subsequent lifetime of the instance, and hence of its instance properties, depends primarily on the lifetime of the variable to which the instance <em class="calibre11">itself</em> is assigned.</p>
</dd>
<dt class="calibre15">Static/class properties</dt>
<dd class="calibre16">
<p class="calibre17">A property is a static/class property if its declaration is preceded by the keyword <code class="calibre19">static</code> or <code class="calibre19">class</code>. (Iâ€™ll go into detail about those terms in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>.) Its lifetime is the same as the lifetime of the object type. If the object type is declared at the top level of a file, the property lives as long as the program runs.</p>
</dd>
</dl>
</div>


<p class="calibre17">A property is visible to code <em class="calibre11">inside</em> the object declaration. For example, an objectâ€™s methods can see that objectâ€™s properties. Such code can refer to the property using dot-notation with <code class="calibre19">self</code>, and I always do this as a matter of style, but <code class="calibre19">self</code> can usually be omitted except for purposes of disambiguation. An instance property is also visible (by default) to other code, provided the other code has a reference to this instance; in that case, the property can be referred to through dot-notation with the instance reference. A static/class property is visible (by default) to other code that can see the name of this object type; in that case, it can be referred to through dot-notation with the object type:
<a data-type="indexterm" data-primary="properties" data-secondary="instance" id="calibre_link-1762" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="static" id="calibre_link-1773" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="class" id="calibre_link-1744" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instance" data-secondary="properties" id="calibre_link-1110" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static properties" id="calibre_link-2071" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="class" data-secondary="properties" id="calibre_link-367" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// File1:
class Dog {
    static let staticProperty = "staticProperty"
    let instanceProperty = "instanceProperty"
    func printInstanceProperty() {
        print(self.instanceProperty) // *
    }
}
// File2:
class Cat {
    func printDogStaticProperty() {
        print(Dog.staticProperty) // *
    }
    func printDogInstanceProperty() {
        let d = Dog()
        print(d.instanceProperty) // *
    }
}</pre>
</dd>
<dt class="calibre15">Local variables</dt>
<dd class="calibre16">
<p class="calibre17">A local variable is a variable declared inside a function body. A local variable lives only as long as its surrounding curly-braces scope lives: it comes into existence when the path of execution passes into the scope and reaches the variable declaration, and it goes out of existence when the path of execution exits the scope. Local variables are sometimes called <em class="calibre11">automatic</em>, to signify that they come into and go out of existence automatically. A local variable can be seen only by subsequent code within the same scope (including a subsequent deeper scope within the same scope):
<a data-type="indexterm" data-primary="variables" data-secondary="local" id="calibre_link-2332" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="local variables" id="calibre_link-1244" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="automatic variables" id="calibre_link-235" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func printLocalVariable() {
        let localVariable = "local"
        print(localVariable) // *
    }
}</pre>
</dd>
</dl>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Variable Declaration" class="calibre2"><div class="preface" id="calibre_link-2439">
<h1 class="calibre18">Variable Declaration</h1>

<p class="author1">A variable is declared with <code class="calibre19">let</code> or <code class="calibre19">var</code>:<a data-type="indexterm" data-primary="variables" data-secondary="declaration" id="calibre_link-2321" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="constants" id="calibre_link-539" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initialization" id="calibre_link-1072" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of variables" id="calibre_link-632" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="let" id="calibre_link-1221" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="var" id="calibre_link-2313" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">With <code class="calibre19">let</code>, the variable becomes a <em class="calibre11">constant</em> &mdash; its value can never be changed after the first assignment of a value.</p>
</li>
<li class="calibre12">
<p class="calibre17">With <code class="calibre19">var</code>, the variable is a true variable, and its value can be changed by subsequent assignment.</p>
</li>
</ul>

<p class="author1">A variable declaration is usually accompanied by <em class="calibre11">initialization</em> &mdash; you use an equal sign to assign the variable a value, as part of the declaration. That, however, is not a requirement; it is legal to declare a variable without immediately initializing it.</p>

<p class="author1">What is <em class="calibre11">not</em> legal is to declare a variable without giving it a <em class="calibre11">type.</em> A variable <em class="calibre11">must</em> have a type from the outset, and that type can <em class="calibre11">never be changed</em>. A variable declared with <code class="calibre19">var</code> can have its <em class="calibre11">value</em> changed by subsequent assignment, but the new value must conform to the variableâ€™s fixed type.</p>

<p class="author1">You can give a variable a type explicitly or implicitly:<a data-type="indexterm" data-primary="variables" data-secondary="type" id="calibre_link-2339" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="of variable" id="calibre_link-2239" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Explicit variable type declaration</dt>
<dd class="calibre16">
<p class="calibre17">After the variableâ€™s name in the declaration, add a colon and the name of the type:<a data-type="indexterm" data-primary="colon" data-secondary="variable type" id="calibre_link-468" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var x : Int</pre>
</dd>
<dt class="calibre15">Implicit variable type by initialization</dt>
<dd class="calibre16">
<p class="calibre17">If you initialize the variable as part of the declaration, and if you provide no explicit type, Swift will <em class="calibre11">infer</em> its type, based on the value with which it is initialized:</p>

<pre data-type="programlisting" class="calibre28">var x = 1 // and now x is an Int</pre>
</dd>
</dl>

<p class="author1">It is perfectly possible to declare a variableâ€™s type explicitly <em class="calibre11">and</em> assign it an initial value, all in one move:<a data-type="indexterm" data-primary="inferred variable type" id="calibre_link-1059" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="explicit variable type" id="calibre_link-822" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var x : Int = 1</pre>

<p class="author1">In that example, the explicit type declaration is superfluous, because the type (Int) would have been inferred from the initial value. Sometimes, however, providing an explicit type, even while also assigning an initial value, is <em class="calibre11">not</em> superfluous. Here are the main situations where thatâ€™s the case:</p>
<dl class="calibre14">
<dt class="calibre15">Swiftâ€™s inference would be wrong</dt>
<dd class="calibre16">
<p class="calibre17">A very common case in my own code is when I want to provide the initial value as a numeric literal. Swift will infer either Int or Double, depending on whether the literal contains a decimal point. But there are a lot of other numeric types! When I mean one of those, I will provide the type explicitly, like this:</p>

<pre data-type="programlisting" class="calibre28">let separator : CGFloat = 2.0</pre>
</dd>
<dt class="calibre15">Swift canâ€™t infer the type</dt>
<dd class="calibre16">
<p class="calibre17">Sometimes, the type of the initial value is completely unknown to the compiler unless you tell it. A very common case involves option sets (discussed in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>). This wonâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">var opts = [.autoreverse, .repeat] // compile error</pre>

<p class="calibre17">The problem is that Swift doesnâ€™t know the type of <code class="calibre19">.autoreverse</code> and <code class="calibre19">.repeat</code> unless we tell it:</p>

<pre data-type="programlisting" class="calibre28">let opts : UIView.AnimationOptions = [.autoreverse, .repeat]</pre>
</dd>
<dt class="calibre15">The programmer canâ€™t infer the type</dt>
<dd class="calibre16">
<p class="calibre17">I frequently include a superfluous explicit type declaration as a kind of note to myself. Hereâ€™s an example from my own code:</p>

<pre data-type="programlisting" class="calibre28">let duration : CMTime = track.timeRange.duration</pre>

<p class="calibre17">In that code, <code class="calibre19">track</code> is an AVAssetTrack. Swift knows perfectly well that the <code class="calibre19">duration</code> property of an AVAssetTrackâ€™s <code class="calibre19">timeRange</code> property is a CMTime. But I donâ€™t! In order to remind myself of that fact, Iâ€™ve shown the type explicitly.</p>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Even if the compiler can infer a variableâ€™s type correctly from its initial value, such inference takes time. You can reduce compilation times by providing your variable declarations with explicit types.</p>
</div>

<p class="author1">As Iâ€™ve already said, a variable doesnâ€™t have to be initialized when it is declared &mdash; even if the variable is a constant. It is legal to write this:</p>

<pre data-type="programlisting" class="calibre28">let x : Int</pre>

<p class="author1">Now <code class="calibre19">x</code> is an empty shoebox &mdash; an Int variable without an initial value. You can assign this variable an initial value later. Since this particular variable is a constant, that initial value will be its only value from then on.</p>

<p class="author1">In the case of an instance property of an object (at the top level of an enum, struct, or class declaration), that sort of thing is quite normal, because the property can be initialized in the objectâ€™s initializer function. (Iâ€™ll have more to say about that in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>.) For a local variable, however, such behavior is unusual, and I strongly urge you to avoid it. It isnâ€™t a disaster &mdash; the Swift compiler will stop you from trying to use a variable that has never been assigned a value &mdash; but itâ€™s not a good habit. A local variable should generally be initialized as part of its declaration.</p>

<p class="author1">The exception that proves the rule is what we might call <em class="calibre11">conditional initialization</em>. Sometimes, we donâ€™t <em class="calibre11">know</em> a variableâ€™s initial value until weâ€™ve performed some sort of conditional test. The variable itself, however, can be declared only once; so it must be declared in advance and conditionally initialized afterward. This sort of thing is not unreasonable:<a data-type="indexterm" data-primary="initialization" data-secondary="conditional" id="calibre_link-1073" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conditional initialization" id="calibre_link-517" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let timed : Bool
if val == 1 {
    timed = true
} else {
    timed = false
}</pre>

<p class="author1">That particular example can arguably be better expressed in other ways (which Iâ€™ll come to in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>), but there are situations where conditional initialization is the cleanest approach.</p>

<p class="author1">When a variableâ€™s <em class="calibre11">address</em> is to be passed as argument to a function, the variable must be declared <em class="calibre11">and initialized</em> beforehand, even if the initial value is fake. Recall this example from <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>:</p>

<pre data-type="programlisting" class="calibre28">var r : CGFloat = 0
var g : CGFloat = 0
var b : CGFloat = 0
var a : CGFloat = 0
c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</pre>

<p class="author1">After that code runs, our four CGFloat <code class="calibre19">0</code> values will have been replaced; they were just momentary placeholders, to satisfy the compiler.</p>

<p class="author1">On rare occasions, youâ€™ll want to call a Cocoa method that returns a value immediately and later uses that value in a function passed to that same method. For example, Cocoa has a UIApplication instance method declared like this:<a data-type="indexterm" data-primary="UIBackgroundTaskIdentifier" id="calibre_link-2253" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func beginBackgroundTask(
    expirationHandler handler: (() -&gt; Void)? = nil)
        -&gt; UIBackgroundTaskIdentifier</pre>

<p class="author1"><code class="calibre19">beginBackgroundTask(expirationHandler:)</code> returns an identifier object, and will later call the <code class="calibre19">expirationHandler:</code> function passed to it &mdash; a function in which you will want to <em class="calibre11">use</em> the identifier object that was returned at the outset. Swiftâ€™s safety rules wonâ€™t let you declare the variable that holds this identifier and use it in an anonymous function all in the same statement:</p>

<pre data-type="programlisting" class="calibre28">let bti = UIApplication.shared.beginBackgroundTask {
    UIApplication.shared.endBackgroundTask(bti)
} // error: variable used within its own initial value</pre>

<p class="author1">Therefore, you need to declare the variable beforehand; but then Swift has another complaint:</p>

<pre data-type="programlisting" class="calibre28">var bti : UIBackgroundTaskIdentifier
bti = UIApplication.shared.beginBackgroundTask {
    UIApplication.shared.endBackgroundTask(bti)
} // error: variable captured by a closure before being initialized</pre>

<p class="author1">One solution is to declare the variable beforehand with a fake initial value as a placeholder:</p>

<pre data-type="programlisting" class="calibre28">var bti : UIBackgroundTaskIdentifier = .invalid
bti = UIApplication.shared.beginBackgroundTask {
    UIApplication.shared.endBackgroundTask(bti)
}</pre>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Computed Variable Initializer" class="calibre2"><div class="preface" id="calibre_link-2440">
<h1 class="calibre18">Computed Variable Initializer</h1>

<p class="author1">Sometimes, youâ€™d like to run several lines of code in order to compute a variableâ€™s initial value. A simple and compact way to express this is with a define-and-call anonymous function (see <a data-type="xref" href="#calibre_link-2427" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œDefine-and-Callâ€</a>). Iâ€™ll illustrate by rewriting an earlier example:<a data-type="indexterm" data-primary="computed initializer" id="calibre_link-504" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let timed : Bool = {
    if val == 1 {
        return true
    } else {
        return false
    }
}()</pre>

<p class="author1">You can do the same thing when youâ€™re initializing an instance property. For example, hereâ€™s a class with an image (a UIImage) that Iâ€™m going to need many times later on. It makes sense to create this image in advance as a constant instance property of the class. To create it means to draw it. That takes several lines of code. So I declare and initialize the property by defining and calling an anonymous function, like this (for my <code class="calibre19">imageOfSize</code> utility, see <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>):</p>

<pre data-type="programlisting" class="calibre28">class RootViewController : UITableViewController {
    let cellBackgroundImage : UIImage = {
        return imageOfSize(CGSize(width:320, height:44)) {
            // ... drawing goes here ...
        }
    }()
    // ... rest of class goes here ...
}</pre>

<p class="author1">You might ask: Instead of a define-and-call initializer, why donâ€™t I declare an instance method and initialize the instance property by calling that method? The reason is that thatâ€™s illegal:</p>

<pre data-type="programlisting" class="calibre28">class RootViewController : UITableViewController {
    let cellBackgroundImage : UIImage = self.makeTheImage() // compile error
    func makeTheImage() -&gt; UIImage {
        return imageOfSize(CGSize(width:320, height:44)) {
            // ... drawing goes here ...
        }
    }
}</pre>

<p class="author1">The problem is that, at the time of initializing the instance property, there is no instance yet &mdash; the instance is what we are in the process of creating. Therefore you canâ€™t refer to <code class="calibre19">self</code> (implicitly or explictly) in a property declarationâ€™s initializer. A define-and-call anonymous function, however, is legal.<a data-type="indexterm" data-primary="properties" data-secondary="computed initialization" id="calibre_link-1750" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Even so, <em class="calibre11">within</em> this define-and-call anonymous function you <em class="calibre11">still</em> canâ€™t refer to <code class="calibre19">self</code>; Iâ€™ll provide a workaround a little later in this chapter.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Computed Variables" class="calibre2"><div class="preface" id="calibre_link-2441">
<h1 class="calibre18">Computed Variables</h1>

<p class="author1">The variables Iâ€™ve been describing so far in this chapter have all been <em class="calibre11">stored</em> variables. The named shoebox analogy applies: a value can be put into the shoebox by assigning it to the variable, and it then sits there and can be retrieved later by referring to the variable, for as long the variable lives.<a data-type="indexterm" data-primary="stored variables" id="calibre_link-2077" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="stored" id="calibre_link-2336" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="computed variables" id="calibre_link-506" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="computed" id="calibre_link-2319" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">But a variable in Swift can work in a completely different way: it can be <em class="calibre11">computed</em>. This means that the variable, instead of having a value, has <em class="calibre11">functions</em>. One function, the <em class="calibre11">setter</em>, is called when the variable is assigned to. The other function, the <em class="calibre11">getter</em>, is called when the variable is referred to. Hereâ€™s some code illustrating schematically the syntax for declaring a computed <span class="publishername">variable:</span><a data-type="indexterm" data-primary="setter" id="calibre_link-2019" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="getter" id="calibre_link-970" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var now : String { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2801" href="#calibre_link-2796"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    get { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2802" href="#calibre_link-2797"><img src="images/000008.png" alt="2" class="calibre39" /></a>
        return Date().description <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2803" href="#calibre_link-2798"><img src="images/000029.png" alt="3" class="calibre39" /></a>
    }
    set { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2804" href="#calibre_link-2799"><img src="images/000014.png" alt="4" class="calibre39" /></a>
        print(newValue) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2805" href="#calibre_link-2800"><img src="images/000021.png" alt="5" class="calibre39" /></a>
    }
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2796" href="#calibre_link-2801"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The variable must be declared with <code class="calibre19">var</code> (not <code class="calibre19">let</code>). Its type must be declared explicitly. The type is followed immediately by curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-582" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2797" href="#calibre_link-2802"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The getter function is called <code class="calibre19">get</code>. There is no formal function declaration; the word <code class="calibre19">get</code> is simply followed immediately by a function body in curly braces.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2798" href="#calibre_link-2803"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The getter function must return a value of the same type as the variable. When the getter is a single statement, it is legal to omit the keyword <code class="calibre19">return</code> (new in Swift 5.1).</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2799" href="#calibre_link-2804"><img src="images/000014.png" alt="4" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The setter function is called <code class="calibre19">set</code>. There is no formal function declaration; the word <code class="calibre19">set</code> is simply followed immediately by a function body in curly braces.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2800" href="#calibre_link-2805"><img src="images/000021.png" alt="5" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The setter behaves like a function taking one parameter. By default, this parameter arrives into the setter function body with the local name <code class="calibre19">newValue</code>.</p></dd>
</dl>

<p class="author1">Hereâ€™s some code that illustrates the use of our computed variable. You donâ€™t treat it any differently than any other variable! To assign to the variable, assign to it; to use the variable, use it. Behind the scenes, though, the setter and getter functions are called:</p>

<pre data-type="programlisting" class="calibre28">now = "Howdy" // Howdy <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2808" href="#calibre_link-2806"><img src="images/000019.png" alt="1" class="calibre39" /></a>
print(now) // 2019-06-26 17:03:30 +0000 <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2809" href="#calibre_link-2807"><img src="images/000008.png" alt="2" class="calibre39" /></a></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2806" href="#calibre_link-2808"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Assigning to <code class="calibre19">now</code> calls its setter. The argument passed into this call is the assigned value; here, thatâ€™s <code class="calibre19">"Howdy"</code>. That value arrives in the <code class="calibre19">set</code> function as <code class="calibre19">newValue</code>. Our <code class="calibre19">set</code> function prints <code class="calibre19">newValue</code> to the console.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2807" href="#calibre_link-2809"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Fetching <code class="calibre19">now</code> calls its getter. Our <code class="calibre19">get</code> function obtains the current date-time and translates it into a string, and returns the string. Our code then prints that string to the console.</p></dd>
</dl>

<p class="author1">There are a couple of variants on the basic syntax Iâ€™ve just illustrated:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The name of the <code class="calibre19">set</code> function parameter doesnâ€™t have to be <code class="calibre19">newValue</code>. To specify a different name, put it in parentheses after the word <code class="calibre19">set</code>, like this:</p>

<pre data-type="programlisting" class="calibre38">set (val) { // now you can use "val" inside the setter function body</pre>
</li>
<li class="calibre12">
<p class="calibre17">There doesnâ€™t have to be a setter. If the setter is omitted, this becomes a <em class="calibre11">read-only</em> variable. This is the computed variable equivalent of a <code class="calibre19">let</code> variable: attempting to assign to it is a compile error.<a data-type="indexterm" data-primary="variables" data-secondary="read-only" id="calibre_link-2333" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="read-only variables" id="calibre_link-1855" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre12">
<p class="calibre17">There must always be a getter! However, if there is no setter, the word <code class="calibre19">get</code> and the curly braces that follow it can be omitted. This is a legal declaration of a read-only variable (omitting the <code class="calibre19">return</code> keyword):</p>

<pre data-type="programlisting" class="calibre38">var now : String {
    Date().description
}</pre>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="Computed Properties" class="calibre2"><div class="preface" id="calibre_link-2442">
<h2 class="calibre42">Computed Properties</h2>

<p class="author1">In real life, your main use of computed variables will nearly always be as instance properties. Here are some common ways in which computed properties are useful:<a data-type="indexterm" data-primary="computed properties" id="calibre_link-505" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="computed" id="calibre_link-1746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="properties" data-secondary="computed" data-seealso="variables, computed" id="calibre_link-1747" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">FaÃ§ade for a longer expression</dt>
<dd class="calibre16">
<p class="calibre17">When a value can be readily calculated or obtained each time it is needed, it often makes for simpler syntax to express it as a read-only computed variable, which effectively acts as a shorthand for a longer expression. Hereâ€™s an example from my own code:</p>

<pre data-type="programlisting" class="calibre28">var mp : MPMusicPlayerController {
    MPMusicPlayerController.systemMusicPlayer
}
var nowPlayingItem : MPMediaItem? {
    self.mp.nowPlayingItem
}</pre>

<p class="calibre17">No work is saved by these computed variables; each time we ask for <code class="calibre19">self.nowPlayingItem</code>, we are fetching <code class="calibre19">MPMusicPlayerController.systemMusicPlayer.nowPlayingItem</code>. Still, the clarity and convenience of the resulting code justifies the use of computed variables here.</p>
</dd>
<dt class="calibre15">FaÃ§ade for an elaborate calculation</dt>
<dd class="calibre16">
<p class="calibre17">A computed variable getter can encapsulate multiple lines of code, in effect turning a method into a property. Hereâ€™s an example from my own code:</p>

<pre data-type="programlisting" class="calibre28">var authorOfItem : String? {
    guard let authorNodes =
        self.extensionElements(
            withXMLNamespace: "http://www.tidbits.com/dummy",
            elementName: "app_author_name")
        else {return nil}
    guard let authorNode = authorNodes.last as? FPExtensionNode
        else {return nil}
    return authorNode.stringValue
}</pre>

<p class="calibre17">In that example, Iâ€™m diving into some parsed XML and extracting a value. I could have declared this as a method (<code class="calibre19">func authorOfItem() -&gt; String?</code>), but a method expresses a <em class="calibre11">process</em>, whereas a computed property characterizes it more intuitively as a <em class="calibre11">thing</em>.</p>
</dd>
<dt class="calibre15">FaÃ§ade for storage</dt>
<dd class="calibre16">
<p class="calibre17">A computed variable can sit in front of one or more stored variables, acting as a gatekeeper on how those stored variables are set and fetched. This is comparable to an accessor method in Objective-C. Commonly, a public computed variable is backed by a private stored variable.<a data-type="indexterm" data-primary="Objective-C" data-secondary="accessors" id="calibre_link-1512" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The simplest possible storage faÃ§ade would do no more than get and set the private stored variable directly:<a data-type="indexterm" data-primary="variables" data-secondary="faÃ§ade" id="calibre_link-2322" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">private var _p : String = ""
var p : String {
    get {
        self._p
    }
    set {
        self._p = newValue
    }
}</pre>

<p class="calibre17">Thatâ€™s legal but pointless. A storage faÃ§ade becomes useful when it does <em class="calibre11">other</em> things while getting or setting the stored variable. Hereâ€™s a more realistic example: a â€œclampedâ€ setter. This is an Int property to which only values between 0 and 5 can be assigned; larger values are replaced by 5, and smaller values are replaced by 0:</p>

<pre data-type="programlisting" class="calibre28">private var _pp : Int = 0
var pp : Int {
    get {
        self._pp
    }
    set {
        self._pp = max(min(newValue,5),0)
    }
}</pre>
</dd>
</dl>

<p class="author1">As the preceding examples have demonstrated, a computed instance property getter or setter can refer to other instance members. Thatâ€™s important, because in general the initializer for a stored property canâ€™t do that. The reason itâ€™s legal for a computed property is that the getter and setter functions wonâ€™t be called until the instance actually exists.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Property Wrappers" class="calibre2"><div class="preface" id="calibre_link-2443">
<h2 class="calibre42">Property Wrappers</h2>

<p class="author1">If we have several storage faÃ§ade computed properties that effectively do the same thing, weâ€™re going to end up with a lot of repeated code. Imagine, for example, implementing more than one Int property with a clamped setter, as in the preceding section. It would be nice to move the common functionality off into a single location. New in Swift 5.1, we can do that, using a <em class="calibre11">property wrapper</em>.<a data-type="indexterm" data-primary="wrappers, property" id="calibre_link-2372" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="property wrappers" id="calibre_link-1783" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="computed" data-tertiary="property wrappers" id="calibre_link-1748" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A property wrapper is declared as a type marked with the <code class="calibre19">@propertyWrapper</code> attribute, and must have a <code class="calibre19">wrappedValue</code> computed property. Hereâ€™s a property wrapper implementing the â€œclampedâ€ pattern:</p>

<pre data-type="programlisting" class="calibre28">@propertyWrapper struct Clamped {
    private var _i : Int = 0
    var wrappedValue : Int {
        get {
            self._i
        }
        set {
            self._i = Swift.max(Swift.min(newValue,5),0)
        }
    }
}</pre>

<p class="author1">The result is that we can declare a computed property marked with a custom attribute whose name is the same as that struct (<code class="calibre19">@Clamped</code>), with <em class="calibre11">no</em> getter or setter:<a data-type="indexterm" data-primary="attributes, custom" id="calibre_link-230" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="custom attributes" id="calibre_link-593" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@Clamped var p : Int</pre>

<p class="author1">Our property <code class="calibre19">p</code> doesnâ€™t need to be initialized, because itâ€™s a computed property. And it doesnâ€™t need a getter or a setter, because the <code class="calibre19">wrappedValue</code> computed property of the Clamped struct supplies them! Behind the scenes, an actual Clamped instance has been created for us. When we set <code class="calibre19">self.p</code> to some value through assignment, the assignment passes through the Clamped instanceâ€™s <code class="calibre19">wrappedValue</code> setter, and the resulting clamped value is stored in the Clamped instanceâ€™s <code class="calibre19">_i</code> property. When we fetch the value of <code class="calibre19">self.p</code>, what we get is the value returned from the Clamped instanceâ€™s <code class="calibre19">wrappedValue</code> getter, which is the value stored in the Clamped instanceâ€™s <code class="calibre19">_i</code> property.</p>

<p class="author1">Thanks to our property wrapper, we have <em class="calibre11">encapsulated</em> this computed property pattern, which means we can now declare <em class="calibre11">another</em> <code class="calibre19">@Clamped</code> property which will behave in just the same way. Itâ€™s also nice that this pattern now has a <em class="calibre11">name:</em> the declaration <code class="calibre19">@Clamped var</code> tells us what the behavior of this computed property will be.</p>

<p class="author1">(Believe it or not, I created the Clamped example <em class="calibre11">before</em> discovering that the Swift language proposal for property wrappers uses the same example!)</p>

<p class="author1">Thereâ€™s considerably more to know about property wrappers, but Iâ€™ll postpone further discussion to <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, after Iâ€™ve explained other language features that will help you appreciate their power and flexibility.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Setter Observers" class="calibre2"><div class="preface" id="calibre_link-2444">
<h1 class="calibre18">Setter Observers</h1>

<p class="author1">Computed variables are not needed as a stored variable faÃ§ade as often as you might suppose. Thatâ€™s because Swift has another feature, which lets you inject functionality into the setter of a <em class="calibre11">stored</em> variable &mdash; <em class="calibre11">setter observers</em>. These are functions that are called just before and just after other code sets a stored variable.<a data-type="indexterm" data-primary="setter observers" id="calibre_link-2022" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="setter observers" id="calibre_link-2335" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="willSet" id="calibre_link-2371" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="didSet" id="calibre_link-680" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The syntax for declaring a variable with a setter observer is very similar to the syntax for declaring a computed variable; you can write a <code class="calibre19">willSet</code> function, a <code class="calibre19">didSet</code> function, or both:</p>

<pre data-type="programlisting" class="calibre28">var s = "whatever" { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2815" href="#calibre_link-2810"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    willSet { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2816" href="#calibre_link-2811"><img src="images/000008.png" alt="2" class="calibre39" /></a>
        print(newValue) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2817" href="#calibre_link-2812"><img src="images/000029.png" alt="3" class="calibre39" /></a>
    }
    didSet { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2818" href="#calibre_link-2813"><img src="images/000014.png" alt="4" class="calibre39" /></a>
        print(oldValue) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2819" href="#calibre_link-2814"><img src="images/000021.png" alt="5" class="calibre39" /></a>
        // self.s = "something else"
    }
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2810" href="#calibre_link-2815"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The variable must be declared with <code class="calibre19">var</code> (not <code class="calibre19">let</code>). It can be assigned an initial value. It is then followed immediately by curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-583" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2811" href="#calibre_link-2816"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The <code class="calibre19">willSet</code> function, if there is one, is the word <code class="calibre19">willSet</code> followed immediately by a function body in curly braces. It is called when other code sets this variable, just <em class="calibre11">before</em> the variable actually receives its new value.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2812" href="#calibre_link-2817"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">By default, the <code class="calibre19">willSet</code> function receives the incoming new value as <code class="calibre19">newValue</code>. You can change this name by writing a different name in parentheses after the word <code class="calibre19">willSet</code>. The old value is still sitting in the stored variable, and the <code class="calibre19">willSet</code> function can access it there.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2813" href="#calibre_link-2818"><img src="images/000014.png" alt="4" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The <code class="calibre19">didSet</code> function, if there is one, is the word <code class="calibre19">didSet</code> followed immediately by a function body in curly braces. It is called when other code sets this variable, just <em class="calibre11">after</em> the variable actually receives its new value.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2814" href="#calibre_link-2819"><img src="images/000021.png" alt="5" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">By default, the <code class="calibre19">didSet</code> function receives the old value, which has already been replaced as the value of the variable, as <code class="calibre19">oldValue</code>. You can change this name by writing a different name in parentheses after the word <code class="calibre19">didSet</code>. The new value is already sitting in the stored variable, and the <code class="calibre19">didSet</code> function can access it there. Moreover, it is legal for the <code class="calibre19">didSet</code> function to set the stored variable to a different value.</p></dd>
</dl>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">Setter observer functions are <em class="calibre11">not</em> called when the stored variable is initialized or when the <code class="calibre19">didSet</code> function changes the stored variableâ€™s value. That would be <span class="publishername">circular!</span></p>
</div>

<p class="author1">In real-life iOS programming, youâ€™ll want the visible interface to reflect the state of your objects. A setter observer is a simple but powerful way to synchronize the interface with a property. In this example, we have an instance property of a view class, determining how much the view should be rotated; every time this property changes, we change the interface to reflect it, setting <code class="calibre19">self.transform</code> so that the view <em class="calibre11">is</em> rotated by that amount:</p>

<pre data-type="programlisting" class="calibre28">var angle : CGFloat = 0 {
    didSet {
        // modify interface to match
        self.transform = CGAffineTransform(rotationAngle: self.angle)
    }
}</pre>

<p class="author1">A computed variable canâ€™t have setter observers. But it doesnâ€™t need them! Thereâ€™s a setter function, so anything additional that needs to happen during setting can be programmed directly into that setter function. (But a property-wrapped computed variable <em class="calibre11">can</em> have setter observers.)</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Lazy Initialization" class="calibre2"><div class="preface" id="calibre_link-2445">
<h1 class="calibre18">Lazy Initialization</h1>

<p class="author1">The term <em class="calibre11">lazy</em> is not a pejorative puritanical judgment; itâ€™s a formal description of a useful behavior. If a stored variable is assigned an initial value as part of its declaration, and if it uses lazy initialization, then the initial value is not actually evaluated and assigned until running code accesses the variableâ€™s value.<a data-type="indexterm" data-primary="initialization" data-secondary="lazy" id="calibre_link-1076" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="lazy initialization" id="calibre_link-1210" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="lazy" id="calibre_link-2329" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">There are three types of variable that can be initialized lazily in Swift:</p>
<dl class="calibre14">
<dt class="calibre15">Global variables</dt>
<dd class="calibre16">
<p class="calibre17">Global variables are <em class="calibre11">automatically lazy</em>. This makes sense if you ask yourself when they should be initialized. As the app launches, files and their top-level code are encountered. It would make no sense to initialize globals now, because the app isnâ€™t even running yet. Thus global initialization must be postponed to some moment that <em class="calibre11">does</em> make sense. Therefore, a global variableâ€™s initialization doesnâ€™t happen until other code first refers to that global. Under the hood, this behavior is implemented in such a way as to make initialization both singular (it can happen only once) and thread-safe.<a data-type="indexterm" data-primary="global variables" data-secondary="initialization" id="calibre_link-982" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="global" data-tertiary="initialization" id="calibre_link-2326" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Static properties</dt>
<dd class="calibre16">
<p class="calibre17">Static properties are <em class="calibre11">automatically lazy</em>. They behave exactly like global variables, and for basically the same reason. (There are no stored class properties in Swift, so class properties canâ€™t be initialized and thus canâ€™t have lazy initialization.)<a data-type="indexterm" data-primary="static properties" data-secondary="initialization" id="calibre_link-2073" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="static" data-tertiary="initialization" id="calibre_link-1775" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Instance properties</dt>
<dd class="calibre16">
<p class="calibre17">An instance property is not lazy by default, but it may be made lazy by marking its declaration with the keyword <code class="calibre19">lazy</code>. This property must be declared with <code class="calibre19">var</code>, not <code class="calibre19">let</code>. The initializer for such a property might <em class="calibre11">never</em> be evaluated, namely if code assigns the property a value before any code fetches the propertyâ€™s value.</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Singleton" class="calibre2"><div class="preface" id="calibre_link-2446">
<h2 class="calibre42">Singleton</h2>

<p class="author1">Lazy initialization is often used to implement <em class="calibre11">singleton</em>. Singleton is a pattern where all code is able to get access to a single shared instance of a certain class:<a data-type="indexterm" data-primary="singleton" id="calibre_link-2036" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class MyClass {
    static let sharedSingleton = MyClass()
}</pre>

<p class="author1">Now other code can obtain a reference to MyClassâ€™s singleton by saying <code class="calibre19">MyClass.sharedSingleton</code>. The singleton instance is not created until the first time other code says this; subsequently, no matter how many times other code may say this, the instance returned is always that same instance. (That is <em class="calibre11">not</em> what would happen if this were a computed read-only property whose getter calls <code class="calibre19">MyClass()</code> and returns that instance; do you see why?)</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Lazy Initialization of Instance Properties" class="calibre2"><div class="preface" id="calibre_link-2447">
<h2 class="calibre42">Lazy Initialization of Instance Properties</h2>

<p class="author1">Why might you want an instance property to be lazy? One reason is obvious: the initial value might be expensive to generate, so youâ€™d like to avoid generating it unless it is actually needed. But thereâ€™s another reason that turns out to be even more important: a lazy initializer can do things that a normal initializer canâ€™t.</p>

<p class="author1">In particular, a lazy initializer can <em class="calibre11">refer to the instance</em>. A normal initializer canâ€™t do that, because the instance doesnâ€™t yet exist at the time that a normal initializer would need to run (weâ€™re in the middle of creating the instance, so it isnâ€™t ready yet). A lazy initializer, by contrast, is guaranteed not to run until some time after the instance has fully come into existence, so referring to the instance is fine. For example, this code would be illegal if the <code class="calibre19">arrow</code> property werenâ€™t declared <code class="calibre19">lazy</code>:<a data-type="indexterm" data-primary="properties" data-secondary="initialization" data-tertiary="lazy" id="calibre_link-1759" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class MyView : UIView {
    lazy var arrow = self.arrowImage() // legal
    func arrowImage () -&gt; UIImage {
        // ... big image-generating code goes here ...
    }
}</pre>

<p class="author1">A very common idiom is to initialize a lazy instance property with a define-and-call anonymous function whose code can refer to <code class="calibre19">self</code>:</p>

<pre data-type="programlisting" class="calibre28">lazy var prog : UIProgressView = {
    let p = UIProgressView(progressViewStyle: .default)
    p.alpha = 0.7
    p.trackTintColor = UIColor.clear
    p.progressTintColor = UIColor.black
    p.frame =
        CGRect(x:0, y:0, width:self.view.bounds.size.width, height:20) // legal
    p.progress = 1.0
    return p
}()</pre>

<p class="author1">Thereâ€™s no <code class="calibre19">lazy let</code> for instance properties, so you canâ€™t readily make a lazy instance property read-only. Thatâ€™s unfortunate, because there are some common situations that would benefit from such a feature.</p>

<p class="author1">For example, suppose we want to arm ourselves (<code class="calibre19">self</code>) with a <code class="calibre19">helper</code> property holding an instance of a Helper class that needs a reference back to <code class="calibre19">self</code>. We also want this one Helper instance to persist for the entire lifetime of <code class="calibre19">self</code>. We can enforce that rule by making <code class="calibre19">helper</code> a <code class="calibre19">let</code> property and initializing it in its declaration. But we canâ€™t pass <code class="calibre19">self</code> into the Helper instance at that point, because we canâ€™t refer to <code class="calibre19">self</code> in the property declaration.</p>

<p class="author1">We can solve the problem by declaring the <code class="calibre19">helper</code> property <code class="calibre19">lazy</code>, but then it has to be a <code class="calibre19">var</code> property, meaning that, in theory, other code can come along and replace this Helper with another. Of course, weâ€™ll try not to let that happen; but the point is that the expression <code class="calibre19">lazy var</code> fails to express and enforce this policy as an unbreakable contract. (It may be possible to work around the issue by making <code class="calibre19">helper</code> a computed property acting as a faÃ§ade on storage &mdash; and we can even encapsulate that pattern as a property wrapper &mdash; but even then we can enforce our policy only at runtime, not at compile time the way <code class="calibre19">let</code> does.)</p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Unlike automatically lazy global and static variables, an instance property marked <code class="calibre19">lazy</code> does <em class="calibre11">not</em> initialize itself in a thread-safe way. When used in a multithreaded context, <code class="calibre19">lazy</code> instance properties can cause multiple initialization and even crashes.</p>
</div>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Built-In Simple Types" class="calibre2"><div class="preface" id="calibre_link-2448">
<h1 class="calibre18">Built-In Simple Types</h1>

<p class="author1">Every variable, and every value, must have a type. But what types are there? Up to this point, Iâ€™ve assumed the existence of some types, such as Int and String, without formally telling you about them. Hereâ€™s a survey of the primary simple types provided by Swift, along with some instance methods, global functions, and operators that apply to them. (Collection types will be discussed at the end of <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>.) <a data-type="indexterm" data-startref="idxvariables" id="calibre_link-2317" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Bool" class="calibre2"><div class="preface" id="calibre_link-2449">
<h2 class="calibre42">Bool</h2>

<p class="author1">The Bool object type (a struct) has only two values, commonly regarded as true and false (or yes and no). You can represent these values using the literal keywords <code class="calibre19">true</code> and <code class="calibre19">false</code>, and it is natural to think of a Bool value as <em class="calibre11">being</em> either <code class="calibre19">true</code> or <code class="calibre19">false</code>:<a data-type="indexterm" data-primary="Bool" id="calibre_link-266" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="true" id="calibre_link-2224" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="false" id="calibre_link-848" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var selected : Bool = false</pre>

<p class="author1">In that code, <code class="calibre19">selected</code> is a Bool variable initialized to <code class="calibre19">false</code>; it can subsequently be set to <code class="calibre19">false</code> or <code class="calibre19">true</code>, and to no other values. Because of its simple yes-or-no state, a Bool variable of this kind is often referred to as a <em class="calibre11">flag</em>.<a data-type="indexterm" data-primary="flag" id="calibre_link-868" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Cocoa methods very often expect a Bool parameter or return a Bool value. For example, when your app launches, Cocoa calls a method in your code declared like this:</p>

<pre data-type="programlisting" class="calibre28">func application(_ application: UIApplication,
    didFinishLaunchingWithOptions
    launchOptions: [UIApplication.LaunchOptionsKey : Any]?)
    -&gt; Bool {</pre>

<p class="author1">You can do anything you like in that method; often, you will do nothing. But you must return a Bool! And in real life, that Bool will probably be <code class="calibre19">true</code>. A minimal implementation thus looks like this:</p>

<pre data-type="programlisting" class="calibre28">func application(_ application: UIApplication,
    didFinishLaunchingWithOptions
    launchOptions: [UIApplication.LaunchOptionsKey : Any]?)
    -&gt; Bool {
        return true
}</pre>

<p class="author1">A Bool is useful in conditions; as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, when you say <code class="calibre19">if <em class="calibre43">something</em></code>, the <code class="calibre19"><em class="calibre43">something</em></code> is the condition, and is a Bool or an expression that evaluates to a Bool. For example, when you compare two values using the equality comparison operator <code class="calibre19">==</code>, the result is a Bool &mdash; <code class="calibre19">true</code> if they are equal to each other, <code class="calibre19">false</code> if they are not:<a data-type="indexterm" data-primary="conditions" id="calibre_link-518" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">if meaningOfLife == 42 { // ...</pre>

<p class="author1">(Iâ€™ll talk more about equality comparison in a moment, when we come to discuss types that can be compared, such as Int and String.)</p>

<p class="author1">When preparing a condition, you will sometimes find that it enhances clarity to store the Bool value in a variable beforehand:</p>

<pre data-type="programlisting" class="calibre28">let comp = self.traitCollection.horizontalSizeClass == .compact
if comp { // ...</pre>

<p class="author1">Observe that, when employing that idiom, we use the Bool variable <code class="calibre19">comp</code> <em class="calibre11">directly</em> as the condition. There is no need to test explicitly whether a Bool equals <code class="calibre19">true</code> or <code class="calibre19">false</code>; the conditional expression itself is already testing that. It is pointless to say <code class="calibre19">if comp == true</code>, because <code class="calibre19">if comp</code> already <em class="calibre11">means</em> â€œif <code class="calibre19">comp</code> is <code class="calibre19">true</code>.â€</p>

<p class="author1">Since a Bool can be used as a condition, a call to a function that returns a Bool can be used as a condition. Hereâ€™s an example from my own code. Iâ€™ve declared a function that returns a Bool to say whether the cards the user has selected constitute a correct answer to the puzzle:</p>

<pre data-type="programlisting" class="calibre28">func isCorrect(_ cells:[CardCell]) -&gt; Bool { // ...</pre>

<p class="author1">Thus, elsewhere I can say this:</p>

<pre data-type="programlisting" class="calibre28">if self.isCorrect(cellsToTest) { // ...</pre>

<p class="author1">Unlike many computer languages, nothing else in Swift is implicitly coerced to or treated as a Bool. In C, for example, a boolean is actually a number, and <code class="calibre19">0</code> is false. But in Swift, nothing is false but <code class="calibre19">false</code>, and nothing is true but <code class="calibre19">true</code>.</p>

<p class="author1">The type name, Bool, comes from the English mathematician George Boole; Boolean algebra provides operations on logical values. Bool values are subject to these same operations:<a data-type="indexterm" data-primary="Boolean operators" id="calibre_link-268" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="Boolean" id="calibre_link-1565" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="logical operators" id="calibre_link-1250" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">!</code> (not)</dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre19">!</code> unary operator reverses the truth value of the Bool to which it is applied as a prefix. If <code class="calibre19">ok</code> is <code class="calibre19">true</code>, <code class="calibre19">!ok</code> is <code class="calibre19">false</code> &mdash; and <em class="calibre11">vice versa</em>.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&amp;&amp;</code> (logical-and)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> only if both operands are <code class="calibre19">true</code>; otherwise, returns <code class="calibre19">false</code>. If the first operand is <code class="calibre19">false</code>, the second operand is not even evaluated (thus avoiding possible side effects).</p>
</dd>
<dt class="calibre15"><code class="calibre19">||</code> (logical-or)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> if either operand is <code class="calibre19">true</code>; otherwise, returns <code class="calibre19">false</code>. If the first operand is <code class="calibre19">true</code>, the second operand is not even evaluated (thus avoiding possible side effects).</p>
</dd>
</dl>

<p class="author1">If a logical operation is complicated or elaborate, parentheses around subexpressions can help clarify both the logic and the order of operations.<a data-type="indexterm" data-primary="parentheses" data-secondary="order of operations" id="calibre_link-1681" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A common situation is that we have a Bool stored in a <code class="calibre19">var</code> variable somewhere, and we want to reverse its value &mdash; that is, make it <code class="calibre19">true</code> if it is <code class="calibre19">false</code>, and <code class="calibre19">false</code> if it is <code class="calibre19">true</code>. The <code class="calibre19">!</code> operator solves the problem; we fetch the variableâ€™s value, reverse it with <code class="calibre19">!</code>, and assign the result back into the variable:</p>

<pre data-type="programlisting" class="calibre28">v.isUserInteractionEnabled = !v.isUserInteractionEnabled</pre>

<p class="author1">That, however, is cumbersome and error-prone. Starting in Swift 4.2, thereâ€™s a simpler way &mdash; call the <code class="calibre19">toggle</code> method on the Bool variable:</p>

<pre data-type="programlisting" class="calibre28">v.isUserInteractionEnabled.toggle()</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Numbers" class="calibre2"><div class="preface" id="calibre_link-2450">
<h2 class="calibre42">Numbers</h2>

<p class="author1">The main numeric types are Int and Double &mdash; meaning that, left to your own devices, those are the types youâ€™ll generally use. Other numeric types exist mostly for compatibility with the C and Objective-C APIs that Swift needs to be able to talk to when youâ€™re programming iOS.<a data-type="indexterm" data-primary="numeric types, Swift" id="calibre_link-1477" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Int" class="calibre2"><div class="preface" id="calibre_link-2904">
<h3 class="calibre44">Int</h3>

<p class="author1">The Int object type (a struct) represents an integer between <code class="calibre19">Int.min</code> and <code class="calibre19">Int.max</code> inclusive. The actual values of those limits might depend on the platform and architecture under which the app runs, so donâ€™t count on them to be absolute; in my testing at this moment, they are -2<sup class="calibre45">63</sup> and 2<sup class="calibre45">63</sup>-1 respectively (64-bit words).<a data-type="indexterm" data-primary="Int" id="calibre_link-1146" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The easiest way to represent an Int value is as a numeric literal. A numeric literal without a decimal point is taken as an Int by default. Internal underscores are legal; this is useful for making long numbers readable. Leading zeroes are legal; this is useful for padding and aligning values in your code.<a data-type="indexterm" data-primary="numeric literals" id="calibre_link-1475" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="literals" data-secondary="numeric" id="calibre_link-1235" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can write an Int literal using binary, octal, or hexadecimal digits. To do so, start the literal with <code class="calibre19">0b</code>, <code class="calibre19">0o</code>, or <code class="calibre19">0x</code> respectively. For example, <code class="calibre19">0x10</code> is decimal 16.<a data-type="indexterm" data-primary="binary numbers" id="calibre_link-249" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="octal numbers" id="calibre_link-1554" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hexadecimal number" id="calibre_link-1018" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Negative numbers are stored in the twoâ€™s complement format (consult Wikipedia if youâ€™re curious). You can write a binary literal that looks like the underlying storage, but to use it you must pass it through the <code class="calibre19">Int(bitPattern:)</code> initializer.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Double" class="calibre2"><div class="preface" id="calibre_link-2905">
<h3 class="calibre44">Double</h3>

<p class="author1">The Double object type (a struct) represents a floating-point number to a precision of about 15 decimal places (64-bit storage).<a data-type="indexterm" data-primary="Double" id="calibre_link-709" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The easiest way to represent a Double value is as a numeric literal. A numeric literal containing a decimal point is taken as a Double by default. Internal underscores and leading zeroes are legal.<a data-type="indexterm" data-primary="decimal point" id="calibre_link-620" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A Double literal may <em class="calibre11">not</em> begin with a decimal point (unlike C and Objective-C). If the value to be represented is between 0 and 1, start the literal with a leading <code class="calibre19">0</code>.</p>

<p class="author1">You can write a Double literal using scientific notation. Everything after the letter <code class="calibre19">e</code> is the exponent of 10. You can omit the decimal point if the fractional digits would be zero. For example, <code class="calibre19">3e2</code> is 3 times 10<sup class="calibre45">2</sup> (300).<a data-type="indexterm" data-primary="scientific notation" id="calibre_link-1953" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can write a Double literal using hexadecimal digits. To do so, start the literal with <code class="calibre19">0x</code>. You can use exponentiation here too (and again, you can omit the decimal point); everything after the letter <code class="calibre19">p</code> is the exponent of 2. For example, <code class="calibre19">0x10p2</code> is decimal 64, because you are multiplying 16 by 2<sup class="calibre45">2</sup>.</p>

<p class="author1">There are static properties <code class="calibre19">Double.infinity</code> and <code class="calibre19">Double.pi</code>, and an instance property <code class="calibre19">isZero</code>, among others.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Numeric coercion" class="calibre2"><div class="preface" id="calibre_link-2906">
<h3 class="calibre44">Numeric coercion</h3>

<p class="author1"><em class="calibre11">Coercion</em> is the conversion of a value from one type to another, and numeric coercion is the conversion of a value from one numeric type to another. Swift doesnâ€™t really have explicit coercion, but it has something that serves the same purpose &mdash; instantiation. Swift numeric types are supplied with initializers that take another numeric type as parameter. For example, to convert an Int explicitly into a Double, instantiate Double with the Int in the parentheses. To convert a Double explicitly into an Int, instantiate Int with the Double in the parentheses; this will truncate the original value (everything after the decimal point will be thrown away):<a data-type="indexterm" data-primary="coercion" data-secondary="numeric" id="calibre_link-449" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parentheses" data-secondary="coercion" id="calibre_link-1676" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="coercion" id="calibre_link-448" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let i = 10
let x = Double(i)
print(x) // 10.0, a Double
let y = 3.8
let j = Int(y)
print(j) // 3, an Int</pre>

<p class="author1">When numeric values are assigned to variables or passed as arguments to a function, Swift can perform implicit coercion <em class="calibre11">of literals only</em>. This code is legal:</p>

<pre data-type="programlisting" class="calibre28">let d : Double = 10</pre>

<p class="author1">But this code is not legal, because what youâ€™re assigning is a <em class="calibre11">variable</em> (not a literal) of a different type; the compiler will stop you:</p>

<pre data-type="programlisting" class="calibre28">let i = 10
let d : Double = i // compile error</pre>

<p class="author1">The problem is that <code class="calibre19">i</code> is an Int and <code class="calibre19">d</code> is a Double, and never the twain shall meet. The solution is to <em class="calibre11">coerce explicitly</em> as you assign or pass the variable:</p>

<pre data-type="programlisting" class="calibre28">let i = 10
let d : Double = Double(i)</pre>

<p class="author1">The same rule holds when numeric values are combined by an arithmetic operation. Swift will perform implicit coercion <em class="calibre11">of literals only</em>. The usual situation is an Int combined with a Double; the Int is treated as a Double:</p>

<pre data-type="programlisting" class="calibre28">let x = 10/3.0
print(x) // 3.33333333333333</pre>

<p class="author1">But <em class="calibre11">variables</em> of different numeric types must be <em class="calibre11">coerced explicitly</em> so that they are the <em class="calibre11">same</em> type if you want to combine them in an arithmetic operation. Thus, for <span class="publishername">example:</span><a data-type="indexterm" data-primary="variables" data-secondary="coercion" id="calibre_link-2318" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let i = 10
let n = 3.0
let x = i / n // compile error; you need to say Double(i)</pre>

<p class="author1">These rules are evidently a consequence of Swiftâ€™s strict typing; but (as far as I am aware) they constitute very unusual treatment of numeric values for a modern computer language, and will probably drive you mad in short order. The examples Iâ€™ve given so far were easily solved, but things can become more complicated if an arithmetic expression is longer, and the problem is compounded by the existence of other numeric types that are needed for compatibility with Cocoa, as I shall now proceed to explain.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Other numeric types" class="calibre2"><div class="preface" id="calibre_link-2907">
<h3 class="calibre44">Other numeric types</h3>

<p class="author1">If you were using Swift in some isolated, abstract world, you could probably do all necessary arithmetic with Int and Double alone. But when youâ€™re programming iOS, you encounter Cocoa, which is full of other numeric types; and Swift has types that match every one of them. In addition to Int, there are signed integer types of various sizes &mdash; Int8, Int16, Int32, Int64 &mdash; plus the unsigned integer type UInt along with UInt8, UInt16, UInt32, and UInt64. In addition to Double, there is the lower-precision Float (32-bit storage, about 6 or 7 decimal places of precision) and the extended-precision Float80 &mdash; plus, in the Core Graphics framework, CGFloat (whose size can be that of Float or Double, depending on the bitness of the architecture).<a data-type="indexterm" data-primary="numeric types, C" id="calibre_link-1476" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="C" data-secondary="numeric types" id="calibre_link-318" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You may also encounter a C numeric type when trying to interface with a C API. These types, as far as Swift is concerned, are just type aliases, meaning that they are alternate names for another type; for example, a CDouble (corresponding to Câ€™s <code class="calibre19">double</code>) is just a Double by another name, a CLong (Câ€™s <code class="calibre19">long</code>) is an Int, and so on. Many other numeric type aliases will arise in various Cocoa frameworks; for example, TimeInterval (Objective-C NSTimeInterval) is merely a type alias for Double.</p>

<p class="author1">Recall that you canâ€™t assign, pass, or combine values of different numeric types using variables; you have to coerce those values explicitly to the correct type. But now it turns out that youâ€™re being flooded by Cocoa with numeric values of many types! Cocoa will often hand you a numeric value that is neither an Int nor a Double &mdash; and you wonâ€™t necessarily realize this, until the compiler stops you dead in your tracks for some sort of type mismatch. You must then figure out what youâ€™ve done wrong and coerce everything to the same type.</p>

<p class="author1">Hereâ€™s a typical example from one of my apps. A slider in the interface is a UISlider, whose <code class="calibre19">minimumValue</code> and <code class="calibre19">maximumValue</code> are Floats. In this code, <code class="calibre19">s</code> is a UISlider, <code class="calibre19">g</code> is a UIGestureRecognizer, and weâ€™re trying to use the gesture recognizer to move the sliderâ€™s â€œthumbâ€ to wherever the user tapped within the slider:<a data-type="indexterm" data-primary="Float" id="calibre_link-872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pt = g.location(in:s) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2823" href="#calibre_link-2820"><img src="images/000019.png" alt="1" class="calibre39" /></a>
let percentage = pt.x / s.bounds.size.width <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2824" href="#calibre_link-2821"><img src="images/000008.png" alt="2" class="calibre39" /></a>
let delta = percentage * (s.maximumValue - s.minimumValue) // compile error <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2825" href="#calibre_link-2822"><img src="images/000029.png" alt="3" class="calibre39" /></a></pre>

<p class="author1">That wonâ€™t compile. Hereâ€™s why:</p>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2820" href="#calibre_link-2823"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41"><code class="calibre19">pt</code> is a CGPoint, and therefore <code class="calibre19">pt.x</code> is a CGFloat.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2821" href="#calibre_link-2824"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Luckily, <code class="calibre19">s.bounds.size.width</code> is also a CGFloat, so the second line compiles; <code class="calibre19">percentage</code> is now inferred to be a CGFloat.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2822" href="#calibre_link-2825"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">We now try to combine <code class="calibre19">percentage</code> with <code class="calibre19">s.maximumValue</code> and <code class="calibre19">s.minimumValue</code> &mdash; and they are Floats, not CGFloats. Thatâ€™s a compile error.</p></dd>
</dl>

<p class="author1">This sort of thing is not an issue in C or Objective-C, where there is implicit coercion; but in Swift a CGFloat canâ€™t be combined with Floats. We must coerce explicitly:</p>

<pre data-type="programlisting" class="calibre28">let delta = Float(percentage) * (s.maximumValue - s.minimumValue)</pre>

<p class="author1">The good news here is that if you can get enough of your code to compile, Xcodeâ€™s Quick Help feature will tell you what type Swift has inferred for a variable (<a data-type="xref" href="#calibre_link-3" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;3-1</a>). This can assist you in tracking down your issues with numeric types.<a data-type="indexterm" data-primary="inferred variable type" data-secondary="learning" id="calibre_link-1060" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-3" class="figure">
<img src="images/000003.png" alt="ios12 0301" class="calibre46" />
<h6 class="calibre34"><span class="publishername">Figure 3-1. </span>Quick Help displays a variableâ€™s type</h6>
</div>
</figure>

<p class="author1">Another problem is that not every numeric value <em class="calibre11">can</em> be coerced to a numeric value of a different type. In particular, integers of various sizes can be out of range with respect to integer types of other sizes. For example, <code class="calibre19">Int8.max</code> is 127, so attempting to assign a literal <code class="calibre19">128</code> or larger to an Int8 variable is illegal. Fortunately, the compiler will stop you in that case, because it knows what the literal is. But now consider <em class="calibre11">coercing</em> a variable value of a larger integer type to an Int8:</p>

<pre data-type="programlisting" class="calibre28">let i : Int16 = 128
let ii = Int8(i)</pre>

<p class="author1">That code is legal &mdash; and will crash at runtime.<a data-type="indexterm" data-primary="crash" data-secondary="not enough bits" id="calibre_link-567" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> One solution is to call the numeric <code class="calibre19">exactly:</code> initializer; this is a <em class="calibre11">failable</em> initializer &mdash; meaning, as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>,  that you wonâ€™t crash, but youâ€™ll have to add code to test whether the coercion succeeded (and youâ€™ll understand what the test would be when youâ€™ve read the discussion of Optionals later in this chapter):</p>

<pre data-type="programlisting" class="calibre28">let i : Int16 = 128
let ii = Int8(exactly:i)
if // ... test to learn whether ii holds a real Int8</pre>

<p class="author1">Yet another solution is to call the <code class="calibre19">clamping:</code> initializer; it <em class="calibre11">always</em> succeeds, because an out of range value is forced to fall within range:</p>

<pre data-type="programlisting" class="calibre28">let i : Int16 = 128
let ii = Int8(clamping:i) // 127</pre>

<p class="author1">(There is also a <code class="calibre19">truncatingIfNeeded:</code> initializer, but you probably wonâ€™t need to know about it unless you are deliberately manipulating integers as binary, so I wonâ€™t describe it here.)</p>

<p class="author1">When a floating-point type, such as a Double, is coerced to an integer type, the stuff after the decimal point is thrown away first and then the coercion is attempted. Thus, <code class="calibre19">Int8(127.9)</code> succeeds, because 127 is in bounds.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Arithmetic operations" class="calibre2"><div class="preface" id="calibre_link-2908">
<h3 class="calibre44">Arithmetic operations</h3>

<p class="author1">Swiftâ€™s arithmetic operators are as you would expect; they are familiar from other computer languages as well as from real arithmetic:<a data-type="indexterm" data-primary="operators" data-secondary="arithmetic" id="calibre_link-1561" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arithmetic operators" id="calibre_link-176" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">+</code> (addition operator)</dt>
<dd class="calibre16">
<p class="calibre17">Add the second operand to the first and return the result.</p>
</dd>
<dt class="calibre15"><code class="calibre19">-</code> (subtraction operator)</dt>
<dd class="calibre16">
<p class="calibre17">Subtract the second operand from the first and return the result. A different operator (unary minus), used as a prefix, looks the same; it returns the additive inverse of its single operand. (There is, in fact, also a unary plus operator, which returns its operand unchanged.)</p>
</dd>
<dt class="calibre15"><code class="calibre19">*</code> (multiplication operator)</dt>
<dd class="calibre16">
<p class="calibre17">Multiply the first operand by the second and return the result.</p>
</dd>
<dt class="calibre15"><code class="calibre19">/</code> (division operator)</dt>
<dd class="calibre16">
<p class="calibre17">Divide the first operand by the second and return the result. As in C, division of one Int by another Int yields an Int; any remaining fraction is stripped away. <code class="calibre19">10/3</code> is 3, not 3-and-one-third.</p>
</dd>
<dt class="calibre15"><code class="calibre19">%</code> (remainder operator)</dt>
<dd class="calibre16">
<p class="calibre17">Divide the first operand by the second and return the remainder. The result can be negative, if the first operand is negative; if the second operand is negative, it is treated as positive. For floating-point operands, use a method such as <code class="calibre19">remainder(dividingBy:)</code> instead.</p>
</dd>
</dl>

<p class="author1">Integer types can be treated as binary bitfields and subjected to binary bitwise <span class="publishername">operations:</span><a data-type="indexterm" data-primary="operators" data-secondary="bitwise" id="calibre_link-1563" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bitwise operators" id="calibre_link-258" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">&amp;</code> (bitwise-and)</dt>
<dd class="calibre16">
<p class="calibre17">A bit in the result is 1 if and only if that bit is 1 in both operands.</p>
</dd>
<dt class="calibre15"><code class="calibre19">|</code> (bitwise-or)</dt>
<dd class="calibre16">
<p class="calibre17">A bit in the result is 0 if and only if that bit is 0 in both operands.</p>
</dd>
<dt class="calibre15"><code class="calibre19">^</code> (bitwise-or, exclusive)</dt>
<dd class="calibre16">
<p class="calibre17">A bit in the result is 1 if and only if that bit is not identical in both operands.</p>
</dd>
<dt class="calibre15"><code class="calibre19">~</code> (bitwise-not)</dt>
<dd class="calibre16">
<p class="calibre17">Precedes its single operand; inverts the value of each bit and returns the result.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&lt;&lt;</code> (shift left)</dt>
<dd class="calibre16">
<p class="calibre17">Shift the bits of the first operand leftward the number of times indicated by the second operand.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&gt;&gt;</code> (shift right)</dt>
<dd class="calibre16">
<p class="calibre17">Shift the bits of the first operand rightward the number of times indicated by the second operand.</p>
</dd>
</dl>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">Technically, the shift operators perform a logical shift if the integer is unsigned, and an arithmetic shift if the integer is signed.</p>
</div>

<p class="author1">Integer overflow or underflow &mdash; for example, adding two Int values so as to exceed <code class="calibre19">Int.max</code> &mdash; is a runtime error (your app will crash). In simple cases the compiler will stop you, but you can get away with it easily enough:<a data-type="indexterm" data-primary="overflow" id="calibre_link-1645" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="underflow" id="calibre_link-2267" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let i = Int.max - 2
let j = i + 12/2 // crash</pre>

<p class="author1">Under certain circumstances you might want to force such an operation to succeed, so special overflow/underflow methods are supplied. These methods return a tuple; Iâ€™ll show you an example even though I havenâ€™t discussed tuples yet:</p>

<pre data-type="programlisting" class="calibre28">let i = Int.max - 2
let (j, over) = i.addingReportingOverflow(12/2)</pre>

<p class="author1">Now <code class="calibre19">j</code> is <code class="calibre19">Int.min + 3</code> (because the value has wrapped around from <code class="calibre19">Int.max</code> to <code class="calibre19">Int.min</code>) and <code class="calibre19">over</code> is an enum reporting that overflow occurred.</p>

<p class="author1">If you donâ€™t care to hear about whether or not there was an overflow/underflow, special arithmetic operators let you suppress the error: <code class="calibre19">&amp;+</code>, <code class="calibre19">&amp;-</code>, <code class="calibre19">&amp;*</code>.</p>

<p class="author1">You will frequently want to combine the value of an existing variable arithmetically with another value and store the result in the same variable. To do so, you will need to have declared the variable as a <code class="calibre19">var</code>:</p>

<pre data-type="programlisting" class="calibre28">var i = 1
i = i + 7</pre>

<p class="author1">As a shorthand, operators are provided that perform the arithmetic operation and the assignment all in one move:</p>

<pre data-type="programlisting" class="calibre28">var i = 1
i += 7</pre>

<p class="author1">The shorthand (<em class="calibre11">compound</em>) assignment arithmetic operators are <code class="calibre19">+=</code>, <code class="calibre19">-=</code>, <code class="calibre19">*=</code>, <code class="calibre19">/=</code>, <code class="calibre19">%=</code>, <code class="calibre19">&amp;=</code>, <code class="calibre19">|=</code>, <code class="calibre19">^=</code>, <code class="calibre19">&lt;&lt;=</code>, <code class="calibre19">&gt;&gt;=</code>.<a data-type="indexterm" data-primary="assignment" data-secondary="compound" id="calibre_link-218" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="compound assignment operators" id="calibre_link-503" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="compound assignment" id="calibre_link-1568" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Operation precedence is largely intuitive: for example, <code class="calibre19">*</code> has a higher precedence than <code class="calibre19">+</code>, so <code class="calibre19">x+y*z</code> multiplies <code class="calibre19">y</code> by <code class="calibre19">z</code> first, and then adds the result to <code class="calibre19">x</code>. Use parentheses to disambiguate when in doubt; for example, <code class="calibre19">(x+y)*z</code> performs the addition first.<a data-type="indexterm" data-primary="parentheses" data-secondary="order of operations" id="calibre_link-1682" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="precedence" id="calibre_link-1577" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Global functions from the Swift standard library include <code class="calibre19">abs</code> (absolute value), <code class="calibre19">max</code>, and <code class="calibre19">min</code>:<a data-type="indexterm" data-primary="functions" data-secondary="mathematical" id="calibre_link-924" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="math functions" id="calibre_link-1270" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let i = -7
let j = 6
print(abs(i)) // 7
print(max(i,j)) // 6</pre>

<p class="author1">Doubles are also stocked with mathematical methods. For example, if <code class="calibre19">d</code> is a Double, you can say <code class="calibre19">d.squareRoot()</code> or <code class="calibre19">d.rounded()</code>; if <code class="calibre19">dd</code> is also a Double, you can say <code class="calibre19">Double.maximum(d,dd)</code>. Other global mathematical functions, such as trigonometric <code class="calibre19">sin</code> and <code class="calibre19">cos</code>, come from the C standard libraries that are visible because youâ€™ve imported UIKit.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">New in Swift 5, the <code class="calibre19">simd</code> types for representing vectors are given native support through various fixed-size structs such as SIMD2, SIMD3, and so forth; these types introduce a large number of pointwise operators beginning with a dot (<code class="calibre19">.</code>) that are beyond the scope of this book.<a data-type="indexterm" data-primary="simd" id="calibre_link-2032" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>

<p class="author1">Starting in Swift 4.2, numeric types have a <code class="calibre19">random(in:)</code> static method allowing generation of a random number. The parameter is a range representing the bounds within which the random number should fall. (Ranges are discussed later in this chapter.) This method is much easier to use correctly than the C library methods such as <code class="calibre19">arc4random_uniform</code>, which should be avoided:<a data-type="indexterm" data-primary="random" id="calibre_link-1837" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// pick a number from 1 to 10
let i = Int.random(in: 1...10)</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Comparison" class="calibre2"><div class="preface" id="calibre_link-2909">
<h3 class="calibre44">Comparison</h3>

<p class="author1">Numbers are compared using the comparison operators, which return a Bool. For example, the expression <code class="calibre19">i==j</code> tests whether <code class="calibre19">i</code> and <code class="calibre19">j</code> are equal; when <code class="calibre19">i</code> and <code class="calibre19">j</code> are numbers, â€œequalâ€ means numerically equal. So <code class="calibre19">i==j</code> is <code class="calibre19">true</code> only if <code class="calibre19">i</code> and <code class="calibre19">j</code> are â€œthe same number,â€ in exactly the sense you would expect.<a data-type="indexterm" data-primary="comparison operators" id="calibre_link-491" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="comparison" id="calibre_link-1567" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="equality" data-secondary="operators" id="calibre_link-772" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="equality" id="calibre_link-1571" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The comparison operators are:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">==</code> (equality operator)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> if its operands are equal.</p>
</dd>
<dt class="calibre15"><code class="calibre19">!=</code> (inequality operator)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">false</code> if its operands are equal.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&lt;</code> (less-than operator)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> if the first operand is less than the second operand.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&lt;=</code> (less-than-or-equal operator)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> if the first operand is less than or equal to the second operand.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&gt;</code> (greater-than operator)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> if the first operand is greater than the second operand.</p>
</dd>
<dt class="calibre15"><code class="calibre19">&gt;=</code> (greater-than-or-equal operator)</dt>
<dd class="calibre16">
<p class="calibre17">Returns <code class="calibre19">true</code> if the first operand is greater than or equal to the second operand.</p>
</dd>
</dl>

<p class="author1">Because of the way computers store numbers, equality comparison of Double values may not succeed where you would expect. To give a classic example, adding <code class="calibre19">0.1</code> to <code class="calibre19">0</code> ten times does not give the same result as multiplying <code class="calibre19">0.1</code> by ten:</p>

<pre data-type="programlisting" class="calibre28">let f = 0.1
var sum = 0.0
for _ in 0..&lt;10 { sum += f }
let product = f * 10
let ok = sum == product // false</pre>

<p class="author1">Working around this sort of thing is not easy. The usual approach is to check whether two values are sufficient close to one another, but this begs the question of what constitutes sufficient closeness. A useful formula is:</p>

<pre data-type="programlisting" class="calibre28">let ok2 = sum &gt;= product.nextDown &amp;&amp; sum &lt;= product.nextUp // true</pre>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="String" class="calibre2"><div class="preface" id="calibre_link-2451">
<h2 class="calibre42">String</h2>

<p class="author1">The String object type (a struct) represents text. The simplest way to represent a String value is with a literal, delimited by double quotes:<a data-type="indexterm" data-primary="String" id="calibre_link-2085" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="literals" data-secondary="string" id="calibre_link-1236" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="literals" id="calibre_link-2106" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="quotes" id="calibre_link-1836" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" id="calibre_link-2088" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let greeting = "hello"</pre>

<p class="author1">A Swift string is thoroughly modern; under the hood, itâ€™s Unicode, and you can include any character (such as an emoji) directly in a string literal. If you donâ€™t want to bother typing a Unicode character whose codepoint you know, use the notation <code class="calibre19">\u{...}</code>, where whatâ€™s between the curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-584" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is up to eight hex digits:<a data-type="indexterm" data-primary="Unicode" id="calibre_link-2275" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let leftTripleArrow = "\u{21DA}"</pre>

<p class="author1">The backslash in that string representation is the <em class="calibre11">escape</em> character; it means, â€œIâ€™m not really a backslash; I indicate that the next character gets special treatment.â€ Various nonprintable and ambiguous characters are entered as escaped characters; the most important are:<a data-type="indexterm" data-primary="escaped characters" id="calibre_link-806" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="characters, escaped" id="calibre_link-359" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="backslash" id="calibre_link-240" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">\n</code></dt>
<dd class="calibre16">
<p class="calibre17">A Unix newline character</p>
</dd>
<dt class="calibre15"><code class="calibre19">\t</code></dt>
<dd class="calibre16">
<p class="calibre17">A tab character</p>
</dd>
<dt class="calibre15"><code class="calibre19">\"</code></dt>
<dd class="calibre16">
<p class="calibre17">A quotation mark (escaped to show that this is not the end of the string literal)</p>
</dd>
<dt class="calibre15"><code class="calibre19">\\</code></dt>
<dd class="calibre16">
<p class="calibre17">A backslash (escaped because a lone backslash is the escape character)</p>
</dd>
</dl>

<p class="author1">Escaped quotation marks and backslashes can quickly make your string literals ugly and illegible. The issue arises particularly in contexts such as regular expression patterns. For example, the pattern <code class="calibre19">\b\d\d\b</code> (a word consisting of two digits) must be written <code class="calibre19">"\\b\\d\\d\\b"</code>. New in Swift 5, you can omit the escape character before quotes and backslashes by surrounding your literal with one or more hash characters (<code class="calibre19">#</code>); thus, these are all identical strings:<a data-type="indexterm" data-primary="literals" data-secondary="string" data-tertiary="raw" id="calibre_link-1238" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="literals" data-tertiary="raw" id="calibre_link-2108" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hash character" id="calibre_link-998" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pattold = "\\b\\d\\d\\b"
let pattnew = #"\b\d\d\b"# // same thing
let pattnew2 = ##"\b\d\d\b"## // same thing</pre>

<p class="author1">Thatâ€™s called a <em class="calibre11">raw</em> string literal. The downside is that if you <em class="calibre11">want</em> to use a backslash as an escape character in a raw string literal, you must follow it with the same number of <code class="calibre19">#</code> characters you are using to surround your literal.</p>

<p class="author1">Starting in Swift 4, a string literal containing newline characters can be entered as multiple lines (rather than a single-line expression containing <code class="calibre19">"\n"</code> characters). This is called a <em class="calibre11">multiline</em> string literal. The rules are:<a data-type="indexterm" data-primary="literals" data-secondary="string" data-tertiary="multiline" id="calibre_link-1237" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="literals" data-tertiary="multiline" id="calibre_link-2107" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The multiline string literal must be delimited by a triple of double quotes (<code class="calibre19">"""</code>) at start and end.</p>
</li>
<li class="calibre12">
<p class="calibre17">No material may follow the opening delimiter on the same line.</p>
</li>
<li class="calibre12">
<p class="calibre17">No material other than whitespace may appear on the same line as the closing delimiter.</p>
</li>
<li class="calibre12">
<p class="calibre17">The last implicit newline character before the closing delimiter is ignored.</p>
</li>
<li class="calibre12">
<p class="calibre17">The indentation of the closing delimiter dictates the indentation of the lines of text, which must be indented at least as far as the closing delimiter (except for completely empty lines).</p>
</li>
</ul>

<p class="author1">For example:</p>

<pre data-type="programlisting" class="calibre28">func f() {
    let s = """
    Line 1
        Line 2
    Line 3
    """
    // ...
}</pre>

<p class="author1">In that code, the string <code class="calibre19">s</code> consists of three lines of text; lines 1 and 3 start with no whitespace; line 2 starts with four spaces; and there are two newline characters, namely after lines 1 and 2. To add a newline after line 3, you could enter a blank line, or write it as an escaped <code class="calibre19">\n</code>.</p>

<p class="author1">Quotation marks do <em class="calibre11">not</em> have to be escaped. A line ending with a backslash is joined with the following line. In this code, the string <code class="calibre19">s</code> consists of just two lines of text; the second line consists of four spaces followed by â€œLine 2 and this is still line 2â€:</p>

<pre data-type="programlisting" class="calibre28">func f() {
    let s = """
    Line "1"
        Line 2 \
    and this is still Line 2
    """
    // ...
}</pre>

<p class="author1">(You can surround a multiline string literal with <code class="calibre19">#</code> characters, making a raw multiline string literal; but you are unlikely to do so.)</p>

<p class="author1">String interpolation permits you to embed any value that can be output with <code class="calibre19">print</code> inside a string literal <em class="calibre11">as a string</em>, even if it is not itself a string. The notation is escaped parentheses: <code class="calibre19">\(...)</code>:<a data-type="indexterm" data-primary="strings" data-secondary="interpolation" id="calibre_link-2101" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="interpolation, string" id="calibre_link-1153" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let n = 5
let s = "You have \(n) widgets."</pre>

<p class="author1">Now <code class="calibre19">s</code> is the string <code class="calibre19">"You have 5 widgets."</code> The example is not very compelling, because we know what <code class="calibre19">n</code> is and could have typed <code class="calibre19">5</code> directly into our string; but imagine that we <em class="calibre11">donâ€™t</em> know what <code class="calibre19">n</code> is! Moreover, the stuff in escaped parentheses doesnâ€™t have to be the name of a variable; it can be almost any expression that evaluates as legal Swift:</p>

<pre data-type="programlisting" class="calibre28">let m = 4
let n = 5
let s = "You have \(m + n) widgets."</pre>

<p class="author1">String interpolation is legal inside a multiline string literal. It is also legal inside a string literal surrounded with <code class="calibre19">#</code> characters, but the backslash must be followed by the same number of <code class="calibre19">#</code> characters, to indicate that it is the escape character.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">New in Swift 5, string interpolation syntax can be customized to accept additional parameters, refining how the first parameter should be transformed. Thus, expressions of this form can be made legal:</p>

<pre data-type="programlisting" class="calibre38">let s = "You have \(n, roman:true) widgets"</pre>

<p class="author1">(Iâ€™m imagining that if <code class="calibre19">n</code> is 5, this would yield <code class="calibre19">"You have V widgets"</code>.) Iâ€™ll say more in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> about how that is achieved.</p>
</div>

<p class="author1">To combine (concatenate) two strings, the simplest approach is to use the <code class="calibre19">+</code> operator:<a data-type="indexterm" data-primary="concatenating strings" id="calibre_link-508" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="concatenating" id="calibre_link-2094" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = " world"
let greeting = s + s2</pre>

<p class="author1">This convenient notation is possible because the <code class="calibre19">+</code> operator is <em class="calibre11">overloaded</em>: it does one thing when the operands are numbers (numeric addition) and another when the operands are strings (concatenation). As Iâ€™ll explain in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, <em class="calibre11">all</em> operators can be overloaded, and you can overload them to operate in some appropriate way on your own types.</p>

<p class="author1">The <code class="calibre19">+</code> operator comes with a <code class="calibre19">+=</code> assignment shortcut; naturally, the variable on the left side must have been declared with <code class="calibre19">var</code>:</p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let s2 = " world"
s += s2</pre>

<p class="author1">As an alternative to <code class="calibre19">+=</code>, you can call the <code class="calibre19">append(_:)</code> instance method:<a data-type="indexterm" data-primary="append" id="calibre_link-166" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let s2 = " world"
s.append(s2)</pre>

<p class="author1">Another way of concatenating strings is with the <code class="calibre19">joined(separator:)</code> method. You start with an array of strings to be concatenated, and hand it the string that is to be inserted between all of them:<a data-type="indexterm" data-primary="joined" id="calibre_link-1170" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = "world"
let space = " "
let greeting = [s,s2].joined(separator:space)</pre>

<p class="author1">The comparison operators are also overloaded so that they work with String operands. Two String values are equal (<code class="calibre19">==</code>) if they are, in the natural sense of the words, the same text. A String is less than another if it is alphabetically prior.<a data-type="indexterm" data-primary="strings" data-secondary="comparison" id="calibre_link-2093" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="equality" id="calibre_link-2096" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Some additional convenient instance methods and properties are provided. <code class="calibre19">isEmpty</code> returns a Bool reporting whether this string is the empty string (<code class="calibre19">""</code>). <code class="calibre19">hasPrefix(_:)</code> and <code class="calibre19">hasSuffix(_:)</code> report whether this string starts or ends with another string; for example, <code class="calibre19">"hello".hasPrefix("he")</code> is <code class="calibre19">true</code>. The <code class="calibre19">uppercased</code> and <code class="calibre19">lowercased</code> methods provide uppercase and lowercase versions of the original string.<a data-type="indexterm" data-primary="isEmpty" id="calibre_link-1163" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hasPrefix" id="calibre_link-1007" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hasSuffix" id="calibre_link-1008" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="uppercased" id="calibre_link-2300" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="lowercased" id="calibre_link-1254" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Coercion between a String and an Int is possible. To make a string that represents an Int, it is sufficient to use string interpolation; alternatively, use a String initializer taking the Int:<a data-type="indexterm" data-primary="coercion" data-secondary="String and Int" id="calibre_link-452" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="coercion" id="calibre_link-2092" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="initializers" id="calibre_link-2100" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let i = 7
let s = String(i) // "7"</pre>

<p class="author1">Your string can also represent an Int in some other base; in the initializer, supply a <code class="calibre19">radix:</code> argument expressing the base:</p>

<pre data-type="programlisting" class="calibre28">let i = 31
let s = String(i, radix:16) // "1f"</pre>

<p class="author1">A String that might represent a number can be coerced to a numeric type; an integer type will accept a <code class="calibre19">radix:</code> argument expressing the base. The coercion might fail, because the String might <em class="calibre11">not</em> represent a number of the specified type; so the result is not a number but an Optional wrapping a number (I havenâ€™t talked about Optionals yet, so youâ€™ll have to trust me for now; failable initializers are discussed in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>):</p>

<pre data-type="programlisting" class="calibre28">let s = "31"
let i = Int(s) // Optional(31)
let s2 = "1f"
let i2 = Int(s2, radix:16) // Optional(31)</pre>

<p class="author1">Similarly, you can coerce a Bool to a String, which will be <code class="calibre19">"true"</code> or <code class="calibre19">"false"</code>. Going the other way, you can coerce the string <code class="calibre19">"true"</code> to the Bool <code class="calibre19">true</code> and the string <code class="calibre19">"false"</code> to the Bool <code class="calibre19">false</code>; again, this is a failable initializer, and any other string will fail.</p>

<p class="author1">The length of a String, in characters, is given by its <code class="calibre19">count</code> property:<a data-type="indexterm" data-primary="strings" data-secondary="length" id="calibre_link-2104" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="count" id="calibre_link-555" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let length = s.count // 5</pre>

<p class="author1">This property is called <code class="calibre19">count</code> rather then <code class="calibre19">length</code> because a String doesnâ€™t really have a simple length. The String comprises a sequence of Unicode codepoints, but multiple Unicode codepoints can combine to form a single character; so, in order to know how many characters are represented by such a sequence, we actually have to walk through the sequence and resolve it into the characters that it represents.<a data-type="indexterm" data-primary="codepoints, Unicode" id="calibre_link-446" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="Unicode" id="calibre_link-2117" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You, too, can walk through a Stringâ€™s characters. The simplest way is with the <code class="calibre19">for...in</code> construct (see <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>). What you get when you do this are Character objects; Iâ€™ll talk more about Character objects later:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
for c in s {
    print(c) // print each Character on its own line
}</pre>

<p class="author1">At an even deeper level, you can decompose a String into its UTF-8 codepoints or its UTF-16 codepoints, using the <code class="calibre19">utf8</code> and <code class="calibre19">utf16</code> properties:<a data-type="indexterm" data-primary="UTF-8, UTF-16, UTF-32" id="calibre_link-2307" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "\u{BF}Qui\u{E9}n?"
for i in s.utf8 {
    print(i) // 194, 191, 81, 117, 105, 195, 169, 110, 63
}
for i in s.utf16 {
    print(i) // 191, 81, 117, 105, 233, 110, 63
}</pre>

<p class="author1">There is also a <code class="calibre19">unicodeScalars</code> property representing a collection (a <span class="publishername">String.UnicodeScalarView</span>) of the Stringâ€™s UTF-32 codepoints expressed as UnicodeScalar structs. To illustrate, hereâ€™s a utility function that turns a two-letter country abbreviation into an emoji representation of its flag:<a data-type="indexterm" data-primary="UnicodeScalar" id="calibre_link-2276" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func flag(country:String) -&gt; String {
    let base : UInt32 = 127397
    var s = ""
    for v in country.unicodeScalars {
        s.unicodeScalars.append(UnicodeScalar(base + v.value)!)
    }
    return String(s)
}
// and here's how to use it:
let s = flag(country:"DE")</pre>

<p class="author1">The curious thing is that there arenâ€™t more methods for standard string manipulation. How, for example, do you capitalize a string, or find out whether a string contains a given substring? Most modern programming languages have a compact, convenient way of doing things like that; Swift doesnâ€™t. The reason appears to be that missing features are provided by the Foundation framework, to which youâ€™ll always be linked in real life (importing UIKit imports Foundation). A Swift String is bridged to a Foundation NSString. This means that, to a large extent, Foundation NSString properties and methods magically spring to life whenever you are using a Swift String. For example:<a data-type="indexterm" data-primary="NSString" id="calibre_link-1469" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bridged types" data-secondary="String and NSString" id="calibre_link-296" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello world"
let s2 = s.capitalized // "Hello World"</pre>

<p class="author1">The <code class="calibre19">capitalized</code> property comes from the Foundation framework; itâ€™s provided by Cocoa, not by Swift. Itâ€™s an NSString property; it appears tacked onto String â€œfor free.â€ Similarly, hereâ€™s how to locate a substring of a string:<a data-type="indexterm" data-primary="strings" data-secondary="range" id="calibre_link-2111" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="ranges" data-secondary="string" id="calibre_link-1850" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="searching" id="calibre_link-2113" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="substrings" id="calibre_link-2114" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let range = s.range(of:"ell") // Optional(Range(...)) [details omitted]</pre>

<p class="author1">I havenâ€™t explained yet what an Optional is or what a Range is (Iâ€™ll talk about them later in this chapter), but that innocent-looking code has made a remarkable round-trip from Swift to Cocoa and back again: the Swift String <code class="calibre19">s</code> becomes an NSString, an NSString method is called, a Foundation NSRange struct is returned, and the NSRange is converted to a Swift Range and wrapped up in an Optional.</p>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-59">
<h5 class="calibre36">The String&ndash;NSString Element Mismatch</h5>
<p class="calibre37">Swift and Cocoa have different ideas of what the elements of a string are. The Swift conception involves characters. The NSString conception involves UTF-16 codepoints. Each approach has its advantages. The NSString way makes for great speed and efficiency in comparison to Swift, which must walk the string to investigate how the characters are constructed; but the Swift way gives what you would intuitively think of as the right answer. To emphasize this difference, a nonliteral Swift string has no <code class="calibre19">length</code> property; its analog to an NSStringâ€™s <code class="calibre19">length</code> is its <code class="calibre19">utf16.count</code>.<a data-type="indexterm" data-primary="strings" data-secondary="length" id="calibre_link-2105" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="characters vs. codepoints" id="calibre_link-358" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="codepoints, Unicode" data-secondary="vs. characters" id="calibre_link-447" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre37">Fortunately, the element mismatch doesnâ€™t arise very often in practice; but it can arise. Hereâ€™s a good test case:</p>

<pre data-type="programlisting" class="calibre38">let s = "Ha\u{030A}kon"
print(s.count) // 5
let length = (s as NSString).length // or: s.utf16.count
print(length) // 6</pre>

<p class="calibre37">Weâ€™ve created our string (the Norwegian name HaÌŠkon) using a Unicode codepoint that combines with the previous codepoint to form a character with a ring over it. Swift walks the whole string, so it normalizes the combination and reports five characters. Cocoa just sees at a glance that this string contains six 16-bit codepoints.</p>
</div>
</aside>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Character and String Index" class="calibre2"><div class="preface" id="calibre_link-2452">
<h2 class="calibre42">Character and String Index</h2>

<p class="author1">You are more likely to be interested in a stringâ€™s characters than its codepoints. Codepoints are numbers, but what we naturally think of as characters are effectively minimal strings: a character is a single â€œletterâ€ or â€œsymbolâ€ &mdash; formally, a <em class="calibre11">grapheme</em>. The equivalence between numeric codepoints and symbolic graphemes is provided, in Unicode, by the notion of a grapheme cluster. To embody this equivalence, Swift provides the Character object type (a struct), representing a single grapheme cluster.</p>

<p class="author1">A String (in Swift 4 and later) simply <em class="calibre11">is</em> a character sequence &mdash; quite literally, a Sequence of the Character objects that constitute it. That is why, as I mentioned earlier, you can walk through a string with <code class="calibre19">for...in</code> to obtain the Stringâ€™s Characters, one by one; when you do that, youâ€™re walking through the string <em class="calibre11">qua</em> character sequence:<a data-type="indexterm" data-primary="Character" id="calibre_link-356" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sequence" data-secondary="character" id="calibre_link-1991" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="character sequence" id="calibre_link-357" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="characters" id="calibre_link-2091" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
for c in s {
    print(c) // print each Character on its own line
}</pre>

<p class="author1">It isnâ€™t common to encounter Character objects outside of some character sequence of which they are a part. There isnâ€™t even a way to write a literal Character. To make a Character from scratch, initialize it from a single-character String:</p>

<pre data-type="programlisting" class="calibre28">let c = Character("h")</pre>

<p class="author1">Similarly, you can pass a one-character String literal where a Character is expected, and many examples in this section will do so.</p>

<p class="author1">By the same token, you can initialize a String from a Character:</p>

<pre data-type="programlisting" class="calibre28">let c = Character("h")
let s = (String(c)).uppercased()</pre>

<p class="author1">Characters can be compared for equality; â€œless thanâ€ means what you would expect it to mean.</p>

<p class="author1">Formally, a String is both a Sequence of Characters and a Collection of Characters. Sequence and Collection are protocols; Iâ€™ll discuss protocols in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, but whatâ€™s important for now is that a String is endowed with methods and properties that it gets by virtue of being a Sequence and a Collection.</p>

<p class="author1">For example, a String has a <code class="calibre19">first</code> and <code class="calibre19">last</code> property; the resulting Character is wrapped in an Optional because the string might be empty:<a data-type="indexterm" data-primary="first" id="calibre_link-862" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="last" id="calibre_link-1202" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let c1 = s.first // Optional("h")
let c2 = s.last // Optional("o")</pre>

<p class="author1">The <code class="calibre19">firstIndex(of:)</code> method locates the first occurrence of a given character within the sequence and returns its index. Again, this is an Optional, because the character might be absent:<a data-type="indexterm" data-primary="firstIndex" id="calibre_link-865" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="lastIndex" id="calibre_link-1204" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let firstL = s.firstIndex(of:"l") // Optional(2)</pre>

<p class="author1">All Swift indexes are numbered starting with <code class="calibre19">0</code>, so <code class="calibre19">2</code> means the third character. The index value here, however, is not an Int; Iâ€™ll explain in a moment what it is and what itâ€™s good for.</p>

<p class="author1">A related method, <code class="calibre19">firstIndex(where:)</code>, takes a function that takes a Character and returns a Bool. This code locates the first character smaller than <code class="calibre19">"f"</code>:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let firstSmall = s.firstIndex{$0 &lt; "f"} // Optional(1)</pre>

<p class="author1">Those methods are matched by <code class="calibre19">lastIndex(of:)</code> and <code class="calibre19">lastIndex(where:)</code>.</p>

<p class="author1">A String has a <code class="calibre19">contains(_:)</code> method that returns a Bool, reporting whether a certain character is present:<a data-type="indexterm" data-primary="contains" id="calibre_link-545" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ok = s.contains("o") // true</pre>

<p class="author1">Alternatively, <code class="calibre19">contains(_:)</code> can take a function that takes a Character and returns a Bool. This code reports whether the target string contains a vowel:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ok = s.contains{"aeiou".contains($0)} // true</pre>

<p class="author1">The <code class="calibre19">filter(_:)</code> method, too, takes a function that takes a Character and returns a Bool, effectively eliminating those characters for which <code class="calibre19">false</code> is returned. Here, we delete all consonants from a string:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = s.filter{"aeiou".contains($0)} // "eo"</pre>

<p class="author1">The <code class="calibre19">dropFirst</code> and <code class="calibre19">dropLast</code> methods return, in effect, a new string without the first or last character, respectively:<a data-type="indexterm" data-primary="dropFirst" id="calibre_link-713" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dropLast" id="calibre_link-715" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = s.dropFirst() // "ello"</pre>

<p class="author1">I say â€œin effectâ€ because a method that extracts a substring returns, in reality, a Substring instance. The Substring struct is an efficient way of pointing at part of some original String, rather than having to generate a new String. For example, when we call <code class="calibre19">s.dropFirst()</code> on the string <code class="calibre19">"hello"</code>, the resulting Substring points at the <code class="calibre19">"ello"</code> part of <code class="calibre19">"hello"</code>, which continues to exist; there is still only one string, and no new string storage memory is required.<a data-type="indexterm" data-primary="Substring" id="calibre_link-2157" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In general, the difference between a String and a Substring will make little practical difference to you, because what you can do with a String, you can usually do also with a Substring. Nevertheless, they are different classes; this code wonâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let s2 = s.dropFirst()
s = s2 // compile error</pre>

<p class="author1">To pass a Substring where a String is expected, coerce the Substring to a String <span class="publishername">explicitly:</span></p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let s2 = s.dropFirst()
s = String(s2)</pre>

<p class="author1"><code class="calibre19">prefix(_:)</code> and <code class="calibre19">suffix(_:)</code> extract a Substring of a given length from the start or end of the original string:<a data-type="indexterm" data-primary="prefix" id="calibre_link-1717" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="suffix" id="calibre_link-2159" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
s = String(s.prefix(4)) // "hell"</pre>

<p class="author1"><code class="calibre19">split(_:)</code> breaks a string up into an array, according to a function that takes a Character and returns a Bool. In this example, I obtain the words of a String, where a â€œwordâ€ is simplemindedly defined as a run of Characters other than a space:<a data-type="indexterm" data-primary="split" id="calibre_link-2053" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello world"
let arr = s.split{$0 == " "} // ["hello", "world"]</pre>

<p class="author1">The result is actually an array of Substrings. If we needed to get String objects, we could apply the <code class="calibre19">map(_:)</code> function and coerce them all to Strings. Iâ€™ll talk about <code class="calibre19">map(_:)</code> in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, so youâ€™ll have to trust me for now:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello world"
let arr = s.split{$0 == " "}.map{String($0)} // ["hello", "world"]</pre>

<p class="author1">A String, <em class="calibre11">qua</em> character sequence, can also be manipulated similarly to an array. For example, you can use subscripting to obtain the character at a certain position. Unfortunately, this isnâ€™t as easy as it might be. For example, whatâ€™s the second character of <code class="calibre19">"hello"</code>? This doesnâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let c = s[1] // compile error</pre>

<p class="author1">The reason is that the indexes on a String are not Int values, but rather a special nested type, a <span class="publishername">String.Index</span> (which is actually a type alias for <span class="publishername">String.CharacterView.Index</span>). To make an object of this type is rather tricky. Start with a Stringâ€™s <code class="calibre19">startIndex</code> or <code class="calibre19">endIndex</code>, or with the return value from <code class="calibre19">firstIndex</code> or <code class="calibre19">lastIndex</code>; you can then call the <code class="calibre19">index(_:offsetBy:)</code> method to derive the index you want:<a data-type="indexterm" data-primary="subscripting" id="calibre_link-2145" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="indexing" id="calibre_link-2098" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="indexing a string" id="calibre_link-1052" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="startIndex" id="calibre_link-2061" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="endIndex" id="calibre_link-735" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="String.Index" id="calibre_link-2086" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ix = s.startIndex
let ix2 = s.index(ix, offsetBy:1)
let c = s[ix2] // "e"</pre>

<p class="author1">The reason for this clumsy circumlocution is that Swift doesnâ€™t know where the characters of a character sequence are until it actually walks the sequence; calling <code class="calibre19">index(_:offsetBy:)</code> is how you make Swift do that.</p>

<p class="author1">To offset an index by a single position, you can obtain the next or preceding index value with the <code class="calibre19">index(after:)</code> and <code class="calibre19">index(before:)</code> methods. Thus, I could have written the preceding example like this:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ix = s.startIndex
let c = s[s.index(after:ix)] // "e"</pre>

<p class="author1">Another reason why itâ€™s necessary to think of a string index as an offset from the <code class="calibre19">startIndex</code> or <code class="calibre19">endIndex</code> is that those values may not be what you think they are &mdash; in particular, when youâ€™re dealing with a Substring. Consider, once again, the following:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = s.dropFirst()</pre>

<p class="author1">Now <code class="calibre19">s2</code> is <code class="calibre19">"ello"</code>. What, then, is <code class="calibre19">s2.startIndex</code> (as an Int)? Not 0, but 1 &mdash; because <code class="calibre19">s2</code> is a Substring pointing into the original <code class="calibre19">"hello"</code>, where the index of the <code class="calibre19">"e"</code> is 1. Similarly, <code class="calibre19">s2.firstIndex(of:"o")</code> is not 3, but 4, because the index value is reckoned with respect to the original <code class="calibre19">"hello"</code>.</p>

<p class="author1">Once youâ€™ve obtained a desired character index value, you can use it to modify the String. For example, the <code class="calibre19">insert(contentsOf:at:)</code> method inserts a string into a string:<a data-type="indexterm" data-primary="insert" id="calibre_link-1105" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let ix = s.index(s.startIndex, offsetBy:1)
s.insertContentsOf("ey, h", at: ix) // s is now "hey, hello"</pre>

<p class="author1">Similarly, <code class="calibre19">remove(at:)</code> deletes a single character, and also returns that character. (Manipulations involving longer character stretches require use of a Range, which is the subject of the next section.)<a data-type="indexterm" data-primary="remove" id="calibre_link-1889" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">On the other hand, a character sequence can be coerced directly to an Array of Character objects &mdash; for example, <code class="calibre19">Array("hello")</code> creates an array of the characters <code class="calibre19">"h"</code>, <code class="calibre19">"e"</code>, and so on &mdash; and array indexes <em class="calibre11">are</em> Ints, and are thus easy to work with. Once youâ€™ve manipulated the array of Characters, you can coerce it directly to a String. Iâ€™ll give an example in the next section (and Iâ€™ll discuss arrays, and say more about collections and sequences, in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>).</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Range" class="calibre2"><div class="preface" id="calibre_link-2453">
<h2 class="calibre42">Range</h2>

<p class="author1">The Range object type (a struct) represents a pair of endpoints. There are two operators for forming a Range literal; you supply a start value and an end value, with one of the Range operators between them:<a data-type="indexterm" data-primary="ranges" id="calibre_link-1840" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="interval" id="calibre_link-1574" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="interval operators" id="calibre_link-1156" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Range" id="calibre_link-1839" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">...</code> (closed range operator)</dt>
<dd class="calibre16">
<p class="calibre17">The notation <code class="calibre19">a...b</code> means â€œeverything from <code class="calibre19">a</code> up to <code class="calibre19">b</code>, <em class="calibre11">including</em> <code class="calibre19">b</code>.â€</p>
</dd>
<dt class="calibre15"><code class="calibre19">..&lt;</code> (half-open range operator)</dt>
<dd class="calibre16">
<p class="calibre17">The notation <code class="calibre19">a..&lt;b</code> means â€œeverything from <code class="calibre19">a</code> up to but <em class="calibre11">not</em> including <code class="calibre19">b</code>.â€</p>
</dd>
</dl>

<p class="author1">Spaces around a Range operator are legal.</p>

<p class="author1">The types of a Rangeâ€™s endpoints will typically be some kind of number &mdash; most often, Ints:</p>

<pre data-type="programlisting" class="calibre28">let r = 1...3</pre>

<p class="author1">If the end value is a negative literal, it has to be enclosed in parentheses or preceded by whitespace:</p>

<pre data-type="programlisting" class="calibre28">let r = -1000 ... -1</pre>

<p class="author1">A very common use of a Range is to loop through numbers with <code class="calibre19">for...in</code>:</p>

<pre data-type="programlisting" class="calibre28">for ix in 1...3 {
    print(ix) // 1, then 2, then 3
}</pre>

<p class="author1">There are no reverse Ranges: the start value of a Range canâ€™t be greater than the end value (the compiler wonâ€™t stop you, but youâ€™ll crash at runtime). In practice, you can use Rangeâ€™s <code class="calibre19">reversed()</code> method to iterate from a higher value to a lower one:<a data-type="indexterm" data-primary="reversed" id="calibre_link-1937" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">for ix in (1...3).reversed() {
    print(ix) // 3, then 2, then 1
}</pre>

<p class="author1">In <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> Iâ€™ll show how to create a custom operator that effectively generates a reverse Range.</p>

<p class="author1">You can also use a Rangeâ€™s <code class="calibre19">contains(_:)</code> instance method to test whether a value falls within given limits:<a data-type="indexterm" data-primary="contains" id="calibre_link-546" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let ix = // ... an Int ...
if (1...3).contains(ix) { // ...</pre>

<p class="author1">For purposes of testing containment, a Rangeâ€™s endpoints can be Doubles:</p>

<pre data-type="programlisting" class="calibre28">let d = // ... a Double ...
if (0.1...0.9).contains(d) { // ...</pre>

<p class="author1">There are also methods for learning whether two ranges overlap, and for clamping one range to another.</p>

<p class="author1">Another common use of a Range is to index into a sequence. For example, hereâ€™s one way to get the second, third, and fourth characters of a String. As I suggested at the end of the preceding section, if we coerce the String to an Array of Character, we can then use an Int Range as an index into that array, and coerce back to a String:<a data-type="indexterm" data-primary="sequence" data-secondary="range indexing" id="calibre_link-1999" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let arr = Array(s)
let result = arr[1...3]
let s2 = String(result) // "ell"</pre>

<p class="author1">A String is itself a sequence &mdash; a character sequence &mdash; so you can use a Range to index directly into a String; but then it has to be a Range of <span class="publishername">String.Index</span>, which, as Iâ€™ve already pointed out, is rather tricky to obtain. By manipulating <span class="publishername">String.Index</span> values, you can form a Range of the proper type and use it to extract a substring by <span class="publishername">subscripting:</span><a data-type="indexterm" data-primary="ranges" data-secondary="indexing with" id="calibre_link-1842" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subscripting" id="calibre_link-2146" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="indexing" id="calibre_link-2099" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="indexing a string" id="calibre_link-1053" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ix1 = s.index(s.startIndex, offsetBy:1)
let ix2 = s.index(ix1, offsetBy:2)
let s2 = s[ix1...ix2] // "ell"</pre>

<p class="author1">The <code class="calibre19">replaceSubrange(_:with:)</code> method splices into a range, thus modifying the string:<a data-type="indexterm" data-primary="replaceSubrange" id="calibre_link-1898" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="modifying" id="calibre_link-2109" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let ix = s.startIndex
let r = s.index(ix, offsetBy:1)...s.index(ix, offsetBy:3)
s.replaceSubrange(r, with: "ipp") // s is now "hippo"</pre>

<p class="author1">Similarly, you can delete a stretch of characters with the <code class="calibre19">removeSubrange(_:)</code> method:<a data-type="indexterm" data-primary="removeSubrange" id="calibre_link-1893" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-startref="idxsubstrings" id="calibre_link-2115" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxstrings" id="calibre_link-2089" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
let ix = s.startIndex
let r = s.index(ix, offsetBy:1)...s.index(ix, offsetBy:3)
s.removeSubrange(r) // s is now "ho"</pre>

<p class="author1">It is possible to omit one of the endpoints from a Range literal, thus specifying a <em class="calibre11">partial range</em>. There are three kinds of partial range expression, corresponding to three types of Range-like struct. To illustrate, the following expressions are identical ways of specifying the range of an entire String <code class="calibre19">s</code>:<a data-type="indexterm" data-primary="ranges" data-secondary="partial" id="calibre_link-1845" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="partial range" id="calibre_link-1686" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let range1 = s.startIndex..&lt;s.endIndex      // Range
let range2 = ..&lt;s.endIndex                  // PartialRangeUpTo
let range3 = ...s.index(before: s.endIndex) // PartialRangeUpThrough
let range4 = s.startIndex...                // PartialRangeFrom</pre>

<p class="author1">If you need to convert a partial range to a range, call <code class="calibre19">relative(to:)</code>. For example, in the preceding code, <code class="calibre19">range1</code> and <code class="calibre19">range2.relative(to:s)</code> are identical. But in general you wonâ€™t need to do that, because a partial range literal can be used wherever you would use a range literal. For instance, a partial range is a legal String subscript value:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ix2 = s.index(before: s.endIndex)
let s2 = s[..&lt;ix2] // "hell"</pre>

<p class="author1">Iâ€™ll show further practical examples later on.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Tuple" class="calibre2"><div class="preface" id="calibre_link-2454">
<h2 class="calibre42">Tuple</h2>

<p class="author1">A <em class="calibre11">tuple</em> is a lightweight custom ordered collection of multiple values.
As a type, it is expressed by surrounding the types of the contained values with parentheses, separated by a comma. For example, hereâ€™s a declaration for a variable whose type is a tuple of an Int and a String:<a data-type="indexterm" data-primary="tuples" id="calibre_link-2226" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parentheses" data-secondary="tuples" id="calibre_link-1685" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="tuples" id="calibre_link-482" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var pair : (Int, String)</pre>

<p class="author1">The literal value of a tuple is expressed in the same way &mdash; the contained values, surrounded with parentheses and separated by a comma:</p>

<pre data-type="programlisting" class="calibre28">var pair : (Int, String) = (1, "Two")</pre>

<p class="author1">Those types can be inferred, so thereâ€™s no need for the explicit type in the declaration:</p>

<pre data-type="programlisting" class="calibre28">var pair = (1, "Two")</pre>

<p class="author1">Tuples are a pure Swift language feature; they are not compatible with Cocoa and Objective-C, so youâ€™ll use them only for values that Cocoa never sees. Within Swift, however, they have many uses. For example, a tuple is an obvious solution to the problem that a function can return only one value; a tuple <em class="calibre11">is</em> one value, but it <em class="calibre11">contains</em> multiple values, so using a tuple as the return type of a function permits that function to return multiple values.</p>

<p class="author1">Tuples come with numerous linguistic conveniences. You can assign to a tuple of variable names as a way of assigning to multiple variables simultaneously:</p>

<pre data-type="programlisting" class="calibre28">let ix: Int
let s: String
(ix, s) = (1, "Two")</pre>

<p class="author1">Thatâ€™s such a convenient thing to do that Swift lets you do it in one line, declaring and initializing multiple variables simultaneously:<a data-type="indexterm" data-primary="assignment" data-secondary="multiple" id="calibre_link-220" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let (ix, s) = (1, "Two")</pre>

<p class="author1">To ignore one of the assigned values, use an underscore to represent it in the receiving tuple:<a data-type="indexterm" data-primary="underscore" data-secondary="assignment to" id="calibre_link-2270" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pair = (1, "Two")
let (_, s) = pair // now s is "Two"</pre>

<p class="author1">Assigning variable values to one another through a tuple swaps them safely:<a data-type="indexterm" data-primary="swapping variables" id="calibre_link-2167" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="swapping" id="calibre_link-2337" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s1 = "hello"
var s2 = "world"
(s1, s2) = (s2, s1) // now s1 is "world" and s2 is "hello"</pre>

<p class="author1">The <code class="calibre19">enumerated</code> method lets you walk a sequence with <code class="calibre19">for...in</code> and receive, on each iteration, each successive elementâ€™s index number along with the element itself; this double result comes to you as &mdash; you guessed it &mdash; a tuple:<a data-type="indexterm" data-primary="enumerated" id="calibre_link-743" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sequence" data-secondary="enumerating with index" id="calibre_link-1994" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="index, enumerate with" id="calibre_link-1049" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
for (ix,c) in s.enumerated() {
    print("character \(ix) is \(c)")
}</pre>

<p class="author1">I also pointed out earlier that numeric instance methods such as <code class="calibre19">addingReportingOverflow</code> return a tuple.</p>

<p class="author1">You can refer to the individual elements of a tuple directly, in two ways. The first way is by index number, using a <em class="calibre11">literal number</em> (not a variable value) as the name of a message sent to the tuple with dot-notation:<a data-type="indexterm" data-primary="dot-notation" data-secondary="tuples" id="calibre_link-708" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pair = (1, "Two")
let ix = pair.0 // now ix is 1</pre>

<p class="author1">If you have a <code class="calibre19">var</code> reference to a tuple, you can assign into it by the same means:</p>

<pre data-type="programlisting" class="calibre28">var pair = (1, "Two")
pair.0 = 2 // now pair is (2, "Two")</pre>

<p class="author1">The second way to access tuple elements is to give them labels. The notation is like that of function parameters, and must appear as part of the explicit or implicit type declaration. Thus, hereâ€™s one way to establish tuple element labels:<a data-type="indexterm" data-primary="labels" data-secondary="tuples" id="calibre_link-1200" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pair : (first:Int, second:String) = (1, "Two")</pre>

<p class="author1">And hereâ€™s another way:</p>

<pre data-type="programlisting" class="calibre28">let pair = (first:1, second:"Two")</pre>

<p class="author1">The labels are now part of the type of this value, and travel with it through subsequent assignments. You can then use them as literal messages, just like (and together with) the numeric literals:</p>

<pre data-type="programlisting" class="calibre28">var pair = (first:1, second:"Two")
let x = pair.first // 1
pair.first = 2
let y = pair.0 // 2</pre>

<p class="author1">The tuple generated by the <code class="calibre19">enumerated</code> method has labels <code class="calibre19">offset</code> and <code class="calibre19">element</code>, so we can rewrite an earlier example like this:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
for t in s.enumerated() {
    print("character \(t.offset) is \(t.element)")
}</pre>

<p class="author1">You can assign from a tuple without labels into a corresponding tuple with labels (and <em class="calibre11">vice versa</em>):</p>

<pre data-type="programlisting" class="calibre28">let pair = (1, "Two")
let pairWithNames : (first:Int, second:String) = pair
let ix = pairWithNames.first // 1</pre>

<p class="author1">You can also pass, or return from a function, a tuple without labels where a corresponding tuple with labels is expected:</p>

<pre data-type="programlisting" class="calibre28">func tupleMaker() -&gt; (first:Int, second:String) {
    return (1, "Two") // no labels here
}
let ix = tupleMaker().first // 1</pre>

<p class="author1">If youâ€™re going to be using a certain type of tuple consistently throughout your program, it might be useful to give it a type name. To do so, define a type alias. For example, in my LinkSame app I have a Board class describing and manipulating the game layout. The board is a grid of Piece objects. I need a way to describe positions of the grid. Thatâ€™s a pair of integers, so I define my own type as a tuple:<a data-type="indexterm" data-primary="type alias" id="calibre_link-2245" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Board {
    typealias Point = (x:Int, y:Int)
    // ...
}</pre>

<p class="author1">The advantage of that notation is that it now becomes easy to use Points throughout my code. For example, given a Point, I can fetch the corresponding Piece:</p>

<pre data-type="programlisting" class="calibre28">func piece(at p:Point) -&gt; Piece? {
    let (i,j) = p
    // ... error-checking goes here ...
    return self.grid[i][j]
}</pre>

<p class="author1">Still, one should not overuse tuples. In a very real sense, they are not a full-fledged type. Keep your tuples small, light, and temporary.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Void, the type of value returned by a function that doesnâ€™t return a value, is actually a type alias for an empty tuple. Thatâ€™s why it is also notated as <code class="calibre19">()</code>.<a data-type="indexterm" data-primary="Void" id="calibre_link-2358" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parentheses" data-secondary="signifying Void" id="calibre_link-1684" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Optional" class="calibre2"><div class="preface" id="calibre_link-2455">
<h2 class="calibre42">Optional</h2>

<p class="author1">The Optional object type (an enum) wraps another object of any type. What makes an Optional optional is this: it <em class="calibre11">might</em> wrap another object, but then again it might not. Think of an Optional as being itself a kind of shoebox &mdash; a shoebox which can quite legally be empty.<a data-type="indexterm" data-primary="Optionals" id="calibre_link-1594" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Letâ€™s start by creating an Optional that does wrap an object. Suppose we want an Optional wrapping the String <code class="calibre19">"howdy"</code>. One way to create it is with the Optional <span class="publishername">initializer:</span><a data-type="indexterm" data-primary="Optionals" data-secondary="creating" id="calibre_link-1601" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe = Optional("howdy")</pre>

<p class="author1">If we log <code class="calibre19">stringMaybe</code> to the console with <code class="calibre19">print</code>, weâ€™ll see an expression identical to the corresponding initializer: <code class="calibre19">Optional("howdy")</code>.</p>

<p class="author1">After that declaration and initialization, <code class="calibre19">stringMaybe</code> is typed, not as a String, nor as an Optional plain and simple, but as an Optional wrapping a String. This means that any other Optional wrapping a String can be assigned to it &mdash; but not an Optional wrapping some other type. This code is legal:<a data-type="indexterm" data-primary="Optionals" data-secondary="type" id="calibre_link-1621" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="of Optional" id="calibre_link-2237" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe = Optional("howdy")
stringMaybe = Optional("farewell")</pre>

<p class="author1">This code, however, is not legal:</p>

<pre data-type="programlisting" class="calibre28">var stringMaybe = Optional("howdy")
stringMaybe = Optional(123) // compile error</pre>

<p class="author1"><code class="calibre19">Optional(123)</code> is an Optional wrapping an Int, and you canâ€™t assign an Optional wrapping an Int where an Optional wrapping a String is expected.</p>

<p class="author1">Optionals are so important to Swift that special syntax for working with them is baked into the language. The usual way to make an Optional is not to use the Optional initializer (though you can certainly do that), but to assign or pass a value of some type to a reference that is already typed as an Optional wrapping that type. This seems as if it should not be legal &mdash; but it is. For example, once <code class="calibre19">stringMaybe</code> is typed as an Optional wrapping a String, it is legal to assign a String directly to it. The outcome is that the assigned String is wrapped in an Optional for us, automatically:<a data-type="indexterm" data-primary="Optionals" data-secondary="wrapping" id="calibre_link-1630" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe = Optional("howdy")
stringMaybe = "farewell" // now stringMaybe is Optional("farewell")</pre>

<p class="author1">We also need a way of typing something <em class="calibre11">explicitly</em> as an Optional wrapping a String. Otherwise, we cannot declare a variable or parameter with an Optional type. Formally, an Optional is a generic, so an Optional wrapping a String is an <code class="calibre19">Optional&lt;String&gt;</code>. (Iâ€™ll explain that syntax in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>.) However, you donâ€™t have to write that. The Swift language supports syntactic sugar for expressing an Optional type: use the name of the wrapped type followed by a question mark:<a data-type="indexterm" data-primary="Optionals" data-secondary="declaration" id="calibre_link-1602" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="question mark" id="calibre_link-1827" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String?</pre>

<p class="author1">Thus I donâ€™t need to use the Optional initializer at all. I can type the variable as an Optional wrapping a String and assign a String into it for wrapping, all in one move:</p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String? = "howdy"</pre>

<p class="author1">That, in fact, is the normal way to make an Optional in Swift.</p>

<p class="author1">Once youâ€™ve got an Optional wrapping a particular type, you can use it wherever an Optional wrapping that type is expected &mdash; just like any other value. If a function expects an Optional wrapping a String as its parameter, you can pass <code class="calibre19">stringMaybe</code> as the argument:</p>

<pre data-type="programlisting" class="calibre28">func optionalExpecter(_ s:String?) {}
let stringMaybe : String? = "howdy"
optionalExpecter(stringMaybe)</pre>

<p class="author1">Moreover, where an Optional wrapping a certain type of value is expected, you can pass a value of that wrapped type instead. Thatâ€™s because parameter passing is just like assignment: an unwrapped value will be wrapped implicitly for you. For example, if a function expects an Optional wrapping a String, you can pass a String argument, which will be wrapped into an Optional in the received parameter:</p>

<pre data-type="programlisting" class="calibre28">func optionalExpecter(_ s:String?) {
    // ... here, s will be an Optional wrapping a String ...
    print(s)
}
optionalExpecter("howdy") // console prints: Optional("howdy")</pre>

<p class="author1">But you cannot do the opposite &mdash; you cannot use an Optional wrapping a type where the wrapped type is expected. This wonâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">func realStringExpecter(_ s:String) {}
let stringMaybe : String? = "howdy"
realStringExpecter(stringMaybe) // compile error</pre>

<p class="author1">The error message reads: â€œValue of Optional type <code class="calibre19">String?</code> must be unwrapped.â€ Youâ€™re going to be seeing that sort of message a lot in Swift, so get used to it!
If you want to use an Optional where the type of thing it wraps is expected, you must <em class="calibre11">unwrap</em> the Optional &mdash; that is, you must reach inside it and <em class="calibre11">retrieve</em> the actual thing that it wraps. Now Iâ€™m going to talk about how to do that.<a data-type="indexterm" data-primary="errors, compiler" data-secondary="value of Optional type must be unwrapped" id="calibre_link-805" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Unwrapping an Optional" class="calibre2"><div class="preface" id="calibre_link-2910">
<h3 class="calibre44">Unwrapping an Optional</h3>

<p class="author1">We have seen more than one way to wrap an object in an Optional. But what about the opposite procedure? How do we unwrap an Optional to get at the object wrapped inside it? One way is to use the <em class="calibre11">unwrap operator</em> (or <em class="calibre11">forced unwrap operator</em>), which is a postfixed exclamation mark:<a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1623" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="unwrap" id="calibre_link-1580" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="forced unwrap operator" id="calibre_link-884" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="unwrapping an Optional" id="calibre_link-2298" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="exclamation mark" id="calibre_link-814" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func realStringExpecter(_ s:String) {}
let stringMaybe : String? = "howdy"
realStringExpecter(stringMaybe!)</pre>

<p class="author1">In that code, the <code class="calibre19">stringMaybe!</code> syntax expresses the operation of reaching inside the Optional <code class="calibre19">stringMaybe</code>, grabbing the wrapped value, and substituting it at that point. Since <code class="calibre19">stringMaybe</code> is an Optional wrapping a String, the thing inside it is a String. That is exactly what the <code class="calibre19">realStringExpecter</code> function wants as its parameter! <code class="calibre19">stringMaybe</code> is an Optional <em class="calibre11">wrapping</em> the String <code class="calibre19">"howdy"</code>, but <code class="calibre19">stringMaybe!</code> <em class="calibre11">is</em> the String <code class="calibre19">"howdy"</code>.</p>

<p class="author1">If an Optional wraps a certain type, you cannot send it a message expected by that type. You must unwrap it first. For example, letâ€™s try to get an uppercase version of <code class="calibre19">stringMaybe</code>:</p>

<pre data-type="programlisting" class="calibre28">let stringMaybe : String? = "howdy"
let upper = stringMaybe.uppercased() // compile error</pre>

<p class="author1">The solution is to unwrap <code class="calibre19">stringMaybe</code> to get at the String inside it. We can do this directly, in place, using the unwrap operator:</p>

<pre data-type="programlisting" class="calibre28">let stringMaybe : String? = "howdy"
let upper = stringMaybe!.uppercased()</pre>

<p class="author1">If an Optional is to be used several times where the unwrapped type is expected, and if youâ€™re going to be unwrapping it with the unwrap operator each time, your code can quickly start to look like the dialog from a 1960s Batman comic. For example, an appâ€™s window is an Optional UIWindow property (<code class="calibre19">self.window</code>):</p>

<pre data-type="programlisting" class="calibre28">// self.window is an Optional wrapping a UIWindow
self.window!.rootViewController = RootViewController()
self.window!.backgroundColor = UIColor.white
self.window!.makeKeyAndVisible()</pre>

<p class="author1">That sort of thing soon gets old (or silly). One obvious alternative is to assign the unwrapped value <em class="calibre11">once</em> to a variable of the wrapped type and then use that variable:</p>

<pre data-type="programlisting" class="calibre28">// self.window is an Optional wrapping a UIWindow
let window = self.window!
// now window (not self.window) is a UIWindow, not an Optional
window.rootViewController = RootViewController()
window.backgroundColor = UIColor.white
window.makeKeyAndVisible()</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Implicitly unwrapped Optional" class="calibre2"><div class="preface" id="calibre_link-2911">
<h3 class="calibre44">Implicitly unwrapped Optional</h3>

<p class="author1">Swift provides another way of using an Optional where the wrapped type is expected: you can declare the Optional <em class="calibre11">type</em> as being <em class="calibre11">implicitly unwrapped</em>. An implicitly unwrapped Optional is an Optional, but the compiler permits some special magic associated with it: its value can be used <em class="calibre11">directly</em> where the wrapped type is expected. You <em class="calibre11">can</em> unwrap an implicitly unwrapped Optional explicitly, but you donâ€™t have to, because it will be unwrapped for you, automatically, if you try to use it where the wrapped type is expected. Moreover, Swift provides syntactic sugar for expressing an implicitly unwrapped Optional type. Just as an Optional wrapping a String can be expressed as <code class="calibre19">String?</code>, an implicitly unwrapped Optional wrapping a String can be expressed as <code class="calibre19">String!</code>:<a data-type="indexterm" data-primary="Optionals" data-secondary="implicitly unwrapped" id="calibre_link-1612" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="implicitly unwrapped Optional" id="calibre_link-1045" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="exclamation mark" id="calibre_link-815" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func realStringExpecter(_ s:String) {}
var stringMaybe : String! = "howdy"
realStringExpecter(stringMaybe) // no problem</pre>

<p class="author1">Bear in mind that <em class="calibre11">an implicitly unwrapped Optional is still an Optional.</em> Itâ€™s just a convenience. By declaring something as an implicitly unwrapped Optional, you are asking the compiler, if you happen to use this value where the wrapped type is expected, to forgive you and to unwrap the value for you.</p>

<p class="author1">In reality, an implicitly unwrapped Optional type is not really a distinct type; it is merely an Optional marked in a special way that allows it to be used where the unwrapped type is expected. For this reason, implicit unwrapping does not propagate by assignment. Hereâ€™s a case in point. If <code class="calibre19">self</code> is a UIViewController, then <code class="calibre19">self.view</code> is typed as <code class="calibre19">UIView!</code>. As a result, this expression is legal (assume <code class="calibre19">v</code> is a UIView):</p>

<pre data-type="programlisting" class="calibre28">self.view.addSubview(v)</pre>

<p class="author1">But this is not legal:</p>

<pre data-type="programlisting" class="calibre28">let mainview = self.view
mainview.addSubview(v) // compile error</pre>

<p class="author1">The problem is that, although <code class="calibre19">self.view</code> is an implicitly unwrapped Optional wrapping a UIView, <code class="calibre19">mainview</code> is a <em class="calibre11">normal</em> Optional wrapping a UIView, and so it would have to be unwrapped explicitly before you could send it the <code class="calibre19">addSubview</code> message. Alternatively, you could unwrap the implicitly unwrapped Optional explicitly at the outset:</p>

<pre data-type="programlisting" class="calibre28">let mainview = self.view!
mainview.addSubview(v)</pre>

<p class="author1">In real life, the primary situation in which youâ€™re likely to declare an implicitly unwrapped Optional is when an instance propertyâ€™s initial value canâ€™t be provided until after the instance itself is created. Iâ€™ll give some examples at the end of this chapter.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="The keyword nil" class="calibre2"><div class="preface" id="calibre_link-2912">
<h3 class="calibre44">The keyword nil</h3>

<p class="author1">I have talked so far about Optionals that contain a wrapped value. But what about an Optional that <em class="calibre11">doesnâ€™t</em> contain any wrapped value? Such an Optional is, as Iâ€™ve already said, a perfectly legal entity; that, indeed, is the whole point of Optionals.</p>

<p class="author1">You are going to need a way to <em class="calibre11">ask</em> whether an Optional contains a wrapped value, and a way to <em class="calibre11">specify</em> an Optional <em class="calibre11">without</em> a wrapped value. Swift makes both of those things easy, through the use of a special keyword, <code class="calibre19">nil</code>:<a data-type="indexterm" data-primary="nil" id="calibre_link-1405" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="nil" id="calibre_link-1618" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="empty" id="calibre_link-1607" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">To learn whether an Optional contains a wrapped value</dt>
<dd class="calibre16">
<p class="calibre17">Test the Optional for equality against <code class="calibre19">nil</code>. If the test succeeds, the Optional is empty. An empty Optional is also reported in the console as <code class="calibre19">nil</code>.</p>
</dd>
<dt class="calibre15">To specify an Optional with no wrapped value</dt>
<dd class="calibre16">
<p class="calibre17">Assign or pass <code class="calibre19">nil</code> where the Optional type is expected. The result is an Optional of the expected type, containing no wrapped value.</p>
</dd>
</dl>

<p class="author1">For example:</p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String? = "Howdy"
print(stringMaybe) // Optional("Howdy")
if stringMaybe == nil {
    print("it is empty") // does not print
}
stringMaybe = nil
print(stringMaybe) // nil
if stringMaybe == nil {
    print("it is empty") // prints
}</pre>

<p class="author1">The keyword <code class="calibre19">nil</code> lets you express the concept, â€œan Optional wrapping the appropriate type, but not actually containing any object of that type.â€ Clearly, thatâ€™s very convenient magic; youâ€™ll want to take advantage of it. It is very important to understand, however, that it <em class="calibre11">is</em> magic: <code class="calibre19">nil</code> in Swift is <em class="calibre11">not</em> a thing and is <em class="calibre11">not</em> a value. <em class="calibre11">It is a shorthand.</em> It is natural to think and speak as if this shorthand were real. For example, I will say that something â€œis <code class="calibre19">nil</code>.â€ But in reality, nothing â€œis <code class="calibre19">nil</code>â€; <code class="calibre19">nil</code> isnâ€™t a thing. What I really mean is that this thing is equatable with <code class="calibre19">nil</code>, because it is an Optional not wrapping anything. (Iâ€™ll explain in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> how <code class="calibre19">nil</code>, and Optionals in general, really work.)</p>

<p class="author1">Because a variable typed as an Optional can be <code class="calibre19">nil</code>, Swift follows a special initialization rule: a variable (<code class="calibre19">var</code>) typed as an Optional <em class="calibre11">is</em> <code class="calibre19">nil</code>, automatically:<a data-type="indexterm" data-primary="Optionals" data-secondary="initialization" id="calibre_link-1614" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initialization" data-secondary="of Optionals" id="calibre_link-1079" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="initialization" data-tertiary="of Optional" id="calibre_link-2328" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func optionalExpecter(_ s:String?) {}
var stringMaybe : String?
optionalExpecter(stringMaybe)</pre>

<p class="author1">That code looks as if it should be illegal. We declared a variable <code class="calibre19">stringMaybe</code>, but we never assigned it a value. Nevertheless we are now passing it around as if it were an actual thing. Thatâ€™s because it <em class="calibre11">is</em> an actual thing. This variable has been <em class="calibre11">implicitly initialized</em> &mdash; to <code class="calibre19">nil</code>. A variable (<code class="calibre19">var</code>) typed as an Optional is the <em class="calibre11">only</em> sort of variable that gets implicit initialization in Swift.</p>

<p class="author1">We come now to perhaps the most important rule in all of Swift: You <em class="calibre11">cannot unwrap an Optional containing nothing</em> (an Optional equatable with <code class="calibre19">nil</code>). Such an Optional contains nothing; thereâ€™s nothing to unwrap. Like Oakland, thereâ€™s no there there. In fact, explicitly unwrapping an Optional containing nothing will <em class="calibre11">crash your program</em> at runtime:<a data-type="indexterm" data-primary="nil" data-secondary="unwrapping" id="calibre_link-1410" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="fatal error" data-see="crash" id="calibre_link-2913" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String?
let s = stringMaybe! // crash</pre>

<p class="author1">The crash message reads: â€œFatal error: unexpectedly found <code class="calibre19">nil</code> while unwrapping an Optional value.â€ Get used to it, because youâ€™re going to be seeing it a lot. This is an easy mistake to make. Unwrapping an Optional that contains no value is, in fact, probably the most common way to crash a Swift program. You should look upon this kind of crash as a blessing. Very often, in fact, you will <em class="calibre11">want</em> to crash if your Optional contains no value, because it <em class="calibre11">should</em> contain a value, and the fact that it doesnâ€™t indicates that youâ€™ve made a mistake elsewhere.<a data-type="indexterm" data-primary="crash" data-secondary="unexpectedly found nil" id="calibre_link-569" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In the long run, however, crashing is bad. To eliminate this kind of crash, you need to ensure that your Optional contains a value, and <em class="calibre11">donâ€™t</em> unwrap it if it doesnâ€™t! Ensuring that an Optional contains a value before attempting to unwrap it is clearly a very important thing to do. Accordingly, Swift provides several convenient ways of doing it. Iâ€™ll describe some of them now, and Iâ€™ll discuss others in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>.</p>

<p class="author1">One obvious approach is to test your Optional against <code class="calibre19">nil</code> explicitly before you unwrap it:<a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1624" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String?
// ... stringMaybe might be assigned a real value here ...
if stringMaybe != nil {
    let s = stringMaybe!
    // ...
}</pre>

<p class="author1">But thereâ€™s a more elegant way, as I shall now explain.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Optional chains" class="calibre2"><div class="preface" id="calibre_link-2914">
<h3 class="calibre44">Optional chains</h3>

<p class="author1">A common situation is that you want to send a message to the value wrapped inside an Optional. You <em class="calibre11">cannot</em> send such a message to the Optional <em class="calibre11">itself</em>. If you try to do so, you will get an error message from the <span class="publishername">compiler:</span><a data-type="indexterm" data-primary="messages" data-secondary="to Optionals" id="calibre_link-1326" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="messages to" id="calibre_link-1616" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let stringMaybe : String? = "howdy"
let upper = stringMaybe.uppercased() // compile error</pre>

<p class="author1">You must unwrap the Optional first, so that you can send that message to the <em class="calibre11">actual</em> thing wrapped inside. Conveniently, you can unwrap the Optional <em class="calibre11">in place</em>. I gave an example earlier:<a data-type="indexterm" data-primary="Optional chains" id="calibre_link-1587" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dot-notation" data-secondary="Optionals" id="calibre_link-707" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="chain" id="calibre_link-1599" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="chains" data-secondary="Optional" id="calibre_link-354" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let stringMaybe : String? = "howdy"
let upper = stringMaybe!.uppercased()</pre>

<p class="author1">That form of code is called an <em class="calibre11">Optional chain</em>. In the middle of a chain of dot-notation, you have unwrapped an Optional.</p>

<p class="author1">However, if you unwrap an Optional that contains no wrapped object, youâ€™ll crash. So what if youâ€™re <em class="calibre11">not sure</em> whether this Optional contains a wrapped object? How can you send a message to the value inside an Optional in that situation?</p>

<p class="author1">Swift provides a special shorthand for exactly this purpose. To send a message <em class="calibre11">safely</em> to the value wrapped inside an Optional that might be empty, you can <em class="calibre11">unwrap the Optional optionally.</em> To do so, unwrap the Optional with the question mark postfix operator instead of the exclamation mark:<a data-type="indexterm" data-primary="optional unwrap operator" id="calibre_link-1593" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="unwrap" id="calibre_link-1581" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String?
// ... stringMaybe might be assigned a real value here ...
let upper = stringMaybe?.uppercased()</pre>

<p class="author1">Thatâ€™s an Optional chain in which you used a question mark to unwrap the Optional. By using that notation, you have unwrapped the Optional optionally &mdash; meaning conditionally. The condition in question is one of safety; a test for <code class="calibre19">nil</code> is performed for us. Our code means: â€œIf <code class="calibre19">stringMaybe</code> contains a String, unwrap it and send that String the <code class="calibre19">uppercased</code> message. If it doesnâ€™t (that is, if it equates to <code class="calibre19">nil</code>), <em class="calibre11">do not</em> unwrap it and <em class="calibre11">do not</em> send it any messages!â€</p>

<p class="author1">Such code is a double-edged sword. On the one hand, if <code class="calibre19">stringMaybe</code> is <code class="calibre19">nil</code>, you wonâ€™t crash at runtime. On the other hand, if <code class="calibre19">stringMaybe</code> is <code class="calibre19">nil</code>, that line of code wonâ€™t do anything useful &mdash; you wonâ€™t get any uppercase string.</p>

<p class="author1">But now thereâ€™s a new question. In that code, we initialized a variable <code class="calibre19">upper</code> to an expression that involves sending the <code class="calibre19">uppercased</code> message. Now it turns out that the <code class="calibre19">uppercased</code> message might not even be sent. So what, exactly, is <code class="calibre19">upper</code> initialized <em class="calibre11">to</em>?</p>

<p class="author1">To handle this situation, Swift has a special rule. If an Optional chain contains an optionally unwrapped Optional, and if this Optional chain produces a value, that value is itself <em class="calibre11">wrapped in an Optional</em>. Thus, <code class="calibre19">upper</code> is typed as an Optional wrapping a String. This works brilliantly, because it covers both possible cases. Letâ€™s say, first, that <code class="calibre19">stringMaybe</code> contains a String:</p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String?
stringMaybe = "howdy"
let upper = stringMaybe?.uppercased()</pre>

<p class="author1">After that code, <code class="calibre19">upper</code> is <em class="calibre11">not</em> a String; it is <em class="calibre11">not</em> <code class="calibre19">"HOWDY"</code>. It is an Optional wrapping <code class="calibre19">"HOWDY"</code>.</p>

<p class="author1">On the other hand, if the attempt to unwrap the Optional fails, the Optional chain can return <code class="calibre19">nil</code> instead:</p>

<pre data-type="programlisting" class="calibre28">var stringMaybe : String?
let upper = stringMaybe?.uppercased()</pre>

<p class="author1">After that code, <code class="calibre19">upper</code> is typed as an Optional wrapping a String, but it wraps no string; its value is <code class="calibre19">nil</code>.</p>

<p class="author1">Unwrapping an Optional optionally in this way is elegant and safe; even if <code class="calibre19">stringMaybe</code> is <code class="calibre19">nil</code>, we wonâ€™t crash at runtime. On the other hand, weâ€™ve ended up with yet another Optional on our hands! <code class="calibre19">upper</code> is typed as an Optional wrapping a String, and in order to use that String, weâ€™re going to have to unwrap <code class="calibre19">upper</code>. And we donâ€™t know whether <code class="calibre19">upper</code> is <code class="calibre19">nil</code>, so we have exactly the same problem we had before &mdash; we need to make sure that we unwrap <code class="calibre19">upper</code> safely, and that we donâ€™t accidentally unwrap an empty Optional.</p>

<p class="author1">Longer Optional chains are legal. No matter how many Optionals are unwrapped in the course of the chain, if any of them is unwrapped optionally, the entire expression produces an Optional wrapping the type it would have produced if the Optionals were unwrapped normally, and is free to fail safely at any point along the way. For example:</p>

<pre data-type="programlisting" class="calibre28">// self is a UIViewController
let f = self.view.window?.rootViewController?.view.frame</pre>

<p class="author1">The <code class="calibre19">frame</code> property of a view is a CGRect. But after that code, <code class="calibre19">f</code> is <em class="calibre11">not</em> a CGRect. Itâ€™s an Optional wrapping a CGRect. If <em class="calibre11">any</em> of the optional unwrapping along the chain fails (because the Optional we propose to unwrap is <code class="calibre19">nil</code>), <code class="calibre19">f</code> will be <code class="calibre19">nil</code> to indicate failure.</p>

<p class="author1">(Observe that the preceding code does <em class="calibre11">not</em> end up nesting Optionals; it doesnâ€™t produce a CGRect wrapped in an Optional wrapped in an Optional, merely because there are two Optionals being optionally unwrapped in the chain! However, it is possible, for other reasons, to end up with an Optional wrapped in an Optional, and Iâ€™ll call out some examples as we proceed.)</p>

<p class="author1">If a function call returns an Optional, you can unwrap the result and use it. You donâ€™t necessarily have to capture the result in order to do that; you can unwrap it in place, by putting an exclamation mark or a question mark after the function call (that is, after the closing parenthesis). Thatâ€™s really no different from what weâ€™ve been doing all along, except that instead of an Optional property or variable, this is a function call that returns an Optional:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var noise : String?
    func speak() -&gt; String? {
        return self.noise
    }
}
let d = Dog()
let bigname = d.speak()?.uppercased()</pre>

<p class="author1">After that, donâ€™t forget, <code class="calibre19">bigname</code> is not a String &mdash; itâ€™s an Optional wrapping a String.</p>

<p class="author1">You can also assign safely into an Optional chain. If any of the optionally unwrapped Optionals in the chain turns out to be <code class="calibre19">nil</code>, nothing happens:</p>

<pre data-type="programlisting" class="calibre28">// self is a UIViewController
self.navigationController?.hidesBarsOnTap = true</pre>

<p class="author1">A view controller might or might not have a navigation controller, so its <code class="calibre19">navigationController</code> property is an Optional. In that code, we are setting our navigation controllerâ€™s <code class="calibre19">hidesBarsOnTap</code> property safely; if we happen to have no navigation controller, no harm is done &mdash; because nothing happens.</p>

<p class="author1">When assigning into an Optional chain, if you also want to know whether the assignment succeeded, you can capture the result of the assignment as an Optional wrapping a Void and test it for <code class="calibre19">nil</code>:</p>

<pre data-type="programlisting" class="calibre28">let ok : Void? = self.navigationController?.hidesBarsOnTap = true</pre>

<p class="author1">Now, if <code class="calibre19">ok</code> is not <code class="calibre19">nil</code>, <code class="calibre19">self.navigationController</code> was safely unwrapped and the assignment succeeded.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The <code class="calibre19">!</code> and <code class="calibre19">?</code> postfix operators, which respectively unconditionally and conditionally unwrap an Optional, have basically <em class="calibre11">nothing</em> to do with the <code class="calibre19">!</code> and <code class="calibre19">?</code> used with type names as syntactic sugar for expressing Optional types (such as <code class="calibre19">String? and `String!</code>). The outward similarity has confused many a beginner.<a data-type="indexterm" data-primary="exclamation mark" id="calibre_link-816" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="question mark" id="calibre_link-1828" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Optional map and flatMap" class="calibre2"><div class="preface" id="calibre_link-2915">
<h3 class="calibre44">Optional map and flatMap</h3>

<p class="author1">Optional chaining helps to solve the problem that you cannot send a message to the value wrapped in an Optional without (safely) unwrapping the Optional. But sometimes you <em class="calibre11">do</em> want to send a message to the value wrapped in an Optional and you <em class="calibre11">donâ€™t</em> want to unwrap it: you want to <em class="calibre11">preserve optionality.</em> You want to start with an Optional and end with an Optional, but in between, you want to send a message to the wrapped value.<a data-type="indexterm" data-primary="Optionals" data-secondary="messages to" data-tertiary="without unwrapping" id="calibre_link-1617" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swift provides two methods that elegantly permit you to do that: <code class="calibre19">map(_:)</code> and <code class="calibre19">flatMap(_:)</code>. These are methods of Optional itself, so itâ€™s fine to send them to an Optional.<a data-type="indexterm" data-primary="map" id="calibre_link-1264" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="flatMap" id="calibre_link-869" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The parameter is a function that you supply (usually as an anonymous function) that takes whatever type is wrapped in the Optional; the unwrapped value is passed to this function, and now you can send a message to it. The result of the function is then wrapped as an Optional, so that optionality is preserved:<a data-type="indexterm" data-primary="Optionals" data-secondary="map" id="calibre_link-1615" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="flatMap" id="calibre_link-1611" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s : String? = "howdy"
let s2 = s.map{$0.uppercased()}</pre>

<p class="author1">After that, <code class="calibre19">s2</code> is an Optional wrapping a String, which is the uppercased version of the String wrapped in <code class="calibre19">s1</code>. Thus Optionality is preserved. Not only is Optionality preserved; it is preserved <em class="calibre11">safely</em>. If <code class="calibre19">s</code> in that example had turned out to be <code class="calibre19">nil</code>, there would be no crash, and <code class="calibre19">s2</code> would be set to <code class="calibre19">nil</code> as well.</p>

<p class="author1">The output Optional type doesnâ€™t have to be the same as the input Optional type. Indeed, it commonly is not; <code class="calibre19">map(_:)</code> and <code class="calibre19">flatMap(_:)</code> are often used when the goal is to coerce (or cast, as discussed in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>):</p>

<pre data-type="programlisting" class="calibre28">let s : String? = // whatever
let i = s.flatMap{Int($0)}</pre>

<p class="author1">In that code, we attempt to unwrap an Optional String and coerce it to an Int. The result is an Optional Int, which will be <code class="calibre19">nil</code> if <code class="calibre19">s</code> is <code class="calibre19">nil</code>, or if <code class="calibre19">s</code> isnâ€™t <code class="calibre19">nil</code> but the coercion fails because the string wrapped by <code class="calibre19">s</code> doesnâ€™t represent an integer.</p>

<p class="author1">That example also illustrates the difference between <code class="calibre19">map</code> and <code class="calibre19">flatMap</code>. If the map function itself produces an Optional &mdash; as coercing a String to an Int does &mdash; <code class="calibre19">flatMap</code> unwraps it before wrapping the result in an Optional. <code class="calibre19">map</code> doesnâ€™t do that, so if we had used <code class="calibre19">map</code> here, we would have ended up with a double-wrapped Optional (an <code class="calibre19">Int??</code>).</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Comparison with Optional" class="calibre2"><div class="preface" id="calibre_link-2916">
<h3 class="calibre44">Comparison with Optional</h3>

<p class="author1">In an equality comparison with something other than <code class="calibre19">nil</code>, an Optional gets special treatment: the wrapped value, not the Optional itself, is compared. So, for example, this works:<a data-type="indexterm" data-primary="Optionals" data-secondary="comparison" id="calibre_link-1600" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="equality" id="calibre_link-1610" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s : String? = "Howdy"
if s == "Howdy" { // ... they _are_ equal!</pre>

<p class="author1">That shouldnâ€™t work &mdash; how can an Optional be the same as a String? &mdash; but it does. Instead of comparing the Optional itself with <code class="calibre19">"Howdy"</code>, Swift automagically (and safely) compares its wrapped value (if there is one) with <code class="calibre19">"Howdy"</code>. If the wrapped value is <code class="calibre19">"Howdy"</code>, the comparison succeeds. If the wrapped value is not <code class="calibre19">"Howdy"</code>, the comparison fails. If there is <em class="calibre11">no</em> wrapped value (<code class="calibre19">s</code> is <code class="calibre19">nil</code>), the comparison fails too &mdash; safely! Thus, you can compare <code class="calibre19">s</code> to <code class="calibre19">nil</code> or to a String, and the comparison works correctly in all cases.</p>

<p class="author1">(This feature depends upon the wrapped type itself being usable with <code class="calibre19">==</code>. This means that the wrapped type must adopt the Equatable protocol; otherwise, the compiler will stop you from using <code class="calibre19">==</code> with an Optional wrapping it. Iâ€™ll talk about protocols and Equatable in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> and <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>.)</p>

<p class="author1">Direct comparison of Optionals does <em class="calibre11">not</em> work for an inequality comparison, using the greater-than and less-than operators:</p>

<pre data-type="programlisting" class="calibre28">let i : Int? = 2
if i &lt; 3 { // compile error</pre>

<p class="author1">To perform that sort of comparison, you can unwrap safely and perform the comparison directly on the unwrapped value:</p>

<pre data-type="programlisting" class="calibre28">if i != nil &amp;&amp; i! &lt; 3 { // ... it _is_ less</pre>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Do not compare an implicitly unwrapped Optional with anything; you can crash at runtime.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Why Optionals?" class="calibre2"><div class="preface" id="calibre_link-2827">
<h3 class="calibre44">Why Optionals?</h3>

<p class="author1">Now that you know <em class="calibre11">how</em> to use an Optional, you are probably wondering <em class="calibre11">why</em> to use an Optional. Why does Swift have Optionals at all? What are they good for?<a data-type="indexterm" data-primary="Optionals" data-secondary="Objective-C and" id="calibre_link-1619" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="Optionals and" id="calibre_link-1538" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">One important use of Optionals is to permit a value to be <em class="calibre11">marked as empty or erroneous</em>.
Many built-in Swift functions use an Optional this way:<a data-type="indexterm" data-primary="nil" data-secondary="signaling failure" id="calibre_link-1407" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let ix = arr.firstIndex(of:4)
if ix == nil { // ...</pre>

<p class="author1">Swiftâ€™s <code class="calibre19">firstIndex(of:)</code> method returns an Optional because the object sought might not be present, in which case it has <em class="calibre11">no</em> index. The type returned cannot be an Int, because there is no Int value that can be taken to mean, â€œI didnâ€™t find this object at all.â€ Returning an Optional solves the problem neatly: <code class="calibre19">nil</code> means â€œI didnâ€™t find the object,â€ and otherwise the actual Int result is sitting there wrapped up in the Optional.</p>

<p class="author1">Another purpose of Optionals is to provide <em class="calibre11">interchange of object values with Objective-C</em>. In Objective-C, <em class="calibre11">any</em> object reference can be <code class="calibre19">nil</code>. You thus need a way to send <code class="calibre19">nil</code> to Objective-C and to receive <code class="calibre19">nil</code> from Objective-C. Swift Optionals provide your only way to do that.</p>

<p class="author1">Swift will typically assist you by a judicious use of appropriate types in the Cocoa APIs. For example, consider a UIViewâ€™s <code class="calibre19">backgroundColor</code> property. Itâ€™s a UIColor, but it can be <code class="calibre19">nil</code>, and you are allowed to set it to <code class="calibre19">nil</code>. Thus, it is typed as <code class="calibre19">UIColor?</code>. You donâ€™t need to work directly with Optionals in order to <em class="calibre11">set</em> such a value! Remember, assigning the wrapped type to an Optional is legal, as the assigned value will be wrapped for you. Thus, you can set <code class="calibre19">myView.backgroundColor</code> to a UIColor &mdash; or to <code class="calibre19">nil</code>. But if you <em class="calibre11">get</em> a UIViewâ€™s <code class="calibre19">backgroundColor</code>, you now have an Optional wrapping a UIColor, <em class="calibre11">and you must be conscious of that fact</em>, for all the reasons Iâ€™ve already discussed: if youâ€™re not, surprising things can happen:</p>

<pre data-type="programlisting" class="calibre28">let v = UIView()
let c = v.backgroundColor
let c2 = c.withAlphaComponent(0.5) // compile error</pre>

<p class="author1">Youâ€™re trying to send the <code class="calibre19">withAlphaComponent</code> message to <code class="calibre19">c</code>, as if it were a UIColor. It <em class="calibre11">isnâ€™t</em> a UIColor. Itâ€™s an Optional wrapping a UIColor. Xcode will try to help you in this situation; if you use code completion (<a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>) to enter the name of the <code class="calibre19">withAlphaComponent</code> method, Xcode will insert a question mark after <code class="calibre19">c</code>, thus (optionally) unwrapping the Optional and giving you legal code:</p>

<pre data-type="programlisting" class="calibre28">let v = UIView()
let c = v.backgroundColor
let c2 = c?.withAlphaComponent(0.5)</pre>

<p class="author1">In the vast majority of situations, however, a Cocoa object type will <em class="calibre11">not</em> be marked as an Optional. Thatâ€™s because, although in theory it <em class="calibre11">could</em> be <code class="calibre19">nil</code> (because any Objective-C object reference can be <code class="calibre19">nil</code>), in practice it wonâ€™t be. Swift thus saves you a step by treating the value as the object type itself. This magic is performed by hand-tweaking the Cocoa APIs (also called <em class="calibre11">auditing</em>). In the very first public version of Swift (in June of 2014), <em class="calibre11">all</em> object values received from Cocoa were typed as Optionals (usually implicitly unwrapped Optionals); but then Apple embarked on the massive project of hand-tweaking the APIs to eliminate Optionals that didnâ€™t need to be Optionals, and that project is now essentially complete.<a data-type="indexterm" data-primary="tweaking the APIs" id="calibre_link-2227" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="API" data-secondary="tweaking" id="calibre_link-148" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hand-tweaking the APIs" id="calibre_link-993" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Finally, an important use of Optionals is to <em class="calibre11">defer initialization</em> of an instance property. If a variable (declared with <code class="calibre19">var</code>) is typed as an Optional, it has a value even if you donâ€™t initialize it &mdash; namely <code class="calibre19">nil</code>. That comes in very handy in situations where you know something <em class="calibre11">will</em> have a value, but not right away.<a data-type="indexterm" data-primary="deferred initialization" id="calibre_link-635" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="deferred initialization" id="calibre_link-1603" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initialization" data-secondary="deferred" id="calibre_link-1074" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="initialization" data-tertiary="deferred" id="calibre_link-1757" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nil" data-secondary="signaling no data" id="calibre_link-1408" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">One way this can happen is that a property represents data that will take time to acquire. For example, in my Albumen app, as we launch, I create an instance of my root view controller. I also want to gather a bunch of data about the userâ€™s music library and store that data in instance properties of the root view controller instance. But gathering that data will take time. Therefore I must instantiate the root view controller <em class="calibre11">first</em> and gather the data <em class="calibre11">later</em>, because if we pause to gather the data <em class="calibre11">before</em> instantiating the root view controller, the app will take too long to launch &mdash; the delay will be perceptible, and we might even crash (because iOS forbids long launch times). Therefore the data properties are all typed as Optionals; they are <code class="calibre19">nil</code> until the data are gathered, at which time they are assigned their â€œrealâ€ values:</p>

<pre data-type="programlisting" class="calibre28">class RootViewController : UITableViewController {
    var albums : [MPMediaItemCollection]? // initialized to nil
    // ...
}</pre>

<p class="author1">This approach has a second advantage: as with <code class="calibre19">firstIndex</code>, the initial <code class="calibre19">nil</code> value of <code class="calibre19">albums</code> is a signal to the rest my code that we donâ€™t yet have a real value. When my Albumen app launches, it displays a table listing all the userâ€™s music albums. At launch time, however, that data has not yet been gathered. My table-display code tests <code class="calibre19">albums</code> to see whether itâ€™s <code class="calibre19">nil</code> and, if it is, displays an empty table. After gathering the data, I tell my table to display its data <em class="calibre11">again</em>. This time, the table-display code finds that <code class="calibre19">albums</code> is <em class="calibre11">not</em> <code class="calibre19">nil</code>, but rather consists of actual data &mdash; and it now displays that data. The use of an Optional allows one and the same value, <code class="calibre19">albums</code>, to store the data or to state that there is no data.</p>

<p class="author1">Sometimes, a propertyâ€™s value isnâ€™t time-consuming to acquire, but it <em class="calibre11">still</em> wonâ€™t be ready at initialization time. A common case in real life is an outlet, which is a reference to something in your interface such as a button:</p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
    @IBOutlet var myButton: UIButton! // initialized to nil
    // ...
}</pre>

<p class="author1">Ignore, for now, the <code class="calibre19">@IBOutlet</code> designation, which is an internal hint to Xcode (as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>). The important thing is that this property, <code class="calibre19">myButton</code>, wonâ€™t have a value when our ViewController instance first comes into existence, but shortly thereafter the view controllerâ€™s view will be loaded and <code class="calibre19">myButton</code> will be set so that it points to an actual UIButton object in the interface. Therefore, the variable is typed as an implicitly unwrapped Optional:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Itâ€™s an Optional because we need a placeholder value (namely <code class="calibre19">nil</code>) for <code class="calibre19">myButton</code> when the ViewController instance first comes into existence.</p>
</li>
<li class="calibre12">
<p class="calibre17">Itâ€™s implicitly unwrapped so that in our code, once <code class="calibre19">self.myButton</code> has been assigned a UIButton value, we can treat it as a reference to an actual UIButton, passing through the Optional without noticing that it <em class="calibre11">is</em> an Optional. Moreover, most of this view controllerâ€™s code will run after the view is loaded and the actual button is assigned to <code class="calibre19">myButton</code>, so the implicitly unwrapped Optional is generally safe: code can confidently refer to <code class="calibre19">myButton</code> as if it were a UIButton, without fear that it might be <code class="calibre19">nil</code>.</p>
</li>
</ul>

<p class="author1">A shortcoming of this architecture is that our outlet property must be declared with <code class="calibre19">var</code>, meaning that, in theory, other code can come along later and replace this button reference with another. That is usually undesirable. This is similar to the lack of <code class="calibre19">lazy let</code> discussed earlier in this chapter &mdash; and you can work around the problem in a similar way, namely with a property wrapper that allows the outlet propertyâ€™s value, initialized to <code class="calibre19">nil</code>, to be set only once thereafter.</p>

<p class="author1"><a data-type="indexterm" data-startref="idxoptionals" id="calibre_link-1595" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>





</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2826">
<div id="calibre_link-2917" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 4. Object Types" class="calibre2"><div class="preface" id="calibre_link-19">
<h1 class="calibre13"><span class="label">Chapter 4. </span>Object Types</h1>


<p class="author1">In the preceding chapter, I discussed some built-in object types. But I have not yet explained object types themselves. As I mentioned in <a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>, Swift object types come in three flavors: enum, struct, and class. What are the differences between them? And how would you create your own object type?</p>

<p class="author1">In this chapter, Iâ€™ll describe first object types generally and then each of the three flavors. Then Iâ€™ll explain three Swift ways of giving an object type greater flexibility: protocols, generics, and extensions. Finally, Iâ€™ll complete the survey of Swiftâ€™s main built-in types with three umbrella types and three collection types. <a data-type="indexterm" data-primary="object types" id="calibre_link-1487" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Object Type Declarations and Features" class="calibre2"><div class="preface" id="calibre_link-2456">
<h1 class="calibre18">Object Type Declarations and Features</h1>

<p class="author1">Object types are declared with the flavor of the object type (<code class="calibre19">enum</code>, <code class="calibre19">struct</code>, or <code class="calibre19">class</code>), the name of the object type (which should start with a capital letter), and curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-585" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>:<a data-type="indexterm" data-primary="declaration" data-secondary="of object types" id="calibre_link-628" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="declaration" id="calibre_link-1490" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="types" data-seealso="object types" id="calibre_link-2248" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Manny {
}
struct Moe {
}
enum Jack {
}</pre>

<p class="author1">The visibility of an object type by other code &mdash; its scope &mdash; depends upon where its declaration appears (compare <a data-type="xref" href="#calibre_link-2438" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œVariable Scope and Lifetimeâ€</a>):<a data-type="indexterm" data-primary="scope" data-secondary="object types" id="calibre_link-1957" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="scope" id="calibre_link-1507" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Top level</dt>
<dd class="calibre16">
<p class="calibre17">Object types declared at the top level of a file will, by default, be visible to all files in the same module. This is the usual place for object type declarations.</p>
</dd>
<dt class="calibre15">Inside another type declaration</dt>
<dd class="calibre16">
<p class="calibre17">Sometimes itâ€™s useful to declare a type inside the declaration of another type, thus giving it a namespace. This is called a <em class="calibre11">nested type</em>.<a data-type="indexterm" data-primary="nested types" id="calibre_link-1387" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Function body</dt>
<dd class="calibre16">
<p class="calibre17">An object type declared within the body of a function will exist only inside the scope of the curly braces that surround it; such declarations are legal but rare.</p>
</dd>
</dl>

<p class="author1">Declarations for any object type may contain within their curly braces the following things:</p>
<dl class="calibre14">
<dt class="calibre15">Initializers</dt>
<dd class="calibre16">
<p class="calibre17">An object type is merely the <em class="calibre11">type</em> of an object. The purpose of declaring an object type will usually (though not always) be so that you can make an actual object &mdash; an <em class="calibre11">instance</em> &mdash; that <em class="calibre11">has</em> this type. An <em class="calibre11">initializer</em> is a function, declared and called in a special way, allowing you to do that.</p>
</dd>
<dt class="calibre15">Properties</dt>
<dd class="calibre16">
<p class="calibre17">A variable declared at the top level of an object type declaration is a <em class="calibre11">property</em>.</p>

<p class="calibre17">By default, a property is an <em class="calibre11">instance property</em>. An instance property is scoped to an instance: it is accessed through a particular instance of this type, and its value can be different for every instance of this type.</p>

<p class="calibre17">Alternatively, a property can be a <em class="calibre11">static/class property</em>. For an enum or struct, it is declared with the keyword <code class="calibre19">static</code>; for a class, it may instead be declared with the keyword <code class="calibre19">class</code>. It belongs to the object type itself: it is accessed through the type, and it has just one value, associated with the type.</p>
</dd>
<dt class="calibre15">Methods</dt>
<dd class="calibre16">
<p class="calibre17">A function declared at the top level of an object type declaration is a <em class="calibre11">method</em>.</p>

<p class="calibre17">By default, a method is an <em class="calibre11">instance method</em>: it is called by sending a message to a particular instance of this type. Inside an instance method, <code class="calibre19">self</code> is the instance.<a data-type="indexterm" data-primary="self" data-secondary="in instance methods" id="calibre_link-1980" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">Alternatively, a method can be a <em class="calibre11">static/class method</em>. For an enum or struct, it is declared with the keyword <code class="calibre19">static</code>; for a class, it may be declared instead with the keyword <code class="calibre19">class</code>. It is called by sending a message to the type. Inside a static/class method, <code class="calibre19">self</code> is the type.<a data-type="indexterm" data-primary="self" data-secondary="in static/class methods" id="calibre_link-1982" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Subscripts</dt>
<dd class="calibre16">
<p class="calibre17">A subscript is a special kind of method, called by appending square brackets to an instance reference or type name.</p>
</dd>
<dt class="calibre15">Object type declarations</dt>
<dd class="calibre16">
<p class="calibre17">An object type declaration can contain an object type declaration &mdash; a nested type. From inside the containing object type, the nested type is in scope; from outside the containing object type, the nested type must be referred to through the containing object type. Thus, the containing object type is a namespace for the nested type.</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Initializers" class="calibre2"><div class="preface" id="calibre_link-2457">
<h2 class="calibre42">Initializers</h2>

<p class="author1">An <em class="calibre11">initializer</em> is a function for producing an instance of an object type. Strictly speaking, it is a static/class method, because it is called by talking to the object type. It is usually called by means of special syntax: the name of the type is followed directly by parentheses, as if the type itself were a function. When an initializer is called, a new instance is created and returned as a result. You will usually do something with the returned instance, such as assigning it to a variable, in order to preserve it and work with it in subsequent code.<a data-type="indexterm" data-primary="initializers" id="calibre_link-1083" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="initializers" id="calibre_link-1496" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="creating an instance" id="calibre_link-577" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="creation" id="calibre_link-1120" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instantiation" id="calibre_link-1141" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parentheses" data-secondary="instantiating an object type" id="calibre_link-1680" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, suppose we have a Dog class:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
}</pre>

<p class="author1">Then we can make a Dog instance like this:</p>

<pre data-type="programlisting" class="calibre28">Dog()</pre>

<p class="author1">That code, however, though legal, is silly &mdash; so silly that it warrants a warning from the compiler. We have created a Dog instance, but there is no reference to that instance. Without such a reference, the Dog instance comes into existence and then immediately vanishes in a puff of smoke. The usual sort of thing is more like this:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()</pre>

<p class="author1">Now our Dog instance will persist as long as the variable <code class="calibre19">fido</code> persists (see <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>) &mdash; and the variable <code class="calibre19">fido</code> gives us a reference to our Dog instance, so that we can use it.</p>

<p class="author1">Observe that <code class="calibre19">Dog()</code> calls an initializer even though our Dog class doesnâ€™t declare any initializers! The reason is that object types may have <em class="calibre11">implicit initializers</em>. These are a convenience that save you the trouble of writing your own initializers. But you <em class="calibre11">can</em> write your own initializers, and you will often do so.<a data-type="indexterm" data-primary="initializers" data-secondary="implicit" id="calibre_link-1091" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="implicit initializer" id="calibre_link-1042" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="How to write an initializer" class="calibre2"><div class="preface" id="calibre_link-2918">
<h3 class="calibre44">How to write an initializer</h3>

<p class="author1">An initializer is a kind of function, but its declaration syntax doesnâ€™t involve the keyword <code class="calibre19">func</code> or a return type. Instead, you use the keyword <code class="calibre19">init</code> with a parameter list, followed by curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-586" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> containing the code. An object type can have multiple initializers, distinguished by their parameters. A frequent use of the parameters is to set the values of instance properties.<a data-type="indexterm" data-primary="external parameter names" data-secondary="initializers" id="calibre_link-838" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" data-secondary="external names" data-tertiary="initializers" id="calibre_link-1667" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="init" id="calibre_link-1066" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s a Dog class with two instance properties, <code class="calibre19">name</code> (a String) and <code class="calibre19">license</code> (an Int). We give these instance properties default values that are effectively placeholders &mdash; an empty string and the number zero. Then we declare three initializers, so that the caller can create a Dog instance in three different ways: by supplying a name, by supplying a license number, or by supplying both. In each initializer, the parameters supplied are used to set the values of the corresponding properties:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var license = 0
    init(name:String) {
        self.name = name
    }
    init(license:Int) {
        self.license = license
    }
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">In that code, in each initializer, Iâ€™ve given each parameter the same name as the property to which it corresponds. Thereâ€™s no reason to do that apart from stylistic clarity. In the initializer function body, I can distinguish the parameter from the property by using <code class="calibre19">self</code> explicitly to access the property.</p>

<p class="author1">The result of that declaration is that I can create a Dog in three different ways:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog(name:"Fido")
let rover = Dog(license:1234)
let spot = Dog(name:"Spot", license:1357)</pre>

<p class="author1">But now I <em class="calibre11">canâ€™t</em> create a Dog with <em class="calibre11">no</em> initializer parameters. I wrote initializers, so my implicit initializer went away. This code is no longer legal:</p>

<pre data-type="programlisting" class="calibre28">let puff = Dog() // compile error</pre>

<p class="author1">Of course, I could <em class="calibre11">make</em> that code legal by explicitly declaring an initializer with no parameters:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var license = 0
    init() {
    }
    init(name:String) {
        self.name = name
    }
    init(license:Int) {
        self.license = license
    }
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">Now, the truth is that we donâ€™t need those four initializers, because an initializer is a function, and a functionâ€™s parameters can have default values. Thus, I can condense all that code into a single initializer, like this:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    var license = 0
    init(name:String = "", license:Int = 0) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">I can still make an actual Dog instance in four different ways:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog(name:"Fido")
let rover = Dog(license:1234)
let spot = Dog(name:"Spot", license:1357)
let puff = Dog()</pre>

<p class="author1">Now comes the really interesting part. In my property declarations, I can <em class="calibre11">eliminate</em> the assignment of default initial values (as long as I declare explicitly the <em class="calibre11">type</em> of each property):</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String // no default value!
    var license : Int // no default value!
    init(name:String = "", license:Int = 0) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">That code is legal (and common) &mdash; because an initializer initializes! In other words, I donâ€™t have to give my properties initial values in their declarations, <em class="calibre11">provided I give them initial values in all initializers</em>. That way, I am guaranteed that all my instance properties have values when the instance comes into existence, which is what matters. Conversely, an instance property without an initial value when the instance comes into existence <em class="calibre11">is illegal</em>. A property <em class="calibre11">must</em> be initialized either as part of its declaration or by every initializer, and the compiler will stop you otherwise.<a data-type="indexterm" data-primary="initialization" data-secondary="of properties" id="calibre_link-1080" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="initialization" id="calibre_link-1754" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The Swift compilerâ€™s insistence that all instance properties be properly initialized is a valuable feature of Swift. (Contrast Objective-C, where instance properties can go uninitialized &mdash; and often do, leading to mysterious errors later.) Donâ€™t fight the compiler; work with it. The compiler will help you by giving you an error message (â€œReturn from initializer without initializing all stored propertiesâ€) until <em class="calibre11">all</em> your initializers initialize <em class="calibre11">all</em> your instance properties:<a data-type="indexterm" data-primary="errors, compiler" data-secondary="return from initializer" id="calibre_link-801" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String = "") {
        self.name = name // compile error (do you see why?)
    }
}</pre>

<p class="author1">Because setting an instance property in an initializer counts as initialization, it is legal even if the instance property is a constant declared with <code class="calibre19">let</code>:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    let name : String
    let license : Int
    init(name:String = "", license:Int = 0) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">In our artificial examples, we have been very generous with our initializers: we are letting the caller instantiate a Dog without supplying a <code class="calibre19">name:</code> argument or a <code class="calibre19">license:</code> argument. Usually, however, the purpose of an initializer is just the opposite: we want to <em class="calibre11">force</em> the caller to supply <em class="calibre11">all</em> needed information at instantiation time. Thus, in real life, it is much more likely that our Dog class would look like this:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    let name : String
    let license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">In that code, our Dog has a <code class="calibre19">name</code> property and a <code class="calibre19">license</code> property, and values for these <em class="calibre11">must</em> be supplied at instantiation time (there are no default values), and those values can never be changed thereafter (the properties are constants). In this way, we enforce a rule that every Dog must have a meaningful name and license. There is now only <em class="calibre11">one</em> way to make a Dog:</p>

<pre data-type="programlisting" class="calibre28">let spot = Dog(name:"Spot", license:1357)</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Deferred initialization of properties" class="calibre2"><div class="preface" id="calibre_link-71">
<h3 class="calibre44">Deferred initialization of properties</h3>

<p class="author1">Sometimes there is no meaningful value that can be assigned to an instance property during initialization. Perhaps the initial value of this property will not be obtained until some time has elapsed <em class="calibre11">after</em> this instance has come into existence. This situation conflicts with the requirement that all instance properties be initialized either in their declaration or through an initializer. You could circumvent the problem by assigning a default initial value anyway; but this fails to communicate to your own code the fact that this isnâ€™t a â€œrealâ€ value.<a data-type="indexterm" data-primary="deferred initialization" id="calibre_link-636" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="deferred initialization" id="calibre_link-1604" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initialization" data-secondary="deferred" id="calibre_link-1075" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nil" data-secondary="signaling no data" id="calibre_link-1409" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="initialization" data-tertiary="deferred" id="calibre_link-1758" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A common solution, as I explained in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>, is to declare your instance property as a <code class="calibre19">var</code> having an Optional type. An Optional has a value, namely <code class="calibre19">nil</code>, signifying that no â€œrealâ€ value has been supplied; and an Optional <code class="calibre19">var</code> is initialized to <code class="calibre19">nil</code> automatically. Thus, your code can test this instance property against <code class="calibre19">nil</code> and, if it is <code class="calibre19">nil</code>, it wonâ€™t use the property. Later, the property will be given its â€œrealâ€ value. Of course, that value is now wrapped in an Optional; but if you declare this property as an implicitly unwrapped Optional, you can use the wrapped value directly, without explicitly unwrapping it &mdash; as if this werenâ€™t an Optional at all &mdash; once youâ€™re sure it is safe to do so:<a data-type="indexterm" data-primary="Optionals" data-secondary="properties" id="calibre_link-1620" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="Optional" id="calibre_link-1768" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// this property will be set automatically when the nib loads
@IBOutlet var myButton: UIButton!
// this property will be set after time-consuming gathering of data
var albums : [MPMediaItemCollection]?</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Referring to self" class="calibre2"><div class="preface" id="calibre_link-2919">
<h3 class="calibre44">Referring to self</h3>

<p class="author1">An initializer may refer to an already initialized instance property, and may refer to an uninitialized instance property in order to initialize it. Otherwise, an initializer <em class="calibre11">may not refer to <code class="calibre22">self</code></em>, explicitly or implicitly, until <em class="calibre11">all</em> instance properties have been initialized. This rule guarantees that the instance is fully formed before it is used. This code, for example, is illegal:<a data-type="indexterm" data-primary="self" data-secondary="in initializers" id="calibre_link-1977" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="self used" id="calibre_link-802" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Cat {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        meow() // too soon - compile error
        self.license = license
    }
    func meow() {
        print("meow")
    }
}</pre>

<p class="author1">The call to the instance method <code class="calibre19">meow</code> is implicitly a reference to <code class="calibre19">self</code> &mdash; it means <code class="calibre19">self.meow()</code>. The initializer can say that, but not until it has fulfilled its primary contract of initializing all uninitialized properties. The call to the instance method <code class="calibre19">meow</code> simply needs to be moved down one line, so that it comes <em class="calibre11">after</em> both <code class="calibre19">name</code> and <code class="calibre19">license</code> have been initialized.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Delegating initializers" class="calibre2"><div class="preface" id="calibre_link-2920">
<h3 class="calibre44">Delegating initializers</h3>

<p class="author1">Initializers within an object type can call one another by using the syntax <code class="calibre19">self.init(...)</code>. An initializer that calls another initializer is called a <em class="calibre11">delegating initializer</em>. When an initializer delegates, the other initializer &mdash; the one that it delegates to &mdash; must completely initialize the instance first, and then the delegating initializer can work with the fully initialized instance, possibly setting again a <code class="calibre19">var</code> property that was already set by the initializer that it delegated to.<a data-type="indexterm" data-primary="init" data-secondary="with self" id="calibre_link-1067" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A delegating initializer appears to be an exception to the rule against saying <code class="calibre19">self</code> too early. But it isnâ€™t, because it is saying <code class="calibre19">self</code> in order to delegate &mdash; and delegating will cause all instance properties to be initialized. In fact, the rules about a delegating initializer saying <code class="calibre19">self</code> are even more stringent: a delegating initializer <em class="calibre11">cannot refer to <code class="calibre22">self</code> at all</em>, not even to set a property, until <em class="calibre11">after</em> the call to the other initializer. For <span class="publishername">example:</span><a data-type="indexterm" data-primary="initializers" data-secondary="delegating" id="calibre_link-1086" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="delegating initializers" id="calibre_link-644" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number : Int
    var meaningOfLife : Bool
    init(number:Int) {
        self.number = number
        self.meaningOfLife = false
    }
    init() { // this is a delegating initializer
        self.init(number:42)
        self.meaningOfLife = true
    }
}</pre>

<p class="author1">A delegating initializer <em class="calibre11">cannot set a constant property</em> (a <code class="calibre19">let</code> variable). That is because it cannot refer to the property until after it has called the other initializer, and at that point the instance is fully formed &mdash; initialization proper is over, and the door for initialization of properties has closed. This property is a constant, it has been initialized, and thatâ€™s that. Thus, the preceding code would be illegal if <code class="calibre19">meaningOfLife</code> were declared with <code class="calibre19">let</code>, because the second initializer is a delegating initializer and cannot set a constant property.</p>

<p class="author1">Be careful not to delegate recursively! If you tell an initializer to delegate to itself, or if you create a vicious circle of delegating initializers, the compiler wonâ€™t stop you, but your running app will hang. For example, donâ€™t say this:<a data-type="indexterm" data-primary="recursive initializers" id="calibre_link-1857" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="recursive" id="calibre_link-1098" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Digit { // do not do this!
    var number : Int = 100
    init(value:Int) {
        self.init(number:value)
    }
    init(number:Int) {
        self.init(value:number)
    }
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Failable initializers" class="calibre2"><div class="preface" id="calibre_link-2921">
<h3 class="calibre44">Failable initializers</h3>

<p class="author1">An initializer can return an Optional wrapping the new instance. In this way, <code class="calibre19">nil</code> can be returned to signal failure. An initializer that behaves this way is a <em class="calibre11">failable initializer</em>. To mark an initializer as failable when declaring it, put a question mark after the keyword <code class="calibre19">init</code>. If your failable initializer needs to return <code class="calibre19">nil</code>, explicitly write <code class="calibre19">return nil</code>. It is up to the caller to test the resulting Optional for equivalence with <code class="calibre19">nil</code>, unwrap it, and so forth, as with any Optional.<a data-type="indexterm" data-primary="initializers" data-secondary="failable" id="calibre_link-1089" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="failable initializers" id="calibre_link-844" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s a version of Dog with an initializer that returns an Optional, returning <code class="calibre19">nil</code> if the <code class="calibre19">name:</code> or <code class="calibre19">license:</code> arguments are invalid:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    let name : String
    let license : Int
    init?(name:String, license:Int) {
        if name.isEmpty {
            return nil
        }
        if license &lt;= 0 {
            return nil
        }
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">The resulting value is typed as an Optional wrapping a Dog, and the caller will need to unwrap that Optional (if isnâ€™t <code class="calibre19">nil</code>) before sending any messages to it.</p>

<p class="author1">Cocoa and Objective-C conventionally return <code class="calibre19">nil</code> from initializers to signal failure; the API for such initializers has been hand-tweaked as a Swift failable initializer if initialization really might fail. For example, the UIImage initializer <code class="calibre19">init?(named:)</code> is a failable initializer, because there might be no image with the given name. The resulting value is a <code class="calibre19">UIImage?</code>, and will typically have to be unwrapped before using it.</p>

<p class="author1">(Most Objective-C initializers, however, are <em class="calibre11">not</em> bridged as failable initializers, even though in theory <em class="calibre11">any</em> Objective-C initializer might return <code class="calibre19">nil</code>. This is essentially the same hand-tweaking policy I described in <a data-type="xref" href="#calibre_link-2827" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œWhy Optionals?â€</a>.)<a data-type="indexterm" data-primary="tweaking the APIs" id="calibre_link-2228" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="API" data-secondary="tweaking" id="calibre_link-149" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hand-tweaking the APIs" id="calibre_link-994" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Properties" class="calibre2"><div class="preface" id="calibre_link-2458">
<h2 class="calibre42">Properties</h2>

<p class="author1">A <em class="calibre11">property</em> is a variable &mdash; one that happens to be declared at the top level of an object type declaration. This means that everything said about variables in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a> applies. A property has a fixed type; it can be declared with <code class="calibre19">var</code> or <code class="calibre19">let</code>; it can be stored or computed; it can have setter observers. An instance property can also be declared <code class="calibre19">lazy</code>.<a data-type="indexterm" data-primary="properties" id="calibre_link-1742" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="properties" id="calibre_link-1503" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="How properties are accessed" class="calibre2"><div class="preface" id="calibre_link-2922">
<h3 class="calibre44">How properties are accessed</h3>

<p class="author1">If a property is an instance property (the default), it can be accessed only through an instance, and its value is separate for each instance. For example, letâ€™s start once again with a Dog class:<a data-type="indexterm" data-primary="properties" data-secondary="instance" id="calibre_link-1763" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instance" data-secondary="properties" id="calibre_link-1111" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    let name : String
    let license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
}</pre>

<p class="author1">Our Dog class has a <code class="calibre19">name</code> instance property. Then we can make two different Dog instances with two different <code class="calibre19">name</code> values, and we can access each Dog instanceâ€™s <code class="calibre19">name</code> through the instance:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog(name:"Fido", license:1234)
let spot = Dog(name:"Spot", license:1357)
let aName = fido.name // "Fido"
let anotherName = spot.name // "Spot"</pre>

<p class="author1">A static/class property, on the other hand, is accessed through the type, and is scoped to the type, which usually means that it is global and unique. Iâ€™ll use a struct as an example:<a data-type="indexterm" data-primary="properties" data-secondary="static" id="calibre_link-1774" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="class" id="calibre_link-1745" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="class" data-secondary="properties" id="calibre_link-368" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static properties" id="calibre_link-2072" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
}</pre>

<p class="author1">Now code elsewhere can fetch the values of <code class="calibre19">Greeting.friendly</code> and <code class="calibre19">Greeting.hostile</code>. That example is neither artificial nor trivial; immutable static properties are a convenient and effective way to supply your code with nicely namespaced constants.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Property initialization" class="calibre2"><div class="preface" id="calibre_link-2923">
<h3 class="calibre44">Property initialization</h3>

<p class="author1">A stored instance property must be given an initial value. But, as I explained a moment ago, this doesnâ€™t have to happen through assignment in the declaration; it can happen through initializer functions instead. Setter observers are not called during initialization of properties.</p>

<p class="author1">A property declaration that assigns an initial value to the property <em class="calibre11">cannot fetch an instance property or call an instance method</em>. Such behavior would require a reference, explicit or implicit, to <code class="calibre19">self</code>; and during initialization, there is no <code class="calibre19">self</code> yet &mdash; <code class="calibre19">self</code> is exactly what we are in the process of initializing. Making this mistake can result in some of Swiftâ€™s most perplexing compile error messages. For example, this is illegal (and removing the explicit references to <code class="calibre19">self</code> doesnâ€™t make it legal):<a data-type="indexterm" data-primary="initialization" data-secondary="of properties" id="calibre_link-1081" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="initialization" id="calibre_link-1755" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="self" data-secondary="in property initialization" id="calibre_link-1981" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="use of unresolved identifier self" id="calibre_link-804" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="cannot use instance member" id="calibre_link-791" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Moi {
    let first = "Matt"
    let last = "Neuburg"
    let whole = self.first + " " + self.last // compile error
}</pre>

<p class="author1">There are two common solutions in that situation:</p>
<dl class="calibre14">
<dt class="calibre15">Make this a computed property</dt>
<dd class="calibre16">
<p class="calibre17">A computed property can refer to <code class="calibre19">self</code> because the computation wonâ€™t actually be performed until after <code class="calibre19">self</code> exists:</p>

<pre data-type="programlisting" class="calibre28">class Moi {
    let first = "Matt"
    let last = "Neuburg"
    var whole : String {
        self.first + " " + self.last
    }
}</pre>
</dd>
<dt class="calibre15">Declare this property <code class="calibre19">lazy</code></dt>
<dd class="calibre16">
<p class="calibre17">Like a computed property, a <code class="calibre19">lazy</code> property can refer to <code class="calibre19">self</code> legally because that reference wonâ€™t be accessed until after <code class="calibre19">self</code> exists:</p>

<pre data-type="programlisting" class="calibre28">class Moi {
    let first = "Matt"
    let last = "Neuburg"
    lazy var whole = self.first + " " + self.last
}</pre>
</dd>
</dl>

<p class="author1">As I demonstrated in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>, a variable can be initialized as part of its declaration using multiple lines of code by means of a define-and-call anonymous function. If this variable is an instance property, and if the function code refers to <code class="calibre19">self</code>, the variable must also be declared <code class="calibre19">lazy</code>:<a data-type="indexterm" data-primary="lazy initialization" data-secondary="instance properties" id="calibre_link-1211" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Moi {
    let first = "Matt"
    let last = "Neuburg"
    lazy var whole : String = {
        var s = self.first
        s.append(" ")
        s.append(self.last)
        return s
    }()
}</pre>

<p class="author1">Unlike instance properties, static properties <em class="calibre11">can</em> be initialized with reference to one another; the reason is that static property initializers are lazy (see <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>):</p>

<pre data-type="programlisting" class="calibre28">struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static let ambivalent = friendly + " but " + hostile
}</pre>

<p class="author1">Notice the lack of <code class="calibre19">self</code> in that code. In static/class code, <code class="calibre19">self</code> means the type itself. I like to use <code class="calibre19">self</code> explicitly wherever it would be implicit, but here I canâ€™t use it without arousing the ire of the compiler (I regard this as a bug). To clarify the status of the terms <code class="calibre19">friendly</code> and <code class="calibre19">hostile</code>, I can use the name of the type, just as any other code would do:</p>

<pre data-type="programlisting" class="calibre28">struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static let ambivalent = Greeting.friendly + " but " + Greeting.hostile
}</pre>

<p class="author1">On the other hand, if I write <code class="calibre19">ambivalent</code> as a computed property, I <em class="calibre11">can</em> use <code class="calibre19">self</code>:</p>

<pre data-type="programlisting" class="calibre28">struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static var ambivalent : String {
        self.friendly + " but " + self.hostile
    }
}</pre>

<p class="author1">On the other other hand, Iâ€™m not allowed to use <code class="calibre19">self</code> when the initial value is set by a define-and-call anonymous function (again, I regard this as a bug):</p>

<pre data-type="programlisting" class="calibre28">struct Greeting {
    static let friendly = "hello there"
    static let hostile = "go away"
    static var ambivalent : String = {
        self.friendly + " but " + self.hostile // compile error
    }()
}</pre>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Methods" class="calibre2"><div class="preface" id="calibre_link-2459">
<h2 class="calibre42">Methods</h2>

<p class="author1">A <em class="calibre11">method</em> is a function &mdash; one that happens to be declared at the top level of an object type declaration. This means that everything said about functions in <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a> applies.<a data-type="indexterm" data-primary="methods" id="calibre_link-1330" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="methods" id="calibre_link-1497" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">By default, a method is an instance method. This means that it can be accessed only through an instance. Within the body of an instance method, <code class="calibre19">self</code> is the instance. To illustrate, letâ€™s continue to develop our Dog class:<a data-type="indexterm" data-primary="instance" data-secondary="methods" id="calibre_link-1108" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="instance" id="calibre_link-1337" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    let name : String
    let license : Int
    let whatDogsSay = "woof"
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    func bark() {
        print(self.whatDogsSay)
    }
    func speak() {
        self.bark()
        print("I'm \(self.name)")
    }
}</pre>

<p class="author1">Now I can make a Dog instance and tell it to speak:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog(name:"Fido", license:1234)
fido.speak() // woof I'm Fido</pre>

<p class="author1">In my Dog class, the <code class="calibre19">speak</code> method calls the instance method <code class="calibre19">bark</code> by way of <code class="calibre19">self</code>, and obtains the value of the instance property <code class="calibre19">name</code> by way of <code class="calibre19">self</code>; and the <code class="calibre19">bark</code> instance method obtains the value of the instance property <code class="calibre19">whatDogsSay</code> by way of <code class="calibre19">self</code>. This is because instance code can use <code class="calibre19">self</code> to refer to this instance. Such code can omit <code class="calibre19">self</code> if the reference is unambiguous; for example, I could have written this:</p>

<pre data-type="programlisting" class="calibre28">func speak() {
    bark()
    print("I'm \(name)")
}</pre>

<p class="author1">But I never write code like that (except by accident). Omitting <code class="calibre19">self</code>, in my view, makes the code harder to read and maintain; the loose terms <code class="calibre19">bark</code> and <code class="calibre19">name</code> seem mysterious and confusing. Moreover, sometimes <code class="calibre19">self</code> cannot be omitted (for example, see <a data-type="xref" href="#calibre_link-2433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œEscaping Closuresâ€</a>), so itâ€™s more consistent to use it always.</p>

<p class="author1">A static/class method is accessed through the type. Within the body of a static/class method, <code class="calibre19">self</code> means the type:<a data-type="indexterm" data-primary="methods" data-secondary="static" id="calibre_link-1352" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="class" id="calibre_link-1331" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="class" data-secondary="methods" id="calibre_link-363" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static methods" id="calibre_link-2069" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Greeting {
    static let friendly = "hello there"
    static func beFriendly() {
        print(self.friendly)
    }
}</pre>

<p class="author1">And hereâ€™s how to call the static <code class="calibre19">beFriendly</code> method:</p>

<pre data-type="programlisting" class="calibre28">Greeting.beFriendly() // hello there</pre>

<p class="author1">There is a kind of conceptual wall between static/class members, on the one hand, and instance members on the other; even though they may be declared within the same object type declaration, they inhabit different worlds. A static/class method canâ€™t refer to â€œthe instanceâ€ because there is no instance; thus, a static/class method cannot directly refer to any instance properties or call any instance methods. An instance method, on the other hand, can refer to the type, and can thus access static/class properties and can call static/class methods.</p>

<p class="author1">For example, letâ€™s return to our Dog class and grapple with the question of what dogs say. Presume that all dogs say the same thing. Weâ€™d prefer, therefore, to express <code class="calibre19">whatDogsSay</code> not at instance level but at class level. This would be a good use of a static property. Hereâ€™s a simplified Dog class that illustrates:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    static var whatDogsSay = "woof"
    func bark() {
        print(Dog.whatDogsSay)
    }
}</pre>

<p class="author1">Now we can make a Dog instance and tell it to bark:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.bark() // woof</pre>

<p class="author1">(Iâ€™ll talk later in this chapter about another way in which an instance method can refer to the type.)</p>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2924">
<h5 class="calibre36">The Secret Life of Instance Methods</h5>
<p class="calibre37">Hereâ€™s a secret: instance methods are actually static/class methods. For example, this is legal (but strange):<a data-type="indexterm" data-primary="methods" data-secondary="instance" data-tertiary="secret life" id="calibre_link-1338" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">class MyClass {
    var s = ""
    func store(_ s:String) {
        self.s = s
    }
}
let m = MyClass()
let f = MyClass.store(m) // what just happened!?</pre>

<p class="calibre37">Even though <code class="calibre19">store</code> is an instance method, we are able to call it as a class method &mdash; with a parameter that is an instance of this class! The reason is that an instance method is actually a curried static/class method composed of two functions &mdash; one function that takes an instance, and another function that takes the parameters of the instance method. Thus, after that code, <code class="calibre19">f</code> is the <em class="calibre11">second</em> of those functions, and can be called as a way of passing a parameter to the <code class="calibre19">store</code> method <em class="calibre11">of the instance <code class="calibre22">m</code>:</em></p>

<pre data-type="programlisting" class="calibre38">f("howdy")
print(m.s) // howdy</pre>
</div>
</aside>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Subscripts" class="calibre2"><div class="preface" id="calibre_link-2460">
<h2 class="calibre42">Subscripts</h2>

<p class="author1">A <em class="calibre11">subscript</em> is a method that is called in a special way &mdash; by appending square brackets to a reference. The square brackets can contain arguments to be passed to the subscript method. You can use this feature for whatever you like, but it is suitable particularly for situations where this is an object type with <em class="calibre11">elements</em> that can be appropriately accessed by key or by index number. I have already described (in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>) the use of this syntax with strings, and it is familiar also from dictionaries and arrays; you can use square brackets with strings and dictionaries and arrays exactly because Swiftâ€™s String and Dictionary and Array types declare subscript methods.<a data-type="indexterm" data-primary="subscripts" id="calibre_link-2151" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="subscripts" id="calibre_link-1508" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="square brackets" id="calibre_link-2055" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The syntax for declaring a subscript method is somewhat like a function declaration and somewhat like a computed property declaration. Thatâ€™s no coincidence. A subscript is like a function in that it can take parameters: arguments can appear in the square brackets when a subscript method is called. A subscript is like a computed property in that the call is used like a reference to a property: you can fetch its value or you can assign into it.</p>

<p class="author1">To illustrate the syntax, hereâ€™s a struct that treats an integer as if it were a digit sequence, returning a digit that can be specified by an index number in square brackets; for simplicity, Iâ€™m deliberately omitting any error-checking:</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number : Int
    init(_ n:Int) {
        self.number = n
    }
    subscript(ix:Int) -&gt; Int { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2831" href="#calibre_link-2828"><img src="images/000019.png" alt="1" class="calibre39" /></a> <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2832" href="#calibre_link-2829"><img src="images/000008.png" alt="2" class="calibre39" /></a>
        get { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2833" href="#calibre_link-2830"><img src="images/000029.png" alt="3" class="calibre39" /></a>
            let s = String(self.number)
            return Int(String(s[s.index(s.startIndex, offsetBy:ix)]))!
        }
    }
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2828" href="#calibre_link-2831"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">After the keyword <code class="calibre19">subscript</code> we have a parameter list stating what parameters are to appear inside the square brackets. By default, <em class="calibre11">parameter names are not externalized</em>; if you want a parameter name to be externalized, your declaration must include an external name before the internal name, even if they are the same name &mdash; for example, <code class="calibre19">subscript(ix&nbsp;ix:Int)</code>. This is different from how external names work everywhere else in Swift (and therefore I regard it as a bug in the language).<a data-type="indexterm" data-primary="external parameter names" data-secondary="subscripts" id="calibre_link-840" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" data-secondary="external names" data-tertiary="subscripts" id="calibre_link-1669" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2829" href="#calibre_link-2832"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Then we have the type of value that is passed out (when the getter is called) or in (when the setter is called); this is parallel to the type declared for a computed property, except that (oddly) the type is preceded by the arrow operator instead of a colon.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2830" href="#calibre_link-2833"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Finally, we have curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-587" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> whose contents are exactly like those of a computed property. You can have <code class="calibre19">get</code> and curly braces for the getter, and <code class="calibre19">set</code> and curly braces for the setter. The setter can be omitted (as here); in that case, the word <code class="calibre19">get</code> and its curly braces can be omitted. If the getter consists of a single statement, the keyword <code class="calibre19">return</code> can be omitted. The setter receives the new value as <code class="calibre19">newValue</code>, but you can change that name by supplying a different name in parentheses after the word <code class="calibre19">set</code>.</p></dd>
</dl>

<p class="author1">Hereâ€™s an example of calling the getter; the instance with appended square brackets containing the arguments is used just as if you were getting a property value:</p>

<pre data-type="programlisting" class="calibre28">var d = Digit(1234)
let aDigit = d[1] // 2</pre>

<p class="author1">Now Iâ€™ll expand my Digit struct so that its subscript method includes a setter (and again Iâ€™ll omit error-checking):</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number : Int
    init(_ n:Int) {
        self.number = n
    }
    subscript(ix:Int) -&gt; Int {
        get {
            let s = String(self.number)
            return Int(String(s[s.index(s.startIndex, offsetBy:ix)]))!
        }
        set {
            var s = String(self.number)
            let i = s.index(s.startIndex, offsetBy:ix)
            s.replaceSubrange(i...i, with: String(newValue))
            self.number = Int(s)!
        }
    }
}</pre>

<p class="author1">And hereâ€™s an example of calling the setter; the instance with appended square brackets containing the arguments is used just as if you were setting a property value:</p>

<pre data-type="programlisting" class="calibre28">var d = Digit(1234)
d[0] = 2 // now d.number is 2234</pre>

<p class="author1">An object type can declare multiple subscript methods, distinguished by their <span class="publishername">parameters.</span> New in Swift 5.1, a subscript can be a static/class method.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Nested Object Types" class="calibre2"><div class="preface" id="calibre_link-2461">
<h2 class="calibre42">Nested Object Types</h2>

<p class="author1">An object type may be declared inside an object type declaration, forming a nested type:<a data-type="indexterm" data-primary="namespaces" id="calibre_link-1378" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="nested" id="calibre_link-1498" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nested types" id="calibre_link-1388" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    struct Noise {
        static var noise = "woof"
    }
    func bark() {
        print(Dog.Noise.noise)
    }
}</pre>

<p class="author1">A nested object type is no different from any other object type, but the rules for referring to it from the outside are changed; the surrounding object type acts as a namespace, and must be referred to explicitly in order to access the nested object type:</p>

<pre data-type="programlisting" class="calibre28">Dog.Noise.noise = "arf"</pre>

<p class="author1">Here, the Noise struct is namespaced inside the Dog class. This namespacing provides clarity: the name Noise does not float free, but is explicitly associated with the Dog class to which it belongs. Namespacing also allows more than one Noise type to exist, without any clash of names. Swift built-in object types often take advantage of namespacing; for example, the String struct is one of several structs that contain an Index struct, with no clash of names.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Enums" class="calibre2"><div class="preface" id="calibre_link-2462">
<h1 class="calibre18">Enums</h1>

<p class="author1">An <em class="calibre11">enum</em> is an object type whose instances represent <em class="calibre11">distinct predefined alternative values</em>. Think of it as a list of known possibilities. An enum is the Swift way to express a set of constants that are alternatives to one another. An enum declaration includes case statements. Each case is the name of one of the alternatives. An instance of an enum will represent exactly one alternative &mdash; one case.<a data-type="indexterm" data-primary="case" data-secondary="enum" id="calibre_link-340" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="cases" id="calibre_link-754" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-primary="enums" data-seealso="object types" id="calibre_link-746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, in my Albumen app, different instances of the same view controller can list any of four different sorts of music library contents: albums, playlists, podcasts, or audiobooks. The view controllerâ€™s behavior is slightly different in each case. So I need a sort of four-way switch that I can set once when the view controller is instantiated, saying which sort of contents this view controller is to display. That sounds like an enum!<a data-type="indexterm" data-primary="enums" data-secondary="declaration" id="calibre_link-756" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of enums" id="calibre_link-624" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s the basic declaration for that enum; I call it Filter, because each case represents a different way of filtering the contents of the music library:</p>

<pre data-type="programlisting" class="calibre28">enum Filter {
    case albums
    case playlists
    case podcasts
    case books
}</pre>

<p class="author1">That enum doesnâ€™t have an initializer. You <em class="calibre11">can</em> write an initializer for an enum, as Iâ€™ll demonstrate in a moment; but there is a default mode of initialization that youâ€™ll probably use most of the time &mdash; the name of the enum followed by dot-notation and one of the cases. For example, hereâ€™s how to make an instance of Filter representing the <code class="calibre19">albums</code> case:<a data-type="indexterm" data-primary="enums" data-secondary="initializing" id="calibre_link-762" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="creating an enum" id="calibre_link-574" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initialization" data-secondary="of enums" id="calibre_link-1077" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="implicit" data-tertiary="enum" id="calibre_link-1093" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let type = Filter.albums</pre>

<p class="author1">If the type is known in advance, you can omit the name of the enum; the bare case must still be preceded by a dot:<a data-type="indexterm" data-primary="enums" data-secondary="omitting type name" id="calibre_link-764" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="name, omitting" id="calibre_link-2233" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let type : Filter = .albums</pre>

<p class="author1">You canâ€™t say <code class="calibre19">.albums</code> just anywhere out of the blue, because Swift doesnâ€™t know what enum it belongs to. But in that code, the variable is explicitly declared as a Filter, so Swift knows what <code class="calibre19">.albums</code> means. A similar thing happens when passing an enum instance as an argument in a function call:</p>

<pre data-type="programlisting" class="calibre28">func filterExpecter(_ type:Filter) {}
filterExpecter(.albums)</pre>

<p class="author1">In the second line, I create an instance of Filter and pass it, all in one move, without having to include the name of the enum. Thatâ€™s because Swift knows from the function declaration that a Filter is expected here.</p>

<p class="author1">In real life, the space savings when omitting the enum name can be considerable &mdash; especially because, when talking to Cocoa, the enum type names are often long:</p>

<pre data-type="programlisting" class="calibre28">let v = UIView()
v.contentMode = .center</pre>

<p class="author1">A UIViewâ€™s <code class="calibre19">contentMode</code> property is typed as a <span class="publishername">UIView.ContentMode</span> enum. Our code is neater and simpler because we donâ€™t have to include the type name explicitly here; <code class="calibre19">.center</code> is nicer than <code class="calibre19">UIView.ContentMode.center</code>. But either is legal.</p>

<p class="author1">Instances of an enum with the same case are regarded as equal. Thus, you can compare an enum instance for equality against a case. Again, the type of enum is known from the first term in the comparison, so the second term can omit the enum name:<a data-type="indexterm" data-primary="enums" data-secondary="equality" id="calibre_link-757" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func filterExpecter(_ type:Filter) {
    if type == .albums {
        print("it's albums")
    }
}
filterExpecter(.albums) // "it's albums"</pre>








<section data-type="sect2" data-pdf-bookmark="Raw Values" class="calibre2"><div class="preface" id="calibre_link-2463">
<h2 class="calibre42">Raw Values</h2>

<p class="author1">Optionally, when you declare an enum, you can add a type declaration. The cases then all carry with them a fixed (constant) value of that type. The types attached to an enum in this way are limited to numbers and strings, and the values assigned must be literals.</p>

<p class="author1">If the type is an integer numeric type, the values can be implicitly assigned, and will start at zero by default. For example:<a data-type="indexterm" data-primary="raw value" id="calibre_link-1853" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="raw value" id="calibre_link-766" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="colon" data-secondary="enum raw value type" id="calibre_link-461" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum PepBoy : Int {
    case manny
    case moe
    case jack
}</pre>

<p class="author1">In that code, <code class="calibre19">.manny</code> carries a value of <code class="calibre19">0</code>, <code class="calibre19">.moe</code> carries of a value of <code class="calibre19">1</code>, and so on.</p>

<p class="author1">If the type is String, the implicitly assigned values are the string equivalents of the case names. For example:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String {
    case albums
    case playlists
    case podcasts
    case books
}</pre>

<p class="author1">In that code, <code class="calibre19">.albums</code> carries a value of <code class="calibre19">"albums"</code>, and so on.</p>

<p class="author1">Regardless of the type, you can assign values explicitly as part of the case declarations, like this:</p>

<pre data-type="programlisting" class="calibre28">enum Normal : Double {
    case fahrenheit = 98.6
    case centigrade = 37
}
enum PepBoy : Int {
    case manny = 1
    case moe // 2 implicitly
    case jack = 4
}
enum Filter : String {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
}</pre>

<p class="author1">The values carried by the cases are called their <em class="calibre11">raw values</em>. Thatâ€™s because an enum with a type declaration automatically adopts the RawRepresentable<a data-type="indexterm" data-primary="RawRepresentable" id="calibre_link-1854" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> protocol, meaning that such an enum implicitly has a <code class="calibre19">rawValue</code> property and an <code class="calibre19">init(rawValue:)</code> initializer. (Iâ€™ll explain later what a protocol is.) An instance of an enum has just one case, so it has just one fixed raw value, which can be retrieved with its <code class="calibre19">rawValue</code> property:</p>

<pre data-type="programlisting" class="calibre28">let type = Filter.albums
print(type.rawValue) // Albums</pre>

<p class="author1">Having each case carry a fixed raw value can be quite useful. In my Albumen app, the Filter cases really do have those String values, and <code class="calibre19">type</code> is a Filter instance property of the view controller; when the view controller wants to know what title string to put at the top of the screen, it simply retrieves <code class="calibre19">self.type.rawValue</code>.</p>

<p class="author1">The raw value associated with each case must be unique within this enum; the compiler will enforce this rule. Therefore, the mapping works the other way: given a raw value, you can derive the case; in particular, you can instantiate an enum that has raw values by using its <code class="calibre19">init(rawValue:)</code> <span class="publishername">initializer:</span></p>

<pre data-type="programlisting" class="calibre28">let type = Filter(rawValue:"Albums")</pre>

<p class="author1">However, the attempt to instantiate the enum in this way still might fail, because you might supply a raw value corresponding to <em class="calibre11">no</em> case; therefore, this is a failable <span class="publishername">initializer</span>, and the value returned is an Optional. In that code, <code class="calibre19">type</code> is not a Filter; itâ€™s an Optional wrapping a Filter. This might not be terribly important, however, because the thing you are most likely to want to do with an enum is to compare it for equality with a case of the enum; you can do that with an Optional without unwrapping it. This code is legal and works correctly:</p>

<pre data-type="programlisting" class="calibre28">let type = Filter(rawValue:"Albums")
if type == .albums { // ...</pre>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2739">
<h5 class="calibre36">Inference of Type Name with Static/Class Members</h5>
<p class="calibre37">Just as you can use a dot and the name of an enum case where an instance of that enum is expected, you can do the same thing when referring to a typeâ€™s static/class member whose value is an instance of that type. For example, UIColor has many class properties that produce a UIColor instance, so you can omit <code class="calibre19">UIColor</code> where a UIColor is expected:<a data-type="indexterm" data-primary="properties" data-secondary="omitting type name" id="calibre_link-1767" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="omitting type name" id="calibre_link-389" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="omitting type name" id="calibre_link-2128" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="omitting type name" id="calibre_link-1343" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">p.trackTintColor = .red // instead of UIColor.red</pre>

<p class="calibre37">Similarly, suppose we have a struct Thing with static constants whose values are Thing instances:</p>

<pre data-type="programlisting" class="calibre38">struct Thing : RawRepresentable {
    let rawValue : Int
    static let one : Thing = Thing(rawValue:1)
    static let two : Thing = Thing(rawValue:2)
}</pre>

<p class="calibre37">Then we can refer to <code class="calibre19">Thing.one</code> as <code class="calibre19">.one</code> where a Thing instance is expected:</p>

<pre data-type="programlisting" class="calibre38">let thing : Thing = .one</pre>

<p class="calibre37">Many Objective-C enums are bridged to Swift as that kind of struct, as Iâ€™ll explain later in the chapter.</p>
</div>
</aside>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Associated Values" class="calibre2"><div class="preface" id="calibre_link-2464">
<h2 class="calibre42">Associated Values</h2>

<p class="author1">The raw values discussed in the preceding section are fixed in the enumâ€™s declaration: a given case carries with it a certain raw value, and thatâ€™s that. But thereâ€™s also a way to construct a case whose constant value can be set <em class="calibre11">when the instance is created</em>. The attached value here is called an <em class="calibre11">associated value</em>.</p>

<p class="author1">To write an enum with one or more cases taking an associated value, do not declare any raw value type for the enum as a whole; instead, you append to the name of the case an expression that looks very much like a tuple &mdash; that is, parentheses containing a list of possibly labeled types. Unlike a raw value, your choice of type is not limited. Most often, a single value will be attached to a case, so youâ€™ll write parentheses containing a single type name. Hereâ€™s an <span class="publishername">example:</span><a data-type="indexterm" data-primary="associated value" id="calibre_link-224" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="associated value" id="calibre_link-748" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum MyError {
    case number(Int)
    case message(String)
    case fatal
}</pre>

<p class="author1">That code means that, at instantiation time, a MyError instance with the <code class="calibre19">.number</code> case must be assigned an Int value, a MyError instance with the <code class="calibre19">.message</code> case must be assigned a String value, and a MyError instance with the <code class="calibre19">.fatal</code> case canâ€™t be assigned any value. Instantiation with assignment of a value is really a way of calling an initialization function, so to supply the value, you pass it as an argument in parentheses:</p>

<pre data-type="programlisting" class="calibre28">let err : MyError = .number(4)</pre>

<p class="author1">This is an ordinary function call, so the argument doesnâ€™t have to be a literal:</p>

<pre data-type="programlisting" class="calibre28">let num = 4
let err : MyError = .number(num)</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">At the risk of sounding like a magician explaining his best trick, I can now reveal how an Optional works. An Optional is simply an enum with two cases: <code class="calibre19">.none</code> and <code class="calibre19">.some</code>. If it is <code class="calibre19">.none</code>, it carries no associated value, and it equates to <code class="calibre19">nil</code>. If it is <code class="calibre19">.some</code>, it carries the wrapped value as its associated value.<a data-type="indexterm" data-primary="Optionals" data-secondary="enum" id="calibre_link-1608" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>

<p class="author1">If a caseâ€™s associated value type has a label, that label must be used at initialization time:</p>

<pre data-type="programlisting" class="calibre28">enum MyError2 {
    case number(Int)
    case message(String)
    case fatal(n:Int, s:String)
}
let err : MyError2 = .fatal(n:-12, s:"Oh the horror")</pre>

<p class="author1">By default, the <code class="calibre19">==</code> operator cannot be used to compare cases of an enum if any case of that enum has an associated value:<a data-type="indexterm" data-primary="enums" data-secondary="equality" id="calibre_link-758" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">if err == MyError.fatal { // compile error</pre>

<p class="author1">But if you declare this enum explicitly as adopting the Equatable<a data-type="indexterm" data-primary="Equatable" id="calibre_link-773" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> protocol (discussed later in this chapter and in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>), the <code class="calibre19">==</code> operator starts working:</p>

<pre data-type="programlisting" class="calibre28">enum MyError : Equatable { // *
    case number(Int)
    case message(String)
    case fatal
}</pre>

<p class="author1">That code wonâ€™t compile, however, unless all the associated types are themselves Equatable. That makes sense; if we declare <code class="calibre19">case pet(Dog)</code> and there is no way to know whether any two Dogs are equal, there is obviously no way to know whether any two <code class="calibre19">pet</code> cases are equal.</p>

<p class="author1">Iâ€™ll explain in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> how to <em class="calibre11">check the case</em> of an instance of an enum that has an associated value case, as well as how to <em class="calibre11">extract</em> the associated value from an enum instance that has one.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Enum Case Iteration" class="calibre2"><div class="preface" id="calibre_link-2465">
<h2 class="calibre42">Enum Case Iteration</h2>

<p class="author1">It is often useful to have a list &mdash; that is, an array &mdash; of all the cases of an enum. You could define this list manually as a static property of the enum:<a data-type="indexterm" data-primary="enums" data-secondary="cases" data-tertiary="enumerating" id="calibre_link-755" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="CaseIterable" id="calibre_link-342" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="allCases" id="calibre_link-129" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum Filter : String {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    static let cases : [Filter] = [.albums, .playlists, .podcasts, .books]
}</pre>

<p class="author1">That, however, is error-prone and hard to maintain; if, as you develop your program, you modify the enumâ€™s cases, you must remember to modify the <code class="calibre19">cases</code> property to match. Starting in Swift 4.2, the list of cases can be generated for you <em class="calibre11">automatically.</em> Simply have your enum adopt the CaseIterable protocol (adoption of protocols is explained later in this chapter); now the list of cases springs to life as a static property called <code class="calibre19">allCases</code>:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String, CaseIterable {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    // static allCases is now [.albums, .playlists, .podcasts, .books]
}</pre>

<p class="author1">Iâ€™ll put this feature to use in the next section.</p>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">Automatic generation of <code class="calibre19">allCases</code> is impossible if any of the enumâ€™s cases has an associated value, as it would then be unclear how that case should be defined in the list.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Enum Initializers" class="calibre2"><div class="preface" id="calibre_link-2466">
<h2 class="calibre42">Enum Initializers</h2>

<p class="author1">An explicit enum initializer must do what default initialization does: it must return a particular case of this enum. To do so, set <code class="calibre19">self</code> to the case. In this example, Iâ€™ll expand my Filter enum so that it can be initialized with a numeric argument:<a data-type="indexterm" data-primary="enums" data-secondary="initializers" id="calibre_link-761" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="enum" id="calibre_link-1088" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum Filter : String, CaseIterable {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    init(_ ix:Int) {
        self = Filter.allCases[ix]
    }
}</pre>

<p class="author1">Now there are three ways to make a Filter instance:</p>

<pre data-type="programlisting" class="calibre28">let type1 = Filter.albums
let type2 = Filter(rawValue:"Playlists")!
let type3 = Filter(2) // .podcasts</pre>

<p class="author1">In that example, weâ€™ll crash in the third line if the caller passes a number thatâ€™s out of range (less than 0 or greater than 3). If we want to avoid that, we can make this a failable initializer and return <code class="calibre19">nil</code> if the number is out of range:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String, CaseIterable {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    init?(_ ix:Int) {
        if !Filter.allCases.indices.contains(ix) {
            return nil
        }
        self = Filter.allCases[ix]
    }
}</pre>

<p class="author1">An enum can have multiple initializers. Enum initializers can delegate to one another by saying <code class="calibre19">self.init(...)</code>. The only requirement is that, at some point in the chain of calls, <code class="calibre19">self</code> must be set to a case; if that doesnâ€™t happen, your enum wonâ€™t compile.</p>

<p class="author1">In this example, I improve my Filter enum so that it can be initialized with a String raw value without having to say <code class="calibre19">rawValue:</code> in the call. To do so, I declare a failable initializer with a string parameter that delegates to the built-in failable <code class="calibre19">rawValue:</code> <span class="publishername">initializer:</span></p>

<pre data-type="programlisting" class="calibre28">enum Filter : String, CaseIterable {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    init?(_ ix:Int) {
        if !Filter.allCases.indices.contains(ix) {
            return nil
        }
        self = Filter.allCases[ix]
    }
    init?(_ rawValue:String) {
        self.init(rawValue:rawValue)
    }
}</pre>

<p class="author1">Now there are four ways to make a Filter instance:</p>

<pre data-type="programlisting" class="calibre28">let type1 = Filter.albums
let type2 = Filter(rawValue:"Playlists")!
let type3 = Filter(2)
let type4 = Filter("Audiobooks")!</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Enum Properties" class="calibre2"><div class="preface" id="calibre_link-2467">
<h2 class="calibre42">Enum Properties</h2>

<p class="author1">An enum can have instance properties and static properties, but thereâ€™s a limitation: an enum instance property canâ€™t be a stored property.
<a data-type="indexterm" data-primary="enums" data-secondary="properties" id="calibre_link-765" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="enums" id="calibre_link-1753" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
Computed instance properties are fine, however, and the value of the property can vary by rule in accordance with the case of <code class="calibre19">self</code>. In this example from my real code, Iâ€™ve associated an MPMediaQuery (obtained by calling an MPMediaQuery factory class method) with each case of my Filter enum, suitable for fetching the songs of that type from the music library:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    var query : MPMediaQuery {
        switch self {
        case .albums:
            return .albums()
        case .playlists:
            return .playlists()
        case .podcasts:
            return .podcasts()
        case .books:
            return .audiobooks()
        }
    }
}</pre>

<p class="author1">If an enum instance property is a computed variable with a setter, other code can assign to this property. However, that codeâ€™s reference to the enum instance itself must be a variable (<code class="calibre19">var</code>), not a constant (<code class="calibre19">let</code>). If you try to assign to an enum instance property through a <code class="calibre19">let</code> reference to the enum, youâ€™ll get a compile error.</p>

<p class="author1">For example, hereâ€™s a silly enum:</p>

<pre data-type="programlisting" class="calibre28">enum Silly {
    case one
    var sillyProperty : String {
        get { "Howdy" }
        set {} // do nothing
    }
}</pre>

<p class="author1">It is then legal to say this:</p>

<pre data-type="programlisting" class="calibre28">var silly = Silly.one
silly.sillyProperty = "silly"</pre>

<p class="author1">But if <code class="calibre19">silly</code> were declared with <code class="calibre19">let</code> instead of <code class="calibre19">var</code>, trying to set <code class="calibre19">silly.sillyProperty</code> would cause a compile error.</p>

<p class="author1">An enum static property can have a property wrapper, but an enum instance property canâ€™t, because that would imply storage of an instance of the underlying <code class="calibre19">@propertyWrapper</code> type.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Enum Methods" class="calibre2"><div class="preface" id="calibre_link-2468">
<h2 class="calibre42">Enum Methods</h2>

<p class="author1">An enum can have instance methods (including subscripts) and static methods. Writing an enum method is straightforward. Hereâ€™s an example from my own code. In a card game, the cards draw themselves as rectangles, ellipses, or diamonds. Iâ€™ve abstracted the drawing code into an enum that draws itself as a rectangle, an ellipse, or a diamond, depending on its case:<a data-type="indexterm" data-primary="enums" data-secondary="methods" id="calibre_link-763" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="enums" id="calibre_link-1333" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum Shape {
    case rectangle
    case ellipse
    case diamond
    func addShape (to p: CGMutablePath, in r: CGRect) -&gt; () {
        switch self {
        case .rectangle:
            p.addRect(r)
        case .ellipse:
            p.addEllipse(in:r)
        case .diamond:
            p.move(to: CGPoint(x:r.minX, y:r.midY))
            p.addLine(to: CGPoint(x: r.midX, y: r.minY))
            p.addLine(to: CGPoint(x: r.maxX, y: r.midY))
            p.addLine(to: CGPoint(x: r.midX, y: r.maxY))
            p.closeSubpath()
        }
    }
}</pre>

<p class="author1">An enum instance method that modifies the enum itself must be marked as <code class="calibre19">mutating</code>. For example, an enum instance method might assign to an instance property of <code class="calibre19">self</code>; even though this is a computed property, such assignment is illegal unless the method is marked as <code class="calibre19">mutating</code>. The caller of a mutating instance method must have a variable reference to the instance (<code class="calibre19">var</code>), not a constant reference (<code class="calibre19">let</code>).<a data-type="indexterm" data-primary="methods" data-secondary="mutating" id="calibre_link-1339" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutating methods" id="calibre_link-1368" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A mutating enum instance method can replace this instance with another instance, by assigning another case to <code class="calibre19">self</code>. In this example, I add an <code class="calibre19">advance</code> method to my Filter enum. The idea is that the cases constitute a sequence, and the sequence can cycle. By calling <code class="calibre19">advance</code>, I transform a Filter instance into an instance of the next case in the sequence:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String, CaseIterable {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    mutating func advance() {
        let cases = Filter.allCases
        var ix = cases.firstIndex(of:self)!
        ix = (ix + 1) % cases.count
        self = cases[ix]
    }
}</pre>

<p class="author1">And hereâ€™s how to call it:</p>

<pre data-type="programlisting" class="calibre28">var type = Filter.books
type.advance() // type is now Filter.albums</pre>

<p class="author1">Observe that <code class="calibre19">type</code> is declared with <code class="calibre19">var</code>; if it were declared with <code class="calibre19">let</code>, weâ€™d get a compile error.</p>

<p class="author1">A subscript or computed property setter is considered mutating by default and does not have to be specially marked. However, if a getter sets another property as a side effect, it must be marked <code class="calibre19">mutating get</code>.<a data-type="indexterm" data-primary="subscripts" data-secondary="enums" id="calibre_link-2153" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="subscripts" id="calibre_link-767" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Why Enums?" class="calibre2"><div class="preface" id="calibre_link-2469">
<h2 class="calibre42">Why Enums?</h2>

<p class="author1">An enum is a switch whose states have names. There are many situations where thatâ€™s a desirable thing. You could implement a multistate value yourself; for example, if there are five possible states, you could use an Int whose values can be 0 through 4. But then you would have to provide a lot of additional overhead, interpreting those numeric values correctly and making sure that no other values are used. A list of five named cases is much better!</p>

<p class="author1">Even when there are only <em class="calibre11">two</em> states, an enum is often better than, say, a mere Bool, because the enumâ€™s states have names. With a Bool, you have to know what <code class="calibre19">true</code> and <code class="calibre19">false</code> signify in a particular usage; with an enum, the name of the enum and the names of its cases <em class="calibre11">tell</em> you its significance. Moreover, you can store extra information in an enumâ€™s associated value or raw value; you canâ€™t do that with a mere Bool.</p>

<p class="author1">For example, in my LinkSame app, the user can play a real game with a timer or a practice game without a timer. At various places in the code, I need to know which type of game this is. The game types are the cases of an enum:</p>

<pre data-type="programlisting" class="calibre28">enum InterfaceMode : Int {
    case timed = 0
    case practice = 1
}</pre>

<p class="author1">The current game type is stored in an instance property <code class="calibre19">interfaceMode</code>, whose value is an InterfaceMode. Thus, itâ€™s easy to set the game type by case name:</p>

<pre data-type="programlisting" class="calibre28">// ... initialize new game ...
self.interfaceMode = .timed</pre>

<p class="author1">And itâ€™s easy to examine the game type by case name:</p>

<pre data-type="programlisting" class="calibre28">// notify of high score only if user is not just practicing
if self.interfaceMode == .timed { // ...</pre>

<p class="author1">And what are my InterfaceMode enumâ€™s raw value integers for? Thatâ€™s the really clever part. They correspond to the segment indexes of a UISegmentedControl in the interface! Whenever I change the <code class="calibre19">interfaceMode</code> property, a setter observer also selects the corresponding segment of the UISegmentedControl (<code class="calibre19">self.timedPractice</code>), simply by fetching the <code class="calibre19">rawValue</code> of the current enum case:<a data-type="indexterm" data-startref="idxenums" id="calibre_link-747" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var interfaceMode : InterfaceMode = .timed {
    willSet (mode) {
        self.timedPractice?.selectedSegmentIndex = mode.rawValue
    }
}</pre>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Structs" class="calibre2"><div class="preface" id="calibre_link-2470">
<h1 class="calibre18">Structs</h1>

<p class="author1">A <em class="calibre11">struct</em> is the Swift object type <em class="calibre11">par excellence</em>. An enum, with its fixed set of cases, is a reduced, specialized kind of object. A class, at the other extreme, will often turn out to be overkill; it has some features that a struct lacks (Iâ€™ll talk later about what they are), but if you donâ€™t need those features, a struct may be preferable.<a data-type="indexterm" data-primary="structs" data-seealso="object types" id="calibre_link-2119" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Of more than two hundred object types declared in the Swift header, maybe half a dozen are classes. A couple of dozen are enums. All the rest are structs. A String is a struct. An Int is a struct. A Range is a struct. An Array is a struct. And so on. That shows how powerful a struct can be.</p>








<section data-type="sect2" data-pdf-bookmark="Struct Initializers" class="calibre2"><div class="preface" id="calibre_link-2471">
<h2 class="calibre42">Struct Initializers</h2>

<p class="author1">A struct that doesnâ€™t have an explicit initializer and that doesnâ€™t <em class="calibre11">need</em> an explicit initializer &mdash; because it has no stored properties, or because all its stored properties are assigned default values as part of their declaration &mdash; automatically gets an implicit initializer with no parameters, <code class="calibre19">init()</code>. For example:<a data-type="indexterm" data-primary="structs" data-secondary="initializers" id="calibre_link-2125" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="struct" id="calibre_link-1102" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="implicit" data-tertiary="struct" id="calibre_link-1094" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="implicit initializer" id="calibre_link-1043" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number = 42
}</pre>

<p class="author1">That struct can be initialized by saying <code class="calibre19">Digit()</code>. But if you add any explicit initializers of your own, you lose that implicit initializer:</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number = 42
    init(number:Int) {
        self.number = number
    }
}</pre>

<p class="author1">Now you can say <code class="calibre19">Digit(number:42)</code>, but you canâ€™t say <code class="calibre19">Digit()</code> any longer. Of course, you can add an explicit initializer that does the same thing:</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number = 42
    init() {}
    init(number:Int) {
        self.number = number
    }
}</pre>

<p class="author1">Now you can say <code class="calibre19">Digit()</code> once again, as well as <code class="calibre19">Digit(number:42)</code>.</p>

<p class="author1">A struct that has stored properties and that doesnâ€™t have an explicit initializer automatically gets an implicit initializer derived from its instance properties. This is called the <em class="calibre11">memberwise initializer</em>. For example:<a data-type="indexterm" data-primary="memberwise initializer" id="calibre_link-1277" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Test {
    var number = 42
    var name : String
    let age : Int
    let greeting = "Hello"
}</pre>

<p class="author1">That struct is legal, even though it seems we have not fulfilled the contract requiring us to initialize all stored properties in their declaration or in an initializer. The reason is that this struct automatically has a memberwise initializer which <em class="calibre11">does</em> initialize all its properties.
Given that declaration, there are two ways to make a Test instance:</p>

<pre data-type="programlisting" class="calibre28">let t1 = Test(number: 42, name: "matt", age: 65)
let t2 = Test(name: "matt", age: 65)</pre>

<p class="author1">The memberwise initializer includes <code class="calibre19">number</code>, <code class="calibre19">name</code>, and <code class="calibre19">age</code>, but not <code class="calibre19">greeting</code>, because <code class="calibre19">greeting</code> is a <code class="calibre19">let</code> property that has already been initialized before the initializer is called. <code class="calibre19">number</code> has been initialized too, but it is a <code class="calibre19">var</code> property, so the memberwise initializer includes it &mdash; but you can also omit it from your call to the memberwise initializer, because it has been initialized already and therefore has a default value.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The ability to omit an initialized <code class="calibre19">var</code> property from a call to the memberwise initializer is new in Swift 5.1.</p>
</div>

<p class="author1">But if you add any explicit initializers of your own, or if any of the properties involved are declared <code class="calibre19">private</code>, you lose the memberwise initializer (though of course you can write an explicit initializer that does the same thing).</p>

<p class="author1">All stored properties must be initialized either by direct initialization in the declaration or by all initializers. If a struct has multiple explicit initializers, they can delegate to one another by saying <code class="calibre19">self.init(...)</code>.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Struct Properties" class="calibre2"><div class="preface" id="calibre_link-2472">
<h2 class="calibre42">Struct Properties</h2>

<p class="author1">A struct can have instance properties and static properties, which can be stored or computed variables. If other code wants to set a property of a struct instance, its reference to that instance must be a variable (<code class="calibre19">var</code>), not a constant (<code class="calibre19">let</code>).<a data-type="indexterm" data-primary="structs" data-secondary="properties" id="calibre_link-2129" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="structs" id="calibre_link-1778" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s a Digit struct with a <code class="calibre19">var number</code> instance property:</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number : Int
    init(_ n:Int) {
        self.number = n
    }
}</pre>

<p class="author1">Then this is legal:</p>

<pre data-type="programlisting" class="calibre28">var d = Digit(123)
d.number = 42</pre>

<p class="author1">But if <code class="calibre19">d</code> were declared with <code class="calibre19">let</code>, trying to set <code class="calibre19">d.number</code> would cause a compile error.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Struct Methods" class="calibre2"><div class="preface" id="calibre_link-2473">
<h2 class="calibre42">Struct Methods</h2>

<p class="author1">A struct can have instance methods and static methods, including subscripts. If an instance method sets a property, it must be marked as <code class="calibre19">mutating</code>, and the callerâ€™s reference to the struct instance must be a variable (<code class="calibre19">var</code>), not a constant (<code class="calibre19">let</code>).<a data-type="indexterm" data-primary="methods" data-secondary="mutating" id="calibre_link-1340" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutating methods" id="calibre_link-1369" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="methods" id="calibre_link-2127" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="structs" id="calibre_link-1354" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subscripts" data-secondary="structs" id="calibre_link-2155" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="subscripts" id="calibre_link-2131" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s a new version of our Digit struct:</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    private var number : Int
    init(_ n:Int) {
        self.number = n
    }
    mutating func changeNumberTo(_ n:Int) {
        self.number = n
        // or: self = Digit(n)
    }
}</pre>

<p class="author1">Here we have a private <code class="calibre19">number</code> property private, along with a public method for setting it. This method must be declared <code class="calibre19">mutating</code>. We can then say this:</p>

<pre data-type="programlisting" class="calibre28">var d = Digit(123)
d.changeNumberTo(42)</pre>

<p class="author1">The <code class="calibre19">changeNumberTo</code> method must be declared <code class="calibre19">mutating</code>, and if <code class="calibre19">d</code> were declared with <code class="calibre19">let</code>, trying to call <code class="calibre19">d.changeNumberTo</code> would cause a compile error.</p>

<p class="author1">A subscript or computed property setter is considered mutating by default and does not have to be specially marked. However, if a getter sets another property as a side effect, it must be marked <code class="calibre19">mutating get</code>.</p>

<p class="author1">A mutating instance method can replace this instance with another instance, by setting <code class="calibre19">self</code> to a different instance of the same struct.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Struct As Namespace" class="calibre2"><div class="preface" id="calibre_link-95">
<h2 class="calibre42">Struct As Namespace</h2>

<p class="author1">I often use a degenerate struct as a handy namespace for constants. I call such a struct â€œdegenerateâ€ because it consists entirely of static members; I donâ€™t intend to use this object type to make any instances.<a data-type="indexterm" data-primary="namespaces" id="calibre_link-1379" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="constants" id="calibre_link-540" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="global constants" id="calibre_link-975" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="static" data-tertiary="struct" id="calibre_link-1776" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static properties" data-secondary="struct" id="calibre_link-2074" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="static properties" id="calibre_link-2130" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s say Iâ€™m going to be storing user preference information in Cocoaâ€™s UserDefaults<a data-type="indexterm" data-primary="UserDefaults" id="calibre_link-2304" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. UserDefaults is a kind of dictionary: each item is accessed through a key. The keys are typically strings. A common programmer mistake is to write out these string keys literally every time a key is used; if you then misspell a key name, thereâ€™s no penalty at compile time, but your code will mysteriously fail to work correctly. A better approach is to embody those keys as constant strings and use the names of the strings; if you make a mistake typing a name, the compiler can catch you. A struct with static members is a great way to define constant strings and clump their names into a namespace:</p>

<pre data-type="programlisting" class="calibre28">struct Default {
    static let rows = "CardMatrixRows"
    static let columns = "CardMatrixColumns"
    static let hazyStripy = "HazyStripy"
}</pre>

<p class="author1">That code means that I can now refer to a UserDefaults key with a name, such as <code class="calibre19">Default.hazyStripy</code>.<a data-type="indexterm" data-startref="idxstructs" id="calibre_link-2120" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Classes" class="calibre2"><div class="preface" id="calibre_link-2474">
<h1 class="calibre18">Classes</h1>

<p class="author1">A <em class="calibre11">class</em> is similar to a struct, with the following key differences:<a data-type="indexterm" data-primary="classes" data-seealso="object types" id="calibre_link-371" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Reference type</dt>
<dd class="calibre16">
<p class="calibre17">Classes are reference types. This means, among other things, that a class instance has two remarkable features that are not true of struct or enum instances:<a data-type="indexterm" data-primary="classes" data-secondary="vs. structs" id="calibre_link-401" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="vs. classes" id="calibre_link-2132" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Mutability</dt>
<dd class="calibre16">
<p class="calibre17">A class instance is mutable in place. Even if your reference to an instance of a class is a constant (<code class="calibre19">let</code>), you can change the value of an instance property through that reference. An instance method of a class never has to be marked <code class="calibre19">mutating</code> (and cannot be).</p>
</dd>
<dt class="calibre15">Multiple references</dt>
<dd class="calibre16">
<p class="calibre17">When a given instance of a class is assigned to multiple variables or passed as argument to a function, you get multiple references to <em class="calibre11">one and the same object</em>.</p>
</dd>
</dl>
</dd>
<dt class="calibre15">Inheritance</dt>
<dd class="calibre16">
<p class="calibre17">A class can have a superclass. A class that has a superclass is a <em class="calibre11">subclass</em> of that superclass, and inherits its superclassâ€™s members. Class types can thus form a hierarchical tree.</p>
</dd>
</dl>

<p class="author1">In Objective-C, classes are the only object type. Some built-in Swift struct types are magically bridged to Objective-C class types, but your custom struct types donâ€™t have that magic. Thus, when programming iOS with Swift, one reason for declaring a class, rather than a struct, is as a form of interchange with Objective-C and Cocoa.</p>








<section data-type="sect2" data-pdf-bookmark="Value Types and Reference Types" class="calibre2"><div class="preface" id="calibre_link-65">
<h2 class="calibre42">Value Types and Reference Types</h2>

<p class="author1">A major difference between enums and structs, on the one hand, and classes, on the other, is that enums and structs are <em class="calibre11">value types</em>, whereas classes are <em class="calibre11">reference types</em>. I will now explain what that means.<a data-type="indexterm" data-primary="object types" data-secondary="reference vs. value" id="calibre_link-1504" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="reference types" id="calibre_link-1863" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="value types" id="calibre_link-2309" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="reference types" id="calibre_link-392" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Class instances are mutable" class="calibre2"><div class="preface" id="calibre_link-2925">
<h3 class="calibre44">Class instances are mutable</h3>

<p class="author1">A value type is <em class="calibre11">not mutable in place</em>, even though it seems to be. For example, consider a struct. A struct is a value type:</p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number : Int
    init(_ n:Int) {
        self.number = n
    }
}</pre>

<p class="author1">Now, Swiftâ€™s syntax of assignment would lead us to believe that changing a Digitâ€™s <code class="calibre19">number</code> is possible:</p>

<pre data-type="programlisting" class="calibre28">var d = Digit(123)
d.number = 42</pre>

<p class="author1">But in reality, when you apparently mutate an instance of a value type, you are actually <em class="calibre11">replacing</em> that instance with a <em class="calibre11">different</em> instance. To see that this is true, add a setter observer:</p>

<pre data-type="programlisting" class="calibre28">var d : Digit = Digit(123) { // Digit is a struct
    didSet {
        print("d was set")
    }
}
d.number = 42 // "d was set"</pre>

<p class="author1">That explains why it is impossible to mutate a value type instance if the reference to that instance is declared with <code class="calibre19">let</code>:<a data-type="indexterm" data-primary="let" id="calibre_link-1222" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="var" id="calibre_link-2314" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d = Digit(123) // Digit is a struct
d.number = 42 // compile error</pre>

<p class="author1">Under the hood, this change would require us to <em class="calibre11">replace</em> the Digit instance pointed to by <code class="calibre19">d</code> with another Digit instance &mdash; and we canâ€™t do that, because it would mean assigning into <code class="calibre19">d</code>, which is exactly what the <code class="calibre19">let</code> declaration forbids.</p>

<p class="author1">That also explains why an instance method of a struct or enum that sets a property of the instance must be marked explicitly with the <code class="calibre19">mutating</code> keyword. Such a method can potentially replace this object with another, so the reference to the object must be <code class="calibre19">var</code>, not <code class="calibre19">let</code>.<a data-type="indexterm" data-primary="methods" data-secondary="mutating" id="calibre_link-1341" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutating methods" id="calibre_link-1370" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">But classes are <em class="calibre11">not</em> value types. They are reference types. A reference to a class instance does <em class="calibre11">not</em> have to be declared with <code class="calibre19">var</code> in order to set a <code class="calibre19">var</code> property through that reference:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String = "Fido"
}
let rover = Dog()
rover.name = "Rover" // fine</pre>

<p class="author1">In the last line of that code, the class instance pointed to by <code class="calibre19">rover</code> is being <em class="calibre11">mutated in place</em>. No implicit assignment to <code class="calibre19">rover</code> is involved, and so the <code class="calibre19">let</code> declaration is powerless to prevent the mutation. A setter observer on a Dog variable is <em class="calibre11">not</em> called when a property is set:<a data-type="indexterm" data-primary="instances" data-secondary="mutating" id="calibre_link-1130" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutating an instance" id="calibre_link-1367" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="instances" data-tertiary="mutating" id="calibre_link-384" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var rover : Dog = Dog() { // Dog is a class
    didSet {
        print("did set rover")
    }
}
rover.name = "Rover" // nothing in console</pre>

<p class="author1">The setter observer would be called if we were to set <code class="calibre19">rover</code> explicitly (to another Dog instance), but it is not called merely because we change a property of the Dog instance already pointed to by <code class="calibre19">rover</code>.</p>

<p class="author1">Exactly the same difference between a value type and a reference type may be seen with a parameter of a function call. When we receive an instance of a value type as a parameter into a function body, the compiler will stop us in our tracks if we try to assign to its instance property. This doesnâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">func digitChanger(_ d:Digit) { // Digit is a struct
    d.number = 42 // compile error
}</pre>

<p class="author1">But this does compile:</p>

<pre data-type="programlisting" class="calibre28">func dogChanger(_ d:Dog) { // Dog is a class
    d.name = "Rover"
}</pre>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2926">
<h5 class="calibre36">Mutating Captured Self</h5>
<p class="calibre37">An <code class="calibre19">@escaping</code> closure (<a data-type="xref" href="#calibre_link-2433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œEscaping Closuresâ€</a>) is subject to restrictions with respect to its ability to capture <code class="calibre19">self</code>, if <code class="calibre19">self</code> is a value type. To demonstrate, hereâ€™s a Digit struct:</p>

<pre data-type="programlisting" class="calibre38">struct Digit {
    var number : Int
    init(_ n:Int) {
        self.number = n
    }
    mutating func changeNumberTo(_ n:Int) {
        self.number = n
    }
    mutating func callAnotherFunction() {
        otherFunction {
            self.changeNumberTo(345)
        }
    }
}</pre>

<p class="calibre37">Whether thatâ€™s legal depends on whether <code class="calibre19">otherFunction</code> declares its function parameter <code class="calibre19">@escaping</code>. If it does, the compiler will stop us:</p>

<pre data-type="programlisting" class="calibre38">func otherFunction(_ f: @escaping ()-&gt;()) { // compile error
}</pre>

<p class="calibre37">The call to <code class="calibre19">self.changeNumberTo(345)</code> in <code class="calibre19">callAnotherFunction</code> warrants a compile error (â€œEscaping closure captures mutating <code class="calibre19">self</code> parameterâ€), because we are threatening to mutate a persisting captured <code class="calibre19">self</code> at some later time. That would involve <em class="calibre11">replacing</em> the captured <code class="calibre19">self</code> with a different Digit &mdash; and thatâ€™s incoherent. No such problem arises
if Digit is a class, because the persistent captured <code class="calibre19">self</code> can then be mutated in place.<a data-type="indexterm" data-primary="escaping" id="calibre_link-808" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="closures" data-secondary="escaping" id="calibre_link-409" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="self" data-secondary="in escaping functions" id="calibre_link-1976" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="escaping closure captures mutating self" id="calibre_link-792" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</aside>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Class instance references are pointers" class="calibre2"><div class="preface" id="calibre_link-2927">
<h3 class="calibre44">Class instance references are pointers</h3>

<p class="author1">With a reference type, there is a concealed level of indirection between your reference to the instance and the instance itself; the reference actually holds a <em class="calibre11">pointer</em> to the instance. This means that when a class instance is assigned to a variable or passed as an argument to a function or as the result of a function, you can wind up with <em class="calibre11">multiple references to the same object</em>. That is not true of structs and enums:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">When an enum instance or a struct instance is assigned or passed, what is assigned or passed is essentially a <em class="calibre11">new copy</em> of that instance.</p>
</li>
<li class="calibre12">
<p class="calibre17">When a class instance is assigned or passed, what is assigned or passed is a reference to the <em class="calibre11">same</em> instance.<a data-type="indexterm" data-primary="references" data-secondary="to same object" id="calibre_link-1873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="pointers" id="calibre_link-1702" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="multiple references" id="calibre_link-1128" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="instances" data-tertiary="multiple references" id="calibre_link-382" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">To prove it, Iâ€™ll assign one reference to another, and then mutate the second reference &mdash; and then Iâ€™ll examine what happened to the first reference. Letâ€™s start with the struct:</p>

<pre data-type="programlisting" class="calibre28">var d = Digit(123) // Digit is a struct
print(d.number) // 123
var d2 = d // assignment!
d2.number = 42
print(d.number) // 123</pre>

<p class="author1">In that code, we changed the <code class="calibre19">number</code> property of <code class="calibre19">d2</code>, a struct instance; but nothing happened to the <code class="calibre19">number</code> property of <code class="calibre19">d</code>. Now letâ€™s try the class:</p>

<pre data-type="programlisting" class="calibre28">var fido = Dog() // Dog is a class
print(fido.name) // Fido
var rover = fido // assignment!
rover.name = "Rover"
print(fido.name) // Rover</pre>

<p class="author1">In that code, we changed the <code class="calibre19">name</code> property of <code class="calibre19">rover</code>, a class instance &mdash; and the <code class="calibre19">name</code> property of <code class="calibre19">fido</code> was changed as well! Thatâ€™s because, after the assignment in the third line, <code class="calibre19">fido</code> and <code class="calibre19">rover</code> refer to <em class="calibre11">one and the same instance</em>.
<a data-type="indexterm" data-primary="instances" data-secondary="copying" id="calibre_link-1117" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="copying instances" id="calibre_link-554" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The same thing is true of parameter passing. With a class instance, what is passed is a reference to the <em class="calibre11">same</em> instance:</p>

<pre data-type="programlisting" class="calibre28">func dogChanger(_ d:Dog) { // Dog is a class
    d.name = "Rover"
}
var fido = Dog()
print(fido.name) // "Fido"
dogChanger(fido)
print(fido.name) // "Rover"</pre>

<p class="author1">The change made to <code class="calibre19">d</code> inside the function <code class="calibre19">dogChanger</code> affected <em class="calibre11">our</em> Dog instance <code class="calibre19">fido</code>! You canâ€™t do that with an enum or struct instance parameter &mdash; unless itâ€™s an <code class="calibre19">inout</code> parameter &mdash; because the instance is effectively <em class="calibre11">copied</em> as it is passed. But handing a class instance to a function does <em class="calibre11">not</em> copy that instance; it is more like <em class="calibre11">lending</em> that instance to the function.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Advantages of value types vs. reference types" class="calibre2"><div class="preface" id="calibre_link-2928">
<h3 class="calibre44">Advantages of value types vs. reference types</h3>

<p class="author1">The ability to generate multiple references to the same instance is significant particularly in a world of object-based programming, where objects persist and can have properties that persist along with them. If object A and object B are both long-lived, and if they both have a Dog property where Dog is a class, and if they have each been handed a reference to one and the same Dog instance, then either object A or object B can mutate its Dog, and this mutation will affect the otherâ€™s Dog. You can thus be holding on to an object, only to discover that it has been mutated by someone else behind your back. If that happens unexpectedly, it can put your program into an invalid state.</p>

<p class="author1">Class instances are also more complicated behind the scenes. Swift has to manage their memory (as Iâ€™ll explain in detail in <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>), precisely because there can be multiple references to the same object; this management can involve quite a bit of overhead.</p>

<p class="author1">On the whole, therefore, you should prefer a value type (such as a struct) to a reference type (a class) wherever possible. Struct instances are not shared between references, and so you are relieved from any worry about such an instance being mutated behind your back; moreover, under the hood, storage and memory management are far simpler as well. Apple likes to say that value types are <em class="calibre11">easier to reason about</em>. The Swift language itself will help you by imposing value types in front of many Cocoa Foundation reference types. For example, Objective-C NSDate and NSData are classes, but Swift will steer you toward using struct types Date and Data instead. (Iâ€™ll talk about these types in detail in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>.)</p>

<p class="author1">But donâ€™t get the wrong idea. Classes are not bad; theyâ€™re good! For one thing, a class instance is very efficient to pass around, because all youâ€™re passing is a pointer. No matter how big and complicated a class instance may be, no matter how many properties it may have containing vast amounts of data, passing the instance is incredibly fast and efficient.</p>

<p class="author1">And although a class may be a reference type, a <em class="calibre11">particular</em> class can be implemented in such a way as to exhibit value <em class="calibre11">semantics</em>. Simply put, a classâ€™s API can refuse to mutate that class in place. Cocoa NSString, NSArray, NSDictionary, NSDate, NSIndexSet, NSParagraphStyle, and many more behave like this; they are <em class="calibre11">immutable</em> by design. Two objects may hold a reference to the same NSArray without fear that it will be mutated behind their backs, not because itâ€™s a value type (it isnâ€™t) but because itâ€™s immutable. In effect, this architecture combines the ease of use of a value type with the pointer efficiency of a reference type.</p>

<p class="author1">Moreover, there are many situations where the independent identity of a class instance, no matter how many times it is referred to, is exactly what you want. The extended lifetime of a class instance, as it is passed around, can be crucial to its functionality and integrity. In particular, only a class instance can successfully represent an <em class="calibre11">independent reality</em>. For example, a UIView needs to be a class, not a struct, because an individual UIView instance, no matter how it gets passed around, must continue to represent the same single real and persistent view in your running appâ€™s interface.</p>

<p class="author1">Still another reason for preferring a class over a struct or enum is when you need recursive references. A value type cannot be structurally recursive: a stored instance property of a value type cannot be an instance of the same type. This code wonâ€™t <span class="publishername">compile:</span><a data-type="indexterm" data-primary="recursive references" id="calibre_link-1858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="recursive" id="calibre_link-1868" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Dog { // compile error
    var puppy : Dog?
}</pre>

<p class="author1">More complex circular chains, such as a Dog with a Puppy property and a Puppy with a Dog property, are similarly illegal. But if Dog is a class instead of a struct, thereâ€™s no error. This is a consequence of the nature of memory management of value types as opposed to reference types.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">An enum caseâ€™s associated value <em class="calibre11">can</em> be an instance of that enum, provided the case (or the entire enum) is marked <code class="calibre19">indirect</code>:<a data-type="indexterm" data-primary="indirect" id="calibre_link-1058" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="indirect" id="calibre_link-760" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">enum Node {
    case none(Int)
    indirect case left(Int, Node)
    indirect case right(Int, Node)
    indirect case both(Int, Node, Node)
}</pre>
</div>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Subclass and Superclass" class="calibre2"><div class="preface" id="calibre_link-2475">
<h2 class="calibre42">Subclass and Superclass</h2>

<p class="author1">Two classes can be <em class="calibre11">subclass</em> and <em class="calibre11">superclass</em> of one another. For example, we might have a class Quadruped and a class Dog, with Quadruped as the superclass of Dog. A class may have many subclasses, but a class can have only one immediate superclass. I say â€œimmediateâ€ because that superclass might itself have a superclass, and so on until we get to the ultimate superclass, called the <em class="calibre11">base class</em>, or <em class="calibre11">root class</em>.<a data-type="indexterm" data-primary="subclass" id="calibre_link-2134" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="superclass" id="calibre_link-2163" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="base class" id="calibre_link-245" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="root class" id="calibre_link-1939" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Thus there is a hierarchical tree of subclasses, each group of subclasses branching from its superclass, and so on, with a single class, the base class, at the top.<a data-type="indexterm" data-primary="classes" data-secondary="subclass and superclass" id="calibre_link-395" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">As far as the Swift language itself is concerned, there is no requirement that a class should have any superclass, or, if it does have a superclass, that it should ultimately be descended from any particular base class. Thus, a Swift program can have many classes that have no superclass, and it can have many independent hierarchical subclass trees, each descended from a different base class.</p>

<p class="author1">Cocoa, however, doesnâ€™t work that way. In Cocoa, there is effectively just one base class &mdash; NSObject<a data-type="indexterm" data-primary="NSObject" id="calibre_link-1457" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, which embodies all the functionality necessary for a class to <em class="calibre11">be</em> a class in the first place &mdash; and all other classes are subclasses, at some level, of that one base class. Cocoa thus consists of one huge tree of hierarchically arranged classes, even before you write a single line of code or create any classes of your own.<a data-type="indexterm" data-primary="classes" data-secondary="hierarchy" id="calibre_link-378" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hierarchy of classes" id="calibre_link-1019" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">We can imagine diagramming this tree as an outline. And in fact Xcode will <em class="calibre11">show</em> you this outline (<a data-type="xref" href="#calibre_link-2834" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;4-1</a>): in an iOS project window, choose View â†’ Navigators â†’ Show Symbol Navigator and click Hierarchical, with the first and third icons in the filter bar selected (blue). Now locate NSObject in the list; the Cocoa classes are the part of the tree descending from it.</p>

<figure class="calibre32"><div id="calibre_link-2834" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 4-1. </span>Part of the Cocoa class hierarchy as shown in Xcode</h6>
</div>
</figure>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">A class declaration can <em class="calibre11">prevent</em> the class from being subclassed by preceding the class declaration with the <code class="calibre19">final</code> keyword.<a data-type="indexterm" data-primary="final" id="calibre_link-857" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="subclassing, preventing" id="calibre_link-396" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subclassing" data-secondary="preventing" id="calibre_link-2137" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>










<section data-type="sect3" data-pdf-bookmark="Inheritance" class="calibre2"><div class="preface" id="calibre_link-2929">
<h3 class="calibre44">Inheritance</h3>

<p class="author1">The reason for having a superclass&ndash;subclass relationship in the first place is to allow related classes to <em class="calibre11">share functionality</em>. Suppose, for example, we have a Dog class and a Cat class, and we are considering declaring a <code class="calibre19">walk</code> method for both of them. We might reason that both a dog and a cat walk in pretty much the same way, by virtue of both being quadrupeds. So it might make sense to declare <code class="calibre19">walk</code> as a method of the Quadruped class, and make both Dog and Cat subclasses of Quadruped. When we do that, both Dog and Cat can be sent the <code class="calibre19">walk</code> message, even if neither of them has a <code class="calibre19">walk</code> method, because each of them has a superclass that <em class="calibre11">does</em> have a <code class="calibre19">walk</code> method. We say that a subclass <em class="calibre11">inherits</em> the methods of its superclass.<a data-type="indexterm" data-primary="inheritance" id="calibre_link-1065" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="inheritance" id="calibre_link-379" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="inheritance" id="calibre_link-1335" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To declare that a certain class is a subclass of a certain superclass, add a colon and the superclass name after the classâ€™s name in its declaration:<a data-type="indexterm" data-primary="colon" data-secondary="superclass" id="calibre_link-466" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Quadruped {
    func walk () {
        print("walk walk walk")
    }
}
class Dog : Quadruped {}
class Cat : Quadruped {}</pre>

<p class="author1">Now letâ€™s prove that Dog has indeed inherited <code class="calibre19">walk</code> from Quadruped:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.walk() // walk walk walk</pre>

<p class="author1">Observe that, in that code, the <code class="calibre19">walk</code> message can be sent to a Dog instance just as if the <code class="calibre19">walk</code> instance method were declared in the Dog class, even though the <code class="calibre19">walk</code> instance method is in fact declared in a superclass of Dog. Thatâ€™s inheritance at work.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Additional functionality" class="calibre2"><div class="preface" id="calibre_link-2930">
<h3 class="calibre44">Additional functionality</h3>

<p class="author1">The purpose of subclassing is not <em class="calibre11">merely</em> so that a class can inherit another classâ€™s methods; itâ€™s so that it can also declare methods <em class="calibre11">of its own</em>. Typically, a subclass consists of the methods inherited from its superclass <em class="calibre11">and then some</em>.
For example, dogs can bark, but quadrupeds in general canâ€™t. If we declare <code class="calibre19">bark</code> in the Dog class, and <code class="calibre19">walk</code> in the Quadruped class, and make Dog a subclass of Quadruped, then Dog inherits the ability to walk from the Quadruped class <em class="calibre11">and also</em> knows how to bark:</p>

<pre data-type="programlisting" class="calibre28">class Quadruped {
    func walk () {
        print("walk walk walk")
    }
}
class Dog : Quadruped {
    func bark () {
        print("woof")
    }
}</pre>

<p class="author1">Again, letâ€™s prove that it works:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.walk() // walk walk walk
fido.bark() // woof</pre>

<p class="author1">Within a class, it is a matter of indifference whether that class has an instance method because that method is declared in that class or because the method is declared in a superclass and inherited. A message to <code class="calibre19">self</code> works equally well either way. In this code, we have declared a <code class="calibre19">barkAndWalk</code> instance method that sends two messages to <code class="calibre19">self</code>, without regard to where the corresponding methods are declared (one is native to the subclass, one is inherited from the superclass):</p>

<pre data-type="programlisting" class="calibre28">class Quadruped {
    func walk () {
        print("walk walk walk")
    }
}
class Dog : Quadruped {
    func bark () {
        print("woof")
    }
    func barkAndWalk() {
        self.bark()
        self.walk()
    }
}</pre>

<p class="author1">And hereâ€™s proof that it works:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.barkAndWalk() // woof walk walk walk</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Overriding" class="calibre2"><div class="preface" id="calibre_link-2931">
<h3 class="calibre44">Overriding</h3>

<p class="author1">It is also permitted for a subclass to <em class="calibre11">redefine</em> a method inherited from its superclass. For example, perhaps some dogs bark differently from other dogs. We might have a class NoisyDog, for instance, that is a subclass of Dog. Dog declares <code class="calibre19">bark</code>, but NoisyDog also declares <code class="calibre19">bark</code>, and defines it differently from how Dog defines it. This is called <em class="calibre11">overriding</em>. The very natural rule is that if a subclass overrides a method inherited from its superclass, then when the corresponding message is sent to an instance of that subclass, it is the subclassâ€™s version of that method that is called.<a data-type="indexterm" data-primary="overriding" id="calibre_link-1650" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="overriding" id="calibre_link-1346" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="methods, overriding" id="calibre_link-385" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In Swift, when you override something inherited from a superclass, you must explicitly acknowledge this fact by preceding its declaration with the keyword <code class="calibre19">override</code>:</p>

<pre data-type="programlisting" class="calibre28">class Quadruped {
    func walk () {
        print("walk walk walk")
    }
}
class Dog : Quadruped {
    func bark () {
        print("woof")
    }
}
class NoisyDog : Dog {
    override func bark () {
        print("woof woof woof")
    }
}</pre>

<p class="author1">And letâ€™s try it:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.bark() // woof
let rover = NoisyDog()
rover.bark() // woof woof woof</pre>

<p class="author1">Observe that a subclass method by the same <em class="calibre11">name</em> as a superclassâ€™s method is not necessarily, of itself, an override. Recall that Swift can distinguish two functions with the same name, provided they have different <em class="calibre11">signatures</em>. Those are different functions, and so an implementation of one in a subclass is not an override of the other in a superclass. An override situation exists only when the subclass redefines the <em class="calibre11">same</em> method that it inherits from a superclass &mdash; using the same name, including the external parameter names, and the same signature.</p>

<p class="author1">However, a method override need not have <em class="calibre11">exactly</em> the same signature as the overridden method. In particular, in a method override, the type of a <em class="calibre11">parameter</em> may be replaced with a superclass, or with an Optional wrapping the superclass. For example, if we have a Cat class and its Kitten subclass, the following is legal:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func barkAt(cat:Kitten) {}
}
class NoisyDog : Dog {
    override func barkAt(cat:Cat) {}
    // or barkAt(cat:Cat?)
}</pre>

<p class="author1">Moreover, a parameter may be overridden with an Optional wrapping its own type, and an Optional parameter may be overridden with an Optional wrapping its wrapped typeâ€™s superclass:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func barkAt(cat:Cat) {}
    // or barkAt(cat:Kitten)
    // or barkAt(cat:Kitten?)
}
class NoisyDog : Dog {
    override func barkAt(cat:Cat?) {}
}</pre>

<p class="author1">There are further rules along the same lines, but I wonâ€™t try to list them all here; you probably wonâ€™t need to take advantage of them, and in any case the compiler will tell you if your override is illegal.</p>

<p class="author1">Along with methods, a subclass also inherits its superclassâ€™s properties. Naturally, the subclass may also declare additional properties of its own. It is possible to override an inherited property (with some restrictions that Iâ€™ll talk about later).</p>

<p class="author1">Iâ€™ll have more to say about the implications of overriding when I talk about polymorphism, later in this chapter.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">A class declaration can <em class="calibre11">prevent</em> a class member from being overridden by a subclass by preceding the memberâ€™s declaration with the <code class="calibre19">final</code> keyword.<a data-type="indexterm" data-primary="final" id="calibre_link-858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="overriding" data-tertiary="preventing" id="calibre_link-1349" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="overriding" data-secondary="preventing" id="calibre_link-1654" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="methods, overriding" data-tertiary="preventing" id="calibre_link-387" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="The keyword super" class="calibre2"><div class="preface" id="calibre_link-2932">
<h3 class="calibre44">The keyword super</h3>

<p class="author1">It often happens that we want to override something in a subclass and yet access the thing overridden in the superclass. This is done by sending a message to the keyword <code class="calibre19">super</code>. Our <code class="calibre19">bark</code> implementation in NoisyDog is a case in point. What NoisyDog really does when it barks is the same thing Dog does when <em class="calibre11">it</em> barks, but more times. Weâ€™d like to express that relationship in our implementation of NoisyDogâ€™s <code class="calibre19">bark</code>. To do so, we have NoisyDogâ€™s <code class="calibre19">bark</code> implementation send the <code class="calibre19">bark</code> message, not to <code class="calibre19">self</code> (which would be circular), but to <code class="calibre19">super</code>; this causes the search for a <code class="calibre19">bark</code> instance method implementation to start in the superclass rather than in our own class:<a data-type="indexterm" data-primary="super" id="calibre_link-2161" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog : Quadruped {
    func bark () {
        print("woof")
    }
}
class NoisyDog : Dog {
    override func bark () {
        for _ in 1...3 {
            super.bark()
        }
    }
}</pre>

<p class="author1">And it works:</p>

<pre data-type="programlisting" class="calibre28">let fido = Dog()
fido.bark() // woof
let rover = NoisyDog()
rover.bark() // woof woof woof</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">A subscript function is a method. If a superclass declares a subscript, the subclass can declare a subscript with the same signature, provided it designates it with the <code class="calibre19">override</code> keyword. To call the superclass subscript implementation, the subclass can use square brackets after the keyword <code class="calibre19">super</code> (e.g. <code class="calibre19">super[3]</code>).<a data-type="indexterm" data-primary="classes" data-secondary="subscripts, overriding" id="calibre_link-398" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subscripts" data-secondary="overriding" id="calibre_link-2154" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subscripts" data-secondary="classes" id="calibre_link-2152" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Class Initializers" class="calibre2"><div class="preface" id="calibre_link-2476">
<h2 class="calibre42">Class Initializers</h2>

<p class="author1">Initialization of a class instance is considerably more complicated than initialization of a struct or enum instance, because of class inheritance. The chief task of an initializer is to ensure that all properties have an initial value, thus making the instance well-formed as it comes into existence; and an initializer may have other tasks to perform that are essential to the initial state and integrity of this instance. A class, however, may have a superclass, which may have properties and initializers of its own. Thus we must somehow ensure that when a subclass is initialized, its <em class="calibre11">superclassâ€™s</em> properties are initialized and the tasks of <em class="calibre11">its</em> initializers are performed in good order, in addition to those of the subclass itself.<a data-type="indexterm" data-primary="initializers" data-secondary="class" id="calibre_link-1084" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="initializers" id="calibre_link-380" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="initialization" data-tertiary="classes" id="calibre_link-1756" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swift solves this problem coherently and reliably &mdash; and ingeniously &mdash; by enforcing some clear and well-defined rules about what a class initializer must do.</p>










<section data-type="sect3" data-pdf-bookmark="Kinds of class initializer" class="calibre2"><div class="preface" id="calibre_link-2933">
<h3 class="calibre44">Kinds of class initializer</h3>

<p class="author1">The rules begin with a distinction between the kinds of initializer that a class can have:</p>
<dl class="calibre14">
<dt class="calibre15">Designated initializer</dt>
<dd class="calibre16">
<p class="calibre17">A class initializer, by default, is a <em class="calibre11">designated</em> initializer.<a data-type="indexterm" data-primary="designated initializers" id="calibre_link-651" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="designated" id="calibre_link-1087" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> A class with any stored properties that are <em class="calibre11">not</em> initialized as part of their declaration <em class="calibre11">must</em> have at least one designated initializer. A designated initializer must see to it that all stored properties are initialized. A class can be instantiated <em class="calibre11">only</em> through a call to one of its designated initializers. A designated initializer may <em class="calibre11">not</em> delegate to another initializer in the same class; it is <em class="calibre11">illegal</em> for a designated initializer to use the phrase <code class="calibre19">self.init(...)</code>.</p>

<p class="calibre17">A class with no stored properties, or with stored properties all of which are initialized as part of their declaration, and that has <em class="calibre11">no explicit designated initializers</em>, has an <em class="calibre11"><span class="publishername">implicit</span></em> designated initializer <code class="calibre19">init()</code>.<a data-type="indexterm" data-primary="initializers" data-secondary="implicit" data-tertiary="class" id="calibre_link-1092" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="implicit initializer" id="calibre_link-1044" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Convenience initializer</dt>
<dd class="calibre16">
<p class="calibre17">A <em class="calibre11">convenience</em> initializer is marked with the keyword <code class="calibre19">convenience</code>.<a data-type="indexterm" data-primary="convenience initializers" id="calibre_link-551" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="initializers" data-secondary="convenience" id="calibre_link-1085" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> A convenience initializer is not how a class is instantiated; it is merely a faÃ§ade for a designated initializer. A convenience initializer is a delegating initializer; it <em class="calibre11">must</em> contain the phrase <code class="calibre19">self.init(...)</code>, which must call a <em class="calibre11">designated</em> initializer in the same class &mdash; or, if it calls another convenience initializer in the same class, the chain of convenience initializers must end by calling a designated initializer in the same class.</p>
</dd>
</dl>

<p class="author1">Here are some examples. This class has no stored properties, so it has an implicit <code class="calibre19">init()</code> designated initializer:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
}
let d = Dog()</pre>

<p class="author1">This classâ€™s stored properties have default values, so it has an implicit <code class="calibre19">init()</code> designated initializer too:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = "Fido"
}
let d = Dog()</pre>

<p class="author1">This classâ€™s stored properties have default values, but it has no implicit <code class="calibre19">init()</code> initializer because it has an explicit designated initializer:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = "Fido"
    init(name:String) {self.name = name}
}
let d = Dog(name:"Rover") // ok
let d2 = Dog() // compile error</pre>

<p class="author1">This classâ€™s stored properties have default values, and it has an explicit initializer, but it also has an implicit <code class="calibre19">init()</code> initializer because its explicit initializer is a convenience initializer. Moreover, the implicit <code class="calibre19">init()</code> initializer is a designated initializer, so the convenience initializer can delegate to it:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = "Fido"
    convenience init(name:String) {
        self.init()
        self.name = name
    }
}
let d = Dog(name:"Rover")
let d2 = Dog()</pre>

<p class="author1">This class has stored properties without default values; it has an explicit designated initializer, and all of those properties are initialized in that designated initializer:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
}
let d = Dog(name:"Rover", license:42)</pre>

<p class="author1">This class is similar to the previous example, but it also has convenience initializers forming a chain that ends with a designated initializer:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
        self.init(name:"Fido", license:license)
    }
    convenience init() {
        self.init(license:1)
    }
}
let d = Dog()</pre>

<p class="author1">Note that the rules about what else an initializer can say and when it can say it, as I described them earlier in this chapter, are still in force:<a data-type="indexterm" data-primary="self" data-secondary="in initializers" id="calibre_link-1978" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A designated initializer cannot, except in order to initialize a property (or to fetch the value of a property that is already initialized), say <code class="calibre19">self</code>, implicitly or explicitly, until <em class="calibre11">all</em> of this classâ€™s properties have been initialized.</p>
</li>
<li class="calibre12">
<p class="calibre17">A convenience initializer is a delegating initializer, so it cannot say <code class="calibre19">self</code> for <em class="calibre11">any</em> purpose until after it has called, directly or indirectly, a designated initializer (and cannot set a constant property at all).</p>
</li>
</ul>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Subclass initializers" class="calibre2"><div class="preface" id="calibre_link-2934">
<h3 class="calibre44">Subclass initializers</h3>

<p class="author1">Having defined and distinguished between designated initializers and convenience initializers, we are ready for the rules about a subclassâ€™s initializers:<a data-type="indexterm" data-primary="initializers" data-secondary="inheritance" id="calibre_link-1095" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">No declared initializers</dt>
<dd class="calibre16">
<p class="calibre17">If a subclass doesnâ€™t have to have any initializers of its own, and if it declares no initializers of its own, then its initializers consist of the initializers inherited from its superclass. (A subclass thus has no implicit <code class="calibre19">init()</code> initializer unless it inherits it from its superclass.)</p>
</dd>
<dt class="calibre15">Convenience initializers only</dt>
<dd class="calibre16">
<p class="calibre17">If a subclass doesnâ€™t have to have any initializers of its own, it is eligible to declare convenience initializers, and these work exactly as convenience initializers always do, because inheritance supplies the designated initializers that the convenience initializers must call by saying <code class="calibre19">self.init(...)</code>.</p>
</dd>
<dt class="calibre15">Designated initializers</dt>
<dd class="calibre16">
<p class="calibre17">If a subclass declares any designated initializers of its own, the entire game changes drastically. Now, <em class="calibre11">no initializers are inherited!</em> The existence of an explicit designated initializer <em class="calibre11">blocks initializer inheritance</em>. The only initializers the subclass now has are the initializers that you explicitly write (with one exception that Iâ€™ll mention later). This rule may seem surprising, but Iâ€™ll justify it in an example later on.<a data-type="indexterm" data-primary="designated initializers" id="calibre_link-652" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="initializers" data-tertiary="inheritance" id="calibre_link-381" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">Moreover, every designated initializer in the subclass now has an extra requirement: it must call one of the <em class="calibre11">superclassâ€™s designated initializers</em>, by saying <code class="calibre19">super.init(...)</code>. If it fails to do this, then <code class="calibre19">super.init()</code> is called implicitly if possible, but I disapprove of this feature (in my view, Swift should not indulge in secret behavior, even if that behavior might be considered â€œhelpfulâ€).</p>

<p class="calibre17">At the same time, the rules about saying <code class="calibre19">self</code> continue to apply.</p>

<p class="calibre17">Thus, a subclass designated initializer must do these things <em class="calibre11">in this order:</em><a data-type="indexterm" data-primary="init" data-secondary="with super" id="calibre_link-1068" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="super" data-secondary="in initializers" id="calibre_link-2162" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">It must ensure that all properties of <em class="calibre11">this</em> class (the subclass) are initialized.</p>
</li>
<li class="calibre4">
<p class="calibre17">It must call <code class="calibre19">super.init(...)</code>, and the initializer that it calls must be a designated initializer.</p>
</li>
<li class="calibre4">
<p class="calibre17">Only then may this initializer say <code class="calibre19">self</code> for such purposes as to call an instance method or to access an inherited property.</p>
</li>

</ol>
</dd>
<dt class="calibre15">Designated and convenience initializers</dt>
<dd class="calibre16">
<p class="calibre17">If a subclass declares both designated and convenience initializers, the convenience initializers in the subclass are still subject to the rules Iâ€™ve already outlined. They must call <code class="calibre19">self.init(...)</code>, calling a designated initializer directly or through a chain of convenience initializers. There are no inherited initializers, so the designated initializer must be explicitly declared in the <span class="publishername">subclass.</span></p>
</dd>
<dt class="calibre15">Override initializers</dt>
<dd class="calibre16">
<p class="calibre17">A subclass may override initializers from its superclass, in accordance with these restrictions:<a data-type="indexterm" data-primary="initializers" data-secondary="overriding" id="calibre_link-1097" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="overriding" data-secondary="initializers" id="calibre_link-1652" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div class="preface">
<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">An initializer whose parameters match a <em class="calibre11">convenience</em> initializer of the superclass can be a designated initializer or a convenience initializer, and is <em class="calibre11">not</em> marked <code class="calibre19">override</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">An initializer whose parameters match a <em class="calibre11">designated</em> initializer of the superclass can be a designated initializer or a convenience initializer, and <em class="calibre11">must</em> be marked <code class="calibre19">override</code>. An <code class="calibre19">override</code> designated initializer must still call some superclass designated initializer (possibly even the one that it overrides) with <code class="calibre19">super.init(...)</code>.</p>
</li>
</ul>
</div>


<p class="calibre17">If a subclass overrides <em class="calibre11">all</em> of its superclassâ€™s <em class="calibre11">designated</em> initializers, then the subclass inherits the superclassâ€™s <em class="calibre11">convenience</em> initializers. (This is the exception to the rule that if a subclass has any designated initializers, no initializers are inherited.)</p>
</dd>
<dt class="calibre15">Failable initializers</dt>
<dd class="calibre16">
<p class="calibre17">If an initializer called by a failable initializer is failable, the calling syntax does not change, and no additional test is needed &mdash; if a failable initializer fails, the whole initialization process will fail (and will be aborted) immediately.<a data-type="indexterm" data-primary="initializers" data-secondary="failable" id="calibre_link-1090" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="failable initializers" id="calibre_link-845" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">There are some additional restrictions on failable initializers:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><code class="calibre19">init</code> can override <code class="calibre19">init?</code>, but not <em class="calibre11">vice versa</em>.</p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">init?</code> can call <code class="calibre19">init</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">init</code> can call <code class="calibre19">init?</code> by saying <code class="calibre19">init</code> and unwrapping the result with an exclamation mark (and if the <code class="calibre19">init?</code> fails, youâ€™ll crash).</p>
</li>
</ul>
</dd>
</dl>

<p class="author1">At no time can a subclass initializer set a constant (<code class="calibre19">let</code>) property of a superclass. This is because, by the time the subclass is allowed to do anything other than initialize its own properties and call another initializer, the superclass has finished its own initialization and the door for initializing its constants has closed.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Subclass initializer examples" class="calibre2"><div class="preface" id="calibre_link-2935">
<h3 class="calibre44">Subclass initializer examples</h3>

<p class="author1">Your eyes may glaze over reading the subclass initializer rules, but the most important rules are very easy to understand with the help of some basic examples. We start with a subclass that has no explicit initializers of its own:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
        self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
}</pre>

<p class="author1">Given that code, you can make a NoisyDog like this:</p>

<pre data-type="programlisting" class="calibre28">let nd1 = NoisyDog(name:"Fido", license:1)
let nd2 = NoisyDog(license:2)</pre>

<p class="author1">That code is legal, because NoisyDog inherits its superclassâ€™s initializers. However, you canâ€™t make a NoisyDog like this:</p>

<pre data-type="programlisting" class="calibre28">let nd3 = NoisyDog() // compile error</pre>

<p class="author1">That code is illegal. Even though a NoisyDog has no properties of its own, it has no implicit <code class="calibre19">init()</code> initializer; its initializers are its inherited initializers, and its superclass, Dog, has no implicit <code class="calibre19">init()</code> initializer to inherit.</p>

<p class="author1">Now here is a subclass whose only explicit initializer is a convenience initializer:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
        self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
    convenience init(name:String) {
        self.init(name:name, license:1)
    }
}</pre>

<p class="author1">Observe how NoisyDogâ€™s convenience initializer fulfills its contract by calling <code class="calibre19">self.init(...)</code> to call a designated initializer &mdash; which it happens to have inherited. Given that code, there are three ways to make a NoisyDog, just as you would expect:</p>

<pre data-type="programlisting" class="calibre28">let nd1 = NoisyDog(name:"Fido", license:1)
let nd2 = NoisyDog(license:2)
let nd3 = NoisyDog(name:"Rover")</pre>

<p class="author1">Next, here is a subclass that declares a designated initializer:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
        self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
    init(name:String) {
        super.init(name:name, license:1)
    }
}</pre>

<p class="author1">NoisyDogâ€™s explicit initializer is now a designated initializer. It fulfills its contract by calling a designated initializer in <code class="calibre19">super</code>. NoisyDog has now <em class="calibre11">cut off inheritance</em> of all initializers; the <em class="calibre11">only</em> way to make a NoisyDog is like this:</p>

<pre data-type="programlisting" class="calibre28">let nd1 = NoisyDog(name:"Rover")</pre>

<p class="author1">Earlier, I promised to justify the rule that adding a designated initializer to a subclass cuts off initializer inheritance. That example is a case in point. It would be terrible if the caller could bypass NoisyDogâ€™s designated initializer by using an inherited Dog initializer instead. NoisyDogâ€™s initializer enforces a rule that a NoisyDog can only have a <code class="calibre19">license</code> value of <code class="calibre19">1</code>; if you could say <code class="calibre19">NoisyDog(license:2)</code>, youâ€™d bypass that rule. Hereâ€™s another example that makes the same point a little more realistically:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    let name : String
    init(name:String) {
        self.name = name
    }
}
class RoverDog : Dog {
    init() {
        super.init(name:"Rover")
    }
}
let fido = RoverDog(name:"Fido") // compile error</pre>

<p class="author1">Clearly that last line <em class="calibre11">needs</em> to be an error; otherwise, a RoverDog could be named Fido, undermining the point of the subclass.</p>

<p class="author1">Finally, here is a subclass that overrides its designated initializers:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    convenience init(license:Int) {
        self.init(name:"Fido", license:license)
    }
}
class NoisyDog : Dog {
    override init(name:String, license:Int) {
        super.init(name:name, license:license)
    }
}</pre>

<p class="author1">NoisyDog has overridden <em class="calibre11">all</em> of its superclassâ€™s designated initializers, so it inherits its superclassâ€™s convenience initializers. There are thus two ways to make a NoisyDog:</p>

<pre data-type="programlisting" class="calibre28">let nd1 = NoisyDog(name:"Rover", license:1)
let nd2 = NoisyDog(license:2)</pre>

<p class="author1">Those examples illustrate the main rules that you should keep in your head. You probably donâ€™t need to memorize the remaining rules, because the compiler will enforce them, and will keep slapping you down until you get them right.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Required initializers" class="calibre2"><div class="preface" id="calibre_link-2936">
<h3 class="calibre44">Required initializers</h3>

<p class="author1">Thereâ€™s one more thing to know about class initializers: a class initializer may be preceded by the keyword <code class="calibre19">required</code>. This means that a subclass may not lack this initializer. This, in turn, means that if a subclass implements designated initializers, thus blocking inheritance, it <em class="calibre11">must</em> override this initializer and mark the override <code class="calibre19">required</code>. Hereâ€™s a (rather pointless) example:<a data-type="indexterm" data-primary="initializers" data-secondary="required" id="calibre_link-1099" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="required initializers" id="calibre_link-1902" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    required init(name:String) {
        self.name = name
    }
}
class NoisyDog : Dog {
    var obedient = false
    init(obedient:Bool) {
        self.obedient = obedient
        super.init(name:"Fido")
    }
} // compile error</pre>

<p class="author1">That code wonâ€™t compile. Dogâ€™s <code class="calibre19">init(name:)</code> is marked <code class="calibre19">required</code>; thus, our code wonâ€™t compile unless we inherit or override <code class="calibre19">init(name:)</code> in NoisyDog. But we cannot inherit it, because, by implementing the NoisyDog designated initializer <code class="calibre19">init(obedient:)</code>, we have blocked inheritance. Therefore we must override it:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    required init(name:String) {
        self.name = name
    }
}
class NoisyDog : Dog {
    var obedient = false
    init(obedient:Bool) {
        self.obedient = obedient
        super.init(name:"Fido")
    }
    required init(name:String) {
        super.init(name:name)
    }
}</pre>

<p class="author1">Observe that our overridden required initializer is not marked with <code class="calibre19">override</code>, but <em class="calibre11">is</em> marked with <code class="calibre19">required</code>, thus guaranteeing that the requirement continues drilling down to any further subclasses.</p>

<p class="author1">I have explained what declaring an initializer as <code class="calibre19">required</code> does, but I have not explained <em class="calibre11">why</em> youâ€™d need to do it. Thatâ€™s another matter! Iâ€™ll discuss it later in this chapter.</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Class Deinitializer" class="calibre2"><div class="preface" id="calibre_link-2477">
<h2 class="calibre42">Class Deinitializer</h2>

<p class="author1">A class can have a deinitializer. This is a function declared with the keyword <code class="calibre19">deinit</code> followed by curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-588" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> containing the function body. You never call this function yourself; it is called by the runtime when an instance of this class goes out of existence. If a class has a superclass, the subclassâ€™s deinitializer (if any) is called before the superclassâ€™s deinitializer (if any).<a data-type="indexterm" data-primary="classes" data-secondary="deinitializers" id="calibre_link-375" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="deinit" id="calibre_link-638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A deinitializer is a class feature only; a struct or enum has no deinitializer. Thatâ€™s because a class is a reference type (as I explained earlier in this chapter). The idea is that you might want to perform some cleanup. Another good use a classâ€™s <code class="calibre19">deinit</code> is to log to the console to prove to yourself that your instance is going out of existence in good order; Iâ€™ll take advantage of that when I discuss memory management issues in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Property observers are not called during <code class="calibre19">deinit</code>.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Class Properties" class="calibre2"><div class="preface" id="calibre_link-2478">
<h2 class="calibre42">Class Properties</h2>

<p class="author1">A subclass can override its inherited properties. The override must have the same name and type as the inherited property, and must be marked with <code class="calibre19">override</code>. (A property cannot have the same name as an inherited property but a different type, as there is no way to distinguish them.)</p>

<p class="author1">The chief restriction here is that an <code class="calibre19">override</code> property <em class="calibre11">cannot be a stored property</em>. More specifically:<a data-type="indexterm" data-primary="classes" data-secondary="properties, overriding" id="calibre_link-391" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="overriding" id="calibre_link-1770" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If the superclass property is writable (a stored property or a computed property with a setter), the subclassâ€™s override may consist of adding setter observers to this property.</p>
</li>
<li class="calibre12">
<p class="calibre17">Alternatively, the subclassâ€™s override may be a computed property. In that case:</p>

<ul class="calibre48">
<li class="calibre12">
<p class="pcalibre5 calibre17">If the superclass property is stored, the subclassâ€™s computed property override must have both a getter and a setter.</p>
</li>
<li class="calibre12">
<p class="pcalibre5 calibre17">If the superclass property is computed, the subclassâ€™s computed property override must have at least a getter, and:</p>

<ul class="calibre49">
<li class="calibre12">
<p class="pcalibre6 calibre17">If the superclass property has a setter, the override must have a setter.</p>
</li>
<li class="calibre12">
<p class="pcalibre6 calibre17">If the superclass property has no setter, the override can add one.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p class="author1">The overriding propertyâ€™s functions may refer to &mdash; and may read from and write to &mdash; the inherited property, through the <code class="calibre19">super</code> keyword.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Static/Class Members" class="calibre2"><div class="preface" id="calibre_link-2479">
<h2 class="calibre42">Static/Class Members</h2>

<p class="author1">A class can have static members, marked <code class="calibre19">static</code>, just like a struct or an enum. It can also have class members, marked <code class="calibre19">class</code>. Both static and class members are inherited by subclasses.</p>










<section data-type="sect3" data-pdf-bookmark="Static methods vs. class methods" class="calibre2"><div class="preface" id="calibre_link-2937">
<h3 class="calibre44">Static methods vs. class methods</h3>

<p class="author1">The chief difference between static and class <em class="calibre11">methods</em>, from the programmerâ€™s point of view, is that a static method <em class="calibre11">cannot be overridden;</em> it is as if <code class="calibre19">static</code> were a synonym for <code class="calibre19">class final</code>.<a data-type="indexterm" data-primary="classes" data-secondary="static methods" id="calibre_link-393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="class methods" id="calibre_link-373" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="static" data-tertiary="vs. class" id="calibre_link-1353" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static methods" data-secondary="vs. class methods" id="calibre_link-2070" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="class" data-secondary="methods" data-tertiary="vs. static methods" id="calibre_link-365" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Here, for example, Iâ€™ll use a static method to express what dogs say:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    static func whatDogsSay() -&gt; String {
        return "woof"
    }
    func bark() {
        print(Dog.whatDogsSay())
    }
}</pre>

<p class="author1">A subclass now inherits <code class="calibre19">whatDogsSay</code>, but canâ€™t override it. No subclass of Dog may contain any implementation of a class method or a static method <code class="calibre19">whatDogsSay</code> with this same signature.</p>

<p class="author1">Now Iâ€™ll use a class method to express what dogs say:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    class func whatDogsSay() -&gt; String {
        return "woof"
    }
    func bark() {
        print(Dog.whatDogsSay())
    }
}</pre>

<p class="author1">A subclass inherits <code class="calibre19">whatDogsSay</code>, and <em class="calibre11">can</em> override it, either as a class method or as a static method:</p>

<pre data-type="programlisting" class="calibre28">class NoisyDog : Dog {
    override class func whatDogsSay() -&gt; String {
        return "WOOF"
    }
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Static properties vs. class properties" class="calibre2"><div class="preface" id="calibre_link-2938">
<h3 class="calibre44">Static properties vs. class properties</h3>

<p class="author1">The difference between static and class <em class="calibre11">properties</em> is similar to the difference between static and class methods, but with an additional, rather dramatic qualification: a static property can be stored, but a class property <em class="calibre11">must be a computed property.</em><a data-type="indexterm" data-primary="classes" data-secondary="static properties" id="calibre_link-394" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="class properties" id="calibre_link-374" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="static" data-tertiary="vs. class" id="calibre_link-1777" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="static properties" data-secondary="vs. class properties" id="calibre_link-2075" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="class" data-secondary="properties" data-tertiary="vs. static properties" id="calibre_link-369" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Here, Iâ€™ll use a static class property to express what dogs say:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    static var whatDogsSay = "woof"
    func bark() {
        print(Dog.whatDogsSay)
    }
}</pre>

<p class="author1">A subclass inherits <code class="calibre19">whatDogsSay</code>, but canâ€™t override it; no subclass of Dog can declare a class or static property <code class="calibre19">whatDogsSay</code>.</p>

<p class="author1">Now Iâ€™ll use a class property to express what dogs say. It cannot be a stored property, so Iâ€™ll have to use a computed property instead:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    class var whatDogsSay : String {
        return "woof"
    }
    func bark() {
        print(Dog.whatDogsSay)
    }
}</pre>

<p class="author1">A subclass inherits <code class="calibre19">whatDogsSay</code> and can override it either as a class property or as a static property. But the rule about property overrides not being stored is still in force, even if the override is a static property: <a data-type="indexterm" data-startref="idxclasses" id="calibre_link-372" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxobjecttypes" id="calibre_link-1488" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class NoisyDog : Dog {
    override static var whatDogsSay : String {
        return "WOOF"
    }
}</pre>
</div>
</section>



</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Polymorphism" class="calibre2"><div class="preface" id="calibre_link-2480">
<h1 class="calibre18">Polymorphism</h1>

<p class="author1">When a computer language has a hierarchy of types and subtypes, it must resolve the question of what such a hierarchy means for the relationship between the type of an <em class="calibre11">object</em> and the declared type of a <em class="calibre11">reference</em> to that object. Swift obeys the principles of <em class="calibre11">polymorphism</em>. In my view, it is polymorphism that turns an object-based language into a full-fledged object-oriented language. We may summarize Swiftâ€™s polymorphism principles as follows:<a data-type="indexterm" data-primary="polymorphism" id="calibre_link-1708" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="substitution principle" id="calibre_link-2156" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="internal identity principle" id="calibre_link-1150" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="polymorphism" id="calibre_link-390" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Substitution</dt>
<dd class="calibre16">
<p class="calibre17">Wherever a certain type of object is expected, the actual object may be a subtype of that type.</p>
</dd>
<dt class="calibre15">Internal identity</dt>
<dd class="calibre16">
<p class="calibre17">An objectâ€™s real type is a matter of its internal nature, regardless of how that object is referred to.</p>
</dd>
</dl>

<p class="author1">To see what these principles mean in practice, imagine we have a Dog class, along with its subclass, NoisyDog:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
}
class NoisyDog : Dog {
}
let d : Dog = NoisyDog()</pre>

<p class="author1">In that code:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The substitution rule says that the last line is legal: we can assign a NoisyDog instance to a reference, <code class="calibre19">d</code>, that is typed as Dog.</p>
</li>
<li class="calibre12">
<p class="calibre17">The internal identity rule says that, under the hood, even though <code class="calibre19">d</code> is typed as Dog, the instance that it refers to is a NoisyDog.<a data-type="indexterm" data-primary="type" data-secondary="of instance vs. type of variable" id="calibre_link-2235" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="variables" data-secondary="type" data-tertiary="vs. instance type" id="calibre_link-2340" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="type" id="calibre_link-1135" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">You may be asking: How is the internal identity rule manifested? If a reference to a NoisyDog is typed as Dog, in what sense is this â€œreallyâ€ a NoisyDog? To illustrate, letâ€™s examine what happens when a subclass overrides an inherited method. Iâ€™ll redefine Dog and NoisyDog to demonstrate:<a data-type="indexterm" data-primary="overriding" data-secondary="polymorphism and" id="calibre_link-1653" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="overriding" data-tertiary="polymorphism and" id="calibre_link-1348" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        print("woof")
    }
}
class NoisyDog : Dog {
    override func bark() {
        for _ in 1...3 {
            super.bark()
        }
    }
}</pre>

<p class="author1">Now consider the following code:</p>

<pre data-type="programlisting" class="calibre28">func tellToBark(_ d:Dog) {
    d.bark()
}
var nd = NoisyDog()
tellToBark(nd) // what will happen??????</pre>

<p class="author1">That code is legal, because, by the substitution principle, we can pass <code class="calibre19">nd</code>, typed as NoisyDog, where a Dog is expected. Now, inside the <code class="calibre19">tellToBark</code> function, <code class="calibre19">d</code> is typed as Dog. How will it react to being told to <code class="calibre19">bark</code>? On the one hand, <code class="calibre19">d</code> is <em class="calibre11">typed</em> as Dog, and a Dog barks by saying <code class="calibre19">"woof"</code> once. On the other hand, in our code, when <code class="calibre19">tellToBark</code> is called, what is <em class="calibre11">really</em> passed is a NoisyDog instance, and a NoisyDog barks by saying <code class="calibre19">"woof"</code> three times. <em class="calibre11">What will happen?</em> Letâ€™s find out:</p>

<pre data-type="programlisting" class="calibre28">func tellToBark(_ d:Dog) {
    d.bark()
}
var nd = NoisyDog()
tellToBark(nd) // woof woof woof</pre>

<p class="author1">The result is <code class="calibre19">"woof woof woof"</code>. The internal identity rule says that what matters when a message is sent is not how the recipient of that message is <em class="calibre11">typed</em> through this or that <em class="calibre11">reference</em>, but what that recipient actually <em class="calibre11">is</em>. What arrives inside <code class="calibre19">tellToBark</code> is a NoisyDog, regardless of the type of variable that holds it; thus, the <code class="calibre19">bark</code> message causes this object to say <code class="calibre19">"woof"</code> three times.</p>

<p class="author1">Hereâ€™s another important consequence of polymorphism &mdash; the meaning of the keyword <code class="calibre19">self</code>. It means the actual instance, and thus its meaning depends upon the type of the actual instance &mdash; even if the word <code class="calibre19">self</code> <em class="calibre11">appears</em> in a superclassâ€™s code. For example:<a data-type="indexterm" data-primary="self" data-secondary="polymorphism" id="calibre_link-1983" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        print("woof")
    }
    func speak() {
        self.bark()
    }
}
class NoisyDog : Dog {
    override func bark() {
        for _ in 1...3 {
            super.bark()
        }
    }
}</pre>

<p class="author1">What happens when we tell a NoisyDog to <code class="calibre19">speak</code>? The <code class="calibre19">speak</code> method is declared in Dog, the superclass &mdash; not in NoisyDog. The <code class="calibre19">speak</code> method calls the <code class="calibre19">bark</code> method. It does this by way of the keyword <code class="calibre19">self</code>. (I could have omitted the explicit reference to <code class="calibre19">self</code> here, but <code class="calibre19">self</code> would still be involved implicitly, so Iâ€™m not cheating by making <code class="calibre19">self</code> explicit.) Thereâ€™s a <code class="calibre19">bark</code> method in Dog, and an override of the <code class="calibre19">bark</code> method in NoisyDog. <em class="calibre11">Which <code class="calibre22">bark</code> method will be called?</em> Letâ€™s find out:</p>

<pre data-type="programlisting" class="calibre28">let nd = NoisyDog()
nd.speak() // woof woof woof</pre>

<p class="author1">The word <code class="calibre19">self</code> is encountered within the Dog classâ€™s implementation of <code class="calibre19">speak</code>. But what matters is not <em class="calibre11">where</em> the word <code class="calibre19">self</code> appears but what it <em class="calibre11">means</em>. It means <em class="calibre11">this instance</em>. And the internal identity principle tells us that this instance is a NoisyDog! Thus, it is NoisyDogâ€™s override of <code class="calibre19">bark</code> that is called when Dogâ€™s <code class="calibre19">speak</code> says <code class="calibre19">self.bark()</code>.</p>

<p class="author1">Polymorphism applies to Optional types in the same way that it applies to the type of thing wrapped by the Optional. Suppose we have a reference typed as an Optional wrapping a Dog. You already know that you can assign a Dog to it. Well, you can also assign a NoisyDog, or an Optional wrapping a NoisyDog, and the underlying wrapped object will maintain its integrity:</p>

<pre data-type="programlisting" class="calibre28">var d : Dog?
d = Dog()
d = NoisyDog()
d = Optional(NoisyDog())</pre>

<p class="author1">(The applicability of polymorphism to Optionals derives from a special dispensation of the Swift language: Optionals are <em class="calibre11">covariant</em>. Iâ€™ll talk more about that later in this chapter.)<a data-type="indexterm" data-primary="covariant" id="calibre_link-558" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Thanks to polymorphism, you can take advantage of subclasses to add power and customization to existing classes. This is important particularly in the world of iOS programming, where most of the classes are defined by Cocoa and donâ€™t belong to you. The UIViewController class, for example, is defined by Cocoa; it has lots of built-in methods that Cocoa will call, and these methods perform various important tasks &mdash; but in a generic way. In real life, youâ€™ll make a UIViewController <em class="calibre11">subclass</em>, and youâ€™ll <em class="calibre11">override</em> those methods to do the tasks appropriate to your particular app. When you do that:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">It wonâ€™t bother Cocoa in the slightest, because (substitution principle) wherever Cocoa expects to receive or to be talking to a UIViewController, it will accept without question an instance of your UIViewController subclass.</p>
</li>
<li class="calibre12">
<p class="calibre17">The substituted UIViewController subclass will also work as expected, because (internal identity principle) whenever Cocoa calls one of those UIViewController methods on your subclass, it is your subclassâ€™s override that will be called, and wherever a UIViewController method refers to <code class="calibre19">self</code>, that will mean your subclass.</p>
</li>
</ul>

<p class="author1">Iâ€™ll talk more about subclassing Cocoa classes in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Polymorphism is cool, but in the grand scheme of things it is also relatively slow. It requires <em class="calibre11">dynamic dispatch</em>, meaning that the compiler canâ€™t perform certain optimizations, and that the runtime has to think about what a message to a class instance means. You can reduce the need for dynamic dispatch by declaring a class or a class member <code class="calibre19">final</code> or <code class="calibre19">private</code>. Or use a struct, if appropriate; structs donâ€™t need dynamic dispatch.<a data-type="indexterm" data-primary="dynamic dispatch" id="calibre_link-720" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dispatch, dynamic" id="calibre_link-682" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Casting" class="calibre2"><div class="preface" id="calibre_link-2481">
<h1 class="calibre18">Casting</h1>

<p class="author1">Hereâ€™s a conundrum. The Swift compiler, with its strict typing, imposes severe restrictions on what messages can be sent to an object reference. The messages that the compiler will permit to be sent to an object reference depend upon the referenceâ€™s <em class="calibre11">declared</em> type. But the internal identity principle of polymorphism says that, under the hood, an object may have a <em class="calibre11">real</em> type that is different from its referenceâ€™s declared type. Such an object may thus be <em class="calibre11">capable</em> of receiving certain messages, but the compiler <em class="calibre11">wonâ€™t permit us</em> to send them.<a data-type="indexterm" data-primary="instances" data-secondary="type" data-tertiary="telling compiler" id="calibre_link-1137" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="typecasting" data-see="casting" id="calibre_link-2939" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To illustrate the problem, letâ€™s give NoisyDog a method that Dog doesnâ€™t have:<a data-type="indexterm" data-primary="casting" id="calibre_link-343" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    func bark() {
        print("woof")
    }
}
class NoisyDog : Dog {
    override func bark() {
        super.bark(); super.bark()
    }
    func beQuiet() {
        self.bark()
    }
}</pre>

<p class="author1">In that code, we configure a NoisyDog so that we can tell it to <code class="calibre19">beQuiet</code>. Now look at what happens when we try to tell an object typed as Dog to be quiet:</p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    d.beQuiet() // compile error
}
let nd = NoisyDog()
tellToHush(nd)</pre>

<p class="author1">Our code doesnâ€™t compile. We canâ€™t send the <code class="calibre19">beQuiet</code> message to the reference <code class="calibre19">d</code> inside the function body, because it is typed as Dog &mdash; and a Dog has no <code class="calibre19">beQuiet</code> method. But there is a certain irony here: for once, we happen to know more than the compiler does &mdash; namely, that this object is <em class="calibre11">in fact</em> a NoisyDog and <em class="calibre11">does</em> have a <code class="calibre19">beQuiet</code> method! Our code would run correctly &mdash; because <code class="calibre19">d</code> really is a NoisyDog &mdash; if only we could get our code to compile in the first place. We need a way to say to the compiler, â€œLook, compiler, just trust me: this thing is going to turn out to be a NoisyDog when the program actually runs, so let me send it this message.â€</p>

<p class="author1">There is in fact a way to do this &mdash; <em class="calibre11">casting</em>. To cast, you use a form of the keyword <code class="calibre19">as</code> followed by the name of the type you claim something really is.</p>








<section data-type="sect2" data-pdf-bookmark="Casting Down" class="calibre2"><div class="preface" id="calibre_link-2482">
<h2 class="calibre42">Casting Down</h2>

<p class="author1">Swift will not let you cast just any old type to any old other type &mdash; for example, you canâ€™t cast a String to an Int &mdash; but it will let you cast a superclass to a subclass. This is called <em class="calibre11">casting down</em>. When you cast down, the form of the keyword <code class="calibre19">as</code> that you use is <code class="calibre19">as!</code> with an exclamation mark. The exclamation mark reminds you that you are <em class="calibre11">forcing</em> the compiler to do something it would rather not do:<a data-type="indexterm" data-primary="exclamation mark" id="calibre_link-817" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="as" id="calibre_link-210" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="downcasting" data-see="casting" id="calibre_link-2940" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    (d as! NoisyDog).beQuiet()
}
let nd = NoisyDog()
tellToHush(nd)</pre>

<p class="author1">That code compiles, and works. A useful way to rewrite the example is like this:</p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    let d = d as! NoisyDog
    d.beQuiet()
    // ... other NoisyDog messages to d can go here ...
}
let nd = NoisyDog()
tellToHush(nd)</pre>

<p class="author1">The reason that way of rewriting the code is useful is in case we have other NoisyDog messages to send to this object. Instead of casting every time we want to send a message to it, we cast the object once to its internal identity type, and assign it to a variable. Now that variableâ€™s type &mdash; inferred, in this case, from the cast &mdash; is the internal identity type, and we can send multiple messages to the variable.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Type Testing and Casting Down Safely" class="calibre2"><div class="preface" id="calibre_link-2483">
<h2 class="calibre42">Type Testing and Casting Down Safely</h2>

<p class="author1">A moment ago, I said that the <code class="calibre19">as!</code> operatorâ€™s exclamation mark reminds you that you are forcing the compilerâ€™s hand. It also serves as a warning: your code can now crash! The reason is that you might be lying to the compiler. Casting down is a way of telling the compiler to relax its strict type checking and to let you call the shots. If you use casting to make a false claim, the compiler may permit it, but you will crash when the app runs:<a data-type="indexterm" data-primary="crash" data-secondary="could not cast value" id="calibre_link-564" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    let d = d as! NoisyDog
    d.beQuiet()
    // ... other NoisyDog messages to d can go here ...
}
let nd = NoisyDog()
tellToHush(nd)</pre>

<p class="author1">In that code, we told the compiler that this object would turn out to be a NoisyDog, and the compiler obediently took its hands off and allowed us to send the <code class="calibre19">beQuiet</code> message to it. But in fact, this object was a Dog when our code ran, and so we ultimately crashed when the cast failed because this object was <em class="calibre11">not</em> a NoisyDog.</p>

<p class="author1">To prevent yourself from lying accidentally, you can <em class="calibre11">test</em> the type of an instance at runtime. One way to do this is with the keyword <code class="calibre19">is</code>. You can use <code class="calibre19">is</code> in a condition; if the condition passes, <em class="calibre11">then</em> cast, in the knowledge that your cast is safe:<a data-type="indexterm" data-primary="is" id="calibre_link-1161" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="of instance, testing" id="calibre_link-2236" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="type" data-tertiary="testing" id="calibre_link-1138" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="casting" data-secondary="safely" id="calibre_link-345" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    if d is NoisyDog {
        let d = d as! NoisyDog
        d.beQuiet()
    }
}</pre>

<p class="author1">The result is that we wonâ€™t cast <code class="calibre19">d</code> to a NoisyDog unless it really <em class="calibre11">is</em> a NoisyDog.</p>

<p class="author1">An alternative way to solve the same problem is to use Swiftâ€™s <code class="calibre19">as?</code> operator. This casts down, but with the option of failure; therefore what it casts to is (you guessed it) an Optional &mdash; and now we are on familiar ground, because we know how to deal safely with an Optional:<a data-type="indexterm" data-primary="question mark" id="calibre_link-1829" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    let d = d as? NoisyDog // an Optional wrapping a NoisyDog
    if d != nil {
        d!.beQuiet()
    }
}</pre>

<p class="author1">That doesnâ€™t look much cleaner or shorter than our previous approach. But remember that we can safely send a message to an Optional by optionally unwrapping the Optional:</p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    let d = d as? NoisyDog // an Optional wrapping a NoisyDog
    d?.beQuiet()
}</pre>

<p class="author1">Or, as a one-liner:</p>

<pre data-type="programlisting" class="calibre28">func tellToHush(_ d:Dog) {
    (d as? NoisyDog)?.beQuiet()
}</pre>

<p class="author1">First we use the <code class="calibre19">as?</code> operator to obtain an Optional wrapping a NoisyDog. Then we optionally unwrap that Optional and send a message to it. If the original <code class="calibre19">d</code> wasnâ€™t a NoisyDog, the Optional will be <code class="calibre19">nil</code> and it wonâ€™t be unwrapped and no message will be sent.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Type Testing and Casting Optionals" class="calibre2"><div class="preface" id="calibre_link-2484">
<h2 class="calibre42">Type Testing and Casting Optionals</h2>

<p class="author1">The <code class="calibre19">is</code>, <code class="calibre19">as!</code>, and <code class="calibre19">as?</code> operators work with Optionals in the same way that the equality comparison operators do (<a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>): they are automatically applied to the object wrapped by the Optional.</p>

<p class="author1">Letâ€™s start with <code class="calibre19">is</code>. Consider an Optional <code class="calibre19">d</code> ostensibly wrapping a Dog (that is, <code class="calibre19">d</code> is a <code class="calibre19">Dog?</code> object). It might, in actual fact, be wrapping either a Dog or a NoisyDog. To find out which it is, you might be tempted to use <code class="calibre19">is</code>. But can you? After all, an Optional is neither a Dog nor a NoisyDog &mdash; itâ€™s an Optional! Nevertheless, Swift knows what you mean; when the thing on the left side of <code class="calibre19">is</code> is an Optional, Swift pretends that itâ€™s the value wrapped in the Optional. This works just as you would hope:<a data-type="indexterm" data-primary="Optionals" data-secondary="casting" id="calibre_link-1598" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="type" data-tertiary="testing" id="calibre_link-1622" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d : Dog? = NoisyDog()
if d is NoisyDog { // it is!</pre>

<p class="author1">When using <code class="calibre19">is</code> with an Optional, the test fails in good order if the Optional is <code class="calibre19">nil</code>. Thus our <code class="calibre19">is</code> test really does <em class="calibre11">two</em> things: it checks whether the Optional is <code class="calibre19">nil</code>, and if it is not, it then checks whether the wrapped value is the type we specify.</p>

<p class="author1">What about casting? You canâ€™t really cast an Optional to anything. Nevertheless, Swift knows what you mean; you can use the <code class="calibre19">as!</code> operator with an Optional. When the thing on the left side of <code class="calibre19">as!</code> is an Optional, Swift treats it as the wrapped type. Moreover, the consequence of applying the <code class="calibre19">as!</code> operator is that two things happen: Swift unwraps first, and then casts. This code works, because <code class="calibre19">d</code> is unwrapped to give us <code class="calibre19">d2</code>, which is a NoisyDog:</p>

<pre data-type="programlisting" class="calibre28">let d : Dog? = NoisyDog()
let d2 = d as! NoisyDog
d2.beQuiet()</pre>

<p class="author1">That code, however, is not safe. You shouldnâ€™t cast like that, without testing first, unless you are very sure of your ground. If <code class="calibre19">d</code> were <code class="calibre19">nil</code>, youâ€™d crash in the second line because youâ€™re trying to unwrap a <code class="calibre19">nil</code> Optional. And if <code class="calibre19">d</code> were a Dog, not a NoisyDog, youâ€™d <em class="calibre11">still</em> crash in the second line when the cast fails. Thatâ€™s why thereâ€™s also an <code class="calibre19">as?</code> operator, which <em class="calibre11">is</em> safe &mdash; but yields an Optional:</p>

<pre data-type="programlisting" class="calibre28">let d : Dog? = NoisyDog()
let d2 = d as? NoisyDog
d2?.beQuiet()</pre>

<p class="author1">In that code, we use <code class="calibre19">as?</code> to cast down from an Optional wrapping a Dog (<code class="calibre19">d</code>) to an Optional wrapping a NoisyDog (<code class="calibre19">d2</code>). The operation is safe, twice. If <code class="calibre19">d</code> is <code class="calibre19">nil</code>, <code class="calibre19">d2</code> will be <code class="calibre19">nil</code>, safely. If <code class="calibre19">d</code> is not <code class="calibre19">nil</code> but wraps a Dog, not a NoisyDog, the case will fail, and <code class="calibre19">d2</code> will be <code class="calibre19">nil</code>, safely. If <code class="calibre19">d</code> wraps a NoisyDog, <code class="calibre19">d2</code> wraps a NoisyDog. In the last line, we unwrap <code class="calibre19">d2</code> and send it a NoisyDog message &mdash; safely.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Bridging to Objective-C" class="calibre2"><div class="preface" id="calibre_link-2485">
<h2 class="calibre42">Bridging to Objective-C</h2>

<p class="author1">Another way youâ€™ll use casting is during a value interchange between Swift and Objective-C when two types are <em class="calibre11">equivalent</em>. For example, you can cast a Swift String to a Cocoa NSString, and <em class="calibre11">vice versa</em>. Thatâ€™s not because one is a subclass of the other, but because they are <em class="calibre11">bridged</em> to one another; in a very real sense, they are the same type. When you cast from String to NSString, youâ€™re not casting down, and what youâ€™re doing is not dangerous, so you use the <code class="calibre19">as</code> operator, with no exclamation mark or question mark.<a data-type="indexterm" data-primary="bridged types" data-secondary="casting" id="calibre_link-288" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In general, to cross the bridge from a Swift type to a bridged Objective-C type, you will need to cast explicitly (except in the case of a string literal):</p>

<pre data-type="programlisting" class="calibre28">let s : NSString = "howdy"         // string literal to NSString
let s2 = "howdy"
let s3 : NSString = s2 as NSString // String to NSString
let i : NSNumber = 1 as NSNumber   // Int to NSNumber</pre>

<p class="author1">That sort of code, however, is rather artificial. In real life, you wonâ€™t be casting all that often, because the Cocoa API will present itself to you in terms of Swift types. For example, this is legal with no cast:</p>

<pre data-type="programlisting" class="calibre28">let name = "MyNib" // Swift String
let vc = ViewController(nibName:name, bundle:nil)</pre>

<p class="author1">The UIViewController class comes from Cocoa, and its <code class="calibre19">nibName</code> property is an Objective-C NSString &mdash; not a Swift String. But you donâ€™t have to help the Swift String <code class="calibre19">name</code> across the bridge by casting, because, in the Swift world, <code class="calibre19">nibName:</code> is typed as a Swift String (actually, an Optional wrapping a String). The bridge, in effect, is crossed <em class="calibre11">later</em>.</p>

<p class="author1">Similarly, no cast is required here:</p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
let s = "howdy"
ud.set(s, forKey:"greeting")</pre>

<p class="author1">You donâ€™t have to help the Swift String <code class="calibre19">s</code> across the bridge by casting, because the first argument of <code class="calibre19">set(_:forKey:)</code> is typed as a Swift type, namely Any (actually, an Optional wrapping Any) &mdash; and any Swift type can be used, without casting, where an Any is expected. Iâ€™ll talk more about Any later in this chapter.</p>

<p class="author1">Coming back the other way, it is possible that youâ€™ll receive from Objective-C a value about whose real underlying type Swift has no information. In that case, youâ€™ll probably want to cast explicitly to the underlying type &mdash; and now you <em class="calibre11">are</em> casting down, with all that that implies. For example, hereâ€™s what happens when we go to retrieve the <code class="calibre19">"howdy"</code> that we put into UserDefaults in the previous example:</p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
let test = ud.object(forKey:"greeting") as! String</pre>

<p class="author1">When we call <code class="calibre19">ud.object(forKey:)</code>, Swift has no type information; the result is an Any (actually, an Optional wrapping Any). But we know that this particular call should yield a string &mdash; because thatâ€™s what we put in to begin with. So we can force-cast this value down to a String &mdash; and it works. However, if <code class="calibre19">ud.object(forKey:"greeting")</code> were <em class="calibre11">not</em> a string (or if it were <code class="calibre19">nil</code>), weâ€™d crash. If youâ€™re not sure of your ground, use <code class="calibre19">is</code> or <code class="calibre19">as?</code> to be safe.
<a data-type="indexterm" data-startref="idxcasting" id="calibre_link-344" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Type References" class="calibre2"><div class="preface" id="calibre_link-2486">
<h1 class="calibre18">Type References</h1>

<p class="author1">This section talks about the ways in which Swift can refer to the type of an object, other than saying the bare type literally.</p>








<section data-type="sect2" data-pdf-bookmark="From Instance to Type" class="calibre2"><div class="preface" id="calibre_link-2487">
<h2 class="calibre42">From Instance to Type</h2>

<p class="author1">Sometimes, what youâ€™ve got is an instance, and you want to know its type. This might be for no other reason than to log its type to the console, for the sake of information or debugging; or you might need to use the type as a value, as Iâ€™ll explain later.<a data-type="indexterm" data-primary="object types" data-secondary="references to" id="calibre_link-1505" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="references" id="calibre_link-2242" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="to object types" id="calibre_link-1871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="type" data-tertiary="learning" id="calibre_link-1136" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="printing" id="calibre_link-1502" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For this purpose, you can use the global <code class="calibre19">type(of:)</code> function:<a data-type="indexterm" data-primary="type(of:)" id="calibre_link-2246" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d : Dog = NoisyDog()
print(type(of:d)) // NoisyDog</pre>

<p class="author1">As you would expect, the identity principle applies. We are not asking how <code class="calibre19">d</code>, the variable, is typed; weâ€™re asking what sort of object the instance referred to by <code class="calibre19">d</code> <em class="calibre11">really</em> is. Itâ€™s typed as Dog, but itâ€™s a NoisyDog instance.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="From self to Type" class="calibre2"><div class="preface" id="calibre_link-2488">
<h2 class="calibre42">From self to Type</h2>

<p class="author1">It is particularly important for an instance to be able to refer to its <em class="calibre11">own</em> type. Quite commonly, this is in order to send a message to that type. For instance, suppose an instance wants to send a class message to its class. In an earlier example, a Dog instance method fetched a Dog class property by sending a message to the Dog type, literally using the word <code class="calibre19">Dog</code>:<a data-type="indexterm" data-primary="Self" id="calibre_link-1986" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="self" data-secondary="type of" id="calibre_link-1984" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    class var whatDogsSay : String {
        return "woof"
    }
    func bark() {
        print(Dog.whatDogsSay) // woof
    }
}</pre>

<p class="author1">The expression <code class="calibre19">Dog.whatDogsSay</code> seems clumsy and inflexible. Why should we hard-code into Dog a knowledge of what type it is? It <em class="calibre11">has</em> a type; it should just <em class="calibre11">know</em> what it is. Method code can refer to the current type &mdash; the type of <code class="calibre19">self</code> &mdash; using the keyword <code class="calibre19">Self</code> (with a capital letter). So:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    class var whatDogsSay : String {
        return "woof"
    }
    func bark() {
        print(Self.whatDogsSay) // woof
    }
}</pre>

<p class="author1">Similarly, we wrote a Filter enum earlier in this chapter that accessed its static <code class="calibre19">allCases</code> by saying <code class="calibre19">Filter.allCases</code>. We can say <code class="calibre19">Self.allCases</code> instead, and I prefer to do so; itâ€™s prettier.</p>

<p class="author1">Saying <code class="calibre19">Self</code> instead of a type name isnâ€™t <em class="calibre11">just</em> prettier; itâ€™s more powerful, because <code class="calibre19">Self</code>, like <code class="calibre19">self</code>, obeys polymorphism. Here are Dog and its subclass, NoisyDog:<a data-type="indexterm" data-primary="object types" data-secondary="polymorphism" id="calibre_link-1501" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    class var whatDogsSay : String {
        return "woof"
    }
    func bark() {
        print(Self.whatDogsSay)
    }
}
class NoisyDog : Dog {
    override class var whatDogsSay : String {
        return "woof woof woof"
    }
}</pre>

<p class="author1">Now watch what happens:</p>

<pre data-type="programlisting" class="calibre28">let nd = NoisyDog()
nd.bark() // woof woof woof</pre>

<p class="author1">If we tell a NoisyDog instance to <code class="calibre19">bark</code>, it says <code class="calibre19">"woof woof woof"</code>. The reason is that <code class="calibre19">Self</code> means, â€œThe type that this object actually is, right now.â€ We send the <code class="calibre19">bark</code> message to a NoisyDog instance. The <code class="calibre19">bark</code> implementation refers to <code class="calibre19">Self</code>; even though the <code class="calibre19">bark</code> implementation is inherited from Dog, <code class="calibre19">Self</code> means the type of this instance, which is a NoisyDog, and so <code class="calibre19">Self</code> is the NoisyDog class, and it is NoisyDogâ€™s version of <code class="calibre19">whatDogsSay</code> that is fetched.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">This use of <code class="calibre19">Self</code> is new in Swift 5.1. Previously you had to say <code class="calibre19">type(of:self)</code>.</p>
</div>

<p class="author1">Another important use of polymorphic <code class="calibre19">Self</code> is as a return type. To show why this is valuable, Iâ€™ll introduce the notion of a <em class="calibre11">factory method.</em><a data-type="indexterm" data-primary="factory" data-secondary="for instances" id="calibre_link-842" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Suppose our Dog class has a <code class="calibre19">name</code> instance property, and its only initializer is <code class="calibre19">init(name:)</code>. Letâ€™s give our Dog class a class method <code class="calibre19">makeAndName</code>. We want this class method to create and return a named Dog of whatever class we send the <code class="calibre19">makeAndName</code> message to. If we say <code class="calibre19">Dog.makeAndName()</code>, we should get a Dog. If we say <code class="calibre19">NoisyDog.makeAndName()</code>, we should get a NoisyDog. Well, we know how to do that; just initialize polymorphic <code class="calibre19">Self</code>. It works in a class method just as it works in an instance method:<a data-type="indexterm" data-primary="init" data-secondary="with type reference" id="calibre_link-1069" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    init(name:String) {
        self.name = name
    }
    class func makeAndName() -&gt; Dog {
        let d = Self(name:"Fido") // compile error
        return d
    }
}
class NoisyDog : Dog {
}</pre>

<p class="author1">However, thereâ€™s a problem: that code doesnâ€™t compile. The reason is that the compiler is in doubt as to whether the <code class="calibre19">init(name:)</code> initializer is implemented by every possible subtype of Dog. To reassure it, we must declare that initializer with the <code class="calibre19">required</code> keyword:<a data-type="indexterm" data-primary="initializers" data-secondary="required" id="calibre_link-1100" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="required initializers" id="calibre_link-1903" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    required init(name:String) { // *
        self.name = name
    }
    class func makeAndName() -&gt; Dog {
        let d = Self(name:"Fido")
        return d
    }
}
class NoisyDog : Dog {
}</pre>

<p class="author1">I promised earlier that Iâ€™d tell you why you might need to declare an initializer as <code class="calibre19">required</code>; now Iâ€™m fulfilling that promise! The <code class="calibre19">required</code> designation reassures the compiler; every subclass of Dog <em class="calibre11">must inherit or reimplement</em> <code class="calibre19">init(name:)</code>, so itâ€™s legal to call <code class="calibre19">init(name:)</code> message on a type reference that might refer to Dog or some subclass of Dog.</p>

<p class="author1">So now our code compiles, and we can call our function:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog.makeAndName() // d is a Dog named Fido
let d2 = NoisyDog.makeAndName() // d2 is a NoisyDog named Fido</pre>

<p class="author1">That code works as expected. But now thereâ€™s <em class="calibre11">another</em> problem. Although <code class="calibre19">d2</code> is in fact a NoisyDog, it is <em class="calibre11">typed</em> as a Dog. Thatâ€™s because our <code class="calibre19">makeAndName</code> class method is declared as returning a Dog. That isnâ€™t what we want to declare. We want to declare that this method returns an instance <em class="calibre11">of the same type</em> as the class to which the <code class="calibre19">makeAndName</code> message was originally sent. In other words, we need a polymorphic type declaration! That type is <code class="calibre19">Self</code> once again:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    required init(name:String) {
        self.name = name
    }
    class func makeAndName() -&gt; Self { // *
        let d = Self(name:"Fido")
        return d
    }
}
class NoisyDog : Dog {
}</pre>

<p class="author1">The <code class="calibre19">Self</code> type is used as a return type in a method declaration to mean â€œan instance of whatever type this is at runtime.â€ So when we call <code class="calibre19">NoisyDog.makeAndName()</code> we get a NoisyDog typed as NoisyDog.</p>

<p class="author1"><code class="calibre19">Self</code> also works for instance method declarations. Therefore, we can write an instance method version of our factory method. Here, we start with a Dog or a NoisyDog and tell it to have a puppy of the same type as itself:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name : String
    required init(name:String) {
        self.name = name
    }
    func havePuppy(name:String) -&gt; Self {
        return Self(name:name)
    }
}
class NoisyDog : Dog {
}</pre>

<p class="author1">And hereâ€™s some code to test it:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog(name:"Fido")
let d2 = d.havePuppy(name:"Fido Junior")
let nd = NoisyDog(name:"Rover")
let nd2 = nd.havePuppy(name:"Rover Junior")</pre>

<p class="author1">As expected, <code class="calibre19">d2</code> is a Dog, but <code class="calibre19">nd2</code> is a NoisyDog typed as NoisyDog.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Type as Value" class="calibre2"><div class="preface" id="calibre_link-2489">
<h2 class="calibre42">Type as Value</h2>

<p class="author1">In some situations, you may want to treat an object type <em class="calibre11">as a value.</em> That is legal. An object type is itself an object, of a sort; itâ€™s what Swift calls a <em class="calibre11">metatype.</em> So an object type can be assigned to a variable or passed as a parameter. Hereâ€™s what you need to know:<a data-type="indexterm" data-primary="object types" data-secondary="passing or assigning" id="calibre_link-1500" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Type" id="calibre_link-2243" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="metatype" id="calibre_link-1328" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">To <em class="calibre11">declare</em> that an object type is acceptable &mdash; for example, when declaring the type of a variable or parameter &mdash; use dot-notation with the name of the type and the keyword <code class="calibre19">Type</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">To <em class="calibre11">use</em> an object type as a value &mdash; for example, to assign a type to a variable or pass it as a parameter &mdash; hand the object to <code class="calibre19">type(of:)</code>, or use dot-notation with the name of the type and the keyword <code class="calibre19">self</code>. (In the latter case, the name of the type might be <code class="calibre19">Self</code>, in which case youâ€™ll be saying <code class="calibre19">Self.self</code>!)<a data-type="indexterm" data-primary="self" data-secondary="with type name" id="calibre_link-1985" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">For example, hereâ€™s a function <code class="calibre19">dogTypeExpecter</code> that accepts a Dog type as its <span class="publishername">parameter:</span></p>

<pre data-type="programlisting" class="calibre28">func dogTypeExpecter(_ whattype:Dog.Type) {
}</pre>

<p class="author1">And hereâ€™s an example of calling that function:</p>

<pre data-type="programlisting" class="calibre28">dogTypeExpecter(Dog.self)</pre>

<p class="author1">Or you could call it like this:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
dogTypeExpecter(type(of:d))</pre>

<p class="author1">The substitution principle applies, so you could call <code class="calibre19">dogTypeExpecter</code> like this:</p>

<pre data-type="programlisting" class="calibre28">dogTypeExpecter(NoisyDog.self)</pre>

<p class="author1">Or like this:</p>

<pre data-type="programlisting" class="calibre28">let nd = NoisyDog()
dogTypeExpecter(type(of:nd))</pre>

<p class="author1">To illustrate more practically, Iâ€™ll rewrite our Dog factory method as a global factory function that will accept a Dog <em class="calibre11">type</em> as a parameter and will create an instance from that type. You can use a variable reference to a type (a metatype) to instantiate that type, but you canâ€™t just use parentheses:<a data-type="indexterm" data-primary="errors, compiler" data-secondary="Initializing from a metatype value must reference init explicitly" id="calibre_link-797" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer(_ whattype:Dog.Type) -&gt; Dog {
    let d = whattype(name:"Fido") // compile error
    return d
}</pre>

<p class="author1">Instead, you must explicitly send the metatype an <code class="calibre19">init(...)</code> message:</p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer(_ whattype:Dog.Type) -&gt; Dog {
    let d = whattype.init(name:"Fido")
    return d
}</pre>

<p class="author1">And hereâ€™s how to call our function:</p>

<pre data-type="programlisting" class="calibre28">let d = dogMakerAndNamer(Dog.self) // d is a Dog named Fido
let d2 = dogMakerAndNamer(NoisyDog.self) // d2 is a NoisyDog named Fido</pre>

<p class="author1">Unfortunately, the global factory function <code class="calibre19">dogMakerAndNamer</code>, displays the same problem we had before &mdash; it returns an object typed as Dog, even if the underlying instance is in fact a NoisyDog. We canâ€™t return <code class="calibre19">Self</code> to solve the problem here, because thereâ€™s no type for it to refer to. Swift does have a solution, however &mdash; generics. Iâ€™ll discuss generic functions later in this chapter.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Summary of Type Terminology" class="calibre2"><div class="preface" id="calibre_link-2490">
<h2 class="calibre42">Summary of Type Terminology</h2>

<p class="author1">All this terminology can get a bit confusing, so hereâ€™s a quick summary:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">type(of:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Applied to an object: the polymorphic (internal) type of the object, regardless of how a reference is typed.</p>
</dd>
<dt class="calibre15"><code class="calibre19">Self</code></dt>
<dd class="calibre16">
<p class="calibre17">In a method body, or in a method declaration when specifying the return type, this type or this instanceâ€™s type, polymorphically.</p>
</dd>
<dt class="calibre15"><code class="calibre19">.Type</code></dt>
<dd class="calibre16">
<p class="calibre17">Appended to a type in a type declaration to specify that the type itself (or a subtype) is expected.</p>
</dd>
<dt class="calibre15"><code class="calibre19">.self</code></dt>
<dd class="calibre16">
<p class="calibre17">Sent to a type to generate a metatype, suitable for passing where a type (<code class="calibre19">.Type</code>) is expected.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Comparing Types" class="calibre2"><div class="preface" id="calibre_link-2491">
<h2 class="calibre42">Comparing Types</h2>

<p class="author1">Type references can be compared to one another. On the right side of an <code class="calibre19">==</code> comparison, you can use the name of a type with <code class="calibre19">.self</code>; on the right side of an <code class="calibre19">is</code> comparison, you can use the name of a type with <code class="calibre19">.Type</code>. The difference, as you might expect, is that <code class="calibre19">==</code> tests for absolutely identical types, whereas <code class="calibre19">is</code> permits subtypes.</p>

<p class="author1">In this artificial example, if the parameter <code class="calibre19">whattype</code> is <code class="calibre19">Dog.self</code>, both <code class="calibre19">equality</code> and <code class="calibre19">typology</code> are <code class="calibre19">true</code>; if the parameter is <code class="calibre19">NoisyDog.self</code>, <code class="calibre19">equality</code> is <code class="calibre19">false</code> but <code class="calibre19">typology</code> is still <code class="calibre19">true</code>:<a data-type="indexterm" data-primary="object types" data-secondary="comparison" id="calibre_link-1489" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func dogTypeExpecter(_ whattype:Dog.Type) {
    let equality = whattype == Dog.self
    let typology = whattype is Dog.Type
}</pre>

<p class="author1">(The second line is silly, because we <em class="calibre11">know</em> that <code class="calibre19">whattype</code> will always be some sort of Dog type &mdash; and the compiler tells you so. But suppose we had three classes: Dog, its subclass NoisyDog, and <em class="calibre11">its</em> subclass VeryNoisyDog. Now it would be useful to ask whether <code class="calibre19">whattype is NoisyDog.Type</code>, meaning NoisyDog or a subclass thereof.)</p>

<p class="author1">In that example, <code class="calibre19">whattype</code> might be replaced on the left side of the comparisons by the result of a call to <code class="calibre19">type(of:)</code> (or by a type name qualified by <code class="calibre19">.self</code>, though that would be pointless); and <code class="calibre19">Dog.self</code> might be replaced on the right side of the <code class="calibre19">==</code> comparison by <code class="calibre19">whattype</code> or the result of a call to <code class="calibre19">type(of:)</code>. But neither <code class="calibre19">whattype</code> nor <code class="calibre19">type(of:)</code> can appear on the right side of an <code class="calibre19">is</code> comparison; <code class="calibre19">is</code> requires a literal type as its second operand.</p>

<p class="author1">In real life, however, comparing type references is a <em class="calibre11">very</em> rare thing to do. Passing metatypes around is not Swifty, and comparing metatypes is <em class="calibre11">really</em> not Swifty. In general, if you find yourself talking like that, you should probably think of another way of doing whatever it is youâ€™re trying to do.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Protocols" class="calibre2"><div class="preface" id="calibre_link-2492">
<h1 class="calibre18">Protocols</h1>

<p class="author1">A <em class="calibre11">protocol</em> is a way of expressing commonalities between otherwise unrelated types. For example, a Bee object and a Bird object might have features in common by virtue of the fact that both a bee and a bird can fly. Thus, it might be useful to define a Flier type. The question is: In what sense can both Bee and Bird be Fliers?<a data-type="indexterm" data-primary="protocols" id="calibre_link-1785" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">One possibility might be class inheritance. If Bee and Bird are both classes, Flier could be the superclass of both Bee and Bird. However, there may be other reasons why Flier <em class="calibre11">canâ€™t</em> be the superclass of both Bee and Bird. A Bee is an Insect; a Bird isnâ€™t. Yet they both have the power of flight &mdash; independently. We need a type that cuts across the class hierarchy somehow, tying remote classes together.</p>

<p class="author1">Moreover, what if Bee and Bird are <em class="calibre11">not</em> both classes? In Swift, thatâ€™s a real possibility. Important and powerful objects can be structs instead of classes. But there is no hierarchy of superstructs and substructs!
How can a Bee struct and a Bird struct both be Fliers?</p>

<p class="author1">Swift solves this problem through the use of protocols. Protocols are tremendously important in Swift; the Swift header defines over 60 protocols! Moreover, Objective-C has protocols as well, and Cocoa makes heavy use of protocols; Swift protocols correspond roughly to Objective-C protocols, and can interchange with them.</p>

<p class="author1">A protocol is an object <em class="calibre11">type</em>, but there are no protocol <em class="calibre11">objects</em> &mdash; you canâ€™t instantiate a protocol. A protocol declaration is just a lightweight list of properties and methods. The properties have no values, and the methods have no code! The idea is that a â€œrealâ€ object type can formally declare that it belongs to a protocol type; this is called <em class="calibre11">adopting</em> the protocol. An object type that adopts a protocol is promising to implement the properties and methods listed by the protocol. And it must keep that promise! This is called <em class="calibre11">conforming to</em> the protocol.<a data-type="indexterm" data-primary="adopt a protocol" id="calibre_link-128" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conform to a protocol" id="calibre_link-521" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="adopting" id="calibre_link-1789" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="conforming to" id="calibre_link-1797" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s say that being a Flier consists of no more than implementing a <code class="calibre19">fly</code> method. Then a Flier protocol could specify that there must be a <code class="calibre19">fly</code> method; to do so, it lists the <code class="calibre19">fly</code> method <em class="calibre11">with no function body</em>, like this:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    func fly()
}</pre>

<p class="author1">Any type &mdash; an enum, a struct, a class, or even another protocol &mdash; can then adopt this protocol. To do so, it lists the protocol after a colon after its name in its declaration. (If the adopter is a class with a superclass, the protocol comes after a comma after the superclass specification.)<a data-type="indexterm" data-primary="colon" data-secondary="adopting protocol" id="calibre_link-459" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="protocol" id="calibre_link-479" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Letâ€™s say Bird is a struct. Then it can adopt Flier like this:</p>

<pre data-type="programlisting" class="calibre28">struct Bird : Flier {
} // compile error</pre>

<p class="author1">So far, so good. But that code wonâ€™t compile. The Bird struct has promised to implement the features listed in the Flier protocol. Now it must keep that promise! The <code class="calibre19">fly</code> method is the only requirement of the Flier protocol. To satisfy that requirement, Iâ€™ll just give Bird an empty <code class="calibre19">fly</code> method:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    func fly()
}
struct Bird : Flier {
    func fly() {
    }
}</pre>

<p class="author1">Thatâ€™s all there is to it. Weâ€™ve defined a protocol, and weâ€™ve made a struct adopt and conform to that protocol. Of course, in real life youâ€™ll probably want to make the adopterâ€™s implementation of the protocolâ€™s methods <em class="calibre11">do</em> something; but the protocol says nothing about that.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">A protocol can also declare a method <em class="calibre11">and provide its implementation</em>, thanks to protocol extensions, which Iâ€™ll discuss later in this chapter.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Why Protocols?" class="calibre2"><div class="preface" id="calibre_link-2493">
<h2 class="calibre42">Why Protocols?</h2>

<p class="author1">Perhaps at this point youâ€™re wondering: So what? If we wanted a Bird to know how to fly, why didnâ€™t we just give Bird a <code class="calibre19">fly</code> method <em class="calibre11">without</em> adopting any protocol? What difference does the protocol make?</p>

<p class="author1">The answer has to do with types. A protocol, such as our Flier, is a type. Therefore, I can <em class="calibre11">use</em> Flier as a type &mdash; to declare the type of a variable, for example, or the type of a function parameter:</p>

<pre data-type="programlisting" class="calibre28">func tellToFly(_ f:Flier) {
    f.fly()
}</pre>

<p class="author1">Protocols thus give us another way of expressing the notion of type and subtype &mdash; and <em class="calibre11">polymorphism applies</em>. By the substitution principle, a Flier here could be an instance of <em class="calibre11">any</em> object type, <em class="calibre11">as long as it adopts the Flier protocol.</em> It might be a Bird, it might be something else; we donâ€™t care. If it adopts the Flier protocol, it can be passed where a Flier is expected; moreover, it must have a <code class="calibre19">fly</code> method, because thatâ€™s exactly what it <em class="calibre11">means</em> to adopt the Flier protocol! Therefore we can confidently send the <code class="calibre19">fly</code> message to this object, and the compiler lets us do that.</p>

<p class="author1">The converse, however, is not true: an object with a <code class="calibre19">fly</code> method is <em class="calibre11">not</em> automatically a Flier. It isnâ€™t enough to <em class="calibre11">obey</em> the requirements of a protocol; the object type must formally <em class="calibre11">adopt</em> the protocol. This code wonâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">func tellToFly(_ f:Flier) {
    f.fly()
}
struct Bee {
    func fly() {
    }
}
let b = Bee()
tellToFly(b) // compile error</pre>

<p class="author1">A Bee <em class="calibre11">can</em> be sent the <code class="calibre19">fly</code> message, <em class="calibre11">qua</em> Bee. But <code class="calibre19">tellToFly</code> doesnâ€™t take a Bee parameter; it takes a Flier parameter. Formally, a Bee is <em class="calibre11">not</em> a Flier. To make a Bee a Flier, just declare formally that Bee adopts the Flier protocol! This code does compile:</p>

<pre data-type="programlisting" class="calibre28">func tellToFly(_ f:Flier) {
    f.fly()
}
struct Bee : Flier {
    func fly() {
    }
}
let b = Bee()
tellToFly(b)</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Adopting a Library Protocol" class="calibre2"><div class="preface" id="calibre_link-2494">
<h2 class="calibre42">Adopting a Library Protocol</h2>

<p class="author1">Enough of birds and bees; weâ€™re ready for a real-life example! As Iâ€™ve already said, the Swift standard library is chock full of protocols already. Letâ€™s make one of our own object types adopt one and watch the powers of that protocol spring to life for us.</p>

<p class="author1">The CustomStringConvertible protocol requires that we implement a <code class="calibre19">description</code> String property. If we do that, a wonderful thing happens: when an instance of this type is used in string interpolation or with <code class="calibre19">print</code> (or the <code class="calibre19">po</code> command in the console, or in the String initializer <code class="calibre19">init(describing:)</code>), its <code class="calibre19">description</code> property value is used automatically to represent it.<a data-type="indexterm" data-primary="description" id="calibre_link-650" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="CustomStringConvertible" id="calibre_link-596" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="interpolation" id="calibre_link-2102" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="interpolation, string" id="calibre_link-1154" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="print" id="calibre_link-1723" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Recall, for example, the Filter enum, from earlier in this chapter. Iâ€™ll add a <code class="calibre19">description</code> property to it:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    var description : String { return self.rawValue }
}</pre>

<p class="author1">But that isnâ€™t enough, in and of itself, to give Filter the power of the CustomStringConvertible protocol; to do that, we also need to <em class="calibre11">adopt</em> the CustomStringConvertible protocol formally. There is already a colon and a type in the Filter declaration, so an adopted protocol comes after a comma:</p>

<pre data-type="programlisting" class="calibre28">enum Filter : String, CustomStringConvertible {
    case albums = "Albums"
    case playlists = "Playlists"
    case podcasts = "Podcasts"
    case books = "Audiobooks"
    var description : String { return self.rawValue }
}</pre>

<p class="author1">We have now made Filter formally adopt the CustomStringConvertible protocol. The CustomStringConvertible protocol requires that we implement a <code class="calibre19">description</code> String property; we <em class="calibre11">do</em> implement a <code class="calibre19">description</code> String property, so our code compiles. Now we can interpolate a Filter into a string, or hand it over to <code class="calibre19">print</code>, or coerce it to a String, and its <code class="calibre19">description</code> will be used automatically:</p>

<pre data-type="programlisting" class="calibre28">let type = Filter.albums
print("It is \(type)") // It is Albums
print(type) // Albums
let s = String(describing:type) // Albums</pre>

<p class="author1">Behold the power of protocols. You can give <em class="calibre11">any</em> object type the power of string conversion in exactly the same way.</p>

<p class="author1">Note that a type can adopt more than one protocol! For example, the built-in Double type adopts CustomStringConvertible, Hashable, Strideable, and several other built-in protocols. To declare adoption of multiple protocols, list them separated by a comma after the protocol name and colon in the declaration (after the raw value type or superclass type if there is one):<a data-type="indexterm" data-primary="comma" data-secondary="protocol" id="calibre_link-480" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct MyType : CustomStringConvertible, TextOutputStreamable, Strideable {
    // ...
}</pre>

<p class="author1">(Of course, that code wonâ€™t compile unless I also declare, in MyType, any required properties and methods, so that MyType actually conforms to those protocols.)</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Protocol Type Testing and Casting" class="calibre2"><div class="preface" id="calibre_link-2495">
<h2 class="calibre42">Protocol Type Testing and Casting</h2>

<p class="author1">The operators for mediating between an objectâ€™s declared type and its real type work when the declared type is a protocol type. For example, given a protocol Flier that is adopted by both Bird and Bee, we can use the <code class="calibre19">is</code> operator to test whether a particular Flier is in fact a Bird:<a data-type="indexterm" data-primary="is" id="calibre_link-1162" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="as" id="calibre_link-211" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="testing type" id="calibre_link-1815" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="casting" id="calibre_link-1794" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func isBird(_ f:Flier) -&gt; Bool {
    return f is Bird
}</pre>

<p class="author1">Similarly, <code class="calibre19">as!</code> and <code class="calibre19">as?</code> can be used to cast an object declared as a protocol type down to its actual type. This is important to be able to do, because the adopting object will typically be able to receive messages that the protocol canâ€™t receive. For example, letâ€™s say that a Bird can get a worm:</p>

<pre data-type="programlisting" class="calibre28">struct Bird : Flier {
    func fly() {
    }
    func getWorm() {
    }
}</pre>

<p class="author1">A Bird can <code class="calibre19">fly</code> <em class="calibre11">qua</em> Flier, but it can <code class="calibre19">getWorm</code> only <em class="calibre11">qua</em> Bird. Thus, you canâ€™t tell just any old Flier to get a worm:</p>

<pre data-type="programlisting" class="calibre28">func tellGetWorm(_ f:Flier) {
    f.getWorm() // compile error
}</pre>

<p class="author1">But if this Flier is a Bird, clearly it <em class="calibre11">can</em> get a worm. That is exactly what casting is all about:</p>

<pre data-type="programlisting" class="calibre28">func tellGetWorm(f:Flier) {
    (f as? Bird)?.getWorm()
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Declaring a Protocol" class="calibre2"><div class="preface" id="calibre_link-2496">
<h2 class="calibre42">Declaring a Protocol</h2>

<p class="author1">Protocol declaration can take place only at the top level of a file. To declare a protocol, use the keyword <code class="calibre19">protocol</code> followed by the name of the protocol (which should start with a capital letter, as this is a type). Then come curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-589" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> which may contain declarations for any of the following:<a data-type="indexterm" data-primary="protocols" data-secondary="declaration" id="calibre_link-1798" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of protocols" id="calibre_link-630" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Properties</dt>
<dd class="calibre16">
<p class="calibre17">A property declaration in a protocol consists of <code class="calibre19">var</code> (not <code class="calibre19">let</code>), the property name, a colon, its type, and curly braces containing the word <code class="calibre19">get</code> or the words <code class="calibre19">get set</code>. In the former case, the adopterâ€™s implementation of this property <em class="calibre11">can</em> be writable, while in the latter case, it <em class="calibre11">must</em> be: the adopter may not implement a <code class="calibre19">get set</code> property as a read-only computed property or as a constant (<code class="calibre19">let</code>) stored property.</p>

<p class="calibre17">To declare a static/class property, precede it with the keyword <code class="calibre19">static</code>. A class adopter is free to implement this as a <code class="calibre19">class</code> property.</p>
</dd>
<dt class="calibre15">Methods</dt>
<dd class="calibre16">
<p class="calibre17">A method declaration in a protocol is a function declaration without a function body; it has no curly braces and thus it has no code. Any object function type is legal, including <code class="calibre19">init</code> and <code class="calibre19">subscript</code>. (The syntax for declaring a subscript in a protocol is the same as the syntax for declaring a subscript in an object type, except that the curly braces will contain <code class="calibre19">get</code> or <code class="calibre19">get set</code>.)</p>

<p class="calibre17">To declare a static/class method, precede it with the keyword <code class="calibre19">static</code>. A class adopter is free to implement this as a <code class="calibre19">class</code> method.</p>

<p class="calibre17">To permit an enum or struct adopter to declare a method <code class="calibre19">mutating</code>, declare it <code class="calibre19">mutating</code> in the protocol. An adopter cannot add <code class="calibre19">mutating</code> if the protocol lacks it, but the adopter may omit <code class="calibre19">mutating</code> if the protocol has it.</p>
</dd>
</dl>

<p class="author1">A protocol can itself adopt one or more protocols; the syntax is just as you would expect &mdash; a colon after the protocolâ€™s name in the declaration, followed by a comma-separated list of the protocols it adopts. In effect, this gives you a way to create an entire secondary hierarchy of types! The Swift headers make heavy use of this.</p>

<p class="author1">A protocol that adopts another protocol may repeat the contents of the adopted protocolâ€™s curly braces, for clarity; but it doesnâ€™t have to, as this repetition is implicit. An object type that adopts a protocol must satisfy the requirements of this protocol and all protocols that the protocol adopts.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Protocol Composition" class="calibre2"><div class="preface" id="calibre_link-2497">
<h2 class="calibre42">Protocol Composition</h2>

<p class="author1">If the only purpose of a protocol is to combine other protocols by adopting all of them, without adding any new requirements, you can avoid formally declaring the protocol in the first place by specifying the protocol combination on the fly. To do so, join the protocol names with <code class="calibre19">&amp;</code>. This is called <em class="calibre11">protocol composition:</em><a data-type="indexterm" data-primary="protocols" data-secondary="composition" id="calibre_link-1796" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="composition of protocols" id="calibre_link-502" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func f(_ x: CustomStringConvertible &amp; CustomDebugStringConvertible) {
}</pre>

<p class="author1">That is a function declaration with a parameter whose type is specified as being some object type that adopts both the CustomStringConvertible protocol and the CustomDebugStringConvertible protocol.</p>

<p class="author1">A type can also be specified as a composite of a class type and a protocol (or multiple protocols).
A case in point might look something like this:</p>

<pre data-type="programlisting" class="calibre28">protocol MyViewProtocol {
    func doSomethingReallyCool()
}
class ViewController: UIViewController {
    var v: (UIView &amp; MyViewProtocol)?
    func test() {
        self.v?.doSomethingReallyCool() // a MyViewProtocol requirement
        self.v?.backgroundColor = .red // a UIView property
    }
}</pre>

<p class="author1">To be assigned to ViewControllerâ€™s <code class="calibre19">v</code> property, an object would need to be an instance of a UIView subclass that is also an adopter of MyViewProtocol.
In this way, we guarantee to the compiler that both UIView messages and MyViewProtocol messages can be sent to a ViewControllerâ€™s <code class="calibre19">v</code>; otherwise, weâ€™d have to type <code class="calibre19">v</code> as a MyViewProtocol and then cast down to UIView in order to send it UIView messages, even if we knew that <code class="calibre19">v</code> would in fact always be a UIView.</p>

<p class="author1">New in Swift 5, thereâ€™s another way to accomplish the same thing; we can declare MyViewProtocol itself in such a way that it can be adopted <em class="calibre11">only</em> by UIView, as I shall now explain.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Class Protocols" class="calibre2"><div class="preface" id="calibre_link-2498">
<h2 class="calibre42">Class Protocols</h2>

<p class="author1">A protocol declaration may include the name of a class after the colon. This limits the types capable of adopting this protocol to that class or its subclasses:<a data-type="indexterm" data-primary="class" data-secondary="protocols" id="calibre_link-370" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="class" id="calibre_link-1795" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol MyViewProtocol : UIView {
    func doSomethingReallyCool()
}
class ViewController: UIViewController {
    var v: MyViewProtocol? // and therefore a UIView
    func test() {
        self.v?.doSomethingReallyCool() // a MyViewProtocol requirement
        self.v?.backgroundColor = .red // a UIView property
    }
}</pre>

<p class="author1">Here, MyViewProtocol can be adopted only by UIView or a UIView subclass. This means that an object typed as MyViewProtocol can be sent both MyViewProtocol messages and UIView messages, because <em class="calibre11">ex hypothesi</em> a MyViewProtocol object must <em class="calibre11">be</em> a UIView.</p>

<p class="author1">To specify that a protocol can be adopted only by some class (and not a struct or enum) without specifying what class it must be, use the protocol type AnyObject, which every class type adopts (as Iâ€™ll explain later):</p>

<pre data-type="programlisting" class="calibre28">protocol MyClassProtocol : AnyObject {
    // ...
}</pre>

<p class="author1">An alternative notation is a where clause before the curly braces. I have not yet talked about where clauses or the use of <code class="calibre19">Self</code> to signify the protocolâ€™s adopter, but Iâ€™ll show you the notation now anyway:</p>

<pre data-type="programlisting" class="calibre28">protocol MyViewProtocol where Self:UIView {
    func doSomethingReallyCool()
}
protocol MyClassProtocol where Self:AnyObject {
    // ...
}</pre>

<p class="author1">Instead of AnyObject after the colon following the name of the protocol, you can use the keyword <code class="calibre19">class</code>. That notation predates Swift 5 and may eventually be deprecated, but it is still legal as of this writing:</p>

<pre data-type="programlisting" class="calibre28">protocol MyClassProtocol : class {
    // ...
}</pre>

<p class="author1">A valuable byproduct of declaring a class protocol is that the resulting type can take advantage of special memory management features that apply only to classes. I havenâ€™t discussed memory management yet, but Iâ€™ll give an example anyway (and Iâ€™ll repeat it when I talk about memory management in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>):</p>

<pre data-type="programlisting" class="calibre28">protocol SecondViewControllerDelegate : AnyObject {
    func accept(data:Any)
}
class SecondViewController : UIViewController {
    weak var delegate : SecondViewControllerDelegate?
    // ...
}</pre>

<p class="author1">The keyword <code class="calibre19">weak</code> marks the <code class="calibre19">delegate</code> property as having special memory management that applies only to class instances. The <code class="calibre19">delegate</code> property is typed as a protocol, and a protocol might be adopted by a struct or an enum type. So to satisfy the compiler that this object <em class="calibre11">will</em> in fact be a class instance, and <em class="calibre11">not</em> a struct or enum instance, the protocol is declared as a class protocol.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">There is no need to qualify a protocol with AnyObject or <code class="calibre19">class</code> if this protocol is already marked <code class="calibre19">@objc</code>. The <code class="calibre19">@objc</code> attribute implies that this is also a class protocol, because classes are the only Objective-C object type.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Optional Protocol Members" class="calibre2"><div class="preface" id="calibre_link-55">
<h2 class="calibre42">Optional Protocol Members</h2>

<p class="author1">In Objective-C, a protocol member can be declared optional, meaning that this member doesnâ€™t have to be implemented by the adopter, but it may be. Swift allows optional protocol members, but this is solely for compatibility with Objective-C, and in fact it is implemented <em class="calibre11">by</em> Objective-C; it isnâ€™t really a Swift feature at all. Therefore, everything about an optional protocol member must be explicitly exposed to Objective-C. The protocotol declaration must be preceded with the <code class="calibre19">@objc</code> attribute, and an optional memberâ€™s declaration must be preceded with the keywords <code class="calibre19">@objc optional</code>:<a data-type="indexterm" data-primary="protocols" data-secondary="optional members" id="calibre_link-1812" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="optional methods" id="calibre_link-1590" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="optional" id="calibre_link-1344" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="optional properties" id="calibre_link-1592" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="optional" id="calibre_link-1769" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="objc" id="calibre_link-1479" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@objc protocol Flier {
    @objc optional var song : String {get}
    @objc optional func sing()
}</pre>

<p class="author1">(Iâ€™ll explain in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a> <em class="calibre11">how</em> Objective-C implements optional protocol members.)</p>

<p class="author1">An <code class="calibre19">@objc</code> protocol is a class protocol, as class protocols are the only kind of protocol Objective-C understands.
Many Cocoa protocols have optional members. For example, your iOS app will have an app delegate class that adopts the UIApplicationDelegate protocol; this protocol has many methods, all of them optional. That fact, however, will have no effect on how you implement those methods; either you implement a method or you donâ€™t. (Iâ€™ll talk more about Cocoa protocols in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>, and about delegate protocols in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>.)</p>

<p class="author1">An optional member is not guaranteed to be implemented by the adopter, so Swift doesnâ€™t know whether itâ€™s safe to send a Flier either the <code class="calibre19">song</code> message or the <code class="calibre19">sing</code> message. How Swift solves that problem depends on whether this is an optional property or an optional method.</p>










<section data-type="sect3" data-pdf-bookmark="Optional properties" class="calibre2"><div class="preface" id="calibre_link-2941">
<h3 class="calibre44">Optional properties</h3>

<p class="author1">In the case of an <em class="calibre11">optional property</em> like <code class="calibre19">song</code>, Swift solves the problem by wrapping its fetched value in an Optional. If the Flier adopter doesnâ€™t implement the property, the result is <code class="calibre19">nil</code> and no harm done:</p>

<pre data-type="programlisting" class="calibre28">@objc protocol Flier {
    @objc optional var song : String {get}
}
let f : Flier = Bird()
let s = f.song // s is an Optional wrapping a String</pre>

<p class="author1">This is one of those rare situations where you can wind up with a double-wrapped Optional. For example, if the value of the optional property <code class="calibre19">song</code> were itself a <code class="calibre19">String?</code>, then fetching its value from a Flier would yield a <code class="calibre19">String??</code>.<a data-type="indexterm" data-primary="Optionals" data-secondary="double-wrapped" id="calibre_link-1605" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A curious limitation is that if a protocol declares an optional property <code class="calibre19">{get set}</code>, you canâ€™t set that property. For example, if <code class="calibre19">f</code> is a Flier and <code class="calibre19">song</code> is declared <code class="calibre19">{get set}</code>, you canâ€™t set <code class="calibre19">f.song</code>:</p>

<pre data-type="programlisting" class="calibre28">@objc protocol Flier {
    @objc optional var song : String? {get set}
}
let f : Flier = Bird()
f.song = "tweet tweet" // compile error</pre>

<p class="author1">The error message claims that <code class="calibre19">f</code> is immutable, which is blatantly false. This is evidently a bug in the language. A workaround (pointed out to me by Jordan Rose) is to use key path notation (which Iâ€™ll explain in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>):</p>

<pre data-type="programlisting" class="calibre28">let f : Flier = Bird()
f[keyPath: \.song] = "tweet tweet"</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Optional members" class="calibre2"><div class="preface" id="calibre_link-2942">
<h3 class="calibre44">Optional members</h3>

<p class="author1">In the case of an <em class="calibre11">optional method</em> like <code class="calibre19">sing</code>, things are more elaborate. If the method is not implemented, we must not be permitted to call it in the first place. To handle this situation, the method is typed as an Optional version of its declared type. To send the <code class="calibre19">sing</code> message to a Flier, therefore, you must unwrap it. What you are unwrapping is not the result of the method call; itâ€™s the method <em class="calibre11">itself.</em> In the method call, the unwrap operator must appear <em class="calibre11">before</em> the parentheses!</p>

<p class="author1">The safe approach is to unwrap an optional method optionally, with a question mark:<a data-type="indexterm" data-primary="question mark" id="calibre_link-1830" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@objc protocol Flier {
    @objc optional func sing()
}
let f : Flier = Bird()
f.sing?()</pre>

<p class="author1">The effect is to send the <code class="calibre19">sing</code> message to <code class="calibre19">f</code> only if this Flier adopter implements <code class="calibre19">sing</code>. If this Flier adopter <em class="calibre11">doesnâ€™t</em> implement <code class="calibre19">sing</code>, nothing happens. You could have force-unwrapped the call &mdash; <code class="calibre19">f.sing!()</code> &mdash; but then your app would crash if the adopter doesnâ€™t implement <code class="calibre19">sing</code>.<a data-type="indexterm" data-primary="messages" data-secondary="sending optionally" id="calibre_link-1324" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="optional message sending" id="calibre_link-1588" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If an optional method returns a value, that value is wrapped in an Optional as well. For example:</p>

<pre data-type="programlisting" class="calibre28">@objc protocol Flier {
    @objc optional func sing() -&gt; String
}</pre>

<p class="author1">If we now call <code class="calibre19">sing?()</code> on a Flier, the result is an Optional wrapping a String:</p>

<pre data-type="programlisting" class="calibre28">let f : Flier = Bird()
let s = f.sing?() // s is an Optional wrapping a String</pre>

<p class="author1">If we force-unwrap the call &mdash; <code class="calibre19">sing!()</code> &mdash; the result is either a String (if the adopter implements <code class="calibre19">sing</code>) or a crash (if it doesnâ€™t).<a data-type="indexterm" data-primary="exclamation mark" id="calibre_link-818" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Implicitly Required Initializers" class="calibre2"><div class="preface" id="calibre_link-2499">
<h2 class="calibre42">Implicitly Required Initializers</h2>

<p class="author1">Suppose that a protocol declares an initializer. And suppose that a class adopts this protocol. By the terms of this protocol, this class and any subclass it may ever have must implement this initializer. Therefore, the class must not only implement the initializer, but it must also mark it as <code class="calibre19">required</code>. An initializer declared in a protocol is thus <em class="calibre11">implicitly required</em>, and the class is forced to make that requirement explicit.<a data-type="indexterm" data-primary="initializers" data-secondary="required" id="calibre_link-1101" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="required initializers" id="calibre_link-1904" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="implicitly required initializers" id="calibre_link-1807" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Consider this simple example, which wonâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    init()
}
class Bird : Flier {
    init() {} // compile error
}</pre>

<p class="author1">That code generates an elaborate but perfectly informative compile error message: â€œInitializer requirement <code class="calibre19">init()</code> can only be satisfied by a <code class="calibre19">required</code> initializer in non-final class Bird.â€ To compile our code, we must designate our initializer as <code class="calibre19">required</code>:<a data-type="indexterm" data-primary="errors, compiler" data-secondary="initializer requirement" id="calibre_link-796" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    init()
}
class Bird : Flier {
    required init() {}
}</pre>

<p class="author1">Alternatively, if Bird were marked <code class="calibre19">final</code>, there would be no need to mark its <code class="calibre19">init</code> as <code class="calibre19">required</code>, because this would mean that Bird <em class="calibre11">cannot have any subclasses</em> &mdash; thus guaranteeing that the problem will never arise in the first place.</p>

<p class="author1">In the above code, Bird is <em class="calibre11">not</em> marked as <code class="calibre19">final</code>, and its <code class="calibre19">init</code> <em class="calibre11">is</em> marked as <code class="calibre19">required</code>. This, as Iâ€™ve already explained, means that any subclass of Bird that implements any designated initializers &mdash; and thus loses initializer inheritance &mdash; must implement the required initializer and mark it <code class="calibre19">required</code> as well.</p>

<p class="author1">That fact is responsible for a strange and annoying feature of real-life iOS programming with Swift. Letâ€™s say you subclass the built-in Cocoa class UIViewController &mdash; something that you are extremely likely to do. And letâ€™s say you give your subclass an initializer &mdash; something that you are also extremely likely to do:</p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
    init() {
        super.init(nibName:"ViewController", bundle:nil) // compile error
    }
}</pre>

<p class="author1">That code wonâ€™t compile. The compile error says: â€œ<code class="calibre19">required</code> initializer <code class="calibre19">init(coder:)</code> must be provided by subclass of UIViewController.â€<a data-type="indexterm" data-primary="errors, compiler" data-secondary="required initializer must be provided" id="calibre_link-800" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Whatâ€™s going on here? It turns out that UIViewController adopts a protocol, <span class="publishername">NSCoding</span>. And this protocol requires an initializer <code class="calibre19">init(coder:)</code>. None of that is your doing; UIViewController and NSCoding are declared by Cocoa, not by you. But that doesnâ€™t matter! This is the same situation I was just describing. Your UIViewController subclass must either inherit <code class="calibre19">init(coder:)</code> or must explicitly implement it and mark it <code class="calibre19">required</code>. Well, your subclass has implemented a designated initializer of its own &mdash; thus <em class="calibre11">cutting off initializer inheritance</em>. Therefore it <em class="calibre11">must</em> implement <code class="calibre19">init(coder:)</code> and mark it <code class="calibre19">required</code>.<a data-type="indexterm" data-primary="init(coder:)" id="calibre_link-1070" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="NSCoding" id="calibre_link-1433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">But that makes no sense if you are not expecting <code class="calibre19">init(coder:)</code> ever to be <em class="calibre11">called</em> on your UIViewController subclass. You are being forced to write an initializer for which you can provide no meaningful functionality! Fortunately, Xcodeâ€™s Fix-it feature will offer to write the initializer for you, like this:</p>

<pre data-type="programlisting" class="calibre28">required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}</pre>

<p class="author1">That code satisfies the compiler. (Iâ€™ll explain in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> why itâ€™s a legal initializer even though it doesnâ€™t fulfill an initializerâ€™s contract.) It also deliberately crashes if it is ever called &mdash; which is fine, because <em class="calibre11">ex hypothesi</em> you donâ€™t expect it ever to be called.</p>

<p class="author1">If, on the other hand, you <em class="calibre11">do</em> have functionality for this initializer, you will delete the <code class="calibre19">fatalError</code> line and insert that functionality in its place. A minimum meaningful implementation would be to call <code class="calibre19">super.init(coder:aDecoder)</code>, but of course if your class has properties that need initialization, you will need to initialize them first.</p>

<p class="author1">Not only UIViewController but <em class="calibre11">lots</em> of built-in Cocoa classes adopt NSCoding. You will encounter this problem if you subclass <em class="calibre11">any</em> of those classes and implement your own initializer. Itâ€™s just something youâ€™ll have to get used to.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Literal Convertibles" class="calibre2"><div class="preface" id="calibre_link-2500">
<h2 class="calibre42">Literal Convertibles</h2>

<p class="author1">One of the wonderful things about Swift is that so many of its features, rather than being built-in and accomplished by magic, are exposed in the Swift header. Literals are a case in point. The reason you can say <code class="calibre19">5</code> to make an Int whose value is 5, instead of formally initializing Int by saying <code class="calibre19">Int(5)</code>, is not because of magic (or at least, not entirely because of magic). Itâ€™s because Int adopts a protocol, ExpressibleByIntegerLiteral. Not only Int literals, but <em class="calibre11">all</em> literals work this way. The following protocols are declared in the Swift header:<a data-type="indexterm" data-primary="protocols" data-secondary="literal convertible" id="calibre_link-1809" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="literals" data-secondary="where instance expected" id="calibre_link-1239" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="literals instead" id="calibre_link-1127" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">ExpressibleByNilLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByBooleanLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByIntegerLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByFloatLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByStringLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByExtendedGraphemeClusterLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByUnicodeScalarLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByArrayLiteral</p>
</li>
<li class="calibre12">
<p class="calibre17">ExpressibleByDictionaryLiteral</p>
</li>
</ul>

<p class="author1">Your own object type can adopt a literal convertible protocol as well. This means that a literal can appear where an instance of your object type is expected! For example, here we declare a Nest type that contains some number of eggs (its <code class="calibre19">eggCount</code>):</p>

<pre data-type="programlisting" class="calibre28">struct Nest : ExpressibleByIntegerLiteral {
    var eggCount : Int = 0
    init() {}
    init(integerLiteral val: Int) {
        self.eggCount = val
    }
}</pre>

<p class="author1">Because Nest adopts ExpressibleByIntegerLiteral, we can pass an Int where a Nest is expected, and our <code class="calibre19">init(integerLiteral:)</code> will be called automatically, causing a new Nest object with the specified <code class="calibre19">eggCount</code> to come into existence at that moment:<a data-type="indexterm" data-startref="idxprotocols" id="calibre_link-1786" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func reportEggs(_ nest:Nest) {
    print("this nest contains \(nest.eggCount) eggs")
}
reportEggs(4) // this nest contains 4 eggs</pre>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Generics" class="calibre2"><div class="preface" id="calibre_link-2501">
<h1 class="calibre18">Generics</h1>

<p class="author1">A <em class="calibre11">generic</em> is a sort of placeholder for a type, into which an actual type will be slotted later. In particular, there are situations where you want to say that a certain <em class="calibre11">same</em> type is to be used in several places, without specifying precisely <em class="calibre11">what</em> type this is to be. Swift generics allow you to say that, without sacrificing or evading Swiftâ€™s fundamental strict typing.<a data-type="indexterm" data-primary="generics" id="calibre_link-946" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="placeholders" data-secondary="generic" data-seealso="generics" id="calibre_link-1696" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="placeholders" data-seealso="generics" id="calibre_link-2241" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A motivating case in point arose earlier in this chapter, when we wrote a global factory function for dogs:</p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer(_ whattype:Dog.Type) -&gt; Dog {
    let d = whattype.init(name:"Fido")
    return d
}</pre>

<p class="author1">That works, but it isnâ€™t quite what weâ€™d like to say. This functionâ€™s declared return type is Dog. So if we are passed a Dog subclass such as NoisyDog as the parameter, we will instantiate that type (which is good) but then return that instance typed as Dog (which is bad). Instead, weâ€™d like the type declared as the return type after the arrow operator to be the <em class="calibre11">same</em> type that we were passed as a parameter in the first line and that we instantiated in the second line &mdash; whatever that type may be. Generics permit us to say that:</p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer&lt;WhatType:Dog&gt;(_:WhatType.Type) -&gt; WhatType { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2838" href="#calibre_link-2835"><img src="images/000019.png" alt="1" class="calibre39" /></a> <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2840" href="#calibre_link-2836"><img src="images/000029.png" alt="3" class="calibre39" /></a>
    let d = WhatType.init(name:"Fido") <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2839" href="#calibre_link-2837"><img src="images/000008.png" alt="2" class="calibre39" /></a>
    return d
}</pre>

<p class="author1">I havenâ€™t yet explained the syntax, but you can see the point. The angle brackets (<code class="calibre19">&lt;WhatType:Dog&gt;</code>) <em class="calibre11">declare</em> that the type WhatType is a generic type &mdash; a placeholder &mdash; and that it stands for Dog or for some subclass thereof. Then, WhatType is <em class="calibre11">used</em> in the course of the declaration, in three places:</p>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2835" href="#calibre_link-2838"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">As the type passed in as parameter.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2837" href="#calibre_link-2839"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">As the type instantiated in the function body.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2836" href="#calibre_link-2840"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">As the declared type of the returned instance (after the arrow operator).</p></dd>
</dl>

<p class="author1">The generic function specifies that WhatType is the <em class="calibre11">same</em> type throughout, without having to specify exactly <em class="calibre11">what</em> type it is (beyond the fact that it is Dog or a Dog subclass).</p>

<p class="author1">However, Swift has strict typing, so in order to let us <em class="calibre11">call</em> this function, the compiler needs to know the <em class="calibre11">real</em> type that WhatType stands for. But in fact it knows this from looking at the call itself! For example:</p>

<pre data-type="programlisting" class="calibre28">let dog = dogMakerAndNamer(NoisyDog.self)</pre>

<p class="author1">In that call, we pass <code class="calibre19">NoisyDog.self</code> as the parameter. That tells the compiler what WhatType is! It is NoisyDog. In effect, the compiler now <em class="calibre11">substitutes</em> NoisyDog for WhatType throughout the generic, like this (pseudocode):</p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer(_:NoisyDog.Type) -&gt; NoisyDog {
    let d = NoisyDog.init(name:"Fido")
    return d
}</pre>

<p class="author1">That process of substitution is called <em class="calibre11">resolving</em> (or <em class="calibre11">specializing</em>) the generic. The type in question is unambiguously clear <em class="calibre11">for this call</em> to our function, and the compiler is satisfied. And this resolution extends beyond the generic itself. For example, now that the compiler knows that this call to our function will return a NoisyDog instance, it can type the variable initialized to the result of the call as a NoisyDog by inference:<a data-type="indexterm" data-primary="resolving a generic" id="calibre_link-1907" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="resolution" id="calibre_link-959" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="specializing a generic" id="calibre_link-2050" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="generics" data-secondary="specialization" data-seealso="generics, resolution" id="calibre_link-963" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let dog = dogMakerAndNamer(NoisyDog.self) // dog is typed as NoisyDog</pre>

<p class="author1">Letâ€™s consider another case in point: an Optional. Any type of value can be wrapped up in an Optional. Yet there is no doubt as to what type is wrapped up in a <em class="calibre11">particular</em> Optional. How can this be? Itâ€™s because Optional is a generic! Hereâ€™s how an Optional works.<a data-type="indexterm" data-primary="Optionals" data-secondary="enum" id="calibre_link-1609" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">I have already said that an Optional is an enum, with two cases: <code class="calibre19">.none</code> and <code class="calibre19">.some</code>. If an Optionalâ€™s case is <code class="calibre19">.some</code>, it has an associated value &mdash; the value that is wrapped by this Optional. But what is the type of that associated value? On the one hand, one wants to say that it can be any type; that, after all, is why anything can be wrapped up in an Optional. On the other hand, any <em class="calibre11">particular</em> Optional can wrap a value only of some one <em class="calibre11">specific</em> known type. That sounds like a generic! The declaration for the Optional enum in the Swift header starts like this:</p>

<pre data-type="programlisting" class="calibre28">enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral {
    case none
    case some(Wrapped)
    init(_ some: Wrapped)
    // ...
}</pre>

<p class="author1">The angle-bracket syntax <code class="calibre19">&lt;Wrapped&gt;</code> <em class="calibre11">declares</em> that Wrapped is a placeholder. The rest of the enum declaration proceeds to <em class="calibre11">use</em> the placeholder. Besides the case <code class="calibre19">.none</code>, thereâ€™s also a case <code class="calibre19">.some</code>, which has an associated value &mdash; of type <span class="publishername">Wrapped</span>. And thereâ€™s an initializer, which takes a parameter &mdash; of type Wrapped. Thus, the type with which we are initialized &mdash; whatever type that may be &mdash; <em class="calibre11">is</em> type Wrapped, and therefore is the type associated with the <code class="calibre19">.some</code> case.</p>

<p class="author1">And how will this placeholder be resolved? Well, when an Optional is created, it will be initialized with an actual value of some definite type:</p>

<pre data-type="programlisting" class="calibre28">let s = Optional("howdy")</pre>

<p class="author1">Weâ€™re calling <code class="calibre19">init(_ some: Wrapped)</code>, so <code class="calibre19">"howdy"</code> is being supplied here as a Wrapped instance, thus resolving the generic as String. The compiler now knows that Wrapped is String <em class="calibre11">throughout</em> this particular <code class="calibre19">Optional&lt;Wrapped&gt;</code>; the declaration for this <em class="calibre11">particular</em> Optional looks, in the compilerâ€™s mind, like this (pseudocode):</p>

<pre data-type="programlisting" class="calibre28">enum Optional&lt;String&gt; {
    case none
    case some(String)
    init(_ some: String)
    // ...
}</pre>

<p class="author1">That is the pseudocode declaration of an Optional whose Wrapped placeholder has been replaced everywhere with the String type. We can summarize this by saying that <code class="calibre19">s</code> is an <code class="calibre19">Optional&lt;String&gt;</code>. In fact, that is legal syntax! We can create the same Optional like this:</p>

<pre data-type="programlisting" class="calibre28">let s : Optional&lt;String&gt; = "howdy"</pre>








<section data-type="sect2" data-pdf-bookmark="Generic Declarations" class="calibre2"><div class="preface" id="calibre_link-2502">
<h2 class="calibre42">Generic Declarations</h2>

<p class="author1">Hereâ€™s a list of places where generics, in one form or another, can be declared in Swift:<a data-type="indexterm" data-primary="generics" data-secondary="declaration" id="calibre_link-951" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of generics" id="calibre_link-627" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Generic protocol with <code class="calibre19">Self</code></dt>
<dd class="calibre16">
<p class="calibre17">In a protocol body, use of the keyword <code class="calibre19">Self</code> turns the protocol into a generic. <code class="calibre19">Self</code> here is a placeholder meaning <em class="calibre11">the type of the adopter</em>. For example, hereâ€™s a Flier protocol that declares a method that takes a <code class="calibre19">Self</code> <span class="publishername">parameter:</span><a data-type="indexterm" data-primary="protocols" data-secondary="generic" id="calibre_link-1805" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Self" id="calibre_link-1987" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="protocols" id="calibre_link-957" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="adopter" id="calibre_link-1788" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    func flockTogetherWith(_ f:Self)
}</pre>

<p class="calibre17">That means that if the Bird object type were to adopt the Flier protocol, its implementation of <code class="calibre19">flockTogetherWith</code> would need to declare its parameter as a Bird.</p>
</dd>
<dt class="calibre15">Generic protocol with associated type</dt>
<dd class="calibre16">
<p class="calibre17">A protocol can declare an <em class="calibre11">associated type</em> using an <code class="calibre19">associatedtype</code> statement. This turns the protocol into a generic; the associated type name is a placeholder:<a data-type="indexterm" data-primary="associated type" id="calibre_link-222" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="associated type" id="calibre_link-1791" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    associatedtype Other
    func flockTogetherWith(_ f:Other)
    func mateWith(_ f:Other)
}</pre>

<p class="calibre17">An adopter will declare a particular type at some point where the generic uses the associated type name, thus resolving the placeholder:</p>

<pre data-type="programlisting" class="calibre28">struct Bird : Flier {
    func flockTogetherWith(_ f:Bird) {}
    func mateWith(_ f:Bird) {}
}</pre>

<p class="calibre17">The Bird struct adopts the Flier protocol and declares the parameter of <code class="calibre19">flockTogetherWith</code> as a Bird. That declaration resolves Other to Bird for this particular adopter &mdash; and now Bird must declare the parameter for <code class="calibre19">mateWith</code> as a Bird as well.</p>
</dd>
<dt class="calibre15">Generic functions</dt>
<dd class="calibre16">
<p class="calibre17">A function declaration can use a generic placeholder type for any of its parameters, for its return type, and within its body. The placeholder name is declared in angle brackets after the function name:<a data-type="indexterm" data-primary="functions" data-secondary="generic" id="calibre_link-916" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="functions" id="calibre_link-954" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func takeAndReturnSameThing&lt;T&gt; (_ t:T) -&gt; T {
    print(T.self)
    return t
}</pre>

<p class="calibre17">The caller will use a particular type at some point where the placeholder appears in the function declaration, thus resolving the placeholder:</p>

<pre data-type="programlisting" class="calibre28">let thing = takeAndReturnSameThing("howdy")</pre>

<p class="calibre17">Here, the type of the argument <code class="calibre19">"howdy"</code> used in the call resolves T to String; therefore this call to <code class="calibre19">takeAndReturnSameThing</code> will also return a String, and the variable capturing the result, <code class="calibre19">thing</code>, is inferred to String as well.</p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Generic object types</dt>
<dd class="calibre16">
<p class="calibre17">An object type declaration can use a generic placeholder type anywhere within its curly braces. The placeholder name is declared in angle brackets after the object type name:<a data-type="indexterm" data-primary="object types" data-secondary="generic" id="calibre_link-1494" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="object types" id="calibre_link-955" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct HolderOfTwoSameThings&lt;T&gt; {
    var firstThing : T
    var secondThing : T
    init(thingOne:T, thingTwo:T) {
        self.firstThing = thingOne
        self.secondThing = thingTwo
    }
}</pre>

<p class="calibre17">A user of this object type will use a particular type at some point where the placeholder appears in the object type declaration, thus resolving the placeholder:</p>

<pre data-type="programlisting" class="calibre28">let holder = HolderOfTwoSameThings(thingOne:"howdy", thingTwo:"getLost")</pre>

<p class="calibre17">Here, the type of the <code class="calibre19">thingOne</code> argument, <code class="calibre19">"howdy"</code>, used in the initializer call, resolves T to String; therefore <code class="calibre19">thingTwo</code> must also be a String, and the properties <code class="calibre19">firstThing</code> and <code class="calibre19">secondThing</code> are Strings as well.</p>
</dd>
</dl>

<p class="author1">The angle brackets that declare a placeholder may declare multiple placeholders, separated by a comma:<a data-type="indexterm" data-primary="comma" data-secondary="generic placeholders" id="calibre_link-477" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func flockTwoTogether&lt;T, U&gt;(_ f1:T, _ f2:U) {}</pre>

<p class="author1">The two parameters of <code class="calibre19">flockTwoTogether</code> can now be resolved to two different types (though they do not <em class="calibre11">have</em> to be different).</p>

<p class="author1">Inside a genericâ€™s code, the generic placeholder is a type reference standing for the resolved type, which can be interrogated using type reference comparison, as described earlier in this chapter:</p>

<pre data-type="programlisting" class="calibre28">func takeAndReturnSameThing&lt;T&gt; (_ t:T) -&gt; T {
    if T.self is String.Type {
        // ...
    }
    return t
}</pre>

<p class="author1">If we call <code class="calibre19">takeAndReturnSameThing("howdy")</code>, the condition will be true. That sort of thing, however, is unusual; a generic whose behavior depends on interrogation of the placeholder type may need to be rewritten in some other way.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Contradictory Resolution is Impossible" class="calibre2"><div class="preface" id="calibre_link-2503">
<h2 class="calibre42">Contradictory Resolution is Impossible</h2>

<p class="author1">Because the use of a generic resolves the generic, a resolution that would contradict itself is ruled out <em class="calibre11">at compile time</em>. This is one of the most important features of generics: contradictory resolution is impossible as a consequence of Swiftâ€™s strict typing. A generic placeholder must be resolved consistently throughout the generic, or it cannot be resolved at all.</p>

<p class="author1">To illustrate, Iâ€™ll return to an earlier example:<a data-type="indexterm" data-primary="generics" data-secondary="resolution" data-tertiary="contradictory" id="calibre_link-960" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer&lt;WhatType:Dog&gt;(_:WhatType.Type) -&gt; WhatType {
    let d = WhatType.init(name:"Fido")
    return d
}</pre>

<p class="author1">Now consider this code:</p>

<pre data-type="programlisting" class="calibre28">let d : NoisyDog = dogMakerAndNamer(Dog.self)</pre>

<p class="author1">That code makes no sense. On the one hand, the parameter <code class="calibre19">Dog.self</code> resolves WhatType to Dog. On the other hand, the explicit type of the result <code class="calibre19">d</code> resolves WhatType to NoisyDog. Those two resolutions contradict one another. The compiler knows this, and stops you in your tracks:<a data-type="indexterm" data-primary="errors, compiler" data-secondary="cannot convert value to specified type" id="calibre_link-789" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d : NoisyDog = dogMakerAndNamer(Dog.self) // compile error</pre>

<p class="author1">Similarly, recall this example:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    associatedtype Other
    func flockTogetherWith(_ f:Other)
    func mateWith(_ f:Other)
}</pre>

<p class="author1">The placeholder Other may be resolved to any type, but it must be the <em class="calibre11">same</em> type. This is a legal adoption of Flier:</p>

<pre data-type="programlisting" class="calibre28">struct Bird : Flier {
    func flockTogetherWith(_ f: String) {}
    func mateWith(_ f:String) {}
}</pre>

<p class="author1">But this is not:</p>

<pre data-type="programlisting" class="calibre28">struct Bird : Flier { // compile error
    func flockTogetherWith(_ f: String) {}
    func mateWith(_ f:Int) {}
}</pre>

<p class="author1">The compiler stops you, complaining that Bird does not conform to Flier.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Type Constraints" class="calibre2"><div class="preface" id="calibre_link-2504">
<h2 class="calibre42">Type Constraints</h2>

<p class="author1">A generic declaration can <em class="calibre11">limit</em> the types that are eligible to be used for resolving a particular placeholder. This is called a <em class="calibre11">type constraint</em>.</p>

<p class="author1">The simplest form of type constraint is to put a colon and a type name after the placeholderâ€™s name when it first appears. The type name after the colon can be a class name or a protocol name:<a data-type="indexterm" data-primary="type" data-secondary="constraints" id="calibre_link-2230" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="type constraints" id="calibre_link-964" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="constraints, type" id="calibre_link-542" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="colon" data-secondary="generic type constraint" id="calibre_link-462" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Class name</dt>
<dd class="calibre16">
<p class="calibre17">A class name means that this type must be this class <em class="calibre11">or a subclass</em> of this class.</p>
</dd>
<dt class="calibre15">Protocol name</dt>
<dd class="calibre16">
<p class="calibre17">A protocol name means that this type must be <em class="calibre11">an adopter</em> of this protocol.</p>
</dd>
</dl>

<p class="author1">For a protocol associated type, the type constraint appears as part of the <code class="calibre19">associatedtype</code> declaration:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    func fly()
}
protocol Flocker {
    associatedtype Other : Flier // *
    func flockTogetherWith(f:Other)
}
struct Bird : Flocker, Flier {
    func fly() {}
    func flockTogetherWith(f:Bird) {}
}</pre>

<p class="author1">In that example, Flockerâ€™s associated type Other is constrained to be an adopter of Flier. Bird <em class="calibre11">is</em> an adopter of Flier; therefore it can also adopt Flocker while specifying that the parameter type in its <code class="calibre19">flockTogetherWith</code> implementation is Bird.</p>

<p class="author1">Observe that we could not have achieved the same effect without the associated type, by declaring Flocker like this:</p>

<pre data-type="programlisting" class="calibre28">protocol Flocker {
    func flockTogetherWith(f:Flier)
}</pre>

<p class="author1">Thatâ€™s not the same thing! That requires that a Flocker adopter specify the parameter for <code class="calibre19">flockTogetherWith</code> <em class="calibre11">as Flier</em>. We would then have had to write Bird like this:</p>

<pre data-type="programlisting" class="calibre28">struct Bird : Flocker, Flier {
    func fly() {}
    func flockTogetherWith(f:Flier) {}
}</pre>

<p class="author1">The constrained associated type, on the other hand, requires that a Flocker adopter specify the parameter for <code class="calibre19">flockTogetherWith</code> as <em class="calibre11">some Flier adopter</em> (such as Bird).</p>

<p class="author1">For a generic function or a generic object type, the type constraint appears in the angle brackets. The global function declaration earlier in this chapter, <code class="calibre19">func dogMakerAndNamer&lt;WhatType:Dog&gt;</code>, is an example; Dog is a class, so the constraint says that WhatType must be Dog or a Dog subclass. Hereâ€™s another example, using a protocol as a constraint:</p>

<pre data-type="programlisting" class="calibre28">func flockTwoTogether&lt;T:Flier&gt;(_ f1:T, _ f2:T) {}</pre>

<p class="author1">In that example, Flier is a protocol, so the constraint says that T must be a Flier adopter. If Bird and Insect both adopt Flier, this <code class="calibre19">flockTwoTogether</code> function can be called with two Bird arguments or with two Insect arguments &mdash; but not with a Bird and an Insect, because T is just one placeholder, signifying one Flier adopter type. And you canâ€™t call <code class="calibre19">flockTwoTogether</code> with two String parameters, because a String is not a Flier.</p>

<p class="author1">A type constraint on a placeholder is often used to reassure the compiler that some message can be sent to an instance of the placeholder type. For example, letâ€™s say we want to implement a function <code class="calibre19">myMin</code> that returns the smallest from a list of the same type. Hereâ€™s a promising implementation as a generic function, but thereâ€™s one problem &mdash; it doesnâ€™t compile:<a data-type="indexterm" data-primary="generics" data-secondary="type, telling compiler" id="calibre_link-967" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func myMin&lt;T&gt;(_ things:T...) -&gt; T {
    var minimum = things.first!
    for item in things.dropFirst() {
        if item &lt; minimum { // compile error
            minimum = item
        }
    }
    return minimum
}</pre>

<p class="author1">The problem is the comparison <code class="calibre19">things[ix] &lt; minimum</code>. How does the compiler know that the type T, the type of <code class="calibre19">things[ix]</code> and <code class="calibre19">minimum</code>, will be resolved to a type that can in fact be compared using the less-than operator in this way? It doesnâ€™t, and thatâ€™s exactly why it rejects that code. The solution is to promise the compiler that the resolved type of T <em class="calibre11">will</em> in fact work with the less-than operator. The way to do that, it turns out, is to constrain T to Swiftâ€™s built-in Comparable<a data-type="indexterm" data-primary="Comparable" id="calibre_link-489" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> protocol; adoption of the Comparable protocol exactly guarantees that the adopter <em class="calibre11">does</em> work with the less-than operator:</p>

<pre data-type="programlisting" class="calibre28">func myMin&lt;T:Comparable&gt;(_ things:T...) -&gt; T {</pre>

<p class="author1">Now <code class="calibre19">myMin</code> compiles, because it cannot be called except by resolving T to an object type that adopts Comparable and hence can be compared with the less-than operator. Naturally, built-in object types that you think should be comparable, such as Int, Double, String, and Character, do in fact adopt the Comparable protocol! If you look in the Swift headers, youâ€™ll find that the built-in <code class="calibre19">min</code> global function is declared in just this way, and for just this reason.</p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">A generic protocol type can be used <em class="calibre11">only</em> as a type constraint. If you try to use it in any other way, youâ€™ll get a compile error. This restriction can be quite frustrating. The standard way of circumventing it is called <em class="calibre11">type erasure</em>; for an excellent discussion, see <a href="http://robnapier.net/erasure" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://robnapier.net/erasure</em></a>.<a data-type="indexterm" data-primary="errors, compiler" data-secondary="protocol can only be used" id="calibre_link-799" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Explicit Specialization" class="calibre2"><div class="preface" id="calibre_link-2505">
<h2 class="calibre42">Explicit Specialization</h2>

<p class="author1">In the generic examples so far, the placeholderâ€™s type has been resolved mostly through <em class="calibre11">inference</em>. For example, we initialize an Optional with a string literal, so its Wrapped type is resolved to String:</p>

<pre data-type="programlisting" class="calibre28">let s = Optional("howdy")</pre>

<p class="author1">But thereâ€™s another way to perform resolution: we can resolve the type <em class="calibre11">manually</em>. For example, we can actually declare, as we use the generic, what the placeholder type is:</p>

<pre data-type="programlisting" class="calibre28">let s : Optional&lt;String&gt; = "howdy"</pre>

<p class="author1">This is called <em class="calibre11">explicit specialization</em>. In some situations, explicit specialization is mandatory &mdash; namely, if the placeholder type cannot be resolved through inference. There are two forms of explicit specialization:<a data-type="indexterm" data-primary="resolving a generic" id="calibre_link-1908" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="explicit specialization" id="calibre_link-952" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="specializing a generic" id="calibre_link-2051" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="explicit specialization" id="calibre_link-821" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="resolution" data-tertiary="explicit" id="calibre_link-961" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Generic protocol with associated type</dt>
<dd class="calibre16">
<p class="calibre17">The adopter of a protocol can resolve an associated type manually through a type alias defining the associated type as some explicit type:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    associatedtype Other
}
struct Bird : Flier {
    typealias Other = String
}</pre>
</dd>
<dt class="calibre15">Generic object type</dt>
<dd class="calibre16">
<p class="calibre17">The user of a generic object type can resolve a placeholder type manually using the same angle bracket syntax used to declare the generic in the first place, with the type name in the angle brackets:</p>

<pre data-type="programlisting" class="calibre28">class Dog&lt;T&gt; {
    var name : T?
}
let d = Dog&lt;String&gt;()</pre>
</dd>
</dl>

<p class="author1">You cannot explicitly specialize a generic function. One solution is to make your generic function take a type parameter resolving the generic. Thatâ€™s what I did in my earlier <code class="calibre19">dogMakerAndNamer</code> example:</p>

<pre data-type="programlisting" class="calibre28">func dogMakerAndNamer&lt;WhatType:Dog&gt;(_:WhatType.Type) -&gt; WhatType {
    let d = WhatType.init(name:"Fido")
    return d
}</pre>

<p class="author1">The parameter to <code class="calibre19">dogMakerAndNamer</code> is never used within the function body, which is why it has no name (just an underscore). It does, however, serve to resolve the generic!</p>

<p class="author1">Another approach is not to use a generic function in the first place. Instead, declare a generic object type wrapping a nongeneric function that uses the generic typeâ€™s placeholder. The generic type <em class="calibre11">can</em> be explicitly specialized, thus resolving the placeholder in the function:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    init()
}
struct Bird : Flier {
    init() {}
}
struct FlierMaker&lt;T:Flier&gt; {
    static func makeFlier() -&gt; T {
        return T()
    }
}
let f = FlierMaker&lt;Bird&gt;.makeFlier() // returns a Bird</pre>

<p class="author1">When a class is generic, you can subclass it, provided you resolve the generic. You can do this either through a matching generic subclass or by resolving the superclass generic explicitly. For example, hereâ€™s a generic Dog:<a data-type="indexterm" data-primary="classes" data-secondary="generic, subclassing" id="calibre_link-377" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="classes, subclassing" id="calibre_link-950" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog&lt;T&gt; {
    func speak(_ what:T) {}
}</pre>

<p class="author1">You can subclass it as a generic whose placeholder matches that of the superclass:</p>

<pre data-type="programlisting" class="calibre28">class NoisyDog&lt;T&gt; : Dog&lt;T&gt; {}</pre>

<p class="author1">Thatâ€™s legal because the resolution of the NoisyDog placeholder T will resolve the Dog placeholder T. The alternative is to subclass an explicitly specialized Dog:</p>

<pre data-type="programlisting" class="calibre28">class NoisyDog : Dog&lt;String&gt; {}</pre>

<p class="author1">In that case, a method override in the subclass can use the specialized type where the superclass uses the generic:</p>

<pre data-type="programlisting" class="calibre28">class NoisyDog : Dog&lt;String&gt; {
   override func speak(_ what:String) {}
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Generic Invariance" class="calibre2"><div class="preface" id="calibre_link-2506">
<h2 class="calibre42">Generic Invariance</h2>

<p class="author1">In general, a generic type specialized to a subtype is <em class="calibre11">not polymorphic</em> with respect to the same generic type specialized to a supertype. For example, suppose we have a simple generic Wrapper struct along with a Cat class and its CalicoCat subclass:<a data-type="indexterm" data-primary="covariant" id="calibre_link-559" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="polymorphism" id="calibre_link-956" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="polymorphism" data-secondary="generics" id="calibre_link-1709" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Wrapper&lt;T&gt; {
}
class Cat {
}
class CalicoCat : Cat {
}</pre>

<p class="author1">Then you canâ€™t assign a Wrapper specialized to CalicoCat where a Wrapper specialized to Cat is expected:</p>

<pre data-type="programlisting" class="calibre28">let w : Wrapper&lt;Cat&gt; = Wrapper&lt;CalicoCat&gt;() // compile error</pre>

<p class="author1">It appears that polymorphism is failing here &mdash; but it isnâ€™t. The two generic types, <code class="calibre19">Wrapper&lt;Cat&gt;</code> and <code class="calibre19">Wrapper&lt;CalicoCat&gt;</code>, are not superclass and subclass. Rather, if this assignment were possible, we would say that the types are <em class="calibre11">covariant</em>, meaning that the polymorphic relationship between the specializations of the placeholders is applied to the generic types themselves. Certain Swift built-in generic types <em class="calibre11">are</em> covariant; Optional is a clear example! But, frustratingly, covariance is not a <em class="calibre11">general</em> language feature; thereâ€™s no way for you to specify that <em class="calibre11">your</em> generic types should be covariant.</p>

<p class="author1">One workaround is to have your generic placeholder constrained to a protocol, and have your types adopt that protocol:</p>

<pre data-type="programlisting" class="calibre28">protocol Meower {
    func meow()
}
struct Wrapper&lt;T:Meower&gt; {
    let meower : T
}
class Cat : Meower {
    func meow() { print("meow") }
}
class CalicoCat : Cat {
}</pre>

<p class="author1">Now it is legal to say:</p>

<pre data-type="programlisting" class="calibre28">let w : Wrapper&lt;Cat&gt; = Wrapper(meower:CalicoCat())</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Associated Type Chains" class="calibre2"><div class="preface" id="calibre_link-2507">
<h2 class="calibre42">Associated Type Chains</h2>

<p class="author1">When a generic placeholder is constrained to a generic protocol with an associated type, you can refer to that type using a dot-notation chain: the placeholder name, a dot, and the associated type name.<a data-type="indexterm" data-primary="associated type chains" id="calibre_link-223" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="associated type chains" id="calibre_link-949" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="associated type" data-tertiary="chaining" id="calibre_link-1792" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="chains" data-secondary="associated type" id="calibre_link-353" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s an example. Imagine that in a game program, soldiers and archers are enemies of one another. Iâ€™ll express this by subsuming a Soldier struct and an Archer struct under a Fighter protocol that has an Enemy associated type, which is itself constrained to be a Fighter:</p>

<pre data-type="programlisting" class="calibre28">protocol Fighter {
    associatedtype Enemy : Fighter
}</pre>

<p class="author1">Iâ€™ll resolve that associated type manually for both the Soldier and the Archer structs:</p>

<pre data-type="programlisting" class="calibre28">struct Soldier : Fighter {
    typealias Enemy = Archer
}
struct Archer : Fighter {
    typealias Enemy = Soldier
}</pre>

<p class="author1">Now Iâ€™ll create a generic struct to express the opposing camps of these fighters:</p>

<pre data-type="programlisting" class="calibre28">struct Camp&lt;T:Fighter&gt; {
}</pre>

<p class="author1">Now suppose that a camp may contain a spy from the opposing camp. What is the type of that spy? Well, if this is a Soldier camp, itâ€™s an Archer; and if itâ€™s an Archer camp, itâ€™s a Soldier. More generally, since T is a Fighter, itâ€™s the type of the Enemy of this adopter of Fighter. I can express that neatly by a chain consisting of the placeholder name <code class="calibre19">T</code>, a dot, and the associated type name <code class="calibre19">Enemy</code>:</p>

<pre data-type="programlisting" class="calibre28">struct Camp&lt;T:Fighter&gt; {
    var spy : T.Enemy?
}</pre>

<p class="author1">The result is that if, for a particular Camp, T is resolved to Soldier, <code class="calibre19">T.Enemy</code> means Archer &mdash; and <em class="calibre11">vice versa</em>. We have created a correct and inviolable rule for the type that a Campâ€™s <code class="calibre19">spy</code> must be. This wonâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">var c = Camp&lt;Soldier&gt;()
c.spy = Soldier() // compile error</pre>

<p class="author1">Weâ€™ve tried to assign an object of the wrong type to this Campâ€™s <code class="calibre19">spy</code> property. But this does compile:</p>

<pre data-type="programlisting" class="calibre28">var c = Camp&lt;Soldier&gt;()
c.spy = Archer()</pre>

<p class="author1">A generic protocol might have an associated type which is constrained to a generic protocol that <em class="calibre11">also</em> has an associated type. Therefore, longer chains of associated type names are possible. For example, letâ€™s give each type of Fighter a characteristic weapon: a soldier has a sword, while an archer has a bow. Iâ€™ll make a Sword struct and a Bow struct, and Iâ€™ll unite them under a Wieldable protocol:</p>

<pre data-type="programlisting" class="calibre28">protocol Wieldable {
}
struct Sword : Wieldable {
}
struct Bow : Wieldable {
}</pre>

<p class="author1">Iâ€™ll add a Weapon associated type to Fighter, which is constrained to be a Wieldable, and once again Iâ€™ll resolve it manually for each type of Fighter:</p>

<pre data-type="programlisting" class="calibre28">protocol Fighter {
    associatedtype Enemy : Fighter
    associatedtype Weapon : Wieldable
}
struct Soldier : Fighter {
    typealias Weapon = Sword
    typealias Enemy = Archer
}
struct Archer : Fighter {
    typealias Weapon = Bow
    typealias Enemy = Soldier
}</pre>

<p class="author1">Now letâ€™s say that every Fighter has the ability to steal his enemyâ€™s weapon. Iâ€™ll give the Fighter generic protocol a <code class="calibre19">steal(weapon:from:)</code> method. How can the Fighter generic protocol express the parameter types in a way that causes its adopter to declare this method with the proper types?</p>

<p class="author1">The <code class="calibre19">from:</code> parameter type is this Fighterâ€™s Enemy. We already know how to express that: itâ€™s the placeholder plus dot-notation with the associated type name. Here, the placeholder is the adopter of this protocol &mdash; namely, <code class="calibre19">Self</code>. So the <code class="calibre19">from:</code> parameter type is <code class="calibre19">Self.Enemy</code>. And what about the <code class="calibre19">weapon:</code> parameter type? Thatâ€™s the Weapon of that Enemy! So the <code class="calibre19">weapon:</code> parameter type is <code class="calibre19">Self.Enemy.Weapon</code>:<a data-type="indexterm" data-primary="Self" id="calibre_link-1988" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol Fighter {
    associatedtype Enemy : Fighter
    associatedtype Weapon : Wieldable
    func steal(weapon:Self.Enemy.Weapon, from:Self.Enemy)
}</pre>

<p class="author1">(We could omit <code class="calibre19">Self</code> from that code, and it would compile and would mean the same thing. But <code class="calibre19">Self</code> would still be the implicit start of the chain, and I think explicit <code class="calibre19">Self</code> makes the meaning of the code clearer.)</p>

<p class="author1">The result is that the following declarations for Soldier and Archer correctly adopt the Fighter protocol, and the compiler approves:</p>

<pre data-type="programlisting" class="calibre28">struct Soldier : Fighter {
    typealias Weapon = Sword
    typealias Enemy = Archer
    func steal(weapon:Bow, from:Archer) {
    }
}
struct Archer : Fighter {
    typealias Weapon = Bow
    typealias Enemy = Soldier
    func steal(weapon:Sword, from:Soldier) {
    }
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Where Clauses" class="calibre2"><div class="preface" id="calibre_link-2508">
<h2 class="calibre42">Where Clauses</h2>

<p class="author1">The most flexible way to express a type constraint is to add a where clause. Before I tell you what a where clause looks like, Iâ€™ll tell you where it goes:<a data-type="indexterm" data-primary="generics" data-secondary="where clauses" id="calibre_link-968" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="where" id="calibre_link-2364" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="type constraints" data-tertiary="multiple" id="calibre_link-966" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="constraints" data-tertiary="multiple" id="calibre_link-2231" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="constraints, type" data-secondary="multiple" id="calibre_link-544" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">For a generic function, a where clause may appear after the signature declaration (after the parameter list, following the arrow operator and return type if included).</p>
</li>
<li class="calibre12">
<p class="calibre17">For a generic type, a where clause may appear after the type declaration, before the curly braces.</p>
</li>
<li class="calibre12">
<p class="calibre17">For a generic protocol, a where clause may appear after the protocol declaration, before the curly braces.</p>
</li>
<li class="calibre12">
<p class="calibre17">For an associated type in a generic protocol, a where clause may appear at the end of the associated type declaration.</p>
</li>
</ul>

<p class="author1">Now letâ€™s talk about the syntax of a where clause. It starts with the keyword <code class="calibre19">where</code>. Then what? One possibility is a comma-separated list of additional constraints on an already declared placeholder. For example, you already know that we can constrain a placeholder at the point of declaration, using a colon and a type (which might be a protocol composition):<a data-type="indexterm" data-primary="comma" data-secondary="generic constraints" id="calibre_link-476" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func flyAndWalk&lt;T: Flier&gt; (_ f:T) {}
func flyAndWalk2&lt;T: Flier &amp; Walker&gt; (_ f:T) {}
func flyAndWalk3&lt;T: Flier &amp; Dog&gt; (_ f:T) {}</pre>

<p class="author1">Using a where clause, we can move those constraints out of the angle brackets. No new functionality is gained, but the resulting notation is arguably neater:</p>

<pre data-type="programlisting" class="calibre28">func flyAndWalk&lt;T&gt; (_ f:T) where T: Flier {}
func flyAndWalk2&lt;T&gt; (_ f:T) where T: Flier &amp; Walker {}
func flyAndWalk2a&lt;T&gt; (_ f:T) where T: Flier, T: Walker {}
func flyAndWalk3&lt;T&gt; (_ f:T) where T: Flier &amp; Dog {}
func flyAndWalk3a&lt;T&gt; (_ f:T) where T: Flier, T: Dog {}</pre>

<p class="author1">When a constraint on a placeholder is a generic protocol with an associated type, you can use an associated type chain to impose additional constraints <em class="calibre11">on the associated type</em>. This pseudocode shows what I mean (Iâ€™ve omitted the content of the where clause, to focus on what the where clause will be constraining):<a data-type="indexterm" data-primary="protocols" data-secondary="generic" data-tertiary="constraining associated type" id="calibre_link-1806" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="associated type" data-tertiary="constraining" id="calibre_link-1793" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="protocols" data-tertiary="constraining associated type" id="calibre_link-958" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    associatedtype Other
}
func flockTogether&lt;T&gt; (_ f:T) where T:Flier, T.Other /* ... */ {}</pre>

<p class="author1">In that pseudocode, the placeholder T is constrained to be a Flier &mdash; and Flier is itself a generic protocol, with an associated type Other. Therefore, whatever type resolves T will resolve Other. We can thus proceed to constrain the types eligible to resolve <code class="calibre19">T.Other</code> &mdash; and this, in turn, will further constrain by implication the types eligible to resolve T.</p>

<p class="author1">So now letâ€™s fill in the blank in our pseudocode. What sort of restriction are we allowed to impose here? One possibility is a colon expression, as for any type constraint:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    associatedtype Other
}
struct Bird : Flier {
    typealias Other = String
}
struct Insect : Flier {
    typealias Other = Bird
}
func flockTogether&lt;T&gt; (_ f:T) where T:Flier, T.Other:Equatable {}</pre>

<p class="author1">Both Bird and Insect adopt Flier. The <code class="calibre19">flockTogether</code> function can be called with a Bird argument, because a Birdâ€™s Other associated type is resolved to String, which adopts the built-in Equatable protocol. But <code class="calibre19">flockTogether</code> canâ€™t be called with an Insect argument, because an Insectâ€™s Other associated type is resolved to Bird, which <em class="calibre11">doesnâ€™t</em> adopt the Equatable protocol:</p>

<pre data-type="programlisting" class="calibre28">flockTogether(Bird()) // okay
flockTogether(Insect()) // compile error</pre>

<p class="author1">The other possibility is the equality operator <code class="calibre19">==</code> followed by a type or an associated type chain, and the constrained type must then match it <em class="calibre11">exactly:</em></p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    associatedtype Other
}
struct Bird : Flier {
    typealias Other = String
}
struct Insect : Flier {
    typealias Other = Int
}
func flockTwoTogether&lt;T,U&gt; (_ f1:T, _ f2:U)
    where T:Flier, U:Flier, T.Other == U.Other {}</pre>

<p class="author1">The <code class="calibre19">flockTwoTogether</code> function can be called with a Bird and a Bird, and it can be called with an Insect and an Insect, but it canâ€™t be called with an Insect and a Bird, because they donâ€™t resolve the Other associated type to the same type.</p>

<p class="author1">The Swift header makes extensive use of where clauses with an <code class="calibre19">==</code> operator, especially as a way of restricting a sequence type. Take, for example, the String <code class="calibre19">append(contentsOf:)</code> method, declared like this:</p>

<pre data-type="programlisting" class="calibre28">mutating func append&lt;S&gt;(contentsOf newElements: S)
    where S:Sequence, S.Element == Character</pre>

<p class="author1">The Sequence protocol has an Element associated type, representing the type of the sequenceâ€™s elements. This where clause thus means that a sequence of characters &mdash; but <em class="calibre11">not</em> a sequence of something else, such as Int &mdash; can be concatenated to a String:</p>

<pre data-type="programlisting" class="calibre28">var s = "hello"
s.append(contentsOf: Array(" world")) // "hello world"
s.append(contentsOf: ["!" as Character, "?" as Character])</pre>

<p class="author1">The Array <code class="calibre19">append(contentsOf:)</code> method is declared a little differently:</p>

<pre data-type="programlisting" class="calibre28">mutating func append&lt;S&gt;(contentsOf newElements: S)
    where S:Sequence, S.Element == Self.Element</pre>

<p class="author1">An array is a sequence; its element type is its Element associated type. The where clause thus means that you can append to an Array the elements of any sort of Sequence, but only if they are the same kind of element as the elements of this array. If the array consists of String elements, you can add more String elements to it, but not Int elements.</p>

<p class="author1">(Actually, the <code class="calibre19">append(contentsOf:)</code> declaration in the Swift header doesnâ€™t say <code class="calibre19">S.Element == Self.Element</code>; it says <code class="calibre19">Element == S.Element</code>. But they are equivalent expressions. <code class="calibre19">Self</code> can be omitted at the start of an associated type chain (as Iâ€™ve already mentioned), and <code class="calibre19">==</code> is commutative: the equated types can be written in either order.)</p>

<p class="author1">A generic protocol or its associated type can have a where clause. The chief effect is to reduce the length of associated type chains. For example, the Sequence generic protocol has an associated type Iterator, which is constrained to be an adopter of the generic IteratorProtocol, which in turn has an associated type Element. Thus, the Swift headers used to be peppered with where clauses constraining a type to a sequenceâ€™s <span class="publishername">Iterator.Element</span>. In Swift 4 and later, however, the introduction of associated type where clauses means that a Sequence itself can have an Element associated type which simply <em class="calibre11">is</em> its <span class="publishername">Iterator.Element</span>:</p>

<pre data-type="programlisting" class="calibre28">protocol Sequence {
    associatedtype Iterator : IteratorProtocol
    associatedtype Element where Self.Element == Self.Iterator.Element
    // ...
}</pre>

<p class="author1">As a result, wherever the Swift header used to say <code class="calibre19">Iterator.Element</code>, it can now say simply <code class="calibre19">Element</code> instead (as in the String and Array <code class="calibre19">append(contentsOf:)</code> declarations I cited a moment ago). <a data-type="indexterm" data-startref="idxgenerics" id="calibre_link-947" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Extensions" class="calibre2"><div class="preface" id="calibre_link-2509">
<h1 class="calibre18">Extensions</h1>

<p class="author1">An <em class="calibre11">extension</em> is a way of injecting your own code into an object type that has already been declared elsewhere; you are <em class="calibre11">extending</em> an existing object type. You can extend your own object types; you can also extend one of Swiftâ€™s object types or one of Cocoaâ€™s object types, in which case you are <em class="calibre11">adding functionality</em> to a type that doesnâ€™t belong to you!
<a data-type="indexterm" data-primary="extensions" data-seealso="categories" id="calibre_link-825" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="extend" data-see="extensions" id="calibre_link-2943" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Extension declaration can take place only at the top level of a file. To declare an extension, put the keyword <code class="calibre19">extension</code> followed by the name of an existing object type, then optionally a colon plus the names of any protocols you want to add to the list of those adopted by this type, and finally curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-590" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> containing the usual things that go inside an object type declaration &mdash; with the following restrictions:<a data-type="indexterm" data-primary="declaration" data-secondary="of extensions" id="calibre_link-625" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="extensions" data-secondary="declaring" id="calibre_link-827" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="extensions" data-secondary="restrictions on" id="calibre_link-835" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">An extension canâ€™t declare a stored property (but it can declare a computed <span class="publishername">property).</span></p>
</li>
<li class="calibre12">
<p class="calibre17">An extension of a class canâ€™t declare a designated initializer or a deinitializer (but it can declare a convenience initializer).</p>
</li>
<li class="calibre12">
<p class="calibre17">An extension canâ€™t override an existing member (but it can overload an existing method), and a method declared in an extension canâ€™t be overridden.<a data-type="indexterm" data-primary="extensions" data-secondary="overrides" id="calibre_link-832" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="overriding" data-secondary="extensions" id="calibre_link-1651" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">In my real programming life, I sometimes extend a built-in Swift or Cocoa type just to inject some missing functionality by expressing it as a property or method.<a data-type="indexterm" data-primary="extensions" data-secondary="object types" id="calibre_link-830" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="extensions" id="calibre_link-1492" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="methods, overriding" data-tertiary="extensions" id="calibre_link-386" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="overriding" data-tertiary="extensions" id="calibre_link-1347" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, Cocoaâ€™s Core Graphics framework has many useful functions associated with the CGRect struct, and Swift already extends CGRect to add some helpful properties and methods; but thereâ€™s no shortcut for getting the center point (a CGPoint) of a CGRect, something that in practice is often needed. I extend CGRect to give it a <code class="calibre19">center</code> property:</p>

<pre data-type="programlisting" class="calibre28">extension CGRect {
    var center : CGPoint {
        return CGPoint(x:self.midX, y:self.midY)
    }
}</pre>

<p class="author1">String ranges, as weâ€™ve already seen, are hard to construct, because they are a range of <span class="publishername">String.Index</span> rather than Int. We can extend String with methods that take an Int index and a count, yielding a Swift Range; while weâ€™re up, letâ€™s permit a negative index, as most modern languages do:<a data-type="indexterm" data-primary="ranges" data-secondary="string" id="calibre_link-1851" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">extension String {
    func range(_ start:Int, _ count:Int) -&gt; Range&lt;String.Index&gt; {
        let i = self.index(start &gt;= 0 ?
            self.startIndex :
            self.endIndex, offsetBy: start)
        let j = self.index(i, offsetBy: count)
        return i..&lt;j
    }
}</pre>

<p class="author1">An extension can declare a static or class member; this can be a good way to slot a global function into an appropriate namespace. For example, in one of my apps, I find myself frequently using a certain color (a UIColor). Instead of creating that color repeatedly, it makes sense to encapsulate the instructions for generating it in a global function. But instead of making that function <em class="calibre11">completely</em> global, I make it &mdash; appropriately enough &mdash; a read-only static property of UIColor:<a data-type="indexterm" data-primary="global functions" data-secondary="class method instead" id="calibre_link-979" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="namespaces" id="calibre_link-1380" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="global" data-tertiary="class method instead" id="calibre_link-920" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">extension UIColor {
    static var myGolden : UIColor {
        return self.init(
            red:1.000, green:0.894, blue:0.541, alpha:0.900
        )
    }
}</pre>

<p class="author1">Now I can use that color throughout my code as <code class="calibre19">UIColor.myGolden</code>, completely parallel to built-in class properties such as <code class="calibre19">UIColor.red</code>.</p>

<p class="author1">Extensions on oneâ€™s own object types can help to organize oneâ€™s code. A frequently used convention is to add an extension for each protocol oneâ€™s object type needs to adopt, like this:<a data-type="indexterm" data-primary="extensions" data-secondary="object types" id="calibre_link-831" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
    // ... UIViewController method overrides go here ...
}
extension ViewController : UIPopoverPresentationControllerDelegate {
    // ... UIPopoverPresentationControllerDelegate methods go here ...
}
extension ViewController : UIToolbarDelegate {
    // ... UIToolbarDelegate methods go here ...
}</pre>

<p class="author1">An extension on your own object type can also be a way to spread your definition of that object type over multiple files, if you feel that several shorter files are better than one long file.<a data-type="indexterm" data-primary="object types" data-secondary="definition over multiple files" id="calibre_link-1491" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">When you extend a Swift struct, a curious thing happens with initializers: it becomes possible to declare an initializer and keep the implicit initializers:<a data-type="indexterm" data-primary="structs" data-secondary="initializers" data-tertiary="extensions" id="calibre_link-2126" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="extensions" data-secondary="structs" id="calibre_link-836" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Digit {
    var number : Int
}
extension Digit {
    init() {
        self.init(number:42)
    }
}</pre>

<p class="author1">In that code, the explicit declaration of an initializer through an extension did not cause us to lose the implicit memberwise initializer, as would have happened if we had declared the same initializer inside the original struct declaration. Now we can instantiate a Digit by calling the explicitly declared initializer &mdash; <code class="calibre19">Digit()</code> &mdash; or by calling the implicit memberwise initializer &mdash; <code class="calibre19">Digit(number:7)</code>.</p>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2944">
<h5 class="calibre36">Class Extensions and Overrides</h5>
<p class="calibre37">The rules about class extensions and overrides are more complicated than Iâ€™ve stated. Letâ€™s say we have a class Dog and its subclass NoisyDog. Then:</p>

<ul class="calibre50">
<li class="calibre12">
<p class="calibre51">If we have an extension on Dog that declares a method, NoisyDog <em class="calibre11">can</em> override it <em class="calibre11">if</em> the Dog extension method is exposed to Objective-C.</p>
</li>
<li class="calibre12">
<p class="calibre51">If we have a method in Dog, an extension on NoisyDog <em class="calibre11">can</em> override it <em class="calibre11">if</em> Dogâ€™s method is exposed to Objective-C and marked <code class="calibre19">dynamic</code>.</p>
</li>
</ul>

<p class="calibre37">So a native Swift method in an extension can neither override nor be overridden, but then Objective-C comes along with its own rules and messes everything up. Things are made even messier by the existence of modules; if thereâ€™s a class with a method in a module, an extension on that class in another module can declare <em class="calibre11">the same method</em>, not overriding but effectively replacing it. No doubt Apple will eventually straighten all this out.</p>
</div>
</aside>








<section data-type="sect2" data-pdf-bookmark="Extending Protocols" class="calibre2"><div class="preface" id="calibre_link-2510">
<h2 class="calibre42">Extending Protocols</h2>

<p class="author1">When you extend a protocol, you can add methods and properties to the protocol, just as for any object type. Unlike a protocol declaration, these methods and properties are not mere requirements, to be fulfilled by the adopter of the protocol; they are actual methods and properties, to be <em class="calibre11">inherited</em> by the adopter of the protocol:<a data-type="indexterm" data-primary="extensions" data-secondary="protocols" id="calibre_link-833" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="extensions" id="calibre_link-1801" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
}
extension Flier {
    func fly() {
        print("flap flap flap")
    }
}
struct Bird : Flier {
}</pre>

<p class="author1">Observe that Bird can now adopt Flier without implementing the <code class="calibre19">fly</code> method.
Thatâ€™s because the Flier protocol extension <em class="calibre11">supplies</em> the <code class="calibre19">fly</code> method! Bird thus <em class="calibre11">inherits</em> an implementation of <code class="calibre19">fly</code>:</p>

<pre data-type="programlisting" class="calibre28">let b = Bird()
b.fly() // flap flap flap</pre>

<p class="author1">Of course, an adopter can still provide its own implementation of a method inherited from a protocol extension:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
}
extension Flier {
    func fly() {
        print("flap flap flap")
    }
}
struct Insect : Flier {
    func fly() {
        print("whirr")
    }
}
let i = Insect()
i.fly() // whirr</pre>

<p class="author1">But be warned: this kind of inheritance is <em class="calibre11">not polymorphic</em>. The adopterâ€™s implementation is not an override; it is merely another implementation. The internal identity rule does <em class="calibre11">not</em> apply; it matters how a reference is typed:</p>

<pre data-type="programlisting" class="calibre28">let f : Flier = Insect()
f.fly() // flap flap flap (!!)</pre>

<p class="author1">Even though <code class="calibre19">f</code> is internally an Insect (as we can discover with the <code class="calibre19">is</code> operator), the <code class="calibre19">fly</code> message is being sent to an object reference typed as Flier, so it is Flierâ€™s implementation of the <code class="calibre19">fly</code> method that is called, not Insectâ€™s implementation.</p>

<p class="author1">To get something that looks like polymorphic inheritance, we must also declare <code class="calibre19">fly</code> as a requirement <em class="calibre11">in the original protocol</em>:</p>

<pre data-type="programlisting" class="calibre28">protocol Flier {
    func fly() // *
}
extension Flier {
    func fly() {
        print("flap flap flap")
    }
}
struct Insect : Flier {
    func fly() {
        print("whirr")
    }
}</pre>

<p class="author1">Now an Insect maintains its internal integrity:</p>

<pre data-type="programlisting" class="calibre28">let f : Flier = Insect()
f.fly() // whirr</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Extending Generics" class="calibre2"><div class="preface" id="calibre_link-2511">
<h2 class="calibre42">Extending Generics</h2>

<p class="author1">When you extend a generic type, the placeholder type names are visible to your extension declaration. Thatâ€™s good, because you might need to use them; but it can make your code a little mystifying, because you seem to be using an undefined type name out of the blue. It might be a good idea to add a comment, to remind yourself what youâ€™re up to:<a data-type="indexterm" data-primary="generics" data-secondary="extensions" id="calibre_link-953" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="generic" data-tertiary="extensions" id="calibre_link-1495" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="extensions" data-secondary="generics" id="calibre_link-828" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog&lt;T&gt; {
    var name : T?
}
extension Dog {
    func sayYourName() -&gt; T? { // T? is the type of self.name
        return self.name
    }
}</pre>

<p class="author1">A generic type extension declaration can include a where clause. Similar to a generic constraint, this limits which resolvers of the generic can call the code <em class="calibre11">injected by this extension</em>, and assures the compiler that your code is legal for those resolvers.<a data-type="indexterm" data-primary="generics" data-secondary="where clauses" data-tertiary="extensions" id="calibre_link-969" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="where" id="calibre_link-2365" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="type constraints" data-tertiary="extensions" id="calibre_link-965" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="constraints, type" data-secondary="extensions" id="calibre_link-543" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="extensions" data-secondary="generics" data-tertiary="type constraints" id="calibre_link-829" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For instance, recall this example from earlier in this chapter:</p>

<pre data-type="programlisting" class="calibre28">func myMin&lt;T:Comparable&gt;(_ things:T...) -&gt; T {
    var minimum = things.first!
    for item in things.dropFirst() {
        if item &lt; minimum {
            minimum = item
        }
    }
    return minimum
}</pre>

<p class="author1">Thatâ€™s a global function. Iâ€™d prefer to inject it into Array as a method. Array is a generic struct whose placeholder type is called Element. To make this work, I need somehow to bring along the Comparable type constraint that makes this code legal; without it, as you remember, my use of <code class="calibre19">&lt;</code> wonâ€™t compile. I can do that with a where clause:<a data-type="indexterm" data-primary="protocols" data-secondary="extensions" data-tertiary="constraining associated type" id="calibre_link-1803" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">extension Array where Element:Comparable {
    func myMin() -&gt; Element? {
        var minimum = self.first
        for item in self.dropFirst() {
            if item &lt; minimum! {
                minimum = item
            }
        }
        return minimum
    }
}</pre>

<p class="author1">The where clause is a constraint guaranteeing that this arrayâ€™s elements adopt Comparable, so the compiler permits the use of the <code class="calibre19">&lt;</code> operator &mdash; and it doesnâ€™t permit the <code class="calibre19">myMin</code> method to be called on an array whose elements <em class="calibre11">donâ€™t</em> adopt Comparable. The Swift standard library makes heavy use of that sort of thing, and in fact Sequence has a <code class="calibre19">min</code> method declared like <code class="calibre19">myMin</code>.</p>

<p class="author1">Starting in Swift 4.1, the same syntax can be used to express <em class="calibre11">conditional conformance</em> to a protocol. The idea is that a generic type should adopt a certain protocol only if something is true of its placeholder type &mdash; and the extension then contains whatever is needed to satisfy the protocol requirements when thatâ€™s the case.<a data-type="indexterm" data-primary="conditional conformance" id="calibre_link-515" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conformance, conditional" id="calibre_link-522" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="adopting" data-tertiary="conditionally" id="calibre_link-1790" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="adopting protocol conditionally" id="calibre_link-948" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In the standard library, conditional conformance fills what used to be a serious hole in the Swift language. For example, an Array can consist of Equatable<a data-type="indexterm" data-primary="Equatable" id="calibre_link-774" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> elements, and in that case it is possible to compare two arrays for equality:</p>

<pre data-type="programlisting" class="calibre28">let arr1 = [1,2,3]
let arr2 = [1,2,3]
if arr1 == arr2 { // ...</pre>

<p class="author1">Itâ€™s clear what array equality should consist of: the two arrays should consist of the same elements in the same order. The elements must be Equatable so as to guarantee the meaningfulness of the notion â€œsame elements.â€</p>

<p class="author1">Ironically, however, there was, before Swift 4.1, no way to compare two arrays of arrays:</p>

<pre data-type="programlisting" class="calibre28">let arr1 = [[1], [2], [3]]
let arr2 = [[1], [2], [3]]
let arr1 == arr2 { // compile error before Swift 4.1</pre>

<p class="author1">Thatâ€™s because there was no coherent way to make Array <em class="calibre11">itself</em> Equatable &mdash; because there was no way to assert that Array should be Equatable only just in case its elements are Equatable. Thatâ€™s conditional conformance! Now that conditional conformance exists, the standard library says:</p>

<pre data-type="programlisting" class="calibre28">extension Array : Equatable where Element : Equatable {
    // ...
}</pre>

<p class="author1">And so comparing arrays of arrays becomes legal:</p>

<pre data-type="programlisting" class="calibre28">let arr1 = [[1], [2], [3]]
let arr2 = [[1], [2], [3]]
let arr1 == arr2 { // fine</pre>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Umbrella Types" class="calibre2"><div class="preface" id="calibre_link-2512">
<h1 class="calibre18">Umbrella Types</h1>

<p class="author1">Swift provides a few built-in types as general umbrella types, capable of embracing multiple real types under a single heading.<a data-type="indexterm" data-primary="classes" data-secondary="umbrella type" id="calibre_link-399" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="umbrella types" id="calibre_link-2266" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="id" id="calibre_link-1031" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="id" id="calibre_link-1523" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="umbrella types" id="calibre_link-1509" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Any" class="calibre2"><div class="preface" id="calibre_link-2513">
<h2 class="calibre42">Any</h2>

<p class="author1">The Any type is the universal Swift umbrella type. Where an Any object is expected, absolutely any object or function can be passed, without casting:<a data-type="indexterm" data-primary="Any" id="calibre_link-140" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func anyExpecter(_ a:Any) {}
anyExpecter("howdy")     // a struct instance
anyExpecter(String.self) // a struct type
anyExpecter(Dog())       // a class instance
anyExpecter(Dog.self)    // a class type
anyExpecter(anyExpecter) // a function</pre>

<p class="author1">Going the other way, if you want to type an Any object as a more specific type, you will generally have to cast down. Such a cast is legal for any specific object type or function type. A forced cast isnâ€™t safe, but you can easily make it safe, because you can also test an Any object against any specific object type or function type. Here, <code class="calibre19">anything</code> is typed as Any:</p>

<pre data-type="programlisting" class="calibre28">if anything is String {
    let s = anything as! String
    // ...
}</pre>

<p class="author1">(In <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> Iâ€™ll introduce a more elegant syntax for casting down safely.)</p>

<p class="author1">The Any umbrella type is the general medium of interchange between Swift and the Cocoa Objective-C APIs. When an Objective-C object type is nonspecific (Objective-C <code class="calibre19">id</code>), it will appear to Swift as Any. Commonly encountered examples are UserDefaults and key&ndash;value coding (<a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>); these allow you to <em class="calibre11">pass</em> an object of indeterminate class along with a string key name, and they allow you to <em class="calibre11">retrieve</em> an object of indeterminate class by a string key name. That object is typed, in Swift, as Any (or as an Optional wrapping Any, so that it can be <code class="calibre19">nil</code>):<a data-type="indexterm" data-primary="bridged types" data-secondary="Any and id" id="calibre_link-279" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
ud.set(Date(), forKey:"now") // Date to Any</pre>

<p class="author1">The first parameter of UserDefaults <code class="calibre19">set(_:forKey:)</code> is typed as Any. Thus, Any functions as a general conduit for crossing the bridge between the Swift world and Cocoaâ€™s Objective-C world.</p>

<p class="author1">When a Swift object is assigned or passed to an Any that acts as a conduit to Objective-C, it crosses the bridge to Objective-C. Even though you donâ€™t have to cast it, if the objectâ€™s type is not an Objective-C type (a class derived from NSObject), it will be transformed in order to cross the bridge. If this type is automatically bridged to an Objective-C class type, it becomes that type; other types are boxed up in a way that allows them to survive the journey into Objective-Câ€™s world, even though Objective-C canâ€™t deal with them directly. (For full details, see <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>.)</p>

<p class="author1">To illustrate, suppose we have an Objective-C class Thing with a method <code class="calibre19">take1id:</code>, declared like this:</p>

<pre data-type="programlisting" class="calibre28">- (void) take1id: (id) anid;</pre>

<p class="author1">That appears to Swift as:</p>

<pre data-type="programlisting" class="calibre28">func take1id(_ anid: Any)</pre>

<p class="author1">When we pass an object to <code class="calibre19">take1Id(_:)</code> as its parameter, it crosses the bridge:</p>

<pre data-type="programlisting" class="calibre28">let t = Thing()
t.take1id("howdy")  // String to NSString
t.take1id(1)        // Int to NSNumber
t.take1id(CGRect()) // CGRect to NSValue
t.take1id(Date())   // Date to NSDate
t.take1id(Bird())   // Bird (struct) to boxed type</pre>

<p class="author1">Coming back the other way, if Objective-C hands you an Any object, you will need to cast it down to its underlying type in order to do anything useful with it:</p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
let d = ud.object(forKey:"now")
if d is Date {
    let d = d as! Date
    // ...
}</pre>

<p class="author1">The result returned from UserDefaults <code class="calibre19">object(forKey:)</code> is typed as Any &mdash; actually, as an Optional wrapping an Any, because UserDefaults might need to return <code class="calibre19">nil</code> to indicate that no object exists for that key. But you know that itâ€™s supposed to be a date, so you cast it down to Date.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="AnyObject" class="calibre2"><div class="preface" id="calibre_link-2514">
<h2 class="calibre42">AnyObject</h2>

<p class="author1">AnyObject is an empty protocol with the special feature that <em class="calibre11">all class types</em> conform to it automatically. Although Objective-C APIs present Objective-C <code class="calibre19">id</code> as Any in Swift, Swift AnyObject <em class="calibre11">is</em> Objective-C <code class="calibre19">id</code>. AnyObject is useful primarily when you want to take advantage of the <em class="calibre11">behavior</em> of Objective-C <code class="calibre19">id</code>, as Iâ€™ll demonstrate in a moment. <a data-type="indexterm" data-primary="AnyObject" id="calibre_link-143" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A class type can be assigned directly where an AnyObject is expected; to retrieve it as its original type, youâ€™ll need to cast down:<a data-type="indexterm" data-primary="bridged types" data-secondary="AnyObject and id" id="calibre_link-281" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
}
let d = Dog()
let anyo : AnyObject = d
let d2 = anyo as! Dog</pre>

<p class="author1">Assigning a nonclass type to an AnyObject requires casting (with <code class="calibre19">as</code>). The bridge to Objective-C is then crossed immediately, as I described for Any in the preceding <span class="publishername">section:</span></p>

<pre data-type="programlisting" class="calibre28">let s = "howdy" as AnyObject  // String to NSString to AnyObject
let i = 1 as AnyObject        // Int to NSNumber to AnyObject
let r = CGRect() as AnyObject // CGRect to NSValue to AnyObject
let d = Date() as AnyObject   // Date to NSDate to AnyObject
let b = Bird() as AnyObject   // Bird (struct) to boxed type to AnyObject</pre>










<section data-type="sect3" data-pdf-bookmark="Suppressing type checking" class="calibre2"><div class="preface" id="calibre_link-57">
<h3 class="calibre44">Suppressing type checking</h3>

<p class="author1">Because AnyObject is Objective-C <code class="calibre19">id</code>, it can be used, like Objective-C <code class="calibre19">id</code>, to suspend the compilerâ€™s judgment as to whether a certain message can be sent to an object. Thus, you can send a message to an AnyObject without bothering to cast down to its real type.<a data-type="indexterm" data-primary="type" data-secondary="checking, suppressing" id="calibre_link-2229" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="AnyObject" data-secondary="suppressing type checking" id="calibre_link-146" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You canâ€™t send just any old message to an AnyObject; this is an Objective-C feature, so the message must correspond to a class member that meets one of the following criteria:<a data-type="indexterm" data-primary="objc" id="calibre_link-1480" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">It is a member of an Objective-C class.</p>
</li>
<li class="calibre12">
<p class="calibre17">It is a member of your own Swift subclass of an Objective-C class.</p>
</li>
<li class="calibre12">
<p class="calibre17">It is a member of your own Swift extension of an Objective-C class.</p>
</li>
<li class="calibre12">
<p class="calibre17">It is a member of a Swift class or protocol marked <code class="calibre19">@objc</code>.</p>
</li>
</ul>

<p class="author1">This feature is fundamentally parallel to optional protocol members, which I discussed earlier in this chapter. Letâ€™s start with two classes:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    @objc var noise : String = "woof"
    @objc func bark() -&gt; String {
        return "woof"
    }
}
class Cat {}</pre>

<p class="author1">The Dog property <code class="calibre19">noise</code> and the Dog method <code class="calibre19">bark</code> are marked <code class="calibre19">@objc</code>, so they are visible as potential messages to be sent to an AnyObject. To prove it, Iâ€™ll type a Cat as an AnyObject and send it one of these messages. Letâ€™s start with the <code class="calibre19">noise</code> property:</p>

<pre data-type="programlisting" class="calibre28">let c : AnyObject = Cat()
let s = c.noise</pre>

<p class="author1">That code, amazingly, compiles. Moreover, it doesnâ€™t crash when the code runs! The <code class="calibre19">noise</code> property has been typed as an Optional wrapping its original type. Here, thatâ€™s an Optional wrapping a String. If the object typed as AnyObject doesnâ€™t implement <code class="calibre19">noise</code>, the result is <code class="calibre19">nil</code> and no harm done.</p>

<p class="author1">Now letâ€™s try it with a method call:</p>

<pre data-type="programlisting" class="calibre28">let c : AnyObject = Cat()
let s = c.bark?()</pre>

<p class="author1">Again, that code compiles and is safe. If the Object typed as AnyObject doesnâ€™t implement <code class="calibre19">bark</code>, no <code class="calibre19">bark()</code> call is performed; the method result type has been wrapped in an Optional, so <code class="calibre19">s</code> is typed as <code class="calibre19">String?</code> and has been set to <code class="calibre19">nil</code>. If the AnyObject turns out to have a <code class="calibre19">bark</code> method (for example, if itâ€™s a Dog), the result is an Optional wrapping the returned String. If you call <code class="calibre19">bark!()</code> on the AnyObject instead, the result will be a String, but youâ€™ll crash if the AnyObject doesnâ€™t implement <code class="calibre19">bark</code>. Unlike an optional protocol member, you can even send the message <em class="calibre11">with no unwrapping</em>. This is legal:</p>

<pre data-type="programlisting" class="calibre28">let c : AnyObject = Cat()
let s = c.bark()</pre>

<p class="author1">Thatâ€™s just like force-unwrapping the call: the result is a String, but itâ€™s possible to crash.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Donâ€™t make a habit of sending messages to an AnyObject; because it involves dynamic lookup, itâ€™s expensive at build time and expensive at runtime.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Object identity" class="calibre2"><div class="preface" id="calibre_link-2945">
<h3 class="calibre44">Object identity</h3>

<p class="author1">Sometimes, what you want to know is not what <em class="calibre11">type</em> an object is, but whether an object itself is the <em class="calibre11">particular object</em> you think it is. This problem canâ€™t arise with a value type, but it can arise with a reference type &mdash; in particular, with class instances.<a data-type="indexterm" data-primary="AnyObject" data-secondary="object identity" id="calibre_link-145" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swiftâ€™s solution is the identity operator (<code class="calibre19">===</code>). Its operands are typed as <code class="calibre19">AnyObject?</code>, meaning an object whose type is a class or an Optional whose wrapped type is a class; it compares one object reference with another. This is not a comparison of <em class="calibre11">values</em>, like the equality operator (<code class="calibre19">==</code>); youâ€™re asking whether two object <em class="calibre11">references</em> refer to <em class="calibre11">one and the same</em> object. There is also a negative version (<code class="calibre19">!==</code>) of the identity <span class="publishername">operator.</span><a data-type="indexterm" data-primary="operators" data-secondary="identity" id="calibre_link-1573" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="identity operator" id="calibre_link-1036" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="objects" data-secondary="identity of two" id="calibre_link-1551" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="to same object" id="calibre_link-1874" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A typical use case is that a class instance arrives from Cocoa, and you need to know whether it is in fact a particular object to which you already have a reference. For example, a Notification has an <code class="calibre19">object</code> property that helps identify the notification (usually, it is the original sender of the notification). We can use <code class="calibre19">===</code> to test whether this <code class="calibre19">object</code> is the same as some object to which we already have a reference. However, <code class="calibre19">object</code> is typed as Any (actually, as an Optional wrapping Any), so we must cast to AnyObject in order to take advantage of the identity operator:<a data-type="indexterm" data-startref="idxanyobject" id="calibre_link-144" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@objc func changed(_ n:Notification) {
    let player = MPMusicPlayerController.applicationMusicPlayer
    if n.object as AnyObject === player {
        // ...
    }
}</pre>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="AnyClass" class="calibre2"><div class="preface" id="calibre_link-2515">
<h2 class="calibre42">AnyClass</h2>

<p class="author1">AnyClass is the type of AnyObject. It corresponds to the Objective-C Class type. It arises typically in declarations where a Cocoa API wants to say that a class is expected.<a data-type="indexterm" data-primary="AnyClass" id="calibre_link-141" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="umbrella type" id="calibre_link-400" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, the UIView <code class="calibre19">layerClass</code> class property is declared, in its Swift translation, like this:</p>

<pre data-type="programlisting" class="calibre28">class var layerClass : AnyClass {get}</pre>

<p class="author1">That means: if you override this class property, implement your getter to return a class (which will presumably be a CALayer subclass):</p>

<pre data-type="programlisting" class="calibre28">override class var layerClass : AnyClass { CATiledLayer.self }</pre>

<p class="author1">A reference to an AnyClass object behaves much like a reference to an AnyObject object. You can send it any Objective-C message that Swift knows about &mdash; any Objective-C <em class="calibre11">class</em> message. To illustrate, once again Iâ€™ll start with two classes:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    @objc static var whatADogSays : String = "woof"
}
class Cat {}</pre>

<p class="author1">Objective-C can see <code class="calibre19">whatADogSays</code>, and it sees it as a class property. Therefore you can send <code class="calibre19">whatADogSays</code> to an AnyClass reference:</p>

<pre data-type="programlisting" class="calibre28">let c : AnyClass = Cat.self
let s = c.whatADogSays</pre>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Collection Types" class="calibre2"><div class="preface" id="calibre_link-2516">
<h1 class="calibre18">Collection Types</h1>

<p class="author1">Swift, in common with most modern computer languages, has built-in collection types Array and Dictionary, along with a third type, Set. Array and Dictionary are sufficiently important that the language accommodates them with some special <span class="publishername">syntax.</span><a data-type="indexterm" data-primary="collections" data-secondary="Swift" id="calibre_link-457" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Array" class="calibre2"><div class="preface" id="calibre_link-2517">
<h2 class="calibre42">Array</h2>

<p class="author1">An array (Array, a struct) is an ordered collection of object instances (the <em class="calibre11">elements</em> of the array) accessible by index number, where an index number is an Int numbered from <code class="calibre19">0</code>. Thus, if an array contains four elements, the first has index <code class="calibre19">0</code> and the last has index <code class="calibre19">3</code>. A Swift array cannot be sparse: if there is an element with index <code class="calibre19">3</code>, there is also an element with index <code class="calibre19">2</code> and so on.<a data-type="indexterm" data-primary="Array" id="calibre_link-177" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" id="calibre_link-178" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The salient feature of Swift arrays is their strict typing. Unlike some other computer languages, a Swift arrayâ€™s elements must be <em class="calibre11">uniform</em> &mdash; that is, the array must consist solely of elements of the same definite type. Even an empty array must have a definite element type, despite lacking elements at this moment. An array is itself typed in accordance with its element type. Two arrays whose elements are of different types are considered, themselves, to be of two different types: an array of Int elements has a different type from an array of String elements.</p>

<p class="author1">If all this reminds you of Optionals, it should. Like Optional, Array is a generic. It is declared as <code class="calibre19">Array&lt;Element&gt;</code>, where the placeholder Element is the type of a particular arrayâ€™s elements. And, like Optional types, Array types are covariant, meaning that they behave polymorphically in accordance with their element types: if NoisyDog is a subclass of Dog, then an array of NoisyDog can be used where an array of Dog is expected.</p>

<p class="author1">To declare or state the type of a given arrayâ€™s elements, you could explicitly resolve the generic placeholder; an array of Int elements would thus be an <code class="calibre19">Array&lt;Int&gt;</code>. However, Swift offers syntactic sugar for stating an arrayâ€™s element type, using square brackets around the name of the element type, like this: <code class="calibre19">[Int]</code>. Thatâ€™s the syntax youâ€™ll use most of the time.<a data-type="indexterm" data-primary="arrays" data-secondary="declaration" id="calibre_link-187" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of arrays" id="calibre_link-622" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A literal array is represented as square brackets containing a list of its elements separated by a comma (and optional spaces): for example, <code class="calibre19">[1,2,3]</code>. The literal for an empty array is empty square brackets: <code class="calibre19">[]</code>.<a data-type="indexterm" data-primary="arrays" data-secondary="literal" id="calibre_link-194" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="literals" data-secondary="array" id="calibre_link-1232" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="square brackets" id="calibre_link-2056" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="array literal" id="calibre_link-473" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Arrayâ€™s default initializer <code class="calibre19">init()</code>, called by appending empty parentheses to the arrayâ€™s type, yields an empty array of that type. Thus, you can create an empty array of Int like this:<a data-type="indexterm" data-primary="arrays" data-secondary="initializers" id="calibre_link-193" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var arr = [Int]()</pre>

<p class="author1">Alternatively, if a referenceâ€™s type is known in advance, the empty array <code class="calibre19">[]</code> can be inferred to that type. Thus, you can also create an empty array of Int like this:</p>

<pre data-type="programlisting" class="calibre28">var arr : [Int] = []</pre>

<p class="author1">If youâ€™re starting with a literal array containing elements, you wonâ€™t usually need to declare the arrayâ€™s type, because Swift will infer it by looking at the elements. For example, Swift will infer that <code class="calibre19">[1,2,3]</code> is an array of Int. If the array element types consist of a class and its subclasses, like Dog and NoisyDog, Swift will infer the common superclass as the arrayâ€™s type. However, in some cases you will need to declare an array referenceâ€™s type explicitly even while assigning a literal to that array:<a data-type="indexterm" data-primary="errors, compiler" data-secondary="heterogeneous collection" id="calibre_link-795" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr : [Any] = [1, "howdy"]          // mixed bag
let arr2 : [Flier] = [Insect(), Bird()] // protocol adopters</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If an array variable is declared and initialized to a literal with many elements, itâ€™s a good idea to declare the variableâ€™s type explicitly, saving the compiler from having to examine the entire array to decide its type and thus making compilation faster.</p>
</div>

<p class="author1">Array also has an initializer whose parameter is a sequence. This means that if a type is a sequence, you can split an instance of it into the elements of an array. For <span class="publishername">example:</span><a data-type="indexterm" data-primary="sequence" data-secondary="array initializer" id="calibre_link-1990" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><code class="calibre19">Array(1...3)</code> generates the array of Int <code class="calibre19">[1,2,3]</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">Array("hey")</code> generates the array of Character <code class="calibre19">["h","e","y"]</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">Array(d)</code>, where <code class="calibre19">d</code> is a Dictionary, generates an array of tuples of the key&ndash;value pairs of <code class="calibre19">d</code>.</p>
</li>
</ul>

<p class="author1">Another Array initializer, <code class="calibre19">init(repeating:count:)</code>, lets you populate an array with the same value. In this example, I create an array of 100 Optional strings initialized to <code class="calibre19">nil</code>:</p>

<pre data-type="programlisting" class="calibre28">let strings : [String?] = Array(repeating:nil, count:100)</pre>

<p class="author1">Thatâ€™s the closest you can get in Swift to a sparse array; we have 100 slots, each of which might or might not contain a string (and to start with, none of them do).</p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Beware of using <code class="calibre19">init(repeating:count:)</code> with a reference type! If Dog is a class, and you say <code class="calibre19">let dogs = Array(repeating:Dog(), count:3)</code>, you donâ€™t have an array of three Dogs; you have an array consisting of three <em class="calibre11">references</em> to <em class="calibre11">one</em> Dog. Iâ€™ll give a workaround later.</p>
</div>










<section data-type="sect3" data-pdf-bookmark="Array casting and type testing" class="calibre2"><div class="preface" id="calibre_link-2946">
<h3 class="calibre44">Array casting and type testing</h3>

<p class="author1">When you assign, pass, or cast an array of a certain type to another array type, you are really operating on the individual elements of the array. For example:<a data-type="indexterm" data-primary="arrays" data-secondary="casting" id="calibre_link-185" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr : [Int?] = [1,2,3]</pre>

<p class="author1">That code is actually syntactic sugar: assigning an array of Int where an array of Optionals wrapping Int is expected constitutes a request that each individual Int in the original array should be wrapped in an Optional. And that is exactly what <span class="publishername">happens:</span><a data-type="indexterm" data-primary="Optionals" data-secondary="array of" id="calibre_link-1596" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="Optional" id="calibre_link-197" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr : [Int?] = [1,2,3]
print(arr) // [Optional(1), Optional(2), Optional(3)]</pre>

<p class="author1">Similarly, suppose we have a Dog class and its NoisyDog subclass; then this code is legal:</p>

<pre data-type="programlisting" class="calibre28">let dog1 : Dog = NoisyDog()
let dog2 : Dog = NoisyDog()
let arr = [dog1, dog2]
let arr2 = arr as! [NoisyDog]</pre>

<p class="author1">In the third line, we have an array of Dog. In the fourth line, we apparently cast this array down to an array of NoisyDog &mdash; which really means that we cast each individual Dog in the first array to a NoisyDog. We can crash when we do that, but we wonâ€™t if each element of the first array really <em class="calibre11">is</em> a NoisyDog.</p>

<p class="author1">The <code class="calibre19">as?</code> operator will cast an array to an Optional wrapping an array, which will be <code class="calibre19">nil</code> if the requested cast cannot be performed for each element individually:</p>

<pre data-type="programlisting" class="calibre28">let dog1 : Dog = NoisyDog()
let dog2 : Dog = NoisyDog()
let dog3 : Dog = Dog()
let arr = [dog1, dog2]
let arr2 = arr as? [NoisyDog] // Optional wrapping an array of NoisyDog
let arr3 = [dog2, dog3]
let arr4 = arr3 as? [NoisyDog] // nil</pre>

<p class="author1">You can test each element of an array with the <code class="calibre19">is</code> operator by testing the array itself. For example, given the array of Dog from the previous code, you can say:<a data-type="indexterm" data-primary="arrays" data-secondary="testing element type" id="calibre_link-205" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">if arr is [NoisyDog] { // ...</pre>

<p class="author1">That will be <code class="calibre19">true</code> if each element of the array is in fact a NoisyDog.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Array comparison" class="calibre2"><div class="preface" id="calibre_link-2947">
<h3 class="calibre44">Array comparison</h3>

<p class="author1">Array equality works just as you would expect: two arrays are equal if they contain the same number of elements and all the elements are pairwise equal in order. Of course, this presupposes that the notion â€œequalâ€ is meaningful for these elements:<a data-type="indexterm" data-primary="arrays" data-secondary="equality" id="calibre_link-189" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let i1 = 1
let i2 = 2
let i3 = 3
let arr : [Int] = [1,2,3]
if arr == [i1,i2,i3] { // they are equal!</pre>

<p class="author1">Two arrays donâ€™t have to be of the same type to be compared against one another for equality, but the test wonâ€™t succeed unless they do in fact contain objects that are equal to one another. Here, I compare a Dog array against a NoisyDog array; this is legal if equatability is defined for two Dogs. (For example, Dog might be an NSObject subclass; or you might make Dog adopt Equatable, as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>.) The two arrays are in fact equal, because the dogs they contain are the same dogs in the same order:</p>

<pre data-type="programlisting" class="calibre28">let nd1 = NoisyDog()
let d1 = nd1 as Dog
let nd2 = NoisyDog()
let d2 = nd2 as Dog
let arr1 = [d1,d2] // [Dog]
let arr2 = [nd1,nd2] // [NoisyDog]
if arr1 == arr2 { // they are equal!</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Arrays are value types" class="calibre2"><div class="preface" id="calibre_link-2948">
<h3 class="calibre44">Arrays are value types</h3>

<p class="author1">Because an array is a struct, it is a value type, not a reference type. This means that every time an array is assigned to a variable or passed as argument to a function, it is effectively copied. I do not mean to imply, however, that merely assigning or passing an array is expensive, or that a lot of actual copying takes place every time. If the reference to an array is a constant, clearly no copying is necessary; and even operations that yield a new array derived from another array, or that mutate an array, may be quite efficient. You just have to trust that the designers of Swift have thought about these problems and have implemented arrays efficiently behind the scenes.</p>

<p class="author1">Although an array is <em class="calibre11">itself</em> a value type, its <em class="calibre11">elements</em> might not be. If an array of class instances is assigned to multiple variables, the result is multiple references to the same instances.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Array subscripting" class="calibre2"><div class="preface" id="calibre_link-2949">
<h3 class="calibre44">Array subscripting</h3>

<p class="author1">The Array struct implements subscript methods to allow access to elements using square brackets after a reference to an array. You can use an Int inside the square brackets. For example, in an array consisting of three elements, if the array is referred to by a variable <code class="calibre19">arr</code>, then <code class="calibre19">arr[1]</code> accesses the second element.<a data-type="indexterm" data-primary="subscripting" id="calibre_link-2147" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="subscripting" id="calibre_link-203" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="indexing" id="calibre_link-192" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="indexing an array" id="calibre_link-1054" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can also use a Range of Int inside the square brackets. For example, if <code class="calibre19">arr</code> is an array with three elements, then <code class="calibre19">arr[1...2]</code> signifies the second and third elements. Technically, an expression like <code class="calibre19">arr[1...2]</code> yields something called an ArraySlice, which stands in relation to Array much as Substring stands in relation to String (<a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>). Itâ€™s very similar to an array, and in general you will probably pretend that an ArraySlice <em class="calibre11">is</em> an array. For example, you can subscript an ArraySlice in just the same ways you would subscript an array. Nevertheless, they are not the same thing. An ArraySlice is not a new array; itâ€™s just a way of pointing into a section of the original array. For this reason, its index numbers are those of the original array:<a data-type="indexterm" data-primary="ranges" data-secondary="indexing with" id="calibre_link-1843" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="ArraySlice" id="calibre_link-208" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="slice" id="calibre_link-2039" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = ["manny", "moe", "jack"]
let slice = arr[1...2] // ["moe", "jack"]
print(slice[1]) // moe</pre>

<p class="author1">The ArraySlice <code class="calibre19">slice</code> consists of two elements, <code class="calibre19">"moe"</code> and <code class="calibre19">"jack"</code>, of which <code class="calibre19">"moe"</code> is the first element. But these are not merely <code class="calibre19">"moe"</code> and <code class="calibre19">"jack"</code> taken <em class="calibre11">from</em> the original array, but the <code class="calibre19">"moe"</code> and <code class="calibre19">"jack"</code> <em class="calibre11">in</em> the original array. For this reason, their index numbers are not 0 and 1, but rather 1 and 2, just as in the original array. If you need to extract a new array based on this slice, coerce the slice to an Array:</p>

<pre data-type="programlisting" class="calibre28">let arr2 = Array(slice) // ["moe", "jack"]
print(arr2[1]) // jack</pre>

<p class="author1">If the reference to an array is mutable (<code class="calibre19">var</code>, not <code class="calibre19">let</code>), then a subscript expression can be assigned to. This alters whatâ€™s in that slot. Of course, what is assigned must accord with the type of the arrayâ€™s elements:<a data-type="indexterm" data-primary="arrays" data-secondary="mutating" id="calibre_link-195" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var arr = [1,2,3]
arr[1] = 4 // arr is now [1,4,3]</pre>

<p class="author1">If the subscript is a range, what is assigned must be a slice. You can assign a literal array, because it will be coerced for you to an ArraySlice; but if what youâ€™re starting with is an array reference, youâ€™ll have to coerce it to a slice yourself. Such assignment can change the length of the array being assigned to:</p>

<pre data-type="programlisting" class="calibre28">var arr = [1,2,3]
arr[1..&lt;2] = [7,8] // arr is now [1,7,8,3]
arr[1..&lt;2] = []    // arr is now [1,8,3]
arr[1..&lt;1] = [10]  // arr is now [1,10,8,3] (no element was removed!)
let arr2 = [20,21]
// arr[1..&lt;1] = arr2 // compile error! You have to say this:
arr[1..&lt;1] = ArraySlice(arr2) // arr is now [1,20,21,10,8,3]</pre>

<p class="author1">Subscripting an array with a Range is an opportunity to use partial range notation. The missing value is taken to be the arrayâ€™s first or last index. For example, if <code class="calibre19">arr</code> is <code class="calibre19">[1,2,3]</code>, then <code class="calibre19">arr[1...]</code> is <code class="calibre19">[2,3]</code>, and <code class="calibre19">arr[...1]</code> is <code class="calibre19">[1,2]</code>. Similarly, you can assign into a range specified as a partial range:<a data-type="indexterm" data-primary="ranges" data-secondary="partial" id="calibre_link-1846" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="partial range" id="calibre_link-1687" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var arr = [1,2,3]
arr[1...] = [4,5] // arr is now [1,4,5]</pre>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">It is a runtime error to access an element by an index number larger than the largest element number or smaller than the smallest element number. If <code class="calibre19">arr</code> has three elements, speaking of <code class="calibre19">arr[-1]</code> or <code class="calibre19">arr[3]</code> is not illegal linguistically, but your program will crash.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Nested arrays" class="calibre2"><div class="preface" id="calibre_link-2950">
<h3 class="calibre44">Nested arrays</h3>

<p class="author1">It is legal for the elements of an array to be arrays:<a data-type="indexterm" data-primary="arrays" data-secondary="nested" id="calibre_link-196" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nested arrays" id="calibre_link-1384" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [[1,2,3], [4,5,6], [7,8,9]]</pre>

<p class="author1">Thatâ€™s an array of arrays of Int. Its type declaration, therefore, is <code class="calibre19">[[Int]]</code>. (No law says that the contained arrays have to be the same length; thatâ€™s just something I did for clarity.)</p>

<p class="author1">To access an individual Int inside those nested arrays, you can chain subscripts:</p>

<pre data-type="programlisting" class="calibre28">let arr = [[1,2,3], [4,5,6], [7,8,9]]
let i = arr[1][1] // 5</pre>

<p class="author1">If the outer array reference is mutable, you can also write into a nested array:</p>

<pre data-type="programlisting" class="calibre28">var arr = [[1,2,3], [4,5,6], [7,8,9]]
arr[1][1] = 100</pre>

<p class="author1">You can modify the inner arrays in other ways as well; for example, you can insert additional elements into them.</p>

<p class="author1">Thanks to conditional conformance (discussed earlier in this chapter), nested arrays can be compared with <code class="calibre19">==</code> as long as the inner arrayâ€™s elements are Equatable. For example, if <code class="calibre19">arr</code> and <code class="calibre19">arr2</code> are both <code class="calibre19">[[Int]]</code>, you can compare them by saying <code class="calibre19">arr == arr2</code>.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Basic array properties and methods" class="calibre2"><div class="preface" id="calibre_link-2951">
<h3 class="calibre44">Basic array properties and methods</h3>

<p class="author1">An array is a Collection, which is itself a Sequence. If those terms have a familiar ring, they should: the same is true of a Stringâ€™s underlying character sequence, which I discussed in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>. For this reason, an array and a character sequence bear some striking similarities to one another.</p>

<p class="author1">As a collection, an arrayâ€™s <code class="calibre19">count</code> read-only property reports the number of elements it contains. If an arrayâ€™s <code class="calibre19">count</code> is <code class="calibre19">0</code>, its <code class="calibre19">isEmpty</code> property is <code class="calibre19">true</code>.<a data-type="indexterm" data-primary="count" id="calibre_link-556" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="isEmpty" id="calibre_link-1164" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="properties and methods" id="calibre_link-199" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">An arrayâ€™s <code class="calibre19">first</code> and <code class="calibre19">last</code> read-only properties return its first and last elements, but they are wrapped in an Optional because the array might be empty and so these properties would need to be <code class="calibre19">nil</code>. (This is one of those rare situations in Swift where you can wind up with an Optional wrapping an Optional. For example, consider an array of Optionals wrapping Ints, and what happens when you get its <code class="calibre19">last</code> property.)<a data-type="indexterm" data-primary="first" id="calibre_link-863" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="last" id="calibre_link-1203" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="double-wrapped" id="calibre_link-1606" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">An arrayâ€™s largest accessible index is one less than its <code class="calibre19">count</code>. You may find yourself calculating index values with reference to the <code class="calibre19">count</code>; for example, to refer to the last two elements of <code class="calibre19">arr</code>, you might say:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let slice = arr[arr.count-2...arr.count-1] // [2,3]</pre>

<p class="author1">Swift doesnâ€™t adopt the modern convention of letting you use negative numbers as a shorthand for that calculation. On the other hand, for the common case where you want the last <code class="calibre19">n</code> elements of an array, you can use the <code class="calibre19">suffix(_:)</code> method:<a data-type="indexterm" data-primary="suffix" id="calibre_link-2160" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let slice = arr.suffix(2) // [2,3]</pre>

<p class="author1">Therefore, a neat way to obtain, say, the next-to-last element of an array is to combine <code class="calibre19">suffix</code> with <code class="calibre19">first</code>:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let nextToLast = arr.suffix(2).first // Optional(2)</pre>

<p class="author1">Both <code class="calibre19">suffix(_:)</code> and its companion <code class="calibre19">prefix(_:)</code> yield ArraySlices, and have the remarkable feature that there is no penalty for going out of range:<a data-type="indexterm" data-primary="prefix" id="calibre_link-1718" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let slice = arr.suffix(10) // [1,2,3] (and no crash)</pre>

<p class="author1">Instead of describing the size of the suffix or prefix by its count, you can express the limit of the suffix or prefix by its index. And partial range notation may provide yet another useful alternative:<a data-type="indexterm" data-primary="ranges" data-secondary="partial" id="calibre_link-1847" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="partial range" id="calibre_link-1688" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let slice = arr.suffix(from:1)     // [2,3]
let slice2 = arr[1...]             // [2,3]
let slice3 = arr.prefix(upTo:1)    // [1]
let slice4 = arr.prefix(through:1) // [1,2]</pre>

<p class="author1">An arrayâ€™s <code class="calibre19">startIndex</code> property is <code class="calibre19">0</code>, and its <code class="calibre19">endIndex</code> property is its <code class="calibre19">count</code>. An arrayâ€™s <code class="calibre19">indices</code> property is a half-open range whose endpoints are the arrayâ€™s <code class="calibre19">startIndex</code> and <code class="calibre19">endIndex</code> &mdash; that is, a range accessing the entire array. Moreover, these values are Ints, so you can use ordinary arithmetic operations on them:<a data-type="indexterm" data-primary="startIndex" id="calibre_link-2062" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="endIndex" id="calibre_link-736" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="indices" id="calibre_link-1056" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let slice = arr[arr.endIndex-2..&lt;arr.endIndex] // [2,3]</pre>

<p class="author1">But the <code class="calibre19">startIndex</code>, <code class="calibre19">endIndex</code>, and <code class="calibre19">indices</code> of an ArraySlice are measured against the original array; for example, after the previous code, <code class="calibre19">slice.indices</code> is <code class="calibre19">1..&lt;3</code>, and <code class="calibre19">slice.startIndex</code> is 1.</p>

<p class="author1">The <code class="calibre19">firstIndex(of:)</code> method reports the index of the first occurrence of an element in an array, but it is wrapped in an Optional so that <code class="calibre19">nil</code> can be returned if the element doesnâ€™t appear in the array. In general, the comparison uses <code class="calibre19">==</code> behind the scenes to identify the element being sought, and therefore the array elements must adopt Equatable<a data-type="indexterm" data-primary="Equatable" id="calibre_link-775" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (otherwise the compiler will stop you):<a data-type="indexterm" data-primary="firstIndex" id="calibre_link-866" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="lastIndex" id="calibre_link-1205" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="searching arrays" id="calibre_link-1966" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors, compiler" data-secondary="cannot invoke index" id="calibre_link-790" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let ix = arr.firstIndex(of:2) // Optional wrapping 1</pre>

<p class="author1">Alternatively, you can call <code class="calibre19">firstIndex(where:)</code>, supplying your own function that takes an element type and returns a Bool, and youâ€™ll get back the index of the first element for which that Bool is <code class="calibre19">true</code>. In this example, my Bird struct has a <code class="calibre19">name</code> String property:</p>

<pre data-type="programlisting" class="calibre28">let aviary = [Bird(name:"Tweety"), Bird(name:"Flappy"), Bird(name:"Lady")]
let ix = aviary.firstIndex{$0.name.count &lt; 5} // Optional(2)</pre>

<p class="author1">If what you want is not the index but the object itself, the <code class="calibre19">first(where:)</code> method returns it &mdash; wrapped, naturally, in an Optional. These methods are matched by <code class="calibre19">lastIndex(of:)</code>, <code class="calibre19">lastIndex(where:)</code>, and <code class="calibre19">last(where:)</code>.</p>

<p class="author1">As a sequence, an arrayâ€™s <code class="calibre19">contains(_:)</code> method reports whether it contains an element.<a data-type="indexterm" data-primary="contains" id="calibre_link-547" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="searching" id="calibre_link-201" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Again, you can rely on the <code class="calibre19">==</code> operator if the elements are Equatable, or you can supply your own function that takes an element type and returns a Bool:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let ok = arr.contains(2) // true
let ok2 = arr.contains{$0 &gt; 3} // false</pre>

<p class="author1">The <code class="calibre19">starts(with:)</code> method reports whether an arrayâ€™s starting elements match the elements of a given sequence of the same type. Once more, you can rely on the <code class="calibre19">==</code> operator for Equatable elements, or you can supply a function that takes two values of the element type and returns a Bool stating whether they match:<a data-type="indexterm" data-primary="starts" id="calibre_link-2063" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let ok = arr.starts(with:[1,2]) // true
let ok2 = arr.starts(with:[1,-2]) {abs($0) == abs($1)} // true</pre>

<p class="author1">The <code class="calibre19">min</code> and <code class="calibre19">max</code> methods return the smallest or largest element in an array, wrapped in an Optional in case the array is empty. If the array consists of Comparable elements, you can let the <code class="calibre19">&lt;</code> operator do its work; alternatively, you can call <code class="calibre19">min(by:)</code> or <code class="calibre19">max(by:)</code>, supplying a function that returns a Bool stating whether the smaller of two given elements is the first:<a data-type="indexterm" data-primary="min" id="calibre_link-1355" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="max" id="calibre_link-1271" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [3,1,-2]
let min = arr.min() // Optional(-2)
let min2 = arr.min{abs($0)&lt;abs($1)} // Optional(1)</pre>

<p class="author1">If the reference to an array is mutable, the <code class="calibre19">append(_:)</code> and <code class="calibre19">append(contentsOf:)</code> instance methods add elements to the end of it. The difference between them is that <code class="calibre19">append(_:)</code> takes a single value of the element type, while <code class="calibre19">append(contentsOf:)</code> takes a sequence of the element type:<a data-type="indexterm" data-primary="append" id="calibre_link-167" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="concatenating" id="calibre_link-186" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="concatenating arrays" id="calibre_link-507" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var arr = [1,2,3]
arr.append(4)
arr.append(contentsOf:[5,6])
arr.append(contentsOf:7...8) // arr is now [1,2,3,4,5,6,7,8]</pre>

<p class="author1">The <code class="calibre19">+</code> operator is overloaded to behave like <code class="calibre19">append(contentsOf:)</code> (not <code class="calibre19">append(_:)</code>!) when the left-hand operand is an array, except that it generates a new array, so it works even if the reference to the array is a constant (<code class="calibre19">let</code>). If the reference to the array is mutable (<code class="calibre19">var</code>), you can append to it in place with the <code class="calibre19">+=</code> operator:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let arr2 = arr + [4] // arr2 is now [1,2,3,4]
var arr3 = [1,2,3]
arr3 += [4] // arr3 is now [1,2,3,4]</pre>

<p class="author1">If the reference to an array is mutable, the instance method <code class="calibre19">insert(at:)</code> inserts a single element at the given index. To insert multiple elements at once, call the <code class="calibre19">insert(contentsOf:at:)</code> method. Assignment into a range-subscripted array, which I described earlier, is even more flexible.<a data-type="indexterm" data-primary="insert" id="calibre_link-1106" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If the reference to an array is mutable, the instance method <code class="calibre19">remove(at:)</code> removes the element at that index; the instance method <code class="calibre19">removeLast</code> removes the last element. These methods also <em class="calibre11">return</em> the value that was removed from the array; you can ignore the returned value if you donâ€™t need it. These methods do not wrap the returned value in an Optional, and accessing an out-of-range index will crash your program. On the other hand, <code class="calibre19">popLast</code> does wrap the returned value in an Optional, and is thus safe even if the array is empty.<a data-type="indexterm" data-primary="remove" id="calibre_link-1890" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="removeFirst" id="calibre_link-1891" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="removeLast" id="calibre_link-1892" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Similar to <code class="calibre19">removeLast</code> and <code class="calibre19">popLast</code> are <code class="calibre19">removeFirst</code> and <code class="calibre19">popFirst</code>. Alternate forms <code class="calibre19">removeFirst(_:)</code> and <code class="calibre19">removeLast(_:)</code> allow you to specify how many elements to remove, but return no value; they, too, can crash if there arenâ€™t as many elements as you specify. <code class="calibre19">popFirst</code>, remarkably, operates on a slice, not an array, presumably for the sake of efficiency: all it has to do is increase the sliceâ€™s <code class="calibre19">startIndex</code>, whereas with an array, the whole array must be renumbered.<a data-type="indexterm" data-primary="popLast" id="calibre_link-1712" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="popFirst" id="calibre_link-1711" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Even if the reference is <em class="calibre11">not</em> mutable, you can use the <code class="calibre19">dropFirst</code> and <code class="calibre19">dropLast</code> methods to return a slice with the end element removed. Again, you can supply a parameter stating how many elements to drop. And again, there is no penalty for dropping too many elements; you simply end up with an empty slice.<a data-type="indexterm" data-primary="dropFirst" id="calibre_link-714" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dropLast" id="calibre_link-716" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The <code class="calibre19">joined(separator:)</code> instance method starts with an array of arrays. It extracts their individual elements, and interposes between each sequence of extracted elements the elements of the <code class="calibre19">separator:</code>. The result is an intermediate sequence called a <span class="publishername">JoinSequence</span>, which might have to be coerced further to an Array if thatâ€™s what you were after:<a data-type="indexterm" data-primary="joined" id="calibre_link-1171" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [[1,2], [3,4], [5,6]]
let joined = Array(arr.joined(separator:[10,11]))
// [1, 2, 10, 11, 3, 4, 10, 11, 5, 6]</pre>

<p class="author1">Calling <code class="calibre19">joined()</code> with no <code class="calibre19">separator:</code> is a way to flatten an array of arrays. Again, it returns an intermediate sequence (or collection), so you might want to coerce to an Array:<a data-type="indexterm" data-primary="arrays" data-secondary="flattening" id="calibre_link-190" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [[1,2], [3,4], [5,6]]
let arr2 = Array(arr.joined())
// [1, 2, 3, 4, 5, 6]</pre>

<p class="author1">The <code class="calibre19">split</code> instance method breaks an array into an array of slices at elements matching the parameter, if you call <code class="calibre19">split(separator:)</code>, or at elements that pass a specified test, if you call <code class="calibre19">split(isSeparator:</code>); in the latter, the parameter is a function that takes a value of the element type and returns a Bool. The separator elements themselves are eliminated:<a data-type="indexterm" data-primary="split" id="calibre_link-2054" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3,4,5,6]
let arr2 = arr.split{$0 % 2 == 0} // split at evens: [[1], [3], [5]]</pre>

<p class="author1">The <code class="calibre19">reversed</code> instance method yields a new array whose elements are in the opposite order from the original.<a data-type="indexterm" data-primary="reversed" id="calibre_link-1938" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The <code class="calibre19">sort</code> and <code class="calibre19">sorted</code> instance methods respectively sort the original array (if the reference to it is mutable) and yield a new sorted array based on the original. Once again, you get two choices: if this is an array of Comparable elements, you can let the <code class="calibre19">&lt;</code> operator dictate the new order; alternatively, you can call <code class="calibre19">sort(by:)</code> or <code class="calibre19">sorted(by:)</code>, supplying a function that takes two parameters of the element type and returns a Bool stating whether the first parameter should be ordered before the second (just like <code class="calibre19">min</code> and <code class="calibre19">max</code>):<a data-type="indexterm" data-primary="sort" id="calibre_link-2044" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sorted" id="calibre_link-2045" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="sorting" id="calibre_link-202" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sorting arrays" id="calibre_link-2046" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var arr = [4,3,5,2,6,1]
arr.sort() // [1, 2, 3, 4, 5, 6]
arr.sort{$0 &gt; $1} // [6, 5, 4, 3, 2, 1]</pre>

<p class="author1">In that last line, I provided an anonymous function. Alternatively, of course, you can pass as argument the name of a declared function. In Swift, comparison operators <em class="calibre11">are</em> the names of functions! Therefore, I can do the same thing like this:</p>

<pre data-type="programlisting" class="calibre28">var arr = [4,3,5,2,6,1]
arr.sort(by: &gt;) // [6, 5, 4, 3, 2, 1]</pre>

<p class="author1">The <code class="calibre19">swapAt</code> method accepts two Int index numbers and interchanges those elements of a mutable array:<a data-type="indexterm" data-primary="swapAt" id="calibre_link-2166" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var arr = [1,2,3]
arr.swapAt(0,2) // [3,2,1]</pre>

<p class="author1">Starting in Swift 4.2, the <code class="calibre19">shuffle</code> and <code class="calibre19">shuffled</code> methods sort an array in random order, whilethe <code class="calibre19">randomElement</code> method generates a valid index at random and hands you the element at that index (wrapped in an Optional, in case the array is empty).<a data-type="indexterm" data-primary="shuffle" id="calibre_link-2025" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="randomElement" id="calibre_link-1838" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="randomizing" id="calibre_link-200" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Array enumeration and transformation" class="calibre2"><div class="preface" id="calibre_link-2952">
<h3 class="calibre44">Array enumeration and transformation</h3>

<p class="author1">An array is a sequence, and so you can enumerate it, inspecting or operating with each element in turn. The simplest way is by means of a <code class="calibre19">for...in</code> loop; Iâ€™ll have more to say about this construct in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>:<a data-type="indexterm" data-primary="arrays" data-secondary="enumerating" id="calibre_link-188" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pepboys = ["Manny", "Moe", "Jack"]
for pepboy in pepboys {
    print(pepboy) // prints Manny, then Moe, then Jack
}</pre>

<p class="author1">Alternatively, you can use the <code class="calibre19">forEach(_:)</code> instance method. Its parameter is a function that takes an element and returns no value. Think of it as the functional equivalent of the imperative <code class="calibre19">for...in</code> loop:<a data-type="indexterm" data-primary="forEach" id="calibre_link-885" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pepboys = ["Manny", "Moe", "Jack"]
pepboys.forEach{print($0)} // prints Manny, then Moe, then Jack</pre>

<p class="author1">If you need the index numbers as well as the elements, call the <code class="calibre19">enumerated</code> instance method and loop on the result; what you get on each iteration is a tuple with labels <code class="calibre19">offset</code> and <code class="calibre19">element</code>:<a data-type="indexterm" data-primary="enumerated" id="calibre_link-744" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="index, enumerate with" id="calibre_link-1050" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pepboys = ["Manny", "Moe", "Jack"]
for (ix,pepboy) in pepboys.enumerated() {
    print("Pep boy \(ix) is \(pepboy)") // Pep boy 0 is Manny, etc.
}
// or:
pepboys.enumerated().forEach {
    print("Pep boy \($0.offset) is \($0.element)")
}</pre>

<p class="author1">Starting in Swift 4.2, the <code class="calibre19">allSatisfy(_:)</code> method tells you whether all elements pass some test; you supply a function that takes an element and returns a Bool:<a data-type="indexterm" data-primary="allSatisfy" id="calibre_link-131" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="testing all elements" id="calibre_link-204" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pepboys = ["Manny", "Moe", "Jack"]
let ok = pepboys.allSatisfy{$0.hasPrefix("M")} // false
let ok2 = pepboys.allSatisfy{$0.hasPrefix("M") || $0.hasPrefix("J")} // true</pre>

<p class="author1">Swift also provides some powerful array transformation instance methods. Like <code class="calibre19">forEach(_:)</code> and <code class="calibre19">allSatisfy(_:)</code>, these methods enumerate the array for you, so that the loop is buried implicitly inside the method call, making your code tighter and cleaner.<a data-type="indexterm" data-primary="arrays" data-secondary="transforming" id="calibre_link-206" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The <code class="calibre19">filter(_:)</code> instance method yields a new array, each element of which is an element of the old array, in the same order; but some of the elements of the old array may be omitted &mdash; they were filtered out. What filters them out is a function that you supply; it accepts a parameter of the element type and returns a Bool stating whether this element should go into the new array:<a data-type="indexterm" data-primary="filter" id="calibre_link-855" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pepboys = ["Manny", "Moe", "Jack"]
let pepboys2 = pepboys.filter{$0.hasPrefix("M")} // ["Manny", "Moe"]</pre>

<p class="author1">If the function is effectively negative, and if the reference to the collection is mutable, you should call <code class="calibre19">removeAll(where:)</code> rather whan <code class="calibre19">filter(_:)</code>:</p>

<pre data-type="programlisting" class="calibre28">var pepboys = ["Manny", "Jack", "Moe"]
pepboys.removeAll{$0.hasPrefix("M")} // pepboys is now ["Jack"]</pre>

<p class="author1">Thatâ€™s better in general than saying <code class="calibre19">pepboys.filter{!$0.hasPrefix("M")}</code> because of efficiencies achieved under the hood.</p>

<p class="author1">Similar to <code class="calibre19">filter(_:)</code> is <code class="calibre19">prefix(while:)</code>. The difference is that <code class="calibre19">prefix(while:)</code> stops looping as soon as it encounters an element for which the supplied function returns <code class="calibre19">false</code>; it returns the start of the original array as a slice. The complement of <code class="calibre19">prefix(while:)</code> is <code class="calibre19">drop(while:)</code>; it stops where <code class="calibre19">prefix(while:)</code> stops, but it returns the <em class="calibre11">rest</em> of the original array as a slice:<a data-type="indexterm" data-primary="prefix" id="calibre_link-1719" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="drop" id="calibre_link-712" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pepboys = ["Manny", "Jack", "Moe"]
let arr1 = pepboys.filter{$0.hasPrefix("M")} // ["Manny", "Moe"]
let arr2 = pepboys.prefix{$0.hasPrefix("M")} // ["Manny"]
let arr3 = pepboys.drop{$0.hasPrefix("M")} // ["Jack", "Moe"]</pre>

<p class="author1">The <code class="calibre19">map(_:)</code> instance method yields a new array, each element of which is the result of passing the corresponding element of the old array through a function that you supply. This function accepts a parameter of the element type and returns a result which may be of some other type; Swift can usually infer the type of the resulting array elements by looking at the type returned by the function.<a data-type="indexterm" data-primary="map" id="calibre_link-1265" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s how to multiply every element of an array by 2:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let arr2 = arr.map{$0 * 2} // [2,4,6]</pre>

<p class="author1">Hereâ€™s another example, to illustrate the fact that <code class="calibre19">map(_:)</code> can yield an array with a different element type:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,3]
let arr2 = arr.map{Double($0)} // [1.0, 2.0, 3.0]</pre>

<p class="author1">Hereâ€™s a real-life example showing how neat and compact your code can be when you use <code class="calibre19">map(_:)</code>. In order to remove all the table cells in a section of a UITableView, I have to specify the cells as an array of IndexPath objects. If <code class="calibre19">sec</code> is the section number, I can form those IndexPath objects individually like this:</p>

<pre data-type="programlisting" class="calibre28">let path0 = IndexPath(row:0, section:sec)
let path1 = IndexPath(row:1, section:sec)
// ...</pre>

<p class="author1">Hmmm, I think I see a pattern here! I could generate my array of IndexPath objects by looping through the row values using <code class="calibre19">for...in</code>. But with <code class="calibre19">map(_:)</code>, thereâ€™s a much tighter way to express the same loop &mdash; namely, to loop through the range <code class="calibre19">0..&lt;ct</code> (where <code class="calibre19">ct</code> is the number of rows in the section). Since <code class="calibre19">map(_:)</code> is a Collection instance method, and a Range is itself a Collection, I can call <code class="calibre19">map(_:)</code> directly on the range:</p>

<pre data-type="programlisting" class="calibre28">let paths = (0..&lt;ct).map{IndexPath(row:$0, section:sec)}</pre>

<p class="author1">The <code class="calibre19">map(_:)</code> method provides a neat alternative to <code class="calibre19">init(repeating:count:)</code> with a reference type:</p>

<pre data-type="programlisting" class="calibre28">let dogs = Array(repeating:Dog(), count:3) // probably a mistake</pre>

<p class="author1">You probably wanted an array of three Dogs. But if Dog is a class, the array consists of three references to <em class="calibre11">one and the same</em> Dog instance! Instead, generate the array using <code class="calibre19">map(_:)</code>, like this:</p>

<pre data-type="programlisting" class="calibre28">let dogs = (0..&lt;3).map{_ in Dog()}</pre>

<p class="author1">The <code class="calibre19">map(_:)</code> method has a specialized companion, <code class="calibre19">flatMap(_:)</code>. Applied to an array, <code class="calibre19">flatMap(_:)</code> first calls <code class="calibre19">map(_:)</code>, and then, if the map function produces an array of arrays, flattens it. For instance, <code class="calibre19">[[1],[2]].flatMap{$0}</code> is <code class="calibre19">[1,2]</code>.<a data-type="indexterm" data-primary="flatMap" id="calibre_link-870" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="flattening" id="calibre_link-191" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Hereâ€™s a more interesting example:</p>

<pre data-type="programlisting" class="calibre28">let arr = [[1, 2], [3, 4]]
let arr2 = arr.flatMap{$0.map{String($0)}} // ["1", "2", "3", "4"]</pre>

<p class="author1">First our map function calls <code class="calibre19">map(_:)</code> to coerce the individual elements of each inner array to a string, thus yielding an array of arrays of String: <code class="calibre19">[["1", "2"], ["3", "4"]]</code>. Then <code class="calibre19">flatMap(_:)</code> flattens the array of arrays, and we end up with a simple array of String.</p>

<p class="author1">Another specialized <code class="calibre19">map(_:)</code> companion is <code class="calibre19">compactMap(_:)</code>. (Before Swift 4.1, this was another form of <code class="calibre19">flatMap(_:)</code>.) Given a map function that produces an array of Optionals, <code class="calibre19">compactMap(_:)</code> safely unwraps them by first eliminating any <code class="calibre19">nil</code> elements.<a data-type="indexterm" data-primary="compactMap" id="calibre_link-488" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This neatly solves a large class of commonly encountered problem. In particular, we can coerce or cast an array safely by eliminating those elements that <em class="calibre11">canâ€™t</em> be coerced or cast.<a data-type="indexterm" data-primary="Optionals" data-secondary="array of" id="calibre_link-1597" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="Optional" id="calibre_link-198" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, suppose I have a mixed bag of strings, some of which represent integers. Iâ€™d like to coerce to Int those that <em class="calibre11">can</em> be coerced to Int, and eliminate the others. Int coercion of a String yields an Optional, so the <code class="calibre19">compactMap(_:)</code> lightbulb should go on in our heads:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["1", "hey", "2", "ho"]
let arr2 = arr.compactMap{Int($0)} // [1, 2]</pre>

<p class="author1">First we map the original array to an array of Optionals wrapping Int, by coercing: <code class="calibre19">[Optional(1), nil, Optional(2), nil]</code>. Then <code class="calibre19">compactMap(_:)</code> removes the <code class="calibre19">nil</code> elements and unwraps the remaining elements, resulting in an array of Int.</p>

<p class="author1">The <code class="calibre19">reduce</code> instance method is a way of <em class="calibre11">combining</em> all the elements of an array (actually, a sequence) into a single value. This valueâ€™s type &mdash; the result type &mdash; doesnâ€™t have to be the same as the arrayâ€™s element type. <code class="calibre19">reduce</code> takes two parameters:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">You supply, as the <em class="calibre11">second</em> parameter, a function that takes two parameters; the first is of the result type, the second is of the element type, and the functionâ€™s result is your combination of those two parameters, as the result type. That result, on each iteration, becomes the functionâ€™s <em class="calibre11">first</em> parameter in the <em class="calibre11">next</em> iteration, along with the next element of the array as the <em class="calibre11">second</em> parameter. Thus, the output of combining pairs accumulates, and the final accumulated value is the final output of the function.</p>
</li>
<li class="calibre12">
<p class="calibre17">However, that doesnâ€™t explain where the first parameter for the <em class="calibre11">first</em> iteration comes from. The answer is that you have to supply it as the <em class="calibre11">first</em> parameter of the <code class="calibre19">reduce</code> call.<a data-type="indexterm" data-primary="reduce" id="calibre_link-1859" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">That will all be easier to understand with a simple example. Letâ€™s assume weâ€™ve got an array of Int. Then we can use <code class="calibre19">reduce</code> to sum the elements of the array. Hereâ€™s some pseudocode where Iâ€™ve left out the first argument of the call, so that you can think about what it needs to be:</p>

<pre data-type="programlisting" class="calibre28">let sum = arr.reduce(/* ... */) {$0 + $1}</pre>

<p class="author1">Each pair of parameters will be added together to get the first parameter (<code class="calibre19">$0</code>) on the next iteration. The second parameter on every iteration (<code class="calibre19">$1</code>) is a successive element of the array. Clearly we are just summing the elements, adding each element one by one to the accumulated total. So the remaining question is: What should the <em class="calibre11">first</em> element of the array be added to? We want the actual sum of all the elements, no more and no less; so the first element of the array should be added to <code class="calibre19">0</code>:</p>

<pre data-type="programlisting" class="calibre28">let arr = [1, 4, 9, 13, 112]
let sum = arr.reduce(0){$0 + $1} // 139</pre>

<p class="author1">The <code class="calibre19">+</code> operator is the name of a function of the required type, so hereâ€™s another way to write the same thing:</p>

<pre data-type="programlisting" class="calibre28">let sum = arr.reduce(0, +)</pre>

<p class="author1">There is also <code class="calibre19">reduce(into:)</code>, which greatly improves efficiency when the goal is to build a collection such as an array or a dictionary. The <code class="calibre19">into:</code> argument is passed into your function as an <code class="calibre19">inout</code> parameter, and persists through each iteration; instead of returning a value, your function modifies it, and the final result is its final value.</p>

<p class="author1">For example, suppose we have an array of integers, and our goal is to â€œdealâ€ them into two piles consisting of the even elements and the odd elements respectively. You canâ€™t do that with a single call to <code class="calibre19">map</code>; youâ€™d have to cycle through the original array <em class="calibre11">twice</em>. With <code class="calibre19">reduce(into:)</code>, both target arrays are constructed while cycling through the original array <em class="calibre11">once</em>:</p>

<pre data-type="programlisting" class="calibre28">let nums = [1,3,2,4,5]
let result = nums.reduce(into: [[],[]]) { temp, i in
    temp[i%2].append(i)
}
// result is now [[2, 4], [1, 3, 5]]</pre>

<p class="author1">Swiftâ€™s array transformation methods are very powerful and very useful. In real life, your code is likely to depend heavily on all of these methods, especially <code class="calibre19">filter</code>, <code class="calibre19">map</code>, and <code class="calibre19">reduce</code>, alone or in combination, nested or chained together.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Swift Array and Objective-C NSArray" class="calibre2"><div class="preface" id="calibre_link-62">
<h3 class="calibre44">Swift Array and Objective-C NSArray</h3>

<p class="author1">When youâ€™re programming iOS, you import the Foundation framework (or UIKit, which imports Foundation) and the Objective-C NSArray<a data-type="indexterm" data-primary="NSArray" id="calibre_link-1429" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> type. Swift Array is bridged to Objective-C NSArray. The most general medium of array interchange is <code class="calibre19">[Any]</code>; if an Objective-C API specifies an NSArray, with no further type information, Swift will see this as an array of Any. This reflects the fact that Objective-Câ€™s rules for what can be an element of an NSArray are looser than Swiftâ€™s: the elements of an NSArray do not all have to be of the same type. On the other hand, the elements of an Objective-C NSArray must be Objective-C <em class="calibre11">objects</em> &mdash; that is, they must be class types.<a data-type="indexterm" data-primary="bridged types" data-secondary="Array and NSArray" id="calibre_link-282" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="bridging" id="calibre_link-180" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Passing a Swift array to Objective-C is thus usually easy. Typically, youâ€™ll just pass the array, either by assignment or as an argument in a function call:</p>

<pre data-type="programlisting" class="calibre28">let arr = [UIBarButtonItem(), UIBarButtonItem()]
self.navigationItem.leftBarButtonItems = arr</pre>

<p class="author1">The objects that you pass as elements of the array will cross the bridge to Objective-C in the usual way:<a data-type="indexterm" data-primary="bridged types" data-secondary="array elements" id="calibre_link-285" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let lay = CAGradientLayer()
lay.locations = [0.25, 0.5, 0.75] // bridged to NSArray of NSNumber</pre>

<p class="author1">CAGradientLayerâ€™s <code class="calibre19">locations</code> property needs to be an array of NSNumber. But we can pass an array of Double, because Double is bridged to NSNumber, and so Objective-C receives an NSArray of NSNumber.</p>

<p class="author1">To call an NSArray method on a Swift array, you may have to cast to NSArray:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["Manny", "Moe", "Jack"]
let s = (arr as NSArray).componentsJoined(by:", ")
// s is "Manny, Moe, Jack"</pre>

<p class="author1">A Swift Array seen through a <code class="calibre19">var</code> reference is mutable, but an NSArray isnâ€™t mutable ever. For mutability in Objective-C, you need an NSMutableArray<a data-type="indexterm" data-primary="NSMutableArray" id="calibre_link-1447" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, a subclass of NSArray. You canâ€™t cast, assign, or pass a Swift array as an NSMutableArray; you have to coerce. The best way is to call the NSMutableArray initializer <code class="calibre19">init(array:)</code>, to which you can pass a Swift array directly. To convert back from an NSMutableArray to a Swift array, you can cast:</p>

<pre data-type="programlisting" class="calibre28">var arr = ["Manny", "Moe", "Jack"]
let arr2 = NSMutableArray(array:arr)
arr2.remove("Moe")
arr = arr2 as! [String]</pre>

<p class="author1">Now letâ€™s talk about what happens when an NSArray arrives from Objective-C into Swift. There wonâ€™t be any problem crossing the bridge: the NSArray will arrive safely as a Swift Array. But a Swift Array <em class="calibre11">of what?</em></p>

<p class="author1">Of itself, an NSArray carries no information about what type of element it contains. Starting in Xcode 7, however, the Objective-C language was modified so that the declaration of an NSArray, NSDictionary, or NSSet &mdash; the three collection types that are bridged to Swift &mdash; can include element type information. (Objective-C calls this a <em class="calibre11">lightweight generic</em>.) Thus, for the most part, the arrays you receive from Cocoa will be correctly typed.<a data-type="indexterm" data-primary="lightweight generics" id="calibre_link-1228" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="lightweight generics" id="calibre_link-1528" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, this elegant code was impossible in the bad old days before Xcode 7:</p>

<pre data-type="programlisting" class="calibre28">let arr = UIFont.familyNames.map {
    UIFont.fontNamesForFamilyName($0)
}</pre>

<p class="author1">The result is an array of arrays of String, listing all available fonts grouped by family. That code is possible because both of those UIFont class methods are seen by Swift as returning an array of String. Before Xcode 7, however, those arrays were untyped, and casting down to an array of String was up to you.</p>

<p class="author1">Nevertheless, lightweight generics are not omnipresent. You might read an array from a <em class="calibre11">.plist</em> file stored on disk with NSArrayâ€™s initializer <code class="calibre19">init(contentsOf:)</code>; you might retrieve an array from UserDefaults; you might even be dealing with an Objective-C API that hasnâ€™t been updated to use lightweight generics. In such a situation, youâ€™re going to end up with a plain vanilla NSArray or a Swift array of Any. If that happens, you will usually want to cast down or otherwise transform this array into an array of some specific Swift type. Hereâ€™s an Objective-C class containing a method whose return type of NSArray hasnâ€™t been marked up with an element type:</p>

<pre data-type="programlisting" class="calibre28">@implementation Pep
- (NSArray*) boys {
    return @[@"Manny", @"Moe", @"Jack"];
}
@end</pre>

<p class="author1">To call that method and do anything useful with the result, it will be necessary to cast that result down to an array of String. If Iâ€™m sure of my ground, I can force the cast:</p>

<pre data-type="programlisting" class="calibre28">let p = Pep()
let boys = p.boys() as! [String]</pre>

<p class="author1">As with any cast, though, be sure you donâ€™t lie! An Objective-C array can contain more than one type of object. Donâ€™t force such an array to be cast down to a type to which not all the elements can be cast, or youâ€™ll crash when the cast fails; youâ€™ll need a more deliberate strategy (possibly involving <code class="calibre19">compactMap</code>) for eliminating or otherwise transforming the problematic elements.<a data-type="indexterm" data-startref="idxarray" id="calibre_link-179" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Dictionary" class="calibre2"><div class="preface" id="calibre_link-2518">
<h2 class="calibre42">Dictionary</h2>

<p class="author1">A dictionary (Dictionary, a struct) is an unordered collection of object pairs. In each pair, the first object is the <em class="calibre11">key</em>; the second object is the <em class="calibre11">value</em>. The idea is that you use a key to access a value. Keys are usually strings, but they donâ€™t have to be; the formal requirement is that they be types that conform to the Hashable<a data-type="indexterm" data-primary="Hashable" id="calibre_link-1001" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> protocol.<a data-type="indexterm" data-primary="Dictionary" id="calibre_link-679" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dictionaries" data-secondary="hashable keys" id="calibre_link-669" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="keyâ€“value pairs" id="calibre_link-1193" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="keys (dictionary)" id="calibre_link-1188" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="values (dictionary)" id="calibre_link-2311" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dictionaries" id="calibre_link-662" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To be Hashable means three things. First, the type must be Equatable<a data-type="indexterm" data-primary="Equatable" id="calibre_link-776" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. Second, it must implement an Int <code class="calibre19">hashValue</code> property. Third, its implementation of equality and <code class="calibre19">hashValue</code> must be such that <em class="calibre11">equal keys have equal hash values</em>. (The protocol itself cannot formally insist upon this rule, but that is what is needed for hashability to be useful and well-behaved.) The hash values can then be used behind the scenes for rapid key access. Most Swift standard types are Hashable; Iâ€™ll talk in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> about how to make your own object types Hashable.</p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Do not use mutable objects as keys. Mutating a key while it is in use will break the dictionary (lookup will no longer work correctly).</p>
</div>

<p class="author1">As with arrays, a given dictionaryâ€™s types must be uniform. The key type and the value type donâ€™t have to be the same as one another, and they often will not be. But within any dictionary, all keys must be of the same type, and all values must be of the same type. Formally, a dictionary is a generic, and its placeholder types are its key type and its value type: <code class="calibre19">Dictionary&lt;Key,Value&gt;</code>. As with arrays, Swift provides syntactic sugar for expressing a dictionaryâ€™s type, which is what youâ€™ll usually use: <code class="calibre19">[Key: Value]</code>. Thatâ€™s square brackets containing a colon (and optional spaces) separating the key type from the value type. This code creates an empty dictionary whose keys (when they exist) will be Strings and whose values (when they exist) will be Strings:<a data-type="indexterm" data-primary="dictionaries" data-secondary="declaration" id="calibre_link-666" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of dictionaries" id="calibre_link-623" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="colon" data-secondary="keyâ€“value" id="calibre_link-463" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var d = [String:String]()</pre>

<p class="author1">The colon is used also between each key and value in the literal syntax for expressing a dictionary. The key&ndash;value pairs appear between square brackets, separated by a comma, just like an array. This code creates a dictionary by describing it literally (and the dictionaryâ€™s type of <code class="calibre19">[String:String]</code> is inferred):<a data-type="indexterm" data-primary="dictionaries" data-secondary="literals" id="calibre_link-671" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="literals" data-secondary="dictionary" id="calibre_link-1233" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="square brackets" id="calibre_link-2057" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="dictionary literal" id="calibre_link-475" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If a dictionary variable is declared and initialized to a literal with many elements, itâ€™s a good idea to declare the variableâ€™s type explicitly, saving the compiler from having to examine the entire dictionary to decide its type and thus making compilation faster.</p>
</div>

<p class="author1">The literal for an empty dictionary is square brackets containing just a colon: <code class="calibre19">[:]</code>. That notation can be used provided the dictionaryâ€™s type is known in some other way. This is another way to create an empty <code class="calibre19">[String:String]</code> dictionary:</p>

<pre data-type="programlisting" class="calibre28">var d : [String:String] = [:]</pre>

<p class="author1">You can also initialize a dictionary from a sequence of key&ndash;value tuples. This is useful particularly if youâ€™re starting with two sequences. Suppose, for example, that we happen to have state abbreviations in one array and state names in another:<a data-type="indexterm" data-primary="dictionaries" data-secondary="creating" id="calibre_link-665" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let abbrevs = ["CA", "NY"]
let names = ["California", "New York"]</pre>

<p class="author1">We can then form those two arrays into a single array of tuples and call <code class="calibre19">init(uniqueKeysWithValues:)</code> to generate a dictionary:</p>

<pre data-type="programlisting" class="calibre28">let tuples = (abbrevs.indices).map{(abbrevs[$0],names[$0])}
let d = Dictionary(uniqueKeysWithValues: tuples)
// ["NY": "New York", "CA": "California"]</pre>

<p class="author1">There is actually a simpler way to form those tuples &mdash; the global <code class="calibre19">zip</code> function, which takes two sequences and yields a sequence of tuples:<a data-type="indexterm" data-primary="zip" id="calibre_link-2380" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let tuples = zip(abbrevs, names)
let d = Dictionary(uniqueKeysWithValues: tuples)</pre>

<p class="author1">A nice feature of <code class="calibre19">zip</code> is that if one sequence is longer than the other, the extra elements of the longer sequence are ignored &mdash; tuple formation simply stops when the end of the shorter sequence is reached. For example, one of the zipped sequences can be a partial range; in theory the range is infinite, but in fact the end of the other sequence ends the range as well:<a data-type="indexterm" data-primary="ranges" data-secondary="partial" id="calibre_link-1848" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="partial range" id="calibre_link-1689" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let r = 1...
let names = ["California", "New York"]
let d = Dictionary(uniqueKeysWithValues: zip(r,names))
// [2: "New York", 1: "California"]</pre>

<p class="author1">If the keys in the tuple sequence are not unique, youâ€™ll crash at runtime when <code class="calibre19">init(uniqueKeysWithValues:)</code> is called. To work around that, you can use <code class="calibre19">init(_:uniquingKeysWith:)</code> instead. The second parameter is a function taking two values &mdash; the existing value for this key, and the new incoming value for the same key &mdash; and returning the value that should actually be used for this key. Iâ€™ll give an example later.</p>

<p class="author1">Another way to form a dictionary is <code class="calibre19">init(grouping:by:)</code>. This is useful for forming a dictionary whose values are <em class="calibre11">arrays</em>. You start with a sequence of the <em class="calibre11">elements</em> of the arrays, and the initializer clumps them into arrays for you, in accordance with a function that generates the corresponding key from each value.</p>

<p class="author1">For example, suppose I have a list (<code class="calibre19">states</code>) of the 50 U.S. states in alphabetical order as an array of strings, and we want to group them by the letter they start with. Hereâ€™s a verbose strategy. We loop through the list to construct two arrays (an array of String and an array of arrays of String); we then zip those arrays together to form the dictionary:</p>

<pre data-type="programlisting" class="calibre28">var sectionNames = [String]()
var cellData = [[String]]()
var previous = ""
for aState in states {
    // get the first letter
    let c = String(aState.prefix(1))
    // only add a letter to sectionNames when it's a different letter
    if c != previous {
        previous = c
        sectionNames.append(c.uppercased())
        // and in that case also add new subarray to our array of subarrays
        cellData.append([String]())
    }
    cellData[cellData.count-1].append(aState)
}
let d = Dictionary(uniqueKeysWithValues: zip(sectionNames,cellData))
// ["H": ["Hawaii"], "V": ["Vermont", "Virginia"], ...</pre>

<p class="author1">With <code class="calibre19">init(grouping:by:)</code>, however, that becomes effectively a one-liner:</p>

<pre data-type="programlisting" class="calibre28">let d = Dictionary(grouping: states){$0.prefix(1).uppercased()}</pre>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2953">
<h5 class="calibre36">Dictionaries Have No Order</h5>
<p class="calibre37">It cannot be too strongly stressed that dictionaries are <em class="calibre11">unordered</em>. Whenever you probe a dictionaryâ€™s entire contents &mdash; when you <code class="calibre19">print</code> them, when you cycle through them with <code class="calibre19">for...in</code>, and so forth &mdash; each entry arrives in a completely unpredictable order. If you run the same code as I do (indeed, even if you run the same code as yourself on two different occasions), your results may be ordered differently. This makes no difference to the actual contents of the dictionary, which consists of particular keys, each associated with a particular value. <code class="calibre19">[2: "New York", 1: "California"]</code> is the same dictionary as <code class="calibre19">[1: "California", 2: "New York"]</code>.</p>

<p class="calibre37">If you needed order to be meaningful, you were thinking of an array, not a dictionary. To put it another way, you can have rapid access by key or meaningful order with rapid access by index number, but not both. If what you wanted was an ordered array of key-value pairs &mdash; with no subscripting by key, no hashability requirement, and no guaranteed uniqueness of keys &mdash; you can use a KeyValuePairs object, which is essentially an array of tuples with labels <code class="calibre19">key</code> and <code class="calibre19">value</code>; it can be initialized from a dictionary literal:</p>

<pre data-type="programlisting" class="calibre38">let pairs : KeyValuePairs = ["CA": "California", "NY": "New York"]
print(pairs.count) // 2
print(pairs[0]) // (key: "CA", value: "California")
// to access by key, cycle through the array
if let pair = pairs.first(where: {$0.key == "NY"}) {
    let val = pair.value // New York
}</pre>
</div>
</aside>










<section data-type="sect3" data-pdf-bookmark="Dictionary subscripting" class="calibre2"><div class="preface" id="calibre_link-2954">
<h3 class="calibre44">Dictionary subscripting</h3>

<p class="author1">Access to a dictionaryâ€™s contents is usually by subscripting. To fetch a value by key, use the key as a subscript:<a data-type="indexterm" data-primary="subscripting" id="calibre_link-2148" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dictionaries" data-secondary="subscripting" id="calibre_link-675" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d = ["CA": "California", "NY": "New York"]
let state = d["CA"]</pre>

<p class="author1">If you try to fetch a value through a nonexistent key, there is no error, but Swift needs a way to report failure; to do so, by default, it returns <code class="calibre19">nil</code>. This, in turn, implies that the value returned when you successfully access a value through a key must be an Optional wrapping the real value. After that code, therefore, <code class="calibre19">state</code> is not a String &mdash; itâ€™s an Optional wrapping a String! Forgetting this is a common beginner mistake.</p>

<p class="author1">Starting in Swift 4, you can change that behavior by supplying your own <code class="calibre19">default</code> value as part of the subscript. If the key isnâ€™t found in the dictionary, the <code class="calibre19">default</code> value is returned, and so there is no need for the returned value to be wrapped in an Optional:</p>

<pre data-type="programlisting" class="calibre28">let d = ["CA": "California", "NY": "New York"]
let state = d["MD", default:"N/A"] // state is a String (not an Optional)</pre>

<p class="author1">If the reference to a dictionary is mutable, you can also assign into a key subscript expression. If the key already exists, its value is replaced. If the key doesnâ€™t already exist, it is created and the value is attached to it:<a data-type="indexterm" data-primary="dictionaries" data-secondary="mutating" id="calibre_link-673" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
d["CA"] = "Casablanca"
d["MD"] = "Maryland"
// d is now ["MD": "Maryland", "NY": "New York", "CA": "Casablanca"]</pre>

<p class="author1">Instead of assigning into a subscript expression, you can call <code class="calibre19">updateValue(forKey:)</code>; it has the advantage that it returns the old value.<a data-type="indexterm" data-primary="updateValue" id="calibre_link-2299" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">As with fetching a value by key, you can supply a <code class="calibre19">default</code> value when assigning into a key subscript expression. This can be a source of great economy of expression. For example, consider the common task of collecting a histogram: we want to know how many times each element appears in a sequence:</p>

<pre data-type="programlisting" class="calibre28">let sentence = "how much wood would a wood chuck chuck"
let words = sentence.split(separator: " ").map{String($0)}</pre>

<p class="author1">Our goal is now to make a dictionary pairing each word with the number of times it appears. Before Swift 4, a typical approach would be rather laborious, along these lines:</p>

<pre data-type="programlisting" class="calibre28">var d = [String:Int]()
for word in words {
    let ct = d[word]
    if ct != nil {
        d[word]! += 1
    } else {
        d[word] = 1
    }
}
// d is now ["how": 1, "wood": 2, "a": 1, "chuck": 2, "would": 1, "much": 1]</pre>

<p class="author1">Now, however, itâ€™s effectively a one-liner:</p>

<pre data-type="programlisting" class="calibre28">var d = [String:Int]()
words.forEach{d[$0, default:0] += 1}</pre>

<p class="author1">Earlier, I promised to give an example of <code class="calibre19">init(_:uniquingKeysWith:)</code>, so here it is, forming the same histogram in a silly but interesting way; I start with a values array of ones, and sum the values whenever a duplicate key is encountered:</p>

<pre data-type="programlisting" class="calibre28">let ones = Array(repeating: 1, count: words.count)
let d = Dictionary(zip(words,ones)){$0+$1}</pre>

<p class="author1">By a kind of shorthand, assigning <code class="calibre19">nil</code> into a key subscript expression removes that key&ndash;value pair if it exists:</p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
d["NY"] = nil // d is now ["CA": "California"]</pre>

<p class="author1">Alternatively, call <code class="calibre19">removeValue(forKey:)</code>; it has the advantage that it returns the removed value before it removes the key&ndash;value pair.<a data-type="indexterm" data-primary="removeValue" id="calibre_link-1894" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Dictionary casting and comparison" class="calibre2"><div class="preface" id="calibre_link-2955">
<h3 class="calibre44">Dictionary casting and comparison</h3>

<p class="author1">As with arrays, a dictionary type is legal for casting down, meaning that the individual elements will be cast down. Typically, only the value types will differ:<a data-type="indexterm" data-primary="dictionaries" data-secondary="casting" id="calibre_link-664" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let dog1 : Dog = NoisyDog()
let dog2 : Dog = NoisyDog()
let d = ["fido": dog1, "rover": dog2]
let d2 = d as! [String : NoisyDog]</pre>

<p class="author1">As with arrays, <code class="calibre19">is</code> can be used to test the actual types in the dictionary, and <code class="calibre19">as?</code> can be used to test and cast safely. <a data-type="indexterm" data-primary="dictionaries" data-secondary="testing type" id="calibre_link-676" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Dictionary equality is like array equality. Key types are necessarily Equatable, because they are Hashable. Value types are not necessarily Equatable, but if they are, <code class="calibre19">==</code> and <code class="calibre19">!=</code> are defined as you would expect.<a data-type="indexterm" data-primary="dictionaries" data-secondary="equality" id="calibre_link-668" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Basic dictionary properties and enumeration" class="calibre2"><div class="preface" id="calibre_link-2956">
<h3 class="calibre44">Basic dictionary properties and enumeration</h3>

<p class="author1">A dictionary has a <code class="calibre19">count</code> property reporting the number of key&ndash;value pairs it contains, and an <code class="calibre19">isEmpty</code> property reporting whether that number is <code class="calibre19">0</code>.<a data-type="indexterm" data-primary="dictionaries" data-secondary="properties" id="calibre_link-674" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dictionaries" data-secondary="enumerating" id="calibre_link-667" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A dictionary has a <code class="calibre19">keys</code> property reporting all its keys, and a <code class="calibre19">values</code> property reporting all its values. These are effectively opaque structs providing a specialized view of the dictionary itself. You canâ€™t assign one to a variable, or print it out, but you can work with them as collections. For example, you can enumerate them with <code class="calibre19">for...in</code> (though you should not expect them to arrive in any particular order, as a dictionary is unordered):</p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
for s in d.keys {
    print(s) // NY, then CA (or vice versa)
}</pre>

<p class="author1">You can coerce them to an array:<a data-type="indexterm" data-primary="dictionaries" data-secondary="keys" id="calibre_link-670" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dictionaries" data-secondary="values" id="calibre_link-678" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
var keys = Array(d.keys) // ["NY", "CA"] or ["CA", "NY"]</pre>

<p class="author1">You can sort them, filter them, or map them (yielding an array); you can take their <code class="calibre19">min</code> or <code class="calibre19">max</code>; you can <code class="calibre19">reduce</code> them; you can compare <code class="calibre19">keys</code> of different dictionaries for equality:</p>

<pre data-type="programlisting" class="calibre28">let d : [String:Int] = ["one":1, "two":2, "three":3]
let keysSorted = d.keys.sorted() // ["one", "three", "two"]
let arr = d.values.filter{$0 &lt; 2} // [1]
let min = d.values.min() // Optional(1)
let sum = d.values.reduce(0, +) // 6
let ok = d.keys == ["one":1, "three":3, "two":2].keys // true</pre>

<p class="author1">You can also enumerate a dictionary itself. Each iteration provides a key&ndash;value tuple (arriving in no particular order, because a dictionary is unordered):</p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
for (abbrev, state) in d {
    print("\(abbrev) stands for \(state)")
}</pre>

<p class="author1">The tuple members have labels <code class="calibre19">key</code> and <code class="calibre19">value</code>, so the preceding example can be rewritten like this:</p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
for pair in d {
    print("\(pair.key) stands for \(pair.value)")
}</pre>

<p class="author1">You can extract a dictionaryâ€™s entire contents at once as an array of key&ndash;value tuples (in an unpredictable order) by coercing the dictionary to an array:</p>

<pre data-type="programlisting" class="calibre28">var d = ["CA": "California", "NY": "New York"]
let arr = Array(d)
// [(key: "NY", value: "New York"), (key: "CA", value: "California")] or vice versa</pre>

<p class="author1">When you apply <code class="calibre19">filter</code> to a dictionary, what you get is a dictionary. In addition, thereâ€™s a <code class="calibre19">mapValues</code> method that yields a dictionary with its values changed according to your map function:<a data-type="indexterm" data-primary="filter" id="calibre_link-856" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mapValues" id="calibre_link-1266" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dictionaries" data-secondary="transformations" id="calibre_link-677" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d = ["CA": "California", "NY": "New York"]
let d2 = d.filter{$0.value &gt; "New Jersey"}.mapValues{$0.uppercased()}
// ["NY": "NEW YORK"]</pre>

<p class="author1">You can combine two dictionaries with the <code class="calibre19">merging(_:uniquingKeysWith:)</code> method &mdash; or, if your reference to the first dictionary is mutable, you can call <code class="calibre19">merge</code> to modify it directly. The second parameter is like the second parameter of <code class="calibre19">init(_:uniquingKeysWith:)</code>, saying what the value should be in case the second dictionary has a key matching an existing key in the first dictionary:<a data-type="indexterm" data-primary="dictionaries" data-secondary="merging" id="calibre_link-672" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="merging dictionaries" id="calibre_link-1322" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let d1 = ["CA": "California", "NY": "New York"]
let d2 = ["MD": "Maryland", "NY": "New York"]
let d3 = d1.merging(d2){orig, _ in orig}
// ["MD": "Maryland", "NY": "New York", "CA": "California"]</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Swift Dictionary and Objective-C NSDictionary" class="calibre2"><div class="preface" id="calibre_link-63">
<h3 class="calibre44">Swift Dictionary and Objective-C NSDictionary</h3>

<p class="author1">The Foundation framework dictionary type is NSDictionary<a data-type="indexterm" data-primary="NSDictionary" id="calibre_link-1438" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, and Swift Dictionary is bridged to it. The untyped API characterization of an NSDictionary will be <code class="calibre19">[AnyHashable:Any]</code> (AnyHashable is a <em class="calibre11">type eraser</em> struct, to cope with the possibility, legal in Objective-C, that the keys may be of different Hashable types).<a data-type="indexterm" data-primary="bridged types" data-secondary="Dictionary and NSDictionary" id="calibre_link-290" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="AnyHashable" id="calibre_link-142" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="eraser" id="calibre_link-2232" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Like NSArray element types, NSDictionary key and value types can be marked in Objective-C using a lightweight generic. The most common key type in a real-life Cocoa NSDictionary is NSString, so you might well receive an NSDictionary typed as <code class="calibre19">[String:Any]</code>. Specific typing of an NSDictionaryâ€™s <em class="calibre11">values</em> is rare, because dictionaries that you pass to and receive from Cocoa will often have values of multiple types; it is not surprising to have a dictionary whose keys are strings but whose values include a string, a number, a color, and an array. For this reason, you will usually <em class="calibre11">not</em> cast down the entire dictionaryâ€™s type; instead, youâ€™ll work with the dictionary as having Any values, and cast when fetching an <em class="calibre11">individual value</em> from the dictionary. Since the value returned from subscripting a key is itself an Optional, you will typically unwrap and cast the value as a standard single move.</p>

<p class="author1">Hereâ€™s an example. A Cocoa Notification object comes with a <code class="calibre19">userInfo</code> property. It is an NSDictionary that might itself be <code class="calibre19">nil</code>, so the Swift API characterizes it as <code class="calibre19">[AnyHashable:Any]?</code>. Letâ€™s say Iâ€™m expecting this dictionary to be present and to contain a <code class="calibre19">"progress"</code> key whose value is an NSNumber containing a Double. My goal is to extract that NSNumber and assign the Double that it contains to a property, <code class="calibre19">self.progress</code>. Hereâ€™s one way to do that safely, using optional unwrapping and optional casting (<code class="calibre19">n</code> is the Notification object):</p>

<pre data-type="programlisting" class="calibre28">let prog = n.userInfo?["progress"] as? Double
if prog != nil {
    self.progress = prog!
}</pre>

<p class="author1">The variable <code class="calibre19">prog</code> is implicitly typed as an Optional wrapping a Double. The code is safe, because if there is no <code class="calibre19">userInfo</code> dictionary, or if it doesnâ€™t contain a <code class="calibre19">"progress"</code> key, or if that keyâ€™s value isnâ€™t a Double, nothing happens, and <code class="calibre19">prog</code> will be <code class="calibre19">nil</code>. I then test <code class="calibre19">prog</code> to see whether it <em class="calibre11">is</em> <code class="calibre19">nil</code>; if it isnâ€™t, I know that itâ€™s safe to force-unwrap it, and that the unwrapped value is the Double Iâ€™m after.</p>

<p class="author1">(In <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> Iâ€™ll describe another syntax for accomplishing the same goal, using conditional binding.)</p>

<p class="author1">Conversely, hereâ€™s a typical example of creating a dictionary and handing it off to Cocoa. This dictionary is a mixed bag: its values are a UIFont, a UIColor, and an NSShadow. Its keys are all strings, which I obtain as constants from Cocoa. I form the dictionary as a literal and pass it, all in one move, with no need to cast anything:</p>

<pre data-type="programlisting" class="calibre28">UINavigationBar.appearance().titleTextAttributes = [
    .font: UIFont(name: "ChalkboardSE-Bold", size: 20)!,
    .foregroundColor: UIColor.darkText,
    .shadow.: {
        let shad = NSShadow()
        shad.shadowOffset = CGSize(width:1.5,height:1.5)
        return shad
    }()
]</pre>

<p class="author1">As with NSArray and NSMutableArray, if you want Cocoa to mutate a dictionary, you must coerce to NSDictionaryâ€™s subclass NSMutableDictionary<a data-type="indexterm" data-primary="NSMutableDictionary" id="calibre_link-1449" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>: <a data-type="indexterm" data-startref="idxdictionary" id="calibre_link-663" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var d1 = ["NY":"New York", "CA":"California"]
let d2 = ["MD":"Maryland"]
let mutd1 = NSMutableDictionary(dictionary:d1)
mutd1.addEntries(from:d2)
d1 = mutd1 as! [String:String]
// d1 is now ["MD": "Maryland", "NY": "New York", "CA": "California"]</pre>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Set" class="calibre2"><div class="preface" id="calibre_link-2519">
<h2 class="calibre42">Set</h2>

<p class="author1">A set (Set, a struct) is an unordered collection of unique objects. Its elements must be all of one type; it has a <code class="calibre19">count</code> and an <code class="calibre19">isEmpty</code> property; it can be initialized from any sequence; you can cycle through its elements with <code class="calibre19">for...in</code> (where the order of elements is unpredictable).<a data-type="indexterm" data-primary="Set" id="calibre_link-2003" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="count" id="calibre_link-557" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="isEmpty" id="calibre_link-1165" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" id="calibre_link-2004" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The uniqueness of set elements is implemented by constraining their type to be Hashable (and hence Equatable), just like the keys of a dictionary, so that the hash values can be used behind the scenes for rapid access. Checking whether a set contains a given element, which you can do with the <code class="calibre19">contains(_:)</code> instance method, is <em class="calibre11">very</em> efficient &mdash; far more efficient than doing the same thing with an array. Therefore, if element uniqueness is acceptable (or desirable) and you donâ€™t need indexing or a guaranteed order, a set can be a much better choice of collection than an array.
<a data-type="indexterm" data-primary="Hashable" id="calibre_link-1002" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" data-secondary="hashable elements" id="calibre_link-2009" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">(The warnings in the preceding section apply: donâ€™t store a mutable value in a Set, and donâ€™t expect Set values to be reported to you in any particular order. Iâ€™ll talk in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> about how to make your own types Hashable.)</p>

<p class="author1">There are no set literals in Swift, but you wonâ€™t need them because you can pass an array literal where a set is expected. There is no syntactic sugar for expressing a set type, but the Set struct is a generic, so you can express the type by explicitly specializing the generic:<a data-type="indexterm" data-primary="sets" data-secondary="initializers" id="calibre_link-2011" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" data-secondary="literals" id="calibre_link-2012" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" data-secondary="declaration" id="calibre_link-2007" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of sets" id="calibre_link-631" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let set : Set&lt;Int&gt; = [1, 2, 3, 4, 5]</pre>

<p class="author1">In that particular example there was no real need to specialize the generic, as the Int type can be inferred from the array; however, when setting a Set variable from a literal, it is more efficient to specialize the generic and save the compiler the trouble of reading the whole literal.</p>

<p class="author1">It sometimes happens (more often than you might suppose) that you want to examine one element of a set as a kind of sample. Order is meaningless, so itâ€™s sufficient to obtain <em class="calibre11">any</em> element, such as the first element. For this purpose, use the <code class="calibre19">first</code> instance property; it returns an Optional, just in case the set is empty.<a data-type="indexterm" data-primary="sets" data-secondary="sampling" id="calibre_link-2017" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The distinctive feature of a set is the uniqueness of its objects. If an object is added to a set and that object is already present, it isnâ€™t added a second time. Conversion from an array to a set and back to an array is thus a quick and reliable way of <em class="calibre11">uniquing</em> the array &mdash; though of course order is not preserved:<a data-type="indexterm" data-primary="unique an array" id="calibre_link-2277" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="uniquing" id="calibre_link-207" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = [1,2,1,3,2,4,3,5]
let set = Set(arr)
let arr2 = Array(set) // [5, 2, 3, 1, 4], perhaps</pre>

<p class="author1">A set is a Collection and a Sequence, so it is analogous to an array or a dictionary, and what I have already said about those types generally applies to a set as well. For example, Set has a <code class="calibre19">map(_:)</code> instance method; it returns an array, but of course you can turn that right back into a set if you need to:<a data-type="indexterm" data-primary="sets" data-secondary="transformations" id="calibre_link-2018" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let set : Set = [1,2,3,4,5]
let set2 = Set(set.map{$0+1}) // Set containing 2, 3, 4, 5, 6</pre>

<p class="author1">On the other hand, applying <code class="calibre19">filter</code> to a Set yields a Set directly:</p>

<pre data-type="programlisting" class="calibre28">let set : Set = [1,2,3,4,5]
let set2 = set.filter{$0&gt;3} // Set containing 4, 5</pre>

<p class="author1">If the reference to a set is mutable, you can add an object to it with <code class="calibre19">insert(_:)</code>; there is no penalty for trying to add an object thatâ€™s already in the set, but the object wonâ€™t be added. <code class="calibre19">insert(_:)</code> also returns a result, a tuple whose <code class="calibre19">inserted</code> element will be <code class="calibre19">false</code> if an equivalent object was already present in the set. This result is usually disregarded, but it can sometimes be useful. For example, it is the basis of a commonly used approach to uniquing an array while preserving its order:</p>

<pre data-type="programlisting" class="calibre28">var arr = ["Mannie", "Mannie", "Moe", "Jack", "Jack", "Moe", "Mannie"]
var temp = Set&lt;String&gt;()
arr = arr.filter { temp.insert($0).inserted }</pre>

<p class="author1">The other element of the tuple returned by <code class="calibre19">insert(_:)</code> is <code class="calibre19">memberAfterInsert</code>. If <code class="calibre19">inserted</code> is <code class="calibre19">true</code>, this is simply the parameter of <code class="calibre19">insert(_:)</code>. If <code class="calibre19">inserted</code> is <code class="calibre19">false</code>, however, it is the existing member of the set that caused the insertion to fail because it is regarded as equal to the parameter of <code class="calibre19">insert(_:)</code>; this may be of interest because it tells you <em class="calibre11">why</em> the insertion was rejected.</p>

<p class="author1">Instead of <code class="calibre19">insert(_:)</code>, you can call <code class="calibre19">update(with:)</code>; the difference is that if youâ€™re trying to add an object that already has an equivalent in the set, the former doesnâ€™t insert the new object, but the latter <em class="calibre11">always</em> succeeds, replacing the old object (if there is one) with the new one.</p>

<p class="author1">You can remove an object and return it by specifying an equivalent object with the <code class="calibre19">remove(_:)</code> method; it returns the object from the set, wrapped in an Optional, or <code class="calibre19">nil</code> if the object was not present. You can remove and return an arbitrary object from the set with <code class="calibre19">removeFirst</code>; it crashes if the set is empty, so take precautions &mdash; or use <code class="calibre19">popFirst</code>, which is safe.<a data-type="indexterm" data-primary="sets" data-secondary="mutating" id="calibre_link-2013" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Equality comparison (<code class="calibre19">==</code>) is defined for sets as you would expect; two sets are equal if every element of each is equal to an element of the other.<a data-type="indexterm" data-primary="sets" data-secondary="equality" id="calibre_link-2008" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If the notion of a set evokes visions of Venn diagrams from elementary school, thatâ€™s good, because sets have instance methods giving you all those set operations you remember so fondly. The parameter can be a set, or it can be any sequence, which will be converted to a set; for example, it might be an array, a range, or even a character sequence:<a data-type="indexterm" data-primary="sets" data-secondary="operations" id="calibre_link-2014" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">intersection(_:)</code>, <code class="calibre19">formIntersection(_:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Yields the elements of this set that also appear in the parameter. The first forms a new Set; the second is mutating.</p>
</dd>
<dt class="calibre15"><code class="calibre19">union(_:)</code>, <code class="calibre19">formUnion(_:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Yields the elements of this set along with the (unique) elements of the parameter. The first forms a new Set; the second is mutating.</p>
</dd>
<dt class="calibre15"><code class="calibre19">symmetricDifference(_:)</code>, <code class="calibre19">formSymmetricDifference(_:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Yields the elements of this set that donâ€™t appear in the parameter, plus the (unique) elements of the parameter that donâ€™t appear in this set. The first forms a new Set; the second is mutating.</p>
</dd>
<dt class="calibre15"><code class="calibre19">subtracting(_:)</code>, <code class="calibre19">subtract(_:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Yields the elements of this set except for those that appear in the parameter. The first forms a new Set; the second is mutating.</p>
</dd>
<dt class="calibre15"><code class="calibre19">isSubset(of:)</code>, <code class="calibre19">isStrictSubset(of:)</code></dt>
<dt class="calibre15"><code class="calibre19">isSuperset(of:)</code>, <code class="calibre19">isStrictSuperset(of:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Returns a Bool reporting whether the elements of this set are respectively embraced by or embrace the elements of the parameter. The â€œstrictâ€ variant yields <code class="calibre19">false</code> if the two sets consist of the same elements.</p>
</dd>
<dt class="calibre15"><code class="calibre19">isDisjoint(with:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Returns a Bool reporting whether this set and the parameter have no elements in common.</p>
</dd>
</dl>

<p class="author1">Hereâ€™s a real-life example of elegant Set usage from one of my apps. I have a lot of numbered pictures, of which we are to choose one randomly. But I donâ€™t want to choose a picture that has recently been chosen. Therefore, I keep a list of the numbers of all recently chosen pictures. When itâ€™s time to choose a new picture, I convert the list of all possible numbers to a Set, convert the list of recently chosen picture numbers to a Set, and call <code class="calibre19">subtracting(_:)</code> to get a list of unused picture numbers! Now I choose a picture number at random and add it to the list of recently chosen picture numbers:</p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
let recents = ud.object(forKey: Defaults.recents) as? [Int] ?? []
var forbiddenNumbers = Set(recents)
let legalNumbers = Set(1...PIXCOUNT).subtracting(forbiddenNumbers)
let newNumber = legalNumbers.randomElement()!
forbiddenNumbers.insert(newNumber)
ud.set(Array(forbiddenNumbers), forKey:Defaults.recents)</pre>










<section data-type="sect3" data-pdf-bookmark="Option sets" class="calibre2"><div class="preface" id="calibre_link-70">
<h3 class="calibre44">Option sets</h3>

<p class="author1">An <em class="calibre11">option set</em> (OptionSet struct) is Swiftâ€™s way of treating a certain type of Cocoa enumeration as a Swift struct. It is not, strictly speaking, a Set; but it is deliberately set-like, sharing common features with Set through the <span class="publishername">SetAlgebra</span> protocol. Thus, an option set has <code class="calibre19">contains(_:)</code>, <code class="calibre19">insert(_:)</code>, and <code class="calibre19">remove(_:)</code> methods, along with all the various set operation methods.<a data-type="indexterm" data-primary="OptionSet" id="calibre_link-1631" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="option sets" id="calibre_link-1584" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" data-secondary="option sets" id="calibre_link-2015" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bitwise operators" data-seealso="option sets" id="calibre_link-259" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="bitwise" data-seealso="option sets" id="calibre_link-1564" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The purpose of option sets is to help you grapple with Objective-C <em class="calibre11">bitmasks</em>. A bitmask is an integer whose bits are used as switches when multiple options are to be specified simultaneously. Bitmasks are very common in Cocoa. In Objective-C, bitmasks are manipulated through the arithmetic bitwise-or and bitwise-and operators. Such manipulation can be mysterious and error-prone. But in Swift, thanks to option sets, bitmasks can be manipulated easily through set operations instead.<a data-type="indexterm" data-primary="bitmasks" id="calibre_link-256" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, when specifying how a UIView is to be animated, you are allowed to pass an <code class="calibre19">options:</code> argument whose value comes from the <span class="publishername">UIView.AnimationOptions</span> enumeration, whose definition (in Objective-C) begins as follows:</p>

<pre data-type="programlisting" class="calibre28">typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) {
    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt; 0,
    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt; 1,
    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt; 2,
    UIViewAnimationOptionRepeat                    = 1 &lt;&lt; 3,
    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt; 4,
    // ...
};</pre>

<p class="author1">Pretend that an NSUInteger is 8 bits (it isnâ€™t, but letâ€™s keep things simple and short). Then this enumeration means that (in Swift) the following name&ndash;value pairs are defined:</p>

<pre data-type="programlisting" class="calibre28">UIView.AnimationOptions.layoutSubviews          0b00000001
UIView.AnimationOptions.allowUserInteraction    0b00000010
UIView.AnimationOptions.beginFromCurrentState   0b00000100
UIView.AnimationOptions.repeat                  0b00001000
UIView.AnimationOptions.autoreverse             0b00010000</pre>

<p class="author1">These values can be combined into a single value &mdash; a <em class="calibre11">bitmask</em> &mdash; that you pass as the <code class="calibre19">options:</code> argument for your animation. All Cocoa has to do to understand your intentions is to look to see which bits in the value that you pass are set to 1. So, for example, <code class="calibre19">0b00011000</code> would mean that <code class="calibre19">UIView.AnimationOptions.repeat</code> and <code class="calibre19">UIView.AnimationOptions.autoreverse</code> are both true (and that the others are all false).</p>

<p class="author1">The question is how to <em class="calibre11">form</em> the value <code class="calibre19">0b00011000</code> in order to pass it. You could form it directly as a literal and set the <code class="calibre19">options:</code> argument to <code class="calibre19">UIView.AnimationOptions(rawValue:0b00011000)</code>; but thatâ€™s not a very good idea, because itâ€™s error-prone and makes your code incomprehensible. In Objective-C, youâ€™d use the arithmetic bitwise-or operator, analogous to this Swift code:</p>

<pre data-type="programlisting" class="calibre28">let val =
    UIView.AnimationOptions.autoreverse.rawValue |
    UIView.AnimationOptions.repeat.rawValue
let opts = UIView.AnimationOptions(rawValue: val)</pre>

<p class="author1">Thatâ€™s rather ugly! However, help is on the way: The <span class="publishername">UIView.AnimationOptions</span> type is an option set struct in Swift (because it is marked as <code class="calibre19">NS_OPTIONS</code> in Objective-C), and therefore can be treated much like a Set. For example, given a <span class="publishername">UIView.AnimationOptions</span> value, you can add an option to it using <code class="calibre19">insert(_:)</code>:</p>

<pre data-type="programlisting" class="calibre28">var opts = UIView.AnimationOptions.autoreverse
opts.insert(.repeat)</pre>

<p class="author1">Alternatively, you can start with an array literal, just as if you were initializing a Set:</p>

<pre data-type="programlisting" class="calibre28">let opts : UIView.AnimationOptions = [.autoreverse, .repeat]</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">To indicate that no options are to be set, pass an empty option set (<code class="calibre19">[]</code>) or, where permitted, omit the <code class="calibre19">options:</code> parameter altogether.<a data-type="indexterm" data-primary="option sets" data-secondary="empty" id="calibre_link-1586" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>

<p class="author1">Sometimes Cocoa hands <em class="calibre11">you</em> a bitmask, and you want to know whether a certain bit is set. In this example from a UITableViewCell subclass, the cellâ€™s <code class="calibre19">state</code> comes to us as a bitmask; we want to know about the bit indicating that the cell is showing its edit control. The Objective-C way is to extract the raw values and use the bitwise-and operator:</p>

<pre data-type="programlisting" class="calibre28">override func didTransition(to state: UITableViewCell.StateMask) {
    let editing = UITableViewCell.StateMask.showingEditControl.rawValue
    if state.rawValue &amp; editing != 0 {
        // ... the ShowingEditControl bit is set ...
    }
}</pre>

<p class="author1">Thatâ€™s a tricky formula, all too easy to get wrong. But in Swift this is an option set, so the <code class="calibre19">contains(_:)</code> method tells you the answer:</p>

<pre data-type="programlisting" class="calibre28">override func didTransition(to state: UITableViewCell.StateMask) {
    if state.contains(.showingEditControl) {
        // ... the ShowingEditControl bit is set ...
    }
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Swift Set and Objective-C NSSet" class="calibre2"><div class="preface" id="calibre_link-64">
<h3 class="calibre44">Swift Set and Objective-C NSSet</h3>

<p class="author1">Swiftâ€™s Set type is bridged to Objective-C NSSet. The untyped medium of interchange is <code class="calibre19">Set&lt;AnyHashable&gt;</code>. Coming back from Objective-C, if Objective-C doesnâ€™t know what this is a set of, you would probably cast down as needed. As with NSArray, however, NSSet can be marked up using lightweight generics to indicate its element type, in which case no casting will be necessary:<a data-type="indexterm" data-startref="idxset" id="calibre_link-2005" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxcollectionswift" id="calibre_link-458" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
    let t = touches.first // an Optional wrapping a UITouch
    // ...
}</pre>
</div>
</section>



</div>
</section>





</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2841">
<div id="calibre_link-2957" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 5. Flow Control and More" class="calibre2"><div class="preface" id="calibre_link-20">
<h1 class="calibre13"><span class="label">Chapter 5. </span>Flow Control and More</h1>


<p class="author1">This chapter is a miscellany, presenting various remaining aspects of the Swift language. Iâ€™ll start by describing the syntax of Swiftâ€™s flow control constructs for branching, looping, and jumping. Then Iâ€™ll summarize Swiftâ€™s privacy and introspection features, and talk about how to override operators and how to create your own operators. Next Iâ€™ll explain some specialized aspects of Swift memory management. Finally Iâ€™ll survey some recently added Swift language features: synthesized protocol implementations, key paths, dynamic members, property wrappers, custom string interpolation, reverse generics, function builders, and Result.</p>






<section data-type="sect1" data-pdf-bookmark="Flow Control" class="calibre2"><div class="preface" id="calibre_link-2520">
<h1 class="calibre18">Flow Control</h1>

<p class="author1">A computer program has a <em class="calibre11">path of execution</em> through its code statements. Normally, this path follows a simple rule: execute each statement in succession. But there is another possibility. <em class="calibre11">Flow control</em> can be used to make the path of execution skip some code statements, or go back and repeat some code statements.</p>

<p class="author1">Flow control is what makes a computer program â€œintelligent.â€
By testing in real time the truth value of a <em class="calibre11">condition</em> &mdash; an expression that evaluates to a Bool and is thus <code class="calibre19">true</code> or <code class="calibre19">false</code> &mdash; the program decides <em class="calibre11">at that moment</em> how to proceed. Flow control based on testing a condition may be divided into two general types:<a data-type="indexterm" data-primary="branching" id="calibre_link-270" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="flow control" id="calibre_link-873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="control flow" data-see="flow control" id="calibre_link-2958" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Branching</dt>
<dd class="calibre16">
<p class="calibre17">The code is divided into alternative chunks, like roads that diverge in a wood, and the program is presented with a choice of possible ways to go; the truth of a condition is used to determine which chunk will actually be executed.<a data-type="indexterm" data-primary="conditions" id="calibre_link-519" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Looping</dt>
<dd class="calibre16">
<p class="calibre17">A chunk of code is marked off for possible repetition; the truth of a condition is used to determine whether the chunk should be executed, and then whether it should be executed again. Each repetition is called an <em class="calibre11">iteration</em>.<a data-type="indexterm" data-primary="looping" id="calibre_link-1251" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="iteration" id="calibre_link-1169" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">The chunks of code in flow control, which I refer to as <em class="calibre11">blocks</em>, are demarcated by curly braces<a data-type="indexterm" data-primary="curly braces" id="calibre_link-591" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. These curly braces constitute a scope (<a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>). New local variables can be declared here, and go out of existence automatically when the path of execution exits the curly braces (<a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>). For a loop, this means that local variables come into existence and go out of existence on each iteration. As with any scope, code inside the curly braces can see the surrounding higher scope.<a data-type="indexterm" data-primary="blocks" data-secondary="flow control" id="calibre_link-263" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swift flow control is fairly simple, and by and large is similar to flow control in C and related languages. There are two fundamental syntactic differences between Swift and C, both of which make Swift simpler and clearer:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A condition <em class="calibre11">does not have to be wrapped in parentheses</em> in Swift.</p>
</li>
<li class="calibre12">
<p class="calibre17">The curly braces <em class="calibre11">can never be omitted</em> in Swift.</p>
</li>
</ul>

<p class="author1">Moreover, Swift adds some specialized flow control features to help you grapple more conveniently with Optionals, and boasts a particularly powerful form of switch <span class="publishername">statement.</span></p>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2959">
<h5 class="calibre36">Trailing Closures and Flow Control Blocks</h5>
<p class="calibre37">Trailing closures do not play well with subsequent flow control blocks; therefore parentheses are sometimes needed where generally they would not be. The closing curly brace of the trailing closure, followed by the opening curly brace of the block, upsets the compiler:<a data-type="indexterm" data-primary="errors, compile" data-secondary="trailing closure requires parentheses" id="calibre_link-786" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">for i in arr.map {$0*2} { // compile error
    print(i)
}</pre>

<p class="calibre37">You have to demarcate the expression containing the trailing closure with parentheses:</p>

<pre data-type="programlisting" class="calibre38">for i in (arr.map {$0*2}) {
    print(i)
}</pre>

<p class="calibre37">This doesnâ€™t compile either, and the error messages make no sense:</p>

<pre data-type="programlisting" class="calibre38">if arr.map {$0*2}.first == 4 { // compile error</pre>

<p class="calibre37">Again, parentheses are the simplest solution:</p>

<pre data-type="programlisting" class="calibre38">if (arr.map {$0*2}.first) == 4 {</pre>
</div>
</aside>








<section data-type="sect2" data-pdf-bookmark="Branching" class="calibre2"><div class="preface" id="calibre_link-2521">
<h2 class="calibre42">Branching</h2>

<p class="author1">Swift has two forms of branching: the if construct, and the switch statement. Iâ€™ll also discuss conditional evaluation, a compact form of if construct.</p>










<section data-type="sect3" data-pdf-bookmark="If construct" class="calibre2"><div class="preface" id="calibre_link-2960">
<h3 class="calibre44">If construct</h3>

<p class="author1">The Swift branching construct with <code class="calibre19">if</code> is similar to C. Many examples of if constructs have appeared already in this book. The construct may be formally summarized as shown in <a data-type="xref" href="#calibre_link-2842" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;5-1</a>.<a data-type="indexterm" data-primary="if" id="calibre_link-1038" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-2842" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 5-1. </span>The Swift if construct</h5>

<pre data-type="programlisting" class="calibre31">if <em class="calibre43">condition</em> {
    <em class="calibre43">statements</em>
}

if <em class="calibre43">condition</em> {
    <em class="calibre43">statements</em>
} else {
    <em class="calibre43">statements</em>
}

if <em class="calibre43">condition</em> {
    <em class="calibre43">statements</em>
} else if <em class="calibre43">condition</em> {
    <em class="calibre43">statements</em>
} else {
    <em class="calibre43">statements</em>
}</pre>
</div>

<p class="author1">The third form, containing <code class="calibre19">else if</code>, can have as many <code class="calibre19">else if</code> blocks as needed, and the final <code class="calibre19">else</code> block may be omitted.</p>

<p class="author1">Hereâ€™s a real-life if construct that lies at the heart of one of my apps:</p>

<pre data-type="programlisting" class="calibre28">// okay, we've tapped a tile; there are three cases
if self.selectedTile == nil { // no selected tile: select and play this tile
    self.select(tile:tile)
    self.play(tile:tile)
} else if self.selectedTile == tile { // selected tile tapped: deselect it
    self.deselectAll()
    self.player?.pause()
} else { // there was a selected tile, another tile was tapped: swap them
    self.swap(self.selectedTile, with:tile, check:true, fence:true)
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Conditional binding" class="calibre2"><div class="preface" id="calibre_link-2961">
<h3 class="calibre44">Conditional binding</h3>

<p class="author1">In Swift, <code class="calibre19">if</code> can be followed immediately by a variable declaration and assignment &mdash; that is, by <code class="calibre19">let</code> or <code class="calibre19">var</code> and a new local variable name, possibly followed by a colon and a type declaration, then an equal sign and a value, as follows:</p>

<pre data-type="programlisting" class="calibre28">if let <em class="calibre43">var</em> = <em class="calibre43">val</em> {
    // the block
}</pre>

<p class="author1">This syntax, called a <em class="calibre11">conditional binding</em>, is actually a shorthand for <em class="calibre11">conditionally unwrapping an Optional.</em> The assigned value (<em class="calibre11"><code class="calibre22">val</code></em>) is expected to be an Optional &mdash; the compiler will stop you if it isnâ€™t &mdash; and this is what happens:<a data-type="indexterm" data-primary="binding, conditional" id="calibre_link-252" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conditional binding" id="calibre_link-511" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="if let" id="calibre_link-1040" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1625" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If the Optional (<em class="calibre11"><code class="calibre22">val</code></em>) is <code class="calibre19">nil</code>, the condition fails and the block is skipped, with execution resuming after the block.</p>
</li>
<li class="calibre12">
<p class="calibre17">If the Optional is <em class="calibre11">not</em> <code class="calibre19">nil</code>, then:</p>
<ol class="calibre3">
<li class="calibre52">
<p class="calibre17">The Optional is unwrapped.</p>
</li>
<li class="calibre52">
<p class="calibre17">The unwrapped value is assigned to the declared local variable (<em class="calibre11"><code class="calibre22">var</code></em>).</p>
</li>
<li class="calibre52">
<p class="calibre17">The block is executed with the local variable in scope. The local variable is <em class="calibre11">not</em> in scope outside the block.</p>
</li>

</ol>
</li>
</ul>

<p class="author1">Thus, a conditional binding is a convenient shorthand for safely passing an unwrapped Optional into a block. The Optional is unwrapped, and the block is executed, only if the Optional <em class="calibre11">can</em> be unwrapped.</p>

<p class="author1">It is perfectly reasonable for the local variable in a conditional binding to have the same name as an existing variable in the surrounding scope. It can even have the same name as the Optional being unwrapped! There is then no need to make up a new name, and inside the block the unwrapped value of the Optional neatly overshadows the original Optional so that the latter canâ€™t be accessed accidentally.</p>

<p class="author1">Hereâ€™s an example of a conditional binding. Recall this code from <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, where I optionally unwrap a Notificationâ€™s <code class="calibre19">userInfo</code> dictionary, attempt to fetch a value from the dictionary using the <code class="calibre19">"progress"</code> key, and proceed only if that value turns out to be an NSNumber that can be cast down to a Double:</p>

<pre data-type="programlisting" class="calibre28">let prog = n.userInfo?["progress"] as? Double
if prog != nil {
    self.progress = prog!
}</pre>

<p class="author1">We can rewrite that code more elegantly and compactly as a conditional binding:</p>

<pre data-type="programlisting" class="calibre28">if let prog = n.userInfo?["progress"] as? Double {
    self.progress = prog
}</pre>

<p class="author1">It is also possible to nest conditional bindings. To illustrate, Iâ€™ll rewrite the previous example to use a separate conditional binding for each Optional in the chain:</p>

<pre data-type="programlisting" class="calibre28">if let ui = n.userInfo {
    if let prog = ui["progress"] as? Double {
        self.progress = prog
    }
}</pre>

<p class="author1">The result, if the chain involves many optional unwrappings, can be somewhat verbose and the nest can become deeply indented &mdash; Swift programmers like to call this the â€œpyramid of doomâ€. To help avoid the indentation, successive conditional bindings can be combined into a <em class="calibre11">condition list</em>, with each condition separated by a comma:<a data-type="indexterm" data-primary="condition list" id="calibre_link-509" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comma" data-secondary="condition list" id="calibre_link-474" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="pyramid of doom" id="calibre_link-1825" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="doom, pyramid of" id="calibre_link-702" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">if let ui = n.userInfo, let prog = ui["progress"] as? Double {
    self.progress = prog
}</pre>

<p class="author1">In that code, the assignment to <code class="calibre19">prog</code> wonâ€™t even be attempted if <code class="calibre19">n.userInfo</code> is <code class="calibre19">nil</code>; the assignment to <code class="calibre19">ui</code> fails and thatâ€™s the end.</p>

<p class="author1">Condition lists do not have to consist solely of conditional bindings. They can include ordinary conditions. The important thing is the left-to-right order of evaluation, which allows each condition to depend upon the previous one. Thus it would be possible (though not as elegant) to rewrite the previous example like this:</p>

<pre data-type="programlisting" class="calibre28">if let ui = n.userInfo, let prog = ui["progress"], prog is Double {
    self.progress = prog as! Double
}</pre>

<p class="author1">Nevertheless, I am not fond of this kind of extended condition list. I actually prefer the pyramid of doom, where the structure reflects perfectly the successive stages of testing. If I want to avoid the pyramid of doom, I can usually use a sequence of <code class="calibre19">guard</code> statements (<a data-type="xref" href="#calibre_link-2843" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œGuardâ€</a>):</p>

<pre data-type="programlisting" class="calibre28">guard let ui = n.userInfo else {return}
guard let prog = ui["progress"] as? Double else {return}
self.progress = prog</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Switch statement" class="calibre2"><div class="preface" id="calibre_link-2962">
<h3 class="calibre44">Switch statement</h3>

<p class="author1">A switch statement is a neater way of writing an extended <code class="calibre19">if...else if...else</code> construct. In C (and Objective-C), a switch statement contains hidden traps; Swift eliminates those traps, and adds power and flexibility. As a result, switch statements are commonly used in Swift (whereas they are relatively rare in my Objective-C code).<a data-type="indexterm" data-primary="switch" id="calibre_link-2181" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In a switch statement, the condition involves the comparison of different possible values, called <em class="calibre11">cases</em>, against a single value, called the <em class="calibre11">tag</em>. The case comparisons are performed <em class="calibre11">successively in order</em>. As soon as a case comparison succeeds, that caseâ€™s code is executed and the entire switch statement is exited. The schema is shown in <a data-type="xref" href="#calibre_link-2844" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;5-2</a>; there can be as many cases as needed, and the <code class="calibre19">default</code> case can be omitted (subject to restrictions that Iâ€™ll explain in a moment).<a data-type="indexterm" data-primary="case" data-secondary="switch statement" id="calibre_link-341" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-2844" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 5-2. </span>The Swift switch statement</h5>

<pre data-type="programlisting" class="calibre31">switch <em class="calibre43">tag</em> {
case <em class="calibre43">pattern1</em>:
    <em class="calibre43">statements</em>
case <em class="calibre43">pattern2</em>:
    <em class="calibre43">statements</em>
default:
    <em class="calibre43">statements</em>
}</pre>
</div>

<p class="author1">Hereâ€™s an actual example:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1:
    print("You have 1 thingy!")
case 2:
    print("You have 2 thingies!")
default:
    print("You have \(i) thingies!")
}</pre>

<p class="author1">In that code, an Int variable <code class="calibre19">i</code> functions as the tag. The value of <code class="calibre19">i</code> is first compared to the value <code class="calibre19">1</code>. If it <em class="calibre11">is</em> <code class="calibre19">1</code>, that caseâ€™s code is executed and thatâ€™s all. If it is <em class="calibre11">not</em> <code class="calibre19">1</code>, it is compared to the value <code class="calibre19">2</code>. If it <em class="calibre11">is</em> <code class="calibre19">2</code>, <em class="calibre11">that</em> caseâ€™s code is executed and thatâ€™s all. If the value of <code class="calibre19">i</code> matches neither of those, the <code class="calibre19">default</code> caseâ€™s code is executed.</p>

<p class="author1">In Swift, a switch statement must be <em class="calibre11">exhaustive</em>. This means that <em class="calibre11">every</em> possible value of the tag must be covered by a case. The compiler will stop you if you try to violate this rule. If you donâ€™t want to write every case explicitly, you must add a â€œmop-upâ€ case that covers all other cases; a common way to do that is to add a <code class="calibre19">default</code> case. Itâ€™s easy to write an exhaustive switch when the tag is an enum with a small number of cases, but when the tag is an Int, there is an infinite number of possible cases, so a â€œmop-upâ€ case <em class="calibre11">must</em> appear.</p>

<p class="author1">Each caseâ€™s code can consist of multiple lines; it doesnâ€™t have to be a single line, like the cases in the preceding example. However, it must consist of <em class="calibre11">at least</em> a single line; it is illegal for a Swift switch case to be empty. It is legal for the first (or only) line of a caseâ€™s code to appear on the same line as the case, after the colon; thus, I could have written the preceding example like this:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1: print("You have 1 thingy!")
case 2: print("You have 2 thingies!")
default: print("You have \(i) thingies!")
}</pre>

<p class="author1">The minimum single line of case code is the keyword <code class="calibre19">break</code>; used in this way, <code class="calibre19">break</code> acts as a placeholder meaning, â€œDo nothing.â€ It is very common for a switch statement to include a <code class="calibre19">default</code> (or other â€œmop-upâ€ case) consisting of nothing but the keyword <code class="calibre19">break</code>; in this way, you exhaust all possible values of the tag, but if the value is one that no case explicitly covers, you do nothing.</p>

<p class="author1">Now letâ€™s focus on the comparison between the tag value and the case value. In the preceding example, it works like an equality comparison (<code class="calibre19">==</code>); but that isnâ€™t the only possibility. In Swift, a case value is actually a special expression called a <em class="calibre11">pattern</em>, and the pattern is compared to the tag value using a â€œsecretâ€ pattern-matching operator, <code class="calibre19">~=</code>. The more you know about the syntax for constructing a pattern, the more powerful your case values and your switch statements will be.<a data-type="indexterm" data-primary="patterns, switch statement" id="calibre_link-1691" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A pattern can include an underscore (<code class="calibre19">_</code>) to absorb all values without using them. An underscore case is thus an alternative form of â€œmop-upâ€ case:<a data-type="indexterm" data-primary="underscore" data-secondary="mop-up switch case" id="calibre_link-2271" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1:
    print("You have 1 thingy!")
case _:
    print("You have many thingies!")
}</pre>

<p class="author1">A pattern can include a declaration of a local variable name (an unconditional binding) to absorb all values and use the actual value. This is yet another alternative form of â€œmop-upâ€ case:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1:
    print("You have 1 thingy!")
case let n:
    print("You have \(n) thingies!")
}</pre>

<p class="author1">When the tag is a Comparable, a case can include a Range; the test involves sending the Range the <code class="calibre19">contains</code> message:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1:
    print("You have 1 thingy!")
case 2...10:
    print("You have \(i) thingies!")
default:
    print("You have more thingies than I can count!")
}</pre>

<p class="author1">When the tag is an Optional, a case can test it against <code class="calibre19">nil</code>. Moreover, appending <code class="calibre19">?</code> to a case pattern safely unwraps an Optional tag.<a data-type="indexterm" data-primary="question mark" id="calibre_link-1831" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Thus, if <code class="calibre19">i</code> is an Optional wrapping an Int:<a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1626" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1?:
    print("You have 1 thingy!")
case let n?:
    print("You have \(n) thingies!")
case nil: break
}</pre>

<p class="author1">When the tag is a Bool, a case can test it against a condition. Thus, by a clever perversion, you can use the cases to test <em class="calibre11">any</em> conditions you like &mdash; by using <code class="calibre19">true</code> as the tag! A switch statement thus becomes a genuine substitute for an extended <code class="calibre19">if...else if</code> construct. In this example from my own code, I could have used <code class="calibre19">if...else if</code>, but a switch statement seems cleaner:</p>

<pre data-type="programlisting" class="calibre28">func position(for bar: UIBarPositioning) -&gt; UIBarPosition {
    switch true {
    case bar === self.navbar:  return .topAttached
    case bar === self.toolbar: return .bottom
    default:                   return .any
    }
}</pre>

<p class="author1">A pattern can include a where clause adding a condition to limit the truth value of the case. This is often, though not necessarily, used in combination with a binding; the condition can refer to the variable declared in the binding:<a data-type="indexterm" data-primary="where" id="calibre_link-2366" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch i {
case let j where j &lt; 0:
    print("i is negative, namely \(j)")
case let j where j &gt; 0:
    print("i is positive, namely \(j)")
case 0:
    print("i is 0")
default:break
}</pre>

<p class="author1">In that example, where the binding isnâ€™t really needed, a neater approach might be to use partial range syntax:<a data-type="indexterm" data-primary="ranges" data-secondary="partial" id="calibre_link-1849" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="partial range" id="calibre_link-1690" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch i {
case ..&lt;0:
    print("i is negative, namely \(i)")
case 1...:
    print("i is positive, namely \(i)")
case 0:
    print("i is 0")
default:break
}</pre>

<p class="author1">A pattern can include the <code class="calibre19">is</code> operator to test the tagâ€™s type. In this example, we have a Dog class and its NoisyDog subclass, and <code class="calibre19">d</code> is typed as Dog:</p>

<pre data-type="programlisting" class="calibre28">switch d {
case is NoisyDog:
    print("You have a noisy dog!")
case _:
    print("You have a dog")
}</pre>

<p class="author1">A pattern can include a cast with the <code class="calibre19">as</code> (not <code class="calibre19">as?</code>) operator. Typically, youâ€™ll combine this with a binding that declares a local variable; despite the use of unconditional <code class="calibre19">as</code>, the value is conditionally cast and, if the cast succeeds, the local variable carries the cast value into the case code. Again, <code class="calibre19">d</code> is typed as Dog, which has a NoisyDog subclass; assume that Dog implements <code class="calibre19">bark</code> and that NoisyDog implements <code class="calibre19">beQuiet</code>:<a data-type="indexterm" data-primary="casting" data-secondary="safely" id="calibre_link-346" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="as" id="calibre_link-212" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch d {
case let nd as NoisyDog:
    nd.beQuiet()
case let d:
    d.bark()
}</pre>

<p class="author1">You can also use <code class="calibre19">as</code> (not <code class="calibre19">as?</code>) to cast down the tag (and possibly unwrap it) conditionally as part of a test against a specific match. In this example, <code class="calibre19">i</code> might be an Any or an Optional wrapping an Any:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case 0 as Int:
    print("It is 0")
default:break
}</pre>

<p class="author1">You can perform multiple tests at once by expressing the tag as a tuple and wrapping the corresponding tests in a tuple. The case passes only if every test in the case tuple succeeds against the corresponding member of the tag tuple. In this example, we start with a dictionary <code class="calibre19">d</code> typed as <code class="calibre19">[String:Any]</code>. Using a tuple, we can safely attempt to fetch and cast two values at once:</p>

<pre data-type="programlisting" class="calibre28">switch (d["size"], d["desc"]) {
case let (size as Int, desc as String):
    print("You have size \(size) and it is \(desc)")
default:break
}</pre>

<p class="author1">When a tag is an enum, the cases can be cases of the enum. A switch statement is thus an excellent way to handle an enum. Hereâ€™s the Filter enum from <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>:</p>

<pre data-type="programlisting" class="calibre28">enum Filter {
    case albums
    case playlists
    case podcasts
    case books
}</pre>

<p class="author1">And hereâ€™s a switch statement, where the tag, <code class="calibre19">type</code>, is a Filter; no mop-up is needed, because Iâ€™ve exhausted the cases:</p>

<pre data-type="programlisting" class="calibre28">switch type {
case .albums:
    print("Albums")
case .playlists:
    print("Playlists")
case .podcasts:
    print("Podcasts")
case .books:
    print("Books")
}</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">New in Swift 5, if an enum comes from Objective-C (or C) or the Swift standard library, an exhaustive switch over it might get you a warning from the compiler that the enum â€œmay have additional unknown values.â€ Iâ€™ll explain what that means, and what to do about it, in <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>.</p>
</div>

<p class="author1">A switch statement provides a way to extract an associated value from an enum case. Recall this enum from <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>:<a data-type="indexterm" data-primary="associated value" id="calibre_link-225" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="associated value" id="calibre_link-749" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum MyError {
    case number(Int)
    case message(String)
    case fatal
}</pre>

<p class="author1">If a case of the enum has an associated value, a tuple of patterns after the matched case name is applied to the associated value. If a pattern is a binding variable, it captures the associated value. The <code class="calibre19">let</code> (or <code class="calibre19">var</code>) can appear inside the parentheses or after the <code class="calibre19">case</code> keyword; this code illustrates both alternatives:</p>

<pre data-type="programlisting" class="calibre28">switch err {
case .number(let theNumber):
    print("It is a number: \(theNumber)")
case let .message(theMessage):
    print("It is a message: \(theMessage)")
case .fatal:
    print("It is fatal")
}</pre>

<p class="author1">If the <code class="calibre19">let</code> (or <code class="calibre19">var</code>) appears after the <code class="calibre19">case</code> keyword, I can add a where clause:</p>

<pre data-type="programlisting" class="calibre28">switch err {
case let .number(n) where n &gt; 0:
    print("It's a positive error number \(n)")
case let .number(n) where n &lt; 0:
    print("It's a negative error number \(n)")
case .number(0):
    print("It's a zero error number")
default:break
}</pre>

<p class="author1">If I donâ€™t want to extract the error number but just want to match against it, I can use some other pattern inside the parentheses:</p>

<pre data-type="programlisting" class="calibre28">switch err {
case .number(1...):
    print("It's a positive error number")
case .number(..&lt;0):
    print("It's a negative error number")
case .number(0):
    print("It's a zero error number")
default:break
}</pre>

<p class="author1">This same pattern also gives us yet another way to deal with an Optional tag. An Optional, as I explained in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, is in fact an enum. It has two cases, <code class="calibre19">.none</code> and <code class="calibre19">.some</code>, where the wrapped value is the <code class="calibre19">.some</code> caseâ€™s associated value. But now we know how to extract the associated value! Thus we can rewrite yet again the earlier example where <code class="calibre19">i</code> is an Optional wrapping an Int:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case .none: break
case .some(1):
    print("You have 1 thingy!")
case .some(let n):
    print("You have \(n) thingies!")
}</pre>

<p class="author1">To combine switch case tests (with an implicit logical-or), separate them with a comma:<a data-type="indexterm" data-primary="comma" data-secondary="switch case" id="calibre_link-481" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch i {
case 1,3,5,7,9:
    print("You have a small odd number of thingies")
case 2,4,6,8,10:
    print("You have a small even number of thingies")
default:
    print("You have too many thingies for me to count")
}</pre>

<p class="author1">In this example, <code class="calibre19">i</code> is declared as an Any:</p>

<pre data-type="programlisting" class="calibre28">switch i {
case is Int, is Double:
    print("It's some kind of number")
default:
    print("I don't know what it is")
}</pre>

<p class="author1">A comma can even combine patterns that declare binding variables, provided they declare the same variable of the same type (<code class="calibre19">err</code> is our MyError once again):</p>

<pre data-type="programlisting" class="calibre28">switch err {
case let .number(n) where n &gt; 0, let .number(n) where n &lt; 0:
    print("It's a nonzero error number \(n)")
case .number(0):
    print("It's a zero error number")
default:break
}</pre>

<p class="author1">Another way of combining cases is to jump from one case to the next by using a <code class="calibre19">fallthrough</code> statement. When a <code class="calibre19">fallthrough</code> statement is encountered, the current case code is aborted immediately and the next case code runs <em class="calibre11">unconditionally</em>. The test of the next case is not performed, so the next case canâ€™t declare any binding variables, because they would never be set.
It is not uncommon for a case to consist entirely of a <code class="calibre19">fallthrough</code> statement:<a data-type="indexterm" data-primary="fallthrough" id="calibre_link-846" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">switch pep {
case "Manny": fallthrough
case "Moe": fallthrough
case "Jack":
    print("\(pep) is a Pep boy")
default:
    print("I don't know who \(pep) is")
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="If case" class="calibre2"><div class="preface" id="calibre_link-2963">
<h3 class="calibre44">If case</h3>

<p class="author1">When all you want to do is extract an associated value from one enum case, a full switch statement may seem a bit heavy-handed. The lightweight <code class="calibre19">if case</code> construct lets you use in a condition the same sort of pattern syntax youâ€™d use in a case of a switch statement. The structural difference is that, whereas a switch case pattern is compared against a previously stated tag, an <code class="calibre19">if case</code> pattern is followed by an equal sign and then the tag. In this code, <code class="calibre19">err</code> is our MyError enum once again:<a data-type="indexterm" data-primary="if case" id="calibre_link-1039" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">if case let .number(n) = err {
    print("The error number is \(n)")
}</pre>

<p class="author1">The condition starting with <code class="calibre19">case</code> can be part of a longer comma-separated condition list:</p>

<pre data-type="programlisting" class="calibre28">if case let .number(n) = err, n &lt; 0 {
    print("The negative error number is \(n)")
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Conditional evaluation" class="calibre2"><div class="preface" id="calibre_link-2964">
<h3 class="calibre44">Conditional evaluation</h3>

<p class="author1">An interesting problem arises when youâ€™d like to decide on the fly what value to use &mdash; for example, what value to assign to a variable. This seems like a good use of a branching construct. You can, of course, declare the variable first without initializing it, and then set it from within a subsequent branching construct. It would be nice, however, to use a branching construct <em class="calibre11">as</em> the variableâ€™s value. Here, for example, I try (and fail) to write a variable assignment where the equal sign is followed directly by a branching construct:<a data-type="indexterm" data-primary="conditional evaluation" id="calibre_link-516" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="evaluation, conditional" id="calibre_link-809" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let title = switch type { // compile error
case .albums:
    "Albums"
case .playlists:
    "Playlists"
case .podcasts:
    "Podcasts"
case .books:
    "Books"
}</pre>

<p class="author1">There are languages that let you talk that way, but Swift is not one of them. However, an easy workaround does exist &mdash; use a define-and-call anonymous function, as I suggested in <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>:</p>

<pre data-type="programlisting" class="calibre28">let title : String = {
    switch type {
    case .albums:
        return "Albums"
    case .playlists:
        return "Playlists"
    case .podcasts:
        return "Podcasts"
    case .books:
        return "Books"
    }
}()</pre>

<p class="author1">In the special case where a value can be decided by a two-pronged condition, Swift provides the C ternary operator (<code class="calibre19">?:</code>). Its scheme is as follows:<a data-type="indexterm" data-primary="ternary operator" id="calibre_link-2200" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="ternary" id="calibre_link-1579" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="colon" data-secondary="ternary operator" id="calibre_link-467" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="question mark" id="calibre_link-1832" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28"><em class="calibre43">condition</em> ? <em class="calibre43">exp1</em> : <em class="calibre43">exp2</em></pre>

<p class="author1">If the condition is <code class="calibre19">true</code>, the expression <em class="calibre11"><code class="calibre22">exp1</code></em> is evaluated and the result is used; otherwise, the expression <em class="calibre11"><code class="calibre22">exp2</code></em> is evaluated and the result is used. Thus, you can use the ternary operator while performing an assignment, using this schema:<a data-type="indexterm" data-primary="assignment" data-secondary="conditional" id="calibre_link-219" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conditional assignment" id="calibre_link-510" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let myVariable = <em class="calibre43">condition</em> ? <em class="calibre43">exp1</em> : <em class="calibre43">exp2</em></pre>

<p class="author1">What <code class="calibre19">myVariable</code> gets initialized to depends on the truth value of the condition. I use the ternary operator heavily in my own code. Hereâ€™s an example:</p>

<pre data-type="programlisting" class="calibre28">cell.accessoryType =
    ix.row == self.currow ? .checkmark : .disclosureIndicator</pre>

<p class="author1">The context neednâ€™t be an assignment; here, weâ€™re deciding what value to pass as a function argument:</p>

<pre data-type="programlisting" class="calibre28">context.setFillColor(self.hilite ? purple.cgColor : beige.cgColor)</pre>

<p class="author1">The ternary operator can also be used to determine the receiver of a message. In this example, one of two UIViews will have its background color set:</p>

<pre data-type="programlisting" class="calibre28">(self.firstRed ? v1 : v2).backgroundColor = .red</pre>

<p class="author1">In Objective-C, thereâ€™s a collapsed form of the ternary operator that allows you to test a value against <code class="calibre19">nil</code>. If it is <code class="calibre19">nil</code>, you get to supply a substitute value. If it <em class="calibre11">isnâ€™t</em> <code class="calibre19">nil</code>, the tested value itself is used. In Swift, the analogous operation would involve testing an Optional: if the tested Optional is <code class="calibre19">nil</code>, use the substitute value; if it <em class="calibre11">isnâ€™t</em> <code class="calibre19">nil</code>, <em class="calibre11">unwrap</em> the Optional and use the unwrapped value. Swift has such an operator &mdash; the <code class="calibre19">??</code> operator (called the <em class="calibre11">nil-coalescing</em> operator).<a data-type="indexterm" data-primary="operators" data-secondary="nil-coalescing" id="calibre_link-1575" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nil-coalescing operator" id="calibre_link-1411" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1627" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s a real-life example from my own code:</p>

<pre data-type="programlisting" class="calibre28">func tableView(_ tv: UITableView, numberOfRowsInSection sec: Int) -&gt; Int {
    return self.titles?.count ?? 0
}</pre>

<p class="author1">In that example, <code class="calibre19">self.titles</code> is of type <code class="calibre19">[String]?</code>. If itâ€™s not <code class="calibre19">nil</code>, I want to unwrap the array and return its <code class="calibre19">count</code>. But if it <em class="calibre11">is</em> <code class="calibre19">nil</code>, there is no data and thus no table to display &mdash; but I <em class="calibre11">must</em> return <em class="calibre11">some</em> number, so clearly I want to return zero. The nil-coalescing operator lets me express all that very neatly.</p>

<p class="author1">The nil-coalescing operator together with the Optional <code class="calibre19">map(_:)</code> method neatly solves a class of problem where your goal is to <em class="calibre11">process</em> the wrapped value of an Optional or, if it is <code class="calibre19">nil</code>, to assign some default value. For example, suppose our goal is to produce a string expressing the index of <code class="calibre19">target</code> within <code class="calibre19">arr</code> if it is present, or <code class="calibre19">"NOT FOUND"</code> if it is not. This works, but itâ€™s ugly:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["Manny", "Moe", "Jack"]
let target = // some string
let pos = arr.firstIndex(of:target)
let s = pos != nil ? String(pos!) : "NOT FOUND"</pre>

<p class="author1">Hereâ€™s a more elegant way:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["Manny", "Moe", "Jack"]
let target = // some string
let s = arr.firstIndex(of:target).map{String($0)} ?? "NOT FOUND"</pre>

<p class="author1">Expressions using <code class="calibre19">??</code> can be chained:</p>

<pre data-type="programlisting" class="calibre28">let someNumber = i1 as? Int ?? i2 as? Int ?? 0</pre>

<p class="author1">That code tries to cast <code class="calibre19">i1</code> to an Int and use that Int. If that fails, it tries to cast <code class="calibre19">i2</code> to an Int and use <em class="calibre11">that</em> Int. If <em class="calibre11">that</em> fails, it gives up and uses <code class="calibre19">0</code>.<a data-type="indexterm" data-startref="idxbranching" id="calibre_link-271" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Loops" class="calibre2"><div class="preface" id="calibre_link-2522">
<h2 class="calibre42">Loops</h2>

<p class="author1">The usual purpose of a loop is to repeat a block of code with some simple difference on each iteration. This difference will typically serve also as a signal for when to stop the loop. Swift provides two basic loop structures: while loops and for loops.<a data-type="indexterm" data-primary="looping" id="calibre_link-1252" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="While loops" class="calibre2"><div class="preface" id="calibre_link-2965">
<h3 class="calibre44">While loops</h3>

<p class="author1">A while loop comes in two forms, schematized in <a data-type="xref" href="#calibre_link-2845" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;5-3</a>.<a data-type="indexterm" data-primary="while" id="calibre_link-2368" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-2845" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 5-3. </span>The Swift while loop</h5>

<pre data-type="programlisting" class="calibre31">while <em class="calibre43">condition</em> {
    <em class="calibre43">statements</em>
}

repeat {
    <em class="calibre43">statements</em>
} while <em class="calibre43">condition</em></pre>
</div>

<p class="author1">The chief difference between the two forms is the timing of the test. In the second form, the condition is tested after the block has executed &mdash; meaning that the block will be executed at least once.</p>

<p class="author1">Usually, the code inside the block will change something that alters the environment and hence the value of the condition, thus eventually bringing the loop to an end. Hereâ€™s a typical example from my own code (<code class="calibre19">movenda</code> is an array):</p>

<pre data-type="programlisting" class="calibre28">while self.movenda.count &gt; 0 {
    let p = self.movenda.removeLast()
    // ...
}</pre>

<p class="author1">Each iteration removes an element from <code class="calibre19">movenda</code>, so eventually its <code class="calibre19">count</code>, evaluated in the condition, falls to <code class="calibre19">0</code> and the loop is no longer executed; execution then proceeds to the next line after the closing curly braces.</p>

<p class="author1">In its first form, a while loopâ€™s condition can involve a conditional binding of an Optional. This provides a compact way of safely unwrapping an Optional and looping until the Optional is <code class="calibre19">nil</code>; the local variable containing the unwrapped Optional is in scope inside the curly braces. Thus, my code can be rewritten more compactly:<a data-type="indexterm" data-primary="binding, conditional" id="calibre_link-253" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conditional binding" id="calibre_link-512" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="while let" id="calibre_link-2370" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1628" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">while let p = self.movenda.popLast() {
    // ...
}</pre>

<p class="author1">Hereâ€™s an example of <code class="calibre19">repeat...while</code> from my own code. In my LinkSame app, if there are no legal moves, we pick up all the cards, shuffle them, and redeal them into the same positions. Itâ€™s possible that when we do that, there will <em class="calibre11">still</em> be no legal moves. So we do it again until there <em class="calibre11">is</em> a legal move:</p>

<pre data-type="programlisting" class="calibre28">repeat {
    var deck = self.gatherUpCards()
    deck.shuffle()
    self.redeal(deck)
} while self.legalPath() == nil</pre>

<p class="author1">Similar to the <code class="calibre19">if case</code> construct, <code class="calibre19">while case</code> lets you use a switch case pattern.<a data-type="indexterm" data-primary="while case" id="calibre_link-2369" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> In this rather artificial example, we have an array of various MyError enums:</p>

<pre data-type="programlisting" class="calibre28">let arr : [MyError] = [
    .message("ouch"), .message("yipes"), .number(10), .number(-1), .fatal
]</pre>

<p class="author1">We can extract the <code class="calibre19">.message</code> associated string values from the start of the array, like this:<a data-type="indexterm" data-primary="associated value" id="calibre_link-226" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="associated value" id="calibre_link-750" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var i = 0
while case let .message(message) = arr[i]  {
    print(message) // "ouch", then "yipes"; then the loop stops
    i += 1
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="For loops" class="calibre2"><div class="preface" id="calibre_link-2966">
<h3 class="calibre44">For loops</h3>

<p class="author1">The Swift for loop is schematized in <a data-type="xref" href="#calibre_link-2846" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;5-4</a>.<a data-type="indexterm" data-primary="for" id="calibre_link-881" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-2846" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 5-4. </span>The Swift for loop</h5>

<pre data-type="programlisting" class="calibre31">for <em class="calibre43">variable</em> in <em class="calibre43">sequence</em> {
    <em class="calibre43">statements</em>
}</pre>
</div>

<p class="author1">The sequence must be an instance of a type that adopts the Sequence protocol.
An Array is a Sequence. A Dictionary is a Sequence. A Set is a Sequence. A String is a Sequence. A Range is a Sequence (as long as it is a range of something that comes in discrete steps, like Int). Those, and sequences derived from them, are the things to which you will regularly apply <code class="calibre19">for...in</code>.<a data-type="indexterm" data-primary="for...in" id="calibre_link-883" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Sequence" id="calibre_link-2001" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sequence" data-secondary="cycling through" id="calibre_link-1993" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">On each iteration, a successive element of the sequence is used to initialize the variable. The variable is local to the block; it is in scope inside the curly braces, and is not visible outside them. The variable is implicitly declared with <code class="calibre19">let</code>; it is thus immutable by default. If you need to assign to or mutate the variable within the block, write <code class="calibre19">for var</code>.</p>

<p class="author1">A common use of for loops is to iterate through successive numbers. This is easy in Swift, because you can readily create a sequence of numbers on the fly &mdash; a Range:<a data-type="indexterm" data-primary="sequence" data-secondary="generating" id="calibre_link-1997" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">for i in 1...5 {
    print(i) // 1, 2, 3, 4, 5
}</pre>

<p class="author1">Under the hood, a Sequence has a <code class="calibre19">makeIterator</code> method which yields an iterator object adopting IteratorProtocol. According to this protocol, the iterator has a mutating <code class="calibre19">next</code> method that returns the next object in the sequence wrapped in an Optional, or <code class="calibre19">nil</code> if there is no next object. Thus, <code class="calibre19">for...in</code> is actually a kind of while loop:</p>

<pre data-type="programlisting" class="calibre28">var iterator = (1...5).makeIterator()
while let i = iterator.next() {
    print(i) // 1, 2, 3, 4, 5
}</pre>

<p class="author1">Sometimes you may find that writing out the while loop explicitly in that way makes the loop easier to control and to customize.</p>

<p class="author1">When you cycle through a sequence with <code class="calibre19">for...in</code>, what youâ€™re actually cycling through is a <em class="calibre11">copy</em> of the sequence. That means itâ€™s safe to mutate the sequence while youâ€™re cycling through it:<a data-type="indexterm" data-primary="sequence" data-secondary="cycling makes a copy" id="calibre_link-1992" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var s : Set = [1,2,3,4,5]
for i in s {
    if i % 2 == 0 {
        s.remove(i)
    }
} // s is now [1,3,5]</pre>

<p class="author1">That may not be the most elegant way to remove all even numbers from the Set <code class="calibre19">s</code>, but itâ€™s not illegal or dangerous.</p>

<p class="author1">Not only is the <em class="calibre11">sequence</em> a copy; if the variable type is a value type (<a data-type="xref" href="#calibre_link-65" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œValue Types and Reference Typesâ€</a>), the <em class="calibre11">variable</em> is a copy. So even if you mutate the variable (which is legal if you say <code class="calibre19">for var</code>), the original sequenceâ€™s elements are unaffected. Hereâ€™s a Dog thatâ€™s a struct, not a class:</p>

<pre data-type="programlisting" class="calibre28">struct Dog {
    var name : String
    init(_ n:String) {
        self.name = n
    }
}</pre>

<p class="author1">We cycle through an array of Dogs, uppercasing their names:</p>

<pre data-type="programlisting" class="calibre28">var dogs : [Dog] = [Dog("rover"), Dog("fido")]
for var dog in dogs {
    dog.name = dog.name.uppercased()
}</pre>

<p class="author1">But nothing useful happens; <code class="calibre19">dogs</code> still consists of Dogs named <code class="calibre19">"rover"</code> and <code class="calibre19">"fido"</code>. If the Sequence is also a Collection, one workaround is to cycle through its <code class="calibre19">indices</code> instead:<a data-type="indexterm" data-primary="indices" id="calibre_link-1057" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var dogs : [Dog] = [Dog("rover"), Dog("fido")]
for ix in dogs.indices {
    dogs[ix].name = dogs[ix].name.uppercased()
}</pre>

<p class="author1">Now <code class="calibre19">dogs</code> consists of Dogs named <code class="calibre19">"ROVER"</code> and <code class="calibre19">"FIDO"</code>.</p>

<p class="author1">As I explained in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, you may encounter an array coming from Objective-C whose elements will need to be cast down from Any. If your goal is to iterate through that array, you can cast down as part of the sequence specification:</p>

<pre data-type="programlisting" class="calibre28">let p = Pep() // p.boys() is an array of Any
for boy in p.boys() as! [String] {
    // ...
}</pre>

<p class="author1">The sequence <code class="calibre19">enumerated</code> method yields a succession of tuples in which each element of the original sequence (labeled <code class="calibre19">element</code>) is preceded by its index number (labeled <code class="calibre19">offset</code>). In this example from my real code, <code class="calibre19">tiles</code> is an array of UIViews and <code class="calibre19">centers</code> is an array of CGPoints saying where those views are to be positioned:<a data-type="indexterm" data-primary="enumerated" id="calibre_link-745" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sequence" data-secondary="enumerating with index" id="calibre_link-1995" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="index, enumerate with" id="calibre_link-1051" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">for (i,v) in self.tiles.enumerated() {
    v.center = self.centers[i]
}</pre>

<p class="author1">A <code class="calibre19">for...in</code> construct can take a where clause, allowing you to skip some values of the sequence:<a data-type="indexterm" data-primary="where" id="calibre_link-2367" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">for i in 0...10 where i % 2 == 0 {
    print(i) // 0, 2, 4, 6, 8, 10
}</pre>

<p class="author1">Like <code class="calibre19">if case</code> and <code class="calibre19">while case</code>, thereâ€™s also <code class="calibre19">for case</code>, permitting a switch case pattern to be used a for loop. The tag is each successive value of the sequence, so no assignment operator is used. To illustrate, letâ€™s start again with an array of MyError enums:<a data-type="indexterm" data-primary="for case" id="calibre_link-882" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="associated value" id="calibre_link-227" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="associated value" id="calibre_link-751" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr : [MyError] = [
    .message("ouch"), .message("yipes"), .number(10), .number(-1), .fatal
]</pre>

<p class="author1">Here we cycle through the whole array, extracting only the <code class="calibre19">.number</code> associated values:</p>

<pre data-type="programlisting" class="calibre28">for case let .number(i) in arr {
    print(i) // 10, -1
}</pre>

<p class="author1">Another common use of <code class="calibre19">for case</code> is to cast down conditionally, picking out only those members of the sequence that can be cast down safely. For example, letâ€™s say I want to hide all subviews that happen to be buttons:</p>

<pre data-type="programlisting" class="calibre28">for case let b as UIButton in self.boardView.subviews {
    b.isHidden = true
}</pre>

<p class="author1">A sequence also has instance methods, such as <code class="calibre19">map(_:)</code>, <code class="calibre19">filter(_:)</code>, and <code class="calibre19">reversed</code>; you can apply these to hone the sequence through which we will cycle. In this example, I count backward by even numbers:<a data-type="indexterm" data-primary="sequence" data-secondary="transforming" id="calibre_link-2000" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let range = (0...10).reversed().filter{$0 % 2 == 0}
for i in range {
    print(i) // 10, 8, 6, 4, 2, 0
}</pre>

<p class="author1">Yet another approach is to generate the sequence by calling global functions such as <code class="calibre19">stride(from:through:by)</code> or <code class="calibre19">stride(from:to:by:)</code>. These are applicable to adopters of the Strideable protocol, such as numeric types and anything else that can be incremented and decremented. Which form you use depends on whether you want the sequence to include the final value. The <code class="calibre19">by:</code> argument can be negative:<a data-type="indexterm" data-primary="stride" id="calibre_link-2084" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">for i in stride(from: 10, through: 0, by: -2) {
    print(i) // 10, 8, 6, 4, 2, 0
}</pre>

<p class="author1">For maximum flexibility, you can use the global <code class="calibre19">sequence</code> function to generate your sequence by rule. It takes two parameters &mdash; an initial value, and a generation function that returns the next value based on what has gone before. In theory, the sequence generated by the <code class="calibre19">sequence</code> function can be infinite in length &mdash; though this is not a problem, because the resulting sequence is â€œlazy,â€ meaning that an element isnâ€™t generated until you ask for it. In reality, youâ€™ll use one of two techniques to limit the result:<a data-type="indexterm" data-primary="sequence" data-secondary="function" id="calibre_link-1996" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Return <code class="calibre19">nil</code></dt>
<dd class="calibre16">
<p class="calibre17">The generation function can limit the sequence by returning <code class="calibre19">nil</code> to signal that the end has been reached:</p>

<pre data-type="programlisting" class="calibre28">let seq = sequence(first:1) {$0 &gt;= 10 ? nil : $0 + 1}
for i in seq {
    print(i) // 1,2,3,4,5,6,7,8,9,10
}</pre>
</dd>
<dt class="calibre15">Slice the sequence</dt>
<dd class="calibre16">
<p class="calibre17">You can request just a piece of the infinite sequence &mdash; for example, by cycling through the sequence for a while and then stopping, or by taking a finite <code class="calibre19">prefix</code>:</p>

<pre data-type="programlisting" class="calibre28">let seq = sequence(first:1) {$0 + 1}
for i in seq.prefix(5) {
    print(i) // 1,2,3,4,5
}</pre>
</dd>
</dl>

<p class="author1">The <code class="calibre19">sequence</code> function comes in two forms:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">sequence(first:next:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Initially hands <code class="calibre19">first</code> into the <code class="calibre19">next:</code> function and subsequently hands the previous result of the <code class="calibre19">next:</code> function into the <code class="calibre19">next:</code> function, as illustrated in the preceding examples</p>
</dd>
<dt class="calibre15"><code class="calibre19">sequence(state:next:)</code></dt>
<dd class="calibre16">
<p class="calibre17">This form is more general: it repeatedly hands <code class="calibre19">state</code> into the <code class="calibre19">next:</code> function as an <code class="calibre19">inout</code> parameter; the <code class="calibre19">next:</code> function is expected to set that parameter, using it as a scratchpad, in addition to returning the next value in the sequence.</p>
</dd>
</dl>

<p class="author1">An obvious illustration of the second form is the Fibonacci series:</p>

<pre data-type="programlisting" class="calibre28">let fib = sequence(state:(0,1)) { (pair: inout (Int,Int)) -&gt; Int in
    let n = pair.0 + pair.1
    pair = (pair.1,n)
    return n
}
for i in fib.prefix(10) {
    print(i) // 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
}</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1"><em class="calibre11">Any</em> sequence can be made â€œlazyâ€ by asking for its <code class="calibre19">lazy</code> property. This can be a source of efficiency if youâ€™re going to be looping through the sequence (explicitly or implicitly) and potentially shortcircuiting the loop; thereâ€™s no point generating more elements of the sequence than the loop will actually process, and that is what <code class="calibre19">lazy</code> prevents. Importantly, laziness propagates through a chain of sequence operations. Iâ€™ll give an example in the next section.<a data-type="indexterm" data-primary="lazy sequence" id="calibre_link-1213" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sequence" data-secondary="lazy" id="calibre_link-1998" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Jumping" class="calibre2"><div class="preface" id="calibre_link-2523">
<h2 class="calibre42">Jumping</h2>

<p class="author1">Although branching and looping constitute the bulk of the decision-making flow of code execution, sometimes they are insufficient to express the logic of what needs to happen next. It can be useful to interrupt your codeâ€™s progress completely and <em class="calibre11">jump</em> to a different place within it. In this section, Iâ€™ll list Swiftâ€™s modes of jumping. These are all controlled forms of <em class="calibre11">early exit</em> from the current flow of code.<a data-type="indexterm" data-primary="early exit" id="calibre_link-722" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="exit, early" id="calibre_link-820" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="scope" data-secondary="exiting early" id="calibre_link-1955" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="jumping" id="calibre_link-1180" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Return" class="calibre2"><div class="preface" id="calibre_link-2967">
<h3 class="calibre44">Return</h3>

<p class="author1">You already know one form of early exit: the return statement. One function calls another, which may call another, and so on, forming a call stack. When a return statement is encountered, execution of this function is aborted and the path of execution jumps to the point where the call was made in the function one level up the call stack.<a data-type="indexterm" data-primary="call stack" id="calibre_link-327" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="stack, call" id="calibre_link-2058" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Shortcircuiting and labels" class="calibre2"><div class="preface" id="calibre_link-2968">
<h3 class="calibre44">Shortcircuiting and labels</h3>

<p class="author1">Swift has several ways of shortcircuiting the flow of branch and loop constructs:<a data-type="indexterm" data-primary="shortcircuiting" id="calibre_link-2024" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="branching" data-secondary="shortcircuiting" id="calibre_link-272" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="looping" data-secondary="shortcircuiting" id="calibre_link-1253" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">fallthrough</code></dt>
<dd class="calibre16">
<p class="calibre17">A <code class="calibre19">fallthrough</code> statement in a switch case aborts execution of the current case code and immediately begins executing the code of the next case. There must <em class="calibre11">be</em> a next case or the compiler will stop you.<a data-type="indexterm" data-primary="fallthrough" id="calibre_link-847" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15"><code class="calibre19">continue</code></dt>
<dd class="calibre16">
<p class="calibre17">A <code class="calibre19">continue</code> statement in a loop construct aborts execution of the current iteration and proceeds to the next iteration:<a data-type="indexterm" data-primary="continue" id="calibre_link-548" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">In a while loop, <code class="calibre19">continue</code> means to perform immediately the conditional test.</p>
</li>
<li class="calibre12">
<p class="calibre17">In a for loop, <code class="calibre19">continue</code> means to proceed immediately to the next iteration if there is one.</p>
</li>
</ul>
</dd>
<dt class="calibre15"><code class="calibre19">break</code></dt>
<dd class="calibre16">
<p class="calibre17">A <code class="calibre19">break</code> statement aborts the current construct and proceeds after the end of the construct:<a data-type="indexterm" data-primary="break" id="calibre_link-273" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">In a loop, <code class="calibre19">break</code> aborts the loop.</p>
</li>
<li class="calibre12">
<p class="calibre17">In a switch case, <code class="calibre19">break</code> aborts the entire switch construct.</p>
</li>
</ul>
</dd>
</dl>

<p class="author1">When constructs are nested, you may need to specify <em class="calibre11">which</em> construct you mean when you say <code class="calibre19">continue</code> or <code class="calibre19">break</code>. Therefore, Swift permits you to put a <em class="calibre11">label</em> before the start of an if construct, a switch statement, a while loop, or a for loop (or a do block, which Iâ€™ll describe later). The label is an arbitrary name followed by a colon. You can then use that label name in a continue statement or a break statement within the labeled construct at any depth, to specify that this is the construct you are referring to.<a data-type="indexterm" data-primary="labels" data-secondary="flow control" id="calibre_link-1196" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="colon" data-secondary="label" id="calibre_link-464" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s a simple struct for generating prime numbers:</p>

<pre data-type="programlisting" class="calibre28">struct Primes {
    static var primes = [2]
    static func appendNextPrime() {
        next: for i in (primes.last!+1)... {
            let sqrt = Int(Double(i).squareRoot())
            for prime in primes.lazy.prefix(while:{$0 &lt;= sqrt}) {
                if i % prime == 0 {
                    continue next
                }
            }
            primes.append(i)
            return
        }
    }
}</pre>

<p class="author1">The algorithm is crude &mdash; it could be optimized further &mdash; but itâ€™s effective and straightforward. The struct maintains a list of the primes weâ€™ve found so far, and <code class="calibre19">appendNextPrime</code> basically just looks at each successive larger integer <code class="calibre19">i</code> to see whether any of the primes weâ€™ve already found (<code class="calibre19">prime</code>) divides it. If so, <code class="calibre19">i</code> is not a prime, so we want to go on to the next <code class="calibre19">i</code>. But if we merely say <code class="calibre19">continue</code>, weâ€™ll jump to the next <code class="calibre19">prime</code>, not to the next <code class="calibre19">i</code>. The label solves the problem.</p>

<p class="author1">(That example also demonstrates <code class="calibre19">lazy</code>. We want to keep <code class="calibre19">prefix(while:_)</code> from working harder than it has to; thereâ€™s no point extracting <em class="calibre11">all</em> the <code class="calibre19">primes</code> less than the square root of <code class="calibre19">i</code> in advance, because the loop might be shortcircuited. So we make <code class="calibre19">primes</code> lazy, which makes <code class="calibre19">prefix(while:_)</code> lazy, and so a <code class="calibre19">prime</code> is tested against <code class="calibre19">$0 &lt;= sqrt</code> only if it has to be.)</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Throwing and catching errors" class="calibre2"><div class="preface" id="calibre_link-2969">
<h3 class="calibre44">Throwing and catching errors</h3>

<p class="author1">Sometimes a situation arises where further coherent progress is impossible: the entire operation in which we are engaged has failed. It can then be desirable to abort the current scope, and possibly the current function, and possibly even the function that called that function, and so on, exiting to some point where we can acknowledge this failure and proceed in good order in some other way.<a data-type="indexterm" data-primary="errors" id="calibre_link-780" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For this purpose, Swift provides a mechanism for <em class="calibre11">throwing and catching errors</em>. In keeping with its usual insistence on safety and clarity, Swift imposes strict conditions on the use of this mechanism, and the compiler will ensure that you adhere to them.</p>

<p class="author1">An <em class="calibre11">error</em>, in this sense, is a kind of message, presumably indicating what went wrong. This message is passed up the nest of scopes and function calls as part of the error-handling process, and the code that recovers from the failure can read it. In Swift, an error must be an object of a type that adopts the Error protocol, which has just two requirements: a String <code class="calibre19">_domain</code> property and an Int <code class="calibre19">_code</code> property. The purpose of those properties is to help errors cross the bridge between Swift and Objective-C; in real life, they are hidden and you will be unaware of them. The Error object will be one of the following:<a data-type="indexterm" data-primary="Error" id="calibre_link-778" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">A Swift type that adopts Error</dt>
<dd class="calibre16">
<p class="calibre17">As soon as a Swift type formally declares adoption of the Error protocol, it is ready to be used as an error object; the protocol requirements are magically fulfilled for you behind the scenes. Typically, this type will be an enum, with different cases distinguishing different kinds of possible failure, perhaps with raw values or associated types to carry further information.</p>
</dd>
<dt class="calibre15">NSError</dt>
<dd class="calibre16">
<p class="calibre17">NSError is Cocoaâ€™s class for communicating the nature of a problem; Swift extends NSError to adopt Error and bridges them to one another. If your call to a Cocoa method generates a failure, Cocoa will send you an NSError instance typed as an Error.<a data-type="indexterm" data-primary="NSError" id="calibre_link-1440" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">There are two stages of the error mechanism to consider:</p>
<dl class="calibre14">
<dt class="calibre15">Throwing an error</dt>
<dd class="calibre16">
<p class="calibre17">Throwing an error aborts the current path of execution and hands an error object to the error mechanism.</p>
</dd>
<dt class="calibre15">Catching an error</dt>
<dd class="calibre16">
<p class="calibre17">Catching an error receives that error object from the error mechanism and responds in good order, with the path of execution resuming after the point of catching. In effect, we have <em class="calibre11">jumped</em> from the throwing point to the catching point.</p>
</dd>
</dl>

<p class="author1">To <em class="calibre11">throw an error</em>, use the keyword <code class="calibre19">throw</code> followed by an error object. Thatâ€™s all it takes! The current block of code is immediately aborted, and the error mechanism takes over. However, to ensure that the <code class="calibre19">throw</code> command is used coherently, Swift imposes a rule that you can say <code class="calibre19">throw</code> <em class="calibre11">only in a context where the error will be caught</em>. What is such a context?<a data-type="indexterm" data-primary="errors" data-secondary="throwing" id="calibre_link-784" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="throw" id="calibre_link-2213" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The primary context for throwing and catching an error is the <code class="calibre19">do...catch</code> construct. This consists of a do block and one or more catch blocks. It is legal to throw in the do block; an accompanying catch block can then be fed any errors thrown from within the do block. The <code class="calibre19">do...catch</code> constructâ€™s schema looks like <a data-type="xref" href="#calibre_link-2847" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;5-5</a>.<a data-type="indexterm" data-primary="errors" data-secondary="catching" id="calibre_link-782" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="do...catch" id="calibre_link-688" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-2847" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 5-5. </span>The Swift <code class="calibre53">do...catch</code> construct</h5>

<pre data-type="programlisting" class="calibre31">do {
    <em class="calibre43">statements</em> // a throw can happen here
} catch <em class="calibre43">errortype</em> {
    <em class="calibre43">statements</em>
} catch {
    <em class="calibre43">statements</em>
}</pre>
</div>

<p class="author1">A single do block can be accompanied by multiple catch blocks. Catch blocks are like the cases of a switch statement, and will usually have the same logic: first, you might have specialized catch blocks, each of which is designed to handle some limited set of possible errors; finally, you might (and usually will) have a general catch block that acts as the default, mopping up any errors that were not caught by any of the specialized catch blocks.</p>

<p class="author1">In fact, the <em class="calibre11">syntax</em> used by a catch block to specify what sorts of error it catches <em class="calibre11">is</em> the pattern syntax used by a case in a switch statement! Imagine that this <em class="calibre11">is</em> a switch statement, and that the tag is the error object. Then the matching of that error object to a particular catch block is performed just as if you had written <code class="calibre19">case</code> instead of <code class="calibre19">catch</code>. Typically, when the Error is an enum, a specialized catch block will state at least the enum that it catches, and possibly also the case of that enum; it can have a binding, to capture the enum or its associated type; and it can have a where clause to limit the possibilities still further.</p>

<p class="author1">To illustrate, Iâ€™ll start by defining a couple of errors:</p>

<pre data-type="programlisting" class="calibre28">enum MyFirstError : Error {
    case firstMinorMistake
    case firstMajorMistake
    case firstFatalMistake
}
enum MySecondError : Error {
    case secondMinorMistake(i:Int)
    case secondMajorMistake(s:String)
    case secondFatalMistake
}</pre>

<p class="author1">And hereâ€™s a <code class="calibre19">do...catch</code> construct designed to demonstrate some of the different ways we can catch different errors in different catch blocks:</p>

<pre data-type="programlisting" class="calibre28">do {
    // throw can happen here
} catch MyFirstError.firstMinorMistake {
    // catches MyFirstError.firstMinorMistake
} catch let err as MyFirstError {
    // catches all other cases of MyFirstError
} catch MySecondError.secondMinorMistake(let i) where i &lt; 0 {
    // catches e.g. MySecondError.secondMinorMistake(i:-3)
} catch {
    // catches everything else
}</pre>

<p class="author1">Now letâ€™s talk about how the error object makes its way into each of the catch blocks:</p>
<dl class="calibre14">
<dt class="calibre15">Catch block with pattern</dt>
<dd class="calibre16">
<p class="calibre17">In a catch block with an accompanying pattern, it is up to you to capture in the pattern any desired information about the error. If you want the error itself to travel as a variable into the catch block, youâ€™ll need a binding in the pattern.</p>
</dd>
<dt class="calibre15">Catch block with â€œmop-upâ€ binding</dt>
<dd class="calibre16">
<p class="calibre17">A catch block whose pattern is <em class="calibre11">only</em> a binding catches <em class="calibre11">any</em> error under that name; for example, <code class="calibre19">catch let mistake</code> is a â€œmop-upâ€ catch block that catches any error as a variable called <code class="calibre19">mistake</code>.</p>
</dd>
<dt class="calibre15">Bare catch block</dt>
<dd class="calibre16">
<p class="calibre17">In a â€œmop-upâ€ catch block with <em class="calibre11">no</em> accompanying pattern (that is, the bare word <code class="calibre19">catch</code> and no more), the error arrives into the block <em class="calibre11">automatically</em> as a variable called <code class="calibre19">error</code>.</p>
</dd>
</dl>

<p class="author1">Letâ€™s look again at the previous example, but this time weâ€™ll note whether and how the error object arrives into each catch block:</p>

<pre data-type="programlisting" class="calibre28">do {
    // throw can happen here
} catch MyFirstError.firstMinorMistake {
    // no error object, but we know it's MyFirstError.firstMinorMistake
} catch let err as MyFirstError {
    // MyFirstError arrives as err
} catch MySecondError.secondMinorMistake(let i) where i &lt; 0 {
    // only i arrives, but we know it's MySecondError.secondMinorMistake
} catch {
    // error object arrives as error
}</pre>

<p class="author1">So much for the <code class="calibre19">do...catch</code> construct. But thereâ€™s something else that can happen to a thrown error; instead of being caught directly, it can percolate up the call stack, leaving the current function and arriving at the point where this function was called. In this situation, the error wonâ€™t be caught here, at the point of throwing; it needs to be caught further up the call stack. This can happen in one of two ways:</p>
<dl class="calibre14">
<dt class="calibre15">Throw without a corresponding catch</dt>
<dd class="calibre16">
<p class="calibre17">A <code class="calibre19">do...catch</code> construct might lack a â€œmop-upâ€ catch block. Then a throw inside the do block might <em class="calibre11">not</em> be caught here.</p>
</dd>
<dt class="calibre15">Throw outside a do block</dt>
<dd class="calibre16">
<p class="calibre17">A <code class="calibre19">throw</code> might occur outside of any immediate <code class="calibre19">do...catch</code> construct.</p>
</dd>
</dl>

<p class="author1">However, a thrown error <em class="calibre11">must</em> be caught <em class="calibre11">somehow</em>.
We therefore need a way to say to the compiler: â€œLook, I understand that it looks like this throw is not happening in a context where it will be caught, but thatâ€™s only because youâ€™re not looking far enough up the call stack. If you do look up far enough, youâ€™ll see that a throw at this point <em class="calibre11">is</em> eventually caught.â€ And there is a way to say that! Use the <code class="calibre19">throws</code> <span class="publishername">keyword</span> in a function declaration.</p>

<p class="author1">If you mark a function with the <code class="calibre19">throws</code> keyword, then its <em class="calibre11">entire body</em> becomes a legal place for throwing. The syntax for declaring a <code class="calibre19">throws</code> function is that the keyword <code class="calibre19">throws</code> appears immediately after the parameter list (and before the arrow operator, if there is one):<a data-type="indexterm" data-primary="throws" id="calibre_link-2214" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="throws" id="calibre_link-935" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum NotLongEnough : Error {
    case iSaidLongIMeantLong
}
func giveMeALongString(_ s:String) throws {
    if s.count &lt; 5 {
        throw NotLongEnough.iSaidLongIMeantLong
    }
    print("thanks for the string")
}</pre>

<p class="author1">The addition of <code class="calibre19">throws</code> to a function declaration creates a distinct function type. The type of <code class="calibre19">giveMeALongString</code> is not <code class="calibre19">(String) -&gt; ()</code>, but rather <code class="calibre19">(String) throws -&gt; ()</code>. If a function receives as parameter a function that can throw, that parameterâ€™s type needs to be specified accordingly:</p>

<pre data-type="programlisting" class="calibre28">func receiveThrower(_ f:(String) throws -&gt; ()) {
    // ...
}</pre>

<p class="author1">That function can now be called with <code class="calibre19">giveMeALongString</code> as argument:</p>

<pre data-type="programlisting" class="calibre28">func callReceiveThrower() {
    receiveThrower(giveMeALongString)
}</pre>

<p class="author1">An anonymous function, if necessary, can include the keyword <code class="calibre19">throws</code> in its <code class="calibre19">in</code> expression, in the same place where it would appear in a normal function declaration. But this is not necessary if, as is usually the case, the anonymous functionâ€™s type is known by inference:<a data-type="indexterm" data-primary="functions" data-secondary="anonymous" data-tertiary="throws" id="calibre_link-903" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="anonymous functions" data-secondary="throws" id="calibre_link-138" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func receiveThrower(_ f:(String) throws -&gt; ()) {
    // ...
}
func callReceiveThrower() {
    receiveThrower {
        s in // can say "s throws in", but not required
        if s.count &lt; 5 {
            throw NotLongEnough.iSaidLongIMeantLong
        }
        print("thanks for the string")
    }
}</pre>

<p class="author1">So now we know that <code class="calibre19">throws</code> functions exist. But thereâ€™s more. Swift imposes some requirements on the <em class="calibre11">caller</em> of a <code class="calibre19">throws</code> function:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The caller of a <code class="calibre19">throws</code> function must precede the function call with the keyword <code class="calibre19">try</code>. This keyword acknowledges, to the programmer and to the compiler, that this function can throw.</p>
</li>
<li class="calibre12">
<p class="calibre17">The function call must be made in a place where throwing is legal! A function called with <code class="calibre19">try</code> can throw, so saying <code class="calibre19">try</code> is just like saying <code class="calibre19">throw</code>: you must say it either in the do block of a <code class="calibre19">do...catch</code> construct or in the body of a <code class="calibre19">throws</code> function.<a data-type="indexterm" data-primary="try" id="calibre_link-2225" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="throws" data-tertiary="calling" id="calibre_link-936" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">Swift also provides two variants of <code class="calibre19">try</code> that you will often use as a shorthand:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">try!</code></dt>
<dd class="calibre16">
<p class="calibre17">If you are very sure that a <code class="calibre19">throws</code> function will in fact <em class="calibre11">not</em> throw, then you can call it with the keyword <code class="calibre19">try!</code> instead of <code class="calibre19">try</code>. This relieves you of all further responsibility: you can say <code class="calibre19">try!</code> <em class="calibre11">anywhere</em>, without catching the possible throw. But be warned: if youâ€™re wrong, and this function <em class="calibre11">does</em> throw when your program runs, your program can crash at that moment, because you have allowed an error to percolate, uncaught, all the way up to the top of the call stack.</p>
</dd>
<dt class="calibre15"><code class="calibre19">try?</code></dt>
<dd class="calibre16">
<p class="calibre17">Like <code class="calibre19">try!</code>, you can use <code class="calibre19">try?</code> anywhere; but, like a <code class="calibre19">do...catch</code> construct, <code class="calibre19">try?</code> catches the throw if there is one, without crashing. If thereâ€™s a throw, you donâ€™t receive any error information, as you would with a <code class="calibre19">do...catch</code> construct; but <code class="calibre19">try?</code> tells you if there <em class="calibre11">was</em> a throw, by returning <code class="calibre19">nil</code>. Thus, <code class="calibre19">try?</code> is useful particularly in situations where youâ€™re calling a <code class="calibre19">throws</code> function that returns a value. If thereâ€™s a throw, <code class="calibre19">try?</code> returns <code class="calibre19">nil</code>. If thereâ€™s no throw, <code class="calibre19">try?</code> wraps the returned value in an Optional. Commonly, youâ€™ll unwrap that Optional safely in the same line with a conditional binding.</p>
</dd>
</dl>

<p class="author1">To illustrate, hereâ€™s an artificial test method that can either throw or return a String:</p>

<pre data-type="programlisting" class="calibre28">func canThrowOrReturnString(shouldThrow:Bool) throws -&gt; String {
    enum Whoops : Error {
        case oops
    }
    if shouldThrow {
        throw Whoops.oops
    }
    return "Howdy"
}</pre>

<p class="author1">We can call that method with <code class="calibre19">try</code> inside a <code class="calibre19">do...catch</code> construct:</p>

<pre data-type="programlisting" class="calibre28">do {
    let s = try self.canThrowOrReturnString(shouldThrow: true)
    print(s)
} catch {
    print(error)
}</pre>

<p class="author1">At the other extreme, we can call that method with <code class="calibre19">try!</code> anywhere, but if the method throws, weâ€™ll crash:</p>

<pre data-type="programlisting" class="calibre28">let s = try! self.canThrowOrReturnString(shouldThrow: false)
print(s)</pre>

<p class="author1">In between, we can call our method with <code class="calibre19">try?</code> anywhere. If the method doesnâ€™t throw, weâ€™ll receive a String wrapped in an Optional; if it does throw, we wonâ€™t crash and weâ€™ll receive <code class="calibre19">nil</code> (but no error information):</p>

<pre data-type="programlisting" class="calibre28">if let s = try? self.canThrowOrReturnString(shouldThrow: true) {
    print(s)
} else {
    print("failed")
}</pre>
<aside data-type="sidebar" {http://www.idpf.org/2007/ops}type="sidebar" class="preview-edition"><div class="sidebar" id="calibre_link-2970">
<h5 class="calibre36">Rethrows</h5>
<p class="calibre37">A function that receives a <code class="calibre19">throws</code> function parameter, and that calls that function (with <code class="calibre19">try</code>), and that doesnâ€™t throw for any <em class="calibre11">other</em> reason, may itself be marked as <code class="calibre19">rethrows</code> instead of <code class="calibre19">throws</code>. The difference is that when a <code class="calibre19">rethrows</code> function is called, the caller can pass as argument a function that does <em class="calibre11">not</em> throw, and in that case the call doesnâ€™t have to be marked with <code class="calibre19">try</code> (and the calling function doesnâ€™t have to be marked with <code class="calibre19">throws</code>):<a data-type="indexterm" data-primary="rethrows" id="calibre_link-1929" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="rethrows" id="calibre_link-931" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">func receiveThrower(_ f:(String) throws -&gt; ()) rethrows {
    try f("ok?")
}
func callReceiveThrower() { // no throws needed
    receiveThrower { s in // no try needed
        print("thanks for the string!")
    }
}</pre>
</div>
</aside>

<p class="author1">Even if your own code never uses the keyword <code class="calibre19">throw</code> explicitly, youâ€™re still very likely, in real life, to call Cocoa methods that are marked with <code class="calibre19">throws</code>. Therefore, you need to know how Swiftâ€™s error mechanism relates to Cocoa and Objective-C.</p>

<p class="author1">Recall that an Objective-C method can return only one value (there are no tuples). So if a Cocoa method that returns a value has a failure and wants to hand back an NSError, how can it do it? Typically, such a method will return <code class="calibre19">nil</code> or <code class="calibre19">false</code> to indicate failure, and will also take an <code class="calibre19">NSError**</code> parameter as a way of communicating an error to the caller in addition to the method result; the <code class="calibre19">NSError**</code> parameter is similar to a Swift <code class="calibre19">inout</code> parameter.</p>

<p class="author1">For example, NSString has an initializer declared in Objective-C like this:<a data-type="indexterm" data-primary="NSErrorPointer" id="calibre_link-1441" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="ErrorPointer" id="calibre_link-779" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors" data-secondary="Objective-C" id="calibre_link-783" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">- (instancetype)initWithContentsOfFile:(NSString *)path
                              encoding:(NSStringEncoding)enc
                                 error:(NSError **)error;</pre>

<p class="author1">Objective-C code that calls that initializer must test to see whether the resulting NSString is in fact <code class="calibre19">nil</code>, and can examine the resulting error if it is:</p>

<pre data-type="programlisting" class="calibre28">NSError* err;
NSString* s =
    [[NSString alloc] initWithContentsOfFile:f
                                    encoding:NSUTF8StringEncoding
                                       error:&amp;err];
if (s == nil) {
    NSLog(@"%@", err);
}</pre>

<p class="author1">As you can see, the whole procedure is a lot like using a Swift <code class="calibre19">inout</code> parameter. An NSError variable must be prepared beforehand, and its address must be passed to the initializer as the <code class="calibre19">error:</code> argument. After the call, we have to test the initializerâ€™s result for <code class="calibre19">nil</code> explicitly, to see whether the initialization succeeded; if it didnâ€™t, we can examine the NSError variable to see what the error was. This is an annoyingly elaborate but necessary dance in Objective-C.</p>

<p class="author1">Fortunately, in Swift, an Objective-C method that takes an <code class="calibre19">NSError**</code> is automatically recast to take advantage of the error mechanism. The <code class="calibre19">error:</code> parameter is stripped from the Swift translation of the declaration, and is replaced by a <code class="calibre19">throws</code> marker:</p>

<pre data-type="programlisting" class="calibre28">init(contentsOfFile path: String, encoding enc: String.Encoding) throws</pre>

<p class="author1">Thus there is no need to declare an NSError variable beforehand, and no need to receive the NSError by indirection. Instead, you just call the method, within the controlled conditions dictated by Swift. (The same method bridging works also in reverse: a Swift <code class="calibre19">throws</code> method that is exposed to Objective-C is seen as taking an <code class="calibre19">NSError**</code> parameter.)</p>

<p class="author1">Objective-C NSError and Swift Error are bridged to one another. Swift helps you cross the bridge by giving Error a <code class="calibre19">localizedDescription</code> property, allowing you to read NSErrorâ€™s <code class="calibre19">localizedDescription</code>.
Moreover, you can catch a specific NSError by its name. The name youâ€™ll use is the NSError <code class="calibre19">domain</code>, and optionally (with dot-notation) the Cocoa name of its <code class="calibre19">code</code>.<a data-type="indexterm" data-primary="bridged types" data-secondary="Error and NSError" id="calibre_link-291" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So letâ€™s say we call <code class="calibre19">init(contentsOfFile:)</code> and we want specifically to catch the error thrown when there is no such file. This NSErrorâ€™s <code class="calibre19">domain</code>, according to Cocoa, is <code class="calibre19">"NSCocoaErrorDomain"</code>; Swift sees that as CocoaError. Its <code class="calibre19">code</code> is 260, for which Cocoa provides the name NSFileReadNoSuchFileError (I found that out by looking in the <em class="calibre11">FoundationErrors.h</em> header file in Objective-C); Swift sees that as <code class="calibre19">.fileReadNoSuchFile</code>. Thus we can catch this specific error under the name <code class="calibre19">CocoaError.fileReadNoSuchFile</code>:</p>

<pre data-type="programlisting" class="calibre28">do {
    let f = // path to some file, maybe
    let s = try String(contentsOfFile: f)
    // ... if successful, do something with s ...
} catch CocoaError.fileReadNoSuchFile {
    print("no such file")
} catch {
    print(error)
}</pre>

<p class="author1">Objective-C sees a Swift error coherently as well. By default, it receives a Swift error as an NSError whose <code class="calibre19">domain</code> is the name of the Swift object type. If the Swift object type is an enum, the NSErrorâ€™s <code class="calibre19">code</code> is the index number of its case; otherwise, the <code class="calibre19">code</code> is 1. When you want to provide Objective-C with a fuller complement of information, make your error type adopt one or both of these protocols:<a data-type="indexterm" data-primary="LocalizedError" id="calibre_link-1248" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="CustomNSError" id="calibre_link-594" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-startref="idxerrors" id="calibre_link-781" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">LocalizedError</dt>
<dd class="calibre16">
<p class="calibre17">Adopts Error, adding three optional properties: <code class="calibre19">errorDescription</code> (NSError <code class="calibre19">localizedDescription</code>), <code class="calibre19">failureReason</code> (NSError <code class="calibre19">localizedFailureReason</code>), and <code class="calibre19">recoverySuggestion</code> (NSError <code class="calibre19">localizedRecoverySuggestion</code>). Observe that these are <code class="calibre19">String?</code> properties; declaring them as simple String rather than Optional fails to communicate the information to Objective-C, and is a common mistake.</p>
</dd>
<dt class="calibre15">CustomNSError</dt>
<dd class="calibre16">
<p class="calibre17">Adopts Error, adding three properties with default implementations: <code class="calibre19">errorDomain</code>, <code class="calibre19">errorCode</code>, and <code class="calibre19">errorUserInfo</code>, which Objective-C will see as the <span class="publishername">NSErrorâ€™s</span> <code class="calibre19">domain</code>, <code class="calibre19">code</code>, and <code class="calibre19">userInfo</code>.</p>
</dd>
</dl>

<p class="author1">An initializer can throw &mdash; that is, the initializerâ€™s declaration is marked <code class="calibre19">throws</code>. So in designing an initializer, when should you prefer a failable initializer (<code class="calibre19">init?</code>) and when should you prefer a throwing initializer (<code class="calibre19">init...throws</code>)? No hard and fast rule can be given; it depends on your overall design goals.
In general, <code class="calibre19">init?</code> implies simple failure to create an instance, whereas <code class="calibre19">throws</code> implies that there is useful information to be gleaned by studying the error.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Later in this chapter, Iâ€™ll talk about a new Swift 5 feature, the Result enum, that lets you deal elegantly with errors in an asynchronous context.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Nested scopes" class="calibre2"><div class="preface" id="calibre_link-2971">
<h3 class="calibre44">Nested scopes</h3>

<p class="author1">When a local variable needs to exist only for a few lines of code, you might like to define an artificial scope &mdash; a custom nested scope, at the start of which you can introduce your local variable, and at the end of which that variable will be permitted to go out of scope, destroying its value automatically. Swift does not permit you to use bare curly braces to do this. Instead, use a bare do block without a <code class="calibre19">catch</code>.<a data-type="indexterm" data-primary="do" id="calibre_link-687" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nested scopes" id="calibre_link-1385" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="scope" data-secondary="nested" id="calibre_link-1956" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s a rewrite of our earlier code (<a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>) for uniquing an array while keeping its order:</p>

<pre data-type="programlisting" class="calibre28">var arr = ["Mannie", "Mannie", "Moe", "Jack", "Jack", "Moe", "Mannie"]
do {
    var temp = Set&lt;String&gt;()
    arr = arr.filter { temp.insert($0).inserted }
}</pre>

<p class="author1">The only purpose of <code class="calibre19">temp</code> is to act as a â€œhelperâ€ for this one <code class="calibre19">filter</code> call. So we embed its declaration and the <code class="calibre19">filter</code> call in a bare do block; that way, <code class="calibre19">temp</code> is in a lower scope that doesnâ€™t clutter up our local namespace, and as soon as the <code class="calibre19">filter</code> call is over, we exit the block and <code class="calibre19">temp</code> is destroyed.</p>

<p class="author1">Another use of a bare do block is to implement the simplest form of early exit. The do block gives you a scope to jump out of, by labeling the do block and breaking to that label:</p>

<pre data-type="programlisting" class="calibre28">out: do {
    // ...
    if somethingBadHappened {
        break out
    }
    // we won't get here if somethingBadHappened
}
// jump to here if somethingBadHappened</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Defer statement" class="calibre2"><div class="preface" id="calibre_link-2972">
<h3 class="calibre44">Defer statement</h3>

<p class="author1">The purpose of the defer statement is to ensure that a certain block of code will be executed at the time the path of execution <em class="calibre11">exits</em> the current scope, <em class="calibre11">no matter how</em>.<a data-type="indexterm" data-primary="defer statement" id="calibre_link-634" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A defer statement applies to the scope in which it appears, such as a function body, a while block, an if construct, a do block, and so on. Wherever you say <code class="calibre19">defer</code>, curly braces surround it somehow; the defer block will be executed <em class="calibre11">when the path of execution leaves those curly braces</em>. Leaving the curly braces can involve reaching the last line of code within the curly braces, or any of the forms of early exit described earlier in this section.<a data-type="indexterm" data-primary="ensure code is executed" id="calibre_link-737" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To see one reason why this is useful, consider the following pair of commands:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">UIApplication.shared.beginIgnoringInteractionEvents()</code></dt>
<dd class="calibre16">
<p class="calibre17">Stops all user touches from reaching any view of the application.</p>
</dd>
<dt class="calibre15"><code class="calibre19">UIApplication.shared.endIgnoringInteractionEvents()</code></dt>
<dd class="calibre16">
<p class="calibre17">Restores the ability of user touches to reach views of the application.</p>
</dd>
</dl>

<p class="author1">It can be valuable to turn off user interactions at the start of some slightly time-consuming operation and then turn them back on after that operation, especially when, during the operation, the interface or the appâ€™s logic will be in some state where the userâ€™s tapping a button, say, could cause things to go awry. Thus, it is not uncommon for a method to be constructed like this:</p>

<pre data-type="programlisting" class="calibre28">func doSomethingTimeConsuming() {
    UIApplication.shared.beginIgnoringInteractionEvents()
    // ... do stuff ...
    UIApplication.shared.endIgnoringInteractionEvents()
}</pre>

<p class="author1">All well and good &mdash; <em class="calibre11">if</em> we can guarantee that the only path of execution out of this function will be by way of that last line. But what if we need to return early from this function? Our code now looks like this:</p>

<pre data-type="programlisting" class="calibre28">func doSomethingTimeConsuming() {
    UIApplication.shared.beginIgnoringInteractionEvents()
    // ... do stuff ...
    if somethingHappened {
        return
    }
    // ... do more stuff ...
    UIApplication.shared.endIgnoringInteractionEvents()
}</pre>

<p class="author1">Oops! Weâ€™ve just made a terrible mistake. By providing an additional path out of our <code class="calibre19">doSomethingTimeConsuming</code> function, weâ€™ve created the possibility that our code might never encounter the call to <code class="calibre19">endIgnoringInteractionEvents</code>. We might leave our function by way of the return statement &mdash; and the user will then be left unable to interact with the interface. Obviously, we need to add another <code class="calibre19">endIgnoring...</code> call inside the if construct, just before the return statement. But as we continue to develop our code, we must remember, if we add <em class="calibre11">further</em> ways out of this function, to add <em class="calibre11">yet another</em> <code class="calibre19">endIgnoring...</code> call for <em class="calibre11">each</em> of them. This is madness!</p>

<p class="author1">The defer statement solves the problem. It lets us specify <em class="calibre11">once</em> what should happen when we leave this scope, <em class="calibre11">no matter how</em>. Our code now looks like this:</p>

<pre data-type="programlisting" class="calibre28">func doSomethingTimeConsuming() {
    defer {
        UIApplication.shared.endIgnoringInteractionEvents()
    }
    UIApplication.shared.beginIgnoringInteractionEvents()
    // ... do stuff ...
    if somethingHappened {
        return
    }
    // ... do more stuff ...
}</pre>

<p class="author1">The <code class="calibre19">endIgnoring...</code> call in the defer block will be executed, not where it appears, but before the return statement, or before the last line of the method &mdash; whichever path of execution ends up leaving the function. The defer statement says: â€œEventually, and as late as possible, be sure to execute this code.â€ We have thus ensured the necessary balance between turning off user interactions and turning them back on again. Most uses of the defer statement will probably come under this same rubric: youâ€™ll use it to balance a command or restore a disturbed state.</p>

<p class="author1">Observe that in the preceding code, I placed the defer statement very early in its surrounding scope. This placement is important because a defer statement is itself a command. If a defer statement is not actually <em class="calibre11">encountered</em> by the path of <span class="publishername">execution</span> before we exit from the surrounding scope, <em class="calibre11">its block wonâ€™t be executed.</em> For this reason, always place your defer statement as close to the start of its surrounding block as you can, to ensure that it will in fact be encountered.</p>

<p class="author1">When a defer statement changes a value that is returned by a return statement, the return happens first and the defer statement happens second. In other words, <code class="calibre19">defer</code> effectively lets you return a value <em class="calibre11">and then change it.</em> This example comes from Appleâ€™s own code (in the documentation, demonstrating how to write a struct that can adopt the Sequence protocol):</p>

<pre data-type="programlisting" class="calibre28">struct Countdown: Sequence, IteratorProtocol {
    var count: Int
    mutating func next() -&gt; Int? {
        if count == 0 {
            return nil
        } else {
            defer { count -= 1 }
            return count
        }
    }
}</pre>

<p class="author1">That code returns the current value of <code class="calibre19">count</code> and <em class="calibre11">then</em> decrements <code class="calibre19">count</code>, ready for the next call to the <code class="calibre19">next</code> method. Without <code class="calibre19">defer</code>, weâ€™d decrement <code class="calibre19">count</code> and then return the decremented value, which is not whatâ€™s wanted.</p>

<p class="author1">If the current scope has multiple defer blocks pending, they will be called in the reverse of the order in which they were originally encountered. In effect, there is a defer <em class="calibre11">stack</em>; each successive defer statement, as it is encountered, pushes its code onto the top of the stack, and exiting the scope in which a defer statement appeared pops that code and executes it.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Aborting the whole program" class="calibre2"><div class="preface" id="calibre_link-2973">
<h3 class="calibre44">Aborting the whole program</h3>

<p class="author1">Aborting the whole program is an extreme form of flow control; the program stops dead in its tracks. In effect, you have deliberately crashed your own program. This is an unusual thing to do, but it can be useful as a way of raising a very red flag: you donâ€™t really <em class="calibre11">want</em> to abort, so if you <em class="calibre11">do</em> abort, things must be so bad that youâ€™ve no choice.<a data-type="indexterm" data-primary="aborting" id="calibre_link-105" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">One way to abort is by calling the global function <code class="calibre19">fatalError</code>. It takes a String parameter permitting you to provide a message to appear in the console. Iâ€™ve already given this example:<a data-type="indexterm" data-primary="fatalError" id="calibre_link-849" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}</pre>

<p class="author1">That code says, in effect, that execution should <em class="calibre11">never</em> reach this point. We have declared <code class="calibre19">init(coder:)</code> just because it is <code class="calibre19">required</code>, and we need to satisfy the compiler; but we have no real implementation of <code class="calibre19">init(coder:)</code>, and we do not expect to be initialized this way. If we <em class="calibre11">are</em> initialized this way, something has gone very wrong, and we <em class="calibre11">want</em> to crash, because our program has a serious bug.</p>

<p class="author1">An initializer containing a <code class="calibre19">fatalError</code> call does not have to initialize any properties. This is because <code class="calibre19">fatalError</code> is declared as returning the special Never enum type, which causes the compiler to abandon any contextual requirements. Similarly, a function that returns a value does not have to return any value if a <code class="calibre19">fatalError</code> call is encountered.<a data-type="indexterm" data-primary="Never" id="calibre_link-1389" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can abort conditionally by calling the <code class="calibre19">assert</code> function. Its first parameter is a condition &mdash; something that evaluates as a Bool. If the condition is <code class="calibre19">false</code>, we will abort; the second parameter is a String message to appear in the console if we <em class="calibre11">do</em> abort. The idea here is that you are making a bet (an <em class="calibre11">assertion</em>) that the condition is <code class="calibre19">true</code> &mdash; a bet that you feel so strongly about that if the condition is <code class="calibre19">false</code>, thereâ€™s a serious bug in your program and you want to crash so you can learn of this bug and fix it.<a data-type="indexterm" data-primary="assert" id="calibre_link-213" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">By default, <code class="calibre19">assert</code> works only when youâ€™re developing your program. When your program is to be finalized and made public, you throw a different build switch, telling the compiler that <code class="calibre19">assert</code> should be ignored. In effect, the conditions in your <code class="calibre19">assert</code> calls are then disregarded; they are all seen as <code class="calibre19">true</code>. This means that you can safely leave <code class="calibre19">assert</code> calls in your code. By the time your program ships, of course, none of your assertions should be failing; any bugs that caused them to fail should already have been ironed out.</p>

<p class="author1">The disabling of assertions in shipping code is performed in an interesting way. The condition parameter is given an extra layer of indirection by declaring it as an <code class="calibre19">@autoclosure</code> function. This means that, even though the parameter is <em class="calibre11">not</em> in fact a function, the compiler will wrap it in a function; thus, the runtime neednâ€™t call that function unless it has to. In shipping code, the runtime will <em class="calibre11">not</em> call that function. This mechanism averts expensive and unnecessary evaluation: an <code class="calibre19">assert</code> condition test may involve side effects, but the test wonâ€™t even be performed when assertions are turned off in your shipping program.<a data-type="indexterm" data-primary="autoclosure" id="calibre_link-232" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In addition, Swift provides the <code class="calibre19">assertionFailure</code> function. Itâ€™s like an <code class="calibre19">assert</code> that always fails &mdash; and, like an <code class="calibre19">assert</code>, it <em class="calibre11">doesnâ€™t</em> fail in your shipping program where assertions are turned off. Itâ€™s a convenient synonym for <code class="calibre19">assert(false)</code>, as a way of assuring yourself that your code never goes where itâ€™s never supposed to go.</p>

<p class="author1"><code class="calibre19">precondition</code> and <code class="calibre19">preconditionFailure</code> are similar to <code class="calibre19">assert</code> and <code class="calibre19">assertionFailure</code>, except that they <em class="calibre11">do</em> fail even in a shipping program.<a data-type="indexterm" data-primary="precondition" id="calibre_link-1716" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Guard" class="calibre2"><div class="preface" id="calibre_link-2843">
<h3 class="calibre44">Guard</h3>

<p class="author1">When your code needs to <em class="calibre11">decide</em> whether to exit early, Swift provides a special syntax &mdash; the guard construct. In effect, a guard construct is an if construct where you exit early if the condition fails. Its form is shown in <a data-type="xref" href="#calibre_link-2848" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;5-6</a>.<a data-type="indexterm" data-primary="guard" id="calibre_link-990" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-2848" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 5-6. </span>The Swift guard construct</h5>

<pre data-type="programlisting" class="calibre31">guard <em class="calibre43">condition</em> else {
    <em class="calibre43">statements</em>
    <em class="calibre43">exit</em>
}</pre>
</div>

<p class="author1">A guard construct consists solely of a condition and an <code class="calibre19">else</code> block. The <code class="calibre19">else</code> block <em class="calibre11">must</em> jump out of the current scope, by any of the means that Swift provides, such as <code class="calibre19">return</code>, <code class="calibre19">break</code>, <code class="calibre19">continue</code>, <code class="calibre19">throw</code>, or <code class="calibre19">fatalError</code> &mdash; anything that guarantees to the compiler that, in case of failure of the condition, execution absolutely will not proceed within the block that contains the guard construct.</p>

<p class="author1">An elegant consequence of this architecture is that, because the guard construct guarantees an exit on failure of the condition, the compiler knows that the condition has succeeded after the guard construct if we do <em class="calibre11">not</em> exit. Thus, a conditional binding in the condition <em class="calibre11">is in scope after the guard construct</em>, without introducing a further nested scope:<a data-type="indexterm" data-primary="binding, conditional" id="calibre_link-254" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conditional binding" id="calibre_link-513" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="guard let" id="calibre_link-992" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="unwrapping" id="calibre_link-1629" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">guard let s = optionalString else {return}
// s is now a String (not an Optional)</pre>

<p class="author1">In my own code, itâ€™s not uncommon to have a series of guard constructs, one after another. This may seem a rather clunky and imperative mode of expression, but Iâ€™m fond of it nevertheless. Itâ€™s a nice alternative to a single elaborate if construct, or to the â€œpyramid of doomâ€ that I discussed earlier; and it looks like exactly what it is, a sequence of gates through which the code must pass in order to proceed further. Hereâ€™s an actual example from my real-life code:</p>

<pre data-type="programlisting" class="calibre28">@objc func tapField(_ g: Any) {
    // g must be a gesture recognizer
    guard let g = g as? UIGestureRecognizer else {return}
    // and that gesture recognizer must have a view
    guard g.view != nil else {return}
    // okay, now we can proceed...
}</pre>

<p class="author1">Itâ€™s often possible to combine multiple guard statement conditions into a single condition list:</p>

<pre data-type="programlisting" class="calibre28">@objc func tapField(_ g: Any) {
    // g must be a gesture recognizer
    // and that gesture recognizer must have a view
    guard let g = g as? UIGestureRecognizer, g.view != nil
        else {return}
    // okay, now we can proceed...
}</pre>

<p class="author1">A guard construct will also come in handy in conjunction with <code class="calibre19">try?</code>. Letâ€™s presume we canâ€™t proceed unless <code class="calibre19">String(contentsOfFile:)</code> succeeds. Then we can call it like this:</p>

<pre data-type="programlisting" class="calibre28">let f = // path to some file, maybe
guard let s = try? String(contentsOfFile: f) else {return}
// s is now a String (not an Optional)</pre>

<p class="author1">There is also a <code class="calibre19">guard case</code> construct, forming the logical inverse of <code class="calibre19">if case</code>. To illustrate, weâ€™ll use our MyError enum once again:<a data-type="indexterm" data-primary="guard case" id="calibre_link-991" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">guard case let .number(n) = err else {return}
// n is now the extracted number</pre>

<p class="author1"><code class="calibre19">guard case</code> helps to solve an interesting problem. Suppose we have a function whose returned value we want to check in a <code class="calibre19">guard</code> statement:</p>

<pre data-type="programlisting" class="calibre28">guard howMany() &gt; 10 else {return}</pre>

<p class="author1">All well and good; but suppose also that in the <em class="calibre11">next</em> line we want to <em class="calibre11">use</em> the value returned from that function. We donâ€™t want to call the function <em class="calibre11">again</em>; it might be time-consuming and it might have side effects. We want to <em class="calibre11">capture</em> the result of calling the function and pass that captured result on into the subsequent code. But we canâ€™t do that with <code class="calibre19">guard let</code>, because that requires an Optional, and our function <code class="calibre19">howMany</code> doesnâ€™t return an Optional.</p>

<p class="author1">What should we do? <code class="calibre19">guard case</code> to the rescue:</p>

<pre data-type="programlisting" class="calibre28">guard case let output = howMany(), output &gt; 10 else {return}
// now output is in scope</pre>

<p class="author1">Note that a guard constructâ€™s conditional binding canâ€™t use, on the left side of the equal sign, a name already declared in the same scope. This is illegal:</p>

<pre data-type="programlisting" class="calibre28">let s = // ... some Optional
guard let s = s else {return} // compile error</pre>

<p class="author1">The reason is that <code class="calibre19">guard let</code>, unlike <code class="calibre19">if let</code> and <code class="calibre19">while let</code>, doesnâ€™t declare the bound variable for a <em class="calibre11">nested</em> scope; it declares it for <em class="calibre11">this</em> scope. Thus, we canâ€™t declare <code class="calibre19">s</code> here because <code class="calibre19">s</code> has already been declared in the same scope.<a data-type="indexterm" data-startref="idxflowcontrol" id="calibre_link-874" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxjumping" id="calibre_link-1181" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Privacy" class="calibre2"><div class="preface" id="calibre_link-2524">
<h1 class="calibre18">Privacy</h1>

<p class="author1">Privacy (also known as <em class="calibre11">access control</em>) refers to the explicit modification of the normal scope rules. I gave an example in <a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>:<a data-type="indexterm" data-primary="privacy" id="calibre_link-1726" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="access control" id="calibre_link-106" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog {
    var name = ""
    private var whatADogSays = "woof"
    func bark() {
        print(self.whatADogSays)
    }
}</pre>

<p class="author1">The intention here is to limit how other objects can see the Dog property <code class="calibre19">whatADogSays</code>. It is a private property, intended primarily for the Dog classâ€™s own internal use: a Dog can speak of <code class="calibre19">self.whatADogSays</code>, but other objects should not be aware that it even exists.</p>

<p class="author1">Swift has five levels of privacy:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">internal</code></dt>
<dd class="calibre16">
<p class="calibre17">The default rule is that declarations are <em class="calibre11">internal</em>, meaning that they are globally visible <em class="calibre11">within the containing module</em>.<a data-type="indexterm" data-primary="internal" id="calibre_link-1149" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> That is why Swift files within the same module can see one anotherâ€™s top-level contents automatically, with no effort on your part. (Thatâ€™s different from C and Objective-C, where files canâ€™t see each other at all unless you explicitly show them to one another through <code class="calibre19">include</code> or <code class="calibre19">import</code> statements.)</p>
</dd>
<dt class="calibre15"><code class="calibre19">fileprivate</code> (narrower than <code class="calibre19">internal</code>)</dt>
<dd class="calibre16">
<p class="calibre17">A thing declared <code class="calibre19">fileprivate</code> is visible <em class="calibre11">only within its containing file</em>.<a data-type="indexterm" data-primary="fileprivate" id="calibre_link-853" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> For example, two object types declared in the same file can see one anotherâ€™s members declared <code class="calibre19">fileprivate</code>, but code in other files cannot see those members.</p>
</dd>
<dt class="calibre15"><code class="calibre19">private</code> (even narrower than <code class="calibre19">fileprivate</code>)</dt>
<dd class="calibre16">
<p class="calibre17">A thing declared <code class="calibre19">private</code> is visible <em class="calibre11">only within its containing curly braces</em>. In effect, the visibility of an object typeâ€™s member declared <code class="calibre19">private</code> is limited to code within this type declaration. (A <code class="calibre19">private</code> declaration at the top level of a file is equivalent to <code class="calibre19">fileprivate</code>.)<a data-type="indexterm" data-primary="private" id="calibre_link-1727" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15"><code class="calibre19">public</code> (wider than <code class="calibre19">internal</code>)</dt>
<dd class="calibre16">
<p class="calibre17">A thing declared <code class="calibre19">public</code> is visible <em class="calibre11">even outside its containing module</em>.<a data-type="indexterm" data-primary="public" id="calibre_link-1822" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Another module must first import this module before it can see anything at all. But even when another module <em class="calibre11">has</em> imported this module, it <em class="calibre11">still</em> wonâ€™t be able to see anything in this module that hasnâ€™t been explicitly declared <code class="calibre19">public</code>. If you donâ€™t write any modules, you might never need to declare anything <code class="calibre19">public</code>. If you do write a module, you <em class="calibre11">must</em> declare <em class="calibre11">something</em> <code class="calibre19">public</code>, or your module is useless.</p>
</dd>
<dt class="calibre15"><code class="calibre19">open</code> (even wider than <code class="calibre19">public</code>)</dt>
<dd class="calibre16">
<p class="calibre17">If a class is declared <code class="calibre19">open</code>, code in another module can subclass it; it canâ€™t do that if the class is declared merely <code class="calibre19">public</code>. If an open class member is declared <code class="calibre19">open</code>, code in another module that subclasses this class can override this member; it canâ€™t do that if the member is declared merely <code class="calibre19">public</code>.<a data-type="indexterm" data-primary="open" id="calibre_link-1556" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Private and Fileprivate" class="calibre2"><div class="preface" id="calibre_link-2525">
<h2 class="calibre42">Private and Fileprivate</h2>

<p class="author1">Declaring something <code class="calibre19">private</code> restricts its visibility. In this way, you specify by inversion what the public API of this object is. Hereâ€™s an example from my own code:</p>

<pre data-type="programlisting" class="calibre28">class CancelableTimer: NSObject {
    private var q = DispatchQueue(label: "timer")
    private var timer : DispatchSourceTimer!
    private var firsttime = true
    private var once : Bool
    private var handler : () -&gt; ()
    init(once:Bool, handler:@escaping () -&gt; ()) {
        // ...
    }
    func start(withInterval interval:Double) {
        // ...
    }
    func cancel() {
        // ...
    }
}</pre>

<p class="author1">The initializer <code class="calibre19">init(once:handler:)</code> and the <code class="calibre19">start(withInterval:)</code> and <code class="calibre19">cancel</code> methods, which are <em class="calibre11">not</em> marked <code class="calibre19">private</code>, are this classâ€™s public API. They say, â€œPlease feel free to call me!â€ The properties, however, are all private; no other code can see them, either to get them or to set them. They are purely for the internal use of the methods of this class. They maintain state, but it is not a state that any other code needs to know about.</p>

<p class="author1">Privacy is not magically violated by the existence of a special object relationship. For example, even a subclass cannot see its superclassâ€™s private members. (This comes as a surprise to those coming from a language with a <code class="calibre19">protected</code> privacy level.) You can work around this by declaring the class and its subclass in the same file and declaring those members <code class="calibre19">fileprivate</code> instead of <code class="calibre19">private</code>.</p>

<p class="author1">A nested type can see the private members of the type in which it is nested. This makes sense, because the outer type is a surrounding scope; the nested type sees what everything else inside this type sees.</p>

<p class="author1">An extension can see the private members of the type it extends, provided the type and the extension are in the same file:</p>

<pre data-type="programlisting" class="calibre28">class Dog {
    private var whatADogSays = "woof"
}
extension Dog {
    func speak() {
        print(self.whatADogSays) // ok
    }
}</pre>

<p class="author1">In effect, an extension sees its typeâ€™s <code class="calibre19">private</code> as meaning <code class="calibre19">fileprivate</code>. This lets you break up a type into extensions without being forced to raise the typeâ€™s private members to <code class="calibre19">fileprivate</code> just so the extensions can see them.</p>

<p class="author1">It may be that on some occasions you will want to draw a distinction between the privacy of a variable regarding setting and its privacy regarding getting. To draw this distinction, place the word <code class="calibre19">set</code> in parentheses after its own privacy declaration. Thus, <code class="calibre19">private(set) var myVar</code> means that the <em class="calibre11">setting</em> of this variable is restricted, but says nothing about the <em class="calibre11">getting</em> of this variable, which is left at the default. Similarly, you can say <code class="calibre19">public private(set) var myVar</code> to make getting this variable public, while setting this variable is kept private. (You can use this same syntax with a <code class="calibre19">subscript</code> function.)<a data-type="indexterm" data-primary="setter" data-secondary="private" id="calibre_link-2021" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">The existence of Objective-C adds complications. Things marked <code class="calibre19">@objc</code> can be marked <code class="calibre19">private</code> without harm; Objective-C can still see them. (That includes things marked <code class="calibre19">@IBAction</code> and <code class="calibre19">@IBOutlet</code>, which imply <code class="calibre19">@objc</code>.) But your implementation of a member defined by an Objective-C protocol cannot be marked <code class="calibre19">private</code> without hiding it from Objective-C. In particular, optional methods defined by a Cocoa protocol must be at least <code class="calibre19">internal</code> (the default), or Cocoa wonâ€™t be able to find them and wonâ€™t call them. Thus you are forced to expose these methods to other files in your module, as if they were part of this classâ€™s public API, even though you would probably prefer not to.<a data-type="indexterm" data-primary="objc" id="calibre_link-1481" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Public and Open" class="calibre2"><div class="preface" id="calibre_link-2526">
<h2 class="calibre42">Public and Open</h2>

<p class="author1">If you write a module, youâ€™ll need to specify at least some object type declaration as <code class="calibre19">public</code>; otherwise, code that imports your module wonâ€™t be able to see that type. Other declarations that are not declared <code class="calibre19">public</code> are internal, meaning that they are private to the module. Thus, judicious use of <code class="calibre19">public</code> declarations configures the public API of your module.<a data-type="indexterm" data-primary="modules" data-secondary="privacy" id="calibre_link-1362" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The members of a public object type are not, themselves, automatically public. If you want a method to be public, you have to declare it <code class="calibre19">public</code>. This is an excellent default behavior, because it means that these members are not shared outside the module unless you want them to be. (As Apple puts it, you must â€œopt in to publishingâ€ object members.)</p>

<p class="author1">For example, in my Zotz app, which is a card game, the files declaring object types for creating and portraying cards and for combining them into a deck are bundled into a framework called ZotzDeck. A framework is a module. The idea is for these files to be able to see one another freely while limiting access from the rest of my app. Many of the ZotzDeck types, such as Card and Deck, are declared <code class="calibre19">public</code>. Many utility object types, however, are not; the classes within the ZotzDeck module can see and use them, but code outside the module doesnâ€™t need to be aware of them. Moreover, the Card class is declared <code class="calibre19">public</code> but its initializer is not, because the public way to get cards is by initializing a Deck; the initializer for Deck <em class="calibre11">is</em> declared <code class="calibre19">public</code>, so you can do that.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If the only initializer for a public type is implicit, code in another module canâ€™t see it and thus cannot create an instance of this type. If you want other code to be able to create an instance of this type, you must declare the initializer explicitly and make it public.</p>
</div>

<p class="author1">The <code class="calibre19">open</code> access level draws a further distinction. It is applicable only to classes and to members of open classes. A public class canâ€™t be subclassed in another module that can see this class; an open class can. A public member of an open class that has been subclassed in another module canâ€™t be overridden in that subclass; an open member can.<a data-type="indexterm" data-primary="subclassing" data-secondary="preventing" id="calibre_link-2138" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="subclassing, preventing" id="calibre_link-397" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="overriding" data-secondary="preventing" id="calibre_link-1655" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="overriding" data-tertiary="preventing" id="calibre_link-1350" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="methods, overriding" data-tertiary="preventing" id="calibre_link-388" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Privacy Rules" class="calibre2"><div class="preface" id="calibre_link-2527">
<h2 class="calibre42">Privacy Rules</h2>

<p class="author1">There is an extensive set of rules for ensuring that the privacy level of related things is coherent. Here are some of them:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A variable canâ€™t be public if its type is private, because other code wouldnâ€™t be able to use such a variable.</p>
</li>
<li class="calibre12">
<p class="calibre17">A subclass canâ€™t be public unless the superclass is public.</p>
</li>
<li class="calibre12">
<p class="calibre17">A subclass can change an overridden memberâ€™s access level, but it cannot even <em class="calibre11">see</em> its superclassâ€™s private members unless they are declared in the same file together.</p>
</li>
</ul>

<p class="author1">And so on. I could proceed to list all the rules, but I wonâ€™t. There is no need for me to enunciate them formally. They are spelled out in great detail in the Swift manual, which you can consult if you need to. In general, you probably wonâ€™t need to; the <span class="publishername">privacy</span> rules make intuitive sense, and you can rely on the compiler to help you with useful error messages if you violate one.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Introspection" class="calibre2"><div class="preface" id="calibre_link-2528">
<h1 class="calibre18">Introspection</h1>

<p class="author1">Swift provides limited ability to <em class="calibre11">introspect</em> an object, letting an object display the names and values of its properties. This feature is intended for debugging, not for use in your programâ€™s logic. For example, you can use it to modify the way your object is displayed in the Xcode Debug pane.<a data-type="indexterm" data-primary="introspection" id="calibre_link-1157" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Mirror" id="calibre_link-1357" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To introspect an object, use it as the <code class="calibre19">reflecting:</code> parameter when you instantiate a Mirror. The Mirrorâ€™s <code class="calibre19">children</code> will then be name&ndash;value tuples describing the original objectâ€™s properties. Here, for example, is a Dog class with a <code class="calibre19">description</code> property that takes advantage of introspection. Instead of hard-coding a list of the classâ€™s instance properties, we introspect the instance to obtain the names and values of the properties. This means that we can later add more properties without having to modify our <code class="calibre19">description</code> implementation:</p>

<pre data-type="programlisting" class="calibre28">struct Dog : CustomStringConvertible {
    var name = "Fido"
    var license = 1
    var description : String {
        var desc = "Dog ("
        let mirror = Mirror(reflecting:self)
        for (k,v) in mirror.children {
            desc.append("\(k!): \(v), ")
        }
        return desc.dropLast(2) + ")"
    }
}</pre>

<p class="author1">If we now instantiate Dog and <code class="calibre19">print</code> that instance, this is what we see in the console:</p>

<pre data-type="programlisting" class="calibre28">Dog (name: Fido, license: 1)</pre>

<p class="author1">The main use of Mirror is to generate the console output for the Swift <code class="calibre19">dump</code> function (or the <code class="calibre19">po</code> command when debugging). By adopting the CustomReflectable protocol, we can take charge of what a Mirrorâ€™s <code class="calibre19">children</code> are. To do so, we supply the <code class="calibre19">customMirror</code> property to return our own custom Mirror object whose <code class="calibre19">children</code> property we have configured as a collection of name&ndash;value tuples.<a data-type="indexterm" data-primary="CustomReflectable" id="calibre_link-595" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dump" id="calibre_link-717" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In this (silly) example, we implement <code class="calibre19">customMirror</code> to supply altered names for our properties:</p>

<pre data-type="programlisting" class="calibre28">struct Dog : CustomReflectable {
    var name = "Fido"
    var license = 1
    var customMirror: Mirror {
        let children : [Mirror.Child] = [
            ("ineffable name", self.name),
            ("license to kill", self.license)
        ]
        let m = Mirror(self, children:children)
        return m
    }
}</pre>

<p class="author1">The outcome is that when our code says <code class="calibre19">dump(Dog())</code>, our custom property names are displayed:</p>

<pre data-type="programlisting" class="calibre28">* Dog
  - ineffable name : "Fido"
  - license to kill : 1</pre>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Operators" class="calibre2"><div class="preface" id="calibre_link-60">
<h1 class="calibre18">Operators</h1>

<p class="author1">Swift operators such as <code class="calibre19">+</code> and <code class="calibre19">&gt;</code> are not magically baked into the language. They are, in fact, functions; they are explicitly declared and implemented just like any other function. That is why, as I pointed out in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, the term <code class="calibre19">+</code> can be passed as the second parameter in a <code class="calibre19">reduce</code> call; <code class="calibre19">reduce</code> expects a function taking two parameters and returning a value whose type matches that of the first parameter, and <code class="calibre19">+</code> <em class="calibre11">is</em> in fact the name of such a function. It also explains how Swift operators can be overloaded for different types of operand. You can use <code class="calibre19">+</code> with numbers, strings, or arrays &mdash; with a different meaning in each case &mdash; because Swift functions can be overloaded; there are multiple declarations of the <code class="calibre19">+</code> function, and from the parameter types, Swift is able to determine <em class="calibre11">which</em> <code class="calibre19">+</code> function you are calling.<a data-type="indexterm" data-primary="operators" id="calibre_link-1559" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">These facts are not merely an intriguing behind-the-scenes implementation detail. They have practical implications for you and your code. You are free to overload existing operators to apply to <em class="calibre11">your</em> object types. You can even invent <em class="calibre11">new</em> operators! In this section, weâ€™ll do both.</p>

<p class="author1">First weâ€™ll talk about how operators are declared. Clearly there is some sort of syntactical hanky-panky (a technical computer science term), because you donâ€™t <em class="calibre11">call</em> an operator function in the same way as a normal function. You donâ€™t say <code class="calibre19">+(1,2)</code>; you say <code class="calibre19">1+2</code>. Even so, <code class="calibre19">1</code> and <code class="calibre19">2</code> in that second expression <em class="calibre11">are</em> the parameters to a <code class="calibre19">+</code> function call. How does Swift know that the <code class="calibre19">+</code> function uses this special syntax?<a data-type="indexterm" data-primary="operators" data-secondary="declaration" id="calibre_link-1570" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="of operators" id="calibre_link-629" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operator syntax" id="calibre_link-1558" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To see the answer, look in the Swift header:</p>

<pre data-type="programlisting" class="calibre28">infix operator + : AdditionPrecedence</pre>

<p class="author1">That is an operator declaration. An operator declaration announces that this symbol <em class="calibre11">is</em> an operator, and tells how many parameters it has and what the usage syntax will be in relation to those parameters. The really important part is the stuff before the colon: the keyword <code class="calibre19">operator</code>, preceded by an operator <em class="calibre11">type</em> &mdash; here, <code class="calibre19">infix</code> &mdash; and followed by the name of the operator. The types are:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">infix</code></dt>
<dd class="calibre16">
<p class="calibre17">This operator takes two parameters and appears between them.</p>
</dd>
<dt class="calibre15"><code class="calibre19">prefix</code></dt>
<dd class="calibre16">
<p class="calibre17">This operator takes one parameter and appears before it.</p>
</dd>
<dt class="calibre15"><code class="calibre19">postfix</code></dt>
<dd class="calibre16">
<p class="calibre17">This operator takes one parameter and appears after it.</p>
</dd>
</dl>

<p class="author1">The term after the colon in an operator declaration is the name of a precedence group. Precedence groups dictate the order of operations when an expression contains multiple operators. Iâ€™m not going to go into the details of how precedence groups are defined. The Swift header declares about a dozen precedence groups, and you can easily see how those declarations work. You will probably have no need to declare a new precedence group; instead, youâ€™ll just look for an operator similar to yours and copy its precedence group (or omit the colon and the precedence group from your declaration).<a data-type="indexterm" data-primary="precedence" id="calibre_link-1715" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="precedence" id="calibre_link-1578" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">An operator is also a function, so you also need a function declaration stating the type of the parameters and the result type of the function. Again, the Swift header shows us an example:</p>

<pre data-type="programlisting" class="calibre28">func +(lhs: Int, rhs: Int) -&gt; Int</pre>

<p class="author1">That is one of many declarations for the <code class="calibre19">+</code> function in the Swift header. In particular, it is the declaration for when the parameters are both Int. In that situation, the result is itself an Int. (The local parameter names <code class="calibre19">lhs</code> and <code class="calibre19">rhs</code>, which donâ€™t affect the special calling syntax, presumably stand for â€œleft-hand sideâ€ and â€œright-hand side.â€)</p>

<p class="author1">An operator declaration must appear at the top level of a file. The corresponding function declaration may appear either at the top level of a file or at the top level of a type declaration; in the latter case, it must be marked <code class="calibre19">static</code>. If the operator is a <code class="calibre19">prefix</code> or <code class="calibre19">postfix</code> operator, the function declaration must start with the word <code class="calibre19">prefix</code> or <code class="calibre19">postfix</code>; the default is <code class="calibre19">infix</code> and can be omitted.</p>

<p class="author1">We now know enough to override an operator to work with an object type of our own! As a simple example, imagine a Vial full of bacteria:<a data-type="indexterm" data-primary="operators" data-secondary="overriding" id="calibre_link-1576" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="arithmetic" data-tertiary="custom" id="calibre_link-1562" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct Vial {
    var numberOfBacteria : Int
    init(_ n:Int) {
        self.numberOfBacteria = n
    }
}</pre>

<p class="author1">When two Vials are combined, you get a Vial with all the bacteria from both of them. So the way to add two Vials is to add their bacteria:</p>

<pre data-type="programlisting" class="calibre28">extension Vial {
    static func +(lhs:Vial, rhs:Vial) -&gt; Vial {
        let total = lhs.numberOfBacteria + rhs.numberOfBacteria
        return Vial(total)
    }
}</pre>

<p class="author1">And hereâ€™s code to test our new <code class="calibre19">+</code> operator override:</p>

<pre data-type="programlisting" class="calibre28">let v1 = Vial(500_000)
let v2 = Vial(400_000)
let v3 = v1 + v2
print(v3.numberOfBacteria) // 900000</pre>

<p class="author1">In the case of a compound assignment operator, the first parameter is the thing being assigned to. Therefore, to implement such an operator, the first parameter must be declared <code class="calibre19">inout</code>. Letâ€™s do that for our Vial class:</p>

<pre data-type="programlisting" class="calibre28">extension Vial {
    static func +=(lhs:inout Vial, rhs:Vial) {
        let total = lhs.numberOfBacteria + rhs.numberOfBacteria
        lhs.numberOfBacteria = total
    }
}</pre>

<p class="author1">Hereâ€™s code to test our <code class="calibre19">+=</code> override:</p>

<pre data-type="programlisting" class="calibre28">var v1 = Vial(500_000)
let v2 = Vial(400_000)
v1 += v2
print(v1.numberOfBacteria) // 900000</pre>

<p class="author1">Next, letâ€™s invent a completely new operator. As an example, Iâ€™ll inject an operator into Int that raises one number to the power of another. As my operator symbol, Iâ€™ll use <code class="calibre19">^^</code> (Iâ€™d like to use <code class="calibre19">^</code> but itâ€™s already in use for something else). For simplicity, Iâ€™ll omit error-checking for edge cases (such as exponents less than <code class="calibre19">1</code>):<a data-type="indexterm" data-primary="operators" data-secondary="creating" id="calibre_link-1569" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">infix operator ^^
extension Int {
    static func ^^(lhs:Int, rhs:Int) -&gt; Int {
        var result = lhs
        for _ in 1..&lt;rhs {result *= lhs}
        return result
    }
}</pre>

<p class="author1">Thatâ€™s all it takes! Hereâ€™s some code to test it:</p>

<pre data-type="programlisting" class="calibre28">print(2^^2) // 4
print(2^^3) // 8
print(3^^3) // 27</pre>

<p class="author1">Hereâ€™s another example. Iâ€™ve already illustrated the use of Rangeâ€™s <code class="calibre19">reversed</code> method to allow iteration from a higher value to a lower one. That works, but I find the notation unpleasant. Thereâ€™s an asymmetry with how you iterate up; the endpoints are in the wrong order, and you have to remember to surround a literal range with parentheses:<a data-type="indexterm" data-primary="ranges" data-secondary="iterating in reverse" id="calibre_link-1844" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let r1 = 1..&lt;10
let r2 = (1..&lt;10).reversed()</pre>

<p class="author1">Letâ€™s define a custom operator that calls <code class="calibre19">reversed()</code> for us:</p>

<pre data-type="programlisting" class="calibre28">infix operator &gt;&gt;&gt; : RangeFormationPrecedence
func &gt;&gt;&gt;&lt;Bound&gt;(maximum: Bound, minimum: Bound)
    -&gt; ReversedCollection&lt;Range&lt;Bound&gt;&gt;
    where Bound : Strideable {
        return (minimum..&lt;maximum).reversed()
}</pre>

<p class="author1">Now our expressions can be more symmetrical and compact:</p>

<pre data-type="programlisting" class="calibre28">let r1 = 1..&lt;10
let r2 = 10&gt;&gt;&gt;1</pre>

<p class="author1">The Swift manual lists the special characters that can be used as part of a custom operator name:</p>

<pre data-type="programlisting" class="calibre28">/ = - + ! * % &lt; &gt; &amp; | ^ ? ~</pre>

<p class="author1">An operator name can also contain many other symbol characters (that is, characters that canâ€™t be mistaken for some sort of alphanumeric) that are harder to type; see the manual for a formal list.<a data-type="indexterm" data-startref="idxoperators" id="calibre_link-1560" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Memory Management" class="calibre2"><div class="preface" id="calibre_link-2529">
<h1 class="calibre18">Memory Management</h1>

<p class="author1">Swift memory management is handled automatically, and you will usually be unaware of it. Objects come into existence when they are instantiated and go out of existence as soon as they are no longer needed. Nevertheless, there are some memory management issues of which even a Swift user must be conscious.<a data-type="indexterm" data-primary="reference types" data-secondary="memory management" id="calibre_link-1864" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" id="calibre_link-1284" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Memory Management of Reference Types" class="calibre2"><div class="preface" id="calibre_link-2530">
<h2 class="calibre42">Memory Management of Reference Types</h2>

<p class="author1">Memory management of reference type objects (<a data-type="xref" href="#calibre_link-65" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œValue Types and Reference Typesâ€</a>) is quite tricky under the hood; Iâ€™ll devote <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a> to a discussion of the underlying mechanism. Swift normally does all the work for you, but trouble can arise when two class instances have references to one another. When thatâ€™s the case, you can have a <em class="calibre11">retain cycle</em> which will result in a <em class="calibre11">memory leak</em>, meaning that the two instances <em class="calibre11">never</em> go out of existence. Some computer languages solve this sort of problem with a periodic â€œgarbage collectionâ€ phase that detects retain cycles and cleans them up, but Swift doesnâ€™t do that; you have to fend off retain cycles manually.<a data-type="indexterm" data-primary="retain cycles" id="calibre_link-1922" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory leaks" id="calibre_link-1279" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="leaks, memory" id="calibre_link-1215" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="garbage collection" id="calibre_link-941" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="leaks" id="calibre_link-1300" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="retain cycles" id="calibre_link-1311" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">One way to test for and observe a memory leak is to implement a classâ€™s <code class="calibre19">deinit</code>. This method is called when the instance goes out of existence. If the instance never goes out of existence, <code class="calibre19">deinit</code> is never called. Thatâ€™s a bad sign, if you were expecting that the instance <em class="calibre11">should</em> go out of existence.<a data-type="indexterm" data-primary="deinit" data-secondary="not called" id="calibre_link-639" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s an example. First, Iâ€™ll make two class instances and watch them go out of <span class="publishername">existence:</span></p>

<pre data-type="programlisting" class="calibre28">func testRetainCycle() {
    class Dog {
        deinit {
            print("farewell from Dog")
        }
    }
    class Cat {
        deinit {
            print("farewell from Cat")
        }
    }
    let d = Dog()
    let c = Cat()
}
testRetainCycle() // farewell from Cat, farewell from Dog</pre>

<p class="author1">When we run that code, both â€œfarewellâ€ messages appear in the console. We created a Dog instance and a Cat instance, but the only references to them are automatic (local) variables inside the <code class="calibre19">testRetainCycle</code> function. When execution of that functionâ€™s body comes to an end, all automatic variables are destroyed; that is what it means to be an automatic variable. There are no other references to our Dog and Cat instances that might make them persist, and so they are destroyed in good order.</p>

<p class="author1">Now Iâ€™ll change that code by giving the Dog and Cat objects references to each other:</p>

<pre data-type="programlisting" class="calibre28">func testRetainCycle() {
    class Dog {
        var cat : Cat?
        deinit {
            print("farewell from Dog")
        }
    }
    class Cat {
        var dog : Dog?
        deinit {
            print("farewell from Cat")
        }
    }
    let d = Dog()
    let c = Cat()
    d.cat = c // create a...
    c.dog = d // ...retain cycle
}
testRetainCycle() // nothing in console</pre>

<p class="author1">When we run that code, <em class="calibre11">neither</em> â€œfarewellâ€ message appears in the console. The Dog and Cat objects have references to one another. Those are <em class="calibre11">strong</em> references (also called <em class="calibre11">persisting</em> references). A strong reference sees to it that as long as our Dog has a reference to a particular Cat, that Cat will not be destroyed, and <em class="calibre11">vice versa</em>. Thatâ€™s a good thing, and is a fundamental principle of sensible memory management. The bad thing is that the Dog and the Cat have strong references <em class="calibre11">to one another</em>. Thatâ€™s a retain cycle! Neither the Dog instance nor the Cat instance can be destroyed, because neither of them can â€œgo firstâ€ &mdash; itâ€™s like Alphonse and Gaston who can never get through the door because each requires the other to precede him. The Dog canâ€™t be destroyed first because the Cat has a strong reference to it, and the Cat canâ€™t be destroyed first because the Dog has a strong reference to it.<a data-type="indexterm" data-primary="references" data-secondary="persisting" id="calibre_link-1867" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="persisting references" id="calibre_link-1692" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="strong" id="calibre_link-1869" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strong references" id="calibre_link-2118" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">These objects are now <em class="calibre11">leaking</em>. Our code is over; both <code class="calibre19">d</code> and <code class="calibre19">c</code> are gone. There are <em class="calibre11">no</em> further references to either of these objects; neither object can ever be referred to again. No code can mention them; no code can reach them. But they live on, floating, useless, and taking up memory.</p>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">The term â€œretain cycleâ€ is based on the <code class="calibre19">retain</code> command, which is used in Objective-C to form a strong reference. You canâ€™t say <code class="calibre19">retain</code> in Swift, so Apple often refers to this kind of cycle as a <em class="calibre11">strong reference cycle</em>. But a strong reference cycle <em class="calibre11">is</em> a retain cycle &mdash; the compiler is in fact inserting <code class="calibre19">retain</code> commands under the hood &mdash; and Iâ€™ll continue calling it a retain cycle.</p>
</div>










<section data-type="sect3" data-pdf-bookmark="Weak references" class="calibre2"><div class="preface" id="calibre_link-2974">
<h3 class="calibre44">Weak references</h3>

<p class="author1">One solution to a retain cycle is to mark the problematic reference as <code class="calibre19">weak</code>. This means that the reference is <em class="calibre11">not</em> a strong reference. It is a <em class="calibre11">weak reference</em>. The object referred to can now go out of existence even while the referrer continues to exist. Of course, this might present a danger, because now the object referred to may be destroyed behind the referrerâ€™s back. But Swift has a solution for that, too: only an Optional reference can be marked as <code class="calibre19">weak</code>. That way, if the object referred to <em class="calibre11">is</em> destroyed behind the referrerâ€™s back, the referrer will see something coherent, namely <code class="calibre19">nil</code>. Also, the reference must be a <code class="calibre19">var</code> reference, precisely because it can change spontaneously to <code class="calibre19">nil</code>.<a data-type="indexterm" data-primary="references" data-secondary="weak" id="calibre_link-1878" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="weak references" id="calibre_link-2361" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="weak references" id="calibre_link-1320" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">This code thus breaks the retain cycle and prevents the memory leak:</p>

<pre data-type="programlisting" class="calibre28">func testRetainCycle() {
    class Dog {
        weak var cat : Cat?
        deinit {
            print("farewell from Dog")
        }
    }
    class Cat {
        weak var dog : Dog?
        deinit {
            print("farewell from Cat")
        }
    }
    let d = Dog()
    let c = Cat()
    d.cat = c
    c.dog = d
}
testRetainCycle() // farewell from Cat, farewell from Dog</pre>

<p class="author1">Iâ€™ve gone overboard in that code. To break the retain cycle, thereâ€™s no need to make <em class="calibre11">both</em> Dogâ€™s <code class="calibre19">cat</code> and Catâ€™s <code class="calibre19">dog</code> weak references; making just <em class="calibre11">one</em> of the two a weak reference is sufficient to break the cycle. That, in fact, is the usual solution when a retain cycle threatens. One of the pair will typically be more of an â€œownerâ€ than the other; the one that is <em class="calibre11">not</em> the â€œownerâ€ will have a weak reference to its â€œowner.â€</p>

<p class="author1">Value types are not subject to the same memory management issues as reference types, but a value type can still be <em class="calibre11">involved</em> in a retain cycle with a class instance. In my retain cycle example, if Dog is a class and Cat is a struct, we still get a retain cycle. The solution is the same: make Catâ€™s <code class="calibre19">dog</code> a weak reference. (You canâ€™t make Dogâ€™s <code class="calibre19">cat</code> a weak reference if Cat is a struct; only a reference to a class type can be declared <code class="calibre19">weak</code>.)</p>

<p class="author1">Do <em class="calibre11">not</em> use weak references unless you have to! Memory management is not to be toyed with lightly. Nevertheless, there are real-life situations in which weak references are the right thing to do, even when no retain cycle appears to threaten. The delegation pattern (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) is a typical case in point; an object typically has no business owning (retaining) its delegate. And a view controller <code class="calibre19">@IBOutlet</code> property is usually <code class="calibre19">weak</code>, because it refers to a subview already owned by its own superview.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Unowned references" class="calibre2"><div class="preface" id="calibre_link-2975">
<h3 class="calibre44">Unowned references</h3>

<p class="author1">Thereâ€™s another Swift solution for retain cycles. Instead of marking a reference as <code class="calibre19">weak</code>, you can mark it as <code class="calibre19">unowned</code>. This approach is useful in special cases where one object absolutely cannot exist without a reference to another, but where this reference need not be a strong reference.<a data-type="indexterm" data-primary="references" data-secondary="unowned" id="calibre_link-1875" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="unowned references" id="calibre_link-2284" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="unowned references" id="calibre_link-1316" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s pretend that a Boy may or may not have a Dog, but every Dog must have a Boy &mdash; and so Iâ€™ll give Dog an <code class="calibre19">init(boy:)</code> initializer. The Dog needs a reference to its Boy, and the Boy needs a reference to his Dog if he has one; thatâ€™s potentially a retain cycle:</p>

<pre data-type="programlisting" class="calibre28">func testUnowned() {
    class Boy {
        var dog : Dog?
        deinit {
            print("farewell from Boy")
        }
    }
    class Dog {
        let boy : Boy
        init(boy:Boy) { self.boy = boy }
        deinit {
            print("farewell from Dog")
        }
    }
    let b = Boy()
    let d = Dog(boy: b)
    b.dog = d
}
testUnowned() // nothing in console</pre>

<p class="author1">We can solve this by declaring Dogâ€™s <code class="calibre19">boy</code> property <code class="calibre19">unowned</code>:</p>

<pre data-type="programlisting" class="calibre28">func testUnowned() {
    class Boy {
        var dog : Dog?
        deinit {
            print("farewell from Boy")
        }
    }
    class Dog {
        unowned let boy : Boy // *
        init(boy:Boy) { self.boy = boy }
        deinit {
            print("farewell from Dog")
        }
    }
    let b = Boy()
    let d = Dog(boy: b)
    b.dog = d
}
testUnowned() // farewell from Boy, farewell from Dog</pre>

<p class="author1">An advantage of an <code class="calibre19">unowned</code> reference is that it doesnâ€™t have to be an Optional and it can be a constant (<code class="calibre19">let</code>). But an <code class="calibre19">unowned</code> reference is also <em class="calibre11">genuinely</em> dangerous, because the object referred to can go out of existence behind the referrerâ€™s back, and an attempt to use that reference will cause a crash, as I can demonstrate by this rather forced code:</p>

<pre data-type="programlisting" class="calibre28">var b = Optional(Boy())
let d = Dog(boy: b!)
b = nil // destroy the Boy behind the Dog's back
print(d.boy) // crash</pre>

<p class="author1">Clearly you should use <code class="calibre19">unowned</code> only if you are absolutely certain that the object referred to will outlive the referrer.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Stored anonymous functions" class="calibre2"><div class="preface" id="calibre_link-2976">
<h3 class="calibre44">Stored anonymous functions</h3>

<p class="author1">A particularly insidious kind of retain cycle arises when an instance property holds a function referring to the instance:<a data-type="indexterm" data-primary="anonymous functions" data-secondary="retain cycles" id="calibre_link-137" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="anonymous" data-tertiary="retain cycles" id="calibre_link-902" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="anonymous functions" id="calibre_link-1288" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="retain cycles" data-secondary="anonymous functions" id="calibre_link-1924" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class FunctionHolder {
    var function : (() -&gt; ())?
    deinit {
        print("farewell from FunctionHolder")
    }
}
func testFunctionHolder() {
    let fh = FunctionHolder()
    fh.function = {
        print(fh)
    }
}
testFunctionHolder() // nothing in console</pre>

<p class="author1">Oops! Iâ€™ve created a retain cycle, by referring, inside the anonymous function, to the object that is holding a reference to it. Because functions are closures, the FunctionHolder instance <code class="calibre19">fh</code>, declared outside the anonymous function, is captured by the anonymous function as a strong reference when the anonymous function says <code class="calibre19">print(fh)</code>. But the anonymous function has also been assigned to the <code class="calibre19">function</code> property of the FunctionHolder instance <code class="calibre19">fh</code>, and thatâ€™s a strong reference too. So thatâ€™s a retain cycle: the FunctionHolder persistently refers to the function, which persistently refers to the FunctionHolder.</p>

<p class="author1">In this situation, I <em class="calibre11">cannot</em> break the retain cycle by declaring the <code class="calibre19">function</code> property as <code class="calibre19">weak</code> or <code class="calibre19">unowned</code>. Only a reference to a class type can be declared <code class="calibre19">weak</code> or <code class="calibre19">unowned</code>, and a function is not a class. Thus, I must declare the captured value <code class="calibre19">fh</code> <em class="calibre11">inside the anonymous function</em> as <code class="calibre19">weak</code> or <code class="calibre19">unowned</code> instead.</p>

<p class="author1">Swift provides an ingenious syntax for doing that. At the very start of the anonymous function body, you put square brackets containing a comma-separated list of any problematic references that will be captured from the surrounding environment, each preceded by <code class="calibre19">weak</code> or <code class="calibre19">unowned</code>. This is called a <em class="calibre11">capture list</em>. If you have a capture list, you must follow it with the keyword <code class="calibre19">in</code> if thereâ€™s no <code class="calibre19">in</code> expression already:<a data-type="indexterm" data-primary="capture list" id="calibre_link-336" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="anonymous functions" data-secondary="capture list" id="calibre_link-134" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class FunctionHolder {
    var function : (() -&gt; ())?
    deinit {
        print("farewell from FunctionHolder")
    }
}
func testFunctionHolder() {
    let fh = FunctionHolder()
    fh.function = {
        [weak fh] in // *
        print(fh)
    }
}
testFunctionHolder() // farewell from FunctionHolder</pre>

<p class="author1">This syntax solves the problem. But marking a reference as <code class="calibre19">weak</code> in a capture list has a mild side effect that you will need to be aware of: such a reference passes into the anonymous function as an Optional. This is good, because it means that if the object referred to goes out of existence behind our back, the value of the Optional is <code class="calibre19">nil</code>. But of course you must also adjust your code accordingly, unwrapping the Optional as needed in order to use it. The usual technique is to perform the <em class="calibre11">weak&ndash;strong dance</em>: you unwrap the Optional once, right at the start of the function, in a conditional binding:<a data-type="indexterm" data-primary="weakâ€“strong dance" id="calibre_link-2363" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dance, weakâ€“strong" id="calibre_link-597" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class FunctionHolder {
    var function : (() -&gt; ())?
    deinit {
        print("farewell from FunctionHolder")
    }
}
func testFunctionHolder() {
    let fh = FunctionHolder()
    fh.function = {   // here comes the weak&ndash;strong dance...
        [weak fh] in  // weak
        guard let fh = fh else { return }
        print(fh)     // strong
    }
}
testFunctionHolder() // farewell from FunctionHolder</pre>

<p class="author1">The conditional binding <code class="calibre19">let fh = fh</code> elegantly accomplishes three goals:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">It unwraps the Optional version of <code class="calibre19">fh</code> that arrived into the anonymous function.</p>
</li>
<li class="calibre12">
<p class="calibre17">It declares another <code class="calibre19">fh</code> that is a normal (strong) reference. So if the unwrapping succeeds, this new <code class="calibre19">fh</code> will persist for the rest of this scope.</p>
</li>
<li class="calibre12">
<p class="calibre17">It causes the second <code class="calibre19">fh</code> to overshadow the first <code class="calibre19">fh</code> (because they have the same name). Thus it is impossible after the <code class="calibre19">guard</code> statement to refer accidentally to the weak Optional <code class="calibre19">fh</code>.</p>
</li>
</ul>

<p class="author1">Now, it happens that, in this particular example, there is no way the FunctionHolder instance <code class="calibre19">fh</code> can go out of existence while the anonymous function lives on. There are no other references to the anonymous function; it persists only as a property of <code class="calibre19">fh</code>. Therefore I can avoid some behind-the-scenes bookkeeping overhead, as well as the weak&ndash;strong dance, by declaring <code class="calibre19">fh</code> as <code class="calibre19">unowned</code> in my capture list instead of <code class="calibre19">weak</code>. In real life, my own most frequent use of <code class="calibre19">unowned</code> is precisely in this context. Very often, the reference marked as <code class="calibre19">unowned</code> in the capture list will be <code class="calibre19">self</code>.</p>

<p class="author1">Thereâ€™s another way to write a capture list: you can capture a value and assign it to a constant name. Hereâ€™s an example from my own code (without explanation of the context):</p>

<pre data-type="programlisting" class="calibre28">self.undoer.registerUndo(withTarget: self) {
    [oldCenter = self.center] myself in
    myself.setCenterUndoably(oldCenter)
}</pre>

<p class="author1">That code declares a constant <code class="calibre19">oldCenter</code> and sets its value to <code class="calibre19">self.center</code>. This avoids capturing <code class="calibre19">self</code>, because <code class="calibre19">self</code> never appears in the anonymous function, explicitly or implicitly; instead, the value of a property of <code class="calibre19">self</code> is captured <em class="calibre11">directly</em>, and that <em class="calibre11">value</em> is what passes into the anonymous function. Not only does this prevent a retain cycle, but also it avoids closure semantics; the value of <code class="calibre19">self.center</code> is evaluated <em class="calibre11">now</em>, when <code class="calibre19">registerUndo</code> is called, rather than later, when the anonymous function is called (at which time the value of <code class="calibre19">self.center</code> may have changed).</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Donâ€™t panic! Beginners may be tempted to backstop <em class="calibre11">all</em> their anonymous functions with <code class="calibre19">[weak self]</code>. Thatâ€™s wrong. Only a <em class="calibre11">stored</em> function can raise even the possibility of a retain cycle. Merely passing a function does <em class="calibre11">not</em> introduce such a possibility, especially if the function being passed will be called immediately. And even if a function <em class="calibre11">is</em> stored, if it is stored <em class="calibre11">elsewhere</em>, it might not imply a retain cycle. Always confirm that you actually <em class="calibre11">have</em> a retain cycle before concerning yourself with how to prevent it.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Memory management of protocol-typed references" class="calibre2"><div class="preface" id="calibre_link-2977">
<h3 class="calibre44">Memory management of protocol-typed references</h3>

<p class="author1">Only a reference to an instance of a class type can be declared <code class="calibre19">weak</code> or <code class="calibre19">unowned</code>. A reference to an instance of a struct or enum type cannot be so declared, because its memory management doesnâ€™t work the same way (and is not subject to retain cycles). A reference that is declared as a protocol type, therefore, has a problem. A reference typed as a protocol that might be adopted by a struct or an enum cannot be declared <code class="calibre19">weak</code> or <code class="calibre19">unowned</code>. You can only declare a protocol-typed reference <code class="calibre19">weak</code> or <code class="calibre19">unowned</code> if the compiler knows that only a class can adopt it. You can assure the compiler of that by making the protocol a class protocol.<a data-type="indexterm" data-primary="objc" id="calibre_link-1482" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="memory management" id="calibre_link-1810" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="protocol references" id="calibre_link-1310" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In this code, SecondViewControllerDelegate is a protocol that Iâ€™ve declared. This code wonâ€™t compile unless SecondViewControllerDelegate is declared as a class <span class="publishername">protocol:</span></p>

<pre data-type="programlisting" class="calibre28">class SecondViewController : UIViewController {
    weak var delegate : SecondViewControllerDelegate?
    // ...
}</pre>

<p class="author1">Hereâ€™s the actual declaration of SecondViewControllerDelegate; it <em class="calibre11">is</em> declared as a class protocol, and thatâ€™s why the preceding code is legal:</p>

<pre data-type="programlisting" class="calibre28">protocol SecondViewControllerDelegate : AnyObject {
    func accept(data:Any)
}</pre>

<p class="author1">A protocol declared in Objective-C is implicitly marked as <code class="calibre19">@objc</code> and is a class protocol. This declaration from my real-life code is legal:</p>

<pre data-type="programlisting" class="calibre28">weak var delegate : WKScriptMessageHandler?</pre>

<p class="author1">WKScriptMessageHandler is a protocol declared by Cocoa (in particular, by the Web Kit framework). Thus, it is implicitly marked <code class="calibre19">@objc</code>; only a class can adopt WKScriptMessageHandler, and so the compiler is satisfied that the <code class="calibre19">delegate</code> variable will be an instance of a class, and thus the reference can be treated as <code class="calibre19">weak</code>.</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Exclusive Access to Value Types" class="calibre2"><div class="preface" id="calibre_link-2531">
<h2 class="calibre42">Exclusive Access to Value Types</h2>

<p class="author1">Even value types can have memory management issues. In particular, a struct and its members might be directly accessed simultaneously, which could lead to unpredictable results. Fortunately, starting in Swift 4, the compiler will usually stop you before such an issue can arise.<a data-type="indexterm" data-primary="value types" data-secondary="memory management" id="calibre_link-2310" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To illustrate, imagine that we have a Person struct with a <code class="calibre19">firstName</code> string property. Now letâ€™s write a function that takes both a Person and a string as <code class="calibre19">inout</code> parameters:</p>

<pre data-type="programlisting" class="calibre28">func change(_ p:inout Person, _ s:inout String) {}</pre>

<p class="author1">So far so good; but now imagine calling that function with both a Person and that same Personâ€™s <code class="calibre19">firstName</code> as the parameters:</p>

<pre data-type="programlisting" class="calibre28">var p = Person(firstName: "Matt")
change(&amp;p, &amp;p.firstName) // compile error</pre>

<p class="author1">The compiler will stop you from doing that, with this message: â€œOverlapping accesses to <code class="calibre19">p</code>, but modification requires exclusive access.â€ The problem is that the single function <code class="calibre19">change</code> is being given direct access to the memory of both the struct and a member of that struct, simultaneously. The struct is thus capable of being altered in some unpredictable way.
This dangerous situation is forbidden; the compiler enforces <em class="calibre11">exclusive access</em> when a struct is being modified.<a data-type="indexterm" data-primary="errors, compiler" data-secondary="overlapping accesses" id="calibre_link-798" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="exclusive access" id="calibre_link-819" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="access, exclusive" id="calibre_link-107" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You may encounter that error message from the compiler under surprising circumstances:</p>

<pre data-type="programlisting" class="calibre28">let c = UIColor.purple
var components = Array(repeating: CGFloat(0), count: 4)
c.getRed(&amp;components[0], green: &amp;components[1],
    blue: &amp;components[2], alpha: &amp;components[3]) // compile error</pre>

<p class="author1">That code was legal in Swift 3 and before; in Swift 4 and later, it isnâ€™t. No exclusive access problem is evident to the untrained eye; you just have to take the compilerâ€™s word for it. One workaround is to take control of memory access yourself, thus silencing the compiler:</p>

<pre data-type="programlisting" class="calibre28">components.withUnsafeMutableBufferPointer { ptr -&gt; () in
    c.getRed(&amp;ptr[0], green: &amp;ptr[1], blue: &amp;ptr[2], alpha: &amp;ptr[3])
}</pre>

<p class="author1">It might be better to write a UIColor extension that assembles the array without any simultaneous memory access to multiple elements of the array: <a data-type="indexterm" data-startref="idxmemorymanagementswift" id="calibre_link-1285" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxswift" id="calibre_link-2169" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">extension UIColor {
    func getRedGreenBlueAlpha() -&gt; [CGFloat] {
        var (r,g,b,a) = (CGFloat(0),CGFloat(0),CGFloat(0),CGFloat(0))
        self.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)
        return [r,g,b,a]
    }
}</pre>

<p class="author1">Sometimes the compiler canâ€™t see the issue coming, and youâ€™ll crash at runtime instead:<a data-type="indexterm" data-primary="crash" data-secondary="simultaneous accesses" id="calibre_link-568" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var i = 0
func tweak(_ ii:inout Int) {
    print(i) // legal, but crash
}
tweak(&amp;i)</pre>

<p class="author1">In that code, <code class="calibre19">tweak</code> is accessing <code class="calibre19">i</code> in two ways simultaneously. On the one hand, <code class="calibre19">i</code> is being passed into <code class="calibre19">tweak</code> as an <code class="calibre19">inout</code> parameter. On the other hand, <code class="calibre19">tweak</code> is reaching out directly to <code class="calibre19">i</code> (which is in scope). Even though <code class="calibre19">tweak</code> never actually modifies <code class="calibre19">i</code> and never mentions its own <code class="calibre19">inout</code> parameter <code class="calibre19">ii</code>, thatâ€™s a simultaneous access, and is forbidden.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Miscellaneous Swift Language Features" class="calibre2"><div class="preface" id="calibre_link-2532">
<h1 class="calibre18">Miscellaneous Swift Language Features</h1>

<p class="author1">This chapter is a miscellany, and this section is a miscellany within a miscellany. Here I survey some â€œadvancedâ€ Swift language features that have been added relatively recently.</p>

<p class="author1">The reason for postponing the discussion to this point is in part to avoid cluttering up the earlier exposition and in part to ensure that you know enough to understand the topic. Take, for example, synthesized protocol implementations, explained in the first section; to talk about these together with protocols in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> would have prolonged the discussion unnecessarily, and the chief example, Equatable, depends on operator overloading, which I only just explained earlier in this chapter.</p>

<p class="author1">On the whole, the features described in this section are not so essential in order to be immediately conversant with Swift as what has gone before. Feel free to skim the rest of this chapter and return to it later as the need arises.</p>








<section data-type="sect2" data-pdf-bookmark="Synthesized Protocol Implementations" class="calibre2"><div class="preface" id="calibre_link-61">
<h2 class="calibre42">Synthesized Protocol Implementations</h2>

<p class="author1">A few protocols built into the Swift standard library have, starting in Swift 4.1, the ability to synthesize implementations of their own requirements. Such a protocol can supply code behind the scenes so that an object that adopts the protocol will satisfy the protocolâ€™s requirements <em class="calibre11">automatically</em>.<a data-type="indexterm" data-primary="protocols" data-secondary="synthesizing" id="calibre_link-1814" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="synthesizing protocols" id="calibre_link-2189" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Equatable" data-secondary="synthesizing implemention" id="calibre_link-777" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="equality" data-secondary="of Swift objects" id="calibre_link-771" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="operators" data-secondary="equality" data-tertiary="custom" id="calibre_link-1572" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Equatable" class="calibre2"><div class="preface" id="calibre_link-2978">
<h3 class="calibre44">Equatable</h3>

<p class="author1">Equatable is one such protocol. Thatâ€™s good, because making your custom type adopt Equatable is often a really useful thing to do. Equatable adoption means that the <code class="calibre19">==</code> operator can be used to check whether two instances of this type are equal. The only requirement of the Equatable protocol is that you do, in fact, define <code class="calibre19">==</code> for your type. Using our Vial struct from the previous section, letâ€™s first do that manually:</p>

<pre data-type="programlisting" class="calibre28">struct Vial {
    var numberOfBacteria : Int
    init(_ n:Int) {
        self.numberOfBacteria = n
    }
}
extension Vial : Equatable {
    static func ==(lhs:Vial, rhs:Vial) -&gt; Bool {
        return lhs.numberOfBacteria == rhs.numberOfBacteria
    }
}</pre>

<p class="author1">Now that Vial is an Equatable, not only can it be compared with <code class="calibre19">==</code>, but also lots of methods that need an Equatable parameter spring to life. For example, Vial becomes a candidate for use with methods such as <code class="calibre19">firstIndex(of:)</code>:</p>

<pre data-type="programlisting" class="calibre28">let v1 = Vial(500_000)
let v2 = Vial(400_000)
let arr = [v1,v2]
let ix = arr.firstIndex(of:v1) // Optional wrapping 0</pre>

<p class="author1">Whatâ€™s more, the complementary inequality operator <code class="calibre19">!=</code> has sprung to life for Vial automatically! Thatâ€™s because itâ€™s already defined for <em class="calibre11">any</em> Equatable in terms of the <code class="calibre19">==</code> operator.</p>

<p class="author1">Our implementation of <code class="calibre19">==</code> for Vial was easy to write. But thatâ€™s mostly because this struct has just one property! As soon as you have multiple properties, writing <code class="calibre19">==</code> manually, though theoretically trivial, becomes tedious and possibly hard to maintain. Thatâ€™s just the kind of task computers are good at! Youâ€™re likely going to want to define <code class="calibre19">==</code> in terms of the equality of all your typeâ€™s properties simultaneously; well, Swift will implement <code class="calibre19">==</code> <em class="calibre11">automatically</em> in exactly that way. All we have to do is declare adoption of Equatable, like this:</p>

<pre data-type="programlisting" class="calibre28">struct Vial : Equatable {
    var numberOfBacteria : Int
    init(_ n:Int) {
        self.numberOfBacteria = n
    }
}</pre>

<p class="author1">That code compiles, even though we now have no implementation of <code class="calibre19">==</code>. Thatâ€™s because the implementation has been synthesized for us. Behind the scenes, two Vial objects are now equal just in case their <code class="calibre19">numberOfBacteria</code> are equal &mdash; which is exactly the implementation we supplied when we wrote the code explicitly.</p>

<p class="author1">For Equatable synthesis to operate, the following requirements must be met:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Our object type is a struct or an enum.</p>
</li>
<li class="calibre12">
<p class="calibre17">We have adopted Equatable, <em class="calibre11">not</em> in an extension.</p>
</li>
<li class="calibre12">
<p class="calibre17">We have <em class="calibre11">not</em> supplied the implementation of the <code class="calibre19">==</code> operator required by <span class="publishername">Equatable</span>.</p>
</li>
<li class="calibre12">
<p class="calibre17">All of our structâ€™s stored property types are themselves Equatable.</p>
</li>
</ul>

<p class="author1">For an enum, the requirement here is that, if the enum has associated values, the types of those associated values must be Equatable. The synthesized <code class="calibre19">==</code> implementation will then say that two instances of our enum are equal if they are the same case and, if that case has an associated value, that value is equal for both instances. Recall that our MyError enum in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a> couldnâ€™t be used with the <code class="calibre19">==</code> operator until we explicitly declared it Equatable:</p>

<pre data-type="programlisting" class="calibre28">enum MyError : Equatable {
    case number(Int)
    case message(String)
    case fatal
}</pre>

<p class="author1">(If an enum has <em class="calibre11">no</em> associated values, then it is already effectively Equatable and there is no need to adopt Equatable <span class="publishername">explicitly.)</span><a data-type="indexterm" data-primary="enums" data-secondary="equality" id="calibre_link-759" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="associated value" id="calibre_link-752" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If you donâ€™t like the synthesized implementation of <code class="calibre19">==</code> (perhaps because there is a property that you donâ€™t want involved in the definition of equality), all you have to do is write your own, explicitly. You lose the convenience of automatic synthesis, but youâ€™re no worse off than you were before automatic synthesis existed.</p>

<p class="author1">For example, letâ€™s say we have a Dog struct with a <code class="calibre19">name</code> property and a <code class="calibre19">license</code> property and a <code class="calibre19">color</code> property. And letâ€™s say we think two Dogs are equal just in case they have the same name and license; we donâ€™t care whether the colors are the same. Then we just have to write the implementation of <code class="calibre19">==</code> ourselves, omitting <code class="calibre19">color</code> from the calculation:</p>

<pre data-type="programlisting" class="calibre28">struct Dog : Equatable {
    let name : String
    let license : Int
    let color : UIColor
    static func ==(lhs:Dog,rhs:Dog) -&gt; Bool {
        return lhs.name == rhs.name &amp;&amp; lhs.license == rhs.license
    }
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Hashable" class="calibre2"><div class="preface" id="calibre_link-2979">
<h3 class="calibre44">Hashable</h3>

<p class="author1">Another protocol that performs synthesis of its own implementation is Hashable. Recall that a type must be Hashable to be used in a Set or as the key type of a Dictionary. A struct whose properties are all Hashable, or an enum whose associated values are all Hashable, can conform to Hashable merely by declaring that it adopts <span class="publishername">Hashable.</span><a data-type="indexterm" data-primary="Hashable" data-secondary="synthesizing implementation" id="calibre_link-1003" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hashability" data-secondary="of Swift objects" id="calibre_link-1000" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hashable requires that its adopter, in addition to being Equatable, have a <code class="calibre19">hashValue</code> Int property; the idea is that two equal objects should have equal hash values. The implicit implementation combines the <code class="calibre19">hashValue</code> of the Hashable members to produce a <code class="calibre19">hashValue</code> for the object itself. Thatâ€™s good, because <em class="calibre11">you</em> would surely have no idea how to do that for yourself. Writing your own hash function is a very tricky business! Thanks to this feature, you donâ€™t have to.</p>

<p class="author1">But suppose you donâ€™t like the synthesized implementation of <code class="calibre19">hashValue</code>. Then you <em class="calibre11">will</em> have to calculate the <code class="calibre19">hashValue</code> yourself. Luckily, Swift 4.2 introduced a way to do that. You ignore <code class="calibre19">hashValue</code>, and instead implement the <code class="calibre19">hash(into:)</code> method. There is then no need to implement <code class="calibre19">hashValue</code>, because it is autogenerated based on the result of <code class="calibre19">hash(into:)</code>. In this method, you are handed a Hasher object; you call <code class="calibre19">hash(into:)</code> with that object on every property that you want included in the hash calculation &mdash; and omit the ones you donâ€™t. For hashability to work properly in a Dictionary or Set, these should be the very same properties youâ€™ve included in the Equatable calculation of <code class="calibre19">==</code>.<a data-type="indexterm" data-primary="hashValue" id="calibre_link-1006" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Hasher" id="calibre_link-1004" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So, for our Dog struct, we could write:</p>

<pre data-type="programlisting" class="calibre28">struct Dog : Hashable { // and therefore Equatable
    let name : String
    let license : Int
    let color : UIColor
    static func ==(lhs:Dog,rhs:Dog) -&gt; Bool {
        return lhs.name == rhs.name &amp;&amp; lhs.license == rhs.license
    }
    func hash(into hasher: inout Hasher) {
        name.hash(into:&amp;hasher)
        license.hash(into:&amp;hasher)
    }
}</pre>

<p class="author1">Other protocols, alas, do not provide the same convenience. For example, if we want our Vial struct to be Comparable, we must implement <code class="calibre19">&lt;</code> explicitly. (And when we do, the other three comparison operators spring to life automatically as well.)</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Key Paths" class="calibre2"><div class="preface" id="calibre_link-2533">
<h2 class="calibre42">Key Paths</h2>

<p class="author1">Key paths, a language feature introduced in Swift 4, effectively stand in relation to properties the way function references stand in relation to function calls &mdash; they are a way of storing a reference to a property without actually accessing the property.<a data-type="indexterm" data-primary="key paths" data-secondary="Swift" id="calibre_link-1186" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Suppose, for example, that we have a Person struct with a <code class="calibre19">firstName</code> String property and a <code class="calibre19">lastName</code> String property, and that we want to access one of these properties on a <span class="publishername">Person</span> <code class="calibre19">p</code>, without knowing until runtime <em class="calibre11">which</em> property we are to access. We might write something like this:</p>

<pre data-type="programlisting" class="calibre28">var getFirstName : Bool = // ...
let name : String = {
    if getFirstName {
        return p.firstName
    } else {
        return p.lastName
    }
}()</pre>

<p class="author1">Thatâ€™s not altogether atrocious, but itâ€™s hardly elegant. If we do the same sort of thing in several places, the same choice must somehow be repeated in each of those places &mdash; and the more choices there are, the more elaborate our code must be each time.</p>

<p class="author1">Key paths solve the problem by permitting us to encapsulate the <em class="calibre11">notion</em> of accessing a particular property of a type, such as Personâ€™s <code class="calibre19">firstName</code> or <code class="calibre19">lastName</code>, without actually <em class="calibre11">performing</em> the access. That notion is expressed as an instance; therefore, we can store it as a variable, or pass it as a function parameter. That instance then acts as a token that we can use to access the actual property on an actual instance of that type at some future time.</p>

<p class="author1">The literal notation for constructing a key path is:</p>

<pre data-type="programlisting" class="calibre28">\<em class="calibre43">Type</em>.<em class="calibre43">property</em>.<em class="calibre43">property</em>...</pre>

<p class="author1">We start with a backslash. Then we have the name of a type, which may be omitted if the type can be inferred from the context. Then we have a dot followed by a property name &mdash; and this may be repeated if that propertyâ€™s type itself has a property that we will want to access, and so on.<a data-type="indexterm" data-primary="backslash" id="calibre_link-241" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Thus, in our simple case, we might store the notion of accessing a particular property as a key path variable, like this:</p>

<pre data-type="programlisting" class="calibre28">var prop = \Person.firstName</pre>

<p class="author1">To perform the actual access, start with a reference to a particular instance and fetch its <code class="calibre19">keyPath:</code> subscript:</p>

<pre data-type="programlisting" class="calibre28">let whatname = p[keyPath:prop]</pre>

<p class="author1">If <code class="calibre19">p</code> is a Person with a <code class="calibre19">firstName</code> of <code class="calibre19">"Matt"</code> and a <code class="calibre19">lastName</code> of <code class="calibre19">"Neuburg"</code>, then <code class="calibre19">whatname</code> is now <code class="calibre19">"Matt"</code>. Moreover, <code class="calibre19">whatname</code> is inferred to be a String, because the key path carries within itself information about the type of the property that it refers to (it is a generic).</p>

<p class="author1">Now imagine substituting a different key path for the value of <code class="calibre19">prop</code>:</p>

<pre data-type="programlisting" class="calibre28">var prop = \Person.firstName
// ... time passes ...
prop = \.lastName // inferred as \Person.lastName</pre>

<p class="author1">That substitution is legal, because both <code class="calibre19">firstName</code> and <code class="calibre19">lastName</code> are Strings. Instantly, throughout our program, all occurrences of the Person <code class="calibre19">[keyPath:prop]</code> subscript take on a new meaning!</p>

<p class="author1">If the property referenced by a key path is writable and you have a writable object reference, then you can also set <em class="calibre11">into</em> the <code class="calibre19">keyPath:</code> subscript on that object, thus changing the value of the property:</p>

<pre data-type="programlisting" class="calibre28">p[keyPath:prop] = "Ethan"</pre>

<p class="author1">Hereâ€™s a practical example where my own code takes advantage of key paths. One of my apps is a version of a well-known game involving a deck of 81 cards, where every card has four attributes (color, number, shape, and fill), each of which can have three possible values. (81 is 3<sup class="calibre45">4</sup>.) The userâ€™s job is to spot three cards obeying the following rule: each attribute has either the <em class="calibre11">same</em> value for <em class="calibre11">all</em> three cards or a <em class="calibre11">different</em> value for <em class="calibre11">each</em> of the three cards. The problem is to express that rule succinctly.</p>

<p class="author1">For the four card attributes, I use enums with Int raw values. This allows me to represent any attribute as a common type (Int). I express those raw values as computed properties, and I vend a list of all four computed properties as an array of key paths (<code class="calibre19">attributes</code>):</p>

<pre data-type="programlisting" class="calibre28">struct Card {
    let itsColor : Color
    let itsNumber : Number
    let itsShape : Shape
    let itsFill : Fill
    var itsColorRaw : Int { return itsColor.rawValue }
    var itsNumberRaw : Int { return itsNumber.rawValue }
    var itsShapeRaw : Int { return itsShape.rawValue }
    var itsFillRaw : Int { return itsFill.rawValue }
    static let attributes : [KeyPath&lt;Card, Int&gt;] = [
        \itsColorRaw, \itsNumberRaw, \itsShapeRaw, \itsFillRaw
    ]
    // ...
}</pre>

<p class="author1">Now I can express the rule clearly and elegantly:</p>

<pre data-type="programlisting" class="calibre28">func isValidTriple(_ cards:[Card]) -&gt; Bool {
    func evaluateOneAttribute(_ n:[Int]) -&gt; Bool {
        let allSame = (n[0] == n[1]) &amp;&amp; (n[1] == n[2])
        let allDiff = (n[0] != n[1]) &amp;&amp; (n[1] != n[2]) &amp;&amp; (n[2] != n[0])
        return allSame || allDiff
    }
    return Card.attributes.allSatisfy {attribute in
        evaluateOneAttribute(cards.map{$0[keyPath:attribute]}) // wow!
    }
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Dynamic Membership" class="calibre2"><div class="preface" id="calibre_link-2534">
<h2 class="calibre42">Dynamic Membership</h2>

<p class="author1">Dynamic membership, introduced in Swift 4.2 with additional features that are new in Swift 5, allows you to do two things:<a data-type="indexterm" data-primary="dynamic members" id="calibre_link-721" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Access a nonexistent property of an instance or type.</p>
</li>
<li class="calibre12">
<p class="calibre17">Treat a reference to an instance as the name of a nonexistent function.</p>
</li>
</ul>

<p class="author1">Before I explain how you implement dynamic membership, Iâ€™ll give an example of dynamic membership in action. I have a class Flock that acts as a gatekeeper to a dictionary. I talk to it like this:</p>

<pre data-type="programlisting" class="calibre28">let flock = Flock()
flock.chicken = "peep"
flock.partridge = "covey"
// flock's dictionary is now ["chicken": "peep", "partridge": "covey"]
if let s = flock.partridge {
    print(s) // covey
}
flock(remove:"partridge")
// flock's dictionary is now ["chicken": "peep"]</pre>

<p class="author1">Flock has no <code class="calibre19">chicken</code> property and no <code class="calibre19">partridge</code> property, and it is not the name of a function with a <code class="calibre19">remove:</code> parameter! Nevertheless the compiler permits me to talk that way, and the functionality works.</p>

<p class="author1">Having said all that, hereâ€™s how it works under the hood:<a data-type="indexterm" data-primary="properties" data-secondary="dynamic" id="calibre_link-1751" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="dynamic" id="calibre_link-1332" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Dynamic properties</dt>
<dd class="calibre16">
<p class="calibre17">The type must be marked <code class="calibre19">@dynamicMemberLookup</code>, and must declare a <code class="calibre19">subscript</code> taking a single parameter, either a string or (new in Swift 5.1) a key path, with an external name <code class="calibre19">dynamicMember</code>. The subscript return type is up to you, and you can have multiple overloads distinguished by the return type. When other code accesses a nonexistent property of this type, the corresponding subscript function &mdash; the getter or, if there is one, the setter &mdash; is called with the name of the property as parameter.</p>
</dd>
<dt class="calibre15">Dynamic functions</dt>
<dd class="calibre16">
<p class="calibre17">The type must be marked <code class="calibre19">@dynamicCallable</code>, and must declare either or both of these methods, where the type T is up to you:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">dynamicallyCall(withArguments:[T])</code></dt>
<dd class="calibre16">
<p class="calibre17">Other code uses an instance as a function name and calls it with a variadic parameter of type T. The variadic becomes an array. For example, if T is Int, and the caller says <code class="calibre19">myObject(1,2)</code>, then this method called with <code class="calibre19">[1,2]</code> as parameter.</p>
</dd>
<dt class="calibre15"><code class="calibre19">dynamicallyCall(withKeywordArguments:KeyValuePairs&lt;String, T&gt;)</code></dt>
<dd class="calibre16">
<p class="calibre17">Other code uses an instance as a function name and calls it with labeled arguments of type T. The label&ndash;value pairs become string&ndash;T pairs; if a label is missing, it becomes an empty string. For example, if T is String, and the caller says <code class="calibre19">myObject(label:"one", "two")</code>, then this method is called with <code class="calibre19">["label":"one", "":"two"]</code> as parameter.</p>
</dd>
</dl>
</dd>
</dl>

<p class="author1">So hereâ€™s the implementation of Flock. Its dynamic properties are turned into dictionary keys, and it can be called as a function with a <code class="calibre19">"remove"</code> label to remove a key:</p>

<pre data-type="programlisting" class="calibre28">@dynamicMemberLookup
@dynamicCallable
class Flock {
    var d = [String:String]()
    subscript(dynamicMember s:String) -&gt; String? {
        get { d[s] }
        set { d[s] = newValue }
    }
    func dynamicallyCall(withKeywordArguments kvs:KeyValuePairs&lt;String, String&gt;) {
        if kvs.count == 1 {
            if let (key,val) = kvs.first {
                if key == "remove" {
                    d[val] = nil
                }
            }
        }
    }
}</pre>

<p class="author1">Before Swift 5.1, dynamic membership was largely a curiosity. The compilerâ€™s validity checking is thrown away, which is opposed to the spirit of Swift; you can refer to <code class="calibre19">flock.xxx</code> even though Flock has no <code class="calibre19">xxx</code> property, or call <code class="calibre19">flock("xxx")</code> even though Flock isnâ€™t a method taking one unlabeled parameter. As originally conceived, this feature was not intended for general use; its primary purpose was to prepare Swift for future interoperability with languages like Ruby, and perhaps to permit domain-specific languages.</p>

<p class="author1">New in Swift 5.1, however, <code class="calibre19">@dynamicMemberLookup</code> can be used with a subscript that takes a key path. Thatâ€™s a game changer, because the validity of a given key path is checked at compile time. This feature is good particularly for forwarding messages to a wrapped value. For example, hereâ€™s a Kennel struct that wraps a Dog:</p>

<pre data-type="programlisting" class="calibre28">struct Dog {
    let name : String
    func bark() { print("woof") }
}
@dynamicMemberLookup
struct Kennel {
    let dog : Dog
    subscript(dynamicMember kp:KeyPath&lt;Dog,String&gt;) -&gt; String {
        self.dog[keyPath:kp]
    }
}</pre>

<p class="author1">If <code class="calibre19">k</code> is a Kennel instance, we can now fetch <code class="calibre19">k.name</code> as a way of fetching <code class="calibre19">k.dog.name</code>. And this will work just as well, obviously, if Kennelâ€™s <code class="calibre19">dog</code> property is private. An attempt to say <code class="calibre19">k.nickname</code>, however, wonâ€™t compile; key paths maintain validity checking. (Unfortunately thereâ€™s no analog for methods &mdash; you canâ€™t say <code class="calibre19">k.bark()</code> and have it automatically forwarded to a wrapped Dogâ€™s <code class="calibre19">bark</code> method.)</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Property Wrappers" class="calibre2"><div class="preface" id="calibre_link-2535">
<h2 class="calibre42">Property Wrappers</h2>

<p class="author1">The idea of property wrappers, as youâ€™ll recall from <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>, is that commonly used computed property getter and setter patterns can be encapsulated into a type with a <code class="calibre19">wrappedValue</code> computed property:<a data-type="indexterm" data-primary="wrappers, property" id="calibre_link-2373" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="property wrappers" id="calibre_link-1784" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="computed" data-tertiary="property wrappers" id="calibre_link-1749" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@propertyWrapper struct MyWrapper {
    // ...
    var wrappedValue : SomeType {
        get { /*...*/ }
        set { /*...*/ }
    }
}</pre>

<p class="author1">You can then declare your computed property using the property wrapper type name as a custom attribute:</p>

<pre data-type="programlisting" class="calibre28">@MyWrapper var myProperty : SomeType</pre>

<p class="author1">The result is that, behind the scenes, a MyWrapper instance is created for you, and when your code gets or sets the value of <code class="calibre19">myProperty</code>, it is the getter or setter of this MyWrapper instance that is called.</p>

<p class="author1">In real life, your property wrapperâ€™s purpose will almost certainly be to act as a faÃ§ade for access to a stored instance property, declared inside the property wrapperâ€™s type. This alone makes the property wrapper worth the price of admission, because now your main code is not cluttered with private stored properties acting as the backing store for computed properties; the stored properties are hidden in the property wrapper instances.</p>

<p class="author1">To introduce property wrapper syntax, Iâ€™ll start with a property wrapper that acts as a faÃ§ade for storage, and no more:</p>

<pre data-type="programlisting" class="calibre28">@propertyWrapper struct Facade&lt;T&gt; {
    private var _p : T
    init(initialValue:T) {self._p = initialValue}
    var wrappedValue : T {
        get {
            return self._p
        }
        set {
            self._p = newValue
        }
    }
}</pre>

<p class="author1">Thatâ€™s a fairly normal-looking struct. Itâ€™s a generic so that our property declaration can be of any type. The only special feature here is the initializer. The rule is that if you declare an <code class="calibre19">init(initialValue:)</code> initializer, it will be called automatically with the value to which the property is initialized:</p>

<pre data-type="programlisting" class="calibre28">@Facade var p : String = "test"</pre>

<p class="author1">Here, the property wrapperâ€™s generic is resolved to String, and its <code class="calibre19">init(initialValue:)</code> initializer is called with parameter <code class="calibre19">"test"</code>. You can call other initializers instead, by treating the custom attribute name as a type name (which, of course, is just what it is) and putting parentheses after it. Suppose our property wrapper declares an initializer with no external parameter name:</p>

<pre data-type="programlisting" class="calibre28">init(_ val:T) {self._p = val}</pre>

<p class="author1">Then we can call that initializer by declaring our property like this:</p>

<pre data-type="programlisting" class="calibre28">@Facade("test") var p : String</pre>

<p class="author1">More practically, hereâ€™s a generalized version of our Clamped property wrapper; we accept any Comparable type (so that <code class="calibre19">min</code> and <code class="calibre19">max</code> are available), and we accept (and require) initialization with a minimum and maximum to clamp to:</p>

<pre data-type="programlisting" class="calibre28">@propertyWrapper struct Clamped&lt;T:Comparable&gt; {
    private var _i : T
    private let min : T
    private let max : T
    init(initialValue: T, min:T, max:T) {
        self._i = initial
        self.min = min
        self.max = max
    }
    var wrappedValue : T {
        get {
            self._i
        }
        set {
            self._i = Swift.max(Swift.min(newValue,self.max),self.min)
        }
    }
}</pre>

<p class="author1">And hereâ€™s how to use it:</p>

<pre data-type="programlisting" class="calibre28">@Clamped(min:-7, max:7) var i : Int = 0
@Clamped(initialValue:0, min:-7, max:7) var ii : Int</pre>

<p class="author1">Those declarations are equivalent, but obviously the first one is more natural; behind the scenes, the value with which we initialize the property is routed to the <code class="calibre19">initialValue:</code> parameter of the property wrapper initializer.</p>

<p class="author1">As Iâ€™ve said, when you declare a property with a property wrapper attribute, an actual property wrapper instance is generated. That instance is accessible to our code under the same name as the computed property with underscore (<code class="calibre19">_</code>) prefixed to it. For example, in the case of our <code class="calibre19">@Facade</code> property <code class="calibre19">p</code>, if we set <code class="calibre19">p</code> to <code class="calibre19">"howdy"</code> and then say <code class="calibre19">print(_p)</code>, the console says <code class="calibre19">Facade&lt;String&gt;(_p: "howdy")</code>. You might use this feature for debugging, or to expose additional public members of the struct. This underscore-prefixed variable is declared with <code class="calibre19">var</code>, so you can even assign to it a property wrapper instance that youâ€™ve initialized manually.</p>

<p class="author1">The property wrapper may also vend a value that can be referred to elsewhere by prefixing a dollar sign (<code class="calibre19">$</code>) to the property name. It does this by declaring a <code class="calibre19">projectedValue</code> property (this will usually be a computed property). You might use this to vend some useful secondary object. Thatâ€™s how the SwiftUI <code class="calibre19">@State</code> attribute works. It is a property wrapper (one of several that are commonly used in SwiftUI). The State property wrapper struct has a <code class="calibre19">projectedValue</code> computed property whose getter returns the State structâ€™s <code class="calibre19">binding</code> property. That property is a Binding, so when you use your <code class="calibre19">@State</code> propertyâ€™s <code class="calibre19">$</code> name, you get a Binding (see xref:chap_id13).<a data-type="indexterm" data-primary="dollar sign" id="calibre_link-701" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="SwiftUI" id="calibre_link-2175" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="State" id="calibre_link-2065" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Be careful not cause a name clash! If you declare a <code class="calibre19">@Facade</code> property <code class="calibre19">p</code>, you canâ€™t declare a property <code class="calibre19">_p</code> in the same scope, because thatâ€™s the name of synthesized property wrapper instance. (The same issue does not arise for the <code class="calibre19">$</code> name, because a variable name canâ€™t start with <code class="calibre19">$</code>.)</p>
</div>

<p class="author1">Property wrappers are a brilliant addition to Swift, and can be of practical value immediately. For instance, Iâ€™ve pointed out already that deferred initialization of an instance property using an Optional (<a data-type="xref" href="#calibre_link-71" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œDeferred initialization of propertiesâ€</a>) entails an architectural flaw: the property must be declared with <code class="calibre19">var</code>. Property wrappers canâ€™t change that, but they can prevent further assignment at runtime:</p>

<pre data-type="programlisting" class="calibre28">@propertyWrapper struct DeferredConstant&lt;T&gt; {
    private var _value: T? = nil
    var wrappedValue: T {
        get {
            if _value == nil {
                fatalError("not yet initialized")
            }
            return _value!
        }
        set {
            if _value == nil {
                _value = newValue
            }
        }
    }
}</pre>

<p class="author1">Suppose we now declare an outlet as a DeferredConstant:</p>

<pre data-type="programlisting" class="calibre28">@IBOutlet @DeferredConstant var myButton: UIButton!</pre>

<p class="author1">The result is that after a real button from the interface is assigned to <code class="calibre19">myButton</code>, subsequent code that tries to assign a different value to <code class="calibre19">myButton</code> will fail silently.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Despite the name, property wrappers can be applied to global variables. They cannot be applied to local variables, but this may become possible in the future.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Custom String Interpolation" class="calibre2"><div class="preface" id="calibre_link-2536">
<h2 class="calibre42">Custom String Interpolation</h2>

<p class="author1">New in Swift 5, string interpolation syntax can be customized. The example I imagined in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a> is an expression such as <code class="calibre19">"You have \(n, roman:true) widgets"</code>, where <code class="calibre19">n</code> is an Int; the idea is that, if <code class="calibre19">n</code> is 5, this would yield <code class="calibre19">"You have V widgets"</code>, expressing the Int in Roman numerals instead of Arabic notation. This would be an odd goal to accomplish through string interpolation, but it demonstrates the syntax; so letâ€™s implement that example.<a data-type="indexterm" data-primary="strings" data-secondary="interpolation" data-tertiary="custom" id="calibre_link-2103" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="interpolation, string" data-secondary="custom" id="calibre_link-1155" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To implement string interpolation, you need an adopter of the ExpressibleByStringLiteral protocol that also adopts the ExpressibleByStringInterpolation protocol. This might be some custom type of your own, but in most situations youâ€™ll just use the built-in type that already adopts both of these protocols &mdash; String. <code class="calibre19">"You have \(n, roman:true) widgets"</code> is a String, and it already implements string interpolation.</p>

<p class="author1">That makes our job easy: all we have to do is customize Stringâ€™s already existing implementation of string interpolation. That implementation hinges on two methods, <code class="calibre19">appendInterpolation</code> and <code class="calibre19">appendLiteral</code>. The overall string is broken into segments, the interpolations (<code class="calibre19">appendInterpolation</code>) and the other parts (<code class="calibre19">appendLiteral</code>), and those methods are called; our job is to assemble them into a single object. String is already doing that job, and we donâ€™t need to modify the way it implements <code class="calibre19">appendLiteral</code>; we just need to modify the way it implements <code class="calibre19">appendInterpolation</code>.</p>

<p class="author1">To help us do that, thereâ€™s another protocol, DefaultStringInterpolation. We extend this protocol to inject a version of <code class="calibre19">appendInterpolation</code> that takes our interpolated type &mdash; in this case, Int &mdash; along with any additional parameters. Our implementation should perform any necessary transformations to get a String, and then call the default <code class="calibre19">appendInterpolation(_:)</code>.</p>

<p class="author1">Hereâ€™s an Int method <code class="calibre19">toRoman()</code> that yields an Optional String (Int values of 0 or less would return <code class="calibre19">nil</code>, to indicate that they canâ€™t be expressed in Roman numerals):</p>

<pre data-type="programlisting" class="calibre28">extension Int {
    func toRoman() -&gt; String? {
        guard self &gt; 0 else { return nil }
        let rom = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        let ar = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        var result = ""
        var cur = self
        for (c, num) in zip(rom, ar) {
            let div = cur / num
            if (div &gt; 0) {
                for _ in 0..&lt;div { result += c }
                cur -= num * div
            }
        }
        return result
    }
}</pre>

<p class="author1">Our interpolated type is Int, and we want to add one parameter, <code class="calibre19">roman:</code>, a Bool. So our extension of DefaultStringInterpolation will inject an implementation of <code class="calibre19">appendInterpolation</code> like this:</p>

<pre data-type="programlisting" class="calibre28">extension DefaultStringInterpolation {
    mutating func appendInterpolation(_ i: Int, roman: Bool) {
        if roman {
            if let r = i.toRoman() {
                self.appendInterpolation(r)
                return
            }
        }
        self.appendInterpolation(i)
    }
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Reverse Generics" class="calibre2"><div class="preface" id="calibre_link-2537">
<h2 class="calibre42">Reverse Generics</h2>

<p class="author1">New in Swift 5.1 and iOS 13, a function return type can be specified as a subtype of some supertype without stating <em class="calibre11">what</em> subtype it is. The syntax is the keyword <code class="calibre19">some</code> followed by the supertype. Suppose we have a protocol P and a struct S that adopts it:<a data-type="indexterm" data-primary="some" id="calibre_link-2043" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="generics" data-secondary="reverse" id="calibre_link-962" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="opaque types" id="calibre_link-1555" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="reverse generics" id="calibre_link-1936" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type" data-secondary="opaque" id="calibre_link-2240" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol P {}
struct S : P {}</pre>

<p class="author1">Then we can declare a function that returns a P adopter without specifying what adopter it is, by saying <code class="calibre19">some P</code>:</p>

<pre data-type="programlisting" class="calibre28">func f() -&gt; some P {
    return S()
}</pre>

<p class="author1">A computed property getter (or a subscript getter) is a function, so a computed property can also be declared a <code class="calibre19">some P</code>:</p>

<pre data-type="programlisting" class="calibre28">var p : some P { S() }</pre>

<p class="author1">A stored variable cannot be declared a <code class="calibre19">some P</code> explicitly, but it can be a <code class="calibre19">some P</code> by inference:</p>

<pre data-type="programlisting" class="calibre28">var p2 = f() // now p2 is typed as some P</pre>

<p class="author1">In those examples, the type <em class="calibre11">actually</em> being returned is S &mdash; and the compiler knows this by inference. But users of <code class="calibre19">f</code> and <code class="calibre19">p</code> know only that the type is an unspecified adopter of P. For this reason, this is sometimes called a <em class="calibre11">reverse generic</em> (or an <em class="calibre11">opaque type</em>). Instead of you declaring a placeholder and helping the compiler resolve it, the compiler has already resolved it and hides that resolution behind the placeholder.</p>

<p class="author1">A reverse generic <code class="calibre19">some P</code> is different from declaring the returned type as P. For one thing, in some situations you <em class="calibre11">canâ€™t</em> declare the returned type as P &mdash; when, for example, P is a generic protocol. (A generic protocol, you remember, can be used only as a type constraint.) But more important, if <code class="calibre19">f</code> declared its return type as P, then it could return <em class="calibre11">any</em> P adopter on any occasion. Thatâ€™s not the case with <code class="calibre19">some P</code>; <code class="calibre19">f</code> returns an S and can return <em class="calibre11">only</em> an S. The compiler uses strict typing to enforce this &mdash; but the external declaration hides what exactly the compiler is enforcing. If there are two P adopters, S and S2, then a <code class="calibre19">some P</code> resolved to S has the same underlying type as another <code class="calibre19">some P</code> resolved to S, but it does not have the same type as a <code class="calibre19">some P</code> resolved to S2. This should remind you of a regular generic: an <code class="calibre19">Optional&lt;String&gt;</code> is a different type from an <code class="calibre19">Optional&lt;Int&gt;</code>.</p>

<p class="author1">As a result, a <code class="calibre19">some</code> type plays well with a generic in a way that an ordinary supertype would not. Suppose we have a Named protocol and an adopter of that protocol:</p>

<pre data-type="programlisting" class="calibre28">protocol Named {
    var name : String {get set}
}
struct Person : Named {
    var name : String
}</pre>

<p class="author1">And suppose we have a generic that uses this protocol as a type constraint:</p>

<pre data-type="programlisting" class="calibre28">func haveSameName&lt;T:Named&gt;(_ named1:T, _ named2:T) -&gt; Bool {
    return named1.name == named2.name
}</pre>

<p class="author1">Obviously, you can hand two Person objects to this generic function, because they resolve the generic placeholder T the same way:</p>

<pre data-type="programlisting" class="calibre28">let matt = Person(name: "Matt")
let ethan = Person(name: "Ethan")
let ok = haveSameName(matt,ethan) // fine</pre>

<p class="author1">But you couldnâ€™t do that with two Named objects, because they might or might not represent the same adopting type:</p>

<pre data-type="programlisting" class="calibre28">let named1 : Named = Person(name: "Matt")
let named2 : Named = Person(name: "Ethan")
let ok = haveSameName(named1, named2) // compile error</pre>

<p class="author1">Now suppose we have a function <code class="calibre19">namedMaker</code> that makes a <code class="calibre19">some Named</code> out of a String:</p>

<pre data-type="programlisting" class="calibre28">func namedMaker(_ name: String) -&gt; some Named {
    return Person(name:name)
}</pre>

<p class="author1">You, the user of <code class="calibre19">namedMaker</code>, do not necessarily know what Named adopter is produced by <code class="calibre19">namedMaker</code>. But you <em class="calibre11">do</em> know that every call to <code class="calibre19">namedMaker</code> produces the <em class="calibre11">same</em> type of Named adopter! The compiler knows this too, and it also knows <em class="calibre11">what</em> type of Named adopter <code class="calibre19">namedMaker</code> produces. Therefore you might write this, and the compiler will allow it:</p>

<pre data-type="programlisting" class="calibre28">let named1 = namedMaker("Matt")
let named2 = namedMaker("Ethan")
let ok = haveSameName(named1, named2) // fine</pre>

<p class="author1">The main place you are likely to encounter <code class="calibre19">some</code> is when using SwiftUI or some other domain-specific language or library that wants to vend specific types while masking them under some common identity. (You are less likely to use <code class="calibre19">some</code> in your own code, though I suppose it could be useful for masking types in one area of your code from visibility in another area.)<a data-type="indexterm" data-primary="SwiftUI" id="calibre_link-2176" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, in SwiftUI a Viewâ€™s <code class="calibre19">body</code> is typed as <code class="calibre19">some View</code>. You are shielded from the underlying complexities of compound view types, such as:</p>

<pre data-type="programlisting" class="calibre28">VStack&lt;TupleView&lt;(Text, HStack&lt;TupleView&lt;(Image, Image)&gt;&gt;)&gt;&gt;</pre>

<p class="author1">At the same time, the compiler knows that that <em class="calibre11">is</em> the type of this Viewâ€™s <code class="calibre19">body</code>, and therefore behind the scenes SwiftUI can reason coherently about this view.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Function Builders" class="calibre2"><div class="preface" id="calibre_link-96">
<h2 class="calibre42">Function Builders</h2>

<p class="author1">A new feature of Swift 5.1 &mdash; so new that, as of this writing, the implementation is not complete &mdash; is the ability to intercept a function passed to another function, capture its parameters and content, and transform them by way of a <em class="calibre11">function builder</em> to get a different function that is actually passed. This complex and highly specialized feature is aimed at enabling Swift to embrace domain-specific languages &mdash; the chief such language, at the moment, being SwiftUI. For example, you can say this in SwiftUI:<a data-type="indexterm" data-primary="function builders" id="calibre_link-895" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">VStack {
    Text("Hello")
    Text("World")
}</pre>

<p class="author1">That doesnâ€™t look like legal Swift, so whatâ€™s going on? Well, VStack is a type, and we are creating an instance of that type. We call an initializer to instantiate VStack. This particular initializer takes a function as its <code class="calibre19">content:</code> parameter. We could write this as <code class="calibre19">VStack(content:f)</code>, but instead we use trailing closure syntax; the curly braces embrace the body of an anonymous function. This body is now handed off to a function builder, which detects its structure and transforms it into something that <em class="calibre11">is</em> legal Swift (and that creates a VStack instance consisting of two Texts). The entire look and feel of SwiftUI code rests on this mechanism.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Result" class="calibre2"><div class="preface" id="calibre_link-2538">
<h2 class="calibre42">Result</h2>

<p class="author1">A frustrating problem arises when you want to throw an error in a context where this is forbidden. To see what I mean, consider a function that does some networking:<a data-type="indexterm" data-primary="Result" id="calibre_link-1917" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="errors" data-secondary="throwing" data-tertiary="asynchronous" id="calibre_link-785" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func doSomeNetworking(completion:@escaping (Data) -&gt; ()) {
    URLSession.shared.dataTask(with: myURL) { data, _, err in
        if let data = data {
            completion(data)
        }
        if let err = err {
            throw err // compile error
        }
    }.resume()
}</pre>

<p class="author1">In <code class="calibre19">doSomeNetworking</code>, we get some data from across the Internet by calling <code class="calibre19">resume</code> on a URLSessionâ€™s <code class="calibre19">dataTask</code>, supplying an anonymous function to be called when either data arrives or we get an error. These are handed to us as separate Optional parameters: an Optional wrapping a Data (<code class="calibre19">data</code>), and an Optional wrapping an Error (<code class="calibre19">err</code>). If the data arrives, <code class="calibre19">data</code> wonâ€™t be <code class="calibre19">nil</code>, and we hand it back to whoever called <code class="calibre19">doSomeNetworking</code> by calling a <code class="calibre19">completion</code> function that takes a Data object. If thereâ€™s an error, <code class="calibre19">data</code> will be <code class="calibre19">nil</code> and <code class="calibre19">err</code> wonâ€™t be. The question is: now what? Weâ€™re not allowed to throw <code class="calibre19">err</code>; weâ€™re not in a throwing context, and thereâ€™s no place for the thrown error to percolate up to; the <code class="calibre19">dataTask</code> anonymous function isnâ€™t a <code class="calibre19">throws</code> function, and even if it were, weâ€™d be talking to the URLSession, not to the caller of <code class="calibre19">doSomeNetworking</code>.</p>

<p class="author1">One option is to respond to the error somehow right here in the anonymous function. Often, though, what weâ€™d really like to do here is to hand the error back to the caller of <code class="calibre19">doSomeNetworking</code>. In the past, the only way to do that was to give the <code class="calibre19">completion</code> function another parameter, perpetuating the separate Optional parameters that were foist upon us by Objective-C:</p>

<pre data-type="programlisting" class="calibre28">func doSomeNetworking(completion:@escaping (Data?, Error?) -&gt; ()) {
    URLSession.shared.dataTask(with: myURL) { data, _, err in
        completion(data, err)
    }
}</pre>

<p class="author1">New in Swift 5, thereâ€™s a cleaner solution &mdash; a type that expresses the notion of data-or-error in a single object. Itâ€™s a generic enum called Result, with a <code class="calibre19">success</code> case and a <code class="calibre19">failure</code> case, each of them carrying an associated value which is the data or error, respectively:</p>

<pre data-type="programlisting" class="calibre28">func doSomeNetworking(completion:@escaping (Result&lt;Data,Error&gt;) -&gt; ()) {
    URLSession.shared.dataTask(with: myURL) { data, _, err in
        if let data = data {
            completion(.success(data))
        }
        if let err = err {
            completion(.failure(err))
        }
    }
}</pre>

<p class="author1">The really cool part is that Result provides an initializer that lets us express ourselves in a much more Swifty way: we can return the data or throw the error, just as we would if we werenâ€™t in this asynchronous situation:</p>

<pre data-type="programlisting" class="calibre28">func doSomeNetworking(completion:@escaping (Result&lt;Data,Error&gt;) -&gt; ()) {
    URLSession.shared.dataTask(with: URL(string:"https://www.apple.com")!) { data, _, err in
        let result = Result&lt;Data,Error&gt; {
            if let err = err {
                throw err
            }
            return data!
        }
        completion(result)
    }
}</pre>

<p class="author1">And things work the same way at the callerâ€™s end. We call the Result objectâ€™s <code class="calibre19">get</code> method, which is a <code class="calibre19">throws</code> function. Either this gives us the data or else it throws:</p>

<pre data-type="programlisting" class="calibre28">self.doSomeNetworking { result in
    do {
        let data = try result.get()
        // do something with the data
    } catch {
        // respond to the error
    }
}</pre>

<p class="author1">That summarizes the most important aspects of the Result enum; thereâ€™s more to know, but you can explore further on your own if you need to.</p>
</div>
</section>





</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2849">
<div id="calibre_link-2980" class="calibre1"><div data-type="part" {http://www.idpf.org/2007/ops}type="part" data-pdf-bookmark="Part II. IDE" id="calibre_link-2539" class="preface">
<h1 class="calibre27"><span class="label">Part II. </span>IDE</h1>

<div class="preface">
<p class="author1">By now, youâ€™re doubtless anxious to jump in and start writing an app. To do that, you need a solid grounding in the tools youâ€™ll be using. The heart and soul of those tools can be summed up in one word: Xcode. In this part of the book we explore Xcode, the <em class="calibre11">IDE</em> (integrated development environment) in which youâ€™ll be programming iOS. Xcode is a big program, and writing an app involves coordinating a lot of pieces; this part of the book will help you become comfortable with Xcode. Along the way, weâ€™ll generate a simple working app through some hands-on tutorials.</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a> tours Xcode and explains the architecture of the <em class="calibre11">project</em>, the collection of files from which an app is generated.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a> is about nibs. A <em class="calibre11">nib</em> is a file containing a drawing of your interface. Understanding nibs &mdash; knowing how they work and how they relate to your code &mdash; is crucial to your use of Xcode and to proper development of just about any app.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-54" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;8</a> pauses to discuss the Xcode documentation and other sources of information on the API.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a> explains editing your code, testing and debugging your code, and the various steps youâ€™ll take on the way to submitting your app to the App Store. Youâ€™ll probably want to skim this chapter quickly at first, returning to it as a detailed reference later while developing and submitting an actual app.</p>
</li>
</ul>
</div>




























































</div>
</div>
</div>


<div class="calibre" id="calibre_link-2850">
<div id="calibre_link-2981" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 6. Anatomy of an Xcode Project" class="calibre2"><div class="preface" id="calibre_link-6">
<h1 class="calibre13"><span class="label">Chapter 6. </span>Anatomy of an Xcode Project</h1>


<p class="author1">Xcode is the application used to develop an iOS app. An Xcode <em class="calibre11">project</em> is the source for an app; itâ€™s the entire collection of files and settings used to construct the app.<a data-type="indexterm" data-primary="project" id="calibre_link-1730" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> To create, develop, and maintain an app, it helps to know how to manipulate and navigate an Xcode project. Youâ€™ll want to be familiar with Xcode, and youâ€™ll need to know about the nature and structure of Xcode projects and how Xcode shows them to you. Thatâ€™s the subject of this chapter.<a data-type="indexterm" data-primary="Xcode" data-seealso="nib editor" id="calibre_link-2375" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Xcode is a powerful, complex, and very large program.
Our survey will chart a safe, restricted, and essential path, focusing on aspects of Xcode that you most need to understand immediately, and resolutely ignoring everything else.</p>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">The term â€œXcodeâ€ is used in two ways. Itâ€™s the name of the application in which you edit and build your app, and itâ€™s the name of an entire suite of utilities that accompanies it; in the latter sense, Instruments and the Simulator are part of Xcode. This ambiguity should generally present little difficulty.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="New Project" class="calibre2"><div class="preface" id="calibre_link-2540">
<h1 class="calibre18">New Project</h1>

<p class="author1">Even before youâ€™ve written any code, an Xcode project is quite elaborate. To see this, letâ€™s make a new, essentially â€œemptyâ€ project; youâ€™ll find that it isnâ€™t empty at all.<a data-type="indexterm" data-primary="Empty Window example project" id="calibre_link-731" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Start up Xcode and choose File â†’ New â†’ Project.</p>
</li>
<li class="calibre4">
<p class="calibre17">The â€œChoose a templateâ€ dialog appears. The <em class="calibre11">template</em> is your projectâ€™s initial set of files and settings. When you pick a template, youâ€™re really picking an existing <span class="publishername">folder full</span> of files; this folder is hidden deep inside the Xcode bundle, and
will essentially be copied, with a few values filled in, to create your project.<a data-type="indexterm" data-primary="project" data-secondary="templates" id="calibre_link-1735" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="templates" data-secondary="project" id="calibre_link-2198" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">In this case, select iOS; under Application, select the Single View App template. Click Next.<a data-type="indexterm" data-primary="Single View App template" id="calibre_link-2034" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">You are now asked to provide a name for your project (Product Name).<a data-type="indexterm" data-primary="product name" id="calibre_link-1728" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Letâ€™s call our new project <em class="calibre11">Empty Window</em>.</p>

<p class="calibre17">As Xcode copies the template folder, itâ€™s going to insert the projectâ€™s name in several places, including using it as the name of the app. Thus, whatever you type at this moment is something youâ€™ll be seeing throughout your project. You are not locked into the name of your project forever, though, and thereâ€™s a separate setting allowing you to change the name of the app that your project produces. (Iâ€™ll talk later about name changes; see <a data-type="xref" href="#calibre_link-2563" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œRenaming Parts of a Projectâ€</a>.)</p>

<p class="calibre17">Spaces are legal in the project name, the app name, and the various names of files and folders that Xcode will generate automatically; and in the few places where spaces are problematic (such as the bundle identifier, which Iâ€™ll discuss in a moment), the name you type as the Product Name will have its spaces converted to hyphens. But do <em class="calibre11">not</em> use any other punctuation in your project name! Such punctuation can cause Xcode features to break in subtle ways.</p>
</li>
<li class="calibre4">
<p class="calibre17">Ignore the Team pop-up menu for now; Iâ€™ll discuss its significance in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>. Ignore the Organization Name as well; it is used only in some automatically generated code comments.</p>
</li>
<li class="calibre4">
<p class="calibre17">Note the Organization Identifier field.<a data-type="indexterm" data-primary="organization identifier" id="calibre_link-1633" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bundle" data-secondary="identifier" id="calibre_link-308" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The first time you create a project, this field will be blank, and you should fill it in. The goal here is to create a unique string identifying you or your organization. The convention is to start the organization identifier with <code class="calibre19">com.</code> and to follow it with a string (possibly with multiple dot-components) that no one else is likely to use. For example, I use <code class="calibre19">com.neuburg.matt</code>. Every app on a device or submitted to the App Store needs a unique bundle identifier. Your appâ€™s bundle identifier, which is shown in gray below the organization identifier, will consist by default of the organization identifier plus a version of the projectâ€™s name; if you choose a unique organization identifier and give every project a unique name within your personal world, the bundle identifier will uniquely identify this project and the app that it produces. (You will be able to change the bundle identifier manually later if necessary.)</p>
</li>
<li class="calibre4">
<p class="calibre17">The Language pop-up menu lets you choose between Swift and Objective-C. This choice is not positively binding; it dictates the initial structure and code of the project template, but you are free to add Swift files to an Objective-C project, or Objective-C files to a Swift project. You can even start with an Objective-C project and decide later to convert it completely to Swift. (See <a data-type="xref" href="#calibre_link-2734" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œBilingual Targetsâ€</a>.) For now, choose Swift.</p>
</li>
<li class="calibre4">
<p class="calibre17">For this example project, make sure Use SwiftUI, Use Core Data, Include Unit Tests, and Include UI Tests are <em class="calibre11">not</em> checked. Click Next.</p>
</li>
<li class="calibre4">
<p class="calibre17">Youâ€™ve now told Xcode how to construct your project. Basically, itâ€™s going to copy a template folder from somewhere deep within the Xcode application bundle. But you need to tell it where to copy this template folder <em class="calibre11">to</em>. Thatâ€™s why Xcode is now presenting a Save dialog with a Create button. You are to specify the location of a folder that is about to be created &mdash; the <em class="calibre11">project folder</em> for this project. The project folder can go just about anywhere, and you can move it after creating it. I usually create new projects on the Desktop.</p>
</li>
<li class="calibre4">
<p class="calibre17">Xcode also offers, through a checkbox, to create a git repository for your project. (You might need to click Options to see the checkbox.) In real life, this can be a great convenience (see <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>), but for now, uncheck that checkbox. If you see an Add To pop-up menu, leave it at the default, â€œDonâ€™t add to any project or workspace.â€ Click Create.</p>

<p class="calibre17">The <em class="calibre11">Empty Window</em> project folder is created on disk (on the Desktop, if thatâ€™s the location you just specified), and the project window for the Empty Window project opens in Xcode.</p>
</li>

</ol>

<p class="author1">The project weâ€™ve just created is a working project; it really does build an iOS app called Empty Window. To see this, you can actually build the app &mdash; and run it! The scheme and destination in the project windowâ€™s toolbar might be listed as Empty Window â†’ iPhone X or Empty Window â†’ iPhone 8 Plus; thatâ€™s fine. (The scheme and destination are actually pop-up menus, so you can click them to change their values if needed.) Choose Product â†’ Run. After some delay, the Simulator application eventually opens and displays your app running &mdash; an empty white screen.</p>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">To <em class="calibre11">build</em> a project is to compile its code and assemble the compiled code, together with various resources, into the actual app.<a data-type="indexterm" data-primary="build" id="calibre_link-301" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="run" id="calibre_link-1941" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Typically, if you want to know whether your code compiles and your project is consistently and correctly constructed, youâ€™ll build the project (Product â†’ Build).
To <em class="calibre11">run</em> a project is to launch the built app, in the Simulator or on a connected device; if you want to know whether your code works as expected, youâ€™ll run the project (Product â†’ Run), which automatically builds first if necessary.</p>
</div>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Project Window" class="calibre2"><div class="preface" id="calibre_link-2541">
<h1 class="calibre18">The Project Window</h1>

<p class="author1">An Xcode project embodies a lot of information about what files constitute the project and how they are to be used when building the app, such as:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The source files (your code) that are to be compiled</p>
</li>
<li class="calibre12">
<p class="calibre17">Any <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> files, graphically expressing interface objects to be instantiated as your app runs</p>
</li>
<li class="calibre12">
<p class="calibre17">Any resources, such as icons, images, or sound files, that are to be part of the app</p>
</li>
<li class="calibre12">
<p class="calibre17">All settings (instructions to the compiler, to the linker, and so on) that are to be obeyed as the app is built</p>
</li>
<li class="calibre12">
<p class="calibre17">Any frameworks that the code will need when it runs</p>
</li>
</ul>

<p class="author1">A single Xcode project window presents all of this information, lets you access, edit, and navigate your code, and reports the progress and results of such procedures as building or debugging an app and more. This window displays a lot of information and embodies a lot of functionality! A project window is powerful and elaborate; learning to navigate and understand it takes time. Letâ€™s pause to explore this window and see how it is constructed.<a data-type="indexterm" data-primary="project" data-secondary="window" id="calibre_link-1737" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A project window has four main parts (<a data-type="xref" href="#calibre_link-2851" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-1</a>):</p>

<figure class="calibre32"><div id="calibre_link-2851" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-1. </span>The project window</h6>
</div>
</figure>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">On the left is the Navigator pane. Show and hide it with View â†’ Navigators â†’ Show/Hide Navigator (Command-0) or with the first View button at the right end of the toolbar.</p>
</li>
<li class="calibre4">
<p class="calibre17">In the middle is the Editor pane (or simply â€œeditorâ€). This is the main area of a project window. A project window nearly always displays an Editor pane.</p>
</li>
<li class="calibre4">
<p class="calibre17">On the right is the Utilities pane. Show and hide it with View â†’ Utilities â†’ Show/Hide Utilities (Command-Option-0) or with the third View button at the right end of the toolbar.</p>
</li>
<li class="calibre4">
<p class="calibre17">At the bottom is the Debug pane. Show and hide it with View â†’ Debug Area â†’ Show/Hide Debug Area (Command-Shift-Y) or with the second View button at the right end of the toolbar.</p>
</li>

</ol>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">All Xcode keyboard shortcuts can be customized; see the Key Bindings pane of the Preferences window. Keyboard shortcuts that I cite are the defaults.<a data-type="indexterm" data-primary="keyboard shortcuts in Xcode" id="calibre_link-1187" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Key Bindings preferences" id="calibre_link-1184" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>








<section data-type="sect2" data-pdf-bookmark="The Navigator Pane" class="calibre2"><div class="preface" id="calibre_link-2542">
<h2 class="calibre42">The Navigator Pane</h2>

<p class="author1">The Navigator pane is the column of information at the left of the project window. Among other things, itâ€™s your primary mechanism for controlling what you see in the main area of the project window (the editor). An important use pattern for Xcode is: you select something in the Navigator pane, and that thing is displayed in the editor.</p>

<p class="author1">It is possible to toggle the visibility of the Navigator pane (View â†’ Navigators â†’ Hide/Show Navigator, or Command-0);
you might hide the Navigator pane temporarily to maximize your screen real estate (especially on a smaller monitor). You can change the Navigator paneâ€™s width by dragging the vertical line at its right edge.<a data-type="indexterm" data-primary="Navigator pane" id="calibre_link-1383" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The Navigator pane can display nine different sets of information; thus, there are actually nine navigators. These are represented by the nine icons across its top; to switch among them, use these icons or their keyboard shortcuts (Command-1, Command-2, and so on). If the Navigator pane is hidden, pressing a navigatorâ€™s keyboard shortcut both shows the Navigator pane and switches to that navigator.</p>

<p class="author1">Depending on your settings in the Behaviors pane of Xcodeâ€™s preferences, a navigator might show itself automatically when you perform a certain action. For example, by default, when you build your project, if warning messages or error messages are generated, the Issue navigator may appear. This automatic behavior will not prove troublesome, because it is usually the behavior you want, and if it isnâ€™t, you can change it; plus you can easily switch to a different navigator at any time.<a data-type="indexterm" data-primary="Behaviors preferences" id="calibre_link-246" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Letâ€™s begin experimenting immediately with the various navigators:</p>
<dl class="calibre14">
<dt class="calibre15">Project navigator (Command-1)</dt>
<dd class="calibre16">
<p class="calibre17">Click here for basic navigation through the files that constitute your project (<a data-type="xref" href="#calibre_link-2852" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-2</a>). For example, in the Empty Window folder (the folder-like things in the Project navigator are actually called <em class="calibre11">groups</em>), click <em class="calibre11">AppDelegate.swift</em> to view its code in the editor.<a data-type="indexterm" data-primary="Project navigator" id="calibre_link-1738" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="groups" id="calibre_link-985" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">At the top level of the Project navigator, with a blue Xcode icon, is the Empty Window project itself; click it to view the settings associated with your project and its targets. Donâ€™t change anything here without knowing what youâ€™re doing!</p>

<p class="calibre17">The filter bar at the bottom of the Project navigator lets you limit what files are shown; when there are many files, this is great for quickly reaching a file with a known name. For example, try typing â€œdelegateâ€ in the filter bar search field. Donâ€™t forget to remove your filter when youâ€™re done experimenting.</p>
</dd>
</dl>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Once youâ€™ve filtered a navigator, it stays filtered until you remove the filter &mdash; even if you close the project! A common mistake is to filter a navigator, forget that youâ€™ve done so, fail to notice the filter (because youâ€™re looking at the navigator itself, not down at the bottom where the filter bar is), and wonder, â€œHey, where did all my files go?â€</p>
</div>

<figure class="calibre32"><div id="calibre_link-2852" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-2. </span>The Project navigator</h6>
</div>
</figure>
<dl class="calibre14">
<dt class="calibre15">Source Control navigator (Command-2)</dt>
<dd class="calibre16">
<p class="calibre17">The Source Control navigator helps you manipulate how your projectâ€™s files are handled through version control. Iâ€™ll discuss version control in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>.<a data-type="indexterm" data-primary="Source Control navigator" id="calibre_link-2047" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Symbol navigator (Command-3)</dt>
<dd class="calibre16">
<p class="calibre17">A <em class="calibre11">symbol</em> is a name, typically the name of a class or method. The Symbol navigator lists symbols available to your code. Among other things, this can be useful for navigating. For example, highlight the first two icons in the filter bar (the first two are blue, the third is dark), twist open the class listings, and see how quickly you can reach your codeâ€™s implementation of SceneDelegateâ€™s <code class="calibre19">sceneDidBecomeActive(_:)</code> method.<a data-type="indexterm" data-primary="Symbol navigator" id="calibre_link-2184" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">Try highlighting the filter bar icons in various ways to see how the contents of the Symbol navigator change. Type in the search field in the filter bar to limit what appears in the Symbol navigator; for example, try typing â€œactiveâ€ in the search field, and see what happens.</p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Find navigator (Command-4)</dt>
<dd class="calibre16">
<p class="calibre17">This is a powerful search facility for finding text globally in your project. You can also summon the Find navigator with Find â†’ Find in Project (Command-Shift-F). The words above the search field show what options are currently in force; they are pop-up menus, so click one to change the options. Try searching for â€œdelegateâ€ (<a data-type="xref" href="#calibre_link-2853" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-3</a>). Click a search result to jump to it in your code.<a data-type="indexterm" data-primary="Find navigator" id="calibre_link-859" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">Below the search field, at the left, is the current <em class="calibre11">search scope</em>. This limits what files will be searched. Click it to reveal the search scopes. You can create or edit a â€œsmartâ€ scope (for example, search only <em class="calibre11">.swift</em> files), and you can limit the search to one or more groups (folders).</p>

<p class="calibre17">You can type in the other search field, the one in the filter bar at the bottom, to limit further which search results are displayed. (Iâ€™m going to stop calling your attention to the filter bar now; every navigator has it in some form.)</p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-2853" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-3. </span>The Find navigator</h6>
</div>
</figure>
<dl class="calibre14">
<dt class="calibre15">Issue navigator (Command-5)</dt>
<dd class="calibre16">
<p class="calibre17">Youâ€™ll need this navigator primarily when your code has issues. This doesnâ€™t refer to emotional instability; itâ€™s Xcodeâ€™s term for warning and error messages emitted when you build your project.<a data-type="indexterm" data-primary="Issue navigator" id="calibre_link-1167" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The Issue navigator can also display certain runtime issues (such as leaks, as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>).</p>

<p class="calibre17">To see the Issue navigator in action, letâ€™s give your code a buildtime issue. Navigate
to the file <em class="calibre11">AppDelegate.swift</em>, and in the blank line after the last comment at the top of the fileâ€™s contents, above the <code class="calibre19">import</code> line, type <code class="calibre19">howdy</code>. Build the project (Command-B). Switch to the Issue navigator if it doesnâ€™t appear automatically; in its Buildtime pane, it displays some error messages, showing that the compiler is unable to cope with this illegal word appearing in an illegal place. Click an issue to see it within its file. In your code, issue â€œballoonsâ€ may appear to the right of lines containing issues.</p>

<p class="calibre17">Now that youâ€™ve made Xcode miserable, select â€œhowdyâ€ and delete it; save and build again, and your issues will be gone. If only real life were this easy!</p>

<p class="calibre17">(Starting in Swift 4.2, you can create a custom buildtime issue, either a compile error or a warning, by starting a line with <code class="calibre19">#error</code> or <code class="calibre19">#warning</code> respectively followed by a string literal in parentheses, like this: <code class="calibre19">#warning("Fix this!")</code>. This can be a dramatic way to leave a note to whoever subsequently tries to compile this code &mdash; possibly your future self.)</p>
</dd>
<dt class="calibre15">Test navigator (Command-6)</dt>
<dd class="calibre16">
<p class="calibre17">This navigator lists test files and individual test methods and permits you to run your tests and see whether they succeeded. A test is code that isnâ€™t part of your app; rather, it calls a bit of your appâ€™s code, or exercises your appâ€™s interface, to see whether things behave as expected. Iâ€™ll talk more about tests in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>.<a data-type="indexterm" data-primary="Test navigator" id="calibre_link-2203" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Debug navigator (Command-7)</dt>
<dd class="calibre16">
<p class="calibre17">By default, this navigator will appear when your code is paused while youâ€™re debugging it. There is not a strong distinction in Xcode between running and debugging; the milieu is the same. The difference is mostly a matter of whether breakpoints are obeyed (more about that, and about debugging in general, in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>).<a data-type="indexterm" data-primary="Debug navigator" id="calibre_link-609" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">To see the Debug navigator in action, youâ€™ll need to give your code a breakpoint. Navigate once more to the file <em class="calibre11">AppDelegate.swift</em>, select in the line that says <code class="calibre19">return true</code>, and choose Debug â†’ Breakpoints â†’ Add Breakpoint at Current Line to make a blue breakpoint arrow appear on that line. Run the project. By default, as the breakpoint is encountered, the Navigator pane switches to the Debug navigator, and the Debug pane appears at the bottom of the window. This overall layout (<a data-type="xref" href="#calibre_link-2854" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-4</a>) will rapidly become familiar as you debug your projects.</p>

<figure class="calibre32"><div id="calibre_link-2854" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-4. </span>The Debug layout</h6>
</div>
</figure>

<p class="calibre17">The Debug navigator starts with several numeric and graphical displays of profiling information (at a minimum, youâ€™ll see CPU, Memory, Disk, and Network); click one to see extensive graphical information in the editor. This information allows you to track possible misbehavior of your app as you run it, without the added complexity of running the Instruments utility (discussed in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>). To toggle the visibility of the profiling <span class="publishername">information</span> at the top of the Debug navigator, click the â€œgaugeâ€ icon (to the right of the processâ€™s name).<a data-type="indexterm" data-primary="gauges" id="calibre_link-942" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">The Debug navigator also displays the call stack<a data-type="indexterm" data-primary="call stack" id="calibre_link-328" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, with the names of the nested methods in which a pause occurs; as you would expect, you can click a method name to navigate to it. You can shorten or lengthen the list with the first button in the filter bar at the bottom of the navigator.<a data-type="indexterm" data-primary="stack, call" id="calibre_link-2059" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">The Debug pane, which can be shown or hidden at will (View â†’ Debug Area â†’ Hide/Show Debug Area, or Command-Shift-Y), has at its top the <em class="calibre11">debug bar</em> containing various buttons, and consists of two subpanes:<a data-type="indexterm" data-primary="Debug pane" id="calibre_link-612" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="debug bar" id="calibre_link-607" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div class="preface"><dl class="calibre14">
<dt class="calibre15">The variables list (on the left)</dt>
<dd class="calibre16">
<p class="calibre17">The variables in scope for the selected method in the call stack at the point where we are paused, along with their values.<a data-type="indexterm" data-primary="variables list" id="calibre_link-2341" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">The console (on the right)</dt>
<dd class="calibre16">
<p class="calibre17">Here the debugger displays text messages; thatâ€™s how you learn of exceptions thrown by your running app, plus you can have your code deliberately send you log messages describing your appâ€™s progress and behavior. Such messages are important, so keep an eye on the console as your app runs.<a data-type="indexterm" data-primary="console" id="calibre_link-535" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> You can also use the console to enter commands to the debugger. This can often be a better way to explore values during a pause than the variables list.</p>
</dd>
</dl>
</div>


<p class="calibre17">Either the variables list or the console can be hidden using the two buttons at the bottom right of the pane. The console can also be summoned by choosing View â†’ Debug Area â†’ Activate Console.</p>
</dd>
<dt class="calibre15">Breakpoint navigator (Command-8)</dt>
<dd class="calibre16">
<p class="calibre17">This navigator lists all your breakpoints. At the moment you have only one, but when youâ€™re actively debugging a large project with many breakpoints, youâ€™ll be glad of this navigator. Also, this is where you create special breakpoints (such as symbolic breakpoints), and in general itâ€™s your center for managing existing breakpoints. Weâ€™ll return to this topic in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>.<a data-type="indexterm" data-primary="Breakpoint navigator" id="calibre_link-274" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Report navigator (Command-9)</dt>
<dd class="calibre16">
<p class="calibre17">This navigator lists your recent major actions, such as building or running (debugging) your project. Click a listing to see (in the editor) the report generated when you performed that action. The report might contain information that isnâ€™t displayed in any other way, and also it lets you dredge up console messages from the recent past (â€œWhat was that exception I got while debugging a moment ago?â€).<a data-type="indexterm" data-primary="Report navigator" id="calibre_link-1900" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">By clicking on the listing for a successful build,
we can see the steps by which a build takes place (<a data-type="xref" href="#calibre_link-2855" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-5</a>). To reveal the full text of a step, click that step and then click the Expand Transcript button that appears at the far right (and see also the menu items in the Editor menu).</p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-2855" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-5. </span>Viewing a report</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="The Utilities Pane" class="calibre2"><div class="preface" id="calibre_link-2543">
<h2 class="calibre42">The Utilities Pane</h2>

<p class="author1">The Utilities pane is the column at the right of the project window. It contains inspectors that provide information about the current selection or its settings; if those settings can be changed, this is where you change them.
The Utilities paneâ€™s importance emerges mostly when youâ€™re editing a <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> file (<a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>). But it can be useful also while editing code, mostly because Quick Help, a form of documentation (<a data-type="xref" href="#calibre_link-54" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;8</a>), is displayed here as well. To toggle the visibility of the Utilities pane, choose View â†’ Utilities â†’ Hide/Show Utilities (Command-Option-0). You can change the Utilities paneâ€™s width by dragging the vertical line at its left edge.<a data-type="indexterm" data-primary="Utilities pane" id="calibre_link-2308" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">What appears in
the Utilities pane depends on whatâ€™s selected in the current editor. For example:</p>
<dl class="calibre14">
<dt class="calibre15">A code file is being edited</dt>
<dd class="calibre16">
<p class="calibre17">The
Utilities pane shows the File inspector, the History inspector, or Quick Help. Toggle between them with the icons at the top of
the Utilities pane, or with their keyboard shortcuts (Command-Option-1, Command-Option-2, Command-Option-3). The File inspector consists of multiple sections, each of which can be expanded or collapsed by clicking its header; Iâ€™ll give an example of using it in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a> when I talk about localization. History is about version control (<a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a> as well). Quick Help can be useful because it displays documentation (<a data-type="xref" href="#calibre_link-54" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;8</a>). <a data-type="indexterm" data-primary="File inspector" id="calibre_link-850" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Quick Help" id="calibre_link-1833" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="History inspector" id="calibre_link-1021" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">A <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> file is being edited</dt>
<dd class="calibre16">
<p class="calibre17">The
Utilities pane adds the Identity inspector (Command-Option-4), the Attributes inspector (Command-Option-5), the Size inspector (Command-Option-6), and the Connections inspector (Command-Option-7). These can consist of multiple sections, each of which can be expanded or collapsed by clicking its header. Iâ€™ll talk more about these in <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>.<a data-type="indexterm" data-primary="Identity inspector" id="calibre_link-1034" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Attributes inspector" id="calibre_link-228" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Size inspector" id="calibre_link-2037" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Connections inspector" id="calibre_link-532" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">Other forms of editing may cause other inspector combinations to appear here.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="The Editor" class="calibre2"><div class="preface" id="calibre_link-2544">
<h2 class="calibre42">The Editor</h2>

<p class="author1">In the middle of the project window is the <em class="calibre11">editor</em>.<a data-type="indexterm" data-primary="editor" id="calibre_link-728" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This is where you get actual work done, reading and writing your code (<a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>) or designing your interface in a <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> file (<a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>). The editor is the core of the project window. You can hide the Navigator pane, the Utilities pane, and the Debug pane, but there is basically no such thing as a project window without an editor.</p>

<p class="author1">The <em class="calibre11">jump bar</em> across the top<a data-type="indexterm" data-primary="jump bar" id="calibre_link-1173" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> shows you hierarchically what file is currently being edited. It also allows you to switch to a different file. Each path component in the jump bar is a pop-up menu. These pop-up menus can be summoned by clicking on a path component, or by using keyboard shortcuts (shown in the View â†’ Editor submenu). For example, Control-4 summons a hierarchical pop-up menu, which can be navigated entirely with the keyboard, allowing you to choose a different file in your project to edit. Moreover, each pop-up menu in the jump bar also has a filter field; to see it, summon a pop-up menu from the jump bar and start typing. Thus you can navigate your project even if the Project navigator isnâ€™t showing.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Command-click a jump bar component to summon a menu showing the corresponding file in the Finder and its hierarchy of enclosing folders.</p>
</div>

<p class="author1">The symbol at the left end of the jump bar (Control-1) summons a hierarchical menu called the Related Items menu. This helps you navigate to files conceptually related to the current one.<a data-type="indexterm" data-primary="Related Items menu" id="calibre_link-1886" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="jump bar" data-secondary="Related Items menu" id="calibre_link-1179" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Its contents depend on both the current file and the current selection within it.
You can navigate to related files declaring related types (Superclasses, Subclasses, Siblings, and adopted Protocols) and to methods that call or are called by the currently selected method. The Generated Interface menu displays a fileâ€™s public interface as seen by Swift or Objective-C (see <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>).</p>

<p class="author1">The editor remembers the history of what it has displayed, and you can return to previously viewed content with the Back button in the jump bar, which is also a pop-up menu (Control-2). Alternatively, choose Navigate â†’ Go Back (Command-Control-Left).</p>










<section data-type="sect3" data-pdf-bookmark="Editor panes" class="calibre2"><div class="preface" id="calibre_link-2982">
<h3 class="calibre44">Editor panes</h3>

<p class="author1">It is likely, as you develop a project, that youâ€™ll want to edit more than one file simultaneously, or obtain multiple views of a single file so that you can edit different areas of it simultaneously. New in Xcode 11, this is easier than ever before. The Editor pane area of the project window can be subdivided into smaller editor panes. Each pane can display a different file, or a different area of the same file.<a data-type="indexterm" data-primary="editor" data-secondary="panes" id="calibre_link-730" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="pane" data-secondary="editor" id="calibre_link-1660" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To summon a new editor pane, choose File â†’ New â†’ Editor (Command-Control-T) or click the Add Editor button at the top right of an editor. Alternatively, if there is only editor pane, Option-click a file listing in the Project navigator to open it in a new editor pane.</p>

<p class="author1">The new pane appears to the right of the current editor or below it; choose View â†’ Change Editor Orientation to reverse this default or to move a pane from the right to below (or <em class="calibre11">vice versa</em>). To summon a new editor pane in the other orientation, choose File â†’ New â†’ Editor Below / On Right, or Option-click the Add Editor button.</p>

<p class="author1">To close an editor pane, choose File â†’ Close Editor, or click the X button at the top left of an editor pane.</p>

<p class="author1">To zoom an editor pane temporarily, so that it takes over the whole editor area without closing any other panes, choose View â†’ Editor â†’ Focus, or click the double-arrow button at the top left of the pane. To reverse that zoom, do the same thing again: choose View â†’ Editor â†’ Hide Focus, or click the double-arrow button. You canâ€™t accidentally close a zoomed editor pane.</p>

<p class="author1">When there are multiple editor panes open, what happens when you click a file listing in the Project navigator? By default, its destination is current editor pane. But you can Option-click (or double-click) a file listing to specify a different destination; the exact details depend on your settings in the Navigation pane of Xcodeâ€™s preferences. Alternatively, Option-Shift-click a file listing to summon the destination chooser; you can then navigate with arrow keys to the desired destination, and hit Return to choose it. Words fail me to describe the destination chooser further, but itâ€™s easy to use and unbelievably cool.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Assistant panes" class="calibre2"><div class="preface" id="calibre_link-2983">
<h3 class="calibre44">Assistant panes</h3>

<p class="author1">An assistant pane is a special kind of editor pane, whose job (as the name implies) is to act in a secondary role to another editor pane, to which it is tied, and which serves as the primary pane in the pair. When you cause the primary pane to display a different file, the assistant pane <em class="calibre11">automatically</em> displays a different file to match. To summon an assistant pane, choose Editor â†’ Editor and Assistant (or choose Editor and Assistant from the Editor menu at the top right of the jump bar).<a data-type="indexterm" data-primary="pane" data-secondary="assistant" id="calibre_link-1659" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="assistant" id="calibre_link-221" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Exactly what category of file the assistant pane displays depends upon what youâ€™ve specified as its relationship to the primary pane. You do that with the first pop-menu in the assistant paneâ€™s jump bar.
The Counterparts category is probably more useful for Objective-C, letting you show a <em class="calibre11">.h</em> file in one pane and the corresponding <em class="calibre11">.m</em> file in another. If the primary pane is a nib editor, the assistantâ€™s Automatic category displays the current sceneâ€™s view controller code.</p>

<p class="author1">If the assistantâ€™s category contains more than one file &mdash; for example, youâ€™ve set the assistant to show Subclasses and the main pane displays a class with more than one subclass &mdash; then a pair of arrow buttons appears at the right end of the assistantâ€™s jump bar, with which you can navigate between them (or use the second jump bar component, Control-5).</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Tabs and Windows" class="calibre2"><div class="preface" id="calibre_link-2984">
<h3 class="calibre44">Tabs and Windows</h3>

<p class="author1">The difference between a pane, on the one hand, and a tab or window, on the other, is that the latter doesnâ€™t just display a file &mdash; it displays the whole project window interface. Thus one tab (or window) might show the Project navigator, while another tab (or window) would have the Project navigator hidden, or display a different navigator.</p>

<p class="author1">To make a new tab, choose File â†’ New â†’ Tab (Command-T), revealing the tab bar (just below the toolbar) if it wasnâ€™t showing already. Use of a tabbed interface will likely be familiar from applications such as Safari. To make a new window, choose File â†’ New â†’ Window (Command-Shift-T), or promote a tab to be a window by dragging it right out of its current window. You can also double-click (or Option-click) a file listing in the Project navigator; whether this opens a new tab or a new window depends on your settings in the Navigation pane of Xcodeâ€™s preferences.</p>

<p class="author1">Whether and how you use tabs and windows will depend on your personal tastes. Thereâ€™s a lot of power and flexibility here if you need it. For example, when I have a file I frequently want to refer to, I might spawn off a secondary window displaying that file, sized fairly small and without any panes other than the editor.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If the Project navigator selection gets out of sync with the file displayed in a editor pane, you can bring it back in sync by choosing Navigate â†’ Reveal in Project Navigator (Command-Shift-J).</p>
</div>
</div>
</section>



</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Project File and Dependents" class="calibre2"><div class="preface" id="calibre_link-2545">
<h1 class="calibre18">Project File and Dependents</h1>

<p class="author1">The first item in the Project navigator (Command-1) represents the project itself. (In the Empty Window project that we created earlier in this chapter, it is called Empty Window.) Hierarchically dependent upon it are items that contribute to the building of the project.<a data-type="indexterm" data-primary="project" data-secondary="folder" id="calibre_link-1732" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Many of the listings in the Project navigator correspond to items on disk in the project folder.</p>

<p class="author1">To survey this correspondence, letâ€™s view our Empty Window project in two ways simultaneously &mdash; in the Project navigator in the Xcode project window, and in the project folder in a Finder window. Select the project listing in the Project navigator and choose File â†’ Show in Finder. The Finder displays the contents of your project folder (<a data-type="xref" href="#calibre_link-43" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-6</a>).</p>

<figure class="calibre32"><div id="calibre_link-43" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-6. </span>The Project navigator (Xcode) and the project folder (Finder)</h6>
</div>
</figure>








<section data-type="sect2" data-pdf-bookmark="Contents of the Project Folder" class="calibre2"><div class="preface" id="calibre_link-2546">
<h2 class="calibre42">Contents of the Project Folder</h2>

<p class="author1">The most important file in the project folder is <em class="calibre11">Empty Window.xcodeproj</em>. This is the <em class="calibre11">project file</em>, corresponding to the project listed first in the Project navigator. All Xcodeâ€™s knowledge about your project &mdash; what files it consists of and how to build the project &mdash; is stored in this file. To open a project from the Finder, double-click the project file. (Alternatively, you can drag the project folder onto Xcodeâ€™s icon in the Finder, the Dock, or the application switcher; Xcode will locate the project file and open it for you.)<a data-type="indexterm" data-primary="project" data-secondary="file" id="calibre_link-1731" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="folders in an Xcode project" id="calibre_link-877" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The Project navigator displays groups (folder-like things) and files hierarchically from the project. Letâ€™s consider how these correspond to reality on disk as portrayed in the Finder (<a data-type="xref" href="#calibre_link-43" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-6</a>):</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The Empty Window group corresponds directly to the <em class="calibre11">Empty Window</em> folder on disk. Groups in the Project navigator donâ€™t necessarily correspond to folders on disk in the Finder, and folders on disk in the Finder donâ€™t necessarily correspond to groups in the Project navigator. But in this case, there is such a correspondence!</p>
</li>
<li class="calibre12">
<p class="calibre17">Files within the Empty Window group, such as <em class="calibre11">AppDelegate.swift</em>, correspond to real files on disk that are inside the <em class="calibre11">Empty Window</em> folder. If you were to create additional code files (which, in real life, you would almost certainly do in the course of developing your project), you would likely put them in the Empty Window group in the Project navigator, and they, too, would then be in the <em class="calibre11">Empty Window</em> folder on disk. (However, your files can live anywhere and your project will still work fine.)</p>
</li>
<li class="calibre12">
<p class="calibre17">Two files in the Empty Window group, <em class="calibre11">Main.storyboard</em> and <em class="calibre11">LaunchScreen.storyboard</em>, appear in the Finder inside a folder that doesnâ€™t visibly correspond to anything in the Project navigator, called <em class="calibre11">Base.lproj</em>. This arrangement has to do with <em class="calibre11">localization</em>, which Iâ€™ll discuss in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>.</p>
</li>
<li class="calibre12">
<p class="calibre17">The item <em class="calibre11">Assets.xcassets</em> in the Project navigator corresponds to a specially structured folder <em class="calibre11">Assets.xcassets</em> on disk. This is an <em class="calibre11">asset catalog</em>; you add resources to the asset catalog in Xcode, which maintains that folder on disk for you. Iâ€™ll talk more about the asset catalog later in this chapter, and in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>.</p>
</li>
<li class="calibre12">
<p class="calibre17">The Products group and its contents donâ€™t correspond to anything in the project folder. Xcode generates a reference to the executable bundle generated by building each target in your project, and by convention these references appear in the Products group.</p>
</li>
</ul>

<p class="author1">Now that you have inspected the contents of a typical project folder, you should have little need to open a project folder ever again, except in order to double-click the project file to open the project. Generally speaking, you should not manipulate the contents of a project folder by way of the Finder; manipulate the project <em class="calibre11">in the project window</em>. The project expects things in the project folder to be a certain way; if you make any alterations to the project folder directly in the Finder, behind the projectâ€™s back, you can upset those expectations and break the project. When you work in the project window, it is Xcode itself that makes any necessary changes in the project folder, and all will be well.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Groups" class="calibre2"><div class="preface" id="calibre_link-2547">
<h2 class="calibre42">Groups</h2>

<p class="author1">The purpose of groups in the Project navigator is to make the Project navigator work conveniently for you. So feel free to add further groups! For example, if some of your code files have to do with a login screen that your app sometimes presents, you might clump them together in a Login group. If your app is to contain some sound files, you might put them into a Sounds group. And so on.<a data-type="indexterm" data-primary="groups" id="calibre_link-986" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A group might or might not correspond to a folder on disk in the project folder. Thereâ€™s a visual distinction: a group that corresponds to a folder on disk is a <em class="calibre11">folder-linked group</em>, and has a solid folder icon, like the Empty Window group in <a data-type="xref" href="#calibre_link-43" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-6</a>; a group plain and simple exists purely within the Project navigator, and has a marked folder icon, like the Products group in <a data-type="xref" href="#calibre_link-43" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-6</a>. Youâ€™ll encounter this distinction at various times:<a data-type="indexterm" data-primary="groups" data-secondary="folder-linked" id="calibre_link-988" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="folder-linked group" id="calibre_link-875" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Creating a group</dt>
<dd class="calibre16">
<p class="calibre17">When you make a new group, thereâ€™s a choice of menu items; for example, in the contextual menu, you might see New Group and New Group With Folder. (Confusingly, the choice will sometimes be New Group and New Group <em class="calibre11">Without</em> Folder.) One creates a group plain and simple; the other (the one with a folder) creates a folder-linked group.</p>
</dd>
<dt class="calibre15">Using a group</dt>
<dd class="calibre16">
<p class="calibre17">When you place a file into a folder-linked group, it goes into the corresponding folder on disk (like the contents of the <em class="calibre11">Empty Window</em> folder in <a data-type="xref" href="#calibre_link-43" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-6</a>). When you place a file into a group plain and simple, itâ€™s a little unclear where it will go on disk, but generally it will be at the top level of the project folder.</p>
</dd>
<dt class="calibre15">Renaming a group</dt>
<dd class="calibre16">
<p class="calibre17">To rename a group, select it in the Project navigator and press Return to make the name editable. When you rename a folder-linked group, the folder on disk is renamed as well.</p>
</dd>
</dl>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Target" class="calibre2"><div class="preface" id="calibre_link-2548">
<h1 class="calibre18">The Target</h1>

<p class="author1">A <em class="calibre11">target</em> is a collection of parts along with rules and settings for how to build a product from those parts.<a data-type="indexterm" data-primary="target" id="calibre_link-2190" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Whenever you build, what youâ€™re building is a target (possibly more than one target).</p>

<p class="author1">Select the Empty Window project at the top of the Project navigator, and youâ€™ll see two things on the left side of the editor (<a data-type="xref" href="#calibre_link-2856" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-7</a>): the project itself, and a list of your targets. Our Empty Window project comes with one target &mdash; the <em class="calibre11">app target</em>, called Empty Window (like the project itself).<a data-type="indexterm" data-primary="app" data-secondary="target" id="calibre_link-159" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The app target is the target that you use to build and run your app. Its settings are the settings that tell Xcode how your app is to be built; its product is the app itself.</p>

<p class="author1">Under certain circumstances, you might add further targets to a project:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">You might want to add unit tests or interface tests to your project. A test bundle is a target. (Iâ€™ll talk more about testing in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>.)</p>
</li>
<li class="calibre12">
<p class="calibre17">You might write an application extension, such as a today extension (content to appear in the notification center) or a photo editing extension (custom photo editing interface to appear in the Photos app). An extension is a target.</p>
</li>
<li class="calibre12">
<p class="calibre17">You might write a library, such as a custom framework, as part of your iOS app.
A custom framework is a target. (Iâ€™ll talk more about frameworks later in this chapter.)</p>
</li>
</ul>

<p class="author1">The project name and the list of targets can appear in two ways (<a data-type="xref" href="#calibre_link-2856" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-7</a>): either as a column on the left side of the editor, or, if that column is collapsed to save space, as a pop-up menu at the top left of the editor. If, in the column or pop-up menu, you select the <em class="calibre11">project</em>, you <em class="calibre11">edit the project</em>; if you select a <em class="calibre11">target</em>, you <em class="calibre11">edit the target</em>.
<a data-type="indexterm" data-primary="editing" data-secondary="the target" id="calibre_link-726" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="editing" data-secondary="the project" id="calibre_link-725" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-2856" class="figure">
<img src="images/000006.png" alt="ios9 0607b" class="calibre54" />
<h6 class="calibre34"><span class="publishername">Figure 6-7. </span>Two ways of showing the project and targets</h6>
</div>
</figure>








<section data-type="sect2" data-pdf-bookmark="Build Phases" class="calibre2"><div class="preface" id="calibre_link-2549">
<h2 class="calibre42">Build Phases</h2>

<p class="author1">Edit the app target and click Build Phases at the top of the editor (<a data-type="xref" href="#calibre_link-2857" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-8</a>). These are the stages by which your app is built.<a data-type="indexterm" data-primary="build" data-secondary="phases" id="calibre_link-303" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The <em class="calibre11">build phases</em> are both a report to you on how the target will be built and a set of instructions to Xcode on how to build the target; if you change the build phases, you change the build process. Click each build phase to see a list of the files in your target to which that build phase will apply.</p>

<figure class="calibre32"><div id="calibre_link-2857" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-8. </span>The app targetâ€™s build phases</h6>
</div>
</figure>

<p class="author1">Two of the build phases have contents. The meanings of these build phases are pretty straightforward:</p>
<dl class="calibre14">
<dt class="calibre15">Compile Sources</dt>
<dd class="calibre16">
<p class="calibre17">Certain files (your code) are compiled, and the resulting compiled code is copied into the app.<a data-type="indexterm" data-primary="Compile Sources build phase" id="calibre_link-496" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This build phase typically applies to all of the targetâ€™s <em class="calibre11">.swift</em> files. Sure enough, it currently contains all three Swift files supplied by app template when we created the project. If you add a new Swift file to your project (typically in order to declare another class), youâ€™ll specify that it should be part of the app target, and it will be added to the Compile Sources build phase.</p>
</dd>
<dt class="calibre15">Copy Bundle Resources</dt>
<dd class="calibre16">
<p class="calibre17">Certain files are copied into the app, so that your code or the system can find them there when the app runs.<a data-type="indexterm" data-primary="Copy Bundle Resources build phase" id="calibre_link-553" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This build phase currently applies to the asset catalog; any resources you add to the asset catalog will be copied into your app as part of the catalog. It also applies to your launch storyboard file, <em class="calibre11">LaunchScreen.storyboard</em>, and your appâ€™s interface storyboard file, <em class="calibre11">Main.storyboard</em>.</p>

<p class="calibre17">Copying doesnâ€™t necessarily mean making an identical copy. Certain types of file are automatically treated in special ways as they are copied into the app bundle. Copying the asset catalog means that icons in the catalog are written out to the top level of the app bundle, and that the asset catalog itself is transformed into a <em class="calibre11">.car</em> file; copying a <em class="calibre11">.storyboard</em> file means that it is transformed into a <em class="calibre11">.storyboardc</em> file, which is itself a bundle containing nib files.</p>
</dd>
</dl>

<p class="author1">You can alter these lists manually, and sometimes you may need to do so. For instance, if something in your project, such as a sound file, is not in Copy Bundle Resources and you want it copied into the app during the build process, drag it from the Project navigator into the Copy Bundle Resources list, or (easier) click the Plus button beneath the Copy Bundle Resources list to get a helpful dialog listing everything in your project. Conversely, if something in your project is in the Copy Bundle Resources list and you <em class="calibre11">donâ€™t</em> want it copied into the app, delete it from the list; this will not delete it from your project, from the Project navigator, or from the Finder, but only from the list of things to be copied into your app.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Build Settings" class="calibre2"><div class="preface" id="calibre_link-2550">
<h2 class="calibre42">Build Settings</h2>

<p class="author1">Build phases are only one aspect of how a target knows how to build the app. The other aspect is <em class="calibre11">build settings</em>.<a data-type="indexterm" data-primary="build" data-secondary="settings" id="calibre_link-304" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> To see them, edit the target and click Build Settings at the top of the editor (<a data-type="xref" href="#calibre_link-2858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-9</a>). Here youâ€™ll find a long list of settings, most of which youâ€™ll never touch. Xcode examines this list in order to know what to do at various stages of the build process. Build settings are the reason your project compiles and builds the way it does.</p>

<figure class="calibre32"><div id="calibre_link-2858" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-9. </span>Target build settings</h6>
</div>
</figure>

<p class="author1">You can determine what build settings are displayed by clicking Basic or All. The settings are combined into categories, and you can close or open each category heading to save room. To locate a setting quickly based on something you already know about it, such as its name, use the search field at the top right to filter what settings are shown.</p>

<p class="author1">You can determine how build settings are displayed by clicking Combined or Levels; in <a data-type="xref" href="#calibre_link-2858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-9</a>, Iâ€™ve clicked Levels, in order to discuss what levels are. It turns out that not only does a <em class="calibre11">target</em> contain values for the build settings, but the <em class="calibre11">project</em> also contains values for the same build settings; furthermore, Xcode has certain built-in default build setting values. The Levels display shows all of these levels at once, so you can understand the derivation of the actual values used for every build setting.</p>

<p class="author1">To understand the chart, read from right to left. For example, the iOS default for the Build Active Architecture Only settingâ€™s Debug configuration (far right) is No. But then the project comes along (second column from the right) and sets it to Yes. The target (third column from the right) doesnâ€™t change that setting, so the result (fourth column from the right) is that the setting resolves to Yes.</p>

<p class="author1">You will rarely have occasion to manipulate build settings directly, as the defaults are usually acceptable. Nevertheless, you <em class="calibre11">can</em> change build setting values, and this is where you would do so. You can change a value at the project level or at the target level. You can select a build setting and show Quick Help in the Utilities pane to learn more about it; for further details on what the various build settings are, choose Help â†’ Xcode Help and consult the build settings reference (click Show Topics and look under Reference at the left).</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Configurations" class="calibre2"><div class="preface" id="calibre_link-2551">
<h2 class="calibre42">Configurations</h2>

<p class="author1">There are actually multiple lists of build setting values &mdash; though only one such list applies when a particular build is performed. Each such list is called a <em class="calibre11">configuration</em>.<a data-type="indexterm" data-primary="configurations" id="calibre_link-520" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="build" data-secondary="configurations" id="calibre_link-302" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Multiple configurations are needed because you build in different ways at different times for different purposes, and thus youâ€™ll want certain build settings to take on different values under different circumstances.</p>

<p class="author1">By default, there are two configurations:</p>
<dl class="calibre14">
<dt class="calibre15">Debug</dt>
<dd class="calibre16">
<p class="calibre17">This configuration is used throughout the development process, as you write and run your app.</p>
</dd>
<dt class="calibre15">Release</dt>
<dd class="calibre16">
<p class="calibre17">This configuration is used for late-stage testing, when you want to check performance on a device, and for archiving the app to be submitted to the App Store.</p>
</dd>
</dl>

<p class="author1">Configurations exist at all because the project says so. To see where the project says so, edit the project and click Info at the top of the editor (<a data-type="xref" href="#calibre_link-2859" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-10</a>). Note that these configurations are just names. You can make additional configurations, and when you do, youâ€™re just adding to the list of names. The importance of configurations emerges only when those names are coupled with build setting values. Configurations can affect build setting values both at the project level and at the target level.</p>

<figure class="calibre32"><div id="calibre_link-2859" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-10. </span>Configurations</h6>
</div>
</figure>

<p class="author1">For example, return to the target build settings (<a data-type="xref" href="#calibre_link-2858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-9</a>) and type â€œoptimâ€ into the search field. Now you can look at the Optimization Level build setting (<a data-type="xref" href="#calibre_link-2860" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-11</a>). The Debug configuration value for Optimization Level is No Optimization: while youâ€™re developing your app, you build with the Debug configuration, so your code is just compiled line by line in a straightforward way. The Release configuration value for Optimization Level is Optimize for Speed. When your app is ready to ship, you build it with the Release configuration, so the resulting binary is optimized for speed, which is great for your users running the app on a device, but would be no good while youâ€™re developing the app because breakpoints and stepping in the debugger wouldnâ€™t work properly.
Compilation may take longer when the compiler must optimize for speed, but
you wonâ€™t mind the delay, because you wonâ€™t do a Release build very often.<a data-type="indexterm" data-primary="Optimization Level build setting" id="calibre_link-1582" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-2860" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-11. </span>How configurations affect build settings</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Schemes and Destinations" class="calibre2"><div class="preface" id="calibre_link-2552">
<h2 class="calibre42">Schemes and Destinations</h2>

<p class="author1">So far, I have not said how Xcode knows <em class="calibre11">which</em> configuration to use during a particular build. This is determined by a scheme.<a data-type="indexterm" data-primary="schemes" id="calibre_link-1951" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A <em class="calibre11">scheme</em> unites a target (or multiple targets) with a build configuration, with respect to the purpose for which youâ€™re building. A new project comes by default with a single scheme, named after the project. Thus the Empty Window projectâ€™s single scheme is currently called Empty Window. To see it, choose Product â†’ Scheme â†’ Edit Scheme. The scheme editor dialog opens (<a data-type="xref" href="#calibre_link-2861" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-12</a>).</p>

<figure class="calibre32"><div id="calibre_link-2861" class="figure">
<img src="images/000031.png" alt="ios9 0612" class="calibre55" />
<h6 class="calibre34"><span class="publishername">Figure 6-12. </span>The scheme editor</h6>
</div>
</figure>

<p class="author1">On the left side of the scheme editor are listed various actions you might perform from the Product menu. Click an action to see its corresponding settings in this scheme.</p>

<p class="author1">The first action, the Build action, is different from the other actions, because it is common to all of them &mdash; the other actions all implicitly involve building. The Build action merely determines what target(s) will be built when each of the other actions is performed. For our project this means that the app target is always to be built, regardless of the action you perform.</p>

<p class="author1">The second action, the Run action, determines the settings that will be used when you build and run. The Build Configuration pop-up menu (in the Info pane) is set to Debug. That explains where the current build configuration comes from: whenever you build and run (Product â†’ Run, or click the Run button in the toolbar), youâ€™re using the Debug build configuration and the build setting values that correspond to it, because youâ€™re using this scheme, and thatâ€™s what this scheme says to do when you build and run.</p>

<p class="author1">You can edit an existing scheme, and this can be useful especially as a temporary measure for doing certain kinds of specialized debugging. For example, the Run actionâ€™s Diagnostics tab contains checkboxes that let you turn on the Address Sanitizer or the Thread Sanitizer, useful for tracking down certain types of obscure runtime error. Youâ€™d check the checkbox, build and run, work on the error, and then uncheck the checkbox again.</p>

<p class="author1">Alternatively, you can add a scheme. A typical approach is to duplicate an existing scheme and then modify the duplicate. For example, instead of changing your main scheme to turn on the Address Sanitizer temporarily, you might have a second scheme where the Address Sanitizer is always turned on. You would then use the Address Sanitizer by switching schemes.</p>

<p class="author1">Handy access to schemes and their management is through the Scheme pop-up menu in the project window toolbar (<a data-type="xref" href="#calibre_link-2862" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-13</a>).<a data-type="indexterm" data-primary="Scheme pop-up menu" id="calibre_link-1950" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-2862" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-13. </span>The Scheme pop-up menu</h6>
</div>
</figure>

<p class="author1">The Scheme pop-up menu is something youâ€™re going to be using a lot. Your schemes are listed here, and hierarchically appended to each scheme are the destinations.<a data-type="indexterm" data-primary="destinations" id="calibre_link-653" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> A <em class="calibre11">destination</em> is effectively a machine that can run your app. On any given occasion, you might want to run the app on a physical device or in the Simulator &mdash; and, if in the Simulator, you might want to specify that a particular type of device should be simulated. To make that choice, pick a destination in the Scheme pop-up menu.</p>

<p class="author1">Destinations and schemes have nothing to do with one another. The presence of destinations in the Scheme pop-up menu is just a convenience, letting you choose a scheme or a destination or both in a single move. To switch easily among destinations without changing schemes, click the destination name in the Scheme pop-up menu. To switch among schemes, possibly also determining the destination (as shown in <a data-type="xref" href="#calibre_link-2862" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-13</a>), click the scheme name in the Scheme pop-up menu.
You can open the Scheme pop-up menu with Control-0 (zero), and the Destination pop-up menu with Control-Shift-0; the menu can then be navigated with the keyboard, and is also filterable in the same way as the jump bar (discussed earlier in this chapter).</p>

<p class="author1">Each simulated device has a system version that is installed on that device. At the moment, all our simulated devices are running iOS 13; thus there is no distinction to be drawn, and the system version is not shown. But you can download additional SDKs (systems) in Xcodeâ€™s Components preference pane. If you do, and if your app can run under more than one system version, you might also see a system version listed in the Scheme pop-up menu as part of a Simulator destination name.<a data-type="indexterm" data-primary="SDKs" id="calibre_link-1963" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Components preferences" id="calibre_link-501" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To manage destinations, choose Window â†’ Devices and Simulators. This window is where you govern what simulated devices exist (switch to the Simulators pane if necessary). Here you can create, delete, and rename simulated devices, and specify whether a simulated device actually appears as a destination in the Scheme pop-up menu.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="From Project to Built App" class="calibre2"><div class="preface" id="calibre_link-2553">
<h1 class="calibre18">From Project to Built App</h1>

<p class="author1">Now that you know whatâ€™s in a project, Iâ€™m going to summarize how Xcode builds that project into an app. Letâ€™s first jump ahead and examine the end product &mdash; the app itself.</p>

<p class="author1">What <em class="calibre11">is</em> an app anyway? Itâ€™s actually a special kind of folder called a <em class="calibre11">package</em> (and a special kind of package called a <em class="calibre11">bundle</em>). The Finder normally disguises a package as a file and does not dive into it to reveal its contents to the user, but you can bypass this protection and investigate an app bundle with the Show Package Contents command. By doing so, you can study the internal structure of your built app bundle.</p>

<p class="author1">Weâ€™ll use the Empty Window app that we built earlier as a sample minimal app to investigate. Open the Products group in the Project navigator, Control-click the app listing, and choose Show in Finder.<a data-type="indexterm" data-primary="bundle" data-secondary="app" id="calibre_link-305" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="app" data-secondary="bundle" id="calibre_link-151" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
In the Finder, Control-click the Empty Window app, and choose Show Package Contents from the contextual menu. Here you can see the results of the build process (<a data-type="xref" href="#calibre_link-2863" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-14</a>).</p>

<figure class="calibre32"><div id="calibre_link-2863" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-14. </span>Contents of the app package</h6>
</div>
</figure>

<p class="author1">Think of the app bundle as a transformation of the project folder. Here are some of the things it contains, and how they relate to whatâ€™s in the project folder:</p>
<dl class="calibre14">
<dt class="calibre15"><em class="calibre11">Empty Window</em></dt>
<dd class="calibre16">
<p class="calibre17">Our appâ€™s compiled code. The build process has compiled all our Swift files into this single file, our appâ€™s binary. This is the heart of the app, its actual executable material.</p>
</dd>
<dt class="calibre15"><em class="calibre11">Main.storyboardc</em></dt>
<dd class="calibre16">
<p class="calibre17">Our appâ€™s interface storyboard file. The projectâ€™s <em class="calibre11">Main.storyboard</em> is currently where our appâ€™s interface comes from &mdash; in this case, an empty white view occupying the entire window. The build process has compiled <em class="calibre11">Main.storyboard</em>
into a tighter format, resulting in a <em class="calibre11">.storyboardc</em> file, which is actually a bundle of nib files to be loaded as required while the app runs. One of these nib files, loaded as our app launches, will be the source of the hitherto empty view displayed in the interface. <em class="calibre11">Main.storyboardc</em> sits in the same <em class="calibre11">Base.lproj</em> subfolder as <em class="calibre11">Main.storyboard</em> does in the project folder; as I said earlier, this folder structure has to do with localization (to be discussed in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>).<a data-type="indexterm" data-primary="storyboard files" data-secondary="compiled" id="calibre_link-2079" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15"><em class="calibre11">LaunchScreen.storyboardc</em></dt>
<dd class="calibre16">
<p class="calibre17">This is the compiled version of <em class="calibre11">LaunchScreen.storyboard</em>, containing the interface that will be displayed briefly during the time it takes for our app to launch (the <em class="calibre11">launch screen</em>).</p>
</dd>
<dt class="calibre15"><em class="calibre11">Assets.car</em>, <em class="calibre11">AppIcon60x60@2x.png</em></dt>
<dd class="calibre16">
<p class="calibre17">An asset catalog and an icon file. In preparation for this build, I added an icon image to the original asset catalog, <span class="publishername"><em class="calibre11">Assets.xcassets</em></span>. The build process has compiled this file, resulting in a compiled asset catalog file (<em class="calibre11">.car</em>) containing any resources that have been added to the catalog; at the same time, the icon file has been written out to the top level of the app bundle.<a data-type="indexterm" data-primary="asset catalog" data-secondary="compiled" id="calibre_link-216" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="icons" id="calibre_link-1028" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15"><em class="calibre11">Info.plist</em></dt>
<dd class="calibre16">
<p class="calibre17">A configuration file in a strict text format (a <em class="calibre11">property list</em> file). It is derived from, but is not identical to, the projectâ€™s <em class="calibre11">Info.plist</em>. It contains instructions to the system about how to treat and launch the app. For example, the projectâ€™s <em class="calibre11">Info.plist</em> has a calculated bundle name derived from the product name, <span class="publishername"><code class="calibre19">$(PRODUCT_NAME)</code></span>; in the built appâ€™s <em class="calibre11">Info.plist</em>, this calculation has been performed, and the value reads <code class="calibre19">Empty Window</code>, which is why our app is labeled â€œEmpty Windowâ€ on the device. Also, in conjunction with the asset catalog writing out our icon file to the app bundleâ€™s top level, a setting has been added to the built appâ€™s <em class="calibre11">Info.plist</em> telling the system the name of that icon file, so that the system can find it and display it as our appâ€™s icon.<a data-type="indexterm" data-primary="Info.plist" id="calibre_link-1061" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Frameworks</dt>
<dd class="calibre16">
<p class="calibre17">The built app contains no frameworks. Thatâ€™s new in Swift 5, and stands in sharp contrast to what used to happen; in the past, several megabytes of framework files were added to the app, containing the entirety of the Swift language!<a data-type="indexterm" data-primary="frameworks" data-secondary="Swift" id="calibre_link-894" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> One of the great overarching achievements of Swift 5 is <em class="calibre11">ABI stability,</em> which means, in practical terms, that the Swift frameworks can be moved off into the system, reducing the size and overhead of your built apps.<a data-type="indexterm" data-primary="ABI stability" id="calibre_link-104" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> However, thatâ€™s only on iOS 13. If you were to build this app for an earlier system, those framework files would return, and the app package would look more like <a data-type="xref" href="#calibre_link-2864" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-15</a>.</p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-2864" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-15. </span>Contents of the app package, old style</h6>
</div>
</figure>

<p class="author1">In real life, an app bundle may contain more files, but the difference will be mostly one of degree, not kind. For example, our project might have additional <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> files, additional frameworks, or additional resources such as sound files. All of these would make their way into the app bundle. Also, an app bundle built to run on a device will contain some security-related files.</p>

<p class="author1">You are now in a position to appreciate, in a general sense, how the components of a project are treated and assembled into an app, and what responsibilities accrue to you, the programmer, in order to ensure that the app is built correctly. The rest of this section outlines what goes into the building of an app from a project.</p>








<section data-type="sect2" data-pdf-bookmark="Build Settings" class="calibre2"><div class="preface" id="calibre_link-2554">
<h2 class="calibre42">Build Settings</h2>

<p class="author1">We have already talked about how build settings are determined. Xcode itself, the project, and the target all contribute to the resolved build setting values, some of which may differ depending on the build configuration. You, the programmer, will have specified a scheme before building; the scheme determines the build configuration, meaning the specific set of build setting values that will apply as this build <span class="publishername">proceeds.</span></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Property List Settings" class="calibre2"><div class="preface" id="calibre_link-2555">
<h2 class="calibre42">Property List Settings</h2>

<p class="author1">Your project contains a property list file that will be used to generate the built appâ€™s <em class="calibre11">Info.plist</em> file. The file in the project does not have to be named <em class="calibre11">Info.plist</em>! The app target knows what file it is because it is specified in the Info.plist File build setting. For example, in our project, the value of the app targetâ€™s Info.plist File build setting is <em class="calibre11">Empty Window/Info.plist</em>.<a data-type="indexterm" data-primary="property list settings" id="calibre_link-1779" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Info.plist" data-seealso="property list settings" id="calibre_link-1062" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The property list file is a collection of key&ndash;value pairs. You can edit it, and you may need to do so. There are three main ways to edit your projectâ€™s <em class="calibre11">Info.plist</em>:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Edit the target, and switch to the General pane. Some of the settings here are <span class="publishername">effectively</span> ways of editing the <em class="calibre11">Info.plist</em>. For example, when you click a Device Orientation checkbox here, you are changing the value of the â€œSupported interface orientationsâ€ key in the <em class="calibre11">Info.plist</em>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Edit the <em class="calibre11">Info.plist</em> file manually by selecting it in the Project navigator. The editor displays a special <em class="calibre11">.plist</em> editor interface. By default, most of the key names (and some of the values) are displayed descriptively, in terms of their functionality; for example, it says â€œBundle nameâ€ instead of the actual key, which is <code class="calibre19">CFBundleName</code>. To view the actual keys, choose Editor â†’ Show Raw Keys &amp; Values, or use the contextual menu.</p>

<p class="calibre17">If you like, you can see the file in its true XML text form: Control-click the <em class="calibre11">Info.plist</em> file in the Project navigator and choose Open As â†’ Source Code from the contextual menu. (But editing an <em class="calibre11">Info.plist</em> as raw XML is risky, because if you make a mistake you can invalidate the XML, causing things to break with no warning.)</p>
</li>
<li class="calibre12">
<p class="calibre17">Edit the target, and switch to the Info pane. The Custom iOS Target Properties section shows effectively the same information as editing the <em class="calibre11">Info.plist</em> in the <span class="publishername">editor.</span></p>
</li>
</ul>

<p class="author1">Some values in the projectâ€™s <em class="calibre11">Info.plist</em> are processed at build time to transform them into their final values in the built appâ€™s <em class="calibre11">Info.plist</em>. For example, the â€œExecutable fileâ€ keyâ€™s value in the projectâ€™s <em class="calibre11">Info.plist</em> is <span class="publishername"><code class="calibre19">$(EXECUTABLE_NAME)</code></span>; for this will be substituted the value of the <code class="calibre19">EXECUTABLE_NAME</code> build environment variable, supplied by Xcode at build time.
Also, some additional key&ndash;value pairs will be injected into the <em class="calibre11">Info.plist</em> during processing.</p>

<p class="author1">For a complete list of the possible keys and their meanings, consult Appleâ€™s <em class="calibre11">Information Property List Key Reference</em> in the documentation archive (see <a data-type="xref" href="#calibre_link-54" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;8</a>). Iâ€™ll talk more in <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a> about some <em class="calibre11">Info.plist</em> settings that youâ€™re particularly likely to edit.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Nib Files" class="calibre2"><div class="preface" id="calibre_link-2556">
<h2 class="calibre42">Nib Files</h2>

<p class="author1">A nib file is a file with the extension <em class="calibre11">.nib</em> containing a description of a piece of user interface in a compiled format.<a data-type="indexterm" data-primary="nib files" id="calibre_link-1392" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="xib files" id="calibre_link-2377" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
You edit a <em class="calibre11">.xib</em> or <em class="calibre11">.storyboard</em> file graphically, as in a drawing program.
Your <em class="calibre11">.xib</em> and <em class="calibre11">.storyboard</em> files are then transformed into nib files during the build process by compilation.
This compilation takes place by virtue of the <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> file being listed in the app targetâ€™s Copy Bundle Resources build phase.
A <em class="calibre11">.xib</em> file results in a single nib file; a <em class="calibre11">.storyboard</em> file results in a <em class="calibre11">.storyboardc</em> bundle containing multiple nib files.
<a data-type="indexterm" data-primary="storyboard files" data-seealso="main storyboard" id="calibre_link-2078" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Our Empty Window project generated from the Single View App template contains an interface <em class="calibre11">.storyboard</em> file called <em class="calibre11">Main.storyboard</em>. This is our appâ€™s <em class="calibre11">main storyboard</em> &mdash; not because of its name, but
because the <em class="calibre11">Info.plist</em> file says so, under the key â€œMain storyboard file base nameâ€ (<code class="calibre19">UIMainStoryboardFile</code>).
Iâ€™ll talk more about the main storyboard later in this chapter; in <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a> Iâ€™ll explain how nib files create instances when your code runs.<a data-type="indexterm" data-primary="main storyboard" id="calibre_link-1256" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Additional Resources" class="calibre2"><div class="preface" id="calibre_link-2557">
<h2 class="calibre42">Additional Resources</h2>

<p class="author1"><em class="calibre11">Resources</em> are ancillary files embedded in your app bundle to be extracted as needed while the app runs. For example, at some point during your appâ€™s lifetime you might want to display some images, or play some sound files; to do so, you can include these files in your app bundle.
In effect, your app bundle is being treated as a folder full of extra stuff.<a data-type="indexterm" data-primary="resources" id="calibre_link-1909" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">There are two different places to add resources to your project in Xcode:</p>
<dl class="calibre14">
<dt class="calibre15">The Project navigator</dt>
<dd class="calibre16">
<p class="calibre17">If you add a resource to the Project navigator, it is copied by the build process to the top level of your app bundle (assuming that it is also listed in the Copy Bundle Resources build phase).</p>
</dd>
<dt class="calibre15">An asset catalog</dt>
<dd class="calibre16">
<p class="calibre17">If you add a resource to an asset catalog, then when the asset catalog is copied and compiled by the build process to the top level of your app bundle, the resource will be inside it.</p>
</dd>
</dl>










<section data-type="sect3" data-pdf-bookmark="Resources in the Project navigator" class="calibre2"><div class="preface" id="calibre_link-2985">
<h3 class="calibre44">Resources in the Project navigator</h3>

<p class="author1">To add a resource to your project through the Project navigator, choose File â†’ Add Files to [Project], or drag the resource from the Finder into the Project navigator. A dialog appears (<a data-type="xref" href="#calibre_link-2865" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-16</a>):<a data-type="indexterm" data-primary="resources" data-secondary="app bundle" id="calibre_link-1910" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-2865" class="figure">
<img src="images/000002.png" alt="ios9 0616" class="calibre56" />
<h6 class="calibre34"><span class="publishername">Figure 6-16. </span>Options when adding a resource to a project</h6>
</div>
</figure>
<dl class="calibre14">
<dt class="calibre15">Copy items if needed</dt>
<dd class="calibre16">
<p class="calibre17">Check this checkbox so that the resource is copied into the project folder. (Otherwise, your project will depend on a file thatâ€™s outside the project folder, where you might delete or change it unintentionally; keeping all of your projectâ€™s contents inside the project folder is far safer.)</p>
</dd>
<dt class="calibre15">Added folders</dt>
<dd class="calibre16">
<p class="calibre17">If what youâ€™re adding to the project is a folder, these choices determine how the project references the folder contents:<a data-type="indexterm" data-primary="folders in an Xcode project" id="calibre_link-878" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Create groups</dt>
<dd class="calibre16">
<p class="calibre17">The folderâ€™s name becomes the name of a folder-linked group within the Project navigator, and its contents appear in this group; but the folder contents are listed individually in the Copy Bundle Resources build phase and are copied individually to the top level of the app bundle.</p>
</dd>
<dt class="calibre15">Create folder references</dt>
<dd class="calibre16">
<p class="calibre17">The folder becomes a <em class="calibre11">folder reference.</em> It is shown in blue in the Project navigator, and the folder itself is listed in the Copy Bundle Resources build phase. The build process will copy the folder itself, along with its contents, into the app bundle; the resources thus wonâ€™t be at the top level of the app bundle, but in a subfolder within the app bundle.
Your code for accessing a resource will have to specify the subfolder.<a data-type="indexterm" data-primary="groups" data-secondary="blue" id="calibre_link-987" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
</dd>
<dt class="calibre15">Add to targets</dt>
<dd class="calibre16">
<p class="calibre17">This checkbox determines whether the resource is added to a targetâ€™s Copy Bundle Resources build phase. If your purpose is to make this resource available to the app when it runs, make sure the app target is checked. If your purpose is merely to use the project folder as convenient storage for something that isnâ€™t part of your app, the checkbox should <em class="calibre11">not</em> be checked. Donâ€™t worry; you can always change this setting later by editing the targetâ€™s Copy Bundle Resources build phase.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Resources in an asset catalog" class="calibre2"><div class="preface" id="calibre_link-10">
<h3 class="calibre44">Resources in an asset catalog</h3>

<p class="author1">Asset catalogs were invented originally to accommodate image files; they can now contain any kind of data file. Keeping your resources in an asset catalog provides certain advantages over keeping them at the top level of the app bundle.<a data-type="indexterm" data-primary="resources" data-secondary="asset catalog" id="calibre_link-1911" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="asset catalog" id="calibre_link-214" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, you might need two or three versions of an image file, corresponding to the single-, double-, and triple-resolution screens of target devices; the asset catalog provides resolution slots to make that easy (<a data-type="xref" href="#calibre_link-2866" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-17</a>). The asset catalog can perform certain transformations on an image as it is loaded. And asset catalog images load more efficiently, because they are stored in a special format.</p>

<figure class="calibre32"><div id="calibre_link-2866" class="figure">
<img src="images/000035.png" alt="ios12 0617" class="calibre57" />
<h6 class="calibre34"><span class="publishername">Figure 6-17. </span>Slots for an image set in the asset catalog</h6>
</div>
</figure>

<p class="author1">Asset catalogs can also hold named colors, Sprite Kit textures, and general data objects. Different versions of the same asset can load in response to device type, light or dark mode, and localization. An asset catalog can contain â€œfoldersâ€ that subdivide the assets between namespaces, and multiple asset catalogs can be distinguished by putting them in different bundles (such as frameworks).</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">New in Xcode 11, the Development Assets build setting lets you specify a path for resources that wonâ€™t be included in an archive build (meaning a build to be distributed to other users, as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-2629" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œDistributionâ€</a>). In this way your app can include resources such as default data during development and testing, without those resources polluting the final built app. These can be individual resources or entire asset catalogs. A neat approach is a folder-linked group in the Project navigator: put your development-only resources into that group, and specify the path to the corresponding folder in Development Assets.<a data-type="indexterm" data-primary="Development Asset build setting" id="calibre_link-655" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="resources" data-secondary="dependent on build type" id="calibre_link-1912" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Code Files" class="calibre2"><div class="preface" id="calibre_link-2558">
<h2 class="calibre42">Code Files</h2>

<p class="author1">The build process compiles a code file into the appâ€™s binary if it is listed in the app targetâ€™s Compile Sources build phase. The Swift files provided by the app template are listed under Compile Sources already. As you develop a real app, youâ€™ll create new Swift files
by choosing File â†’ New â†’ File; a Save dialog will appear, offering to make this file part of the app target, and if you accept, the file will be added to the app targetâ€™s Compile Sources build phase. If you get this wrong, your code probably wonâ€™t compile, because the compiler wonâ€™t see the newly added Swift file. Donâ€™t worry; you can fix this later by editing the Compile Sources build phase.</p>

<p class="author1">When you create a new file choose the Cocoa Touch Class template, you get some boilerplate code for free. A file template might import the UIKit framework and write the initial class declaration for you, and in the case of some commonly subclassed superclasses, such as UIViewController and UITableViewController, it even provides stub declarations of some of that classâ€™s methods.<a data-type="indexterm" data-primary="file templates" id="calibre_link-851" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="templates" data-secondary="file" id="calibre_link-2197" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> You can add custom file templates by placing them in <em class="calibre11">~/Library/Developer/Xcode/Templates.</em></p>

<p class="author1">In the project navigator, feel free to divide your code files into groups. But donâ€™t accidentally store a code file in a folder reference; if you do, the compiler wonâ€™t be able to see it.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Frameworks, SDKs, and Packages" class="calibre2"><div class="preface" id="calibre_link-2559">
<h2 class="calibre42">Frameworks, SDKs, and Packages</h2>

<p class="author1">A <em class="calibre11">framework</em> is a library of compiled code used by your code. Most of the frameworks you are likely to use when programming iOS will be Appleâ€™s built-in frameworks. These frameworks are already part of the system on the device where your app will run; they live in <span class="publishername"><em class="calibre11">/System/Library/Frameworks</em></span> on the device, though you canâ€™t tell that because thereâ€™s no way (normally) to inspect a deviceâ€™s file hierarchy directly.<a data-type="indexterm" data-primary="frameworks" id="calibre_link-890" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Your compiled code also needs to be connected to those frameworks when the project is being built and run on your computer. To make this possible, the iOS <span class="publishername">deviceâ€™s</span> <span class="publishername"><em class="calibre11">/System/Library/Frameworks</em></span> is duplicated on your computer, inside Xcode itself. This duplicated subset of the deviceâ€™s system is called an <em class="calibre11">SDK</em> (for â€œsoftware development kitâ€). Which SDK is used depends upon what destination youâ€™re building for.<a data-type="indexterm" data-primary="SDKs" id="calibre_link-1964" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1"><em class="calibre11">Linking</em> is the process of hooking up your compiled code with the frameworks that it needs.<a data-type="indexterm" data-primary="linking" id="calibre_link-1231" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="frameworks" data-secondary="linking" id="calibre_link-893" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
The frameworks are the locus of all the stuff that every app might need to do; they are Cocoa. Thatâ€™s a lot of stuff, and a lot of compiled code. Your app gets to share in the goodness and power of the frameworks because it is linked to them. Your code works as if the framework code were incorporated into it. Yet your app is relatively tiny; itâ€™s the frameworks that are huge.</p>

<p class="author1">Linking takes care of connecting your compiled code to any needed frameworks, but your code also needs to be able to compile in the first place. The frameworks are full of classes and methods that your code will call. To satisfy the compiler, the frameworks publish their API in header files, which your code can import. For example, your code can speak of NSString and can call <code class="calibre19">range(of:)</code> because it imports the NSString header. Actually, what your code imports is the UIKit header, which in turn imports the Foundation header, which in turn imports the NSString header, which declares the <code class="calibre19">range(of:)</code> method.</p>

<p class="author1">Using a framework is therefore a two-stage process. Your code must import the frameworkâ€™s header in order to compile, and it must link to the frameworkâ€™s binary so that your code can communicate with the frameworkâ€™s code at runtime. Luckily, Swiftâ€™s use of modules simplifies the importing and linking process (as well as improving compilation times).
A Swift <code class="calibre19">import</code> statement takes care of everything. For example, the <code class="calibre19">import UIKit</code> statement at the top of our projectâ€™s code files imports the UIKit frameworkâ€™s header files and allows your code to compile; then, at build time, it also causes linkage with the UIKit framework.<a data-type="indexterm" data-primary="import statement" id="calibre_link-1047" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="modules" id="calibre_link-1361" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A framework can be a useful way to subdivide your code into modules. Also, a framework is a bundle, so it can include resources that are referenced by specifying that bundle. Hereâ€™s how to create a framework in your project:<a data-type="indexterm" data-primary="frameworks" data-secondary="creating" id="calibre_link-891" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="target" data-secondary="framework" id="calibre_link-2192" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Edit the target and choose Editor â†’ Add Target.</p>
</li>
<li class="calibre4">
<p class="calibre17">Select iOS. Under Framework &amp; Library, select iOS Framework. Click Next.</p>
</li>
<li class="calibre4">
<p class="calibre17">Give your framework a name; letâ€™s call it <em class="calibre11">MyCoolFramework</em>. You can pick a language, but Iâ€™m not sure this makes any difference, as no code files will be created. The Project and Embed in Application pop-up menus should be correctly set by default. Click Finish.</p>
</li>

</ol>

<p class="author1">A new MyCoolFramework target is created in your project. If you now add a Swift file to the MyCoolFramework target, and inside it define an object type and declare it <code class="calibre19">public</code>, then, back in one of your main app targetâ€™s files, such as <em class="calibre11">AppDelegate.swift</em>, your code can <code class="calibre19">import MyCoolFramework</code> and will then be able to see that object type and its public members.<a data-type="indexterm" data-primary="frameworks" data-secondary="embedded" id="calibre_link-892" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">New in Xcode 11, you can create a <em class="calibre11">package</em>. A package is simpler and more efficient than a framework; itâ€™s just a collection of source code, and doesnâ€™t need linking:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In your project (such as our Empty Window project), choose File â†’ New â†’ Swift Package.</p>
</li>
<li class="calibre4">
<p class="calibre17">Give the package a name, such as <em class="calibre11">MyCoolPackage</em>. At the bottom of the Save dialog, specify that you want to add this package to the existing project (Empty Window), and make sure youâ€™re adding it at the <em class="calibre11">top level</em> of the project, not inside any group. Click Create.</p>
</li>
<li class="calibre4">
<p class="calibre17">The initial package files appear in the Project navigator, but this module is not yet available to the app target. Edit the target; in the General pane, under Frameworks, Libraries, and Embedded Content, click Plus and choose the package in the dialog (<a data-type="xref" href="#calibre_link-2867" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-18</a>). Click Add.</p>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2867" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-18. </span>Adding a local package dependency to the app target</h6>
</div>
</figure>

<p class="author1">In your app targetâ€™s code, you can now <code class="calibre19">import MyCoolPackage</code> to access public types declared in the package. You can add source files to the MyCoolPackage group inside Sources.</p>

<p class="author1">What weâ€™ve created is a <em class="calibre11">local</em> package. But one of the key features of packages is that they can be made public; you can upload your package to GitHub, and other programmers can incorporate it into their projects. Sharing a package with others is easy, because a package is just source files. Distributing a framework to others is more complicated, both for you and for the recipients of your framework. On the other hand, a framework is a bundle, so it can include resources, such as a storyboard, an asset catalog, or image files; a package canâ€™t.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The App Launch Process" class="calibre2"><div class="preface" id="calibre_link-2560">
<h1 class="calibre18">The App Launch Process</h1>

<p class="author1">When the user launches your app, or when you launch it by building and running it in Xcode, a lot needs to happen. Your app needs some initial instances and an initial interface, and at least some of your code needs an opportunity to run. Hereâ€™s how that works.
<a data-type="indexterm" data-primary="launch process of an app" id="calibre_link-1208" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="app" data-secondary="launch process" id="calibre_link-153" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="The Entry Point" class="calibre2"><div class="preface" id="calibre_link-2561">
<h2 class="calibre42">The Entry Point</h2>

<p class="author1">When the app launches, the system knows where to find the compiled binary inside the appâ€™s bundle, because the app bundleâ€™s <em class="calibre11">Info.plist</em> file has an â€œExecutable fileâ€ key (<code class="calibre19">CFBundleExecutable</code>) whose value is the name of the binary; by default, the binaryâ€™s name comes from the <code class="calibre19">EXECUTABLE_NAME</code> environment variable (such as â€œEmpty Windowâ€).</p>

<p class="author1">The system locates and loads the binary and links any needed frameworks. Now it must call into the binaryâ€™s code to start it running. But where?</p>

<p class="author1">If this app were an Objective-C program, the answer would be clear. Objective-C is C, so the entry point is the <code class="calibre19">main</code> function. Our project would typically have a <em class="calibre11">main.m</em> file containing the <code class="calibre19">main</code> function, like this:<a data-type="indexterm" data-primary="main function" id="calibre_link-1255" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="entry point" data-secondary="code" id="calibre_link-740" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">int main(int argc, char *argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil,
            NSStringFromClass([AppDelegate class]));
    }
}</pre>

<p class="author1">The <code class="calibre19">main</code> function does two things:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">It sets up a memory management environment &mdash; the <code class="calibre19">@autoreleasepool</code> and the curly braces that follow it.</p>
</li>
<li class="calibre12">
<p class="calibre17">It calls the <code class="calibre19">UIApplicationMain</code> function, which helps your app pull itself up by its bootstraps and get running.</p>
</li>
</ul>

<p class="author1">Our app, however, is a Swift program. It has no <code class="calibre19">main</code> function! Instead, Swift has a special attribute: <code class="calibre19">@UIApplicationMain</code>. You can see it in the <em class="calibre11">AppDelegate.swift</em> file, attached to the declaration of the AppDelegate class:</p>

<pre data-type="programlisting" class="calibre28">@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {</pre>

<p class="author1">This attribute essentially does everything that the Objective-C <em class="calibre11">main.m</em> file was doing: it creates an entry point that calls <code class="calibre19">UIApplicationMain</code> to get the app started.</p>

<p class="author1">It would be very unusual for you to give your Swift app project a <em class="calibre11">main</em> file. But you are free to do so. Delete the <code class="calibre19">@UIApplicationMain</code> attribute and instead create a <em class="calibre11">main.swift</em> file, making sure it is added to the app target. The name is crucial, because a file called <em class="calibre11">main.swift</em> gets a special dispensation: it is allowed to put executable code at the top level of the file (<a data-type="xref" href="#calibre_link-2393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;1</a>)! The file should contain essentially the Swift equivalent of the Objective-C call to <code class="calibre19">UIApplicationMain</code>, like this:<a data-type="indexterm" data-primary="main.swift file" id="calibre_link-1262" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">import UIKit
UIApplicationMain(
    CommandLine.argc, CommandLine.unsafeArgv, nil,
        NSStringFromClass(AppDelegate.self)
)</pre>

<p class="author1">Regardless of whether you write your own <em class="calibre11">main.swift</em> file or you rely on the Swift <code class="calibre19">@UIApplicationMain</code> attribute, you are calling <code class="calibre19">UIApplicationMain</code>. This one function call is the primary thing your app does. Your entire app is really nothing but a single gigantic call to <code class="calibre19">UIApplicationMain</code>! Moreover, <code class="calibre19">UIApplicationMain</code> is responsible for solving some tricky problems as your app gets going. Where will your app get its initial instances? What instance methods will initially be called on those instances? Where will your appâ€™s initial interface come from?<a data-type="indexterm" data-primary="instances" data-secondary="initial" id="calibre_link-1125" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <code class="calibre19">UIApplicationMain</code> to the rescue!</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="How an App Gets Going" class="calibre2"><div class="preface" id="calibre_link-69">
<h2 class="calibre42">How an App Gets Going</h2>

<p class="author1">Hereâ€™s what happens when your app launches and <code class="calibre19">UIApplicationMain</code> is called. The sequence Iâ€™m describing is new in iOS 13, for a project created with an Xcode 11 app template (with a UIWindowSceneDelegate). I will assume that your app supports scenes; the runtime knows this because the <em class="calibre11">Info.plist</em> contains an â€œApplication Scene Manifestâ€ dictionary. I will also assume (for now) that your app has a main storyboard:<a data-type="indexterm" data-primary="UIApplicationMain" id="calibre_link-2252" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17"><code class="calibre19">UIApplicationMain</code> creates your appâ€™s <em class="calibre11">first instance</em> &mdash; the shared application instance, subsequently accessible to your code as <code class="calibre19">UIApplication.shared</code>.<a data-type="indexterm" data-primary="UIApplication" id="calibre_link-2251" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="shared application instance" id="calibre_link-2023" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The third argument in the call to <code class="calibre19">UIApplicationMain</code> specifies, as a string, what the class of the shared application instance should be. If this argument is <code class="calibre19">nil</code>, as will usually be the case, the default class is UIApplication.</p>
</li>
<li class="calibre4">
<p class="calibre17"><code class="calibre19">UIApplicationMain</code> creates your appâ€™s <em class="calibre11">second instance</em> &mdash; the application instanceâ€™s <em class="calibre11">delegate</em>.
The fourth argument in the call to <code class="calibre19">UIApplicationMain</code> specifies, as a string, what the class of the app delegate instance should be. In a <em class="calibre11">main.swift</em> file, that specification is <code class="calibre19">NSStringFromClass(AppDelegate.self)</code>. When we use the <code class="calibre19">@UIApplicationMain</code> attribute, that attribute is part of the AppDelegate class declaration, and means: â€œ<em class="calibre11">This</em> is the app delegate class!â€<a data-type="indexterm" data-primary="app" data-secondary="delegate" id="calibre_link-152" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">If this app supports scenes, <code class="calibre19">UIApplicationMain</code> turns to the app delegate and, for the first time, runs some of your code: it calls <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code>. This is a place for you to perform certain initializations.</p>
</li>
<li class="calibre4">
<p class="calibre17"><code class="calibre19">UIApplicationMain</code> creates a UISceneSession, a UIWindowScene, and your appâ€™s <em class="calibre11">third instance</em> &mdash; the window sceneâ€™s <em class="calibre11">delegate</em>. The <em class="calibre11">Info.plist</em> specifies, as a string, what the class of the window scene delegate instance should be. In our app template, that is the SceneDelegate class.<a data-type="indexterm" data-primary="UISceneSession" id="calibre_link-2259" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="UIWindowScene" id="calibre_link-2265" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">If there is a storyboard associated with this scene, as specified by the <em class="calibre11">Info.plist</em>, <code class="calibre19">UIApplicationMain</code> loads it and looks inside it to find the view controller designated as this storyboardâ€™s <em class="calibre11">initial view controller</em> (or <em class="calibre11">storyboard entry point</em>);<a data-type="indexterm" data-primary="main storyboard" id="calibre_link-1257" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> it instantiates this view controller, thus creating your appâ€™s <em class="calibre11">fourth instance</em>, a UIViewController subclass. In our app template, the appâ€™s main storyboard, <em class="calibre11">Main.storyboard</em>, is the initial sceneâ€™s storyboard; in that storyboard, the initial view controller is an instance of the ViewController class, which is declared in <em class="calibre11">ViewController.swift</em>.</p>
</li>
<li class="calibre4">
<p class="calibre17"><code class="calibre19">UIApplicationMain</code> creates your appâ€™s <em class="calibre11">window</em>. By default, this is an instance of UIWindow; alternatively, your scene delegate can substitute an instance of a UIWindow subclass. This window is assigned to the scene delegateâ€™s <code class="calibre19">window</code> property. <code class="calibre19">UIApplicationMain</code> then assigns the initial view controller instance to the window instanceâ€™s <code class="calibre19">rootViewController</code> property. This view controller is now the appâ€™s <em class="calibre11">root view controller</em>.<a data-type="indexterm" data-primary="root view controller" id="calibre_link-1940" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="view controller" data-secondary="initial" id="calibre_link-2350" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17"><code class="calibre19">UIApplicationMain</code> causes your appâ€™s interface to appear, by calling the UIWindow instance method <code class="calibre19">makeKeyAndVisible</code>.</p>
</li>
<li class="calibre4">
<p class="calibre17">The window is about to appear. This causes the window to turn to the root view controller and tell it to obtain its main view, which will occupy and appear in the window. If this view controller gets its view from a nib file, that nib is loaded, its objects are instantiated and initialized, and those objects become the initial interface: the view is placed into the window, where it and its subviews are visible to the user. The view controllerâ€™s <code class="calibre19">viewDidLoad</code> is then called &mdash; another early opportunity for your code to run.</p>
</li>

</ol>

<p class="author1">More of your code can run at this time (some further app delegate and scene delegate methods are called if they are implemented), but basically the app is now up and running, with an initial set of instances and a visible interface. <code class="calibre19">UIApplicationMain</code> is <em class="calibre11">still</em> running (like Charlie on the M.T.A., <code class="calibre19">UIApplicationMain</code> never returns), and is just sitting there, watching for the user to do something, maintaining the <em class="calibre11">event loop</em>, which will respond to user actions as they occur. Henceforth, your appâ€™s code will be called only in response to Cocoa events (as Iâ€™ll explain in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>).</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="App Without a Storyboard" class="calibre2"><div class="preface" id="calibre_link-2562">
<h2 class="calibre42">App Without a Storyboard</h2>

<p class="author1">In the preceding description of the app launch process, I assume that the app has a main storyboard.
It is possible, however, <em class="calibre11">not</em> to have a main storyboard.
Without a main storyboard, things like creating a window instance, assigning it to the <code class="calibre19">window</code> property, creating an initial view controller, assigning that view controller to the windowâ€™s <code class="calibre19">rootViewController</code> property, and calling <code class="calibre19">makeKeyAndVisible</code> on the window to show the interface, must be done by your code.</p>

<p class="author1">Letâ€™s try it. Make a new project starting with the Single View App template; call it Truly Empty. Now follow these steps:<a data-type="indexterm" data-primary="main storyboard" data-secondary="app without" id="calibre_link-1258" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="app" data-secondary="without main storyboard" id="calibre_link-161" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Edit the target. In the General pane, select â€œMainâ€ in the Main Interface field and delete it (and press Tab to set this change).</p>
</li>
<li class="calibre4">
<p class="calibre17">In the <em class="calibre11">Info.plist</em>, select the â€œStoryboard Nameâ€ entry in the â€œApplication Scene Configurationâ€ dictionary (<a data-type="xref" href="#calibre_link-2868" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-19</a>) and press Delete (and save).</p>
</li>
<li class="calibre4">
<p class="calibre17">Optionally, in the Project navigator, delete <em class="calibre11">Main.storyboard</em> from the project. You donâ€™t have to do this, because even if <em class="calibre11">Main.storyboard</em> remains, it will now be ignored.</p>
</li>
<li class="calibre4">
<p class="calibre17">In <em class="calibre11">SceneDelegate.swift</em>, edit <code class="calibre19">scene(_:willConnectTo:options:)</code> to look like <a data-type="xref" href="#calibre_link-2869" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;6-1</a>.</p>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2868" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 6-19. </span>The line to be deleted from the <em class="calibre11">Info.plist</em></h6>
</div>
</figure>
<div id="calibre_link-2869" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 6-1. </span>A scene delegate with no storyboard</h5>

<pre data-type="programlisting" class="calibre31">func scene(_ scene: UIScene,
           willConnectTo session: UISceneSession,
           options connectionOptions: UIScene.ConnectionOptions) {
    if let windowScene = scene as? UIWindowScene {
        let window = UIWindow(windowScene: windowScene)
        window.backgroundColor = .white
        window.rootViewController = ViewController()
        self.window = window
        window.makeKeyAndVisible()
    }
}</pre>
</div>

<p class="author1">The result is a minimal working app with an empty white window. You can prove to yourself that the app is working normally by editing <em class="calibre11">ViewController.swift</em> so that its <code class="calibre19">viewDidLoad</code> method changes the main viewâ€™s background color:</p>

<pre data-type="programlisting" class="calibre28">override func viewDidLoad() {
    super.viewDidLoad()
    self.view.backgroundColor = .red
}</pre>

<p class="author1">Run the app again; sure enough, the background is now red.</p>

<p class="author1">This architecture is useful when your intention is to create the entire interface in code. Thatâ€™s what a SwiftUI project does. If you create a project from the Single View App template with Use SwiftUI checked, youâ€™ll find that it is structured just like the project we just made, except that it has a SwiftUI ContentView struct; its <code class="calibre19">scene(_:willConnectTo:options:)</code> contains this code:</p>

<pre data-type="programlisting" class="calibre28">if let windowScene = scene as? UIWindowScene {
    let window = UIWindow(windowScene: windowScene)
    window.rootViewController = UIHostingController(rootView: ContentView())
    self.window = window
    window.makeKeyAndVisible()
}</pre>

<p class="author1">In between an app with a main storyboard and an app without a main storyboard, there is a hybrid architecture where thereâ€™s a main storyboard (you omit steps 1, 2, and 3 in the earlier example) but you sometimes ignore it at launch time (step 4).
A common use case would be an app with a sign-in screen that should appear when the user first launches the app (you create the sign-in view controller manually), but once the user has signed in, that screen shouldnâ€™t appear on any future launch (you let the main storyboard construct the interface).</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Renaming Parts of a Project" class="calibre2"><div class="preface" id="calibre_link-2563">
<h1 class="calibre18">Renaming Parts of a Project</h1>

<p class="author1">The name you give your project at creation time is used in many places throughout the project. Beginners may worry that they can never rename a project without breaking something. But in fact itâ€™s not a problem.<a data-type="indexterm" data-primary="renaming a project" id="calibre_link-1896" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In the first place, you probably donâ€™t <em class="calibre11">need</em> to rename the project. The project name isnâ€™t something the user will ever see, so what does it matter? Typically, what you want to change is the name of the <em class="calibre11">app</em> &mdash; the name that the user sees on the device, associated with this appâ€™s icon. To do so, change (or create) the â€œBundle Display Nameâ€ in the <em class="calibre11">Info.plist</em>; you can do this most easily by editing the Display Name text field at the top of the General pane when you edit the target (see <a data-type="xref" href="#calibre_link-2636" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œProperty List Settingsâ€</a>).<a data-type="indexterm" data-primary="app" data-secondary="name" id="calibre_link-154" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="display name" id="calibre_link-683" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bundle" data-secondary="display name" id="calibre_link-306" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If you really <em class="calibre11">do</em> want to rename the project, select the project listing at the top of the Project navigator, press Return to make its name editable, type the new name, and press Return again. Xcode presents a dialog proposing to change some other names to match, including the app target and the built app and, by implication, various relevant build settings. <a data-type="indexterm" data-primary="project" data-secondary="renaming" id="calibre_link-1734" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Everything that needs to change thus changes coherently when you rename the project. The only thing that isnâ€™t changed is the scheme name; there is no particular need to change it, but to do so, choose Product â†’ Manage Schemes and click the scheme name to make it editable.<a data-type="indexterm" data-primary="schemes" data-secondary="renaming" id="calibre_link-1952" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can change the name of the project folder in the Finder at any time, and you can move the project folder in the Finder at will, because all build setting references to file and folder items in the project folder are relative.<a data-type="indexterm" data-primary="project" data-secondary="folder" id="calibre_link-1733" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Be careful about changing the name of a folder-linked group. When you do that, Xcode automatically changes the name of the corresponding folder on disk, but does <em class="calibre11">not</em> change build settings that depend upon the name of that folder, such as the Info.plist File build setting. I regard this as a bug, because it means that changing a groupâ€™s name can prevent your project from building. However, it usually isnâ€™t hard to fix the problem manually by changing the broken build <span class="publishername">settings</span>.<a data-type="indexterm" data-primary="folder-linked group" data-secondary="renaming" id="calibre_link-876" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="groups" data-secondary="renaming" id="calibre_link-989" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2870">
<div id="calibre_link-2986" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 7. Nib Files" class="calibre2"><div class="preface" id="calibre_link-16">
<h1 class="calibre13"><span class="label">Chapter 7. </span>Nib Files</h1>


<p class="author1">A <em class="calibre11">view</em> (UIView) is an interface object, which draws itself into a rectangular area. Your appâ€™s visible interface consists of views. When your app launches, some view controller is made the root view controller of your appâ€™s window (<a data-type="xref" href="#calibre_link-69" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œHow an App Gets Goingâ€</a>). That view controller has a main view. That view and its subviews now occupy the window. Whatever that view and its subviews look like when they draw themselves, that is what the user will see.<a data-type="indexterm" data-primary="views" id="calibre_link-2354" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="nib files" id="calibre_link-1393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Where do these interface views come from? Well, UIView is a class; an individual UIView is an instance of that class. And you know how to make an instance of a class &mdash; you call that classâ€™s initializer:</p>

<pre data-type="programlisting" class="calibre28">let v = UIView()</pre>

<p class="author1">So you could create all your interface views in code, one by one. For each view, you would <em class="calibre11">instantiate</em> it; then you would <em class="calibre11">configure</em> it. Youâ€™d say where it should go on the screen, what size it should have, what color it should be. If the view is a button or a label, youâ€™d say what text it should display. And so on.</p>

<p class="author1">But that could be a lot of code. Wouldnâ€™t it be nice if, instead, you could <em class="calibre11">draw</em> your desired interface, just as in a drawing application, and have the runtime build the interface for you, based on your drawing? Well, you can &mdash; using a <em class="calibre11">nib</em>.</p>

<p class="author1">A <em class="calibre11">nib</em> is a file, in a special format, consisting of instructions for creating and configuring instances &mdash; primarily UIView instances. You â€œwriteâ€ those instructions graphically, by drawing. You design your appâ€™s interface visually. Under the hood, Xcode translates that design into text (itâ€™s actually XML, but thatâ€™s just an implementation detail). When the app runs and itâ€™s time for those UIView instances to appear visibly to the user, the runtime <em class="calibre11">loads</em> the nib. It reads the instructions and obeys them: it actually creates and configures the view instances that the nib describes.<a data-type="indexterm" data-primary="loading a nib" id="calibre_link-1242" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nib-based instantiation" id="calibre_link-1401" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instantiation" data-secondary="nib-based" id="calibre_link-1143" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So that you can draw your interface into a nib file, Xcode includes a graphical design environment, which I call the <em class="calibre11">nib editor.</em><a data-type="indexterm" data-primary="nib editor" id="calibre_link-1391" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Long ago, the files on which the nib editor operated were literally nib files &mdash; that is, they had a <em class="calibre11">.nib</em> file extension. Nowadays, youâ€™ll use the nib editor to edit a <em class="calibre11">.storyboard</em> file or a <em class="calibre11">.xib</em> file. However, they <em class="calibre11">will</em> be turned into actual <em class="calibre11">.nib</em> files when you build your project (<a data-type="xref" href="#calibre_link-2556" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œNib Filesâ€</a>), so I still refer to them loosely as nibs or nib files.<a data-type="indexterm" data-primary="editor" data-secondary="nib" id="calibre_link-729" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">The name <em class="calibre11">nib</em> has nothing to do with fountain pens or bits of chocolate. The nib editor used to be
a separate application called Interface Builder. The operating system for which it was originally developed was called NeXTStep. The files created by Interface Builder were given the <em class="calibre11">.nib</em> file extension as an acronym for â€œNeXTStep Interface Builder.â€<a data-type="indexterm" data-primary="NeXTStep" id="calibre_link-1390" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Interface Builder" id="calibre_link-1147" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>

<p class="author1">You donâ€™t <em class="calibre11">have</em> to use nibs to create your interface objects. The loading of a nib does nothing that you could not have done directly, in code. A nib is just a device for making the creation of interface views convenient and compact; one nib file can generate many views, and the nib editorâ€™s visual representation of those views can be more intuitive than a code description. But you still have the alternative of using code: you can programmatically instantiate a UIView, you can configure it, you can place that view into your interface &mdash; manually, step by step, one line of code at a time. You are free to mix and match; you can generate some views in code and design other views in the nib editor.</p>

<p class="author1">Clearly, nibs can be a powerful and convenient way to create your appâ€™s interface, in whole or in part. Beginners often use nibs, to take advantage of that power and convenience, without knowing what they really are, how they really work, or how to manipulate them in code &mdash; as if nibs were some kind of impenetrable magic. But nibs are <em class="calibre11">not</em> magic, and they are not hard to understand. Failure to understand nibs and nib loading opens the door to some elementary, confusing mistakes that can be avoided or corrected merely by grasping the basic facts outlined in this chapter.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">One of the salient features of SwiftUI<a data-type="indexterm" data-primary="SwiftUI" id="calibre_link-2177" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is that it avoids nibs. By condensing the code needed to create views programmatically, it lets you describe your interface clearly and compactly in Swift. Part of the goal is multiplatform reusability: the same code can construct an interface destined for an Apple Watch, an iPhone, an Apple TV, or a desktop computer.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="The Nib Editor Interface" class="calibre2"><div class="preface" id="calibre_link-2564">
<h1 class="calibre18">The Nib Editor Interface</h1>

<p class="author1">Letâ€™s explore Xcodeâ€™s nib editor. This is where youâ€™ll draw your appâ€™s interface graphically. In <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>, we created a simple project, Empty Window, directly from the Single View App template; it contains a storyboard file, so weâ€™ll use that. In Xcode, open the Empty Window project, locate <em class="calibre11">Main.storyboard</em> in the Project navigator, and click to edit it.<a data-type="indexterm" data-primary="storyboard files" data-secondary="editing" id="calibre_link-2081" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="editing" data-secondary="a storyboard" id="calibre_link-723" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-2871" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-1. </span>Editing a nib file</h6>
</div>
</figure>

<p class="author1"><a data-type="xref" href="#calibre_link-2871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-1</a> shows part of the project window after selecting <em class="calibre11">Main.storyboard</em> in the Project navigator. The interface may be considered in four pieces:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">The bulk of the editor is devoted to the <em class="calibre11">canvas</em>, where you physically design your appâ€™s interface. The canvas portrays views graphically. View controllers are also represented in the canvas; a view controller isnâ€™t a view, so it isnâ€™t drawn in your appâ€™s interface, but it <em class="calibre11">has</em> a view, which <em class="calibre11">is</em> drawn.<a data-type="indexterm" data-primary="canvas" id="calibre_link-332" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">At the left of the editor is the <em class="calibre11">document outline</em>, listing the storyboardâ€™s contents hierarchically by name. It can be hidden by dragging its right edge or by clicking the button at the bottom left corner below the canvas.</p>
</li>
<li class="calibre4">
<p class="calibre17">To the right of the editor, the inspectors in the Utilities pane let you edit details of the currently selected object.</p>
</li>
<li class="calibre4">
<p class="calibre17">The Objects Library, available as a floating window (View â†’ Libraries â†’ Show Library, Command-Shift-L), is your source of interface objects to be added to the canvas or the document outline.</p>
</li>

</ol>








<section data-type="sect2" data-pdf-bookmark="Document Outline" class="calibre2"><div class="preface" id="calibre_link-2565">
<h2 class="calibre42">Document Outline</h2>

<p class="author1">The document outline portrays hierarchically the relationships between the objects in the nib. This structure differs slightly depending on whether youâ€™re editing a <em class="calibre11">.storyboard</em> file or a <em class="calibre11">.xib</em> file.</p>

<p class="author1">In a storyboard file, the primary constituents are <em class="calibre11">scenes</em>.<a data-type="indexterm" data-primary="scene" id="calibre_link-1948" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> A scene is, roughly speaking, a single view controller, along with some ancillary material; every scene has a single view controller at its top level.</p>

<p class="author1">A view controller isnâ€™t an interface object, but it manages an interface object, a view that serves as its <em class="calibre11">main view</em>.<a data-type="indexterm" data-primary="view controller" id="calibre_link-2348" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="main view of view controller" id="calibre_link-1259" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> A sceneâ€™s view controller is displayed in the canvas with its main view inside it. In <a data-type="xref" href="#calibre_link-2871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-1</a>, the large rectangle in the canvas is a view controllerâ€™s main view, and is actually inside a view controller.
The view controller itself can be seen and selected in the document outline. It is also represented as an icon in the <em class="calibre11">scene dock</em>, which appears above the view controller in the canvas when anything in this scene is selected (<a data-type="xref" href="#calibre_link-2872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-2</a>).</p>

<p class="author1">In the document outline, all the scenes are listed. Each scene is the top level of a hierarchical list. Hierarchically down from each scene are the objects that also appear in the view controllerâ€™s scene dock: the view controller itself, along with two <em class="calibre11">proxy objects</em>, the First Responder token and the Exit token. They are the sceneâ€™s <em class="calibre11">top-level objects</em>. The view controllerâ€™s main view appears hierarchically down from the view controller, and the main viewâ€™s subviews appear hierarchically down from that, reflecting the interface hierarchy of superviews and subviews.<a data-type="indexterm" data-primary="top-level objects (nib)" id="calibre_link-2221" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dock" id="calibre_link-689" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="scene dock" id="calibre_link-1949" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="document outline" id="calibre_link-690" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subview" id="calibre_link-2158" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="superview" id="calibre_link-2164" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hierarchy of views" id="calibre_link-1020" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">(In <a data-type="xref" href="#calibre_link-2872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-2</a>, the main view has no subviews. Ignore the Safe Area; Iâ€™m not going to explain what it is.)</p>

<figure class="calibre32"><div id="calibre_link-2872" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-2. </span>A view controller selected in a storyboard</h6>
</div>
</figure>

<p class="author1">Objects listed in the document outline are of two kinds:</p>
<dl class="calibre14">
<dt class="calibre15">Nib objects</dt>
<dd class="calibre16">
<p class="calibre17">The view controller, along with its main view and its subviews, will be turned into actual instances when the nib is loaded by the running app. They are called <em class="calibre11">nib objects</em>.<a data-type="indexterm" data-primary="nib objects" id="calibre_link-1399" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Proxy objects</dt>
<dd class="calibre16">
<p class="calibre17">Proxy objects (here, the First Responder and Exit tokens) will <em class="calibre11">not</em> be turned into instances when the nib is loaded.<a data-type="indexterm" data-primary="proxy objects" id="calibre_link-1820" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> They represent objects that <em class="calibre11">already</em> exist. They are displayed in the nib in order to facilitate communication between nib objects and those already existing objects; Iâ€™ll give examples later in this chapter.</p>
</dd>
</dl>

<p class="author1">The document outline also contains the Storyboard Entry Point. This isnâ€™t an object of any kind. Itâ€™s an indicator that this view controller is the storyboardâ€™s initial view controller (because Is Initial View Controller is checked in the view controllerâ€™s Attributes inspector); it corresponds to the right-pointing arrow seen at the left of this view controller in the canvas in <a data-type="xref" href="#calibre_link-2871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-1</a>.<a data-type="indexterm" data-primary="entry point" data-secondary="storyboard" id="calibre_link-742" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="storyboard files" data-secondary="entry point" id="calibre_link-2082" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="view controller" data-secondary="initial" id="calibre_link-2351" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In a <em class="calibre11">.xib</em> file, there are no scenes. What would be, in a <em class="calibre11">.storyboard</em> file, the top-level objects of a scene become, in a <em class="calibre11">.xib</em> file, the top-level objects of the nib itself; and the top-level interface object of a <em class="calibre11">.xib</em> file is usually a view. (A <em class="calibre11">.xib</em> file <em class="calibre11">can</em> contain a view controller, but it usually doesnâ€™t.) A <em class="calibre11">.xib</em> fileâ€™s top-level view might well be a view that is to serve as a view controllerâ€™s main view, but thatâ€™s not a requirement. <a data-type="xref" href="#calibre_link-2873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-3</a> shows a <em class="calibre11">.xib</em> file with a structure parallel to the single scene of <a data-type="xref" href="#calibre_link-2872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-2</a>.<a data-type="indexterm" data-primary="xib files" data-secondary="editing" id="calibre_link-2378" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="editing" data-secondary="a xib file" id="calibre_link-724" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-2873" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-3. </span>A .xib file containing a view</h6>
</div>
</figure>

<p class="author1">The document outline in <a data-type="xref" href="#calibre_link-2873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-3</a> lists three top-level objects. Two of them are proxy objects, termed Placeholders in the document outline: the Fileâ€™s Owner, and the First Responder. The third is a nib object, a view; it will be turned into a UIView instance when the nib is loaded as the app runs. <a data-type="indexterm" data-primary="placeholders" data-secondary="nib editor" data-see="proxy objects" id="calibre_link-2987" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">At present, the document outline may seem unnecessary, because there is very little hierarchy; all objects in
Figures <a data-type="xref" data-xrefstyle="select: labelnumber" href="#calibre_link-2872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">7-2</a> and <a data-type="xref" data-xrefstyle="select: labelnumber" href="#calibre_link-2873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">7-3</a>
are readily accessible in the canvas. But when a storyboard contains many scenes, and when a view contains many levels of hierarchically arranged objects, some of which are difficult to see or select in the canvas, youâ€™re going to be very glad of the document outline, which lets you survey the contents of the nib in a nice hierarchical structure, and where you can locate and select the object youâ€™re after. You can also rearrange the hierarchy here; for example, if youâ€™ve made a view a subview of the wrong superview, you can reposition it within this outline by dragging its name.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">You can also select objects using the jump bar at the top of the editor:<a data-type="indexterm" data-primary="jump bar" data-secondary="nib editor" id="calibre_link-1178" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> the last jump bar path component is a hierarchical pop-up menu similar to the document outline.</p>
</div>

<p class="author1">If the names of nib objects in the document outline seem generic and uninformative, you can change them. The name is technically a <em class="calibre11">label</em>, and has no special meaning, so feel free to assign nib objects labels that are useful to you. Select a nib objectâ€™s label in the document outline and press Return to make it editable, or select the object and edit the Label field in the Document section of the Identity inspector.<a data-type="indexterm" data-primary="labels" data-secondary="nib editor" id="calibre_link-1198" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Canvas" class="calibre2"><div class="preface" id="calibre_link-2566">
<h2 class="calibre42">Canvas</h2>

<p class="author1">The canvas provides a graphical representation of a view and its subviews, similar to what youâ€™re probably accustomed to in any drawing program.<a data-type="indexterm" data-primary="canvas" id="calibre_link-333" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The canvas is scrollable and automatically accommodates however many graphical representations it contains, and can also be zoomed (Option-scroll, or choose Editor â†’ Zoom, or use the contextual menu or the zoom buttons at the bottom of the canvas).</p>

<p class="author1">Our simple Empty Window projectâ€™s <em class="calibre11">Main.storyboard</em> contains just one scene, so the only thing it represents in the canvas is that sceneâ€™s view controller with its main view inside it. When the app runs, this view controller will become the windowâ€™s <code class="calibre19">rootViewController</code>; therefore its view will occupy the entire window, and will effectively be our appâ€™s initial interface. That gives us an excellent opportunity to experiment: any visible changes we make within this view should be visible when we subsequently build and run the app! To prove this, letâ€™s add a <span class="publishername">subview:</span><a data-type="indexterm" data-primary="Empty Window example project" id="calibre_link-732" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Start with the nib editor looking more or less like <a data-type="xref" href="#calibre_link-2871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-1</a>.</p>
</li>
<li class="calibre4">
<p class="calibre17">Summon the Objects Library (Command-Shift-L, or click the Library button in the project window toolbar). Make sure itâ€™s displaying objects (not images or colors). If itâ€™s in icon view (a grid of icons without text), switch to list view. Click in the search field and type â€œbuttonâ€ so that only button objects are shown in the list.<a data-type="indexterm" data-primary="Library" id="calibre_link-1223" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objects library" id="calibre_link-1552" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The Button object weâ€™re after is listed first.</p>
</li>
<li class="calibre4">
<p class="calibre17">Drag the Button object from the Library into the view controllerâ€™s main view in the canvas (<a data-type="xref" href="#calibre_link-2874" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-4</a>), and let go of the mouse.</p>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2874" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-4. </span>Dragging a button into a view</h6>
</div>
</figure>

<p class="author1">A button is now present in the view in the canvas. The move weâ€™ve just performed &mdash; dragging from the Library into the canvas &mdash; is extremely characteristic; youâ€™ll do it often as you design your interface.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">By default, the Library floating window is temporary; it vanishes as soon as you drag something out of it. To make it remain onscreen after the drag, hold Option when summoning the Library or when dragging out of it; the Library windowâ€™s toolbar then contains a close button, and the window will remain open until you click that button.</p>
</div>

<p class="author1">Much as in a drawing program, the nib editor provides features to aid you in designing your interface. Here are some things to try:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Select the button: resizing handles appear.</p>
</li>
<li class="calibre12">
<p class="calibre17">Using the resizing handles, resize the button to make it wider: dimension information appears.</p>
</li>
<li class="calibre12">
<p class="calibre17">Drag the button near an edge of the view: a guideline appears, showing standard spacing. Similarly, drag the button near the center of the view: a guideline shows you when the button is centered.</p>
</li>
<li class="calibre12">
<p class="calibre17">With the button selected, hold Option (but <em class="calibre11">not</em> the mouse button) and hover the mouse outside the button: arrows and numbers appear showing the distance between the button and the edges of the view.</p>
</li>
<li class="calibre12">
<p class="calibre17">Control-Shift-click the button: a menu appears, letting you select the button or whatever is behind it or up the hierarchy from it. This is useful particularly when views overlap.</p>
</li>
<li class="calibre12">
<p class="calibre17">Double-click the buttonâ€™s title. The title becomes editable. Give it a new title, such as â€œHello.â€ Press Return to set the new title.</p>
</li>
</ul>

<p class="author1">To prove that we really are designing our appâ€™s interface, weâ€™ll run the app:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Drag the button to a position near the <em class="calibre11">top left</em> corner of the canvas. (If you donâ€™t do this, the button could be off the screen when the app runs.)</p>
</li>
<li class="calibre4">
<p class="calibre17">Examine the Debug â†’ Activate / Deactivate Breakpoints menu item. If it says Deactivate Breakpoints, choose it; we donâ€™t want to pause at any breakpoints you may have created while reading the previous chapter.</p>
</li>
<li class="calibre4">
<p class="calibre17">Make sure the destination in the Scheme pop-up menu is an iPhone simulator.</p>
</li>
<li class="calibre4">
<p class="calibre17">Choose Product â†’ Run (or click the Run button in the toolbar).</p>
</li>

</ol>

<p class="author1">After a heart-stopping pause, the Simulator opens, and presto, our empty window is empty no longer (<a data-type="xref" href="#calibre_link-2875" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-5</a>); it contains a button! You can tap this button with the mouse, emulating what the user would do with a finger; the button highlights as you tap it.</p>

<figure class="calibre32"><div id="calibre_link-2875" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-5. </span>The Empty Window appâ€™s window is empty no longer</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Inspectors and Libraries" class="calibre2"><div class="preface" id="calibre_link-2567">
<h2 class="calibre42">Inspectors and Libraries</h2>

<p class="author1">In addition to the File, History, and Quick Help inspectors, four inspectors appear in conjunction with the nib editor, and apply to whatever object is selected in the document outline, dock, or canvas:</p>
<dl class="calibre14">
<dt class="calibre15">Identity inspector (Command-Option-4)</dt>
<dd class="calibre16">
<p class="calibre17">The first section of this inspector, Custom Class, is the most important. Here you can learn &mdash; and can change &mdash; the selected objectâ€™s class.<a data-type="indexterm" data-primary="Identity inspector" id="calibre_link-1035" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="class" data-secondary="of object in nib, changing" id="calibre_link-366" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Attributes inspector (Command-Option-5)</dt>
<dd class="calibre16">
<p class="calibre17">Settings here correspond to properties and methods that you might use to configure the object in code.<a data-type="indexterm" data-primary="Attributes inspector" id="calibre_link-229" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> For example, selecting our view and choosing from the Background pop-up menu in the Attributes inspector corresponds to setting the viewâ€™s <code class="calibre19">backgroundColor</code> property in code.</p>

<p class="calibre17">The Attributes inspector has sections corresponding to the selected objectâ€™s class inheritance. For example, the UIButton Attributes inspector has three sections: in addition to a Button section, thereâ€™s a Control section (because a UIButton is also a UIControl) and a View section (because a UIControl is also a UIView).</p>
</dd>
<dt class="calibre15">Size inspector (Command-Option-6)</dt>
<dd class="calibre16">
<p class="calibre17">The X, Y, Width, and Height fields determine the objectâ€™s position and size within its superview, corresponding to its <code class="calibre19">frame</code> property in code; you can equally set these values in the canvas by dragging and resizing, but numeric precision can be desirable.<a data-type="indexterm" data-primary="Size inspector" id="calibre_link-2038" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Connections inspector (Command-Option-7)</dt>
<dd class="calibre16">
<p class="calibre17">Iâ€™ll demonstrate use of the Connections inspector later in this chapter.</p>
</dd>
</dl>

<p class="author1">The Library floating window can display three sorts of thing:<a data-type="indexterm" data-primary="library" id="calibre_link-1224" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Objects</dt>
<dd class="calibre16">
<p class="calibre17">Interface objects that you can add to the document outline or canvas.<a data-type="indexterm" data-primary="Objects library" id="calibre_link-1553" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Images</dt>
<dd class="calibre16">
<p class="calibre17">Image resources that youâ€™ve added to the app target or the assets catalog, plus the built-in system symbol images (new in Xcode 11 and iOS 13). If you drag an image onto a view that displays an image (such as a button), it becomes that viewâ€™s image. Otherwise, it becomes a UIImageView with that image.<a data-type="indexterm" data-primary="Media library" id="calibre_link-1274" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Colors</dt>
<dd class="calibre16">
<p class="calibre17">Named colors that you have created in the assets catalog.<a data-type="indexterm" data-primary="Colors library" id="calibre_link-469" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Loading a Nib" class="calibre2"><div class="preface" id="calibre_link-2568">
<h1 class="calibre18">Loading a Nib</h1>

<p class="author1">A nib file is a collection of <em class="calibre11">potential</em> instances &mdash; its nib objects. They become <em class="calibre11">actual</em> instances only if, while your app is running, the nib is <em class="calibre11">loaded</em>. At that moment, the nib objects described in the nib are effectively transformed into instances that are available to your app. I call this process &mdash; the loading of a nib and the resulting creation of instances &mdash; the <em class="calibre11">nib-loading mechanism.</em> We may speak as if a nib contains literal object instances; we may speak of â€œloadingâ€ or â€œinstantiatingâ€ a view controller or a view from a nib. But in fact the nib contains nothing but <em class="calibre11">instructions</em> for creating a view controller or view instance, and the nib-loading mechanism fulfills those instructions.<a data-type="indexterm" data-primary="loading a nib" id="calibre_link-1243" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="nib-based" id="calibre_link-1131" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nib files" data-secondary="loading" id="calibre_link-1397" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nib-loading mechanism" id="calibre_link-1403" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Using nibs as a source of instances is efficient. Interface is relatively heavyweight stuff. But a nib itself is just text; itâ€™s small. Moreover, a nib isnâ€™t loaded until it is needed; indeed, it might never be loaded. So this heavyweight stuff wonâ€™t come into existence until and unless it is about to be displayed.</p>

<p class="author1">Keep in mind that loading a nib is not the only way to create a view controller or a view. You can instantiate a view controller or a view in the same way as you instantiate any other class &mdash; by calling that classâ€™s initializer. You load a view controller or a view from a nib because you have designed and configured it in a nib (a <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> file) with the nib editor, and now you want your designs and configurations to come to life.</p>

<p class="author1">Thereâ€™s no such thing as â€œunloadingâ€ a nib. A nib is loaded, its nib objects are turned into instances, those instances are handed over to the running app, and thatâ€™s all; the nib has done its job. It is then up to the running app to decide what to do with the instances that just sprang to life. It must hang on to them for as long as it needs them, and will let them go out of existence when they are no longer needed. Typically, it will do this by adding them to the interface, where they will persist until that interface as a whole is removed.</p>

<p class="author1">The same nib file can be loaded multiple times, generating a new set of instances each time. Thus, a nib is a mechanism for reproducing a view controller or a view hierarchy as many times as necessary. A nib file might contain a piece of interface that you intend to use in several places in your app &mdash; possibly several places simultaneously.</p>

<p class="author1">There are three chief reasons why your running app might load a nib:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">To obtain a view controller.</p>
</li>
<li class="calibre12">
<p class="calibre17">To obtain a view controllerâ€™s main view.</p>
</li>
<li class="calibre12">
<p class="calibre17">To obtain some other view.</p>
</li>
</ul>

<p class="author1">Letâ€™s discuss them in turn.</p>








<section data-type="sect2" data-pdf-bookmark="Loading a View Controller" class="calibre2"><div class="preface" id="calibre_link-2569">
<h2 class="calibre42">Loading a View Controller</h2>

<p class="author1">A nib containing a view controller will almost certainly come from a storyboard. (A <em class="calibre11">.xib</em> file can contain a view controller, but it usually wonâ€™t.)
A storyboard is a collection of scenes. Each scene starts with a view controller. Each view controller in a storyboard ends up in an individual nib. When that view controller is needed, that nib is loaded.</p>

<p class="author1">A view controller may be loaded from a storyboard automatically (by the runtime) or manually (by your code):</p>
<dl class="calibre14">
<dt class="calibre15">Automatic creation of a view controller</dt>
<dd class="calibre16">
<p class="calibre17">As your app launches, if it has a main storyboard, the runtime looks for that storyboardâ€™s <em class="calibre11">initial view controller</em> (entry point) and loads its nib, turning it into a view controller instance to serve as the appâ€™s root view controller (<a data-type="xref" href="#calibre_link-69" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œHow an App Gets Goingâ€</a>).</p>

<p class="calibre17">In addition, a storyboard typically contains several scenes connected by segues; when a segue is performed, the destination sceneâ€™s view controller nib is loaded and turned into an instance.<a data-type="indexterm" data-primary="view controller" data-secondary="initial" id="calibre_link-2352" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Manual instantiation of a view controller</dt>
<dd class="calibre16">
<p class="calibre17">In code, to turn a view controller in a storyboard into a view controller instance, you start with a UIStoryboard instance, and call one of these methods:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">instantiateInitialViewController</code></dt>
<dd class="calibre16">
<p class="calibre17">Loads the storyboardâ€™s initial view controller nib and turns it into a view controller instance.</p>
</dd>
<dt class="calibre15"><code class="calibre19">instantiateViewController(withIdentifier:)</code></dt>
<dd class="calibre16">
<p class="calibre17">Loads the nib of any view controller within the storyboard whose scene is named by an identifier string, and turns it into a view controller instance.</p>
</dd>
</dl>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Loading a Main View" class="calibre2"><div class="preface" id="calibre_link-2570">
<h2 class="calibre42">Loading a Main View</h2>

<p class="author1">A view controller has a main view. But a view controller is a lightweight object (itâ€™s just some code), whereas its main view is a relatively heavyweight object &mdash; it is interface, and it may contain a lot of subviews. Therefore, a view controller, when it is instantiated, <em class="calibre11">lacks its main view</em>. It obtains its main view <em class="calibre11">later</em>, when that view is needed because it is to be placed into the interface. We say that a view controller loads its view <em class="calibre11">lazily</em>. A view controller can obtain its main view in several ways; one way is to load it from a nib. There are two main cases to consider:<a data-type="indexterm" data-primary="view controller" id="calibre_link-2349" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="main view of view controller" data-secondary="loaded from nib" id="calibre_link-1260" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="lazy loading of views" id="calibre_link-1212" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">View controller in a storyboard</dt>
<dd class="calibre16">
<p class="calibre17">When a view controller and its view belong to a scene in a storyboard, there are <em class="calibre11">two</em> nibs involved: the nib containing the view controller, and the nib containing the view. The nib containing the view controller was loaded in order to instantiate the view controller, as I just described; later, when that view controller instance needs its main view, it <em class="calibre11">automatically</em> loads that nib and generates its main view from it.</p>
</dd>
<dt class="calibre15">View controller instantiated in code</dt>
<dd class="calibre16">
<p class="calibre17">Another fairly common configuration is a view controller instantiated entirely in code, whose main view has been designed in a <em class="calibre11">.xib</em> file in your project. When you call the view controllerâ€™s designated initializer <code class="calibre19">init(nibName:bundle:)</code>, the <code class="calibre19">nibName:</code> parameter tells this view controller instance the name of the nib file generated from that <em class="calibre11">.xib</em> file. Subsequently, when the view controller needs its main view, it <em class="calibre11">automatically</em> loads that nib and generates its main view from it.</p>
</dd>
</dl>

<p class="author1">Those two ways of getting the view controllerâ€™s main view are actually the same. In each case, there is a view controller and an associated nib. The view controllerâ€™s <code class="calibre19">nibName</code> property is the key; it tells the view controller what nib to load in order to generate its main view when it needs it.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Loading a View Manually" class="calibre2"><div class="preface" id="calibre_link-2571">
<h2 class="calibre42">Loading a View Manually</h2>

<p class="author1">A view can be designed in a <em class="calibre11">.xib</em> file. This file is turned into a nib. Assume that this is <em class="calibre11">not</em> a view controllerâ€™s main view. To load that nib and create the view instance requires a call to one of these methods:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">loadNibNamed(_:owner:options:)</code></dt>
<dd class="calibre16">
<p class="calibre17">A Bundle instance method. Usually, youâ€™ll direct it to <code class="calibre19">Bundle.main</code>.</p>
</dd>
<dt class="calibre15"><code class="calibre19">instantiate(withOwner:options:)</code></dt>
<dd class="calibre16">
<p class="calibre17">A UINib instance method. The nib in question was specified when UINib was instantiated and initialized with <code class="calibre19">init(nibName:bundle:)</code>.</p>
</dd>
</dl>

<p class="author1">Sometimes the runtime will make those calls for you. For example, you can tell a table view (UITableView) to obtain its cells from a certain nib. A single nib file containing a table view cell might be loaded many times to generate the visible rows of the table.</p>

<p class="author1">Alternatively, you can make those calls yourself to load a nib view directly. Thatâ€™s the best way to explore and exercise the nib-loading mechanism. Letâ€™s try it!</p>

<p class="author1">First weâ€™ll create and configure a <em class="calibre11">.xib</em> file in our Empty Window project:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In the Empty Window project, choose File â†’ New â†’ File and specify iOS â†’ User Interface â†’ View. This will be a <em class="calibre11">.xib</em> file containing a UIView instance. Click Next.</p>
</li>
<li class="calibre4">
<p class="calibre17">In the Save dialog, accept the default name, View, for the new <em class="calibre11">.xib</em> file. Click <span class="publishername">Create.</span></p>
</li>
<li class="calibre4">
<p class="calibre17">We are now back in the Project navigator; our <em class="calibre11">View.xib</em> file has been created and selected, and weâ€™re looking at its contents in the editor. Those contents consist of a single UIView.</p>
</li>
<li class="calibre4">
<p class="calibre17">Our view is too large for purposes of this demonstration, so select it and, in the Attributes inspector, change the Size pop-up menu, under Simulated Metrics, to Freeform. Handles appear around the view in the canvas; drag them to make the view smaller. About 240Ã—200 would be a good size.</p>
</li>
<li class="calibre4">
<p class="calibre17">Populate the view with some arbitrary subviews by dragging them into it from the Library. You can also configure the view itself; for example, in the Attributes inspector, change its background color (<a data-type="xref" href="#calibre_link-2876" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-6</a>).</p>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2876" class="figure">
<img src="images/000028.png" alt="ios12 0706b" class="calibre58" />
<h6 class="calibre34"><span class="publishername">Figure 7-6. </span>Designing a view in a .xib file</h6>
</div>
</figure>

<p class="author1">Our goal now is to <em class="calibre11">load</em> this nib file, manually, in code, when the app runs. There are three tasks you have to perform when you load a nib:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Load the nib.</p>
</li>
<li class="calibre4">
<p class="calibre17">Obtain the instances that it creates as it loads.</p>
</li>
<li class="calibre4">
<p class="calibre17">Do something with those instances.</p>
</li>

</ol>

<p class="author1">Iâ€™ve already said that to load the nib we can call <code class="calibre19">loadNibNamed(_:owner:)</code>. This would be the complete code for loading our nib:</p>

<pre data-type="programlisting" class="calibre28">Bundle.main.loadNibNamed("View", owner: nil)</pre>

<p class="author1">Thatâ€™s the first task. But if thatâ€™s <em class="calibre11">all</em> we do, we will load the nib <em class="calibre11">to no effect</em>. The instances will be created and will then vanish in a puff of smoke. In order to prevent that, we need to <em class="calibre11">capture</em> those instances. Hereâ€™s one way to do that. The call to <code class="calibre19">loadNibNamed(_:owner:)</code> returns an array of instances created from the nibâ€™s top-level nib objects through the loading of that nib. Our nib contains just one top-level nib object &mdash; the UIView &mdash; so it is sufficient to capture the first (and only) element of this array:</p>

<pre data-type="programlisting" class="calibre28">let arr = Bundle.main.loadNibNamed("View", owner: nil)!
let v = arr[0] as! UIView</pre>

<p class="author1">We have now performed the second task: weâ€™ve captured an instance that we created by loading the nib. The variable <code class="calibre19">v</code> now refers to a brand-new UIView instance.</p>

<p class="author1">Now letâ€™s perform the third task &mdash; doing something with the view weâ€™ve just instantiated. A useful and dramatic thing to do with it, and probably the reason youâ€™d load a nib in the first place, is to put that view into your interface. Letâ€™s do that! Edit <em class="calibre11">ViewController.swift</em> and put these lines of code into its <code class="calibre19">viewDidLoad</code> method:</p>

<pre data-type="programlisting" class="calibre28">let arr = Bundle.main.loadNibNamed("View", owner: nil)!
let v = arr[0] as! UIView
self.view.addSubview(v)</pre>

<p class="author1">Build and run the app. Thereâ€™s our view, visible in the running appâ€™s interface. This proves that our loading of the nib worked (<a data-type="xref" href="#calibre_link-2877" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-7</a>).</p>

<figure class="calibre32"><div id="calibre_link-2877" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-7. </span>A nib-loaded view appears in our interface</h6>
</div>
</figure>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Connections" class="calibre2"><div class="preface" id="calibre_link-2572">
<h1 class="calibre18">Connections</h1>

<p class="author1">A <em class="calibre11">connection</em> is a directional linkage in the nib editor running from one object to another. Iâ€™ll call the two objects the <em class="calibre11">source</em> and the <em class="calibre11">destination</em> of the connection.<a data-type="indexterm" data-primary="connections" id="calibre_link-523" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> There are two kinds of connection: outlet connections and action connections. The rest of this section describes them, explains how to create and configure them, and discusses the nature of the problems that they are intended to solve.</p>








<section data-type="sect2" data-pdf-bookmark="Outlets" class="calibre2"><div class="preface" id="calibre_link-2573">
<h2 class="calibre42">Outlets</h2>

<p class="author1">When a nib loads and its instances come into existence, those instances are useless unless you can get a reference to them. In the preceding section, we solved that problem by capturing the array of instances returned from the loading of the nib. But thereâ€™s another way: use an outlet. This approach is more complicated &mdash; it requires some advance configuration, which can easily go wrong. But it is also more common, especially when nibs are loaded automatically.</p>

<p class="author1">An <em class="calibre11">outlet</em> is a connection that has a <em class="calibre11">name</em>, which is effectively just a string. When the nib loads, something unbelievably clever happens. The source object and the destination object are no longer just potential objects in a nib; they are now real, full-fledged instances. At that moment, the outletâ€™s name is used to locate an <em class="calibre11">instance property</em> with that same name in the outletâ€™s source object, and <em class="calibre11">the destination object is assigned to that property</em>. The source object now has a reference to the destination object!<a data-type="indexterm" data-primary="outlets" id="calibre_link-1640" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="connections" data-secondary="outlet" id="calibre_link-530" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="outlet connections" id="calibre_link-1638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, suppose that the following three things are true:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">As defined in code, a Dog has a <code class="calibre19">master</code> instance property which is typed as <span class="publishername">Person.</span></p>
</li>
<li class="calibre4">
<p class="calibre17">Thereâ€™s a Dog object and a Person object in a nib.</p>
</li>
<li class="calibre4">
<p class="calibre17">We make an outlet from the Dog object to the Person object in the nib, and we name that outlet <code class="calibre19">"master"</code>.</p>
</li>

</ol>

<p class="author1">In that case, when the nib loads and the Dog instance and the Person instance are created, that Person instance will be assigned as the value of that Dog instanceâ€™s <code class="calibre19">master</code> property (<a data-type="xref" href="#calibre_link-66" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-8</a>), just as if we had said <code class="calibre19">dog.master = person</code> in code.</p>

<figure class="calibre32"><div id="calibre_link-66" class="figure">
<img src="images/000022.png" alt="ios8 0707" class="calibre59" />
<h6 class="calibre34"><span class="publishername">Figure 7-8. </span>How an outlet provides a reference to a nib-instantiated object</h6>
</div>
</figure>

<p class="author1">As you can see, for an outlet to work, preparation must be performed in <em class="calibre11">two different places</em>: in the class of the source object, where the instance property is declared, and in the nib, where the outlet is created and configured. This is a bit tricky; Xcode does try to help you get it right, but it is still possible to mess it up. (I will discuss ways of messing it up, in detail, later in this chapter.)</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="The Nib Owner" class="calibre2"><div class="preface" id="calibre_link-2574">
<h2 class="calibre42">The Nib Owner</h2>

<p class="author1">Consider once again the view-loading example that we implemented earlier (illustrated in <a data-type="xref" href="#calibre_link-2877" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-7</a>). Letâ€™s implement that example again; this time, instead of assigning the nib-loaded view to a variable in code, weâ€™ll use an outlet connection to capture the nib-loaded view into a property.</p>

<p class="author1">Now, there is an important difference between the Dog-and-Person example I just outlined and the view-loading example. In our view-loading example, who is the Dog, and who is the Person? The Person is the view in the nib. But the Dog is the view controller (a ViewController instance) &mdash; and the view controller is <em class="calibre11">not in the nib.</em></p>

<p class="author1">For our view controller to use an outlet to capture a reference to a view instance created from a nib, therefore, we need an outlet that runs from an object <em class="calibre11">outside</em> the nib (the view controller) to an object <em class="calibre11">inside</em> the nib (the view). That seems metaphysically impossible &mdash; but it isnâ€™t. The nib editor cleverly permits such an outlet to be created, using the <em class="calibre11">nib owner object</em>.</p>

<p class="author1">Before I explain what the nib owner is, Iâ€™ll tell you where to find the nib owner object in the nib editor:</p>
<dl class="calibre14">
<dt class="calibre15">In a storyboard scene</dt>
<dd class="calibre16">
<p class="calibre17">In a storyboard scene, the nib owner is the view controller. It is the first object listed for that scene in the document outline, and the first object shown in the scene dock.<a data-type="indexterm" data-primary="proxy objects" id="calibre_link-1821" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nib owner" id="calibre_link-1400" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="owner" data-secondary="nib" id="calibre_link-1658" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">In a <em class="calibre11">.xib</em> file</dt>
<dd class="calibre16">
<p class="calibre17">In a <em class="calibre11">.xib</em> file, the nib owner is a proxy object. It is the first object shown in the document outline, listed under Placeholders as the Fileâ€™s Owner.<a data-type="indexterm" data-primary="Fileâ€™s Owner" id="calibre_link-854" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">So what <em class="calibre11">is</em> the nib owner object? Itâ€™s a proxy representing an instance that <em class="calibre11">already</em> exists <em class="calibre11">outside</em> the nib at the time that the nib is loaded. When the nib is loaded, the nib-loading mechanism <em class="calibre11">doesnâ€™t</em> instantiate any object; the nib owner is <em class="calibre11">already</em> an instance. Instead, the nib-loading mechanism <em class="calibre11">substitutes</em> the real, already existing instance for the nib owner object, using the real instance to fulfill any connections that involve the nib owner.</p>

<p class="author1">But wait! How does the nib-loading mechanism <em class="calibre11">know</em> what real, already existing instance to substitute for the nib owner object in the nib? It knows because it is told, in one of two ways, at nib-loading time:</p>
<dl class="calibre14">
<dt class="calibre15">Your code loads the nib</dt>
<dd class="calibre16">
<p class="calibre17">If your code loads a nib manually, either by calling <code class="calibre19">loadNibNamed(_:owner:options:)</code> or by calling <code class="calibre19">instantiate(withOwner:options:)</code>, you specify an owner object as the <code class="calibre19">owner:</code> argument.</p>
</dd>
<dt class="calibre15">A view controller loads the nib</dt>
<dd class="calibre16">
<p class="calibre17">If a view controller instance loads a nib automatically in order to obtain its main view, the view controller instance specifies <em class="calibre11">itself</em> as the owner object.</p>
</dd>
</dl>

<p class="author1">Letâ€™s do a thought-experiment with our Dog and Person objects. This time, suppose the following four things are true:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">As defined in code, a Dog has a <code class="calibre19">master</code> instance property which is typed as <span class="publishername">Person.</span></p>
</li>
<li class="calibre4">
<p class="calibre17">There is a Person nib object in our nib, but no Dog nib object.</p>
</li>
<li class="calibre4">
<p class="calibre17">We configure an outlet in the nib from the nib owner object to the Person object, and we name that outlet <code class="calibre19">"master"</code>. (We canâ€™t do that unless the nib owner objectâ€™s class is Dog, so weâ€™ll set its class first if necessary.)</p>
</li>
<li class="calibre4">
<p class="calibre17">When we load the nib, we specify an existing Dog instance as owner.</p>
</li>

</ol>

<p class="author1">The nib-loading mechanism will then <em class="calibre11">match</em> the Dog nib owner object with the already existing actual Dog instance that we specified as owner, and will assign the newly instantiated Person instance as <em class="calibre11">that</em> Dog instanceâ€™s <code class="calibre19">master</code> (<a data-type="xref" href="#calibre_link-2878" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-9</a>).</p>

<figure class="calibre32"><div id="calibre_link-2878" class="figure">
<img src="images/000016.png" alt="ios8 0708" class="calibre60" />
<h6 class="calibre34"><span class="publishername">Figure 7-9. </span>An outlet from the nib owner object</h6>
</div>
</figure>

<p class="author1">Back in the real world, letâ€™s reconfigure our Empty View nib-loading project to demonstrate this mechanism. Weâ€™re already loading the View nib in code in <em class="calibre11">ViewController.swift</em>. This code is running inside a ViewController instance. We want to use that instance as the nib owner. This will be a little tedious to configure, but bear with me, because understanding how it works is crucial:<a data-type="indexterm" data-primary="connections" data-secondary="creating" id="calibre_link-526" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">We need an instance property in ViewController. At the start of the body of the ViewController class declaration, insert the property declaration, like this:</p>

<pre data-type="programlisting" class="calibre38">class ViewController: UIViewController {
    @IBOutlet var coolview : UIView!</pre>

<p class="calibre17">The <code class="calibre19">var</code> declaration you already understand; weâ€™re making an instance property called <code class="calibre19">coolview</code>. It is declared as an Optional because it wonâ€™t have a â€œrealâ€ value when the ViewController instance is created; itâ€™s going to get that value later through the loading of the nib (<a data-type="xref" href="#calibre_link-71" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œDeferred initialization of propertiesâ€</a>). The <code class="calibre19">@IBOutlet</code> attribute is a hint to Xcode to allow us to create the outlet in the nib editor.<a data-type="indexterm" data-primary="IBOutlet" id="calibre_link-1026" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">Edit <em class="calibre11">View.xib</em>. Weâ€™d like to make the outlet, but in order to do that, we must ensure that the nib owner object is designated as a ViewController instance. Select the Fileâ€™s Owner proxy object and switch to the Identity inspector. In the first text field, under Custom Class, set the Class value as <code class="calibre19">ViewController</code>. Tab out of the text field and save.</p>
</li>
<li class="calibre4">
<p class="calibre17">Now weâ€™re ready to make the outlet! In the document outline, hold Control and <em class="calibre11">Control-drag</em> from the Fileâ€™s Owner object to the View; a little line follows the mouse as you drag. Release the mouse when the View is highlighted. A little HUD<a data-type="indexterm" data-primary="HUD" id="calibre_link-1023" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (heads-up display) appears, listing possible outlets we are allowed to create (<a data-type="xref" href="#calibre_link-2879" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-10</a>). There are two of them: <code class="calibre19">coolview</code> and <code class="calibre19">view</code>. Click <code class="calibre19">coolview</code> (<em class="calibre11">not</em> <code class="calibre19">view</code>!).<a data-type="indexterm" data-primary="heads-up display" id="calibre_link-1017" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">Finally, we need to modify our nib-loading code. We no longer need to capture the result of our call to <code class="calibre19">loadNibNamed(_:owner:)</code>. Thatâ€™s the whole point of this exercise! Instead, weâ€™re going to load the nib <em class="calibre11">with ourself as owner</em>. This will cause our <code class="calibre19">coolview</code> instance property to be set automatically:</p>

<pre data-type="programlisting" class="calibre38">Bundle.main.loadNibNamed("View", owner: self)
self.view.addSubview(self.coolview)</pre>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2879" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-10. </span>Creating an outlet</h6>
</div>
</figure>

<p class="author1">Build and run. It works! The first line loaded the nib, instantiated the view, <em class="calibre11">and set our <code class="calibre22">coolview</code> instance property</em> to that view. Thus, the second line can display <code class="calibre19">self.coolview</code> in the interface, because <code class="calibre19">self.coolview</code> now <em class="calibre11">is</em> that view.</p>

<p class="author1">Letâ€™s sum up what we just did. Our preparatory configuration was a little tricky, because it was performed in two places &mdash; in code, and in the nib:</p>
<dl class="calibre14">
<dt class="calibre15">In code</dt>
<dd class="calibre16">
<p class="calibre17">There must be an <em class="calibre11">instance property</em> in the class whose instance will act as owner when the nib loads. It must be <em class="calibre11">marked</em> as <code class="calibre19">@IBOutlet</code>; otherwise, Xcode wonâ€™t permit us to create the outlet in the nib editor.</p>
</dd>
<dt class="calibre15">In the nib editor</dt>
<dd class="calibre16">
<p class="calibre17">The <em class="calibre11">class of the nib owner object</em> must be set to the class whose instance will act as owner when the nib loads; otherwise, Xcode <em class="calibre11">still</em> wonâ€™t permit us to create the outlet. We must then <em class="calibre11">create the outlet</em>, with the same name as the property, from the nib owner to some nib object.</p>
</dd>
</dl>

<p class="author1">If all those things are true, then, when the nib loads, <em class="calibre11">if</em> it is loaded with an owner of the correct class, that ownerâ€™s instance property will be set to the outlet destination.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">When you configure an outlet to an object in the nib, that objectâ€™s name as listed in the document outline ceases to be generic (e.g. â€œViewâ€) and takes on the name of the outlet (e.g. â€œcoolviewâ€). This name is still just a label &mdash; it has no effect on the operation of the outlet &mdash; and you can change it in the Identity inspector.<a data-type="indexterm" data-primary="labels" data-secondary="nib editor" data-tertiary="changed by outlet" id="calibre_link-1199" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Automatically Configured Nibs" class="calibre2"><div class="preface" id="calibre_link-2575">
<h2 class="calibre42">Automatically Configured Nibs</h2>

<p class="author1">Now that weâ€™ve created a nib owner outlet <em class="calibre11">manually</em> and loaded a nib <em class="calibre11">manually</em>, we have demystified the nib-loading mechanism.
When a view controller gets its main view from a nib <em class="calibre11">automatically</em>, everything works exactly like what we just did.</p>

<p class="author1">Consider our Empty Window projectâ€™s <em class="calibre11">Main.storyboard</em>, with its single scene consisting of a ViewController and its main view:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">In our manual example, we started with an instance property in our nib owner class. Well, ViewController is a UIViewController, and UIViewController has an instance property &mdash; its <code class="calibre19">view</code> property! This is the property that needs to be set in order for the view controller to obtain its main view.</p>
</li>
<li class="calibre12">
<p class="calibre17">In our manual example, in the nib editor, we made sure that the nib owner objectâ€™s class would be the class of the owner when the nib loads. Well, in our <em class="calibre11">Main.storyboard</em> scene, the View Controller object <em class="calibre11">is</em> the nib owner, and it <em class="calibre11">is</em> of the correct class, namely ViewController (the class declared in the <em class="calibre11">ViewController.swift</em> file). Look and see: select the ViewController object in the storyboard and examine its class in the Identity inspector.</p>
</li>
<li class="calibre12">
<p class="calibre17">In our manual example, in the nib editor, we created an outlet with the same name as the owner instance property, leading from the owner to the nib object. Well, in our <em class="calibre11">Main.storyboard</em> scene, the ViewController object <em class="calibre11">is</em> the view nib owner, and it <em class="calibre11">has</em> an outlet named <code class="calibre19">view</code> which <em class="calibre11">is</em> connected to the main view. Look and see: select the view controller object in the storyboard and examine its Connections inspector (<a data-type="xref" href="#calibre_link-2880" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-11</a>).<a data-type="indexterm" data-primary="Connections inspector" id="calibre_link-533" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<figure class="calibre32"><div id="calibre_link-2880" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-11. </span>A view controllerâ€™s view outlet connection</h6>
</div>
</figure>

<p class="author1">Thus, the storyboard has <em class="calibre11">already</em> been configured in a manner exactly parallel to how we configured <em class="calibre11">View.xib</em> in the preceding section. And the result is exactly the same! When the view controller needs its view, it loads the view nib with itself as owner, the nib-loading mechanism sees the connected <code class="calibre19">view</code> outlet, the view at the destination of that outlet is assigned to the view controllerâ€™s <code class="calibre19">view</code> property, and voilÃ ! The view controller has its main view.</p>

<p class="author1">Moreover, the view controllerâ€™s main view is then placed into the interface. And <em class="calibre11">that</em> is why whatever we design in this view in the storyboard, such as putting into it a button whose title is â€œHello,â€ actually appears in the interface when the app runs.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Misconfigured Outlets" class="calibre2"><div class="preface" id="calibre_link-67">
<h2 class="calibre42">Misconfigured Outlets</h2>

<p class="author1">Setting up an outlet to work correctly involves several things being true at the same time. You should expect that at some point in the future you will fail to get this right, and your outlet wonâ€™t work properly. So be prepared! And donâ€™t worry; this happens to everyone. The important thing is to recognize the symptoms so that you know whatâ€™s gone wrong. Weâ€™re deliberately going to make things go wrong, so that we can explore the main ways for an outlet to be incorrectly configured:<a data-type="indexterm" data-primary="outlets" data-secondary="misconfiguring" id="calibre_link-1643" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Outlet name doesnâ€™t match a property name in the source class</dt>
<dd class="calibre16">
<p class="calibre17">Start with our working Empty Window example. Run the project to prove that all is well. Now, in <em class="calibre11">ViewController.swift</em>, change the property name to <code class="calibre19">badview</code>:</p>

<pre data-type="programlisting" class="calibre28">@IBOutlet var badview : UIView!</pre>

<p class="calibre17">In order to get the code to compile, youâ€™ll also have to change the reference to this property in <code class="calibre19">viewDidLoad</code>:</p>

<pre data-type="programlisting" class="calibre28">self.view.addSubview(self.badview)</pre>

<p class="calibre17">The code compiles just fine. But when you run it, the app crashes with this message in the console: â€œThis class is not key value coding-compliant for the key <code class="calibre19">coolview</code>.â€<a data-type="indexterm" data-primary="crash" data-secondary="class not keyâ€“value coding compliant" id="calibre_link-561" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">That message is just a technical way of saying that the name of the outlet in the nib (which is still <code class="calibre19">coolview</code>) doesnâ€™t match the name of any property of the nibâ€™s owner when the nib loads &mdash; because we changed the name of that property to <code class="calibre19">badview</code> and thus wrecked the configuration. In effect, we had everything set up correctly, but then we went behind the nib editorâ€™s back and removed the corresponding instance property from the outlet sourceâ€™s class. When the nib loads, the runtime canâ€™t match the outletâ€™s name with any property in the outletâ€™s source &mdash; the ViewController instance &mdash; and we crash.</p>

<p class="calibre17">There are other ways to bring about this same misconfiguration. For example, you could change things so that the nib owner is an instance of <em class="calibre11">the wrong class</em>. You might do that in the nib editor, by selecting the nib owner and changing its class in the Identity inspector. Alternatively, you might do it in code:</p>

<pre data-type="programlisting" class="calibre28">Bundle.main.loadNibNamed("View", owner: NSObject())</pre>

<p class="calibre17">We made the <code class="calibre19">owner</code> a plain vanilla NSObject instance. The NSObject class has no property with the same name as the outlet, so the app crashes when the nib loads, complaining about the owner not being â€œkey value coding-compliant.â€</p>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">To change an outlet propertyâ€™s name <em class="calibre11">without</em> breaking the connection from the nib, select the property name in code and choose Editor â†’ Refactor â†’ Rename.</p>
</div>
<dl class="calibre14">
<dt class="calibre15">No outlet in the nib</dt>
<dd class="calibre16">
<p class="calibre17">Fix the problem from the previous example by changing both references to the property name from <code class="calibre19">badview</code> back to <code class="calibre19">coolview</code> in <em class="calibre11">ViewController.swift</em>. Run the project to prove that all is well. Now weâ€™re going to mess things up at the other end! Edit <em class="calibre11">View.xib</em>. Select the Fileâ€™s Owner and switch to the Connections inspector, and disconnect the <code class="calibre19">coolview</code> outlet by clicking the X at the left end of the second cartouche. Run the project. We crash with this error message in the console: â€œFatal error: unexpectedly found <code class="calibre19">nil</code> while unwrapping an Optional value.â€<a data-type="indexterm" data-primary="crash" data-secondary="unexpectedly found nil" id="calibre_link-570" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">We removed the outlet from the nib. So when the nib loaded, our ViewController instance property <code class="calibre19">coolview</code>, which is typed as an implicitly unwrapped Optional wrapping a UIView, was <em class="calibre11">never set to anything</em>. Thus, it kept its initial value, which is <code class="calibre19">nil</code>. We then tried to <em class="calibre11">use</em> the implicitly unwrapped Optional by putting it into the interface:</p>

<pre data-type="programlisting" class="calibre28">self.view.addSubview(self.coolview)</pre>

<p class="calibre17">Swift tries to obey by unwrapping the Optional, but you canâ€™t unwrap <code class="calibre19">nil</code>, so we crash.</p>
</dd>
<dt class="calibre15">No view outlet</dt>
<dd class="calibre16">
<p class="calibre17">I canâ€™t demonstrate this problem using a <em class="calibre11">.storyboard</em> file. What weâ€™d like to do is <em class="calibre11">disconnect</em> the <code class="calibre19">view</code> outlet in <em class="calibre11">Main.storyboard</em>, but the storyboard editor guards against this. But if you <em class="calibre11">could</em> make this mistake, then trying to run the project would result in a crash at launch time, with a console message complaining that â€œthe view outlet was not set.â€<a data-type="indexterm" data-primary="crash" data-secondary="loaded nib but view outlet was not set" id="calibre_link-566" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">A nib that is to serve as the source of a view controllerâ€™s main view <em class="calibre11">must</em> have a connected <code class="calibre19">view</code> outlet from the view controller (the nib owner object) to the view. In a <em class="calibre11">.xib</em> file whose view is to function as a view controllerâ€™s main view, you <em class="calibre11">can</em> make this mistake &mdash; usually by forgetting to connect the Fileâ€™s Owner <code class="calibre19">view</code> outlet to the view in the first place.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Deleting an Outlet" class="calibre2"><div class="preface" id="calibre_link-2576">
<h2 class="calibre42">Deleting an Outlet</h2>

<p class="author1">Deleting an outlet coherently &mdash; that is, without causing one of the problems described in the previous section &mdash; involves working in several places at once, just as creating an outlet does. I recommend proceeding in this order:<a data-type="indexterm" data-primary="outlets" data-secondary="deleting" id="calibre_link-1642" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="deleting an outlet" id="calibre_link-645" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="connections" data-secondary="deleting" id="calibre_link-529" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Disconnect the outlet in the nib.</p>
</li>
<li class="calibre4">
<p class="calibre17">Remove the outlet declaration from the code.</p>
</li>
<li class="calibre4">
<p class="calibre17">Attempt compilation and let the compiler catch any remaining issues for you.</p>
</li>

</ol>

<p class="author1">Letâ€™s suppose that you decide to delete the <code class="calibre19">coolview</code> outlet from the Empty Window project. You would follow the same three-step procedure that I just outlined:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Disconnect the outlet in the nib. To do so, edit <em class="calibre11">View.xib</em>, select the source object (the Fileâ€™s Owner proxy object), and disconnect the <code class="calibre19">coolview</code> outlet in the Connections inspector by clicking the X.<a data-type="indexterm" data-primary="Connections inspector" id="calibre_link-534" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">Remove the outlet declaration from the code. To do so, edit <em class="calibre11">ViewController.swift</em> and delete or comment out the <code class="calibre19">@IBOutlet</code> declaration line.</p>
</li>
<li class="calibre4">
<p class="calibre17">Now attempt to build the project; the compiler issues an error on the line referring to <code class="calibre19">self.coolview</code> in <em class="calibre11">ViewController.swift</em>, because there is now no such property. Delete or comment out that line, and build again to prove that all is well.</p>
</li>

</ol>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="More Ways to Create Outlets" class="calibre2"><div class="preface" id="calibre_link-2577">
<h2 class="calibre42">More Ways to Create Outlets</h2>

<p class="author1">Earlier, we created an outlet like this:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In a class file, we declared an <code class="calibre19">@IBOutlet</code> instance property in a class file.</p>
</li>
<li class="calibre4">
<p class="calibre17">In the nib editor, we control-dragged from the source to the destination in the document outline and chose the desired outlet property from the HUD (heads-up display).</p>
</li>

</ol>

<p class="author1">Xcode provides many other ways to create outlets &mdash; too many to list here. Iâ€™ll survey some of the most interesting. Weâ€™ll continue to use the Empty Window project and the <em class="calibre11">View.xib</em> file. All of this works exactly the same way for a <em class="calibre11">.storyboard</em> file.<a data-type="indexterm" data-primary="creating an outlet" id="calibre_link-578" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="outlets" data-secondary="creating" id="calibre_link-1641" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="connections" data-secondary="creating" id="calibre_link-527" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To prepare, delete the outlet in <em class="calibre11">View.xib</em> as I described in the previous section (if you havenâ€™t already done so). In <em class="calibre11">ViewController.swift</em>, create (or uncomment) the property declaration, and save:</p>

<pre data-type="programlisting" class="calibre28">@IBOutlet var coolview : UIView!</pre>

<p class="author1">Now weâ€™re ready to experiment:</p>
<dl class="calibre14">
<dt class="calibre15">Drag from source Connections inspector</dt>
<dd class="calibre16">
<p class="calibre17">You can drag from a circle in the Connections inspector in the nib editor to connect the outlet. In <em class="calibre11">View.xib</em>, select the Fileâ€™s Owner and switch to the Connections inspector. The <code class="calibre19">coolview</code> outlet is listed here, but it isnâ€™t connected: the circle at its right is open. Drag from the circle next to <code class="calibre19">coolview</code> to the UIView object in the nib. You can drag to the view in the canvas or in the document outline. You donâ€™t need to hold Control as you drag from the circle, and thereâ€™s no HUD because youâ€™re dragging from a specific outlet, so Xcode knows which one you mean.</p>
</dd>
<dt class="calibre15">Drag from destination Connections inspector</dt>
<dd class="calibre16">
<p class="calibre17">Now letâ€™s make that same move the other way round. Delete the outlet in the nib. Select the View and look at the Connections inspector. We want an outlet that has this view as its destination: thatâ€™s a â€œreferencing outlet.â€ Drag from the circle next to New Referencing Outlet to the Fileâ€™s Owner object. The HUD appears: click <code class="calibre19">coolview</code> to make the outlet connection.</p>
</dd>
<dt class="calibre15">Drag from source HUD</dt>
<dd class="calibre16">
<p class="calibre17">You can summon a HUD that effectively is the same as the Connections inspector. Letâ€™s start with that HUD. Again delete the outlet in the Connections inspector. Control-click the Fileâ€™s Owner. A HUD appears, looking a lot like the Connections inspector! Drag from the circle at the right of <code class="calibre19">coolview</code> to the UIView.</p>
</dd>
<dt class="calibre15">Drag from destination HUD</dt>
<dd class="calibre16">
<p class="calibre17">Again, letâ€™s make that same move the other way round. Delete the outlet in the Connections inspector. Either in the canvas or in the document outline, Control-click the view. Thereâ€™s the HUD showing its Connections inspector. Drag from the New Referencing Outlet circle to the Fileâ€™s Owner. A second HUD appears, listing possible outlets; click <code class="calibre19">coolview</code>.</p>
</dd>
</dl>

<p class="author1">Again, delete the outlet. Now weâ€™re going to create the outlet by dragging <em class="calibre11">between the code and the nib editor</em>. This will require that you work in two places at once: youâ€™re going to need two editor panes (see <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>). In one editor pane, show <em class="calibre11">ViewController.swift</em>. In the other editor pane, show <em class="calibre11">View.xib</em>, in such a way that the view is visible.</p>
<dl class="calibre14">
<dt class="calibre15">Drag from property declaration to nib</dt>
<dd class="calibre16">
<p class="calibre17">Next to the property declaration in the code, in the gutter, is an empty circle. Drag from that circle <em class="calibre11">right across the barrier</em> to the View in the nib editor (<a data-type="xref" href="#calibre_link-2881" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-12</a>). Youâ€™ve done it! The outlet connection has been formed in the nib; you can see this by looking at the Connections inspector, and also because, back in the code, the circle in the gutter is now filled in.</p>

<p class="calibre17">You can hover over the filled circle, or click it, to learn what the outlet in the nib is connected to. You can click the little menu that appears when you click in the filled circle to navigate to the destination object.</p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-2881" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-12. </span>Connecting an outlet by dragging from code to nib editor</h6>
</div>
</figure>

<p class="author1">Hereâ€™s one more way &mdash; the most amazing of all. Keep the two-pane arrangement from the preceding example. Again, delete the outlet (you will probably need to use the Connections inspector or HUD in the nib editor pane to do this). Also delete the <code class="calibre19">@IBOutlet</code> line from the code! Weâ€™re going to create the property declaration and connect the outlet, <em class="calibre11">in a single move!</em></p>
<dl class="calibre14">
<dt class="calibre15">Drag from nib to code</dt>
<dd class="calibre16">
<p class="calibre17">Control-drag from the view in the nib editor across the pane barrier to just inside the body of the <code class="calibre19">class ViewController</code> declaration. A HUD offers to Insert Outlet or Outlet Collection (<a data-type="xref" href="#calibre_link-2882" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-13</a>). Release the mouse. A popover appears, where you can configure the declaration to be inserted into your code. Configure it as shown in <a data-type="xref" href="#calibre_link-2883" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-14</a>: you want an outlet, and this property should be named <code class="calibre19">coolview</code>. Click Connect. The property declaration is inserted into your code, and the outlet is connected in the nib.</p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-2882" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-13. </span>Creating an outlet by dragging from nib editor to code</h6>
</div>
</figure>

<figure class="calibre32"><div id="calibre_link-2883" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-14. </span>Configuring a property declaration</h6>
</div>
</figure>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Making an outlet by connecting directly between code and the nib editor is cool and convenient, but donâ€™t be fooled: thereâ€™s no such direct connection. There are always, if an outlet is to work properly, <em class="calibre11">two distinct and separate things</em> &mdash; an instance property in a class, and an outlet in the nib <em class="calibre11">with the same name</em> and <em class="calibre11">coming from an instance of that class</em>. It is the identity of the names and classes that allows the two to be matched at runtime when the nib loads. Xcode tries to help you get everything set up correctly, but it is <em class="calibre11">not</em> in fact magically connecting the code to the nib.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Outlet Collections" class="calibre2"><div class="preface" id="calibre_link-2578">
<h2 class="calibre42">Outlet Collections</h2>

<p class="author1">An <em class="calibre11">outlet collection</em><a data-type="indexterm" data-primary="outlet collections" id="calibre_link-1637" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is an <em class="calibre11">array</em> instance property (in code) matched (in a nib) by <em class="calibre11">multiple</em> connections to objects of the same type.</p>

<p class="author1">For example, suppose a class contains this property declaration:</p>

<pre data-type="programlisting" class="calibre28">@IBOutlet var coollabels: [UILabel]!</pre>

<p class="author1">The outcome is that, in the nib editor, with an instance of this class selected, the Connections inspector lists <code class="calibre19">coollabels</code> &mdash; not under Outlets, but under Outlet Collections. This means that you can form multiple <code class="calibre19">coollabels</code> outlets, each one connected to a different UILabel object in the nib. When the nib loads, those UILabel instances become the elements of the array <code class="calibre19">coollabels</code>; the order of elements in the array is the order in which the outlets were formed. Your code can then refer to the labels by number (the index into the array). This can be cleaner than having a separate instance property for each label.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Action Connections" class="calibre2"><div class="preface" id="calibre_link-2579">
<h2 class="calibre42">Action Connections</h2>

<p class="author1">An action connection, like an outlet connection, is a way of giving one object in a nib a reference to another. But, unlike an outlet connection, itâ€™s not a property reference; itâ€™s a <em class="calibre11">message-sending</em> <span class="publishername">reference.</span><a data-type="indexterm" data-primary="connections" data-secondary="action" id="calibre_link-524" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="actions" data-secondary="connections" id="calibre_link-116" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="actions" id="calibre_link-113" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">An <em class="calibre11">action</em> is a message emitted automatically by a Cocoa UIControl<a data-type="indexterm" data-primary="UIControl" id="calibre_link-2254" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> interface object (a <em class="calibre11">control</em>), sent to another object when the user does something to it, such as tapping the control. The various user behaviors that will cause a control to emit an action message are called <em class="calibre11">events</em>.<a data-type="indexterm" data-primary="events" id="calibre_link-811" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="control events" id="calibre_link-549" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> To see a list of possible events, look at the <span class="publishername">UIControl.Event</span> documentation. For example, in the case of a UIButton, the user tapping the button corresponds to the <code class="calibre19">UIControl.Event.touchUpInside</code> event.</p>

<p class="author1">For this architecture to work, the control object must know three things:</p>
<dl class="calibre14">
<dt class="calibre15">Control event</dt>
<dd class="calibre16">
<p class="calibre17">What control event to respond to.</p>
</dd>
<dt class="calibre15">Action</dt>
<dd class="calibre16">
<p class="calibre17">What message to send (that is, what method to call) when that control event occurs.</p>
</dd>
<dt class="calibre15">Target</dt>
<dd class="calibre16">
<p class="calibre17">What object to send that message to.</p>
</dd>
</dl>

<p class="author1">An action connection in a nib builds the knowledge of those three things into itself. It has the control object as its source; its destination is the target; and you tell the action connection, as you form it, what the control event and action message should be. To form the action connection, you need to configure the class of the <em class="calibre11">destination</em> object so that it has an instance method suitable as an action message.</p>

<p class="author1">To experiment with action connections, weâ€™ll need a UIControl object in a nib, such as a button. You may already have such a button in the Empty Window projectâ€™s <em class="calibre11">Main.storyboard</em> file. However, itâ€™s probable that, when the app runs, weâ€™ve been covering the button with the view that weâ€™re loading from <em class="calibre11">View.xib</em>. So first clear out the ViewController class declaration body in <em class="calibre11">ViewController.swift</em>, so that there is no outlet property and no manual nib-loading code; this should be all thatâ€™s left:</p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
}</pre>

<p class="author1">Now letâ€™s arrange to use the view controller in our Empty Window project as a target for an action message emitted by the buttonâ€™s <code class="calibre19">.touchUpInside</code> event (meaning that the button was tapped). Weâ€™ll need a method in the view controller that will be called by the button when the button is tapped. To make this method dramatic and obvious, weâ€™ll have the view controller put up an alert window. Insert this method into the <em class="calibre11">ViewController.swift</em> declaration body:</p>

<pre data-type="programlisting" class="calibre28">@IBAction func buttonPressed(_ sender: Any) {
    let alert = UIAlertController(
        title: "Howdy!", message: "You tapped me!", preferredStyle: .alert)
    alert.addAction(
        UIAlertAction(title: "OK", style: .cancel))
    self.present(alert, animated: true)
}</pre>

<p class="author1">The <code class="calibre19">@IBAction</code> attribute is like <code class="calibre19">@IBOutlet</code>: itâ€™s a hint to Xcode itself, asking Xcode to make this method available in the nib editor. And indeed, if we look in the nib editor, we find that it <em class="calibre11">is</em> now available: edit <em class="calibre11">Main.storyboard</em>, select the View Controller object and switch to the Connections inspector, and youâ€™ll find that <code class="calibre19">buttonPressed:</code>, which is the Objective-C name of our action method, is now listed under Received Actions.<a data-type="indexterm" data-primary="IBAction" id="calibre_link-1024" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In <em class="calibre11">Main.storyboard</em>, in the single scene that it contains, the top-level View Controllerâ€™s View should contain a button. (We created it earlier in this chapter: see <a data-type="xref" href="#calibre_link-2874" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-4</a>.) If it doesnâ€™t, add one, and position it in the upper left corner of the view. Our goal now is to connect that buttonâ€™s Touch Up Inside event, as an action, to the <code class="calibre19">buttonPressed(_:)</code> method in ViewController.</p>

<p class="author1">As with an outlet connection, there is a source and a destination. The source here is the button in the storyboard; the destination is the ViewController instance acting as owner of the nib containing the button. There are many ways to form this action connection, all of them completely parallel to the formation of an outlet connection. The difference is that we must configure <em class="calibre11">both</em> ends of the connection. At the button (source) end, we must specify that the control event we want to use is Touch Up Inside; fortunately, this is the default for a UIButton, so we might be able to skip this step. At the view controller (destination) end, we must specify that the action method to be called is our <code class="calibre19">buttonPressed(_:)</code> method.</p>

<p class="author1">Letâ€™s form the action connection by Control-dragging from the button to the view controller in the nib editor:<a data-type="indexterm" data-primary="actions" data-secondary="connections" data-tertiary="creating" id="calibre_link-117" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="creating an action connection" id="calibre_link-573" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="connections" data-secondary="creating" id="calibre_link-528" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Control-drag from the button (in the canvas or in the document outline) to the View Controller listing in the document outline (or to the view controller icon in the scene dock above the view in the canvas).</p>
</li>
<li class="calibre4">
<p class="calibre17">A HUD listing possible connections appears (<a data-type="xref" href="#calibre_link-2884" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-15</a>); it lists mostly segues, but it also lists Sent Events, and in particular it lists <code class="calibre19">buttonPressed:</code>.</p>
</li>
<li class="calibre4">
<p class="calibre17">Click the <code class="calibre19">buttonPressed:</code> listing in the HUD.</p>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2884" class="figure">
<img src="images/000012.png" alt="ios10 0715" class="calibre61" />
<h6 class="calibre34"><span class="publishername">Figure 7-15. </span>A HUD showing an action method</h6>
</div>
</figure>

<p class="author1">The action connection has now been formed. This means that when the app runs, any time the button gets a Touch Up Inside event &mdash; meaning that it was tapped &mdash; it will call the <code class="calibre19">buttonPressed(_:)</code> method in the target, which is the view controller instance. We know what that method should do: it should put up an alert. Try it! Build and run the app, and when the app appears in the Simulator, tap the button. It works!</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="More Ways to Create Actions" class="calibre2"><div class="preface" id="calibre_link-2580">
<h2 class="calibre42">More Ways to Create Actions</h2>

<p class="author1">Other ways to form the action connection in the nib, having created the action method in <em class="calibre11">ViewController.swift</em>, include the following:</p>
<dl class="calibre14">
<dt class="calibre15">Drag from source Connections inspector</dt>
<dd class="calibre16">
<p class="calibre17">Select the button and use the Connections inspector. Drag from the Touch Up Inside circle to the view controller. A HUD appears, listing the known action methods in the view controller; click <code class="calibre19">buttonPressed:</code>.</p>
</dd>
<dt class="calibre15">Drag from source HUD</dt>
<dd class="calibre16">
<p class="calibre17">Control-click the button. A HUD appears, similar to the Connections inspector. Proceed as in the previous case.</p>
</dd>
<dt class="calibre15">Drag from destination HUD</dt>
<dd class="calibre16">
<p class="calibre17">Control-click the view controller. A HUD appears, similar to the Connections inspector. Drag from <code class="calibre19">buttonPressed:</code> (under Received Actions) to the button. Another HUD appears, listing possible control events. Click Touch Up Inside.</p>
</dd>
<dt class="calibre15">Drag from action method to nib</dt>
<dd class="calibre16">
<p class="calibre17">Make two editor panes. Arrange to see <em class="calibre11">ViewController.swift</em> in one pane and the storyboard in the other. The <code class="calibre19">buttonPressed(_:)</code> declaration in <em class="calibre11">ViewController.swift</em> has a circle to its left, in the gutter. Drag from that circle across the pane barrier to the button in the nib.</p>
</dd>
</dl>

<p class="author1">As with an outlet connection, the most impressive way to make an action connection is to drag from the nib editor to your code, inserting the action method and forming the action connection in the nib <em class="calibre11">in a single move</em>. To try this, first delete the <code class="calibre19">buttonPressed(_:)</code> method in your code and delete the action connection in the nib. Make two editor panes. Arrange to see <em class="calibre11">ViewController.swift</em> in one pane and the storyboard in the other. Now:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Control-drag from the button in the nib editor to an empty area in the ViewController class declarationâ€™s body. A HUD offering to create an outlet <em class="calibre11">or an action</em> appears in the code. Release the mouse.</p>
</li>
<li class="calibre4">
<p class="calibre17">The popover view appears:</p>
<ol class="calibre6">
<li class="calibre4">
<p class="calibre17">Always look first at the Connection pop-up menu. It <em class="calibre11">might</em> be offering to create an outlet connection. That isnâ€™t what you want; you want an action connection! If it says Outlet, <em class="calibre11">change</em> it to Action.</p>
</li>
<li class="calibre4">
<p class="calibre17">Enter the name of the action method (here, <code class="calibre19">buttonPressed</code>) and configure the rest of the declaration. The defaults are probably good enough: see <a data-type="xref" href="#calibre_link-2885" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-16</a>.</p>
</li>

</ol>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-2885" class="figure">
<img src="images/000024.png" alt="ios11 0716" class="calibre62" />
<h6 class="calibre34"><span class="publishername">Figure 7-16. </span>Configuring an action method declaration</h6>
</div>
</figure>

<p class="author1">Xcode forms the action connection in the nib, and inserts a stub method into your code:</p>

<pre data-type="programlisting" class="calibre28">@IBAction func buttonPressed(_ sender: Any) {
}</pre>

<p class="author1">The method is just a stub (Xcode canâ€™t read your mind and guess what you want the method to do), so in real life, at this point, youâ€™d insert some functionality between those curly braces. As with an outlet connection, the filled circle next to the code in an action method tells you that Xcode believes that this connection is correctly configured, and you can click the filled circle to learn, and navigate to, the object at the source of the connection.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Misconfigured Actions" class="calibre2"><div class="preface" id="calibre_link-2581">
<h2 class="calibre42">Misconfigured Actions</h2>

<p class="author1">As with an outlet connection, configuring an action connection involves setting things up correctly at both ends (the nib and the code) so that they match. Thus, you can wreck an action connectionâ€™s configuration and crash your app. The typical misconfiguration is that the name of the action method as embedded in the action connection in the nib no longer matches the name of the action method in the code.<a data-type="indexterm" data-primary="actions" data-secondary="misconfiguring" id="calibre_link-119" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To see this, change the name of the action method in the code from <code class="calibre19">buttonPressed</code> to something else, like <code class="calibre19">buttonPushed</code>. Now run the app and tap the button. Your app crashes, displaying in the console this dreaded error message: â€œUnrecognized selector sent to instance.â€ A selector is a message &mdash; the name of a method (<a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>). The runtime tried to send a message to an object, but that object turned out to have no corresponding method (because we renamed it). If you look a little earlier in the error message, it even tells you the name of this method:<a data-type="indexterm" data-primary="crash" data-secondary="unrecognized selector" id="calibre_link-572" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">-[Empty_Window.ViewController buttonPressed:]</pre>

<p class="author1">The runtime is telling you (using Objective-C notation) that it tried to call the <code class="calibre19">buttonPressed(_:)</code> method in your Empty Window moduleâ€™s ViewController class, but the ViewController class has no such method.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">To change an action methodâ€™s name <em class="calibre11">without</em> breaking the connection from the nib, select the method name in code and choose Editor â†’ Refactor â†’ Rename.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Connections Between Nibs â€” Not!" class="calibre2"><div class="preface" id="calibre_link-2582">
<h2 class="calibre42">Connections Between Nibs &mdash; Not!</h2>

<p class="author1">You cannot draw an outlet connection or an action connection between an object in a nib and an object in a <em class="calibre11">different</em> nib. For example:<a data-type="indexterm" data-primary="nibs" data-secondary="connections between" id="calibre_link-1404" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="connections" data-secondary="between nibs" id="calibre_link-525" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">You canâ€™t open nib editors on two different <em class="calibre11">.xib</em> files and Control-drag a connection from one to the other.</p>
</li>
<li class="calibre12">
<p class="calibre17">In a <em class="calibre11">.storyboard</em> file, you cannot Control-drag a connection between an object in one scene and an object in another scene.</p>
</li>
</ul>

<p class="author1">The reason is obvious when you consider what a nib <em class="calibre11">is</em>. Objects in a nib together will become instances together, at the moment when the nib loads, so it makes sense to connect them in that nib, because we know what instances weâ€™ll be talking about when the nib loads. The two objects may both be instantiated by loading the nib, or one of them may be a proxy object (the nib owner), but they must both be represented <em class="calibre11">in the same nib</em>, so that the actual instances can be configured in relation to one another on each particular occasion when this nib loads.</p>

<p class="author1">If an outlet connection or an action connection were drawn from an object in one nib to an object in another nib, there would be no way to understand what actual future instances the connection is supposed to connect, because they are different nibs and will be loaded at different times (if ever). The problem of communicating between an instance generated from one nib and an instance generated from another nib is a special case of the more general problem of how to communicate between instances in a program, discussed in <a data-type="xref" href="#calibre_link-50" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;13</a>.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Additional Configuration of Nib-Based Instances" class="calibre2"><div class="preface" id="calibre_link-2583">
<h1 class="calibre18">Additional Configuration of Nib-Based Instances</h1>

<p class="author1">After a nib finishes loading, the instances that it describes have been initialized and configured with all the attributes dictated through the Attributes and Size inspectors, and their outlets have been used to set the values of the corresponding instance properties. Nevertheless, you might want to append your own code to the initialization process as an object is instantiated by loading a nib. This section describes some ways you can do that.</p>

<p class="author1">A common situation is that a view controller, functioning as the owner when a nib containing its main view loads (and therefore represented in the nib by the nib owner object), has an outlet to an interface object instantiated by the loading of the nib. In this architecture, the view controller can perform further configuration on that interface object, because it has a reference to it after the nib loads &mdash; the corresponding instance property. The earliest place where it can perform such configuration is its <code class="calibre19">viewDidLoad</code> method. At the time <code class="calibre19">viewDidLoad</code> is called, the view controllerâ€™s view has been instantiated and assigned to its <code class="calibre19">view</code> property, and all its outlets have been connected; but the view is not yet in the visible interface.</p>

<p class="author1">Another possibility is that youâ€™d like the nib object to configure itself, over and above whatever configuration has been performed in the nib. Often, this will be because youâ€™ve got a custom subclass of a built-in interface object class; in fact, you might want to <em class="calibre11">create</em> a subclass precisely so as to have a place to put this self-configuring code. The problem youâ€™re trying to solve might be that the nib editor doesnâ€™t let you perform the configuration youâ€™re after, or that you have many objects that need to be configured similarly, so that it makes more sense for them to configure themselves by virtue of sharing a common class than to configure each one individually.</p>

<p class="author1">One approach is to implement <code class="calibre19">awakeFromNib</code> in your custom class. The <code class="calibre19">awakeFromNib</code> message is sent to all nib-instantiated objects just after they are instantiated by the loading of the nib: the object has been initialized and configured and its connections are operational.<a data-type="indexterm" data-primary="initialization" data-secondary="of nib-based instances" id="calibre_link-1078" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="awakeFromNib" id="calibre_link-239" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s make a button whose background color is always red, regardless of how itâ€™s configured in the nib. (This is a nutty example, but itâ€™s dramatically effective.) In the Empty Window project, weâ€™ll create a button subclass, RedButton:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In the Project navigator, choose File â†’ New â†’ File. Specify iOS â†’ Source â†’ Cocoa Touch Class. Click Next.</p>
</li>
<li class="calibre4">
<p class="calibre17">Call the new class RedButton. Make it a subclass of UIButton. Click Next.</p>
</li>
<li class="calibre4">
<p class="calibre17">Make sure youâ€™re saving into the project folder, in the Empty Window group, and that the Empty Window app target is checked. Click Create. Xcode creates <em class="calibre11">RedButton.swift</em>.</p>
</li>
<li class="calibre4">
<p class="calibre17">In <em class="calibre11">RedButton.swift</em>, inside the body of the RedButton class declaration, implement <code class="calibre19">awakeFromNib</code>:</p>

<pre data-type="programlisting" class="calibre38">override func awakeFromNib() {
    super.awakeFromNib()
    self.backgroundColor = .red
}</pre>
</li>

</ol>

<p class="author1">We now have a UIButton subclass that turns itself red when itâ€™s instantiated from a nib. But we have no instance of this subclass in any nib. Letâ€™s fix that. Edit the storyboard, select the button thatâ€™s already in the main view, and use the Identity inspector to change this buttonâ€™s class to <span class="publishername">RedButton</span>. Now build and run the project. Sure enough, the button is red!</p>

<p class="author1">A further possibility is to take advantage of the User Defined Runtime Attributes in the nib objectâ€™s Identity inspector.<a data-type="indexterm" data-primary="User Defined Runtime Attributes" id="calibre_link-2302" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This can allow you to configure, in the nib editor, aspects of a nib object for which the nib editor itself provides no built-in interface. What youâ€™re actually doing here is sending the nib object, at nib-loading time, a <code class="calibre19">setValue(_:forKeyPath:)</code> message; Cocoa key paths are discussed in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>. Naturally, the object needs to be prepared to respond to the given key path, or your app will crash when the nib loads.</p>

<p class="author1">For example, one of the disadvantages of the nib editor is that it provides no way to configure layer attributes. Letâ€™s say weâ€™d like to use the nib editor to round the corners of our red button. In code, we would do that by setting the buttonâ€™s <code class="calibre19">layer.cornerRadius</code> property. The nib editor gives no access to this property. Instead, we can select the button in the nib editor and use the User Defined Runtime Attributes in the Identity inspector. We set the Key Path to <code class="calibre19">layer.cornerRadius</code>, the Type to Number, and the Value to whatever value we want &mdash; letâ€™s say 10 (<a data-type="xref" href="#calibre_link-2886" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-17</a>). Now build and run; sure enough, the buttonâ€™s corners are now rounded.<a data-type="indexterm" data-primary="layer, configuring in the nib" id="calibre_link-1209" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If you define your own property, your User Defined Runtime Attributes setting for that property will fail silently unless you mark the property <code class="calibre19">@objc</code>.</p>
</div>

<figure class="calibre32"><div id="calibre_link-2886" class="figure">
<img src="images/000030.png" alt="ios12 0717" class="calibre63" />
<h6 class="calibre34"><span class="publishername">Figure 7-17. </span>Rounding a buttonâ€™s corners with a runtime attribute</h6>
</div>
</figure>

<p class="author1">You can also configure a custom property of a nib object by making that property <em class="calibre11">inspectable</em>. To do so, add the <code class="calibre19">@IBInspectable</code> attribute to the propertyâ€™s declaration in your code. This causes the property to be listed in the nib objectâ€™s Attributes inspector. (It also implicitly marks it <code class="calibre19">@objc</code>.)<a data-type="indexterm" data-primary="IBInspectable" id="calibre_link-1025" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="inspectable" id="calibre_link-1760" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s make it possible to configure our buttonâ€™s border in the nib editor. At the start of the RedButton class declaration body, add this code:</p>

<pre data-type="programlisting" class="calibre28">@IBInspectable var borderWidth : CGFloat {
    get {
        return self.layer.borderWidth
    }
    set {
        self.layer.borderWidth = newValue
    }
}</pre>

<p class="author1">That code declares a RedButton property, <code class="calibre19">borderWidth</code>, and makes it a faÃ§ade in front of the layerâ€™s <code class="calibre19">borderWidth</code> property. It also causes the nib editor to display that property in the Attributes inspector for any button that is an instance of the RedButton class (<a data-type="xref" href="#calibre_link-2887" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-18</a>). The result is that when we give this property a value in the nib editor, that value is sent to the setter for this property at nib-loading time, and the button border appears with that width.</p>

<figure class="calibre32"><div id="calibre_link-2887" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 7-18. </span>An inspectable property in the nib editor</h6>
</div>
</figure>

<p class="author1">To intervene with a nib objectâ€™s initialization even earlier, if the object is a UIView (or a UIView subclass), you can override <code class="calibre19">init(coder:)</code>.
A minimal implementation would look like this:<a data-type="indexterm" data-startref="idxnibs2" id="calibre_link-1394" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">required init?(coder aDecoder: NSCoder) {
    super.init(coder:aDecoder)
    // your code here
}</pre>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-0">
<div id="calibre_link-2988" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 8. Documentation" class="calibre2"><div class="preface" id="calibre_link-54">
<h1 class="calibre13"><span class="label">Chapter 8. </span>Documentation</h1>

<blockquote data-type="epigraph" {http://www.idpf.org/2007/ops}type="epigraph" class="calibre64">
   <p class="calibre65">Knowledge is of two kinds. We know a subject ourselves, <span class="label">or we know where we can find information upon it.</span></p>
   <p data-type="attribution" class="calibre65">Samuel Johnson, <em class="calibre66">Boswellâ€™s Life of Johnson</em></p>
</blockquote>

<p class="author1">No aspect of iOS programming is more important than a fluid and nimble relationship with the documentation. In addition to Swiftâ€™s own types, there are hundreds of built-in Cocoa classes along with their numerous methods and properties and other details. Appleâ€™s documentation, whatever its flaws, is the definitive official word on how you can expect Cocoa to behave, and on the contractual rules incumbent upon you in working with this massive framework whose inner workings you cannot see directly.<a data-type="indexterm" data-primary="documentation" id="calibre_link-691" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Your primary access to the documentation is in Xcode, through the documentation window. But there are other forms of documentation and assistance. Quick Help popovers and the Quick Help inspector provide documentation without leaving the code editor. You can examine the code headers, which provide a useful overview and often contain valuable comments, and you can jump quickly to a symbol declaration. Apple provides sample code, and there are lots of additional online resources.<a data-type="indexterm" data-primary="documentation" data-secondary="window" id="calibre_link-700" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="The Documentation Window" class="calibre2"><div class="preface" id="calibre_link-2584">
<h1 class="calibre18">The Documentation Window</h1>

<p class="author1">There are two main categories of documentation provided by Apple:</p>
<dl class="calibre14">
<dt class="calibre15">Primary documentation</dt>
<dd class="calibre16">
<p class="calibre17">The primary documentation (<em class="calibre11">reference</em> documentation) for Cocoa classes and other symbols is included entirely within Xcode, and is displayed in the documentation window (Window â†’ Developer Documentation or Help â†’ Developer Documentation, Command-Shift-0). You can also view the same documentation online, at <a href="https://developer.apple.com/documentation" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/documentation</em></a>.</p>
</dd>
<dt class="calibre15">Secondary documentation</dt>
<dd class="calibre16">
<p class="calibre17">Secondary documentation such as guides and sample code is available <em class="calibre11">only</em> online, at <a href="https://developer.apple.com/library/archive/navigation" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/library/archive/navigation</em></a>. Apple refers to this material as the <em class="calibre11">documentation archive.</em><a data-type="indexterm" data-primary="documentation" data-secondary="archive" id="calibre_link-693" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="archive" data-secondary="documentation" id="calibre_link-171" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">Within the documentation window, the primary pathway is a search; press Command-Shift-0 (or Command-L or Command-Shift-F if youâ€™re already in the documentation window) and type a search term, typically a class name such as â€œNSStringâ€ or â€œUIButton.â€ As you type, youâ€™re shown the top search results pertinent to the language of your choice (such as Swift or Objective-C).
You can choose a result with the mouse, or you can navigate the results with arrow keys and press Return to select the desired hit.<a data-type="indexterm" data-primary="searching the documentation" id="calibre_link-1968" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="documentation" data-secondary="searching" id="calibre_link-699" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can also perform a documentation window search starting from <em class="calibre11">within your code</em>. Youâ€™ll very often want to do this: youâ€™re looking directly at a symbol (a type name, a function name, a property name, and so on) at its point of use in your code, and you want to know more about it. Select text in your code (or anywhere else) and choose Help â†’ Search Documentation for Selected Text (Command-Option-Control-/). This is like typing that text into the search field in the documentation window.</p>

<p class="author1">The documentation window behaves basically as a glorified web browser. Multiple pages can appear simultaneously as tabs. To navigate to a new tab, hold Command as you navigate &mdash; for example, Command-click a link
&mdash; or choose Open Link in New Tab from the contextual menu. You can navigate between tabs (Window â†’ Show Next Tab), and each tab remembers its navigation history (Navigate â†’ Go Back, or use the Back button in the window toolbar, which is also a pop-up menu).</p>

<p class="author1">A hierarchical table of contents for the whole documentation appears in the navigator area at the far left of the documentation window; to see it if it isnâ€™t showing, choose View â†’ Navigators â†’ Show Navigator (Command-0), or click the Navigator button in the window toolbar.
The table of contents can display any of four panes: Swift, Objective-C, REST, or JS. You can switch between them with buttons at the top of the table of contents. To select in the table of contents the page youâ€™re currently viewing, choose Editor â†’ Reveal in Navigator (or use the contextual menu).</p>

<p class="author1">To search for text <em class="calibre11">within</em> the current documentation page, use the Find menu commands. Find â†’ Find (Command-F) summons a find bar, as in Safari.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Class Documentation Pages" class="calibre2"><div class="preface" id="calibre_link-2585">
<h1 class="calibre18">Class Documentation Pages</h1>

<p class="author1">When dealing with Cocoa, your target documentation page will most likely be the documentation for a class, such as the page shown in <a data-type="xref" href="#calibre_link-1" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;8-1</a>.<a data-type="indexterm" data-primary="class" data-secondary="documentation page" id="calibre_link-361" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Itâ€™s important to be comfortable and conversant with the typical features and information provided by a class documentation page:<a data-type="indexterm" data-primary="documentation" data-secondary="class" id="calibre_link-694" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="classes" data-secondary="documentation" id="calibre_link-376" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-1" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 8-1. </span>The start of the UIButton class documentation page</h6>
</div>
</figure>
<dl class="calibre14">
<dt class="calibre15">Jump bar</dt>
<dd class="calibre16">
<p class="calibre17">At the top of the page is the jump bar. This has two main purposes:<a data-type="indexterm" data-primary="jump bar" data-secondary="documentation" id="calibre_link-1176" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Breadcrumbs</dt>
<dd class="calibre16">
<p class="calibre17">The jump bar functions as a kind of â€œbreadcrumbsâ€ display of where you are. The UIButton class documentation page is in the Views and Controls section of the UIKit division of the documentation. This is the same hierarchy in which the page is displayed in the navigator table of contents.</p>
</dd>
<dt class="calibre15">Navigation</dt>
<dd class="calibre16">
<p class="calibre17">Each item in the jump bar is a hierarchical menu, displaying the same hierarchy as in the navigator table of contents. Choose a menu item to navigate there. As with the Xcode project window editorâ€™s jump bar, you can type to filter the items of the currently selected menu.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Language</dt>
<dd class="calibre16">
<p class="calibre17">Links let you choose between Swift and Objective-C as the language for display of symbol names.</p>
</dd>
<dt class="calibre15">SDKs</dt>
<dd class="calibre16">
<p class="calibre17">This list tells you two important things:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">What sort of <em class="calibre11">hardware</em> youâ€™re programming for when you use this class. Thatâ€™s important because searches are not filtered by SDK. If you were to stumble accidentally into the NSViewController class documentation page, you might be confused about how this class fits into the rest of iOS programming, unless you notice that iOS is not listed among this classâ€™s SDKs.</p>
</li>
<li class="calibre12">
<p class="calibre17">The lowest <em class="calibre11">version number</em> in which this class became available &mdash; also called the classâ€™s <em class="calibre11">availability</em>. The UIGraphicsImageRenderer page, for example, tells you that this class is available in iOS 10.0 and later. So you wonâ€™t be able to use it in code intended to run on iOS 9.<a data-type="indexterm" data-primary="availability" id="calibre_link-237" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>
</dd>
<dt class="calibre15">Framework</dt>
<dd class="calibre16">
<p class="calibre17">The framework that vends this class.</p>
</dd>
<dt class="calibre15">On This Page</dt>
<dd class="calibre16">
<p class="calibre17">The class reference page is divided into sections, and these are links to them, in order:</p>
<dl class="calibre14">
<dt class="calibre15">Declaration</dt>
<dd class="calibre16">
<p class="calibre17">The formal declaration for this class, showing its superclass.</p>
</dd>
<dt class="calibre15">Overview</dt>
<dd class="calibre16">
<p class="calibre17">If a page has an Overview section, read it! It explains what this class is for and how to use it. It may also contain valuable links to guides that provide related information.</p>
</dd>
<dt class="calibre15">Topics</dt>
<dd class="calibre16">
<p class="calibre17">These are primarily the classâ€™s members &mdash; its properties and methods &mdash; <span class="publishername">grouped</span> by their purpose. Each member is accompanied by a short description; click the member itself to see further details. (Iâ€™ll talk more about that in a moment.) At the end of the Topics section, there may be further subsections including Constants, such as enums used by this classâ€™s properties and methods, and Notifications if this class emits any; the UIApplication class documentation page is a case in point.</p>
</dd>
<dt class="calibre15">Relationships</dt>
<dd class="calibre16">
<p class="calibre17">There are two chief kinds of relationship that a class can have, and youâ€™ll want to keep an eye on both of them; a common beginner mistake is failing to follow the documentation links in this section:</p>
<dl class="calibre14">
<dt class="calibre15">Inherits from</dt>
<dd class="calibre16">
<p class="calibre17">This classâ€™s superclass. A class inherits from its superclasses, so the functionality or information youâ€™re looking for may be in a superclass. For example, you wonâ€™t find <code class="calibre19">addTarget(_:action:for:)</code> listed in the UIButton class page; itâ€™s in the UIControl class page (UIButtonâ€™s superclass). You wonâ€™t find out that a UIButton has a <code class="calibre19">frame</code> property from the UIButton class page; that information is in the UIView class page (UIControlâ€™s superclass).</p>
</dd>
<dt class="calibre15">Conforms to</dt>
<dd class="calibre16">
<p class="calibre17">Protocols adopted by this class. Again, the functionality or information youâ€™re looking for might be documented for a protocol rather than in this classâ€™s own page. For example, you wonâ€™t find the <code class="calibre19">viewWillTransition(to:with:)</code> method on the UIViewController class page; you have to look in the documentation for the UIContentContainer protocol, which UIViewController adopts.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p class="author1">When you click the name of a property or method in a class documentation page, youâ€™re taken to a separate page that describes it in detail. This page is laid out similarly to a class documentation page:</p>
<dl class="calibre14">
<dt class="calibre15">Jump bar</dt>
<dd class="calibre16">
<p class="calibre17">The jump bar provides breadcrumb navigation leading back to the class documentation page.</p>
</dd>
<dt class="calibre15">Language</dt>
<dd class="calibre16">
<p class="calibre17">The page gives you a choice of languages.</p>
</dd>
<dt class="calibre15">SDKs</dt>
<dd class="calibre16">
<p class="calibre17">The page lists the SDKs in which this property or method is found, including its availability. The availability for a property or method need not be the same as its classâ€™s availability, because a class can acquire (and lose) members over time. For example, the UINavigationBar class is as old as iOS itself and is available starting in iOS 2.0, but the <code class="calibre19">prefersLargeTitles</code> property didnâ€™t appear until iOS 11.0.</p>
</dd>
<dt class="calibre15">On This Page</dt>
<dd class="calibre16">
<p class="calibre17">There is no separate Overview section, but there is always an initial summary of purpose (the same summary that appears on the class documentation page). The other sections of a methodâ€™s page are:</p>
<dl class="calibre14">
<dt class="calibre15">Declaration</dt>
<dd class="calibre16">
<p class="calibre17">The formal declaration for this method, showing its parameters and return type.</p>
</dd>
<dt class="calibre15">Parameters</dt>
<dd class="calibre16">
<p class="calibre17">Separate explanations for each parameter.</p>
</dd>
<dt class="calibre15">Return Value</dt>
<dd class="calibre16">
<p class="calibre17">An explicit description of what this method returns.</p>
</dd>
<dt class="calibre15">Discussion</dt>
<dd class="calibre16">
<p class="calibre17">Often contains extremely important further details about how this method behaves. Always pay attention to this section!</p>
</dd>
<dt class="calibre15">See Also</dt>
<dd class="calibre16">
<p class="calibre17">Links to related methods and properties. Helpful for getting a larger perspective on how this method fits into the overall behavior of this class.</p>
</dd>
</dl>
</dd>
</dl>

<p class="author1">The Topics section of a class documentation page may list many class members, and these can rapidly threaten to become overwhelming. If you know the name of a class member that youâ€™re interested in, or you want to get to a particular topic quickly, how are you going to reach it without the tedium of scrolling? <em class="calibre11">Donâ€™t forget the jump bar!</em> The jump bar lists all the class members listed on the page, grouped by topic. And that list can be filtered by typing. For example, letâ€™s say I know that the class member Iâ€™m interested in contains the term â€œbackground.â€ I summon the rightmost level of the jump bar,
type â€œbackground,â€ and am shown a shortened list of just those terms (<a data-type="xref" href="#calibre_link-2" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;8-2</a>). Now itâ€™s easy to navigate to the detail page for any of those items.</p>

<figure class="calibre32"><div id="calibre_link-2" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 8-2. </span>Filtering the jump bar for the UIButton topics</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Quick Help" class="calibre2"><div class="preface" id="calibre_link-2586">
<h1 class="calibre18">Quick Help</h1>

<p class="author1">Quick Help is a condensed rendering of the documentation for a particular symbol such as a type, function, or property name.<a data-type="indexterm" data-primary="Quick Help" id="calibre_link-1834" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> It appears with regard to the current selection or insertion point automatically in the Quick Help inspector (Command-Option-3) if the inspector is showing. For example, if youâ€™re editing code and the insertion point or selection is within the term <code class="calibre19">viewDidLoad</code>, documentation for the <code class="calibre19">viewDidLoad</code> method appears in the Quick Help inspector if it is visible. Quick Help is also available in the Quick Help inspector for interface objects selected in the nib editor.</p>

<p class="author1">Quick Help documentation can also be displayed as a popover window. Select a term in the code editor and choose Help â†’ Show Quick Help for Selected Item (Command-Control-Shift-?). Alternatively, hold Option and hover the mouse over a term until the cursor becomes a question mark; then Option-click the term.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">When youâ€™re developing Swift code, Quick Help is of increased importance. If you click in the name of a Swift variable whose type is inferred, Quick Help shows the inferred type (see <a data-type="xref" href="#calibre_link-3" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;3-1</a>). This can help you understand compile errors and other surprises.</p>
</div>

<p class="author1">The Quick Help documentation contains links. Click the Open in Developer Reference link to see the full documentation in the documentation <span class="publishername">window.</span></p>

<p class="author1">You can inject documentation for your own code into Quick Help. To do so, precede a declaration with a comment enclosed in <code class="calibre19">/**...*/</code> or a sequence of single-line comments starting with <code class="calibre19">///</code>. Within the comment, Markdown<a data-type="indexterm" data-primary="Markdown" id="calibre_link-1268" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> formatting can be used (<a href="http://daringfireball.net/projects/markdown/syntax" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://daringfireball.net/projects/markdown/syntax</em></a>). The first paragraph of the comment becomes the Summary field for Quick Help; remaining paragraphs become the Description field, except that certain list items (paragraphs beginning with <code class="calibre19">*</code> or <code class="calibre19">-</code> followed by space) are treated in a special way, such as:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">List paragraphs beginning with <code class="calibre19">Parameter <em class="calibre43">paramname</em>:</code> are incorporated into the Parameters field.</p>
</li>
<li class="calibre12">
<p class="calibre17">A list paragraph beginning with <code class="calibre19">Throws:</code> becomes the Throws field.</p>
</li>
<li class="calibre12">
<p class="calibre17">A list paragraph beginning with <code class="calibre19">Returns:</code> becomes the Returns field.</p>
</li>
<li class="calibre12">
<p class="calibre17">A list paragraph beginning with <code class="calibre19">Note:</code> becomes a Note field.</p>
</li>
</ul>

<p class="author1">Hereâ€™s a function declaration with a preceding comment:<a data-type="indexterm" data-primary="comments" data-secondary="self-documenting" id="calibre_link-486" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="documentation" data-secondary="comments" id="calibre_link-695" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">/**
Many people would like to dog their cats. So it is *perfectly*
reasonable to supply a convenience method to do so:

* Because it's cool.
* Because it's there.

* Parameter cats: A string containing cats

* Returns: A string containing dogs
*/

func dogMyCats(_ cats:String) -&gt; String {
    return "Dogs"
}</pre>

<p class="author1">The double asterisk in the opening comment delimiter denotes that this is documentation, which is automatically associated with the <code class="calibre19">dogMyCats</code> method declaration that follows it. The outcome is that when <code class="calibre19">dogMyCats</code> is selected anywhere in my code, its documentation is displayed in Quick Help (<a data-type="xref" href="#calibre_link-4" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;8-3</a>). The first paragraph of the comment becomes the Summary, and is also displayed as part of code completion (see <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>). The word surrounded by asterisks is formatted as italics; the asterisked paragraphs become bulleted paragraphs; and the last two paragraphs become special fields.</p>

<figure class="calibre32"><div id="calibre_link-4" class="figure">
<img src="images/000023.png" alt="ios12 0803" class="calibre67" />
<h6 class="calibre34"><span class="publishername">Figure 8-3. </span>Custom documentation injected into Quick Help</h6>
</div>
</figure>

<p class="author1">You can also generate a documentation comment automatically. Select within the declaration line and choose Editor â†’ Structure â†’ Add Documentation. The comment is inserted before the declaration. The description, plus (if this is a function declaration) the Parameters, Returns, and Throws fields, as applicable, are provided as <span class="publishername">placeholders.</span></p>

<p class="author1">There are additional special documentation fields. For more information about these, see the â€œMarkup Functionalityâ€ page of Appleâ€™s <em class="calibre11">Markup Formatting <span class="publishername">Reference</span></em> in the documentation archive.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Symbol Declarations" class="calibre2"><div class="preface" id="calibre_link-2587">
<h1 class="calibre18">Symbol Declarations</h1>

<p class="author1">A <em class="calibre11">symbol</em> is a declared term, such as the name of a function, variable, or object type.<a data-type="indexterm" data-primary="searching for symbols" id="calibre_link-1967" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="symbols, searching for" id="calibre_link-2187" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> If you can see the name of a symbol in the code editor, you can jump quickly to the declaration of that symbol. Select the term and choose Navigate â†’ Jump to Definition (Command-Control-J); alternatively, hold Command-Control and hover the mouse over a prospective term, until the cursor becomes a pointing finger, and then Command-Control-click the term:<a data-type="indexterm" data-primary="jumping (navigating)" data-secondary="to declaration" id="calibre_link-1182" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="declaration" data-secondary="jumping to" id="calibre_link-621" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If the symbol is declared in your code, you jump to its declaration in your code; this can be helpful not only for understanding your code but also for navigating it.</p>
</li>
<li class="calibre12">
<p class="calibre17">If the symbol is declared in the Swift library or a Cocoa framework, you jump to its declaration in the header file.
(Iâ€™ll talk more about header files in the next section.)</p>
</li>
</ul>

<p class="author1">To jump to the declaration of a symbol whose name you know, even if you donâ€™t see the name in the code before you, choose File â†’ Open Quickly (Command-Shift-O). A search field appears. In it, type key letters from the name, which will be interpreted intelligently; for example, to search for <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code>, you might type â€œappdidf.â€ Possible matches are shown in a scrolling list below the search field; you can navigate this list with the mouse or by keyboard alone. Besides declarations from the framework headers, declarations in your own code are listed as well, so this, too, can be a rapid way of navigating your code.</p>

<p class="author1">In addition, a list of available symbols appears in the the Symbol navigator (<a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>). If the second icon in the filter bar is highlighted, these are symbols declared in your project; if not,
symbols from imported frameworks are listed as well. Click to navigate to a symbol declaration.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Header Files" class="calibre2"><div class="preface" id="calibre_link-2588">
<h1 class="calibre18">Header Files</h1>

<p class="author1">A header file can be a useful form of documentation. The header is necessarily accurate, up-to-date, and complete, and it may contain comments telling you things that the documentation doesnâ€™t. Also, a single header file can contain declarations for multiple classes and protocols. So it can be an excellent quick reference.<a data-type="indexterm" data-primary="header files" id="calibre_link-1009" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The previous section describes various ways of jumping to a symbol declaration; since most symbols are declared in header files, these are ways of reaching header files. For example, to reach <em class="calibre11">NSString.h</em>, Command-Control-click the term <code class="calibre19">NSString</code> wherever it may appear in your code, or choose File â†’ Open Quickly (Command-Shift-O) and type â€œNSString.â€ Once youâ€™re in a header file, you can navigate it conveniently through the jump bar at the top of the editor.<a data-type="indexterm" data-primary="header files" data-secondary="jumping to" id="calibre_link-1013" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="jumping (navigating)" data-secondary="to header files" id="calibre_link-1183" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">When you jump to a header file from your code, the header file, if it is written in Objective-C, can appear in Objective-C or Swift. To switch from an Objective-C original to its Swift translation, choose Generated Interface from the Related Items menu (at the left end of the jump bar, Control-1). To switch from a Swift translated (generated) header to the Objective-C original, choose Navigate â†’ Jump to Original Source, or choose Original Source from the Related Items menu.</p>

<p class="author1">You can learn a lot about the Swift language and the built-in library functions by examining the Swift header file.
The special Swift header files for Core Graphics and Foundation are also likely to prove useful.
A neat trick is to write an <code class="calibre19">import</code> statement just so that you can Command-Control-click it to reach a header. For example, if you <code class="calibre19">import Swift</code> at the top of a Swift file, the word <code class="calibre19">Swift</code> itself is a symbol that you can Command-Control-click to jump to the Swift header.<a data-type="indexterm" data-primary="header files" data-secondary="Swift" id="calibre_link-1016" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Sample Code" class="calibre2"><div class="preface" id="calibre_link-2589">
<h1 class="calibre18">Sample Code</h1>

<p class="author1">The documentation archive includes plenty of sample code projects. You can view the code in a browser, but you can see only one file at a time, so itâ€™s difficult to get an overview.
Instead, click the Download Sample Code button and open the downloaded project in Xcode; with the sample code project open in a project window, you can read the code, navigate it, edit it, and of course run the project.<a data-type="indexterm" data-primary="sample code, Appleâ€™s" id="calibre_link-1943" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">As a form of documentation, sample code is both good and bad. It can be a superb source of working code that you can often copy and paste and use with very little alteration in your own projects. It is usually heavily commented, because the Apple folks are aware, as they write the code, that it is intended for instructional purposes. Sample code also illustrates concepts that users have difficulty extracting from the documentation. (Users who have not grasped UITouch handling, for instance, may find that the lightbulb goes on when they discover the MoveMe example.) But the logic of a project is often spread over multiple files, and nothing is more difficult to understand than someone elseâ€™s code (except, perhaps, your own code). Moreover, what learners most need is not the <em class="calibre11">fait accompli</em> of a fully written project but the reasoning process that constructed the project, which no amount of commentary can provide.</p>

<p class="author1">Appleâ€™s sample code is generally thoughtful and instructive, and is definitely a major component of the documentation; it deserves more appreciation and usage than it seems to get. But it is most useful, I think, after youâ€™ve reached a certain level of competence and comfort. Also, while some of the sample code is astoundingly well-written, some of it is a bit careless or even faulty.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Internet Resources" class="calibre2"><div class="preface" id="calibre_link-2590">
<h1 class="calibre18">Internet Resources</h1>

<p class="author1">Programming has become a lot easier since the Internet came along and Google started indexing it. Itâ€™s amazing what you can learn with a Google search. Your problem is very likely one that someone else has faced, solved, and written about on the Internet. Often youâ€™ll find sample code that you can paste into your project and adapt.<a data-type="indexterm" data-primary="Internet as documentation" id="calibre_link-1152" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Appleâ€™s own online resources go beyond the formal documentation. There are WWDC videos (<a href="https://developer.apple.com/videos" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/videos</em></a>) from the current and previous years. Apple also hosts developer forums (<a href="https://forums.developer.apple.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://forums.developer.apple.com</em></a>); the interface is extraordinarily clunky, but some interesting discussions take place in these forums, and they are patrolled by some very helpful Apple employees.</p>

<p class="author1">Other online resources have sprung up spontaneously as iOS programming has become more popular, and lots of iOS and Cocoa programmers post tutorials or blog about their experiences. One site that Iâ€™m particularly fond of is
<a href="http://www.stackoverflow.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.stackoverflow.com</em></a>;
itâ€™s a general programming question-and-answer site, not devoted exclusively to iOS programming, but with lots of iOS programmers hanging out there; questions are answered succinctly and correctly, and the interface lets you focus on the right answer quickly and easily.<a data-type="indexterm" data-startref="idxdocumentation" id="calibre_link-692" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-7">
<div id="calibre_link-2989" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 9. Life Cycle of a Project" class="calibre2"><div class="preface" id="calibre_link-5">
<h1 class="calibre13"><span class="label">Chapter 9. </span>Life Cycle of a Project</h1>


<p class="author1">This chapter surveys some of the main stages in the life cycle of an Xcode project, from inception to submission at the App Store. This survey will provide an opportunity to discuss some additional features of the Xcode development environment as well as various tasks youâ€™ll typically perform as you work on your app, including
editing, debugging, and testing your code, running your app on a device, profiling, localization, and releasing to the public.</p>






<section data-type="sect1" data-pdf-bookmark="Environmental Dependencies" class="calibre2"><div class="preface" id="calibre_link-2591">
<h1 class="calibre18">Environmental Dependencies</h1>

<p class="author1">It may be useful to have your app behave differently depending on the environment in which it finds itself when compiling or when it actually runs:</p>
<dl class="calibre14">
<dt class="calibre15">Compile-time dependencies</dt>
<dd class="calibre16">
<p class="calibre17">These are choices made at compilation time; the compiler can substitute different code, depending on the target environment while building. Typical dependencies are:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The version of Swift under which weâ€™re compiling.</p>
</li>
<li class="calibre12">
<p class="calibre17">The type of destination for which weâ€™re compiling &mdash; a simulator or a real device.</p>
</li>
<li class="calibre12">
<p class="calibre17">A custom compilation condition defined for the current build configuration in the build settings.</p>
</li>
</ul>
</dd>
<dt class="calibre15">Runtime dependencies</dt>
<dd class="calibre16">
<p class="calibre17">These are choices made depending on what the app discovers its environment to be when it runs. Typical dependencies are the <em class="calibre11">type</em> of device we turn out to be running on (iPad vs. iPhone) and the <em class="calibre11">system version</em> installed on this device:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Should the app be <em class="calibre11">permitted</em> to run under this environment?</p>
</li>
<li class="calibre12">
<p class="calibre17">Should the app do different things, or load different resources, depending on the environment?</p>
</li>
<li class="calibre12">
<p class="calibre17">Should the app respond to the presence of an argument or environment variable injected by Xcode?</p>
</li>
</ul>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Conditional Compilation" class="calibre2"><div class="preface" id="calibre_link-2592">
<h2 class="calibre42">Conditional Compilation</h2>

<p class="author1">Stretches of code that might or might not be compiled into your built app depending on the compile-time environment are fenced off by <code class="calibre19">#if...#endif</code> directives, as shown in <a data-type="xref" href="#calibre_link-8" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Example&nbsp;9-1</a>. <a data-type="indexterm" data-primary="dependencies" data-secondary="compile-time" id="calibre_link-647" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="conditional compilation" id="calibre_link-514" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="compilation, conditional" id="calibre_link-494" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div id="calibre_link-8" data-type="example" class="calibre29">
<h5 class="calibre30"><span class="label">Example 9-1. </span>Swift conditional compilation</h5>

<pre data-type="programlisting" class="calibre31">#if <em class="calibre43">condition</em>
    <em class="calibre43">statements</em>
#elseif <em class="calibre43">condition</em>
    <em class="calibre43">statements</em>
#else
    <em class="calibre43">statements</em>
#endif</pre>
</div>

<p class="author1">The <code class="calibre19">#elseif</code> and <code class="calibre19">#else</code> sections can be omitted, and there can be multiple <code class="calibre19">#elseif</code> sections. There are <em class="calibre11">no curly braces</em>, and the statements will not in fact be indented by the code editor.</p>

<p class="author1">The conditions are treated as Bools, so they can be combined with the usual Boolean logic operators. However, they are not Swift code expressions! They must come from a limited predefined set of reserved words. The ones you are most likely to use are:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">swift(&gt;=5.1)</code>, <code class="calibre19">compiler(&gt;=5.1)</code> (or some other version number)</dt>
<dd class="calibre16">
<p class="calibre17">The version of the Swift language or compiler under which weâ€™re building. The only legal operators are <code class="calibre19">&lt;</code> and <code class="calibre19">&gt;=</code>. The <code class="calibre19">swift</code> version depends on the Swift Language Version build setting, but the compiler version depends on the Xcode version. For example, under Xcode 11, if the Swift Language Version is <code class="calibre19">4.2</code>, then <code class="calibre19">swift</code> is less than <code class="calibre19">5</code>, but <code class="calibre19">compiler</code> is not.</p>
</dd>
<dt class="calibre15"><code class="calibre19">targetEnvironment(simulator)</code></dt>
<dd class="calibre16">
<p class="calibre17">Whether weâ€™re building for a simulator or device destination. You might use this to allow an app to be tested coherently on the simulator even though the simulator lacks certain capabilities, such as the camera. I also use it to load test data on the simulator.</p>
</dd>
<dt class="calibre15"><code class="calibre19">canImport(UIKit)</code> (or some other module name)</dt>
<dd class="calibre16">
<p class="calibre17">Whether the module in question is available on the platform for which weâ€™re building. You might use this to share code between an iOS project and a macOS project, where the modules UIKit and AppKit respectively are available.</p>
</dd>
<dt class="calibre15">Custom compilation condition</dt>
<dd class="calibre16">
<p class="calibre17">A name that you enter in the Active Compilation Conditions build setting will yield <code class="calibre19">true</code> for purposes of conditional compilation.</p>
</dd>
</dl>

<p class="author1">The statements enclosed in each block will not be compiled at all unless the appropriate condition is met,
as this (very silly) example demonstrates:</p>

<pre data-type="programlisting" class="calibre28">#if swift(&gt;=5.1)
print("howdy")
#else
Hey! Ba-Ba-Re-Bop
#endif</pre>

<p class="author1">That code compiles without complaint in a plain vanilla project built from the Single View App template in Xcode 11. The statement <code class="calibre19">Hey! Ba-Ba-Re-Bop</code> is not a legal Swift expression, but the compiler doesnâ€™t care, because our Swift version <em class="calibre11">is</em> Swift 5.1, and the compiler never looks into the <code class="calibre19">#else</code> block.</p>

<p class="author1">An <code class="calibre19">#if</code> condition can distinguish between build configurations by way of the Active Compilation Conditions build setting. In fact, your project already comes with one such condition by default: the <code class="calibre19">DEBUG</code> condition is defined for the Debug configuration but not for the Release configuration (<a data-type="xref" href="#calibre_link-9" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-1</a>). This means that for a Debug build, but not for a Release build, the test <code class="calibre19">#if DEBUG</code> will succeed.</p>

<figure class="calibre32"><div id="calibre_link-9" class="figure">
<img src="images/000032.png" alt="ios12 0901b" class="calibre68" />
<h6 class="calibre34"><span class="publishername">Figure 9-1. </span>Compilation conditions in the build settings</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Permissible Runtime Environment" class="calibre2"><div class="preface" id="calibre_link-2593">
<h2 class="calibre42">Permissible Runtime Environment</h2>

<p class="author1">Under what environments should this app be permitted to run? The choices are determined by build settings, but you can configure them through a more convenient interface:<a data-type="indexterm" data-primary="dependencies" data-secondary="runtime" id="calibre_link-648" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Device Type</dt>
<dd class="calibre16">
<p class="calibre17"><a data-type="indexterm" data-primary="Targeted Device Family build setting" id="calibre_link-2194" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>The device type(s) on which your app will run natively. This is the app targetâ€™s Targeted Device Family build setting; to set, edit the app target, switch to the General pane, and use the Device checkboxes (under Deployment Info):</p>
<dl class="calibre14">
<dt class="calibre15">iPhone</dt>
<dd class="calibre16">
<p class="calibre17">The app will run on an iPhone or iPod touch. It can also run on an iPad, but not as a native iPad app; it runs in a reduced enlargeable window (Apple sometimes refers to this as â€œcompatibility modeâ€).</p>
</dd>
<dt class="calibre15">iPad</dt>
<dd class="calibre16">
<p class="calibre17">The app will run only on an iPad.</p>
</dd>
<dt class="calibre15">Both</dt>
<dd class="calibre16">
<p class="calibre17">The app will run natively on both kinds of device; it is a <em class="calibre11">universal</em> app (and the Targeted Device Family setting will be Universal).<a data-type="indexterm" data-primary="universal app" id="calibre_link-2280" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">iOS Deployment Target</dt>
<dd class="calibre16">
<p class="calibre17"><a data-type="indexterm" data-primary="iOS Deployment Target build setting" id="calibre_link-1160" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Deployment Target build setting" id="calibre_link-649" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>The <em class="calibre11">earliest</em> system your app can run on: in Xcode 11, this can be any major iOS system as far back as iOS 8.0. To set, edit the app target, switch to the General pane, and choose from the Target pop-up menu (under Deployment Info). There is also a drop-down list when you edit the project, in the Info pane.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Backward Compatibility" class="calibre2"><div class="preface" id="calibre_link-2594">
<h2 class="calibre42">Backward Compatibility</h2>

<p class="author1">Writing an app whose iOS Deployment Target version is lower than the current version &mdash; that is, an app that is <em class="calibre11">backward compatible</em> to an earlier system &mdash; can be challenging.<a data-type="indexterm" data-primary="backward compatibility" id="calibre_link-242" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="compatibility, backward" id="calibre_link-493" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
With each new system, Apple adds new features. Youâ€™ll want to take advantage of these. But your app will <em class="calibre11">crash</em> if execution encounters features not supported by the system on which it is actually running!</p>

<p class="author1">Fortunately, when the compiler knows that a feature is unsupported by an earlier system, it will prevent you from accidentally using that feature on that system. For example, hereâ€™s a line of code where we prepare to draw a small image:</p>

<pre data-type="programlisting" class="calibre28">let r = UIGraphicsImageRenderer(size:CGSize(width:10,height:10))</pre>

<p class="author1">The UIGraphicsImageRenderer class exists only in iOS 10.0 and <em class="calibre11">later</em>. If your deployment target is <em class="calibre11">earlier</em> than iOS 10.0, the compiler will stop you with an error: â€œ<span class="publishername">UIGraphicsImageRenderer</span> is only available on iOS 10.0 or newer.â€ You cannot proceed until you guarantee to the compiler that this code will run only on iOS 10 or later. And Xcodeâ€™s Fix-it feature (discussed later in this chapter) will show you how to do that, by surrounding that line with an <em class="calibre11">availability check</em>:</p>

<pre data-type="programlisting" class="calibre28">if #available(iOS 10.0, *) {
    let r = UIGraphicsImageRenderer(size:CGSize(width:10,height:10))
} else {
    // Fallback on earlier versions
}</pre>

<p class="author1">The <code class="calibre19">if #available</code> condition tests the current system at runtime against a set of requirements matching the actual availability of a feature as specified in its declaration. The UIGraphicsImageRenderer class declaration is preceded (in Swift) with this annotation:<a data-type="indexterm" data-primary="available" id="calibre_link-238" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@available(iOS 10.0, *)</pre>

<p class="author1">The detailed meaning of that annotation isnâ€™t important (if youâ€™re interested, consult the Attributes chapter of <a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://docs.swift.org/swift-book/ReferenceManual/Attributes.html</em></a>). The important thing is that your <code class="calibre19">#available</code> condition should match that annotation, and Xcodeâ€™s Fix-it will make sure that it does. You can use <code class="calibre19">#available</code> in an if construct or a guard construct.</p>

<p class="author1">You can annotate your own type and member declarations with an <code class="calibre19">@available</code> attribute, and your own code will then have to use an availability check. For example, if your method is declared <code class="calibre19">@available(iOS 13.0, *)</code>, then you canâ€™t call that method, when the deployment target is earlier than iOS 13, without an availability check that matches it: <code class="calibre19">if #available(iOS 13.0, *)</code>. Within such a method, you donâ€™t need that availability check, because youâ€™ve already guaranteed that this method wonâ€™t run on a system earlier than iOS 13.</p>

<p class="author1">New in Xcode 11, the app template itself not backward compatible, because it uses a scene delegate (<a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>). Scene delegates and the related classes are new in iOS 13; they donâ€™t exist in iOS 12 and before, and the launch process is different. To make a project generated from an app template backward compatible, you need to mark the entire SceneDelegate class, and any methods in the AppDelegate class that refer to UISceneSession, as <code class="calibre19">@available(iOS 13.0, *)</code>. You also need to declare a <code class="calibre19">window</code> property in the AppDelegate class:<a data-type="indexterm" data-primary="UISceneSession" id="calibre_link-2260" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="project" data-secondary="templates" id="calibre_link-1736" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="templates" data-secondary="project" id="calibre_link-2199" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Single View app template" data-secondary="not backward compatible" id="calibre_link-2035" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var window : UIWindow?</pre>

<p class="author1">The result is that when this app runs in iOS 13, the scene delegate has the <code class="calibre19">window</code>, but when it runs in iOS 12 or before, the app delegate has the <code class="calibre19">window</code> &mdash; and your other code may then need to take account of <em class="calibre11">that</em> in order to be backward compatible.</p>

<p class="author1">A more insidious problem arises when the very same method or property behaves differently on different systems. Often this is because Apple introduces a bug, or fixes a bug, or both. For example, setting UIProgressViewâ€™s <code class="calibre19">progressImage</code> property worked in iOS 7.0, didnâ€™t work at all from iOS 7.1 through iOS 8.4, and then started working again in iOS 9 and later. When that sort of thing happens, you usually have no way of knowing about it other than trial and error, and working your way around the problem coherently can be tricky.</p>

<p class="author1">To test your app on an earlier system, youâ€™ll need a destination that runs that earlier system. You can download an earlier Simulator SDK going back as far as iOS 10.3.1 through Xcodeâ€™s Components preference pane (see <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>). To test on an earlier system than that, youâ€™ll need an older version of Xcode, and probably an older device. This can be difficult to configure, and may not be worth the trouble.<a data-type="indexterm" data-primary="SDKs" data-secondary="older" id="calibre_link-1965" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Device Type" class="calibre2"><div class="preface" id="calibre_link-2595">
<h2 class="calibre42">Device Type</h2>

<p class="author1">An app might need to respond differently depending on the hardware on which it finds itself running. For example, a universal app might need to behave differently depending on whether it is running on an iPad or an iPhone, different devices have different screen resolutions that might call for using different images, and so on.</p>

<p class="author1">You can learn in code whether weâ€™re running on an iPhone or an iPad. The current UIDevice (<code class="calibre19">UIDevice.current</code>), or the <code class="calibre19">traitCollection</code> of any UIViewController or UIView in the hierarchy, will tell you the current deviceâ€™s type as its <code class="calibre19">userInterfaceIdiom</code>, which will be a <span class="publishername">UIUserInterfaceIdiom</span>, either <code class="calibre19">.phone</code> or <code class="calibre19">.pad</code>.<a data-type="indexterm" data-primary="screen resolution" id="calibre_link-1959" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="resolution, screen" id="calibre_link-1906" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="device" data-secondary="type" id="calibre_link-660" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">When it comes to loading resources, there are some built-in shortcuts. Image files to be loaded from the top level of the app bundle can be distinguished automatically by using the same name but different suffixes, such as <code class="calibre19">@2x</code> and <code class="calibre19">@3x</code> to indicate the screen resolution, or <code class="calibre19">~iphone</code> and <code class="calibre19">~ipad</code> to indicate the device type. Or you can use an asset catalog (see <a data-type="xref" href="#calibre_link-10" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œResources in an asset catalogâ€</a>), which allows you to specify different images for different runtime environments just by putting them in the correct slot. Either way, the runtime will automatically choose the image variant appropriate to the current environment.<a data-type="indexterm" data-primary="resources" data-secondary="dependent on device type" id="calibre_link-1913" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Certain <em class="calibre11">Info.plist</em> settings come with name suffixes as well. For example, it is usual for a universal app to adopt one set of possible orientations on iPhone and another set on iPad: typically, the iPhone version permits a limited set of orientations while the iPad version permits all orientations. You configure this using two groups of â€œSupported interface orientationsâ€ settings in the <em class="calibre11">Info.plist</em>:</p>
<dl class="calibre14">
<dt class="calibre15">Supported interface orientations (<code class="calibre19">UISupportedInterfaceOrientations</code>)</dt>
<dd class="calibre16">
<p class="calibre17">A general set of orientations.</p>
</dd>
<dt class="calibre15">Supported interface orientations (iPad) (<code class="calibre19">UISupportedInterfaceOrientations~ipad</code>)</dt>
<dd class="calibre16">
<p class="calibre17">An iPad-only set that overrides the general set when the app runs on an iPad.</p>
</dd>
</dl>

<p class="author1">The clearest and most reliable way to make these configurations is to edit the <em class="calibre11">Info.plist</em> directly. Alternatively, there are some checkboxes you can use, in the General pane when you edit the target, under Deployment Info (these constitute one of Xcodeâ€™s least intuitive bits of interface):<a data-type="indexterm" data-primary="property list settings" data-secondary="dependent on device type" id="calibre_link-1781" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Uncheck iPad, check iPhone, and check the desired Device Orientation checkboxes for the iPhone.</p>
</li>
<li class="calibre4">
<p class="calibre17">Uncheck iPhone, check iPad, and check the desired Device Orientation checkboxes for the iPad.</p>
</li>
<li class="calibre4">
<p class="calibre17">Check both iPad and iPhone. Even though youâ€™re now seeing just one set of orientations, both sets are remembered.</p>
</li>

</ol>

<p class="author1">Similarly, your app can load different nib files, and thus display different interfaces, depending on the device type. If the nib comes from a <em class="calibre11">.xib</em> file, use the image file naming convention: a nib file by the same name with <code class="calibre19">~ipad</code> appended will load automatically if we are running on an iPad. If you want to have two different main storyboards, use the <em class="calibre11">Info.plist</em> naming convention: configure two â€œMain storyboard file base nameâ€ keys, <code class="calibre19">UIMainStoryboardFile</code> and <code class="calibre19">UIMainStoryboardFile~ipad</code> &mdash; or, to use window scenes under iOS 13, configure two â€œApplication Scene Manifestâ€ keys, <code class="calibre19">UIApplicationSceneManifest</code> and <code class="calibre19">UIApplicationSceneManifest~ipad</code>.<a data-type="indexterm" data-primary="storyboard files" data-secondary="dependent on device type" id="calibre_link-2080" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nib files" data-secondary="dependent on device type" id="calibre_link-1395" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Arguments and Environment Variables" class="calibre2"><div class="preface" id="calibre_link-2596">
<h2 class="calibre42">Arguments and Environment Variables</h2>

<p class="author1">You can inject key&ndash;value pairs into the environment, making them available to your code, when running the app from Xcode. Edit the scheme and go to the Arguments tab of the Run action. There are two categories (<a data-type="xref" href="#calibre_link-11" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-2</a>); to add a key&ndash;value pair, click the Plus button under the desired category and enter a name and value:<a data-type="indexterm" data-primary="arguments passed on launch" id="calibre_link-175" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="environment variables" id="calibre_link-768" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-11" class="figure">
<img src="images/000026.png" alt="ios12 0901" class="calibre69" />
<h6 class="calibre34"><span class="publishername">Figure 9-2. </span>The Arguments tab of the schemeâ€™s Run action</h6>
</div>
</figure>
<dl class="calibre14">
<dt class="calibre15">Arguments Passed On Launch</dt>
<dd class="calibre16">
<p class="calibre17">The name of the argument must be preceded by a hyphen, and followed with a space and the value. This allows you to inject key&ndash;value pairs into user defaults. For example, if an argument is <code class="calibre19">-TEST1&nbsp;1</code>, then <code class="calibre19">UserDefaults.standard.integer(forKey: "TEST1")</code> will be <code class="calibre19">1</code>.</p>
</dd>
<dt class="calibre15">Environment Variables</dt>
<dd class="calibre16">
<p class="calibre17">Thereâ€™s a Name column and a Value column (which is always a string). To retrieve an environment variable, use the ProcessInfo class. For example, if the name is <code class="calibre19">TEST2</code> and the value is <code class="calibre19">2</code>, then you can say:</p>

<pre data-type="programlisting" class="calibre28">if let t = ProcessInfo.processInfo.environment["TEST2"], t == "2" {</pre>
</dd>
</dl>

<p class="author1">A configured pair can be toggled on or off for future builds by clicking the checkbox to its left. These arguments and environment variables are present only when you build and run <em class="calibre11">from Xcode</em>; a user who launches your app on a device will be unaffected by them. So you can take advantage of this feature during development (for example, to inject default data for testing) without worrying that it will leak out into the real world.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">New in Xcode 11, this feature is also available for individual test plan configurations. Iâ€™ll discuss test plans later in this chapter.</p>
</div>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Version Control" class="calibre2"><div class="preface" id="calibre_link-2597">
<h1 class="calibre18">Version Control</h1>

<p class="author1">Sooner rather than later in the life of any real app, you should consider putting your project under version control.<a data-type="indexterm" data-primary="version control" id="calibre_link-2345" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Version control is a way of taking periodic snapshots (technically called <em class="calibre11">commits</em>) of your project. Its purpose might be:<a data-type="indexterm" data-primary="Source Control preferences and menu" id="calibre_link-2049" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Security</dt>
<dd class="calibre16">
<p class="calibre17">Version control can store your commits in a repository offsite, so that your code isnâ€™t lost in case of a local computer glitch or some equivalent â€œhit by a busâ€ scenario.</p>
</dd>
<dt class="calibre15">Publication</dt>
<dd class="calibre16">
<p class="calibre17">You might want to make your projectâ€™s source publicly available through an online site such as GitHub .</p>
</dd>
<dt class="calibre15">Collaboration</dt>
<dd class="calibre16">
<p class="calibre17">Version control affords multiple developers ready, rational access to the same code.</p>
</dd>
<dt class="calibre15">Confidence</dt>
<dd class="calibre16">
<p class="calibre17">Progress on your code may require changes in many files, possibly over many days, before a new feature can be tested. Version control tracks and lists those changes, and if things go badly, helps to pinpoint whatâ€™s gone wrong, and lets you withdraw the changes altogether if necessary. Thus you can confidently embark on a programmatic experiment whose result may not be apparent until much later.</p>
</dd>
</dl>

<p class="author1">Xcodeâ€™s version control facilities are geared primarily to git (<a href="http://git-scm.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://git-scm.com</em></a>). You can use a different version control system with your projects, but not in an integrated fashion from inside Xcode. Even with git, it is possible to ignore Xcodeâ€™s integrated version control and rely on the Terminal command line or a specialized third-party GUI front end such as Sourcetree (<a href="http://www.sourcetreeapp.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://www.sourcetreeapp.com</em></a>).<a data-type="indexterm" data-primary="git" id="calibre_link-972" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
In that case, you might turn off Xcodeâ€™s version control integration by unchecking Enable Source Control in the Source Control preference pane. If you check Enable Source Control, additional checkboxes spring to life so that you can configure what automatic behaviors you want. In this discussion, Iâ€™ll assume that Enable Source Control is checked.</p>

<p class="author1">When you create a new project, the Save dialog includes a checkbox that offers to place a git repository into your project folder from the outset.
If you have no reason to decide otherwise, I suggest that you check that checkbox! If you donâ€™t, and if you change your mind later and want to add a git repository to an existing project, open the project and choose Source Control â†’ Create Git Repositories.</p>

<p class="author1">When you open an existing project, if that project is already managed with git, Xcode detects this and displays version control information in its interface. Files in the Project navigator are marked with their status. For example, you can distinguish modified files (<code class="calibre19">M</code>), new untracked files (<code class="calibre19">?</code>), and new files added to the index (<code class="calibre19">A</code>).</p>

<p class="author1">Version control management commands are available in these places:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The Source Control menu</p>
</li>
<li class="calibre12">
<p class="calibre17">The Project navigator; Control-click a file listing to see the Source Control submenu of the contextual menu</p>
</li>
<li class="calibre12">
<p class="calibre17">The Source Control navigator (Command-2) and Source Control inspector (Command-Option-4)</p>
</li>
<li class="calibre12">
<p class="calibre17">The Code Review editor (Command-Option-Shift-Return)</p>
</li>
<li class="calibre12">
<p class="calibre17">The History inspector (Command-Option-2); new in Xcode 11</p>
</li>
<li class="calibre12">
<p class="calibre17">The change bars in a source editor pane</p>
</li>
</ul>

<p class="author1">To commit changes for a <em class="calibre11">single</em> file, choose Source Control â†’ Commit [Filename] in the contextual menu for that file; to commit changes for <em class="calibre11">all</em> files, choose Source Control â†’ Commit from the menu bar. These commands summon a comparison view of the changes; each change can be excluded from this commit (or reverted entirely), so related file hunks can be grouped into meaningful commits.</p>

<p class="author1">You can discard changes, push, and pull using the Source Control menu. New in Xcode 11, cherry-pick and stashing commands are added. To download a working copy of an existing project from a remote server, choose Source Control â†’ Clone and enter the required information.</p>

<p class="author1">Branches, tags, and remotes are handled in the Source Control navigator.<a data-type="indexterm" data-primary="Source Control navigator" id="calibre_link-2048" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Selecting an item here causes relevant information to be displayed in the Source Control inspector; for example, selecting a branch displays its corresponding remote, and selecting a remote displays its URL. Selecting a branch also shows the log of its commits in the editor. The list of commits is filterable through a search field at the top of the editor.
Selecting a commit in this list displays in the inspector its branches, its commit message, and its involved files. Double-click a commit to see its involved files and their differences from the previous commit in a comparison view.</p>

<p class="author1">Other relevant commands appear in the contextual menu for items in the Source Control navigator. For example, to add a remote, Control-click the Remotes listing. To make a new branch, check out a branch, tag a branch, delete a branch, or merge a branch, Control-click the branch listing.</p>

<p class="author1">To see a comparison view for the file currently being edited, display the Code Review editor: choose View â†’ Show Code Review, or click the Code Review button in the project window toolbar. This editor fills the entire editor area, covering all individual editor panes. You can switch target files using the Project navigator or jump bar while the Code Review editor is showing.<a data-type="indexterm" data-primary="Code Review editor" id="calibre_link-445" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In <a data-type="xref" href="#calibre_link-12" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-3</a>, Iâ€™m using a comparison view to see that in the more recent version of this file (on the left) Iâ€™ve changed my <code class="calibre19">titleTextAttributes</code> dictionary (because the Swift language changed). The jump bar at the bottom permits me to view any commitâ€™s version of the current file. In the contextual menu I can choose Copy Source Changes to capture the corresponding diff text (a patch file) on the clipboard.</p>

<figure class="calibre32"><div id="calibre_link-12" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-3. </span>Version comparison</h6>
</div>
</figure>

<p class="author1">New in Xcode 11, the History inspector (Command-Option-2) lists the commit log along the current branch for any file, without having to show the comparison view. Click a commit to summon a popover containing the full commit message along with buttons to show the commit and its files, switch to the Code Review editor, or address an email to the commitâ€™s author.<a data-type="indexterm" data-primary="History inspector" id="calibre_link-1022" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For similar information in a source editor pane, choose Editor â†’ Show Authors, or choose Show Authors from the Editor Options pop-up menu at the top right of the pane. The file is divided into hunks corresponding to the individual commits, with the commit author and date listed at the right. Click a commit to summon the popover. Or, to get information on just a given line of code, select it and choose Editor â†’ Show Last Change For Line (or the contextual menu).<a data-type="indexterm" data-primary="blame (version control)" id="calibre_link-260" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="authors (version control)" id="calibre_link-231" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If youâ€™ve checked Show Source Control Changes in the Source Control preferences pane, change bars appear in the source editor pane, in the gutter at the left, showing you what youâ€™ve changed since the last commit (<a data-type="xref" href="#calibre_link-13" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-4</a>). By clicking on a change bar, you can display both the old committed text and the new uncommitted text simultaneously (new in Xcode 11). You can also discard an individual change.<a data-type="indexterm" data-primary="change bars" id="calibre_link-355" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="code" data-secondary="change bars" id="calibre_link-428" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-13" class="figure">
<img src="images/000015.png" alt="ios12 0901c" class="calibre70" />
<h6 class="calibre34"><span class="publishername">Figure 9-4. </span>An uncommitted change marked in the gutter</h6>
</div>
</figure>

<p class="author1">If you have an account with any of three popular online sites that allow ready management of code submitted through version control &mdash; GitHub (<a href="https://github.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://github.com</em></a>), Bitbucket (<a href="https://bitbucket.org" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://bitbucket.org</em></a>), and GitLab (<a href="https://gitlab.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://gitlab.com</em></a>) &mdash; you can enter your authentication information into Xcodeâ€™s Accounts preference pane. Once youâ€™ve done that:<a data-type="indexterm" data-primary="Accounts preferences" id="calibre_link-110" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="GitHub" id="calibre_link-973" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Bitbucket" id="calibre_link-255" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="GitLab" id="calibre_link-974" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">You can easily create a remote repository</dt>
<dd class="calibre16">
<p class="calibre17">If your project is already under git control locally, switch to the Source Control navigator, Control-click Remotes, and choose Create [Project Name] Remote. A dialog lets you choose a remote site and upload to it.</p>
</dd>
<dt class="calibre15">You can easily clone existing remote repositories</dt>
<dd class="calibre16">
<p class="calibre17">When you choose Source Control â†’ Clone, your repositories on those sites are listed in the dialog and you can clone one of them directly.
Also, when youâ€™re in the browser looking at a GitHub repository consisting of an Xcode project, if you click the â€œClone or downloadâ€ button, thereâ€™s a button offering to let you Open in Xcode.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Editing and Navigating Your Code" class="calibre2"><div class="preface" id="calibre_link-2598">
<h1 class="calibre18">Editing and Navigating Your Code</h1>

<p class="author1">Many aspects of Xcodeâ€™s editing environment can be modified to suit your tastes. Your first step should be to go to Xcodeâ€™s Fonts &amp; Colors preference pane and choose a theme and Source Editor font face and size. Nothing is so important as being able to read and write code comfortably! I like a pleasant monospaced font. SF Mono is included and is the default; I think itâ€™s very nice. Other possibilities might be Menlo or Consolas, or the freeware Inconsolata (<a href="http://levien.com/type/myfonts" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://levien.com/type/myfonts</em></a>) or Source Code Pro (<a href="https://github.com/adobe-fonts/source-code-pro" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://github.com/adobe-fonts/source-code-pro</em></a>). I also like a largish size (13, 14, or even 16). You also get a choice of line spacing (leading) and cursor.<a data-type="indexterm" data-primary="code" data-secondary="font" id="calibre_link-433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> You can also change the theme and font size on the fly with the Editor â†’ Font Size and Editor â†’ Theme hierarchical menus.<a data-type="indexterm" data-primary="editing" data-secondary="your code" id="calibre_link-727" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Text Editing Preferences" class="calibre2"><div class="preface" id="calibre_link-2599">
<h2 class="calibre42">Text Editing Preferences</h2>

<p class="author1">The exact look and behavior of a source code editor depends upon your settings in the three tabs of Xcodeâ€™s Text Editing preference pane &mdash; Display, Editing, and Indentation. I like to check just about everything here. Here are some particularly interesting Text Editing settings.<a data-type="indexterm" data-primary="code" data-secondary="editing" id="calibre_link-431" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Display" class="calibre2"><div class="preface" id="calibre_link-2990">
<h3 class="calibre44">Display</h3>

<p class="author1">With â€œLine numbersâ€ checked, line numbers appear in the gutter to the left of source code text. Visible line numbers are useful when debugging.</p>

<p class="author1">Code folding lets you collapse the text between matching curly braces. With â€œCode folder ribbonâ€ checked, code folding bars appear to the left of your code (at the right of the gutter), displaying your codeâ€™s hierarchical structure and allowing you to collapse and expand just by clicking the bars. Iâ€™m not fond of code folding, and I donâ€™t want to trigger it accidentally, so I leave that checkbox unchecked. If I need code folding, it remains available through the Editor â†’ Code Folding hierarchical menu<a data-type="indexterm" data-primary="code" data-secondary="folding" id="calibre_link-432" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="folding, code" id="calibre_link-879" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">New in Xcode 11, a divider line for a <code class="calibre19">MARK:</code> comment (discussed later in this chapter) can appear in your code, above the comment; check â€œMark separators.â€</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Editing" class="calibre2"><div class="preface" id="calibre_link-2991">
<h3 class="calibre44">Editing</h3>

<p class="author1">With â€œEnable type-over completionsâ€ checked, Xcode helps balance delimiters. For example, suppose I intend to make a UIView by calling its initializer <code class="calibre19">init(frame:)</code>. I type as far as this:<a data-type="indexterm" data-primary="delimiters, balancing" id="calibre_link-646" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="balancing delimiters" id="calibre_link-244" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="completion" data-secondary="type-over" id="calibre_link-499" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="type-over completions" id="calibre_link-2247" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let v = UIView(fr</pre>

<p class="author1">Xcode automatically appends the closing right parenthesis, with the insertion point still positioned before it:</p>

<pre data-type="programlisting" class="calibre28">let v = UIView(fr)
// I have typed ^</pre>

<p class="author1">If I finish typing the parameter and then type a right parenthesis, Xcode moves the insertion point through the existing right parenthesis (so that I donâ€™t end up with two adjacent right parentheses):</p>

<pre data-type="programlisting" class="calibre28">let v = UIView(frame:r)
//       I have typed ^</pre>

<p class="author1">With â€œEnclose selection in matching delimitersâ€ checked, if you select some text and type a left delimiter (such as a quotation mark or a left parenthesis), the selected text is not replaced; rather, it is surrounded with left and right delimiters. I find this natural and convenient.</p>

<p class="author1">With Editor Overscroll turned on, Xcode pretends that your file ends with some extra whitespace, so that when you scroll to the end, the last line appears in the middle of the editor pane rather than at the bottom. Since the bottom of the editor pane is usually the bottom of your screen, this let you keep your eyes focussed more or less straight ahead as you work; also, you can append lines without the editor constantly scrolling to accommodate them.<a data-type="indexterm" data-primary="overscroll" id="calibre_link-1656" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The first two checkboxes have to do with autocompletion; Iâ€™ll discuss them separately in a moment.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Indentation" class="calibre2"><div class="preface" id="calibre_link-2992">
<h3 class="calibre44">Indentation</h3>

<p class="author1">I like to have just about everything checked under Indentation; I find the way Xcode lays out code to be excellent with these settings. If you find that once in a while a line of code isnâ€™t indenting itself correctly, select the problematic area and choose Editor â†’ Structure â†’ Re-Indent (Control-I).<a data-type="indexterm" data-primary="code" data-secondary="indentation" id="calibre_link-434" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Multiple Selection" class="calibre2"><div class="preface" id="calibre_link-2600">
<h2 class="calibre42">Multiple Selection</h2>

<p class="author1">You probably know from experience how to use the mouse and keyboard to select text. Xcode also lets you set multiple selections in your code. With a multiple selection, your edits (including keyboard navigation) are performed at each selection site simultaneously, which is useful when you have many parallel changes to make. Some ways to get a multiple selection are:<a data-type="indexterm" data-primary="multiple selection" id="calibre_link-1363" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="selection, multiple" id="calibre_link-1970" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="code" data-secondary="selecting" id="calibre_link-442" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Option-click and drag to create a rectangular selection.</p>
</li>
<li class="calibre12">
<p class="calibre17">Control-Shift-click to add a selection to the existing selection.</p>
</li>
<li class="calibre12">
<p class="calibre17">Select a symbol and choose Editor â†’ Selection â†’ Select All Symbols; each occurrence of that symbol is selected simultaneously.</p>
</li>
<li class="calibre12">
<p class="calibre17">Select any text and choose Find â†’ Select Next Occurrence.</p>
</li>
<li class="calibre12">
<p class="calibre17">Press Command-F to bring up the search field at the top of the editor, enter a search term, and choose Find â†’ Find and Select Next, or Find â†’ Select All Find Matches.</p>
</li>
<li class="calibre12">
<p class="calibre17">Select a stretch of code consisting of multiple lines, and choose Editor â†’ Selection â†’ Split Selection By Lines.</p>
</li>
</ul>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Autocompletion and Placeholders" class="calibre2"><div class="preface" id="calibre_link-2601">
<h2 class="calibre42">Autocompletion and Placeholders</h2>

<p class="author1">As you write code, youâ€™ll want to take advantage of Xcodeâ€™s autocompletion feature. Type names and member names can be astonishingly verbose, and whatever reduces your time and effort typing will be a relief. Autocompletion behavior is governed by two checkboxes in the Editing pane of the Text Editing preferences.</p>

<p class="author1">If â€œSuggest completions while typingâ€ is checked, autocompletion is basically on all the time. I donâ€™t like that, so I uncheck it. Instead, I check â€œUse Escape key to show completion suggestions.â€ When I want autocompletion to happen, I ask for it manually, by pressing Esc.<a data-type="indexterm" data-primary="autocompletion" id="calibre_link-233" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="completion" data-secondary="code" id="calibre_link-498" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="code" data-secondary="completion" id="calibre_link-429" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, suppose I want my code to create an alert. I type as far as <code class="calibre19">let alert = UIAl</code> and press Esc. A menu pops up, listing completions, including UIAlertController. You can navigate this menu, dismiss it, or accept the selection, using the mouse or the keyboard alone. I like to use the keyboard. I arrow down to UIAlertController and hit Return, and â€œUIAlertControllerâ€ is entered in my code. Now I type a left parenthesis, so that Iâ€™ve got <code class="calibre19">UIAlertController(</code>, and again I press Esc. Now the menu pops up listing the initializers appropriate to a UIAlertController (<a data-type="xref" href="#calibre_link-14" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-5</a>). The last one is the one I want, so I arrow down to it (or up, because arrowing up from the top jump to the bottom) and hit Return.</p>

<figure class="calibre32"><div id="calibre_link-14" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-5. </span>The autocompletion menu</h6>
</div>
</figure>

<p class="author1">At this point, the template for the method call is entered in my code (Iâ€™ve broken it into multiple lines here):<a data-type="indexterm" data-primary="placeholders" data-secondary="code" id="calibre_link-1695" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let alert = UIAlertController(
    title: &lt;#T##String?#&gt;,
    message: &lt;#T##String?#&gt;,
    preferredStyle: &lt;#T##UIAlertController.Style#&gt;)</pre>

<p class="author1">The expressions in <code class="calibre19">&lt;#...#&gt;</code> are <em class="calibre11">placeholders</em>, showing the type of each parameter. They appear in Xcode as cartouche-like â€œtext tokensâ€ to prevent them from being edited accidentally. To navigate between placeholders, press Tab or choose Navigate â†’ Jump to Next Placeholder (Control-/). In this way, you can select each placeholder in turn, typing to replace it with the actual argument you wish to pass and then tabbing on the next placeholder. To convert a placeholder to a normal string without the delimiters, select it and press Return, or double-click it.</p>

<p class="author1">When youâ€™re entering a declaration for a method thatâ€™s inherited from a superclass or defined in an adopted protocol, you donâ€™t need to type even the initial <code class="calibre19">func</code>; just type the first few letters of the methodâ€™s name. For example, in my app delegate class I might type:</p>

<pre data-type="programlisting" class="calibre28">applic</pre>

<p class="author1">If I then press Esc, I see a list of methods such as <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code>; these are methods that might be sent to my app delegate (by virtue of its being the app delegate, as discussed in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>). When I choose one, the entire declaration is filled in for me, including the curly braces:</p>

<pre data-type="programlisting" class="calibre28">func application(_ application: UIApplication,
    didFinishLaunchingWithOptions
    launchOptions: [UIApplication.LaunchOptionsKey : Any]?) -&gt; Bool {
        &lt;#code#&gt;
}</pre>

<p class="author1">A placeholder for the code appears between the curly braces, and it is selected, ready for me to start entering the body of the function. If a function needs an <code class="calibre19">override</code> designation, Xcodeâ€™s code completion provides it.</p>

<p class="author1">What you type in connection with autocompletion doesnâ€™t have to be the literal start of a symbol. In the preceding example, I can get <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code> to be <em class="calibre11">first</em> in the code completion menu by starting with â€œlaunchâ€ or even â€œappdidf.â€</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Snippets" class="calibre2"><div class="preface" id="calibre_link-2602">
<h2 class="calibre42">Snippets</h2>

<p class="author1">Autocompletion is supplemented by code snippets. A code snippet is a bit of text with an abbreviation. Code snippets are kept in the Snippets library, which appears when you summon the Library floating window (Command-Shift-L) while editing code.<a data-type="indexterm" data-primary="code" data-secondary="snippets" id="calibre_link-443" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="snippets" data-secondary="Snippets library" id="calibre_link-2041" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> With the Library showing, you can double-click or drag to insert a snippet into your code, but the real point is that a code snippetâ€™s abbreviation is available to code completion, which means you can insert a snippet <em class="calibre11">without</em> showing the library: you type the abbreviation and the snippetâ€™s name is included among the possible completions.</p>

<p class="author1">For example, to enter a <code class="calibre19">class</code> declaration at the top level of a file, I would type <code class="calibre19">class</code> and press Esc to get autocompletion, and choose Class &mdash; Subclass. The template for a class declaration appears in my code: the class name and superclass name are placeholders, the curly braces are provided, and the body of the declaration (between the curly braces) is another placeholder.</p>

<p class="author1">In the Library, single-click on a snippet to see its details: its expansion, its language, its code completion abbreviation (called its â€œcompletion,â€ new in Xcode 11), and the scope where it applies (called its â€œavailabilityâ€). If the details donâ€™t appear, click the Details button at the top right of the Library floating window.</p>

<p class="author1">You can add your own snippets to the Snippets library. These will be categorized as user snippets and will appear first. Unlike built-in snippets, user snippets can be edited and deleted.<a data-type="indexterm" data-primary="snippets" data-secondary="creating" id="calibre_link-2040" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To create a user snippet, select some text and choose Editor â†’ Create Code Snippet.
The Library floating window will appear, with the new snippetâ€™s details ready for editing. Provide a name, a description, and an abbreviation; the Availability pop-up menu lets you narrow the scope in which the snippet will be available through code completion. In the text of the snippet, use the <code class="calibre19">&lt;#...#&gt;</code> construct to form any desired placeholders.</p>

<p class="author1">For example, Iâ€™ve created an <code class="calibre19">outlet</code> snippet (<a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>), with an availability scope of Class Implementation, defined like this:</p>

<pre data-type="programlisting" class="calibre28">@IBOutlet private var &lt;#name#&gt; : &lt;#type#&gt;!</pre>

<p class="author1">And Iâ€™ve created an <code class="calibre19">action</code> snippet, also with a completion scope of Class Implementation, defined like this:</p>

<pre data-type="programlisting" class="calibre28">@IBAction private func &lt;#name#&gt; (_ sender: Any) {
    &lt;#code#&gt;
}</pre>

<p class="author1">My other snippets constitute a personal library of utility functions that Iâ€™ve developed. For example, my <code class="calibre19">delay</code> snippet inserts my <code class="calibre19">DispatchQueue.main.asyncAfter</code> wrapper function (see <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>), and has an Availability of Top Level.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Refactoring and Structure Editing" class="calibre2"><div class="preface" id="calibre_link-2603">
<h2 class="calibre42">Refactoring and Structure Editing</h2>

<p class="author1">Refactoring is an intelligent form of code reorganization.
To use it, select within your code and then choose from the Editor â†’ Refactor hierarchical menu, or Control-click and choose from the Refactor hierarchical menu in the contextual menu. Here are some of the refactoring commands youâ€™re most likely to use:<a data-type="indexterm" data-primary="refactoring" id="calibre_link-1860" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="code" data-secondary="refactoring" id="calibre_link-440" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Rename</dt>
<dd class="calibre16">
<p class="calibre17">The selected symbolâ€™s declaration and all references to it are changed, throughout your code. This also allows you to change the name of an outlet property or action method without breaking the connection from the nib (<a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>).</p>
</dd>
<dt class="calibre15">Extract Method</dt>
<dd class="calibre16">
<p class="calibre17">Creates a new method and moves the selected lines of code into the body of that method, replacing the original lines with a call to that method. The method name and the new call to it are then selected, ready for you to supply a meaningful name.</p>
</dd>
<dt class="calibre15">Extract Variable</dt>
<dd class="calibre16">
<p class="calibre17">Creates a new variable and assigns the selected code expression to that variable, replacing the original expression with a reference to the variable. If the same expression appears multiple times and you choose Extract All Occurrences, they are all replaced with a reference to the variable. The variable name and the new reference(s) to it are then selected, ready for you to supply a meaningful name.</p>
</dd>
<dt class="calibre15">Generate Memberwise Initializer</dt>
<dd class="calibre16">
<p class="calibre17">In a class declaration, when the class name is selected, synthesizes an initializer based on the classâ€™s instance property names. This is a great convenience, because classes, unlike structs, have no implicit memberwise initializer.</p>
</dd>
</dl>

<p class="author1">Another way to refactor is to Command-click a keyword that introduces curly braces. A popover appears containing menu items that let you edit the structure of your code. The same popover can be summoned by selecting the keyword and then choosing Editor â†’ Selection â†’ Select Structure (Command-Shift-A). Some of the popover menu commands are like the refactoring commands Iâ€™ve just listed. Others let you insert templates for standard structural components associated with that keyword. Here are some of the commands that appear, depending on what you Command-clicked:<a data-type="indexterm" data-primary="snippets" data-secondary="structural" id="calibre_link-2042" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">A class or struct declaration (Command-click <code class="calibre19">class</code> or <code class="calibre19">struct</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Add Method and Add Property.</p>
</dd>
<dt class="calibre15">A method declaration (Command-click <code class="calibre19">func</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Add Parameter and Add Return Type.</p>
</dd>
<dt class="calibre15">An if construct (Command-click <code class="calibre19">if</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Add â€œelseâ€ Statement and Add â€œelse ifâ€ Statement.</p>
</dd>
<dt class="calibre15">A switch statement (Command-click <code class="calibre19">switch</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Add â€œcaseâ€ Statement and Add â€œdefaultâ€ Statement.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Fix-it and Live Syntax Checking" class="calibre2"><div class="preface" id="calibre_link-2604">
<h2 class="calibre42">Fix-it and Live Syntax Checking</h2>

<p class="author1">Xcodeâ€™s Fix-it feature allows the compiler to make <em class="calibre11">and implement</em> positive suggestions on how to avert a problem that has arisen as a warning or compile error. In effect, youâ€™re getting the compiler to edit your code for you.<a data-type="indexterm" data-primary="Fix-it" id="calibre_link-867" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="syntax checking" id="calibre_link-2188" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s an example. <a data-type="xref" href="#calibre_link-17" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-6</a>, at the top, shows that Iâ€™ve accidentally forgotten the parentheses after a method call. This causes a compile error. But the stop-sign icon next to the error tells me that Fix-it has a suggestion. I click the stop-sign icon, and <a data-type="xref" href="#calibre_link-17" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-6</a>, at the bottom, shows what happens: a dialog pops up, not only showing the full error message but also telling me how Fix-It proposes to fix the problem &mdash; by inserting the parentheses.
If I click the Fix button in the dialog, Xcode does insert the parentheses &mdash; and the error vanishes, because the problem is solved.</p>

<figure class="calibre32"><div id="calibre_link-17" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-6. </span>A compile error with a Fix-it suggestion</h6>
</div>
</figure>

<p class="author1">Thanks to the intelligence of Fix-it, you can be deliberately lazy and let the compiler do the grunt work. For example, if a switch statementâ€™s tag is an enum and you omit cases, Fix-it will add them. If a type adopts a protocol and fails to implement required members, Fix-it will insert stubs for those members.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">If youâ€™re confident that Fix-It will do the right thing, you can have it implement <em class="calibre11">all</em> suggestions simultaneously: choose Editor â†’ Fix All Issues.</p>
</div>

<p class="author1">Live syntax checking is like continual compilation, emitting a warning or error even if you donâ€™t actually compile. This feature can be toggled on or off using the â€œShow live issuesâ€ checkbox in Xcodeâ€™s General preference pane. I keep it turned off, because I find it intrusive. My code is almost never valid while Iâ€™m in the middle of typing, because things are always half-finished; thatâ€™s what it means to be typing! For example, merely typing <code class="calibre19">let</code> and pausing will likely cause the live syntax checker to complain.<a data-type="indexterm" data-primary="issues, live" id="calibre_link-1168" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="live issues" id="calibre_link-1240" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Navigation" class="calibre2"><div class="preface" id="calibre_link-2605">
<h2 class="calibre42">Navigation</h2>

<p class="author1">Developing an Xcode project involves editing code in many files. Youâ€™ll need to leap nimbly from file to file, or to see multiple files simultaneously. Fortunately, Xcode provides numerous ways to navigate your code,<a data-type="indexterm" data-primary="navigating your code" id="calibre_link-1382" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> some of which have been mentioned already:<a data-type="indexterm" data-primary="code" data-secondary="navigating" id="calibre_link-439" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">The Project navigator</dt>
<dd class="calibre16">
<p class="calibre17"><a data-type="indexterm" data-primary="Project navigator" id="calibre_link-1739" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>If you know something about the name of a file, you can find it quickly in the Project navigator by typing into the search field in the filter bar at the bottom of the navigator (Edit â†’ Filter â†’ Filter in Navigator, Command-Option-J). For example, type <code class="calibre19">story</code> to see just your <em class="calibre11">.storyboard</em> files.</p>
</dd>
<dt class="calibre15">The Symbol navigator</dt>
<dd class="calibre16">
<p class="calibre17"><a data-type="indexterm" data-primary="Symbol navigator" id="calibre_link-2185" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>If you highlight the first two icons in the filter bar (the first two are blue, the third is dark), the Symbol navigator lists your projectâ€™s object types and their members. Click a symbol to navigate to its declaration in the editor. As with the Project navigator, the filter barâ€™s search field can help get you where you want to go.</p>
</dd>
<dt class="calibre15">The jump bar</dt>
<dd class="calibre16">
<p class="calibre17">Every path component of an editor paneâ€™s jump bar is a menu:<a data-type="indexterm" data-primary="jump bar" id="calibre_link-1174" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">The bottom level</dt>
<dd class="calibre16">
<p class="calibre17">At the jump barâ€™s bottom level (the rightmost menu, Control-6) is a list of your fileâ€™s object and member declarations, in the order in which they appear. Hold Command while choosing the menu to see them in alphabetical order instead. To filter what the menu displays, start typing while the menu is open. Another useful trick is to inject section titles into this menu; to do so, put a comment in your code whose first word is <code class="calibre19">MARK:</code>, <code class="calibre19">TODO:</code>, or <code class="calibre19">FIXME:</code>, followed by the section title. To make a divider line in the menu, put a hyphen:<a data-type="indexterm" data-primary="jump bar" data-secondary="injecting comments" id="calibre_link-1177" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="MARK comments" id="calibre_link-1267" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="comments" data-secondary="MARK" id="calibre_link-485" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// MARK: - View lifecycle</pre>
</dd>
<dt class="calibre15">Higher levels</dt>
<dd class="calibre16">
<p class="calibre17">Higher-level path components are hierarchical menus; thus you can use any of them to work your way down the file hierarchy and reach any file without using the project navigator. These menus can also be filtered.</p>
</dd>
<dt class="calibre15">History</dt>
<dd class="calibre16">
<p class="calibre17">Each editor pane remembers the names of files youâ€™ve edited in it. The Back and Forward triangles are buttons as well as pop-up menus (or choose Navigate â†’ Go Back and Navigate â†’ Go Forward, Command-Control-Left and Command-Control-Right).</p>
</dd>
<dt class="calibre15">Related items</dt>
<dd class="calibre16">
<p class="calibre17">The leftmost button in the jump bar summons the Related Items menu, a hierarchical menu of files related to the current file, such as superclasses and adopted protocols. This list even includes functions that call or are called by the currently selected function.</p>
</dd>
</dl>
</dd>
<dt class="calibre15">Editor panes</dt>
<dd class="calibre16">
<p class="calibre17">Using multiple editor panes allows you to work in two places at once (see <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>).</p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Tabs and windows</dt>
<dd class="calibre16">
<p class="calibre17">You can also work in two places at once by opening a tab or a separate window (again, see <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>).</p>
</dd>
<dt class="calibre15">Jump to definition</dt>
<dd class="calibre16">
<p class="calibre17">Navigate â†’ Jump to Definition (Command-Control-J, Command-Control-click) lets you jump from a selected or clicked symbol in your code to its declaration.</p>
</dd>
<dt class="calibre15">Open quickly</dt>
<dd class="calibre16">
<p class="calibre17">File â†’ Open Quickly (Command-Shift-O) opens a dialog where you can search for a symbol in your code and in the framework headers.</p>
</dd>
<dt class="calibre15">Breakpoints</dt>
<dd class="calibre16">
<p class="calibre17">The Breakpoint navigator lists all breakpoints in your code. Xcode lacks code bookmarks, but you can misuse a breakpoint as a bookmark. Breakpoints are discussed later in this chapter.<a data-type="indexterm" data-primary="bookmarking a line of code" id="calibre_link-265" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="code" data-secondary="bookmarking" id="calibre_link-427" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Minimap</dt>
<dd class="calibre16">
<p class="calibre17">The minimap, new in Xcode 11, helps you navigate a single large source code file.<a data-type="indexterm" data-primary="minimap" id="calibre_link-1356" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="code" data-secondary="minimap" id="calibre_link-438" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> To see it, choose Editor â†’ Show Minimap, or use the Editor Options pop-up menu at the top right of the editor pane. The minimap displays the entire file in miniature &mdash; too small to read, but displaying the structure of the code, including <code class="calibre19">MARK:</code> comments, along with transients such as warnings and errors, change bars, breakpoints, and Find results. Drag the shaded area to scroll. Hover the mouse to display structure and symbols; hold Command while hovering to display <em class="calibre11">all</em> symbols (<a data-type="xref" href="#calibre_link-18" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-7</a>). Click a symbol to navigate to it.</p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-18" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-7. </span>The minimap</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Finding" class="calibre2"><div class="preface" id="calibre_link-2606">
<h2 class="calibre42">Finding</h2>

<p class="author1">Finding is a form of navigation.<a data-type="indexterm" data-primary="searching your code" id="calibre_link-1969" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Xcode has both an editor-level find (Find â†’ Find, Command-F), using a bar at the top of the editor pane, and a global find (Find â†’ Find in Project, Command-Shift-F), using the Find navigator. Youâ€™ll want to configure your search with find options:<a data-type="indexterm" data-primary="code" data-secondary="searching" id="calibre_link-441" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="finding" data-seealso="searching" id="calibre_link-861" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Editor-level find options</dt>
<dd class="calibre16">
<p class="calibre17">A button at the right end of the search field toggles case-sensitive search; a pop-up menu lets you specify containment, word exact match, word start, word end, or regular expression search.</p>
</dd>
<dt class="calibre15">Global find options</dt>
<dd class="calibre16">
<p class="calibre17">The options appear above and below the search field. Above the search field, you can choose between Text, References (where a symbol is used), Definitions (where a symbol is defined), Regular Expression, and Call Hierarchy (tracing call stacks backwards); you can search by word contents, word exact match, word start, or word end. Below the search field, you can toggle case sensitivity, and you can specify a scope determining which files will be searched: click the current scope to see the Search Scopes panel, where you can select a different scope or create a custom scope.<a data-type="indexterm" data-primary="Find navigator" id="calibre_link-860" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">To find and replace:<a data-type="indexterm" data-primary="replacing" id="calibre_link-1899" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Editor level find and replace</dt>
<dd class="calibre16">
<p class="calibre17">Next to the magnifying glass icon, click Find and choose Replace to toggle the visibility of the replace With field. You can perform a Find and then click Replace to replace that instance, or click All to replace all occurrences (hold Option to change it to All in Selection).</p>
</dd>
<dt class="calibre15">Global find and replace</dt>
<dd class="calibre16">
<p class="calibre17">Above the left end of the search bar, click Find and choose Replace. You can replace all occurrences (Replace All), or select particular find results in the Find navigator and replace only those (Replace); you can also <em class="calibre11">delete</em> find results from the Find navigator, to protect them from being affected by Replace All.</p>
</dd>
</dl>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Running in the Simulator" class="calibre2"><div class="preface" id="calibre_link-2607">
<h1 class="calibre18">Running in the Simulator</h1>

<p class="author1">When you build and run with a simulator as the destination, you run in the Simulator application.<a data-type="indexterm" data-primary="Simulator" id="calibre_link-2033" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> A Simulator window represents a specific type of device. Depending on your app targetâ€™s Deployment Target and Targeted Device Family build settings, and on what SDKs you have installed, you may have choices about the device type and system as you specify your destination before running (see <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>).</p>

<p class="author1">The Simulator can display multiple windows, representing different devices. You can run different projects in different windows simultaneously. You can also run different projects in the <em class="calibre11">same</em> window simultaneously. When you choose from the Simulatorâ€™s Hardware â†’ Device hierarchical menu, you switch to the window representing the chosen device, launching that deviceâ€™s simulator if needed.</p>

<p class="author1">A Simulator window can display the bezel surrounding the <span class="publishername">deviceâ€™s</span> screen. Choose Window â†’ Show Device Bezels to toggle this feature (for all windows). Displaying the bezel allows you to press hardware buttons (Home button, volume buttons, screen lock button) by clicking the mouse; also, certain gestures, such as swiping from the screen edge, become easier to perform.</p>

<p class="author1">A Simulator window can be resized by dragging an edge or corner. You also have a choice of three standard sizes:</p>
<dl class="calibre14">
<dt class="calibre15">Window â†’ Physical Size</dt>
<dd class="calibre16">
<p class="calibre17">The simulator device screen on your computer monitor is the size of the screen of the physical device (if your monitor is big enough to accommodate it).</p>
</dd>
<dt class="calibre15">Window â†’ Point Accurate</dt>
<dd class="calibre16">
<p class="calibre17">One point on the device screen is one point on the computer monitor. For example, an iPhone 6s screen is 375 points wide, so it occupies 375 points of screen width.</p>
</dd>
<dt class="calibre15">Window â†’ Pixel Accurate</dt>
<dd class="calibre16">
<p class="calibre17">One pixel on the device screen is one pixel on the computer monitor. For example, my computer monitor is single-resolution, but an iPhone 6s is double-resolution, so it occupies 750 pixels of screen width.</p>
</dd>
</dl>

<p class="author1">You can interact with the Simulator in some of the same basic ways as you would a device. Using the mouse, you can tap on the deviceâ€™s screen; hold Option to make the mouse represent two fingers moving symmetrically around their common center, and Option-Shift to represent two fingers moving in parallel. Items in the Hardware menu also let you perform hardware gestures such as rotating the device, shaking it, locking its screen, and clicking the Home button; you can also test your app by simulating certain special situations, such as running low on memory or the arrival of a phone call.</p>

<p class="author1">The Debug menu in the Simulator is useful for detecting problems with animations and drawing. Slow Animations, if checked, makes animations unfold in slow motion so that you can see in detail whatâ€™s happening. The four menu items whose names begin with Color reveal possible sources of inefficiency in screen drawing.<a data-type="indexterm" data-primary="Debug menu (Simulator)" id="calibre_link-608" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The Simulator application supports â€œside-loadingâ€ of apps. This means you can get an app onto a simulator without launching it from Xcode. To do so, drag a built <em class="calibre11">.app</em> file from the Finder onto an open simulator window. Various other types of resource, such as images, can be side-loaded as well.</p>

<p class="author1">New in Xcode 11, while running your app from Xcode in the Simulator, you can change certain user settings on the simulated device without passing through the Settings app. In the debug bar, click the Environment Overrides button to summon a popover where you can switch between light and dark modes, change the dynamic text size, and alter various accessibility settings.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Debugging" class="calibre2"><div class="preface" id="calibre_link-2608">
<h1 class="calibre18">Debugging</h1>

<p class="author1">Debugging is the art of figuring out whatâ€™s wrong with the behavior of your app as it runs. I divide this art into two main techniques: caveman debugging and pausing your running app.<a data-type="indexterm" data-primary="debugging" id="calibre_link-615" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Caveman Debugging" class="calibre2"><div class="preface" id="calibre_link-2609">
<h2 class="calibre42">Caveman Debugging</h2>

<p class="author1">Caveman debugging consists of altering your code, usually temporarily. Typically, youâ€™ll add code to produce informative messages that youâ€™ll read in the Xcode console in the project windowâ€™s Debug pane as your app runs.<a data-type="indexterm" data-primary="caveman debugging" id="calibre_link-348" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The chief Swift command for sending a message to the Xcode console is the <code class="calibre19">print</code> function. You might print a string saying where the path of execution is:</p>

<pre data-type="programlisting" class="calibre28">print("view did load")</pre>

<p class="author1">You might output a value:</p>

<pre data-type="programlisting" class="calibre28">print("i is", i)</pre>

<p class="author1">When you print an object, the output comes from that objectâ€™s <code class="calibre19">description</code> property. Cocoa objects generally have a useful built-in <code class="calibre19">description</code> property implementation. For example:<a data-type="indexterm" data-primary="print" id="calibre_link-1724" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="console" id="calibre_link-536" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">print(self.view)</pre>

<p class="author1">The output in the console reads something like this (Iâ€™ve formatted it for clarity here):</p>

<pre data-type="programlisting" class="calibre28">&lt;UIView: 0x79121d40;
  frame = (0 0; 320 480);
  autoresize = RM+BM;
  layer = &lt;CALayer: 0x79121eb0&gt;&gt;</pre>

<p class="author1">We learn the objectâ€™s class, its address in memory (useful for confirming whether two instances are in fact the same instance), and the values of some additional properties. In your own object types, you can adopt CustomStringConvertible and implement the <code class="calibre19">description</code> property as desired (<a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>).</p>

<p class="author1">Instead of <code class="calibre19">print</code>, you might like to use <code class="calibre19">dump</code>. Its console output describes an object along with its class inheritance and its instance properties, by way of a Mirror object. For example:<a data-type="indexterm" data-primary="dump" id="calibre_link-718" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">dump(self)</pre>

<p class="author1">If <code class="calibre19">self</code> is a view controller of class ViewController with a <code class="calibre19">didInitialSetup</code> instance property, the console output looks like this:</p>

<pre data-type="programlisting" class="calibre28">* ViewController
  - super: UIViewController
    - super: UIResponder
      - super: NSObject
  - didInitialSetup: true</pre>

<p class="author1">In your own object types, you can adopt CustomReflectable and implement the <code class="calibre19">customMirror</code> property as desired (<a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>).</p>

<p class="author1">An important feature of <code class="calibre19">print</code> and <code class="calibre19">dump</code> is that they are effectively suppressed when the app is launched independently of Xcode. Thatâ€™s good, because it means youâ€™re free to pepper your code with <code class="calibre19">print</code> statements and theyâ€™ll have no effect on your app in the real world. But what if you want to send yourself messages when youâ€™re running the app independently of Xcode?</p>

<p class="author1">If youâ€™re importing Foundation &mdash; and in real-life iOS programming, you are &mdash; you have access to the <code class="calibre19">NSLog</code> C function.<a data-type="indexterm" data-primary="logging" id="calibre_link-1249" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="NSLog" id="calibre_link-1445" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> It takes an NSString which operates as a format string, followed by the format arguments. A <em class="calibre11">format string</em> is a string containing symbols called <em class="calibre11">format specifiers</em>, for which values (the format arguments) will be substituted at runtime.<a data-type="indexterm" data-primary="format string" id="calibre_link-886" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> All format specifiers begin with a percent sign (<code class="calibre19">%</code>), so the only way to enter a literal percent sign in a format string is as a double percent sign (<code class="calibre19">%%</code>). The character(s) following the percent sign specify the type of value that will be supplied at runtime. The most common format specifiers are <code class="calibre19">%@</code> (an object reference), <code class="calibre19">%d</code> (an int), <code class="calibre19">%ld</code> (a long), and <code class="calibre19">%f</code> (a double). (See â€œString Format Specifiersâ€ in Appleâ€™s <em class="calibre11">String Programming Guide</em> in the documentation archive.) For example:<a data-type="indexterm" data-primary="strings" data-secondary="format" id="calibre_link-2097" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">NSLog("the view: %@", self.view)</pre>

<p class="author1">In that example, <code class="calibre19">self.view</code> is the first (and only) format argument, so its value will be substituted for the first (and only) format specifier, <code class="calibre19">%@</code>, when the format string is printed in the console:</p>

<pre data-type="programlisting" class="calibre28">2015-01-26 10:43:35.314 Empty Window[23702:809945]
  the view: &lt;UIView: 0x7c233b90;
    frame = (0 0; 320 480);
    autoresize = RM+BM;
    layer = &lt;CALayer: 0x7c233d00&gt;&gt;</pre>

<p class="author1"><code class="calibre19">NSLog</code> is in the process of being superseded by a new unified logging system, OSLog. To use it, <code class="calibre19">import os</code> and create an OSLog object, typically as an instance property or global:<a data-type="indexterm" data-primary="OSLog" id="calibre_link-1636" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">import os
let mylog = OSLog(subsystem: "com.neuburg.matt", category: "testing")</pre>

<p class="author1">The <code class="calibre19">subsystem</code> and <code class="calibre19">category</code> strings are arbitrary but useful, because you can refer to them to focus on the particular log messages that interest you. To send a log message, call the <code class="calibre19">os_log</code> function; like <code class="calibre19">NSLog</code>, it uses a format string along with format arguments, plus you have to specify an OSLog object:</p>

<pre data-type="programlisting" class="calibre28">os_log("%{public}@", log: mylog, "this is a test of os_log")</pre>

<p class="author1">For more about OSLog and the structure of <code class="calibre19">os_log</code> format strings, see <a href="https://developer.apple.com/documentation/os/logging" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/documentation/os/logging</em></a>. In addition to the extra specifiers such as the subsystem and category, a major reason to prefer <code class="calibre19">os_log</code> over <code class="calibre19">NSLog</code> is that messages from <code class="calibre19">NSLog</code> are truncated at 1024 characters.</p>

<p class="author1">Messages from  <code class="calibre19">NSLog</code> or <code class="calibre19">os_log</code> work even when the app is running outside of Xcode.
To view them, use the Console application. In the Sources pane at the left, under Devices, are shown all running simulators and any devices currently paired with the computer. Select the desired device and exercise the app, while watching the Console output. To eliminate unwanted output, set up a filter in the toolbar search field. You can filter by the name of the process (that is, the name of your app); even better, if youâ€™re using <code class="calibre19">os_log</code>, you can filter by the subsystem and category you configured when creating your OSLog object.<a data-type="indexterm" data-primary="Console application" id="calibre_link-537" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In the Xcode console, <code class="calibre19">NSLog</code> and <code class="calibre19">os_log</code> provide extra information along with each log message: the current time and date, along with the process name, process ID, and thread ID (useful for determining whether two logging statements are called on the same thread). In the Console application, you can see that same information by displaying the Time, Process, and Thread ID columns, plus you can show Category, Subsystem, and Type columns.</p>

<p class="author1">Another useful form of caveman debugging is deliberately aborting your app because something has gone seriously wrong. See the discussion of <code class="calibre19">assert</code>, <code class="calibre19">precondition</code>, and <code class="calibre19">fatalError</code> in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>. <code class="calibre19">precondition</code> and <code class="calibre19">fatalError</code> work even in a Release build. By default, <code class="calibre19">assert</code> is inoperative in a Release build, so it is safe to leave it in your code when your app is ready to ship; by that time, of course, you should be confident that the bad situation your <code class="calibre19">assert</code> was intended to detect has been debugged and will never actually occur.</p>

<p class="author1">Purists may scoff at caveman debugging, but I use it heavily: itâ€™s easy, informative, and lightweight. And sometimes itâ€™s the only way. Unlike the debugger, console logging works with any build configuration (Debug or Release) and wherever your app runs (in the Simulator or on a device). It works when pausing is impossible (because of threading issues, for example). It even works on someone elseâ€™s device, such as a tester to whom youâ€™ve distributed your app.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Swift defines four special literals, particularly useful when logging because they describe their own position in the surrounding file: <code class="calibre19">#file</code>, <code class="calibre19">#line</code>, <code class="calibre19">#column</code>, and <code class="calibre19">#function</code>.<a data-type="indexterm" data-primary="literals" data-secondary="logging" id="calibre_link-1234" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="The Xcode Debugger" class="calibre2"><div class="preface" id="calibre_link-2610">
<h2 class="calibre42">The Xcode Debugger</h2>

<p class="author1">When Xcode is running your app, you can pause in the debugger and use Xcodeâ€™s debugging facilities. The important thing, if you want to use the debugger, is that the app should be built with the Debug build configuration (the default for a schemeâ€™s Run action). The debugger is not very helpful against an app built with the Release build configuration, not least because compiler optimizations can destroy the correspondence between steps in the compiled code and lines in your source code.<a data-type="indexterm" data-primary="debugger, Xcode" id="calibre_link-614" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Breakpoints" class="calibre2"><div class="preface" id="calibre_link-2993">
<h3 class="calibre44">Breakpoints</h3>

<p class="author1">There isnâ€™t a strong difference between running and debugging in Xcode; the main distinction is whether breakpoints are effective or ignored. The effectiveness of breakpoints can be toggled at two levels:</p>
<dl class="calibre14">
<dt class="calibre15">Globally (active vs. inactive)</dt>
<dd class="calibre16">
<p class="calibre17">Breakpoints as a whole are either <em class="calibre11">active or inactive</em>. If breakpoints are inactive, we wonâ€™t pause at any breakpoints.</p>
</dd>
<dt class="calibre15">Individually (enabled vs. disabled)</dt>
<dd class="calibre16">
<p class="calibre17">A given breakpoint is either <em class="calibre11">enabled or disabled</em>. Even if breakpoints are active, we wonâ€™t pause at this one if it is disabled. Disabling a breakpoint allows you to leave in place a breakpoint that you might need later without pausing at it every time itâ€™s encountered.</p>
</dd>
</dl>

<p class="author1">To create a breakpoint,<a data-type="indexterm" data-primary="breakpoints" id="calibre_link-275" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> select in the editor the line where you want to pause, and choose Debug â†’ Breakpoints â†’ Add/Remove Breakpoint at Current Line (Command-\). This menu item toggles between adding and removing a breakpoint for the current line. Alternatively, a simple click in the gutter adds a breakpoint. The breakpoint is symbolized by an arrow in the gutter (<a data-type="xref" href="#calibre_link-21" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-8</a>, first). To remove a breakpoint gesturally, drag the arrow out of the gutter.</p>

<figure class="calibre32"><div id="calibre_link-21" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-8. </span>A breakpoint</h6>
</div>
</figure>

<p class="author1">To disable a breakpoint at the current line, click the breakpoint in the gutter to toggle its enabled status. Alternatively, Control-click the breakpoint and choose Disable Breakpoint in the contextual menu. A dark breakpoint is enabled; a light breakpoint is disabled (<a data-type="xref" href="#calibre_link-21" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-8</a>, second).</p>

<p class="author1">To toggle the active status of breakpoints as a whole, click the Breakpoints button in the debug bar, or choose Debug â†’ Activate/Deactivate Breakpoints (Command-Y). If breakpoints are inactive, they are simply ignored <em class="calibre11">en masse</em>, and no pausing at breakpoints takes place. Breakpoint arrows are blue if breakpoints are active, gray if they are inactive (<a data-type="xref" href="#calibre_link-21" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-8</a>, third). The active status of breakpoints as a whole doesnâ€™t affect the enabled or disabled status of any breakpoints.</p>

<p class="author1">Once you have some breakpoints in your code, youâ€™ll want to survey and manage them. Thatâ€™s what the Breakpoint navigator is for. Here you can navigate to a breakpoint, enable or disable a breakpoint by clicking on its arrow in the navigator, and delete a breakpoint.</p>

<p class="author1">You can also configure a breakpointâ€™s behavior. Control-click the breakpoint, in the gutter or in the Breakpoint navigator, and choose Edit Breakpoint; or double-click the breakpoint. You can have a breakpoint pause only under a certain condition or after it has been encountered a certain number of times, and you can have a breakpoint perform one or more actions when it is encountered, such as issuing a debugger command, logging, playing a sound, speaking text, or running a script. A breakpoint whose behavior has been configured is badged (<a data-type="xref" href="#calibre_link-21" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-8</a>, fourth).</p>

<p class="author1">A breakpoint can be configured to continue automatically after performing its action when it is encountered. A breakpoint that logs and continues can be an excellent alternative to caveman debugging. By definition, such a breakpoint operates only when youâ€™re actively debugging the project; it wonâ€™t dump any messages into the console when the app runs independently, because breakpoints exist only in Xcode.</p>

<p class="author1">Certain special kinds of breakpoint (<em class="calibre11">event</em> breakpoints) can be created in the Breakpoint navigator &mdash; click the Plus button at the bottom of the navigator and choose from its pop-up menu &mdash; or by choosing from the Debug â†’ Breakpoints hierarchical menu:</p>
<dl class="calibre14">
<dt class="calibre15">Swift error breakpoint</dt>
<dd class="calibre16">
<p class="calibre17">Pauses when your code says <code class="calibre19">throw</code>.</p>
</dd>
<dt class="calibre15">Exception breakpoint</dt>
<dd class="calibre16">
<p class="calibre17">Pauses when an Objective-C exception is thrown or caught, without regard to whether the exception would crash your app later. An exception breakpoint that pauses on all exceptions when they are thrown gives the best view of the call stack and variable values at the moment of the exception.<a data-type="indexterm" data-primary="exception breakpoint" id="calibre_link-813" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Sometimes Appleâ€™s code will throw an exception and catch it, deliberately. This isnâ€™t a crash, and nothing has gone wrong; but if youâ€™ve created an exception breakpoint, your app will pause at it, which can be confusing. If this happens to you, choose Debug â†’ Continue to resume your app; if it keeps happening, you might need to disable the exception breakpoint.</p>
</div>
<dl class="calibre14">
<dt class="calibre15">Symbolic breakpoint</dt>
<dd class="calibre16">
<p class="calibre17">Pauses when a certain method or function is called, regardless of what object called it. The method doesnâ€™t have to be your method! Thus, a symbolic breakpoint can help you probe Cocoaâ€™s behavior. A method may be specified in one of two ways:<a data-type="indexterm" data-primary="symbolic breakpoint" id="calibre_link-2186" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div class="preface"><dl class="calibre14">
<dt class="calibre15">Using Objective-C method notation</dt>
<dd class="calibre16">
<p class="calibre17">The instance method or class method symbol (<code class="calibre19">-</code> or <code class="calibre19">+</code>) followed by square brackets containing the class name and the method name:</p>

<pre data-type="programlisting" class="calibre28">-[UIApplication beginReceivingRemoteControlEvents]</pre>
</dd>
<dt class="calibre15">By Objective-C method name</dt>
<dd class="calibre16">
<p class="calibre17">The Objective-C method name alone. The debugger will resolve this for you into all possible class&ndash;method pairs, as if you had entered them using the Objective-C notation that I just described:</p>

<pre data-type="programlisting" class="calibre28">beginReceivingRemoteControlEvents</pre>
</dd>
</dl>
</div>


<p class="calibre17">If you enter the method specification incorrectly, the symbolic breakpoint wonâ€™t do anything; however, you might be assisted by code completion,
and in general youâ€™ll know if you got things right, because youâ€™ll see the resolved breakpoint(s) listed hierarchically below yours (though resolution may not take place until you actually run the project).</p>
</dd>
<dt class="calibre15">Runtime Issue breakpoint</dt>
<dd class="calibre16">
<p class="calibre17">New in Xcode 11. Pauses when a runtime issue is encountered. There are four types; for all but the System Frameworks type (useful especially with SwiftUI), youâ€™ll need to enable the corresponding diagnostic in the Scheme editor.</p>
</dd>
</dl>

<p class="author1">Breakpoints come in three levels of exposure:</p>
<dl class="calibre14">
<dt class="calibre15">Local to you and a project</dt>
<dd class="calibre16">
<p class="calibre17">The default. The breakpoint appears in this project on this machine.</p>
</dd>
<dt class="calibre15">Global to you</dt>
<dd class="calibre16">
<p class="calibre17">Use the contextual menu to say Move Breakpoint To â†’ User. The breakpoint now appears in all your projects on this machine. Symbolic and exception breakpoints are particularly good candidates for this level.</p>
</dd>
<dt class="calibre15">Shared with others</dt>
<dd class="calibre16">
<p class="calibre17">Use the contextual menu to say Share Breakpoint. The breakpoint is now visible in this project to others with whom you share the project (for example, through version control).</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Paused at a breakpoint" class="calibre2"><div class="preface" id="calibre_link-2994">
<h3 class="calibre44">Paused at a breakpoint</h3>

<p class="author1">When the app runs with breakpoints active and an enabled breakpoint is encountered (and assuming its conditions are met, and so on), the app pauses. In the active project window, the editor shows the file containing the point of execution, which will usually be the file containing the breakpoint. We are paused at the line that is <em class="calibre11">about</em> to be executed, which is shown by the <em class="calibre11">instruction pointer</em> (<a data-type="xref" href="#calibre_link-22" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-9</a>). Depending on the settings for Running â†’ Pauses in the Behaviors preference pane, the Debug navigator and the Debug pane may also appear.</p>

<figure class="calibre32"><div id="calibre_link-22" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-9. </span>Paused at a breakpoint</h6>
</div>
</figure>

<p class="author1">Here are some things you might like to do while paused at a breakpoint:<a data-type="indexterm" data-primary="Debug pane" id="calibre_link-613" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">See where you are</dt>
<dd class="calibre16">
<p class="calibre17">One common reason for setting a breakpoint is to make sure that the path of execution is passing through a certain line. Functions listed in the call stack<a data-type="indexterm" data-primary="call stack" id="calibre_link-329" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> in the Debug navigator<a data-type="indexterm" data-primary="Debug navigator" id="calibre_link-610" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> with a User icon in a dark blue background are yours; click one to see where you are paused in that function. (Other listings are functions and methods for which you have no source code, so there would be little point clicking one unless you know something about assembly language.) You can also view and navigate the call stack using the jump bar in the debug bar.<a data-type="indexterm" data-primary="jump bar" data-secondary="Debug pane" id="calibre_link-1175" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="stack, call" id="calibre_link-2060" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Study variable values</dt>
<dd class="calibre16">
<p class="calibre17">In the Debug pane, variable values for the current scope (corresponding to whatâ€™s selected in the call stack) are visible in the variables list<a data-type="indexterm" data-primary="variables list" id="calibre_link-2342" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. You can see additional object features, such as collection elements, properties, and even some private information, by opening triangles.</p>

<p class="calibre17">You can use the search field to filter variables by name or value. If a formatted summary isnâ€™t sufficiently helpful, you can send <code class="calibre19">description</code> (or, if this object adopts CustomDebugStringConvertible, <code class="calibre19">debugDescription</code>) to an object variable and view the output in the console: choose Print Description of [Variable] from the contextual menu, or select the variable and click the Info button below the variables list.</p>

<p class="calibre17">You can also view a variableâ€™s value graphically: select the variable and click the Quick Look button (an eye icon) below the variables list, or press Spacebar. For example, in the case of a CGRect, the graphical representation is a correctly proportioned rectangle.<a data-type="indexterm" data-primary="Quick Look a variable" id="calibre_link-1835" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> You can make instances of your own custom class viewable in the same way; declare the following method and return an instance of one of the permitted types (see Appleâ€™s <em class="calibre11">Quick Look for Custom Types in the Xcode</em> <span class="publishername"><em class="calibre11">Debugger</em></span> in the documentation archive):</p>

<pre data-type="programlisting" class="calibre28">@objc func debugQuickLookObject() -&gt; Any {
    // ... create and return your graphical object here ...
}</pre>

<p class="calibre17">You can also inspect a variableâ€™s value in place in your code, by examining its data tip. To see a data tip, hover the mouse over the name of a variable in your code. The data tip is much like the display of this value in the variables list: thereâ€™s a flippy triangle that you can open to see more information, plus an Info button that displays the value description here and in the console, and a Quick Look button for showing a value graphically (<a data-type="xref" href="#calibre_link-23" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-10</a>). <a data-type="indexterm" data-primary="data tips" id="calibre_link-601" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<figure class="calibre32"><div id="calibre_link-23" class="figure">
<img src="images/000009.png" alt="ios11 0907" class="calibre71" />
<h6 class="calibre34"><span class="publishername">Figure 9-10. </span>A data tip</h6>
</div>
</figure>
<dl class="calibre14">
<dt class="calibre15">Set a watchpoint</dt>
<dd class="calibre16">
<p class="calibre17">A watchpoint is like a breakpoint, but instead of depending on a certain line of code it depends on a variableâ€™s value: the debugger pauses whenever the variableâ€™s value changes. You can set a watchpoint only while paused in the debugger. Control-click the variable in the variables list and choose Watch [Variable]. Watchpoints, once created, are listed and managed in the Breakpoint navigator.</p>
</dd>
<dt class="calibre15">Inspect your view hierarchy</dt>
<dd class="calibre16">
<p class="calibre17">You can study the view hierarchy while paused in the debugger.<a data-type="indexterm" data-primary="view debugging" id="calibre_link-2353" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Click the Debug View Hierarchy button in the debug bar, or choose Debug â†’ View Debugging â†’ Capture View Hierarchy. Views are listed in an outline in the Debug navigator. The editor displays your views; this is a three-dimensional projection that you can rotate. The Object inspector and the Size inspector display information about the currently selected view.</p>
</dd>
<dt class="calibre15">Inspect your object graph</dt>
<dd class="calibre16">
<p class="calibre17">Using the View Debugger, you can study the object graph (what objects youâ€™ve created and how they refer to one another) while paused in the debugger. Iâ€™ll talk more about that later in this chapter.</p>
</dd>
<dt class="calibre15">Manage expressions</dt>
<dd class="calibre16">
<p class="calibre17">An expression is code to be added to the variables list and evaluated every time we pause. Choose Add Expression from the contextual menu in the variables list. The expression is evaluated within the current context in your code, so be careful of side effects.</p>
</dd>
<dt class="calibre15">Talk to the debugger</dt>
<dd class="calibre16">
<p class="calibre17">You can communicate directly with the debugger through the console. Xcodeâ€™s debugger interface is a front end to the <em class="calibre11">real</em> debugger, LLDB<a data-type="indexterm" data-primary="LLDB" id="calibre_link-1241" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (<a href="http://lldb.llvm.org" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://lldb.llvm.org</em></a>); by talking directly to LLDB, you can do everything that you can do through the Xcode debugger interface, and more. Common commands are:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">ty loo</code> (short for <code class="calibre19">type lookup</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Followed by a type name, dumps a full declaration for the type, listing all its members (properties and methods). For Cocoa classes, you might get better information by performing the lookup in Objective-C: say <code class="calibre19">ty loo -l objc --</code> followed by the class name.</p>
</dd>
<dt class="calibre15"><code class="calibre19">v</code> (or <code class="calibre19">fr v</code>, short for <code class="calibre19">frame variable</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Alone, prints out all variables locally in scope, similar to the display in the variables list. Alternatively, can be followed by the name of a variable you want to examine. Fast and lightweight because it reaches right into the stack and grabs the value, but it has some limitations; for example, it doesnâ€™t work for computed properties.</p>
</dd>
<dt class="calibre15"><code class="calibre19">p</code> (or <code class="calibre19">expression</code>, <code class="calibre19">expr</code>, or simply <code class="calibre19">e</code>)</dt>
<dd class="calibre16">
<p class="calibre17">Compiles and executes, in the current context, any expression in the current language. Be careful of your expressionâ€™s side effects! This is more heavyweight than <code class="calibre19">v</code>.</p>
</dd>
<dt class="calibre15"><code class="calibre19">po</code> (meaning â€œprint objectâ€)</dt>
<dd class="calibre16">
<p class="calibre17">Like <code class="calibre19">p</code>, but displays the value of the executed expression in accordance with its <code class="calibre19">description</code> or <code class="calibre19">debugDescription</code> (similar to Print Description). It is actually an alias for <code class="calibre19">expr -O</code>, meaning â€œobject description.â€ Twice as expensive as <code class="calibre19">p</code> because it has to be compiled and executed <em class="calibre11">twice.</em></p>
</dd>
</dl>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Fiddle with breakpoints</dt>
<dd class="calibre16">
<p class="calibre17">You are free to create, destroy, edit, enable and disable, and otherwise manage breakpoints even while your app is running, which is useful because where youâ€™d like to pause next might depend on what you learn while youâ€™re paused here. Indeed, this is one of the main advantages of breakpoints over caveman debugging. To change your caveman debugging, you have to stop the app, edit it, rebuild it, and start running the app all over again. But to fiddle with breakpoints, you donâ€™t have to be stopped; you donâ€™t even have to be paused! An operation that went wrong, if it doesnâ€™t crash your app, can probably be repeated in real time, so you can just add a breakpoint and try again. For example, if tapping a button produces the wrong results, you can add a breakpoint to the action method and tap the button again; you pass through the same code, and this time you pause and can work out what the trouble is.</p>
</dd>
<dt class="calibre15">Continue or step</dt>
<dd class="calibre16">
<p class="calibre17">To proceed with your paused app, you can either resume running or take one step and pause again.
The commands are in the Debug menu, or you can click the convenient buttons in the debug bar:<a data-type="indexterm" data-primary="stepping" id="calibre_link-2076" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div class="preface"><dl class="calibre14">
<dt class="calibre15">Continue</dt>
<dd class="calibre16">
<p class="calibre17">Resume running (until a breakpoint is encountered).</p>
</dd>
<dt class="calibre15">Step Over</dt>
<dd class="calibre16">
<p class="calibre17">Pause at the next line.</p>
</dd>
<dt class="calibre15">Step Into</dt>
<dd class="calibre16">
<p class="calibre17">Pause in your function that the current line calls, if there is one; otherwise, pause at the next line.</p>
</dd>
<dt class="calibre15">Step Out</dt>
<dd class="calibre16">
<p class="calibre17">Pause when we return from the current function.</p>
</dd>
</dl>
</div>

</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Start over, or abort</dt>
<dd class="calibre16">
<p class="calibre17">To kill the running app, click Stop in the toolbar (Product â†’ Stop, Command-Period). Clicking the Home button in the Simulator (Hardware â†’ Home) or on the device does <em class="calibre11">not</em> stop the running app.</p>
</dd>
</dl>

<p class="author1">You can make changes to your code while the app is running or paused in the Simulator or on a device, but those changes are not magically communicated to the running app. To see your changes in action, you must stop the running app, build, run, and launch the app all over again.</p>

<p class="author1">However, you can inject changes into your code by means of an <code class="calibre19">expr</code> command, given either at the LLDB console or through a custom-configured breakpoint. Moreover, you can skip a line of code by dragging the instruction pointer down;
if you combine that with <code class="calibre19">expr</code>, youâ€™ve effectively replaced one line of code with another. Thus it may be possible to modify your appâ€™s logic and test a proposed change to your code <em class="calibre11">without</em> rebuilding and relaunching.<a data-type="indexterm" data-startref="idxdebug2" id="calibre_link-616" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Local variable values can exist even if, at the point where you are paused, those variables have not yet been initialized; but <em class="calibre11">such values are meaningless</em>, so ignore them. This applies to the variables list, data tips, and so forth. Forgetting this is a common beginner mistake.</p>
</div>
</div>
</section>



</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Testing" class="calibre2"><div class="preface" id="calibre_link-2611">
<h1 class="calibre18">Testing</h1>

<p class="author1">A <em class="calibre11">test</em> is code that isnâ€™t part of your app target; its purpose is to exercise your app and make sure that it works as expected. Tests can be of two kinds:</p>
<dl class="calibre14">
<dt class="calibre15">Unit tests</dt>
<dd class="calibre16">
<p class="calibre17">A unit test exercises your app <em class="calibre11">internally</em>, from the point of view of its <em class="calibre11">code</em>.<a data-type="indexterm" data-primary="unit tests" id="calibre_link-2279" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> For example, a unit test might call some method in your code, handing it various parameters and looking to see if the expected result is returned each time, not just under normal conditions but also when incorrect or extreme inputs are supplied.</p>
</dd>
<dt class="calibre15">Interface (UI) tests</dt>
<dd class="calibre16">
<p class="calibre17">An interface test exercises your app <em class="calibre11">externally</em>, from the point of view of a <em class="calibre11">user</em>. Such a test guides your app through use case scenarios by effectively tapping buttons with a ghost finger, watching to make sure that the interface behaves as expected.<a data-type="indexterm" data-primary="interface tests" id="calibre_link-1148" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="UI tests" id="calibre_link-2250" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">Tests &mdash; especially unit tests &mdash; should ideally be written and run constantly as you develop your app. It can even be useful to write unit tests <em class="calibre11">before</em> writing the real code, as a way of developing a working algorithm. Having initially ascertained that your code passes your tests, you continue to run those tests to detect whether a bug has been introduced during the course of development.<a data-type="indexterm" data-primary="tests" id="calibre_link-2209" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Tests are bundled in a separate target (see <a data-type="xref" href="#calibre_link-6" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;6</a>). The application templates give you an opportunity to add test targets at the time you create your project: in the second dialog (â€œChoose options for your new projectâ€), you can check Include Unit Tests or Include UI Tests, or both. Alternatively, you can easily create a new test target at any time: make a new target and specify iOS â†’ Test â†’ iOS Unit Testing Bundle or iOS UI Testing Bundle.<a data-type="indexterm" data-primary="target" data-secondary="test" id="calibre_link-2193" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="test target" id="calibre_link-2206" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A test class is a subclass of XCTestCase (which is itself a subclass of XCTest). A test method is an instance method of a test class, returning no value and taking no parameters, whose name starts with <code class="calibre19">test</code>. A test method does not run &mdash; indeed, it is not even compiled &mdash; until you explicitly ask to run or compile it. The test target depends upon the target to be tested (usually, your app target). This means that before a test class can be compiled and built, the target to be tested must be compiled and built. But building the target to be tested does <em class="calibre11">not</em> build the test target. To build a test target so as to learn whether its code compiles successfully, but without running a test method, choose Product â†’ Build For â†’ Testing.</p>

<p class="author1">A test method may call one or more test asserts; in Swift, these are global functions whose names begin with <code class="calibre19">XCTAssert</code>. For a list of these functions, see the XCTest class documentation. Calling a test assert is typically the entire point of writing a unit test; a successful test is one where all asserts succeed.</p>

<p class="author1">A test class may contain utility methods that are called by the test methods; their names do <em class="calibre11">not</em> begin with <code class="calibre19">test</code>. In addition, you can override any of four special methods inherited from XCTestCase:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">setUp</code> class method</dt>
<dd class="calibre16">
<p class="calibre17">Called once before <em class="calibre11">all</em> test methods in the class.</p>
</dd>
<dt class="calibre15"><code class="calibre19">setUp</code> instance method</dt>
<dd class="calibre16">
<p class="calibre17">Called before <em class="calibre11">each</em> test method.</p>
</dd>
<dt class="calibre15"><code class="calibre19">tearDown</code> instance method</dt>
<dd class="calibre16">
<p class="calibre17">Called after <em class="calibre11">each</em> test method.</p>
</dd>
<dt class="calibre15"><code class="calibre19">tearDown</code> class method</dt>
<dd class="calibre16">
<p class="calibre17">Called once after <em class="calibre11">all</em> test methods in the class.</p>
</dd>
</dl>

<p class="author1">As an alternative to the <code class="calibre19">tearDown</code> instance method, you can use a teardown <em class="calibre11">block</em>. To do so, call <code class="calibre19">self.addTeardownBlock(_:)</code> with a function (typically an anonymous function) to be called at teardown time; <code class="calibre19">self</code> here is the XCTestCase instance. When the teardown block is called depends on where it is added; if you call <code class="calibre19">addTeardownBlock</code> within a test method, the block is called only on exit from that method, but if you call it in the <code class="calibre19">setUp</code> instance method, the block is called after every test method, because the block was added freshly before every test method.</p>

<p class="author1">Running a test also runs the app. The test targetâ€™s product is a bundle; a unit test bundle is loaded into the app as it launches, whereas an interface test bundle is loaded into a special test runner app generated for you by Xcode. Resources, such as test data, can be included in the bundle. You might use <code class="calibre19">setUp</code> to load such resources; you can get a reference to the bundle by way of the test class, by saying <code class="calibre19">Bundle(for:Self.self)</code>.<a data-type="indexterm" data-primary="test bundle" id="calibre_link-2201" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bundle" data-secondary="test" id="calibre_link-309" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Unit Tests" class="calibre2"><div class="preface" id="calibre_link-2612">
<h2 class="calibre42">Unit Tests</h2>

<p class="author1">Unit tests can see into the target to be tested, because they depend on it; but, being a bundle, they also constitute a module. Therefore, the test target must import the target to be tested, as a module. To overcome privacy restrictions, the <code class="calibre19">import</code> statement should be preceded by the <code class="calibre19">@testable</code> attribute; this attribute temporarily changes <code class="calibre19">internal</code> (explicit or implicit) to <code class="calibre19">public</code> throughout the imported module.<a data-type="indexterm" data-primary="testable" id="calibre_link-2207" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">As an example of writing and running a unit test method, we can use our Empty Window project. Letâ€™s give the ViewController class a (nonsensical) instance method <code class="calibre19">dogMyCats</code>:</p>

<pre data-type="programlisting" class="calibre28">func dogMyCats(_ s:String) -&gt; String {
    return ""
}</pre>

<p class="author1">The method <code class="calibre19">dogMyCats</code> is supposed to receive any string and return the string <code class="calibre19">"dogs"</code>. At the moment, though, it doesnâ€™t; it returns an empty string instead. Thatâ€™s a bug. Now weâ€™ll write a test method to ferret out this bug.</p>

<p class="author1">First, weâ€™ll need a unit test target:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In the Empty Window project, choose File â†’ New â†’ Target and specify iOS â†’ Test â†’ iOS Unit Testing Bundle.</p>
</li>
<li class="calibre4">
<p class="calibre17">Call the product <em class="calibre11">EmptyWindowTests</em>; observe that the target to be tested is the app target.</p>
</li>
<li class="calibre4">
<p class="calibre17">Click Finish.</p>
</li>

</ol>

<p class="author1">In the Project navigator, a new group has been created, EmptyWindowTests, containing a single test file, <em class="calibre11"><span class="publishername">EmptyWindowTests.swift</span></em>. It contains a test class EmptyWindowTests, including stubs for two test methods, <code class="calibre19">testExample</code> and <code class="calibre19">testPerformanceExample</code>. Comment out those two methods. Weâ€™re going to replace them with a test method that calls <code class="calibre19">dogMyCats</code> and makes an assertion about the result:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">At the top of <em class="calibre11">EmptyWindowTests.swift</em>, where we are importing XCTest, we must also import the target to be tested, which is the app target:</p>

<pre data-type="programlisting" class="calibre38">@testable import Empty_Window</pre>
</li>
<li class="calibre4">
<p class="calibre17">Prepare an instance property in the declaration of the EmptyWindowTests class to store our ViewController instance:</p>

<pre data-type="programlisting" class="calibre38">var viewController = ViewController()</pre>
</li>
<li class="calibre4">
<p class="calibre17">Write the test method. Its name must start with <code class="calibre19">test</code>! Letâ€™s call it <code class="calibre19">testDogMyCats</code>. It has access to the ViewController instance as <code class="calibre19">self.viewController</code>:</p>

<pre data-type="programlisting" class="calibre38">func testDogMyCats() {
    let input = "cats"
    let output = "dogs"
    XCTAssertEqual(output,
        self.viewController.dogMyCats(input),
        "Failed to produce \(output) from \(input)")
}</pre>
</li>

</ol>

<p class="author1">We are now ready to run our test. There are many ways to do this. Switch to the Test navigator, and youâ€™ll see that it lists our test target, our test class, and our test method. You can run a test method, or the whole class suite, using the contextual menu
or with Run buttons that appear when you hover the mouse over a listing.
In addition, in <em class="calibre11">EmptyWindowTests.swift</em> itself, thereâ€™s a diamond-shaped indicator in the gutter to the left of the class declaration and the test method name; when you hover the mouse over it, it changes to a Run button. You can click that button to run, respectively, all tests in this class or an individual test. Or, to run all tests, you can choose Product â†’ Test.<a data-type="indexterm" data-primary="Test navigator" id="calibre_link-2204" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">After running a test, to run just that test again, choose Product â†’ Perform Action â†’ Run [Test] Again. To run multiple individual tests, Command-click in the Test navigator to select just those tests; then choose Product â†’ Perform Action â†’ Run [n] Test Methods (or use the contextual menu).</p>
</div>

<p class="author1">So now letâ€™s run <code class="calibre19">testDogMyCats</code>. The app target is compiled and built; the test target is compiled and built. (If any of those steps fails, we canâ€™t test, and weâ€™ll be back on familiar ground with a compile error or a build error.) The app launches in the Simulator, and the test runs.</p>

<p class="author1">The test fails! (Well, we knew that was going to happen, didnâ€™t we?)
The error is described in a banner next to the assert that failed in our code; moreover, red X marks appear everywhere &mdash; at the top of the project window, in the Test navigator next to <code class="calibre19">testDogMyCats</code>, and in <em class="calibre11">EmptyWindowTests.swift</em> next to the first line of <code class="calibre19">testDogMyCats</code>.</p>

<p class="author1">The best place to survey what went wrong is the Report navigator. Initially, youâ€™re shown a summary view. For even more detail, choose Test â†’ Log from the jump bar at the top of the editor (<a data-type="xref" href="#calibre_link-24" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-11</a>); by expanding transcripts, you can see the full console output from the test run, including any caveman debugging messages that you may have sent from your test code (to show them, you would click the little horizontal lines icon at the far right).<a data-type="indexterm" data-primary="Report navigator" id="calibre_link-1901" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-24" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-11. </span>The Report navigator describes a test failure</h6>
</div>
</figure>

<p class="author1">Now letâ€™s fix our code. In <em class="calibre11">ViewController.swift</em>, modify <code class="calibre19">dogMyCats</code> to return <code class="calibre19">"dogs"</code> instead of an empty string. Now run the test again. It passes!</p>

<p class="author1">When a test failure occurs, you might like to pause at the point where the assertion is about to fail. To do so, in the Breakpoint navigator, click the Plus button at the bottom and choose Test Failure Breakpoint. This is like an Exception breakpoint, pausing on the assert line in your test method just before it reports failure. You could then switch to the method being tested and debug it, examining its variables and so forth, to work out the reason for the impending failure.<a data-type="indexterm" data-primary="Test Failure breakpoint" id="calibre_link-2202" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Xcodeâ€™s code coverage feature lets you assess how much of your app targetâ€™s code is being exercised by your unit tests. To switch it on, edit the Test action in your scheme and check Code Coverage in the Options pane. Run your tests. Afterward, the Report navigator has a Coverage section displaying statistics (<a data-type="xref" href="#calibre_link-25" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-12</a>); you can also choose Editor â†’ Show Code Coverage (or use the Editor Options pop-up menu at the top right of the editor pane) to reveal a gutter at the right of your code calling attention to stretches of code that didnâ€™t run during the tests.<a data-type="indexterm" data-primary="code" data-secondary="coverage" id="calibre_link-430" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="coverage, code" id="calibre_link-560" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-25" class="figure">
<img src="images/000027.png" alt="ios12 0907bb" class="calibre72" />
<h6 class="calibre34"><span class="publishername">Figure 9-12. </span>The Report navigator displays code coverage statistics</h6>
</div>
</figure>

<p class="author1">Thereâ€™s considerably more to learn about unit tests. Asynchronous testing allows a test method to wait for a time-consuming operation to finish. Performance testing lets you check that the speed of an operation has not fallen off by running that operation repeatedly and timing the result; the first time you run a performance test, you establish a baseline measurement, and on subsequent runs, it fails if the standard deviation of the times is too far from the baseline, or if the average time has grown too much. New in Xcode 11, a performance test can exercise launching your app and report whether it launches as quickly as it should.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Interface Tests" class="calibre2"><div class="preface" id="calibre_link-2613">
<h2 class="calibre42">Interface Tests</h2>

<p class="author1">Now letâ€™s experiment with interface testing. Iâ€™m going to assume that you still have (from <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>) a button in the Empty Window interface with an action connection to a ViewController method that summons an alert. Weâ€™ll write a test that taps that button and makes sure that the alert is summoned. Add an iOS UI Testing Bundle to the project; call it <em class="calibre11">EmptyWindowUITests</em>.</p>

<p class="author1">Interface test code is based on <em class="calibre11">accessibility</em>, a feature that allows the screen interface to be described verbally and to be manipulated programmatically. It revolves around <span class="publishername">three classes:</span> XCUIElement, XCUIApplication (an XCUIElement subclass), and <span class="publishername">XCUIElementQuery.</span> In the long run, itâ€™s best to learn about these classes and write your own UI test code; but to help you get started, accessibility actions are <em class="calibre11">recordable</em>, meaning that you can generate code automatically by performing the actual actions that constitute the test. Letâ€™s try it:<a data-type="indexterm" data-primary="accessibility" id="calibre_link-108" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In the <code class="calibre19">testExample</code> stub method, create a new empty line and leave the insertion point within it.</p>
</li>
<li class="calibre4">
<p class="calibre17">Choose Editor â†’ Start Recording UI Test. (Alternatively, thereâ€™s a Record button in the debug bar.) The app launches in the Simulator.</p>
</li>
<li class="calibre4">
<p class="calibre17">In the Simulator, tap the button in the interface. When the alert appears, tap OK to dismiss it.</p>
</li>
<li class="calibre4">
<p class="calibre17">Return to Xcode and choose Editor â†’ Stop Recording UI Test. Also choose Product â†’ Stop to stop running in the Simulator.</p>
</li>

</ol>

<p class="author1">The following code, or something similar, has been generated:</p>

<pre data-type="programlisting" class="calibre28">let app = XCUIApplication()
app.buttons["Hello"].tap()
app.alerts["Howdy!"].buttons["OK"].tap()</pre>

<p class="author1">The <code class="calibre19">app</code> object, obviously, is an XCUIApplication instance. Properties such as <code class="calibre19">buttons</code> and <code class="calibre19">alerts</code> return XCUIElementQuery objects. Subscripting such an object returns an XCUIElement, which can then be sent action methods such as <code class="calibre19">tap</code>.</p>

<p class="author1">Now run the test by clicking in the diamond in the gutter at the left of the <code class="calibre19">testExample</code> declaration. The app launches in the Simulator, and a ghost finger performs the same actions we performed, tapping first the button in the interface and then, when the alert appears, the OK button that dismisses it. The test ends and the app stops running in the simulator. The test passes!</p>

<p class="author1">More important, if the interface stops looking and behaving as it does now, the test will <em class="calibre11">not</em> pass. To see this, in <em class="calibre11">Main.storyboard</em>, select the button and, under Control in the Attributes inspector, uncheck Enabled. The button is still there, but it canâ€™t be tapped; weâ€™ve broken the interface. Run the test. The test fails, and the Report navigator explains why (<a data-type="xref" href="#calibre_link-26" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-13</a>): when we came to the Tap â€œOKâ€ Button step, we first had to Find the â€œOKâ€ Button, and we failed because there was no alert. Ingeniously, the report also supplies lots of information about the view hierarchy, along with a screenshot, so that we can inspect the state of the interface during the test. Under Find the â€œOKâ€ Button, you can double-click Automatic Screenshot to learn what the screen looked like at that moment: itâ€™s easy to see the disabled interface button (and no alert).</p>

<figure class="calibre32"><div id="calibre_link-26" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-13. </span>The Report navigator displays a failed UI test</h6>
</div>
</figure>










<section data-type="sect3" data-pdf-bookmark="Persisting screenshots" class="calibre2"><div class="preface" id="calibre_link-2995">
<h3 class="calibre44">Persisting screenshots</h3>

<p class="author1">Screenshots such as those taken automatically during the UI test I just described can be useful for other purposes. You might like to retain a more permanent record of how your interface looks under various circumstances &mdash; for example, as marketing materials, for submission to the App Store, or to help with localization. In fact, you might construct some of your UI tests for no other purpose than to take screenshots for you!<a data-type="indexterm" data-primary="screenshots" id="calibre_link-1961" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To this end, you can have your UI test <em class="calibre11">deliberately</em> take a screenshot and make it persist. To do so, call the XCUIElement (or XCUIScreen) <code class="calibre19">screenshot</code> method, turn the resulting XCUIScreenshot object into an XCTAttachment, and call the XCTestCase <code class="calibre19">add</code> method to retain the actual screenshot. Along the way, be sure to extend the lifetime of the attachment so that it persists even if the test succeeds; you can also give the screenshot a convenient name:</p>

<pre data-type="programlisting" class="calibre28">let screenshot = XCUIApplication().screenshot()
let attachment = XCTAttachment(screenshot: screenshot)
attachment.lifetime = .keepAlways
attachment.name = "OpeningScreen"
self.add(attachment)</pre>

<p class="author1">In the Report navigator, our screenshot is displayed under the name we assigned to it (<a data-type="xref" href="#calibre_link-27" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-14</a>).</p>

<figure class="calibre32"><div id="calibre_link-27" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-14. </span>The Report navigator displays a persisting screenshot</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Interface testing and accessibility" class="calibre2"><div class="preface" id="calibre_link-2996">
<h3 class="calibre44">Interface testing and accessibility</h3>

<p class="author1">During interface testing, your app is in effect being viewed from the outside, as a human being would view it. As Iâ€™ve already said, that depends upon accessibility. Standard interface objects are accessible, but other interface that you create might not be. Select an interface element in the nib editor to view its accessibility characteristics in the Identity inspector. Run the app in the Simulator and choose Xcode â†’ Open Developer Tool â†’ Accessibility Inspector to explore in real time the accessibility characteristics of whatever is under the cursor.</p>

<p class="author1">Another useful trick is to put a breakpoint in a UI test method, run the test, pause, and tell the debugger to <code class="calibre19">po XCUIApplication()</code> to see the full view hierarchy as accessibility sees it. To see fewer results, form a query specifying the type of entity youâ€™re interested in; for example, <code class="calibre19">po XCUIApplication().buttons</code>.</p>

<p class="author1">Referring to an interface object by its visible title, as in our code <code class="calibre19">app.buttons["Hello"]</code>, is poor practice. If the title changes, or if the app is localized for another language (discussed later in this chapter), the reference breaks. Instead, we should give our button a fixed accessibility identifier, either in code or in the Identity inspector in the nib editor. For example, if the Hello buttonâ€™s accessibility identifier is <code class="calibre19">GreetingButton</code>, we can refer to it as <code class="calibre19">app.buttons["GreetingButton"]</code> instead.</p>

<p class="author1">For more about adding useful accessibility to your interface objects, see Appleâ€™s <em class="calibre11">Accessibility Programming Guide for iOS</em> in the documentation archive.</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Test Plans" class="calibre2"><div class="preface" id="calibre_link-2614">
<h2 class="calibre42">Test Plans</h2>

<p class="author1">When youâ€™ve build up several suites of tests, youâ€™ll want a way to configure what tests should be run under what conditions on a given occasion. In the past, such configuration was confined to a scheme. By editing a schemeâ€™s Test action, you could determine the complete set of tests that would run when you chose Product â†’ Test. If you wanted more than one set of tests, you needed multiple schemes.<a data-type="indexterm" data-primary="test plans" id="calibre_link-2205" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">New in Xcode 11, this scheme-based architecture is superseded by test plans. A test plan is a text file (in JSON format), but you wonâ€™t have to deal with it as text; you edit it in a dedicated editor, similar to how an <em class="calibre11">Info.plist</em> is treated. To create a test plan, choose Product â†’ Test Plan â†’ New Test Plan. The test plan should not be part of any target, and youâ€™ll probably put it at the top level of your project. Edit the new test plan. Click the Plus button and select the targets containing the tests you want to use.</p>

<p class="author1">In the Tests pane of the test plan, you can specify individual test classes and test methods to be run.
In the Configurations pane, you can specify the behavior of your tests, including various choices you would previously have made in the scheme editor and elsewhere: system language, simulated location, screenshot policy, diagnostics, whether to use code coverage, and whether tests should run in random order (which can help unmask hidden dependencies between tests).</p>

<p class="author1">You can make configuration choices on two levels, a set of shared settings and individual named configurations that inherit the shared settings and can override them. Itâ€™s important to give each named configuration a meaningful name, because this name is the identifier that will be displayed in the test report.</p>

<p class="author1">Having created one or more test plans, you still canâ€™t <em class="calibre11">use</em> them for anything until you convert your scheme to use test plans. To do so, choose Product â†’ Scheme â†’ Convert Scheme to Use Test Plans. (I presume that some day test plans will be the default and this step will no longer be needed.) You are offered various ways to add test plans to your scheme. You should add to your scheme <em class="calibre11">every</em> test plan you might want to use with this scheme.</p>

<p class="author1">Your scheme may now have multiple test plans, but only one test plan is current at any given moment. When you choose Product â†’ Test, it is the current test plan that runs.
Hereâ€™s how the current test plan is determined:</p>
<dl class="calibre14">
<dt class="calibre15">In the Test navigator</dt>
<dd class="calibre16">
<p class="calibre17">At the top, the Test navigator has a pop-menu letting you pick a test plan from among those attached to the current scheme. Whatever test plan is currently displayed here is the current test plan. If the current test plan doesnâ€™t include a test, that test is dimmed and you canâ€™t run it from the Test navigator (though of course you can select it and run it from the test source).</p>
</dd>
<dt class="calibre15">In the Product menu</dt>
<dd class="calibre16">
<p class="calibre17">The Product â†’ Test Plan hierarchical menu lists the test plans attached to the current scheme. Whatever test plan is checked here is the current test plan.</p>
</dd>
</dl>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">If a test plan has more than one configuration, then when that test plan is current, if you run any test method within that test plan, by default it runs under <em class="calibre11">all</em> configurations successively. If that isnâ€™t what you want, Control-click to summon the contextual menu; it lets you specify a configuration for this run.</p>
</div>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Clean" class="calibre2"><div class="preface" id="calibre_link-2615">
<h1 class="calibre18">Clean</h1>

<p class="author1">From time to time, during repeated testing and debugging, and before making a different sort of build (switching from Debug to Release, or running on a device instead of the Simulator), itâ€™s a good idea to <em class="calibre11">clean</em> your target.<a data-type="indexterm" data-primary="cleaning" id="calibre_link-402" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This means that existing builds will be removed and caches will be cleared, so that all code will be considered to be in need of compilation and you can build your app from scratch.</p>

<p class="author1">Cleaning removes the cruft, quite literally. For example, suppose you have been including a certain resource in your app, and you decide it is no longer needed. You can remove it from the Copy Bundle Resources build phase (or from your project as a whole), but that doesnâ€™t necessarily remove it from your built app. This sort of leftover resource can cause all kinds of mysterious trouble. The wrong version of a nib may seem to appear in your interface; code that youâ€™ve edited may seem to behave as it did before the edit. Cleaning removes the built app, and very often solves the <span class="publishername">problem.</span></p>

<p class="author1">You can choose Product â†’ Clean Build Folder, which removes the entire build folder for this project. For an even more extensive cleaning, quit Xcode, open your user <em class="calibre11">~/Library/Developer/Xcode/DerivedData</em> folder, and move all its contents to the trash. This is a complete clean for every project youâ€™ve opened recently &mdash; plus the module cache. Removing the module cache can reset Swift itself, thus causing occasional mysterious compilation, code completion, or syntax coloring issues to go away.</p>

<p class="author1">In addition to cleaning your project, you should also remove your app from the Simulator. This is for the same reason as cleaning the project: when a new build of the app is copied to the Simulator, existing resources inside the old build may not be removed (in order to save time), and this may cause the app to behave oddly. To clean out the current simulator while running the Simulator, choose Hardware â†’ Erase All Content and Settings. To clean out <em class="calibre11">all</em> simulators, quit the Simulator and then say, in the <span class="publishername">Terminal:</span></p>

<pre data-type="programlisting" class="calibre28">$ xcrun simctl erase all</pre>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Running on a Device" class="calibre2"><div class="preface" id="calibre_link-2616">
<h1 class="calibre18">Running on a Device</h1>

<p class="author1">Eventually, youâ€™ll want to progress from running and testing and debugging in the Simulator to running and testing and debugging on a real device.<a data-type="indexterm" data-primary="device" data-secondary="running on" id="calibre_link-659" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="running on a device" id="calibre_link-1942" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The Simulator is nice, but itâ€™s only a simulation; there are many differences between the Simulator and a real device. The Simulator is really your computer, which is fast and has lots of memory, so problems with memory management and speed wonâ€™t be exposed until you run on a device. User interaction with the Simulator is limited to what can be done with a mouse: you can click, you can drag, you can hold Option to simulate use of two fingers, but more elaborate gestures can be performed only on an actual device. And many iOS facilities, such as the accelerometer and access to the music library, are not present on the Simulator at all, so that testing an app that uses them is possible <em class="calibre11">only</em> on a device.</p>

<p class="author1">Running your app on a device requires a Developer Program membership, which in turn requires an annual fee. You may balk initially, but sooner or later youâ€™re going to get over it and accept that this fee is worth paying. (You can obtain a temporary ability to run your app on a device <em class="calibre11">without</em> a paid Developer Program membership, but this ability is very limited and Iâ€™m not going to discuss it.)</p>








<section data-type="sect2" data-pdf-bookmark="Obtaining a Developer Program Membership" class="calibre2"><div class="preface" id="calibre_link-2617">
<h2 class="calibre42">Obtaining a Developer Program Membership</h2>

<p class="author1">To obtain a Developer Program membership, go to the Apple Developer Program web page (<a href="https://developer.apple.com/programs" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/programs</em></a>) and initiate the enrollment process. When youâ€™re starting out, the Individual program is sufficient. The Organization program costs no more, but adds the ability to privilege additional team members in various roles; you do <em class="calibre11">not</em> need the Organization program merely to distribute your built app to other users for testing.</p>

<p class="author1">Your Developer Program membership involves two things:</p>
<dl class="calibre14">
<dt class="calibre15">An Apple ID<a data-type="indexterm" data-primary="Apple ID" id="calibre_link-168" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></dt>
<dd class="calibre16">
<p class="calibre17">The user ID that identifies you at Appleâ€™s site (along with the corresponding password). Youâ€™ll use your Developer Program Apple ID for all kinds of things. In addition to letting you prepare an app to run on a device, this same Apple ID lets you post on Appleâ€™s development forums, download Xcode beta versions, and so forth.</p>
</dd>
<dt class="calibre15">A team<a data-type="indexterm" data-primary="team" id="calibre_link-2196" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> name</dt>
<dd class="calibre16">
<p class="calibre17">You, under a single Apple ID, can belong to more than one <em class="calibre11">team</em>. On each team, you will have one or more <em class="calibre11">roles</em> dictating your privileges. If you are the head (or sole member) of the team, you are the <em class="calibre11">team agent</em>, meaning that you can do everything: you can develop apps, run them on your device, submit apps to the App Store, and receive the money for any paid apps that sell copies there.</p>
</dd>
</dl>

<p class="author1">Having established your Developer Program Apple ID, you should enter it into the Accounts preference pane in Xcode. Click the Plus button at the bottom left and select Apple ID as the type of account to add. Provide the Apple ID and password. From now on, Xcode will identify you through the team name(s) associated with this Apple ID; you shouldnâ€™t need to tell Xcode this password again.<a data-type="indexterm" data-primary="Accounts preferences" id="calibre_link-111" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Signing an App" class="calibre2"><div class="preface" id="calibre_link-2618">
<h2 class="calibre42">Signing an App</h2>

<p class="author1">Running an app on a device is a remarkably complicated business. You will need to <em class="calibre11">sign</em> the app as you build it. An app that is not properly signed for a device will not run on that device (assuming you havenâ€™t jailbroken the device). Signing an app requires two things:<a data-type="indexterm" data-primary="signing an app" id="calibre_link-2028" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">An identity</dt>
<dd class="calibre16">
<p class="calibre17">An identity represents Appleâ€™s permission for a given team to develop, <em class="calibre11">on this computer</em>, apps that can run on a device. It consists of two parts:<a data-type="indexterm" data-primary="identity, developer" id="calibre_link-1037" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">A private key</dt>
<dd class="calibre16">
<p class="calibre17">The private key is stored in the keychain on the computer. Thus, it identifies a computer where this team can <em class="calibre11">potentially</em> develop device-targeted apps.</p>
</dd>
<dt class="calibre15">A certificate<a data-type="indexterm" data-primary="certificate" id="calibre_link-349" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></dt>
<dd class="calibre16">
<p class="calibre17">A certificate is a virtual permission slip from Apple. It contains the public key matching the private key (because you told Apple the public key when you asked for the certificate). With a copy of this certificate, any machine holding the private key can <em class="calibre11">actually</em> be used to develop device-targeted apps under the name of this team.</p>
</dd>
</dl>
</dd>
<dt class="calibre15">A provisioning profile<a data-type="indexterm" data-primary="provisioning profile" id="calibre_link-1816" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></dt>
<dd class="calibre16">
<p class="calibre17">A provisioning profile is a virtual permission slip from Apple, uniting four things:</p>
<div class="preface">
<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">An <em class="calibre11">identity</em>.</p>
</li>
<li class="calibre12">
<p class="calibre17">An <em class="calibre11">app</em>, identified by its bundle identifier.</p>
</li>
<li class="calibre12">
<p class="calibre17">A list of eligible <em class="calibre11">devices</em>, identified by their unique device identifiers <span class="publishername">(UDIDs).</span><a data-type="indexterm" data-primary="UDID" id="calibre_link-2249" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre12">
<p class="calibre17">A list of <em class="calibre11">entitlements</em>. An entitlement is a special privilege that not every app needs, such as the ability to talk to iCloud. You wonâ€™t concern yourself with entitlements<a data-type="indexterm" data-primary="entitlements" id="calibre_link-738" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> unless you write an app that needs one.</p>
</li>
</ul>
</div>


<p class="calibre17">A provisioning profile is therefore sufficient for signing an app as you build it. It says that on <em class="calibre11">this</em> computer it is permitted to build <em class="calibre11">this</em> app such that it will run on <em class="calibre11">these</em> devices.</p>
</dd>
</dl>

<p class="author1">There are two types of identity, and hence two types of certificate and provisioning profile: <em class="calibre11">development</em> and <em class="calibre11">distribution</em> (a distribution certificate is also called a <em class="calibre11">production</em> certificate). We are concerned here with the development identity, certificate, and profile; Iâ€™ll talk about the distribution side later.<a data-type="indexterm" data-primary="profile" data-see="provisioning profile" id="calibre_link-2997" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The only thing that belongs entirely to you is the private key in your computerâ€™s keychain. Apple is the ultimate keeper of all other information: your certificates, your provisioning profiles, what apps and what devices youâ€™ve registered. Your communication with Apple, when you need to verify or obtain a copy of this information, will take place through one of two means:</p>
<dl class="calibre14">
<dt class="calibre15">The developer member center<a data-type="indexterm" data-primary="developer member center" id="calibre_link-654" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></dt>
<dd class="calibre16">
<p class="calibre17">A set of web pages at <a href="https://developer.apple.com/account" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/account</em></a>. Having logged in with your Apple ID, you can click Certificates, Identifiers &amp; Profiles (or go directly to <a href="https://developer.apple.com/account/resources" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/account/resources</em></a>) to access all features and information to which you are entitled by your membership type and role. (This is the area of Appleâ€™s site formerly referred to as the Portal<a data-type="indexterm" data-primary="Portal" id="calibre_link-1713" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>.)<a data-type="indexterm" data-primary="member center" id="calibre_link-1275" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Xcode</dt>
<dd class="calibre16">
<p class="calibre17">Just about everything you would need to do at the developer member center can be done through Xcode instead. When all goes well, using Xcode is a lot simpler! If thereâ€™s a problem, you can head for the developer member center to iron it out.</p>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">New in Xcode 11, certificates are unified across all platforms. One development cerficate applies to iOS development and to Mac development. These unified certificates are in a new format and are good <em class="calibre11">only</em> with Xcode 11 and later.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Automatic Signing" class="calibre2"><div class="preface" id="calibre_link-2619">
<h2 class="calibre42">Automatic Signing</h2>

<p class="author1">Apple provides two distinct ways of obtaining and managing certificates and profiles in connection with a project &mdash; automatic signing, and manual signing. For new projects, automatic signing is the default. This is indicated by the fact that the â€œAutomatically manage signingâ€ checkbox is checked in the Signing &amp; Capabilities pane when you edit your projectâ€™s app target (<a data-type="xref" href="#calibre_link-28" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-18</a>).<a data-type="indexterm" data-primary="signing an app" data-secondary="automatic" id="calibre_link-2029" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="automatic signing" id="calibre_link-234" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The Signing &amp; Capabilities pane is new in Xcode 11. Previously, the signing interface was the Signing section of the General pane.</p>
</div>

<p class="author1">To see just how automatic Xcodeâ€™s signing management can be, letâ€™s start at a stage where as yet you have neither a development certificate in your computerâ€™s keychain nor a development profile for any app. But you do have a Developer Program Apple ID, and youâ€™ve entered it into Xcodeâ€™s Accounts preference pane. Then, when you create a new project (File â†’ New â†’ Project), youâ€™ll see on the second screen (â€œChoose options for your new projectâ€) a pop-up menu listing all the teams with which your Apple ID is associated. Specify the desired team here.</p>

<p class="author1">When you then create the project on disk and the project window opens, <em class="calibre11">everything happens automatically</em>. Your computerâ€™s keychain creates a private key for a development certificate. The public key is sent to Apple. The actual development certificate is created at the developer member center, and is downloaded and installed into your computerâ€™s keychain. With no conscious effort, youâ€™ve obtained a development <span class="publishername">identity!</span></p>

<p class="author1">If youâ€™ve never run on any device before, and if you havenâ€™t manually registered any devices at the developer member center, that might be as far as Xcode can go for now. If so, youâ€™ll see some errors in the Signing &amp; Capabilities pane, similar to <a data-type="xref" href="#calibre_link-29" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-15</a>.<a data-type="indexterm" data-primary="registering a device" id="calibre_link-1880" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="device" data-secondary="registering" id="calibre_link-657" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-29" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-15. </span>Xcode knows of no devices</h6>
</div>
</figure>

<p class="author1">Now connect a device via USB to your computer and select it as the destination, either under Product â†’ Destination or in the Scheme pop-up menu in the project window toolbar. This causes the error in <a data-type="xref" href="#calibre_link-29" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-15</a> to change: a Register Device button now appears (<a data-type="xref" href="#calibre_link-30" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-16</a>). Click it!</p>

<figure class="calibre32"><div id="calibre_link-30" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-16. </span>Xcode offers to register a device</h6>
</div>
</figure>

<p class="author1">The problem is resolved; the error vanishes. You can switch to the Report navigator to learn what just happened (<a data-type="xref" href="#calibre_link-31" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-17</a>).</p>

<figure class="calibre32"><div id="calibre_link-31" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-17. </span>Xcode has registered a device for us</h6>
</div>
</figure>

<p class="author1">As the Report navigator tells us, the device has been registered &mdash; and a development provisioning profile has been created and downloaded (and has been stored in your <em class="calibre11">~/Library/MobileDevice/Provisioning Profiles</em> folder). This is a universal iOS Team Provisioning Profile &mdash; and that is all you need in order to run any basic app on any device! <a data-type="xref" href="#calibre_link-28" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-18</a> shows the resulting display in the Signing &amp; Capabilities pane.</p>

<figure class="calibre32"><div id="calibre_link-28" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-18. </span>Xcode manages signing credentials automatically</h6>
</div>
</figure>

<p class="author1">You are now almost ready to run this project on this device. There may, however, be one further step: you might have to disconnect the device from USB and connect it again. This is so that Xcode can recognize the device afresh and prepare for debugging on it. This process is rather time-consuming; a progress indication is shown at the top of the project window, and in the Devices and Simulators window.</p>

<p class="author1">The good news is that once you <em class="calibre11">already</em> have a development certificate, and once Xcode has <em class="calibre11">already</em> generated and downloaded a universal iOS Team Provisioning Profile, and once your device is <em class="calibre11">already</em> registered with Apple and prepared by Xcode for debugging, <em class="calibre11">none</em> of that will be necessary ever again. When you create a new project, you supply your team name. Xcode thus knows everything it needs to know! The development certificate is valid for this computer, the universal iOS Team Provisioning Profile is universal, and the device is registered with Apple and prepared for debugging. Therefore, you should from now on be able to create a project and run it on this device <em class="calibre11">immediately</em>.</p>

<p class="author1">You can confirm your possession of a universal development provisioning profile by clicking the â€œiâ€ button at the right of the Provisioning Profile (<a data-type="xref" href="#calibre_link-28" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-18</a>): a popover displays information about the provisioning profile, as shown in <a data-type="xref" href="#calibre_link-32" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-19</a>.<a data-type="indexterm" data-primary="universal provisioning profile" id="calibre_link-2281" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="provisioning profile" data-secondary="universal" id="calibre_link-1819" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="provisioning profile" data-secondary="development" id="calibre_link-1817" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="development provisioning profile" id="calibre_link-656" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-32" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-19. </span>A universal development profile</h6>
</div>
</figure>

<p class="author1">The asterisk (<code class="calibre19">*</code>) in that popover tells you that this is a universal profile, not restricted to one particular app ID. The universal development profile allows you to run <em class="calibre11">any</em> app on the targeted device for testing purposes, provided that the app doesnâ€™t require special entitlements (such as using iCloud). If you turn on any entitlements for an app target (which you would do by making a change in the Capabilities pane when you edit the app target), and if youâ€™re using automatic signing, Xcode will communicate with the developer member center to attach those entitlements to your registered app; then it will create a new provisioning profile that includes those entitlements, download it, and use it for this project.<a data-type="indexterm" data-primary="entitlements" id="calibre_link-739" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Capabilities pane" id="calibre_link-334" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Manual Signing" class="calibre2"><div class="preface" id="calibre_link-2620">
<h2 class="calibre42">Manual Signing</h2>

<p class="author1">If you donâ€™t want a projectâ€™s signing to be managed automatically by Xcode, simply uncheck the â€œAutomatically manage signingâ€ checkbox.
This causes Xcode to take its hands off completely. Xcode wonâ€™t automatically generate or choose a development certificate or a provisioning profile; you will have to do it all yourself.<a data-type="indexterm" data-primary="signing an app" data-secondary="manual" id="calibre_link-2030" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If you need to obtain a development certificate manually, there are two possible approaches:</p>
<dl class="calibre14">
<dt class="calibre15">The Accounts preference pane</dt>
<dd class="calibre16">
<p class="calibre17">In Xcodeâ€™s Accounts preference pane, select your team name and click Manage Certificates to summon the â€œSigning certificatesâ€ dialog. Click the Plus button at the lower left, and choose Apple Development. Xcode will communicate with the developer member center and a development certificate will be created and installed on your computer.</p>
</dd>
<dt class="calibre15">Keychain Access and the developer member center</dt>
<dd class="calibre16">
<p class="calibre17">Go to Certificates at the developer member center, click the Plus button, ask for an Apple Development certificate, click Continue, and follow the instructions that start on the next page:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">You begin by generating the private key in your computerâ€™s keychain. Launch the Keychain Access application and choose Keychain Access â†’ Certificate Assistant â†’ Request a Certificate From a Certificate Authority. Click the â€œSaved to diskâ€ radio button and save the certificate signing request file onto your computer.</p>
</li>
<li class="calibre4">
<p class="calibre17">At the develop member center, under Certificates, Identifiers &amp; Profiles, go to Certificates and click the Plus button to start the process. Ask for an Apple Development certificate. Youâ€™ll be prompted to upload the certificate signing resquest file. The actual certificate is generated; download it, and double-click to install it into the keychain. (You can then throw away both the certificate request file and the downloaded certificate.)</p>
</li>

</ol>
</dd>
</dl>

<p class="author1"><a data-type="xref" href="#calibre_link-33" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-20</a> shows what a valid development certificate looks like in Keychain Access.</p>

<figure class="calibre32"><div id="calibre_link-33" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-20. </span>A valid development certificate</h6>
</div>
</figure>

<p class="author1">Once you have a development certificate, you can use the developer member center to create a development profile manually, if necessary, as follows:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">The <em class="calibre11">device</em> must be registered at the developer member center. Look under Devices to see if it is. If it isnâ€™t, click the Plus button and enter a name for this device along with its UDID. You can copy the deviceâ€™s UDID from its listing in Xcodeâ€™s Devices and Simulators window.
<a data-type="indexterm" data-primary="registering a device" id="calibre_link-1881" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="device" data-secondary="registering" id="calibre_link-658" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">The <em class="calibre11">app</em> must be registered at the developer member center. Look under Identifiers â†’ App IDs to see if it is. If it isnâ€™t, add it, as follows: Click Plus. Choose App IDs. Enter a name for this app. Ignore the App ID Prefix field.
Copy the Bundle Identifier from the Signing &amp; Capabilities pane and paste it into the bundle identifier field, and register the app.<a data-type="indexterm" data-primary="registering an app" id="calibre_link-1882" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="app" data-secondary="registering" id="calibre_link-158" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="calibre17">(If your app uses special entitlements, this step is also where youâ€™d associate those entitlements manually with the app.)</p>
</li>
<li class="calibre4">
<p class="calibre17">Under Profiles, click Plus. Ask for an iOS App Development profile. On the next screen, choose the App ID for this app (presumably the one you just created in the previous step).
On the next screen, check your development certificate. On the next screen, select the device(s) you want to run on. On the next screen, give this profile a name, and generate the profile. You are now offered a chance to download the profile, but you donâ€™t have to do that, because Xcode can do it for you.</p>
</li>
<li class="calibre4">
<p class="calibre17">In Xcode, in the Signing &amp; Capabilities pane, in the Provisioning Profile pop-up menu, choose Download Profile. The profile you created at the developer member center is listed here! Select it. The profile is downloaded and development provisioning is enabled for this project (<a data-type="xref" href="#calibre_link-34" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-21</a>). <a data-type="indexterm" data-primary="code signing" data-see="signing an app" id="calibre_link-2998" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>

</ol>

<figure class="calibre32"><div id="calibre_link-34" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-21. </span>Manual code signing</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Running the App" class="calibre2"><div class="preface" id="calibre_link-2621">
<h2 class="calibre42">Running the App</h2>

<p class="author1">Once you have a development profile applicable to an app and a device, you can connect the device via USB, choose it as the destination in the Scheme pop-up menu, and build and run the app. (If youâ€™re asked for permission to access your keychain, grant it.)</p>

<p class="author1">The app is built, loaded onto your device, and launched. As long as you launch the app from Xcode, everything is just as when running in the Simulator. You can run and you can debug. The running app is in communication with Xcode, so that you can stop at breakpoints, read messages in the console, profile your app with Instruments, and so on. The outward difference is that to interact physically with the app, you use the device, not the Simulator.</p>

<p class="author1">You can also configure your device to allow Xcode to build and run apps on it <em class="calibre11">without</em> a USB connection. To do so, start with the device connected via USB; locate the device in the Devices and Simulators window and check â€œConnect via network.â€ The device can now be used as a build and run destination <em class="calibre11">wirelessly</em>, provided it is connected via Wi-Fi to the local network or to some other network that your computer can access by its IP address. You can build and run from Xcode, pausing at breakpoints and receiving console messages, even though the device is not physically attached to your computer. This would be useful, for example, if the app youâ€™re testing requires the device to be manipulated in ways that are difficult when the device is tethered by a USB cable.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Managing Development Certificates and Devices" class="calibre2"><div class="preface" id="calibre_link-2622">
<h2 class="calibre42">Managing Development Certificates and Devices</h2>

<p class="author1">Youâ€™re allowed to have more than one development certificate, so there should be no problem running your project on a device from another computer. Just do what you did on the first computer! If youâ€™re using automatic signing, a new certificate will be generated for you, and it wonâ€™t conflict with the existing certificate for the first <span class="publishername">computer.</span></p>

<p class="author1">When a device is attached to the computer, it appears in Xcodeâ€™s Devices and Simulators window. If this device has never been prepared for development, you can ask Xcode to prepare it for development. You can then build and run onto the device. If the device isnâ€™t registered at the member center, a dialog appears offering to let you register it; click Register Device, and now the device <em class="calibre11">is</em> registered. Your automatically generated provisioning profile is modified to include this device, and you are now able to build and run on it.</p>

<p class="author1">The Devices and Simulators window can be used to communicate in other ways with a connected device. Using the contextual menu, you can copy the deviceâ€™s UDID, and you can view and manage provisioning profiles on the device. In the main part of the window, you can see (and delete) apps that have been installed for development using Xcode, and you can view and download their sandboxes. You can take screenshots. You can view the deviceâ€™s stored logs. You can open the Console application to view the deviceâ€™s console output in real time. <a data-type="indexterm" data-primary="Devices and Simulators window" id="calibre_link-661" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Profiling" class="calibre2"><div class="preface" id="calibre_link-2623">
<h1 class="calibre18">Profiling</h1>

<p class="author1">Xcode provides tools for probing the internal behavior of your app graphically and numerically, and you should keep an eye on those tools. The gauges<a data-type="indexterm" data-primary="gauges" id="calibre_link-943" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> in the Debug navigator allow you to monitor key indicators, such as CPU and memory usage, any time you run your app. Memory debugging gives you a graphical view of your appâ€™s objects and their ownership chains, and can even reveal memory leaks. And Instruments, a sophisticated and powerful utility application, collects profiling data that can help track down problems and provide the numeric information you need to improve your appâ€™s performance and responsiveness.<a data-type="indexterm" data-primary="Instruments" id="calibre_link-1144" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="profiling" id="calibre_link-1729" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="optimizing" id="calibre_link-1583" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Gauges" class="calibre2"><div class="preface" id="calibre_link-2624">
<h2 class="calibre42">Gauges</h2>

<p class="author1">The gauges in the Debug navigator are operating whenever you build and run your app. Click a gauge to see further detail displayed in the editor. The gauges do not provide highly detailed information, but they are extremely lightweight and always active, so they are an easy way to get a general sense of your running appâ€™s behavior at any time. If thereâ€™s a problem, such as a prolonged period of unexpectedly high CPU usage or a relentless unchecked increase in memory usage, you can spot it in the gauges and then use Instruments to help track it down.<a data-type="indexterm" data-primary="Debug navigator" id="calibre_link-611" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="leaks, memory" id="calibre_link-1216" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory leaks" id="calibre_link-1280" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">There are four basic gauges: CPU, Memory, Disk, and Network. Depending on the circumstances, you may see additional gauges. For example, an Energy Impact gauge appears when running on a device, and for certain devices, a GPU gauge may appear as well.</p>

<p class="author1">In <a data-type="xref" href="#calibre_link-35" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-22</a>, Iâ€™ve been heavily exercising my app for a few moments, repeating the most calculation- and memory-intensive actions I expect the user to perform. These actions do cause some spikes in energy usage, but thatâ€™s to be expected; this is a user-initiated action, and the user wonâ€™t perform it very often. Meanwhile, my appâ€™s memory usage remains level. So I donâ€™t suspect any issues.</p>

<figure class="calibre32"><div id="calibre_link-35" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-22. </span>The Debug gauges</h6>
</div>
</figure>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Note that <a data-type="xref" href="#calibre_link-35" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-22</a> is the result of running <em class="calibre11">on a device.</em> Running in the Simulator might give completely different &mdash; and misleading &mdash; results.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Memory Debugging" class="calibre2"><div class="preface" id="calibre_link-91">
<h2 class="calibre42">Memory Debugging</h2>

<p class="author1">Memory debugging lets you pause your app and view a graphical display of your object hierarchy at that moment. This is valuable not only for detecting problems but also for understanding your appâ€™s object structure.<a data-type="indexterm" data-primary="objects" data-secondary="graphing" id="calibre_link-1550" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To use memory debugging, run the app and click the Debug Memory Graph button in the debug bar (<a data-type="xref" href="#calibre_link-36" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-23</a>). The app pauses, and you are shown a drawing of your appâ€™s objects, linked by their chains of ownership. The Debug navigator lists your objects hierarchically; click an object to see a different part of the graph. Double-click an object in the graph to refocus the graph on that object.<a data-type="indexterm" data-primary="debugging" data-secondary="memory management" id="calibre_link-617" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory graph" id="calibre_link-1278" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="graph" id="calibre_link-1298" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In my app, the root view controller is a ViewController whose viewâ€™s subviews include a MyBoard view whose <code class="calibre19">tilesInOrder</code> property is an array of Tile views. <a data-type="xref" href="#calibre_link-36" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-23</a> displays that situation.</p>

<figure class="calibre32"><div id="calibre_link-36" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-23. </span>A memory graph</h6>
</div>
</figure>

<p class="author1">At the cost of some additional overhead, you can enable the malloc stack before running your app: edit the schemeâ€™s Run action and under Diagnostics check Malloc Stack with the pop-up menu set to All Allocation and Free History. When you run the app, selecting an object in the memory graph provides a backtrace in the Memory inspector that tells you <em class="calibre11">how</em> each object came into being. Hover over a line of the backtrace and click the right-arrow button to jump to that line of your code.</p>

<p class="author1">Memory debugging also detects memory leaks. Such leaks will cause an error icon to appear, and are listed in the Runtime pane of the Issue navigator. For example, suppose we run the example from <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a> where I have a Dog class instance and a Cat class instance with strong references to one another and no other references to either instance, so they are both leaking. The leaking Cat and Dog are listed in the Issue navigator, and clicking one them displays a graph of the problem: the Cat and the Dog are retaining one another (<a data-type="xref" href="#calibre_link-37" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-24</a>).<a data-type="indexterm" data-primary="leaks, memory" id="calibre_link-1217" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory leaks" id="calibre_link-1281" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="leaks" id="calibre_link-1301" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-37" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-24. </span>The memory graph displays a leak</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Instruments" class="calibre2"><div class="preface" id="calibre_link-2625">
<h2 class="calibre42">Instruments</h2>

<p class="author1">To get started with Instruments, first set the desired destination in the Scheme pop-up menu in the project window toolbar. The destination should be a device if possible; Instruments on the Simulator does not reflect the reality youâ€™re trying to measure. Now choose Product â†’ Profile. Your app builds using the Profile action for your scheme; by default, this uses the Release build configuration, which is probably what you want.
Instruments launches; if your schemeâ€™s Instrument pop-up menu for the Profile action is set to Ask on Launch (the default), Instruments presents a dialog where you choose a template.</p>

<p class="author1">Alternatively, click Profile In Instruments in a Debug navigator gauge editor; this is convenient when the gauges have suggested a possible problem, and you want to reproduce that problem under the more detailed monitoring of Instruments. Instruments launches, selecting the appropriate template for you. A dialog offers two options: Restart stops your app and relaunches it with Instruments, whereas Transfer keeps your app running and hooks Instruments into it.</p>

<p class="author1">Once the Instruments main window appears, youâ€™ll probably have to click the Record button, or choose File â†’ Record Trace, to get your app running. Now you should interact with your app like a user; Instruments will record its statistics.</p>

<p class="author1"><a data-type="xref" href="#calibre_link-38" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-25</a> shows me doing much the same thing in Instruments that I did with the Debug navigator gauges in <a data-type="xref" href="#calibre_link-35" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-22</a>. Iâ€™ve set the destination to my device. I choose Product â†’ Profile; when Instruments launches, I choose the Allocations template. With my app running under Instruments, I exercise it for a while and then pause Instruments, which meanwhile has charted my memory usage. Examining the chart, I find that there are spikes up to about 16MB, but the app in general settles down to a much lower level (less than 8MB). Those are very gentle and steady memory usage figures, so Iâ€™m happy.<a data-type="indexterm" data-primary="Allocations instrument" id="calibre_link-130" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-38" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-25. </span>Instruments graphs memory usage over time</h6>
</div>
</figure>

<p class="author1">The Leaks template can help you detect memory leaks (similar to the memory graph leak detection I discussed earlier). In <a data-type="xref" href="#calibre_link-39" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-26</a>, Iâ€™ve again run the retain cycle code from <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, profiling the app using the Leaks template. Instruments has detected the leak, and has diagrammed the issue.<a data-type="indexterm" data-primary="Leaks instrument" id="calibre_link-1214" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-39" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-26. </span>Instruments describes a retain cycle</h6>
</div>
</figure>

<p class="author1">In the next example, Iâ€™m curious as to whether I can shorten the time it takes my app to load a photo image. Iâ€™ve set the destination to a device, because thatâ€™s where speed matters and needs to be measured. I choose Product â†’ Profile. Instruments launches, and I choose the Time Profiler template. When the app launches under Instruments on the device, I load new images repeatedly to exercise this part of my code.<a data-type="indexterm" data-primary="Time Profiler instrument" id="calibre_link-2215" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In <a data-type="xref" href="#calibre_link-40" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-27</a>, Iâ€™ve paused Instruments, and am looking at what itâ€™s telling me. Opening the triangles in the lower portion of the window, I can drill down to my own code, indicated by the user icon.</p>

<figure class="calibre32"><div id="calibre_link-40" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-27. </span>Drilling down into the time profile</h6>
</div>
</figure>

<p class="author1">By double-clicking the listing of that line, I can see my own code, time-profiled (<a data-type="xref" href="#calibre_link-41" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-28</a>). The profiler is drawing my attention to the call to <code class="calibre19">CGImageSourceCreateThumbnailAtIndex</code>; this is where weâ€™re spending most of our CPU time. That call is in the ImageIO framework; it isnâ€™t my code, so I canâ€™t make it run any faster. It may be, however, that I could load the image another way; for example, at the expense of some temporary memory usage, perhaps I could load the image at full size and scale it down by redrawing it myself. If Iâ€™m concerned about speed here, I could spend a little time experimenting. The point is that now I know <em class="calibre11">what</em> the experiment should be. This is just the sort of focused, fact-based numerical analysis at which Instruments excels.</p>

<figure class="calibre32"><div id="calibre_link-41" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-28. </span>My code, time-profiled</h6>
</div>
</figure>

<p class="author1">You can inject custom messages into your Instruments graphs in the form of <em class="calibre11">signposts</em>. For instance, based on the first Instruments example, I may suspect that my highest memory spikes are taking place within my <code class="calibre19">newGame</code> method. To confirm this, Iâ€™ll add some signposts.<a data-type="indexterm" data-primary="signposts" id="calibre_link-2031" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> I import <code class="calibre19">os</code> and configure an OSLog object called <code class="calibre19">mylog</code> with a <code class="calibre19">.pointsOfInterest</code> category:</p>

<pre data-type="programlisting" class="calibre28">let mylog = OSLog(subsystem: "diabelli", category: .pointsOfInterest)</pre>

<p class="author1">Then I instrument the start and end of my <code class="calibre19">newGame</code> method with <code class="calibre19">os_signpost</code> calls:</p>

<pre data-type="programlisting" class="calibre28">private func newGame(imageSource: Any, song: String) {
    os_signpost(.begin, log: mylog, name: "newgame")
    defer {
        os_signpost(.end, log: mylog, name: "newgame")
    }</pre>

<p class="author1">To prepare my Instruments template, I start with a Blank template, choose View â†’ Show Library to bring up the instrument chooser, and add both the Allocations instrument and the Points of Interest instrument to my template. When I run the app, Instruments displays the <code class="calibre19">"newgame"</code> signposts &mdash; and sure enough, they surround the memory spikes (<a data-type="xref" href="#calibre_link-42" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-29</a>).</p>

<figure class="calibre32"><div id="calibre_link-42" class="figure">
<img src="images/000017.png" alt="suppressed" class="calibre47" />
<h6 class="calibre34"><span class="publishername">Figure 9-29. </span>Signposts in Instruments</h6>
</div>
</figure>

<p class="author1">Those examples barely scratch the surface. Use of Instruments is an advanced topic; an entire book could
be written about Instruments alone.
The Instruments application comes with online help thatâ€™s definitely worth studying.
Many WWDC videos from current and prior years are about Instruments; look particularly for sessions with â€œInstrumentsâ€ or â€œPerformanceâ€ in their names.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Localization" class="calibre2"><div class="preface" id="calibre_link-2626">
<h1 class="calibre18">Localization</h1>

<p class="author1">A device &mdash; or, new in iOS 13, an individual app &mdash; can be set by the user to prefer a certain language as its primary language. You might like your appâ€™s interface to respond to this situation by appearing in that language. This is achieved by <em class="calibre11">localizing</em> the app for that language. You will probably want to implement localization relatively late in the development of the app, after the app has achieved its final form, in preparation for distribution.<a data-type="indexterm" data-primary="localization" id="calibre_link-1246" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Localization operates through <em class="calibre11">localization folders</em> with an <em class="calibre11">.lproj</em> extension in your project folder and in the built app bundle (<a data-type="xref" href="#calibre_link-43" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;6-6</a>). When your app obtains a resource, if it is running on a system whose language corresponds to a localization folder, if that localization folder contains a version of that resource, thatâ€™s the version that is loaded.<a data-type="indexterm" data-primary="internationalization" data-see="localization" id="calibre_link-2999" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Any type of resource can live in these localization folders;
you will be particularly concerned with <em class="calibre11">text</em> that is to appear in your interface. Such text must be maintained in specially formatted <em class="calibre11">.strings</em> files, with special names. For example:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">To localize your <em class="calibre11">Info.plist</em> file, use <em class="calibre11">InfoPlist.strings</em>.</p>
</li>
<li class="calibre12">
<p class="calibre17">To localize your <em class="calibre11">Main.storyboard</em>, use <em class="calibre11">Main.strings</em>.</p>
</li>
<li class="calibre12">
<p class="calibre17">To localize your code strings, use <em class="calibre11">Localizable.strings</em>.</p>
</li>
</ul>

<p class="author1">Fortunately, you donâ€™t have to create or maintain these files manually! Instead, you work with exported XML files in the standard <em class="calibre11">.xliff</em> format. Xcode will generate <em class="calibre11">.xliff</em> files automatically, based on the structure and content of your project; it will also read them and will turn them automatically into the various localized <em class="calibre11">.strings</em> files.<a data-type="indexterm" data-primary="xliff files" id="calibre_link-2379" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Creating Localized Content" class="calibre2"><div class="preface" id="calibre_link-2627">
<h2 class="calibre42">Creating Localized Content</h2>

<p class="author1">To experiment with localization, our app needs some localizable content:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Edit the target and enter a value in the Display Name text field in the General pane. Our Empty Window app already says â€œEmpty Windowâ€ here, but itâ€™s in gray, indicating that this is merely an <em class="calibre11">automatic</em> display name; enter â€œEmpty Windowâ€ explicitly (and press Tab), to make this an <em class="calibre11">actual</em> display name. You have now created a â€œBundle display nameâ€ key (<code class="calibre19">CFBundleDisplayName</code>) in the <em class="calibre11">Info.plist</em> file. That key will be localized.<a data-type="indexterm" data-primary="app" data-secondary="name" data-tertiary="localizing" id="calibre_link-157" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="name of app" data-secondary="localizing" id="calibre_link-1374" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bundle" data-secondary="display name" id="calibre_link-307" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="display name" id="calibre_link-684" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">Edit <em class="calibre11">Main.storyboard</em> and confirm that it contains a button whose title is â€œHello.â€ That title will be localized. (It will help the example if you also widen the button to about 100 points.)<a data-type="indexterm" data-primary="nib files" data-secondary="localizing" id="calibre_link-1398" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre4">
<p class="calibre17">Edit <em class="calibre11">ViewController.swift</em>. The code here contains some string literals, such as <code class="calibre19">"Howdy!"</code>:<a data-type="indexterm" data-primary="code" data-secondary="strings, localizing" id="calibre_link-444" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre38">@IBAction func buttonPressed(_ sender: Any) {
    let alert = UIAlertController(
        title: "Howdy!", message: "You tapped me!",
        preferredStyle: .alert)
    alert.addAction(
        UIAlertAction(title: "OK", style: .cancel))
    self.present(alert, animated: true)
}</pre>

<p class="calibre17">That code <em class="calibre11">wonâ€™t</em> be localized, unless we modify it. Your code needs to call the global <code class="calibre19">NSLocalizedString</code> function; youâ€™ll usually supply these parameters:</p>
<div class="preface"><dl class="calibre14">
<dt class="calibre15"><code class="calibre19">key</code> (first parameter, no label)</dt>
<dd class="calibre16">
<p class="calibre17">The first parameter is the key into a <em class="calibre11">.strings</em> file.</p>
</dd>
<dt class="calibre15"><code class="calibre19">value</code></dt>
<dd class="calibre16">
<p class="calibre17">The default string if thereâ€™s no <em class="calibre11">.strings</em> file for the current language.</p>
</dd>
<dt class="calibre15"><code class="calibre19">comment</code></dt>
<dd class="calibre16">
<p class="calibre17">An explanatory comment.</p>
</dd>
</dl>
</div>


<p class="calibre17">So modify our <code class="calibre19">buttonPressed</code> method to look like this:</p>

<pre data-type="programlisting" class="calibre38">@IBAction func buttonPressed(_ sender: Any) {
    let alert = UIAlertController(
        title: NSLocalizedString(
            "Greeting", value:"Howdy!", comment:"Say hello"),
        message: NSLocalizedString(
            "Tapped", value:"You tapped me!", comment:"User tapped button"),
        preferredStyle: .alert)
    alert.addAction(UIAlertAction(
        title: NSLocalizedString(
            "Accept", value:"OK", comment:"Dismiss"),
        style: .cancel))
    self.present(alert, animated: true)
}</pre>
</li>

</ol>










<section data-type="sect3" data-pdf-bookmark="Exporting" class="calibre2"><div class="preface" id="calibre_link-3000">
<h3 class="calibre44">Exporting</h3>

<p class="author1">Now weâ€™re going to give our project an actual localization, and weâ€™ll export an editable <em class="calibre11">.xliff</em> file expressing the details of that localization. For my localization language, Iâ€™ll choose French:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Edit the project. Under Localizations, click the Plus button. In the pop-up menu that appears, choose French. In the dialog, click Finish.</p>
</li>
<li class="calibre4">
<p class="calibre17">Still editing the project, choose Editor â†’ Export For Localization. In the dialog that appears, check French. Youâ€™re about to create a folder, so call it something like Empty Window Localization and save it to the desktop.</p>
</li>

</ol>

<p class="author1">The result is an <em class="calibre11">.xcloc</em> bundle called <em class="calibre11">fr.xcloc</em> (for French). Itâ€™s an ordinary folder containing subfolders, along with a <em class="calibre11">contents.json</em> file describing the output (<a data-type="xref" href="#calibre_link-44" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-30</a>).<a data-type="indexterm" data-primary="xcloc bundle" id="calibre_link-2374" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-44" class="figure">
<img src="images/000011.png" alt="ios12 0917cccc" class="calibre73" />
<h6 class="calibre34"><span class="publishername">Figure 9-30. </span>An exported xcloc bundle</h6>
</div>
</figure>

<p class="author1">The heart of this output is an XML file called <em class="calibre11">fr.xliff</em> (inside the <em class="calibre11">Localized Contents</em> subfolder). Examining this file, youâ€™ll observe that our appâ€™s localizable strings have all been discovered:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">For our <em class="calibre11">Info.plist</em> file in the project, Xcode has created a corresponding <code class="calibre19">&lt;file&gt;</code> element. When imported, this element will be turned into a localized <em class="calibre11">InfoPlist.strings</em> file.</p>
</li>
<li class="calibre12">
<p class="calibre17">For every localized <em class="calibre11">.storyboard</em> and <em class="calibre11">.xib</em> file, Xcode has run <code class="calibre19">ibtool</code> to extract the text, and has created a corresponding <code class="calibre19">&lt;file&gt;</code> element. When imported, these elements will be turned into eponymous localized <em class="calibre11">.strings</em> files.</p>
</li>
<li class="calibre12">
<p class="calibre17">For our code files containing a call to <code class="calibre19">NSLocalizedString</code>, Xcode has run <code class="calibre19">genstrings</code> to parse the file, and has created a corresponding <code class="calibre19">&lt;file&gt;</code> element. When imported, this element will be turned into a localized <em class="calibre11">Localizable.strings</em> file.</p>
</li>
</ul>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Editing" class="calibre2"><div class="preface" id="calibre_link-3001">
<h3 class="calibre44">Editing</h3>

<p class="author1">Now letâ€™s pretend that you are the French translator, tasked with creating the French localization of this app. Your job is to <em class="calibre11">modify</em> the <em class="calibre11">fr.xliff</em> file by providing a <code class="calibre19">&lt;target&gt;</code> tag for every <code class="calibre19">&lt;source&gt;</code> tag that is to be translated into French. Your edited file might contain, at the appropriate places, translations like this (note that the <code class="calibre19">id</code> and <code class="calibre19">ObjectID</code> attributes will be different in your actual <em class="calibre11">fr.xliff</em> file):</p>

<pre data-type="programlisting" class="calibre28">&lt;trans-unit id="RoQ-mP-swT.normalTitle"&gt;
  &lt;source&gt;Hello&lt;/source&gt;
  &lt;target&gt;Bonjour&lt;/target&gt;
  &lt;note&gt;Class="UIButton"; normalTitle="Hello"; ObjectID="RoQ-mP-swT";&lt;/note&gt;
&lt;/trans-unit&gt;

&lt;trans-unit id="CFBundleDisplayName"&gt;
  &lt;source&gt;Empty Window&lt;/source&gt;
  &lt;target&gt;FenÃªtre Vide&lt;/target&gt;
&lt;/trans-unit&gt;
&lt;trans-unit id="CFBundleName"&gt;
  &lt;source&gt;$(PRODUCT_NAME)&lt;/source&gt;
  &lt;target&gt;$(PRODUCT_NAME)&lt;/target&gt;
&lt;/trans-unit&gt;

&lt;trans-unit id="Accept"&gt;
  &lt;source&gt;OK&lt;/source&gt;
  &lt;target&gt;OK&lt;/target&gt;
  &lt;note&gt;Dismiss&lt;/note&gt;
&lt;/trans-unit&gt;
&lt;trans-unit id="Greeting"&gt;
  &lt;source&gt;Howdy!&lt;/source&gt;
  &lt;target&gt;Bonjour!&lt;/target&gt;
  &lt;note&gt;Say hello&lt;/note&gt;
&lt;/trans-unit&gt;
&lt;trans-unit id="Tapped"&gt;
  &lt;source&gt;You tapped me!&lt;/source&gt;
  &lt;target&gt;Vous m'avez tapÃ©!&lt;/target&gt;
  &lt;note&gt;User tapped button&lt;/note&gt;
&lt;/trans-unit&gt;</pre>

<p class="author1">Other types of localizable resources may have been exported automatically as well. New in Xcode 11, images in the asset catalog are localizable, and these are exported too (in <em class="calibre11">Localized Contents</em>). If an asset catalog was exported for localization, the translator can edit or replace the localized version of an image directly.</p>

<p class="author1">In addition, the <em class="calibre11">original</em> versions of our localizable material were exported (in <em class="calibre11">Source Contents</em>); and, new in Xcode 11, your export can include screenshots taken during interface testing (described earlier in this chapter). These can give the translator valuable context as to the usage of the terms to be translated.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Importing" class="calibre2"><div class="preface" id="calibre_link-3002">
<h3 class="calibre44">Importing</h3>

<p class="author1">The French translator, having edited the <em class="calibre11">fr.xliff</em> file and any exported localizable asset catalog images, returns the <em class="calibre11">fr.xcloc</em> folder to us. We proceed to incorporate it back into our project:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Edit the project.</p>
</li>
<li class="calibre4">
<p class="calibre17">Choose Editor â†’ Import Localizations; in the dialog, locate and open the
<em class="calibre11">fr.xcloc</em> folder.</p>
</li>

</ol>

<p class="author1">Xcode parses the <em class="calibre11">.xcloc</em> folder, locates the <em class="calibre11">fr.xliff</em> file inside it, opens and reads it, and creates the corresponding files in the project. In particular, there is now a <em class="calibre11">fr.lproj</em> folder containing <em class="calibre11">.strings</em> files in the correct format, namely key&ndash;value pairs like this:</p>

<pre data-type="programlisting" class="calibre28">/* Optional comments are C-style comments */
"key" = "value";</pre>

<p class="author1">The <em class="calibre11">.strings</em> files in our <em class="calibre11">fr.lproj</em> include the following:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">An <em class="calibre11">InfoPlist.strings</em> file, localized for French, corresponding to our <em class="calibre11">Info.plist</em> file. It reads like this:</p>

<pre data-type="programlisting" class="calibre38">/* (No Comment) */
"CFBundleDisplayName" = "FenÃªtre Vide";

/* (No Comment) */
"CFBundleName" = "$(PRODUCT_NAME)";</pre>
</li>
<li class="calibre12">
<p class="calibre17">A <em class="calibre11">Main.strings</em> file, localized for French, corresponding to <em class="calibre11">Main.storyboard</em>. It will be similar to this:</p>

<pre data-type="programlisting" class="calibre38">/* Class="UIButton"; normalTitle="Hello"; ObjectID="RoQ-mP-swT"; */
"RoQ-mP-swT.normalTitle" = "Bonjour";</pre>
</li>
<li class="calibre12">
<p class="calibre17">A <em class="calibre11">Localizable.strings</em> file, localized for French, localizing the strings in our code. It looks like this:</p>

<pre data-type="programlisting" class="calibre38">/* Dismiss */
"Accept" = "OK";

/* Say hello */
"Greeting" = "Bonjour!";

/* User tapped button */
"Tapped" = "Vous m'avez tapÃ©!";</pre>
</li>
</ul>

<p class="author1">If the translator has edited any exported asset catalog images, they will be incorporated into the appropriate slots in our asset catalog.</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Testing Localization" class="calibre2"><div class="preface" id="calibre_link-2628">
<h2 class="calibre42">Testing Localization</h2>

<p class="author1">Build and run the project in the Simulator. The project runs in English, so the button title is still â€œHello,â€ and the alert that it summons when you tap it still contains â€œHowdy!â€, â€œYou tapped me!â€, and â€œOK.â€ Stop the project in Xcode.</p>

<p class="author1">Now weâ€™re going to transport ourselves magically to France! In the Simulator, use the Settings app to change the system language to French (under General â†’ Language and Region). Presto! Back in the Springboard, our appâ€™s title has changed to <em class="calibre11">FenÃªtre Vide</em>. When we run the app, the button in the interface has the title Bonjour. When we tap it, the alert contains â€œBonjour!â€, â€œVous mâ€™avez tapÃ©!â€, and â€œOK.â€</p>

<p class="author1">(Instead of changing the Simulator settings, we could edit the scheme. In the schemeâ€™s Run action, under the Options pane, change the Application Language. Then build and run again.)</p>

<p class="author1">In real life, preparing your nib files to deal with localization will take some additional work. In particular, youâ€™ll want to use autolayout, configuring your interface so that interface objects containing text have room to grow and shrink to compensate for the change in the length of their text in different languages.</p>

<p class="author1">To view your interface under different localizations, you can preview your localized nib files within Xcode, without running the app. Edit a <em class="calibre11">.storyboard</em> or <em class="calibre11">.xib</em> file and choose Editor â†’ Editor and Preview (or choose Editor and Preview from the pop-up Editor Options menu at the top right of the editor pane). In the preview pane, a pop-up menu at the lower right lists localizations; choose from the menu to switch between them. A â€œdouble-length pseudolanguageâ€ stress-tests your interface with really long localized replacement text.</p>

<p class="author1">New in Xcode 11, test plans (discussed earlier in this chapter) let you create multiple configurations, each of which can have a different system language and region; and when you run a test, it runs under all of the current test planâ€™s configurations in succession. Thus, testing provides an automated way to check that your app behaves correctly under all localizations.
<a data-type="indexterm" data-startref="idxlocalization" id="calibre_link-1247" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Distribution" class="calibre2"><div class="preface" id="calibre_link-2629">
<h1 class="calibre18">Distribution</h1>

<p class="author1"><em class="calibre11">Distribution</em> means sharing your built app with users (other than members of your team) for running on their devices. There are two primary kinds of distribution:<a data-type="indexterm" data-primary="distributing your app" id="calibre_link-685" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Ad Hoc distribution<a data-type="indexterm" data-primary="Ad Hoc distribution" id="calibre_link-123" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></dt>
<dd class="calibre16">
<p class="calibre17">You are providing a copy of your app to a limited set of known users so that they can try it on specific devices and report bugs, make suggestions, and so forth.</p>
</dd>
<dt class="calibre15">App Store distribution</dt>
<dd class="calibre16">
<p class="calibre17">You are providing the app to the App Store. This could be for one of two reasons:</p>
<dl class="calibre14">
<dt class="calibre15">TestFlight testing</dt>
<dd class="calibre16">
<p class="calibre17">Distribution to the App Store is the basis of another way of having users test your app, namely through TestFlight.</p>
</dd>
<dt class="calibre15">Sale</dt>
<dd class="calibre16">
<p class="calibre17">You are providing the app to the App Store to be listed publicly, so that anyone can download it and run it, possibly for a fee.<a data-type="indexterm" data-primary="App Store" data-secondary="distribution" id="calibre_link-163" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Making an Archive" class="calibre2"><div class="preface" id="calibre_link-2630">
<h2 class="calibre42">Making an Archive</h2>

<p class="author1">To create a copy of your app for distribution, you need first to build an <em class="calibre11">archive</em> of your app. An archive is basically a preserved build. It has three main purposes:<a data-type="indexterm" data-primary="archive" data-secondary="app" id="calibre_link-170" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="exporting from an archive" id="calibre_link-824" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Distribution</dt>
<dd class="calibre16">
<p class="calibre17">An archive will serve as the basis for subsequent distribution of the app; the distributed app will be <em class="calibre11">exported</em> from the archive.</p>
</dd>
<dt class="calibre15">Reproduction</dt>
<dd class="calibre16">
<p class="calibre17">Every time you build, conditions can vary, so the resulting app might behave slightly differently. But every distribution from a particular archive contains an identical binary, and thus will behave the same way. If a bug report arrives based on an app distributed from a particular archive, you can distribute that archive to yourself and run it, knowing that you are testing exactly the same app.</p>
</dd>
<dt class="calibre15">Symbolication</dt>
<dd class="calibre16">
<p class="calibre17">The archive includes a <em class="calibre11">.dSYM</em> file that allows Xcode to accept a crash log and report the crashâ€™s location in your code. This helps you to deal with crash reports from users.</p>
</dd>
</dl>

<p class="author1">Hereâ€™s how to build an archive of your app:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Set the destination in the Scheme pop-up menu in the project window toolbar to Generic iOS Device. Until you do this, the Product â†’ Archive menu item will be disabled. You do <em class="calibre11">not</em> have to have a device connected; you are not building to run on a <em class="calibre11">particular</em> device, but saving an archive that will run on <em class="calibre11">some</em> device.</p>
</li>
<li class="calibre4">
<p class="calibre17">If you like, edit the scheme to confirm that the Release build configuration will be used for the Archive action. This is the default, but it does no harm to double-check.</p>
</li>
<li class="calibre4">
<p class="calibre17">Choose Product â†’ Archive. The app is compiled and built. The archive itself is stored in a date folder within your user <em class="calibre11">~/Library/Developer/Xcode/Archives</em> folder. Also, it is listed in Xcodeâ€™s Organizer window (Window â†’ Organizer) under <span class="publishername">Archives</span>; this window may open spontaneously to show the archive youâ€™ve just created. You can add a comment here; you can also change the archiveâ€™s name (this wonâ€™t affect the name of the app).<a data-type="indexterm" data-primary="Organizer window" id="calibre_link-1634" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>

</ol>

<p class="author1">Youâ€™ve just signed your archive with a development profile; thatâ€™s good, because it means you can run the archived build directly on your device. However, a development profile canâ€™t be used to make an Ad Hoc or App Store build of your app; therefore, when you export the archive to form an Ad Hoc or App Store build, Xcode will embed the appropriate <em class="calibre11">distribution</em> profile instead.
So now, in order to export from your archive, you need a distribution certificate and a distribution <span class="publishername">profile.</span></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="The Distribution Certificate" class="calibre2"><div class="preface" id="calibre_link-2631">
<h2 class="calibre42">The Distribution Certificate</h2>

<p class="author1">There are three ways to obtain a distribution certificate, parallel to the three ways of obtaining a development certificate described earlier in this chapter:</p>
<dl class="calibre14">
<dt class="calibre15">Automatic signing</dt>
<dd class="calibre16">
<p class="calibre17">If youâ€™re using automatic signing, and if you have no distribution certificate, then when you first export the archive to the App Store (as Iâ€™ll describe later in this chapter), Xcode will offer to create and download a distribution certificate for you, automatically, along with a distribution profile.</p>
</dd>
<dt class="calibre15">The Accounts preference pane</dt>
<dd class="calibre16">
<p class="calibre17">You can request a distribution certificate through Xcodeâ€™s Accounts preference pane: select your Apple ID, choose your team, click Manage Certificates to show the â€œSigning certificatesâ€ dialog, click the Plus button at the bottom left, and ask for an Apple Distribution certificate.</p>
</dd>
<dt class="calibre15">Keychain Access and the developer member center</dt>
<dd class="calibre16">
<p class="calibre17">You can obtain a distribution certificate manually using the Keychain Access application and the developer member center, exactly as I described earlier for obtaining a development certificate manually.<a data-type="indexterm" data-primary="Accounts preferences" id="calibre_link-112" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">Once youâ€™ve obtained a distribution certificate, youâ€™ll see it in your keychain. It will look just like <a data-type="xref" href="#calibre_link-33" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-20</a>, except that it will say â€œDistributionâ€ instead of â€œDevelopment.â€</p>

<p class="author1">There is an important difference between distribution certificates and development certificates: your team cannot have multiple distribution identities. Therefore, with distribution certificates, <em class="calibre11">there can be only one.</em></p>

<p class="author1">As a result, distribution from a computer thatâ€™s different from the one where you originally obtained the distribution certificate can be tricky. Your distribution certificate is back in the keychain of your old computer. On your new computer, Xcode reports the <em class="calibre11">existence</em> of the distribution certificate (in the Accounts preference pane, under Manage Certificates), but tells you that it <em class="calibre11">isnâ€™t</em> in the keychain of <em class="calibre11">this</em> computer.</p>

<p class="author1">What to do? One possibility is to click the Plus button at the bottom left and ask for a new distribution certificate, just as I described a moment ago. However, that might not be a good idea, because this will not be the <em class="calibre11">same</em> distribution certificate as the one on the old computer, and remember: <em class="calibre11">there can be only one.</em> Therefore, creating a new distribution certificate <em class="calibre11">invalidates</em> (revokes) the old distribution certificate sitting on the old computer &mdash; and therefore it also invalidates any distribution profiles you already have. The <em class="calibre11">new</em> distribution certificate wonâ€™t work with your <em class="calibre11">existing</em> distribution profiles, because they are tied to the <em class="calibre11">old</em> (invalid) distribution certificate.</p>

<p class="author1">A better alternative would be to install a <em class="calibre11">copy</em> of the <em class="calibre11">existing</em> distribution certificate; but thatâ€™s not trivial either. You canâ€™t simply go to the developer member center and download a copy of the existing distribution certificate, because the existing distribution certificate is matched to a private key, and wonâ€™t work without it &mdash; and that private key is still sitting in the keychain of the old computer.</p>

<p class="author1">The solution is to return to the old computer where the distribution certificate is in the keychain, and, in the Accounts preference pane, under Manage Certificates, Control-click that certificate and choose Export Certificate from the contextual menu. Youâ€™ll be asked to save the resulting file, securing it with a password. The password is needed because this file, a <em class="calibre11">.p12</em> file, contains the private key from your keychain. Now copy the <em class="calibre11">.p12</em> file to the new computer. (You could email it to yourself, for example.) On that computer, open the exported file, using the same password. The private key and the certificate are imported into the keychain of the new computer. You can then throw away all copies of the <em class="calibre11">.p12</em> file; it has done its job.<a data-type="indexterm" data-primary="certificate" data-secondary="exporting" id="calibre_link-350" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="exporting certificates" id="calibre_link-823" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="The Distribution Profile" class="calibre2"><div class="preface" id="calibre_link-2632">
<h2 class="calibre42">The Distribution Profile</h2>

<p class="author1">Obtaining a distribution profile is like obtaining a development profile. If youâ€™re using automatic signing for this project, Xcode will probably be able to create an appropriate distribution profile for you automatically when you export your archive.</p>

<p class="author1">You can also obtain a distribution profile manually, at the developer member center, under Certificates, Identifiers &amp; Profiles. The procedure is similar to obtaining a development profile manually, with a few slight differences:<a data-type="indexterm" data-primary="distribution provisioning profile" id="calibre_link-686" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="provisioning profile" data-secondary="distribution" id="calibre_link-1818" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">If this is to be an Ad Hoc distribution profile, collect the UDIDs of all the devices where this build is to run, and make sure youâ€™ve added each of them at the developer member center under Devices. (For an App Store distribution profile, omit this step.)</p>
</li>
<li class="calibre4">
<p class="calibre17">Make sure that the app is registered at the developer member center under Identifiers â†’ App IDs, as I described earlier in this chapter.</p>
</li>
<li class="calibre4">
<p class="calibre17">Under Profiles, click the Plus button to ask for a new profile. Choose an Ad Hoc or App Store profile. On the next screen, choose your app from the pop-up menu. On the next screen, choose your distribution certificate. On the next screen, for an Ad Hoc profile only, specify the devices you want this app to run on. On the next screen, give the profile a name.</p>

<p class="calibre17">Be careful about the profileâ€™s name, as you might need to be able to recognize it later from within Xcode! My own practice is to assign a name containing the term â€œAdHocâ€ or â€œAppStoreâ€ and the name of the app.</p>
</li>
<li class="calibre4">
<p class="calibre17">Click Done.
You should subsequently be able to download the profile from within Xcode (and if not, you can click Download at the developer member <span class="publishername">center</span>).</p>
</li>

</ol>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Distribution for Testing" class="calibre2"><div class="preface" id="calibre_link-2633">
<h2 class="calibre42">Distribution for Testing</h2>

<p class="author1">There are two ways to distribute your app for testing: Ad Hoc distribution (the old way) and TestFlight distribution (the new way). Iâ€™ll briefly describe each of them.</p>

<p class="author1">Here are the steps for creating an Ad Hoc distribution<a data-type="indexterm" data-primary="Ad Hoc distribution" id="calibre_link-124" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> file from an archive:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In the Organizer window, under Archives, select the archive and click Distribute App at the upper right. A dialog appears. Here, you are to specify a method; choose Ad Hoc. Click Next.</p>
</li>
<li class="calibre4">
<p class="calibre17">In the next screen, you may be offered various options. For example:</p>
<dl class="calibre14">
<dt class="calibre15">App Thinning</dt>
<dd class="calibre16">
<p class="calibre17">This means that multiple copies of the app can be created, each containing resources appropriate only to one type of device, simulating what the App Store will do when the user downloads the app to a device. There would normally be no need for this, though it might be interesting to learn the size of your thinned app.<a data-type="indexterm" data-primary="thinning an app" id="calibre_link-2212" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Rebuild from Bitcode</dt>
<dd class="calibre16">
<p class="calibre17">Bitcode allows the App Store to regenerate your app to incorporate future optimizations. If youâ€™re going to be using bitcode when you upload to the App Store, you might like to use it when you perform your Ad Hoc build. Personally, I avoid bitcode, so I would uncheck this checkbox.</p>
</dd>
<dt class="calibre15">Strip Swift symbols</dt>
<dd class="calibre16">
<p class="calibre17">Check this box to reduce the build size somewhat.</p>
</dd>
</dl>
</li>
<li class="calibre4">
<p class="calibre17">In the next screen, you may be offered a choice between automatic and manual signing. An automatically generated Ad Hoc distribution profile will be configured to run on all devices registered for your team at the developer member center. If you choose manual signing, youâ€™ll see another screen where you can specify the certificate and choose an Ad Hoc distribution profile, either from the member <span class="publishername">center</span> or (if youâ€™ve downloaded the distribution profile already) from your computer.</p>
</li>
<li class="calibre4">
<p class="calibre17">The archive is prepared, and a summary window is displayed. The name of the provisioning profile is shown, so you can tell that the right thing is happening. Click Export.</p>
</li>
<li class="calibre4">
<p class="calibre17">You are shown a dialog for saving a folder. The file will be inside that folder, with the suffix <em class="calibre11">.ipa</em> (â€œiPhone appâ€), accompanied by <em class="calibre11">.plist</em> and log files describing the export process.</p>
</li>
<li class="calibre4">
<p class="calibre17">Locate in the Finder the <em class="calibre11">.ipa</em> file you just saved. Provide this file to your users with instructions.</p>
</li>

</ol>

<p class="author1">How should a user who has received the <em class="calibre11">.ipa</em> file copy it onto a registered device? The old way was to use iTunes as an intermediary, and it may be that that will still work: attach the device to the computer, locate its listing in iTunes, and drag the <em class="calibre11">.ipa</em> file directly from the Finder onto the deviceâ€™s name. However, I find that approach unreliable. Here are two alternative suggestions:</p>
<dl class="calibre14">
<dt class="calibre15">Xcode</dt>
<dd class="calibre16">
<p class="calibre17">A developer who has Xcode can attach the device to the computer, find the device in Xcodeâ€™s Devices window (Window â†’ Devices and Simulators), click the Plus button under Installed Apps, and choose the <em class="calibre11">.ipa</em> file on the computer. It will be copied onto the device.</p>
</dd>
<dt class="calibre15">Apple Configurator</dt>
<dd class="calibre16">
<p class="calibre17">For other users, the simplest approach is to download the Apple Configurator application from the Mac App Store. Attach the device to the computer and launch Apple Configurator. An image of the deviceâ€™s screen appears in the Configurator window. Drag the <em class="calibre11">.ipa</em> file from the Finder onto that image, and it will be copied onto the device.</p>
</dd>
</dl>

<p class="author1">The number of Ad Hoc testers is limited to 100 devices per year per developer (not per app). Devices used for development are counted against this limit. You can work around this limit, and provide your betas more conveniently to testers, by using TestFlight beta testing instead.<a data-type="indexterm" data-primary="TestFlight" id="calibre_link-2208" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="beta testing" id="calibre_link-247" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">TestFlight has many advantages over Ad Hoc testing. It lifts the limit of 100 devices to a limit of 10000 testers. It is far more convenient for your testers than Ad Hoc distribution, because they download and install prerelease versions of your app directly from the App Store onto their devices, through the TestFlight app. Communication between you and your testers is handled seamlessly: TestFlight emails invitations to testers, allows testers to provide feedback comments, collects crash logs, notifies testers when you update the app, and so forth.</p>

<p class="author1">Configuration is performed at the App Store Connect site (<a href="https://appstoreconnect.apple.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://appstoreconnect.apple.com</em></a>); a prerelease version uploaded to App Store Connect must be exported as if for App Store distribution (see the discussion of App Store submission later in this chapter). See the â€œTest a beta versionâ€ chapter of Appleâ€™s <em class="calibre11">App Store Connect Help</em> document (Help â†’ App Store Connect Help).<a data-type="indexterm" data-primary="App Store Connect" id="calibre_link-164" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Prerelease versions of your app intended for distribution to beta testers require review by Apple. Basically, the rule is that if your appâ€™s minor version number increases, you can expect a delay while Apple performs the review. On the other hand, <em class="calibre11">internal</em> testers (team members who have direct access to your App Store Connect account) can download new versions immediately. That includes you! I often use TestFlight as a way of distributing a build to myself so that I can test on a device under real-world conditions.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Final App Preparations" class="calibre2"><div class="preface" id="calibre_link-2634">
<h2 class="calibre42">Final App Preparations</h2>

<p class="author1">As the big day approaches when youâ€™re thinking of submitting your app to the App Store, donâ€™t become so excited by the prospect of huge fame and massive profits that you rush the all-important final stages of app preparation. Apple has a lot of requirements, and failure to meet them can cause your app to be rejected. Take your time. Make a checklist and go through it carefully. See Appleâ€™s <em class="calibre11">App Store Connect Help</em> and the â€œIcons and Imagesâ€ chapter of the <em class="calibre11">iOS Human Interface Guidelines</em>.</p>










<section data-type="sect3" data-pdf-bookmark="Icons in the app" class="calibre2"><div class="preface" id="calibre_link-3003">
<h3 class="calibre44">Icons in the app</h3>

<p class="author1">The best way to provide your app with icons is to use the asset catalog (<a data-type="xref" href="#calibre_link-45" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-31</a>).
The image sizes needed are listed in the asset catalog itself.
To determine which slots should be displayed, use the checkboxes in the Attributes inspector when you select the icon set. To add an image, drag it from the Finder into the appropriate slot.<a data-type="indexterm" data-primary="asset catalog" id="calibre_link-215" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-45" class="figure">
<img src="images/000000.png" alt="ios12 0919" class="calibre74" />
<h6 class="calibre34"><span class="publishername">Figure 9-31. </span>Icon slots in the asset catalog</h6>
</div>
</figure>

<p class="author1">An icon file must be a PNG file, without alpha transparency.<a data-type="indexterm" data-primary="icons" id="calibre_link-1029" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> It should be a full square; the rounding of the corners will be added for you. Apple seems nowadays to prefer simple, cartoony images with a few bright colors and possibly a gentle gradient background.</p>

<p class="author1">App icon sizes have changed over the years. If your app is to be backward-compatible to earlier systems, you may need additional icons in additional sizes, corresponding to the expectations of those earlier systems. Conversely, new devices can come along, bringing with them new icon size requirements (this happened when the iPad Pro appeared on the scene). Again, this is exactly the sort of thing the asset catalog will help you with.</p>

<p class="author1">Optionally, you may elect to include smaller versions of your icon to appear when the user does a search on the device, as well as in the Settings app if you include a settings bundle. However, I never include those icons; the systemâ€™s scaled-down versions of my app icons look fine to me.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Marketing icon" class="calibre2"><div class="preface" id="calibre_link-3004">
<h3 class="calibre44">Marketing icon</h3>

<p class="author1">To submit an app to the App Store, you will need to supply a 1024Ã—1024 PNG or high-quality JPEG icon to be displayed at the App Store (the <em class="calibre11">marketing icon</em>). Appleâ€™s guidelines say that it should not merely be a scaled-up version of your appâ€™s icon; but it must not differ perceptibly from your appâ€™s icon, either, or your app will be rejected (I know this from bitter experience).<a data-type="indexterm" data-primary="icons" data-secondary="marketing" id="calibre_link-1030" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="marketing icon" id="calibre_link-1269" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The marketing icon should be included in the asset catalog. Thereâ€™s a slot for it, along with the slots for the real app icons (<a data-type="xref" href="#calibre_link-46" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;9-32</a>).</p>

<figure class="calibre32"><div id="calibre_link-46" class="figure">
<img src="images/000001.png" alt="ios12 0919b" class="calibre75" />
<h6 class="calibre34"><span class="publishername">Figure 9-32. </span>Marketing icon slot in the asset catalog</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Launch images" class="calibre2"><div class="preface" id="calibre_link-3005">
<h3 class="calibre44">Launch images</h3>

<p class="author1">There is a delay between the moment when the user taps your appâ€™s icon to launch it and the moment when your app is up and running and displaying its initial window.<a data-type="indexterm" data-primary="launch images" id="calibre_link-1206" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> To cover this delay and give the user a visible indication that something is happening, a launch image needs to be displayed during that interval.</p>

<p class="author1">The launch image neednâ€™t be detailed; in fact, it probably should not be. It might be just a blank depiction of the main elements or regions of the interface that will be present when the app has finished launching. In this way, when the app <em class="calibre11">does</em> finish launching, those elements or regions appear to be filled in as the launch image fades away to reveal the real app.</p>

<p class="author1">In iOS 7 and before, the launch image was literally an image (a PNG file). It had to be included in your app bundle, and it had to obey certain naming conventions. As the variety of screen sizes and resolutions of iOS devices proliferated, so did the number of required launch images. The asset catalog, introduced in iOS 7, was helpful in this regard. But with the introduction of more and more devices and screen sizes, the entire situation threatened to become unmanageable.</p>

<p class="author1">For this reason, iOS 8 introduced a better solution. Instead of a set of launch images, you now provide a <em class="calibre11">launch nib file</em> &mdash; a single <em class="calibre11">.xib</em> or <em class="calibre11">.storyboard</em> file containing a single view to be displayed as a launch image. You construct this view using subviews and autolayout. Thus, the view is automatically reconfigured to match the screen size and orientation of the device on which the app is launching, and label and button text can be localized. The launch image is a snapshot of this view.<a data-type="indexterm" data-primary="nib files" data-secondary="launch" id="calibre_link-1396" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="launch nib" id="calibre_link-1207" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="storyboard files" data-secondary="launch" id="calibre_link-2083" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">By default, a new app project comes with a <em class="calibre11">LaunchScreen.storyboard</em> file. This is where you design your launch image. The <em class="calibre11">Info.plist</em> points to this file as the value of its â€œLaunch screen interface file base nameâ€ key (<code class="calibre19">UILaunchStoryboardName</code>). You can configure the <em class="calibre11">Info.plist</em>, if necessary, by editing the target and setting the Launch Screen File field (under App Icons and Launch Images).</p>

<p class="author1">You should take advantage of this feature &mdash; and not merely because it is convenient. The presence of a â€œLaunch screen interface file base nameâ€ key in your <em class="calibre11">Info.plist</em> tells the system that your app runs natively on newer device types. Without it, your app is displayed zoomed or letterboxed (or both). Apple says that eventually, for apps that you submit in the future, devices will stop compensating in this way; therefore you <em class="calibre11">must</em> use a launch screen nib, not a launch image or set of launch images.</p>

<p class="author1">Custom fonts included in your app bundle cannot be displayed in a launch nib file. This is because they have not yet been loaded at the time the launch screen needs to be displayed. Also, code cannot run in association with the display of the launch screen; by definition, your app is launching and its code has not yet started to run. None of those limitations should be a concern. Keep the launch screen simple and minimal. Donâ€™t try to misuse it as some kind of introductory splash screen. If you want a splash screen, configure a real view controller to display its view when the app has finished launching.</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Screenshots and Video Previews" class="calibre2"><div class="preface" id="calibre_link-2635">
<h2 class="calibre42">Screenshots and Video Previews</h2>

<p class="author1">When you submit your app to the App Store, you will be asked for one or more screenshots of your app in action to be displayed at the App Store.<a data-type="indexterm" data-primary="screenshots" id="calibre_link-1962" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> These screenshots must demonstrate actual user experience of the app, or your app may be rejected by Appleâ€™s review team. You should take them beforehand and be prepared to provide them during the app submission process. You can provide a screenshot corresponding to the screen size of every device on which your app can run, in the corresponding resolution, or you can reuse a larger-size screenshot for smaller sizes.</p>

<p class="author1">You can obtain screenshots either from the Simulator or from a device connected to the computer:</p>
<dl class="calibre14">
<dt class="calibre15">Simulator</dt>
<dd class="calibre16">
<p class="calibre17">Run the app in the Simulator with the desired device type as your destination. Choose File â†’ New Screen Shot. Hold Option if you want to specify the screenshotâ€™s name and location.</p>
</dd>
<dt class="calibre15">Device</dt>
<dd class="calibre16">
<p class="calibre17">In Xcode, in the Devices and Simulators window, locate your connected device under Devices and click Take Screenshot. Alternatively, choose Debug â†’ View Debugging â†’ Take Screenshot of [Device].</p>
</dd>
</dl>

<p class="author1">You can also take a screenshot directly on a device. If the device has a Home button, click the screen lock button and the Home button simultaneously. If not, click the screen lock button and the Volume Up button simultaneously. Now the screenshot is in the Camera Roll in the Photos app, and you can communicate it to your computer in any convenient way (such as by emailing it to yourself).</p>

<p class="author1">You probably donâ€™t have devices with every size you need in order to submit screenshots to the App Store. The Simulator supplies every needed device size.
It may be, however, that your app doesnâ€™t run properly on the Simulator, because it uses features that exist only on a device. I frequently solve this problem by supplying artificial data to my app, on the simulator only, so that its interface works sufficiently to let me capture screenshots.</p>

<p class="author1">You can also submit to the App Store a video preview showing your app in action; it can be up to 30 seconds long, in H.264 or Apple ProRes format:<a data-type="indexterm" data-primary="screencasts" id="calibre_link-1960" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="video previews" id="calibre_link-2347" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="previews, video" id="calibre_link-1720" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Connect the device to the computer and launch QuickTime Player. Choose File â†’ New Movie Recording.</p>
</li>
<li class="calibre4">
<p class="calibre17">If necessary, set the Camera and Microphone to the device, using the pop-up menu from the down-pointing chevron button next to the Record button that appears when you hover the mouse over the QuickTime Player window.</p>
</li>
<li class="calibre4">
<p class="calibre17">Start recording, and exercise the app on the device. When youâ€™re finished, stop recording and save.</p>
</li>

</ol>

<p class="author1">The resulting movie file can be edited
to prepare it for submission to the App Store.
For more details, see the â€œApp preview specificationsâ€ section of the Reference chapter of Appleâ€™s <em class="calibre11">App Store Connect Help.</em></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Property List Settings" class="calibre2"><div class="preface" id="calibre_link-2636">
<h2 class="calibre42">Property List Settings</h2>

<p class="author1">A number of settings in the <em class="calibre11">Info.plist</em> are crucial to the proper behavior of your app. You should peruse Appleâ€™s <em class="calibre11">Information Property List Key Reference</em> for full information. Most of the required keys are created as part of the template, and are given reasonable default values, but you should check them anyway. The following are particularly worthy of attention:<a data-type="indexterm" data-primary="Info.plist" id="calibre_link-1063" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="property list settings" id="calibre_link-1780" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Bundle display name (<code class="calibre19">CFBundleDisplayName</code>)</dt>
<dd class="calibre16">
<p class="calibre17">The name that appears under your appâ€™s icon on the device screen; this name needs to be short in order to avoid truncation. I talked earlier in this chapter about how to localize the display name. You can enter this value directly in the General pane when you edit your app target.<a data-type="indexterm" data-primary="name of app" id="calibre_link-1372" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="app" data-secondary="name" id="calibre_link-155" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Supported interface orientations (<code class="calibre19">UISupportedInterfaceOrientations</code>)</dt>
<dd class="calibre16">
<p class="calibre17">This key designates the totality of orientations in which the app is ever permitted to appear. I talked earlier in this chapter about the interface for making these settings with checkboxes in the General pane of the target editor, but you get better fine tuning by editing the <em class="calibre11">Info.plist</em> directly. For example, it might be necessary to reorder the orientations (because on an iPhone the <em class="calibre11">first</em> orientation listed may be the one into which the app will actually launch).<a data-type="indexterm" data-primary="orientation of interface" id="calibre_link-1635" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="supported interface orientations" id="calibre_link-2165" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Required device capabilities (<code class="calibre19">UIRequiredDeviceCapabilities</code>)</dt>
<dd class="calibre16">
<p class="calibre17">You should set this key if the app requires capabilities that are not present on all devices. But donâ€™t use this key unless it makes no sense for your app to run <em class="calibre11">at all</em> on a device lacking the specified capabilities.</p>
</dd>
<dt class="calibre15">Bundle version</dt>
<dd class="calibre16">
<p class="calibre17">Your app needs a version number.<a data-type="indexterm" data-primary="app" data-secondary="version number" id="calibre_link-160" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The best place to set it is the General pane of the target editor. Things are a little confusing here because there are two fields:</p>
<div class="preface"><dl class="calibre14">
<dt class="calibre15">Version</dt>
<dd class="calibre16">
<p class="calibre17">Corresponds in the <em class="calibre11">Info.plist</em> to â€œBundle versions string, shortâ€ (<code class="calibre19">CFBundleShortVersionString</code>). This is a user-facing string and needs to be a version string<a data-type="indexterm" data-primary="version string" id="calibre_link-2346" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, such as <code class="calibre19">"1.0"</code>. It will be displayed at the App Store, distinguishing one release from another. Failure to increment the version string when submitting an update will cause the update to be rejected.</p>
</dd>
<dt class="calibre15">Build</dt>
<dd class="calibre16">
<p class="calibre17">Corresponds in the <em class="calibre11">Info.plist</em> to â€œBundle versionâ€ (<code class="calibre19">CFBundleVersion</code>). The user never sees this value. I treat it as an independent integer value. It is legal to increment the Build number without incrementing the Version number, and that is what I do when I submit several successive builds of the same prospective release during TestFlight testing, or because I discover a bug and have to withdraw a submitted binary before it appears on the App Store.</p>
</dd>
</dl>
</div>


<p class="calibre17">The interplay between TestFlight versions and App Store versions is a little tricky. If youâ€™re satisfied with a TestFlight version, you can submit the very same binary, which is already present at App Store Connect, for distribution by the App Store.
But once you have submitted a version to the App Store, the next build that you submit, even if it is just for TestFlight, must have a higher version string; upping the build number is not sufficient.</p>
</dd>
</dl>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Version strings donâ€™t work like decimal numbers! Each component of the string is treated as an <em class="calibre11">integer</em>. For example, a short version string <code class="calibre19">"1.4"</code> is not â€œhigherâ€ than a version string <code class="calibre19">"1.32"</code> &mdash; because 4 is smaller than 32. As usual, I learned this lesson the hard way.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Submission to the App Store" class="calibre2"><div class="preface" id="calibre_link-2637">
<h2 class="calibre42">Submission to the App Store</h2>

<p class="author1">When youâ€™re satisfied that your app works well, and youâ€™ve installed or collected all the necessary resources, youâ€™re ready to submit your app to the App Store for distribution.<a data-type="indexterm" data-primary="App Store" id="calibre_link-162" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> To do so, youâ€™ll need to make preparations at the App Store Connect site (<a href="https://appstoreconnect.apple.com" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://appstoreconnect.apple.com</em></a>).<a data-type="indexterm" data-primary="App Store Connect" id="calibre_link-165" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="iTunes Connect" data-see="App Store Connect" id="calibre_link-3006" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="note" {http://www.idpf.org/2007/ops}type="note" class="calibre23"><h6 class="calibre24">Note</h6>
<p class="author1">The first time you visit App Store Connect, you should go to the Contracts section and complete submission of your contract. You canâ€™t offer any apps for sale until you do, and even free apps require completion of a contractual form.</p>
</div>

<p class="author1">Iâ€™m not going to recite all the steps you have to go through to tell App Store Connect about your app, as these are described thoroughly in Appleâ€™s <em class="calibre11">App Store Connect Help</em> document, which is the final word on such matters. But here are some of the main pieces of information you will sooner or later have to supply (and see also <a href="https://developer.apple.com/app-store/product-page" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://developer.apple.com/app-store/product-page</em></a>):</p>
<dl class="calibre14">
<dt class="calibre15">Your appâ€™s name</dt>
<dd class="calibre16">
<p class="calibre17">This is the name that will appear at the App Store; it need not be identical to the short name that will appear under the appâ€™s icon on the device, dictated by the â€œBundle display nameâ€ setting in your <em class="calibre11">Info.plist</em> file.<a data-type="indexterm" data-primary="name of app" id="calibre_link-1373" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="app" data-secondary="name" id="calibre_link-156" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Apple now requires that this name be 30 characters or fewer. You can get a rude shock when you submit your appâ€™s information to App Store Connect and discover that the name you wanted is already taken. There is no reliable way to learn this in advance, and such a discovery can necessitate a certain amount of last-minute scrambling on your part. (Can you guess how I know that?)</p>
</dd>
<dt class="calibre15">Subtitle</dt>
<dd class="calibre16">
<p class="calibre17">A description of the app, 30 characters or fewer, that will appear below the name at the App Store.</p>
</dd>
<dt class="calibre15">Description</dt>
<dd class="calibre16">
<p class="calibre17">You must supply a description of fewer than 4,000 characters; Apple recommends fewer than 580 characters, and the first paragraph is the most important, because this may be all that users see at first when they visit the App Store. It must be pure text, with no HTML or character styling.</p>
</dd>
<dt class="calibre15">Promotional text</dt>
<dd class="calibre16">
<p class="calibre17">Optional; 170 characters or fewer. The significance of the promotional text is that you can change it for an existing app, without uploading a new build.</p>
</dd>
<dt class="calibre15">Keywords</dt>
<dd class="calibre16">
<p class="calibre17">A comma-separated list, shorter than 100 characters. These keywords will be used, in addition to your appâ€™s name, to help users discover your app through the Search feature of the App Store.</p>
</dd>
<dt class="calibre15">Privacy policy</dt>
<dd class="calibre16">
<p class="calibre17">The URL of a web page describing your privacy policy.</p>
</dd>
<dt class="calibre15">Support</dt>
<dd class="calibre16">
<p class="calibre17">The URL of a web site where users can find more information about your app.</p>
</dd>
<dt class="calibre15">Copyright</dt>
<dd class="calibre16">
<p class="calibre17">Do not include a copyright symbol in this string; it will be added for you at the App Store.</p>
</dd>
<dt class="calibre15">SKU number</dt>
<dd class="calibre16">
<p class="calibre17">This is arbitrary, so donâ€™t get nervous about it. Itâ€™s just an identifier thatâ€™s unique within the world of your own apps. Itâ€™s convenient if it has something to do with your appâ€™s name. It neednâ€™t be a number; it can actually be any string.</p>
</dd>
<dt class="calibre15">Price</dt>
<dd class="calibre16">
<p class="calibre17">You donâ€™t get to make up a price. You have to choose from a list of pricing â€œtiers.â€</p>
</dd>
<dt class="calibre15">Availability Date</dt>
<dd class="calibre16">
<p class="calibre17">Thereâ€™s an option to make the app available as soon as it is approved, and this will typically be your choice.</p>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">As you submit information, click Save often! If the connection goes down and you havenâ€™t explicitly saved, all your work can be lost. (Can you guess how I know that?)</p>
</div>

<p class="author1">Once your app is initially registered at App Store Connect, and when you have an archived build ready for distribution, you can export and upload it. The export process is similar to what I described earlier for Ad Hoc distribution. Select the archived build in the Organizer and click Distribute App; on the next screen, select App Store. Subsequent options are slightly different from the options for an Ad Hoc distribution: you wonâ€™t see anything about app thinning, because that depends on how the user obtains the app; youâ€™ll see the bitcode checkbox; and thereâ€™s a checkbox for uploading symbols, which should make it easier to analyze crash reports. Eventually, a screen is displayed summarizing the <em class="calibre11">.ipa</em> content, and you can now upload to App Store Connect or save to disk:</p>
<dl class="calibre14">
<dt class="calibre15">Upload to App Store Connect</dt>
<dd class="calibre16">
<p class="calibre17">The upload is performed within Xcode, and the app will be validated at the far end.</p>
</dd>
<dt class="calibre15">Save to disk</dt>
<dd class="calibre16">
<p class="calibre17">You can perform the upload later using Transporter. This is a command-line tool built into Xcode (and is actually how upload within Xcode is performed); you can talk to it by saying <code class="calibre19">xcrun iTMSTransporter</code> in the Terminal. See <a href="https://help.apple.com/itc/transporteruserguide" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">https://help.apple.com/itc/transporteruserguide</em></a> for details.<a data-type="indexterm" data-primary="Transporter" id="calibre_link-2223" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">After uploading the archive, you have one final step to perform. Wait for the binary to be processed at Appleâ€™s end. (You should receive an email when processing has completed.) Then return to App Store Connect, where you submitted your app information. You will now be able to select the binary, save, and submit the app for review.</p>

<p class="author1">You will subsequently receive notifications from Apple informing you of your appâ€™s status as it passes through various stages: â€œWaiting For Review,â€ â€œIn Review,â€ and finally, if all has gone well, â€œReady For Saleâ€ (even if itâ€™s a free app). Your app will then appear at the App Store.<a data-type="indexterm" data-startref="idxxcode" id="calibre_link-2376" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Once your app is registered at the App Store, you do <em class="calibre11">not</em> need to make further preparations merely to upload a new build. Simply increase the build number or version string, as I described earlier, and upload the build. If this build is for TestFlight, and if this version has already been reviewed for TestFlight, the new build becomes available for testing immediately. If this build is for the App Store, you can upload it first and register the new version at App Store Connect later.</p>
</div>
</section>





</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-47">
<div id="calibre_link-3007" class="calibre1"><div data-type="part" {http://www.idpf.org/2007/ops}type="part" data-pdf-bookmark="Part III. Cocoa" id="calibre_link-2638" class="preface">
<h1 class="calibre27"><span class="label">Part III. </span>Cocoa</h1>

<div class="preface">
<p class="author1">The Cocoa Touch frameworks provide the general capabilities needed by any iOS application. Buttons can be tapped, text can be read, screens of interface can succeed one another, because Cocoa makes it so. To use the framework, you must learn to let the framework use you. You must put your code in the right place so that it will be called at the right time. You must fulfill certain obligations that Cocoa expects of you. You master Cocoa by being Cocoaâ€™s obedient servant. In this part of the book, thatâ€™s what youâ€™ll learn to do.</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a> describes how Cocoa is organized and structured through such Objective-C language features as subclassing, categories, and protocols. Then some important built-in Cocoa object types are introduced. The chapter concludes with a description of Cocoa key&ndash;value coding and a look at how the root NSObject class is organized.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a> presents Cocoaâ€™s event-driven model of activity, along with its major design patterns and event-related features &mdash; notifications, delegation, data sources, target&ndash;action, the responder chain, and key&ndash;value observing. The chapter concludes with some words of wisdom about managing the barrage of events Cocoa will be throwing at you, and how to escape that barrage momentarily with delayed performance.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a> is about Cocoa memory management. Iâ€™ll explain how memory management of reference types works. Then some special memory management situations are described: autorelease pools, retain cycles, notifications and timers, nib loading, and CFTypeRefs. The chapter concludes with a discussion of Cocoa property memory management, and advice on how to debug memory management issues.</p>
</li>
<li class="calibre12">
<p class="calibre17"><a data-type="xref" href="#calibre_link-50" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;13</a> discusses the question of how your objects are going to see and communicate with one another within the confines of the Cocoa-based world. It concludes with a look at two new ways of managing object communications, the Combine framework and SwiftUI.</p>
</li>
</ul>

<p class="author1">Finally, donâ€™t forget to read <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a> for more detail about how Objective-C and Swift interact and cooperate.</p>
</div>











































































</div>
</div>
</div>


<div class="calibre" id="calibre_link-53">
<div id="calibre_link-3008" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 10. Cocoa Classes" class="calibre2"><div class="preface" id="calibre_link-48">
<h1 class="calibre13"><span class="label">Chapter 10. </span>Cocoa Classes</h1>


<p class="author1">When you program iOS through Foundation and UIKit, youâ€™re programming Cocoa.
The Cocoa API is written mostly in Objective-C, and Cocoa itself consists mostly of Objective-C classes, derived from the root class, NSObject.</p>

<p class="author1">This chapter introduces Cocoaâ€™s class structure
and explains how Cocoa is conceptually organized, in terms of its underlying Objective-C features, along with a survey of some of the most commonly encountered Cocoa utility classes. The chapter then discusses Objective-C instance properties and Cocoa key&ndash;value coding, and concludes with a description of the Cocoa root class and its features, which are inherited by all Cocoa classes.<a data-type="indexterm" data-primary="Cocoa" id="calibre_link-411" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Subclassing" class="calibre2"><div class="preface" id="calibre_link-2639">
<h1 class="calibre18">Subclassing</h1>

<p class="author1">Cocoa supplies a large repertory of objects that already know how to behave in certain desirable ways. A UIButton, for example, knows how to draw itself and how to respond when the user taps it; a UITextField knows how to display editable text, how to summon the keyboard, and how to accept keyboard input.<a data-type="indexterm" data-primary="subclassing" data-secondary="in Cocoa" id="calibre_link-2135" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="subclassing" id="calibre_link-424" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> When the default behavior or appearance of an object supplied by Cocoa isnâ€™t quite what youâ€™re after, youâ€™ll want to customize it.</p>

<p class="author1">But that does <em class="calibre11">not</em> necessarily mean you need to subclass! In fact, subclassing is one of the rarer ways in which your code will relate to Cocoa.
Most built-in Cocoa Touch classes will never need subclassing (and some, in their documentation, downright forbid it).</p>

<p class="author1">Instead, Cocoa classes are often heavily endowed with methods that you can call and properties that you can set precisely in order to customize an instance, and these will be your first resort. Always study the documentation for a Cocoa class to see whether instances can already be made to do what you want. For example, the UIButton class documentation shows that you can set a buttonâ€™s title, title color, internal image, background image, and many other features and behaviors, without subclassing.</p>

<p class="author1">In addition, many built-in classes use delegation (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) as the preferred way of letting you customize their behavior. You wouldnâ€™t subclass
UITextField just in order to respond in some special way when the user types text into the field, because the delegate mechanism and the UITextFieldDelegate protocol provide ways to do that, such as <code class="calibre19">textField(_:shouldChangeCharactersIn:replacementString:)</code>.</p>

<p class="author1">Nevertheless, sometimes setting properties and calling methods and using delegation wonâ€™t suffice to customize an instance the way you want to. In such cases, a Cocoa class may provide methods that are called by the runtime at key moments in the life of the instance, allowing you to customize that classâ€™s behavior by subclassing and overriding.
In fact, certain Cocoa Touch classes are subclassed routinely, constituting the exception that proves the rule.<a data-type="indexterm" data-primary="subclassing" data-secondary="UIViewController" id="calibre_link-2142" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A case in point is UIViewController. Every app uses view controllers. But a plain vanilla UIViewController, not subclassed, is very rare. An iOS app without at least one UIViewController subclass would be practically impossible. Your code is likely to consist <em class="calibre11">primarily</em> of UIViewController subclasses that you have written. Subclassing is how you inject your functionality into a view controller. With UIKit, <em class="calibre11">most</em> of your appâ€™s functionality will likely live in subclassed view controllers.
<a data-type="indexterm" data-primary="UIViewController" data-seealso="view controller" id="calibre_link-2263" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Another case in point is UIView. Cocoa Touch is full of built-in UIView subclasses that behave and draw themselves as needed (UIButton, UITextField, and so on), and you will rarely need to subclass any of them. On the other hand, you might create your <em class="calibre11">own</em> UIView subclass, whose job would be to draw itself in some completely new way.<a data-type="indexterm" data-primary="drawing a view" id="calibre_link-710" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="views" data-secondary="drawing" id="calibre_link-2355" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You donâ€™t actually draw a UIView; rather, when a UIView needs drawing, its <code class="calibre19">draw(_:)</code> method is called so that the view can draw itself. So the way to draw a custom UIView is to subclass UIView and implement <code class="calibre19">draw(_:)</code> in the subclass. As the documentation says, â€œSubclasses that â€¦ draw their viewâ€™s content should override this method and implement their drawing code there.â€ The documentation is saying that you <em class="calibre11">need</em> to subclass UIView in order to draw custom content.<a data-type="indexterm" data-primary="UIView" data-seealso="views" id="calibre_link-2261" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, suppose we want our window to contain a horizontal line. There is no horizontal line interface widget built into Cocoa, so weâ€™ll just have to roll our own &mdash; a UIView that draws itself as a horizontal line. Letâ€™s try it:<a data-type="indexterm" data-primary="subclassing" data-secondary="UIView" id="calibre_link-2140" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In our Empty Window example project,<a data-type="indexterm" data-primary="Empty Window example project" id="calibre_link-733" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> choose File â†’ New â†’ File and specify iOS â†’ Source â†’ Cocoa Touch Class, and in particular a subclass of UIView. Call the class MyHorizLine. Xcode creates <em class="calibre11">MyHorizLine.swift</em>. Make sure itâ€™s part of the app target.</p>
</li>
<li class="calibre4">
<p class="calibre17">In <em class="calibre11">MyHorizLine.swift</em>, replace the contents of the class declaration with this (without further explanation):</p>

<pre data-type="programlisting" class="calibre38">required init?(coder aDecoder: NSCoder) {
    super.init(coder:aDecoder)
    self.backgroundColor = .clear
}
override func draw(_ rect: CGRect) {
    let c = UIGraphicsGetCurrentContext()!
    c.move(to:CGPoint(x: 0, y: 0))
    c.addLine(to:CGPoint(x: self.bounds.size.width, y: 0))
    c.strokePath()
}</pre>
</li>
<li class="calibre4">
<p class="calibre17">Edit the storyboard. Find UIView in the Library (it is called simply â€œViewâ€) and drag it into the View object in the canvas. You may resize it to be less tall.</p>
</li>
<li class="calibre4">
<p class="calibre17">Select the UIView that you just dragged into the canvas and use the Identity inspector to change its class to MyHorizLine.</p>
</li>

</ol>

<p class="author1">Build and run the app in the Simulator. Youâ€™ll see a horizontal line corresponding to the location of the top of the MyHorizLine instance in the nib. Our view has drawn itself as a horizontal line, because we subclassed it to do so.</p>

<p class="author1">In that example, we started with a bare UIView that had no drawing functionality of its own.
But you might also be able to subclass a built-in UIView subclass to modify the way it already draws itself. For example, the UILabel documentation shows that two methods are present for exactly this purpose. Both <code class="calibre19">drawText(in:)</code> and <code class="calibre19">textRect(forBounds:limitedToNumberOfLines:)</code> explicitly tell us: â€œThis method should only be overridden by subclasses that want to [modify how the label is drawn].â€ The implication is that these are methods that will be called for us, automatically, by Cocoa, as a label draws itself; thus, we can subclass UILabel and implement these methods in our subclass to modify how a particular label draws itself.</p>

<p class="author1">In one of my own apps, I subclass UILabel and override <code class="calibre19">drawText(in:)</code> to make a label that draws its own rectangular border and has its content inset somewhat from that border. As the documentation tells us: â€œIn your overridden method, you can configure the current context further and then invoke <code class="calibre19">super</code> to do the actual drawing [of the text].â€ Letâ€™s try it:<a data-type="indexterm" data-primary="UILabel" id="calibre_link-2256" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subclassing" data-secondary="UILabel" id="calibre_link-2139" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">In the Empty Window project, make a new class file, a UILabel subclass; call the class MyBoundedLabel.</p>
</li>
<li class="calibre4">
<p class="calibre17">In <em class="calibre11">MyBoundedLabel.swift</em>, insert this code into the body of the class declaration:</p>

<pre data-type="programlisting" class="calibre38">override func drawText(in rect: CGRect) {
    let context = UIGraphicsGetCurrentContext()!
    context.stroke(self.bounds.insetBy(dx: 1.0, dy: 1.0))
    super.drawText(in: rect.insetBy(dx: 5.0, dy: 5.0))
}</pre>
</li>
<li class="calibre4">
<p class="calibre17">Edit the storyboard, add a UILabel to the interface, and change its class in the Identity inspector to MyBoundedLabel.</p>
</li>

</ol>

<p class="author1">Build and run the app. As you can see, the rectangle is drawn and the labelâ€™s text is inset within it.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Categories and Extensions" class="calibre2"><div class="preface" id="calibre_link-2640">
<h1 class="calibre18">Categories and Extensions</h1>

<p class="author1">A <em class="calibre11">category</em> is an Objective-C language feature that allows code to reach right into an existing class and inject additional methods.<a data-type="indexterm" data-primary="categories" id="calibre_link-347" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This is comparable to a Swift extension (<a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>), so Iâ€™ll start by reminding you how extensions are used, and then Iâ€™ll describe how Cocoa uses categories.
<a data-type="indexterm" data-primary="Objective-C" data-secondary="categories" id="calibre_link-1514" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="categories" id="calibre_link-413" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Objective-C categories have names, and you may see references to these names in the headers, the documentation, and so forth. However, the names are effectively meaningless, so donâ€™t worry about them.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="How Swift Uses Extensions" class="calibre2"><div class="preface" id="calibre_link-2641">
<h2 class="calibre42">How Swift Uses Extensions</h2>

<p class="author1">In the Swift standard library header, many native object type declarations consist of an initial declaration followed by a series of extensions. For example, after declaring the generic <code class="calibre19">struct Array&lt;Element&gt;</code>, the header proceeds to declare some dozen extensions on the Array struct. Some of these add protocol adoptions; all of them add declarations of properties or methods.
<a data-type="indexterm" data-primary="extensions" id="calibre_link-826" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
These extensions are not, of themselves, functionally significant. The header <em class="calibre11">could</em> have declared the Array struct with all of those properties and methods within the body of a single declaration. Instead, it breaks things up into multiple extensions as a way of clumping related functionality together, organizing this object typeâ€™s members so as to make them easier for human readers to understand.</p>

<p class="author1">In the Swift Core Graphics header, on the other hand, extensions <em class="calibre11">are</em> functionally significant &mdash; and just about everything <em class="calibre11">is</em> an extension &mdash; because Swift is adapting types that are already defined elsewhere. It adapts Swift numeric types for use with Core Graphics and CGFloat, and it adapts C structs such as CGPoint and CGRect for use as Swift object types.<a data-type="indexterm" data-primary="header files" data-secondary="Core Graphics" id="calibre_link-1011" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="How You Use Extensions" class="calibre2"><div class="preface" id="calibre_link-2642">
<h2 class="calibre42">How You Use Extensions</h2>

<p class="author1">For the sake of object-oriented encapsulation, you will often want
to write a function that you inject, as a method, into an existing object type.
To do so, youâ€™ll write an extension. Subclassing merely to add a method or two is heavy-handed &mdash; and besides, it often wouldnâ€™t help you do what you need to do.</p>

<p class="author1">For example, suppose you wanted to add a method to Cocoaâ€™s UIView class. You could subclass UIView and declare your method, but then it would be present only in your UIView subclass and in subclasses of that subclass. It would <em class="calibre11">not</em> be present in UIButton, UILabel, and all the other built-in UIView subclasses, because they are subclasses of UIView, not of <em class="calibre11">your</em> subclass. An extension solves the problem beautifully: you inject your method into UIView, and it is inherited by all built-in UIView subclasses as well.</p>

<p class="author1">For more fine-grained injection of functionality, you can use protocol extensions.
Suppose I want UIButton and UIBarButtonItem &mdash; which is not a UIView, but does have button-like behavior &mdash; to share a certain method. I can declare a protocol with a method, implement that method in a protocol extension, and then use extensions to make UIButton and UIBarButtonItem adopt that protocol and thus acquire that method:<a data-type="indexterm" data-primary="extensions" data-secondary="protocols" id="calibre_link-834" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="extensions" id="calibre_link-1802" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">protocol ButtonLike {
    func behaveInButtonLikeWay()
}
extension ButtonLike {
    func behaveInButtonLikeWay() {
        // ...
    }
}
extension UIButton : ButtonLike {}
extension UIBarButtonItem : ButtonLike {}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="How Cocoa Uses Categories" class="calibre2"><div class="preface" id="calibre_link-2643">
<h2 class="calibre42">How Cocoa Uses Categories</h2>

<p class="author1">Cocoa uses categories as an organizational tool much as Swift uses extensions. The declaration of a class will often be divided by functionality into multiple categories; these can even appear in separate header files.</p>

<p class="author1">A good example is NSString. NSString is defined as part of the Foundation framework, and its basic methods are declared in <em class="calibre11">NSString.h</em>. Here we find that NSString itself, aside from its initializers, has just two members, <code class="calibre19">length</code> and <code class="calibre19">character(at:)</code>, because these are regarded as the minimum functionality that a string needs in order to be a string.</p>

<p class="author1">Additional NSString methods &mdash; those that create a string, deal with a stringâ€™s encoding, split a string, search in a string, and so on &mdash; are clumped into categories. These are shown in the Swift translation of the header as extensions. So, for example, after the declaration for the NSString class itself, we find this in the Swift translation of the header:</p>

<pre data-type="programlisting" class="calibre28">extension NSString {
    func substring(from: Int) -&gt; String
    func substring(to: Int) -&gt; String
    // ...
}</pre>

<p class="author1">That is actually Swiftâ€™s translation of this Objective-C code:</p>

<pre data-type="programlisting" class="calibre28">@interface NSString (NSStringExtensionMethods)
- (NSString *)substringFromIndex:(NSUInteger)from;
- (NSString *)substringToIndex:(NSUInteger)to;
// ...
@end</pre>

<p class="author1">That notation &mdash; the keyword <code class="calibre19">@interface</code>, followed by a class name, followed by another name in parentheses &mdash; is an Objective-C category.</p>

<p class="author1">Moreover, although the declarations for some of Cocoaâ€™s NSString categories appear in this same file, <em class="calibre11">NSString.h</em>, many of them appear elsewhere. For example:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A string may serve as a file pathname, so we also find a category on NSString in <em class="calibre11">NSPathUtilities.h</em>, where methods and properties such as <code class="calibre19">pathComponents</code> are declared for splitting a pathname string into its constituents and the like.</p>
</li>
<li class="calibre12">
<p class="calibre17">In <em class="calibre11">NSURL.h</em>, which is devoted primarily to declaring the NSURL class (and <em class="calibre11">its</em> categories), there is also another NSString category, declaring methods for dealing with percent-escaping in a URL string, such as <code class="calibre19">addingPercentEncoding(withAllowedCharacters:)</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Off in a completely different framework (UIKit), <em class="calibre11">NSStringDrawing.h</em> adds two further NSString categories, with methods like <code class="calibre19">draw(at:withAttributes:)</code> having to do with drawing a string in a graphics context.</p>
</li>
</ul>

<p class="author1">This organization means that the NSString methods are not gathered in a single header file. In general, fortunately, this wonâ€™t matter to you as a programmer, because an NSString is an NSString, no matter how it acquires its methods.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Protocols" class="calibre2"><div class="preface" id="calibre_link-2644">
<h1 class="calibre18">Protocols</h1>

<p class="author1">Objective-C has protocols, and these are generally comparable to and compatible with Swift protocols (see <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>). Since classes are the only Objective-C object type, all Objective-C protocols are seen by Swift as class protocols. Conversely, Swift protocols marked as <code class="calibre19">@objc</code> are implicitly class protocols and can be seen by Objective-C. Cocoa makes extensive use of protocols.<a data-type="indexterm" data-primary="protocols" data-secondary="Objective-C" id="calibre_link-1811" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="protocols" id="calibre_link-1540" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" id="calibre_link-1787" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="protocols" id="calibre_link-422" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, letâ€™s talk about how Cocoa objects are copied. Some objects can be copied; some canâ€™t. This has nothing to do with an objectâ€™s class heritage. Yet we would like a uniform method to which any object that <em class="calibre11">can</em> be copied will respond. So Cocoa defines a protocol named NSCopying<a data-type="indexterm" data-primary="NSCopying" id="calibre_link-1434" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, which declares just one required method, <code class="calibre19">copyWithZone:</code>. Hereâ€™s how the NSCopying protocol is declared in Objective-C (in <em class="calibre11">NSObject.h</em>):</p>

<pre data-type="programlisting" class="calibre28">@protocol NSCopying
- (id)copyWithZone:(nullable NSZone *)zone;
@end</pre>

<p class="author1">Thatâ€™s translated into Swift as follows:</p>

<pre data-type="programlisting" class="calibre28">protocol NSCopying {
    func copy(with zone: NSZone? = nil) -&gt; Any
}</pre>

<p class="author1">The NSCopying protocol declaration in <em class="calibre11">NSObject.h</em>, however, is not a statement that NSObject <em class="calibre11">itself</em> conforms to NSCopying. Indeed, NSObject does <em class="calibre11">not</em> conform to NSCopying! This doesnâ€™t compile:</p>

<pre data-type="programlisting" class="calibre28">let obj = NSObject().copy(with:nil) // compile error</pre>

<p class="author1">But this does compile, because NSString <em class="calibre11">does</em> conform to NSCopying:</p>

<pre data-type="programlisting" class="calibre28">let s = ("hello" as NSString).copy(with: nil)</pre>

<p class="author1">Far and away the most pervasive use of protocols in Cocoa is in connection with the delegation pattern. Iâ€™ll discuss this pattern in detail in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>, but you can readily see an example in our handy Empty Window project: the AppDelegate class provided by the project template is declared like this:</p>

<pre data-type="programlisting" class="calibre28">class AppDelegate: UIResponder, UIApplicationDelegate { // ...</pre>

<p class="author1">AppDelegateâ€™s chief purpose on earth is to serve as the shared applicationâ€™s delegate. The shared application object is a UIApplication, and UIApplicationâ€™s <code class="calibre19">delegate</code> property is declared like this (Iâ€™ll explain the <code class="calibre19">unsafe</code> modifier in <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>):</p>

<pre data-type="programlisting" class="calibre28">unowned(unsafe) var delegate: UIApplicationDelegate?</pre>

<p class="author1">The <code class="calibre19">UIApplicationDelegate</code> type is a protocol. UIApplication is saying: â€œI donâ€™t care what class my delegate belongs to, but whatever it is, it should conform to the UIApplicationDelegate protocol.â€ Such conformance constitutes a promise that the delegate will implement instance methods declared by the protocol, such as <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code>. The AppDelegate class officially announces its role by explicitly adopting the UIApplicationDelegate protocol.</p>

<p class="author1">A Cocoa protocol has its own documentation page (see <a data-type="xref" href="#calibre_link-54" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;8</a>). When the UIApplication class documentation tells you that the <code class="calibre19">delegate</code> property is typed as UIApplicationDelegate, itâ€™s implicitly telling you that if you want to know what messages a UIApplicationâ€™s delegate might receive, you need to look in the UIApplicationDelegate protocol documentation. <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code> isnâ€™t mentioned anywhere in the UIApplication class documentation page; itâ€™s in the UIApplicationDelegate protocol documentation page.<a data-type="indexterm" data-primary="protocols" data-secondary="documentation" id="calibre_link-1800" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="documentation" data-secondary="protocols" id="calibre_link-698" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Optional Members" class="calibre2"><div class="preface" id="calibre_link-2645">
<h2 class="calibre42">Optional Members</h2>

<p class="author1">Objective-C protocols, and Swift protocols marked as <code class="calibre19">@objc</code>, can have optional members (see <a data-type="xref" href="#calibre_link-55" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œOptional Protocol Membersâ€</a>).<a data-type="indexterm" data-primary="methods" data-secondary="optional" id="calibre_link-1345" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="optional methods" id="calibre_link-1591" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The UIApplicationDelegate protocol method <code class="calibre19">application(_:didFinishLaunchingWithOptions:)</code> is a case in point; itâ€™s optional. But how, in practice, is an optional member feasible? We know that if a message is sent to an object and the object canâ€™t handle that message, an exception is raised and your app will likely crash.
How does Objective-C prevent that from happening?<a data-type="indexterm" data-primary="protocols" data-secondary="optional members" id="calibre_link-1813" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The answer is that Objective-C is both dynamic and introspective. Objective-C can ask an object whether it can deal with a message without actually sending it that message. The key method here is NSObjectâ€™s <code class="calibre19">responds(to:)</code> method (Objective-C <code class="calibre19">respondsToSelector:</code>), which takes a selector parameter (see <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>) and returns a Bool. Thus it is possible to send a message to an object <em class="calibre11">conditionally</em> &mdash; that is, only if it would be safe to do so.<a data-type="indexterm" data-primary="responds" id="calibre_link-1916" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="introspection" id="calibre_link-1158" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="messages" data-secondary="sending optionally" id="calibre_link-1325" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="optional message sending" id="calibre_link-1589" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Demonstrating <code class="calibre19">responds(to:)</code> in Swift is generally a little tricky, because Swift, with its strict type checking, doesnâ€™t want to let us send an object a message to which it might not respond. In this artificial example, I start by defining, at top level, a class that derives from NSObject, because otherwise we canâ€™t send <code class="calibre19">responds(to:)</code> to it, along with an <code class="calibre19">@objc</code> protocol to declare the message that I want to send conditionally:</p>

<pre data-type="programlisting" class="calibre28">class MyClass : NSObject {
}
@objc protocol Dummy {
    func woohoo()
}</pre>

<p class="author1">Now I can say this:</p>

<pre data-type="programlisting" class="calibre28">let mc = MyClass()
if mc.responds(to: #selector(Dummy.woohoo)) {
    (mc as AnyObject).woohoo()
}</pre>

<p class="author1">Note the cast of <code class="calibre19">mc</code> to AnyObject. This causes Swift to abandon its strict type checking (see <a data-type="xref" href="#calibre_link-57" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œSuppressing type checkingâ€</a>); we can now send this object any message that Swift knows about, provided it is susceptible to Objective-C introspection &mdash; thatâ€™s why I marked my protocol declaration as <code class="calibre19">@objc</code> to start with. As you know, Swift provides a shorthand for sending a message conditionally &mdash; append a question mark to the name of the message. I could have written this:</p>

<pre data-type="programlisting" class="calibre28">let mc = MyClass()
(mc as AnyObject).woohoo?()</pre>

<p class="author1">Behind the scenes, those two approaches are exactly the same; the latter is syntactic sugar for the former. In response to the question mark, Swift is calling <code class="calibre19">responds(to:)</code> for us, and will refrain from sending <code class="calibre19">woohoo</code> to this object if it <em class="calibre11">doesnâ€™t</em> respond to this selector.</p>

<p class="author1">That explains also how optional protocol members work. It is no coincidence that Swift treats optional protocol members like AnyObject members. Hereâ€™s the example I gave in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>:</p>

<pre data-type="programlisting" class="calibre28">@objc protocol Flier {
    @objc optional var song : String {get}
    @objc optional func sing()
}</pre>

<p class="author1">When you call <code class="calibre19">sing?()</code> on an object typed as Flier, <code class="calibre19">responds(to:)</code> is called behind the scenes to determine whether this call is safe. That is also why optional protocol members work only on <code class="calibre19">@objc</code> protocols and classes derived from NSObject: Swift is relying here on a purely Objective-C feature.</p>

<p class="author1">You wouldnâ€™t want to send a message optionally, or call <code class="calibre19">responds(to:)</code> explicitly, before sending just any old message, because it isnâ€™t generally necessary except with optional methods, and it slows things down a little. But Cocoa does in fact call <code class="calibre19">responds(to:)</code> on your objects as a matter of course. To see that this is true, implement <code class="calibre19">responds(to:)</code> on the AppDelegate class in our Empty Window project and instrument it with logging:</p>

<pre data-type="programlisting" class="calibre28">override func responds(to aSelector: Selector) -&gt; Bool {
    print(aSelector)
    return super.responds(to:aSelector)
}</pre>

<p class="author1">The output on my machine, as the Empty Window app launches, includes the <span class="publishername">following:</span></p>

<pre data-type="programlisting" class="calibre28">application:handleOpenURL:
application:openURL:sourceApplication:annotation:
application:openURL:options:
applicationDidReceiveMemoryWarning:
applicationWillTerminate:
applicationSignificantTimeChange:
application:willChangeStatusBarOrientation:duration:
application:didChangeStatusBarOrientation:
application:willChangeStatusBarFrame:
application:didChangeStatusBarFrame:
application:deviceAccelerated:
application:deviceChangedOrientation:
applicationDidBecomeActive:
applicationWillResignActive:
applicationDidEnterBackground:
applicationWillEnterForeground:
applicationWillSuspend:
application:didResumeWithOptions:
application:shouldSaveApplicationState:
application:supportedInterfaceOrientationsForWindow:
application:defaultWhitePointAdaptivityStyleForWindow:
application:configurationForConnectingSceneSession:options:
application:didDiscardSceneSessions:
application:performFetchWithCompletionHandler:
application:didReceiveRemoteNotification:fetchCompletionHandler:
application:didFinishLaunchingSuspendedWithOptions:
application:willFinishLaunchingWithOptions:
application:didFinishLaunchingWithOptions:</pre>

<p class="author1">Thatâ€™s Cocoa, checking to see which optional UIApplicationDelegate protocol methods
are actually implemented by our AppDelegate instance.
Cocoa checks all the optional protocol methods once, when it first meets the object in question, and presumably stores the results; thus, the app is slowed a tiny bit by this one-time initial bombardment of <code class="calibre19">responds(to:)</code> calls, but now Cocoa knows all the answers and wonâ€™t have to perform any of these same checks on the same object later.
The entire pattern of a delegate with optional delegate members depends upon this technique.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Informal Protocols" class="calibre2"><div class="preface" id="calibre_link-2646">
<h2 class="calibre42">Informal Protocols</h2>

<p class="author1">You may occasionally see, online or in the Cocoa documentation, a reference to an <em class="calibre11">informal protocol</em>. An informal protocol isnâ€™t really a protocol at all; itâ€™s just an Objective-C trick for providing the compiler with a knowledge of a method name so that it will allow a message to be sent without complaining.<a data-type="indexterm" data-primary="informal protocols" id="calibre_link-1064" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="protocols" data-secondary="informal" id="calibre_link-1808" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">There are two complementary ways to implement an informal protocol. One is to define a category on NSObject; this makes any object eligible to receive the messages listed in the category. The other is to define a protocol to which no class formally conforms; instead, messages listed in the protocol are sent only to objects typed as <code class="calibre19">id</code> (AnyObject), thus suppressing any objections from the compiler.</p>

<p class="author1">These techniques were widespread in Cocoa before Objective-C protocols could declare methods as optional; now they are largely unnecessary, and are also mildly dangerous. Nowadays, very few informal protocols remain, but they do exist. For example, NSKeyValueCoding (discussed later in this chapter) is an informal protocol; you may see the term NSKeyValueCoding in the documentation and elsewhere, but there isnâ€™t actually any such type &mdash; itâ€™s a category on NSObject.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Some Foundation Classes" class="calibre2"><div class="preface" id="calibre_link-2647">
<h1 class="calibre18">Some Foundation Classes</h1>

<p class="author1">The Foundation classes of Cocoa provide basic data types and utilities that will form the basis of your communication with Cocoa.<a data-type="indexterm" data-primary="Foundation framework" id="calibre_link-888" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
In this section, Iâ€™ll survey those that youâ€™ll probably want to be aware of initially.
For more information, start with Appleâ€™s list of the Foundation classes in the Foundation framework documentation page.<a data-type="indexterm" data-primary="Cocoa" data-secondary="Foundation classes" id="calibre_link-417" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bridged types" id="calibre_link-276" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In many situations, you can use Foundation classes implicitly by way of Swift classes. Thatâ€™s because of Swiftâ€™s ability to <em class="calibre11">bridge</em> between its own classes and those of Foundation. For example, String is bridged to NSString (<a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>), and Array is bridged to NSArray (<a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>). Thus, a String and an NSString can be cast to one another, and an Array and an NSArray can be cast to one another. But in fact youâ€™ll rarely need to cast, because wherever the Objective-C API expects you to pass an NSString or an NSArray, these will be typed in the Swift translation of that API as a String or an Array.
And when you use String or Array in the presence of Foundation, many NSString and NSArray properties and methods spring to life.</p>

<p class="author1">The Swift Foundation â€œoverlayâ€ puts a native Swift interface in front of many other Foundation types. The Swift interface is distinguished by dropping the â€œNSâ€ prefix that marks Foundation class names; for example, Objective-C NSData is accessed through Swift Data, and Objective-C NSDate is accessed through Swift Date &mdash; though you can still use NSData and NSDate directly if you really want to. Again, the Swift and Objective-C types are bridged to one another, and the API shows the Swift type, so casting and passing works as you would expect. The Swift types provide many conveniences that the Objective-C types do not; for example, they may declare adoption of appropriate Swift protocols such as Equatable, Hashable, and Comparable, and, in some cases, they may be value types (structs) where the Objective-C types are reference types (classes).<a data-type="indexterm" data-primary="bridged types" data-secondary="Foundation" id="calibre_link-292" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Swift overlay (Foundation)" id="calibre_link-2172" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="overlay, Swift" id="calibre_link-1646" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">There are two kinds of bridging to be distinguished here. String and Array are native Swift types, with an independent existence. Date and Data, on the other hand, arenâ€™t native Swift types; they are faÃ§ades for NSDate and NSData, meaning that you cannot use them except in the presence of Cocoaâ€™s Foundation framework.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="NSRange" class="calibre2"><div class="preface" id="calibre_link-2648">
<h2 class="calibre42">NSRange</h2>

<p class="author1">NSRange is a C struct (see <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>).<a data-type="indexterm" data-primary="NSRange" id="calibre_link-1466" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Its components are integers, <code class="calibre19">location</code> and <code class="calibre19">length</code>. For example, an NSRange whose <code class="calibre19">location</code> is <code class="calibre19">1</code> starts at the second element of something (because element counting is always zero-based), and if its <code class="calibre19">length</code> is <code class="calibre19">2</code> it designates this element and the next.</p>

<p class="author1">A Swift Range and a Cocoa NSRange are constructed very differently from one another. A Swift Range is defined by two endpoints. A Cocoa NSRange is defined by a starting point and a length. Nevertheless, Swift goes to some lengths (in the Foundation overlay) to help you work with an NSRange:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">NSRange is endowed with Range-like members such as <code class="calibre19">lowerBound</code>, <code class="calibre19">upperBound</code>, and <code class="calibre19">contains(_:)</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">You can coerce a Swift Range whose Bound type (the type of its endpoints) is Int (or any other integer type) to an NSRange.</p>
</li>
<li class="calibre12">
<p class="calibre17">You can coerce from an NSRange to a Swift Range &mdash; resulting in an Optional wrapping a Range, for reasons Iâ€™ll explain in a moment.</p>
</li>
</ul>

<p class="author1">For example:<a data-type="indexterm" data-primary="coercion" data-secondary="Range and NSRange" id="calibre_link-451" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="ranges" data-secondary="coercion to NSRange" id="calibre_link-1841" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// Range to NSRange
let r = 2..&lt;4
let nsr = NSRange(r) // (2,2), an NSRange
// NSRange to Range
let nsr2 = NSRange(location: 2, length: 2)
let r2 = Range(nsr2) // Optional wrapping Range 2..&lt;4</pre>

<p class="author1">But what about strings? A Swift Stringâ€™s range Bound type is <em class="calibre11">not</em> Int; it is <span class="publishername">String.Index</span>. Meanwhile, on the Cocoa side, an NSString still uses an NSRange whose components are integers. Not only is there a type mismatch, thereâ€™s also a value mismatch, because (as I explained in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>) a String is indexed on its characters, meaning its graphemes, but an NSString is indexed on its Unicode codepoints.<a data-type="indexterm" data-primary="ranges" data-secondary="string" id="calibre_link-1852" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="range" id="calibre_link-2112" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Sometimes, Swift will solve the problem by crossing the bridge for you in both directions; hereâ€™s an example Iâ€™ve already used:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let range = s.range(of:"ell") // Optional wrapping Range 1..&lt;4</pre>

<p class="author1">The <code class="calibre19">range(of:)</code> method in that code is actually a Cocoa method. Swift has cast the String <code class="calibre19">s</code> to an NSString for us, called a Foundation method that returns an NSRange, and coerced the NSRange to a Swift Range (wrapped in an Optional), adjusting its value as needed, entirely behind the scenes.</p>

<p class="author1">On other occasions, you will want to perform that coercion explicitly. For this purpose, Range has an initializer <code class="calibre19">init(_:in:)</code>, taking an NSRange and the String to which the resulting range is to apply:</p>

<pre data-type="programlisting" class="calibre28">let range = NSRange(location: 1, length: 3)
let r = Range(range, in:"hello") // Optional wrapping 1..&lt;4 of String.Index</pre>

<p class="author1">And NSRange has the converse initializer <code class="calibre19">init(_:in:)</code>, taking a Range of <span class="publishername">String.Index</span> and the String to which it applies:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let range = NSRange(s.range(of:"ell")!, in: s) // (1,3), an NSRange</pre>

<p class="author1">Sometimes, however, you actively <em class="calibre11">want</em> to operate in the Cocoa Foundation world, <em class="calibre11">without</em> bridging back to Swift. You can do that by casting:</p>

<pre data-type="programlisting" class="calibre28">let s = "Hello"
let r = (s as NSString).range(of: "ell")
let mas = NSMutableAttributedString(string:s)
mas.addAttributes([.foregroundColor:UIColor.red], range: r)</pre>

<p class="author1">In that code, we cast a String to an NSString so as to be able to call NSStringâ€™s <code class="calibre19">range(of:)</code> and get an NSRange, because that is what NSMutableAttributedStringâ€™s <code class="calibre19">addAttributes(_:range:)</code> wants as its second parameter. It would be wasteful to call <code class="calibre19">range(of:)</code> on a Swift String, which crosses into the Foundation world, gets the range, and brings it back to the Swift world, only to convert it back to an NSRange <em class="calibre11">again.</em></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSNotFound" class="calibre2"><div class="preface" id="calibre_link-2649">
<h2 class="calibre42">NSNotFound</h2>

<p class="author1"><code class="calibre19">NSNotFound</code> is a constant integer indicating that some requested element was not found.<a data-type="indexterm" data-primary="NSNotFound" id="calibre_link-1454" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The true numeric value of <code class="calibre19">NSNotFound</code> is of no concern; you always compare against <code class="calibre19">NSNotFound</code> itself to learn whether a result is meaningful. For example, if you ask for the index of a certain object in an NSArray and the object isnâ€™t present, the result is <code class="calibre19">NSNotFound</code>:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["hey"] as NSArray
let ix = arr.index(of:"ho")
if ix == NSNotFound {
    print("it wasn't found")
}</pre>

<p class="author1">Why does Cocoa resort to an integer value with a special meaning in this way? Because it has to. The result could not be <code class="calibre19">0</code> to indicate the absence of the object, because <code class="calibre19">0</code> would indicate the first element of the array. Nor could it be <code class="calibre19">-1</code>, because an NSArray index value is always positive. Nor could it be <code class="calibre19">nil</code>, because Objective-C canâ€™t return <code class="calibre19">nil</code> when an integer is expected (and even if it could, it would be seen as another way of saying <code class="calibre19">0</code>). Contrast Swift, whose Array <code class="calibre19">firstIndex(of:)</code> method returns an Int wrapped in an Optional, so that it <em class="calibre11">can</em> return <code class="calibre19">nil</code> to indicate that the target object wasnâ€™t found.</p>

<p class="author1">If a search returns an NSRange and the thing sought is not present, the <code class="calibre19">location</code> component of the result will be <code class="calibre19">NSNotFound</code>. This means that, when you turn an NSRange into a Swift Range, the NSRangeâ€™s <code class="calibre19">location</code> might be <code class="calibre19">NSNotFound</code>, and Swift needs to be able to express that as a <code class="calibre19">nil</code> Range. Thatâ€™s why the initializers for coercing an NSRange to a Range are failable. It is also why, when you call NSStringâ€™s <code class="calibre19">range(of:)</code> method on a Swift String, the result is an Optional:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let r = s.range(of:"ha") // nil; an Optional wrapping a Swift Range</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSString and Friends" class="calibre2"><div class="preface" id="calibre_link-2650">
<h2 class="calibre42">NSString and Friends</h2>

<p class="author1">NSString<a data-type="indexterm" data-primary="NSString" id="calibre_link-1470" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is the Cocoa object version of a string. NSString and Swift String are bridged to one another, and you will often move between them without thinking, passing a Swift String to Cocoa, calling Cocoa NSString methods on a Swift String, and so forth:<a data-type="indexterm" data-primary="bridged types" data-secondary="String and NSString" id="calibre_link-297" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = s.capitalized</pre>

<p class="author1">In that code, <code class="calibre19">s</code> is a Swift String and <code class="calibre19">s2</code> is a Swift String, but the <code class="calibre19">capitalized</code> property actually belongs to Cocoa. In the course of that code, a Swift String has been bridged to NSString and passed to Cocoa, which has processed it to get the capitalized string; the capitalized string is an NSString, but it has been bridged back to a Swift String. In all likelihood, you are not conscious of the bridging; <code class="calibre19">capitalized</code> feels like a native String property, but it isnâ€™t &mdash; as you can readily prove by trying to use it in an environment where Foundation is not imported.</p>

<p class="author1">In some cases, Swift may fail to cross the bridge implicitly for you, and you will need to cast explicitly. For example, if <code class="calibre19">s</code> is a Swift string, you canâ€™t call <code class="calibre19">appendingPathExtension</code> on it directly:</p>

<pre data-type="programlisting" class="calibre28">let s = "MyFile"
let s2 = s.appendingPathExtension("txt") // compile error</pre>

<p class="author1">You have to cast explicitly to NSString:</p>

<pre data-type="programlisting" class="calibre28">let s2 = (s as NSString).appendingPathExtension("txt")</pre>

<p class="author1">Similarly, to use NSStringâ€™s <code class="calibre19">substring(to:)</code>, you must cast the String to an NSString beforehand:</p>

<pre data-type="programlisting" class="calibre28">let s2 = (s as NSString).substring(to:4)</pre>

<p class="author1">In this situation, however, we can stay entirely within the Swift world by calling <code class="calibre19">prefix</code>, which is a native Swift method, not a Foundation method; delightfully, it takes an Int, not a <span class="publishername">String.Index</span>:</p>

<pre data-type="programlisting" class="calibre28">let s2 = s.prefix(4)</pre>

<p class="author1">However, those two calls are not equivalent: they can give different answers! The reason is that String and NSString have fundamentally different notions of what constitutes an element of a string (see <a data-type="xref" href="#calibre_link-59" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œThe String&ndash;NSString Element Mismatchâ€</a>). A String must resolve its elements into characters, which means that it must walk the string, coalescing any combining codepoints; an NSString behaves as if it were an array of UTF-16 codepoints. On the Swift side, each increment in a <span class="publishername">String.Index</span> corresponds to a true character, but access by index or range requires walking the string; on the Cocoa side, access by index or range is extremely fast, but might not correspond to character boundaries. (See the â€œCharacters and Grapheme Clustersâ€ chapter of Appleâ€™s <em class="calibre11">String Programming Guide</em> in the documentation archive.)</p>

<p class="author1">Another important difference between a Swift String and a Cocoa NSString is that an NSString is immutable. This means that, with NSString, you can do things such as obtain a new string based on the first &mdash; as <code class="calibre19">capitalized</code> and <code class="calibre19">substring(to:)</code> do &mdash; but you canâ€™t change the string <em class="calibre11">in place</em>. To do that, you need another class, a subclass of NSString, NSMutableString<a data-type="indexterm" data-primary="NSMutableString" id="calibre_link-1453" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. Swift String isnâ€™t bridged to NSMutableString, so you canâ€™t get from String to NSMutableString merely by casting. To obtain an NSMutableString, youâ€™ll have to make one. The simplest way is with NSMutableStringâ€™s initializer <code class="calibre19">init(string:)</code>, which expects an NSString &mdash; meaning that you can pass a Swift String. Coming back the other way, you can cast all the way from NSMutableString to a Swift String in one move, because an NSMutableString is an NSString:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let ms = NSMutableString(string:s)
ms.deleteCharacters(in:NSRange(location: ms.length-1, length:1))
let s2 = (ms as String) + "ion" // now s2 is a Swift String, "hellion"</pre>

<p class="author1">As I said in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>, native Swift String methods are thin on the ground. All the real string-processing power lives over on the Cocoa side of the bridge. So youâ€™re going to be crossing that bridge a lot! And this will not be only for the power of the NSString and NSMutableString classes. Many other useful classes are associated with them. Suppose you want to search a string for some substring; all the best ways come from Cocoa:<a data-type="indexterm" data-primary="strings" data-secondary="substrings" id="calibre_link-2116" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">An NSString can be searched using various <code class="calibre19">range</code> methods, with numerous options such as ignoring diacriticals, ignoring case, and searching backwards.</p>
</li>
<li class="calibre12">
<p class="calibre17">Perhaps you donâ€™t know exactly what youâ€™re looking for: you need to describe it structurally. A Scanner<a data-type="indexterm" data-primary="Scanner" id="calibre_link-1947" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSScanner) lets you walk through a string looking for pieces that fit certain criteria; for example, with Scanner (and CharacterSet, Objective-C NSCharacterSet) you can skip past everything in a string that precedes a number and then extract the number.</p>
</li>
<li class="calibre12">
<p class="calibre17">By specifying the <code class="calibre19">.regularExpression</code> search option, you can search using a regular expression<a data-type="indexterm" data-primary="regular expressions" id="calibre_link-1885" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. Regular expressions are also supported as a separate class, NSRegularExpression<a data-type="indexterm" data-primary="NSRegularExpression" id="calibre_link-1467" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, which in turn uses NSTextCheckingResult to describe match results.</p>
</li>
<li class="calibre12">
<p class="calibre17">More sophisticated automated textual analysis is supported by some additional classes, such as NSDataDetector, an NSRegularExpression subclass that efficiently finds certain types of string expression such as a URL or a phone number.</p>
</li>
</ul>

<p class="author1">In this example, our goal is to replace all occurrences of the word â€œhellâ€ with the word â€œheaven.â€ We donâ€™t want to replace mere occurrences of the <em class="calibre11">substring</em> â€œhellâ€ &mdash; for example, â€œhelloâ€ should be left intact. Thus our search needs some intelligence as to what constitutes a word boundary. That sounds like a job for a regular expression. Swift doesnâ€™t have regular expressions, so the work has to be done by Cocoa:</p>

<pre data-type="programlisting" class="calibre28">var s = "hello world, go to hell"
let r = try! NSRegularExpression(
    pattern: #"\bhell\b"#,
    options: .caseInsensitive)
s = r.stringByReplacingMatches(
    in: s,
    range: NSRange(s.startIndex..., in:s),
    withTemplate: "heaven")
// s is "hello world, go to heaven"</pre>

<p class="author1">NSString also has convenience utilities for working with a file path string, and is often used in conjunction with URL (Objective-C NSURL), which is another Foundation type worth looking into, along with its companion types, URLComponents (Objective-C NSURLComponents) and URLQueryItem (Objective-C <span class="publishername">NSURLQueryItem</span>). In addition, NSString &mdash; like some other classes discussed in this section &mdash; provides methods for writing out to a fileâ€™s contents or reading in a fileâ€™s contents; the file can be specified either as a string file path or as a URL.<a data-type="indexterm" data-primary="URL" id="calibre_link-2301" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">An NSString carries no font and size information. Interface objects that display strings (such as UILabel) have a <code class="calibre19">font</code> property that is a UIFont; but this determines the <em class="calibre11">single</em> font and size in which the string will display. If you want styled text &mdash; where different runs of text have different style attributes (size, font, color, and so forth) &mdash; you need to use NSAttributedString<a data-type="indexterm" data-primary="NSAttributedString" id="calibre_link-1431" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, along with its supporting classes NSMutableAttributedString, NSParagraphStyle, and NSMutableParagraphStyle. These allow you to style text and paragraphs easily in sophisticated ways. The built-in interface objects that display text can display an attributed string.<a data-type="indexterm" data-primary="font" id="calibre_link-880" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="text, styled" id="calibre_link-2211" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="styled text" id="calibre_link-2133" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">String drawing in a graphics context can be performed with methods provided through the NSStringDrawing category on NSString and on NSAttributedString.<a data-type="indexterm" data-primary="text, drawing" id="calibre_link-2210" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="drawing text" id="calibre_link-711" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSDate and Friends" class="calibre2"><div class="preface" id="calibre_link-2651">
<h2 class="calibre42">NSDate and Friends</h2>

<p class="author1">A Date<a data-type="indexterm" data-primary="Date" id="calibre_link-602" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSDate) is a date and time, represented internally as a number of seconds since some reference date.<a data-type="indexterm" data-primary="dates" id="calibre_link-606" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="times" id="calibre_link-2218" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Calling Dateâ€™s initializer <code class="calibre19">init()</code> &mdash; that is, saying <code class="calibre19">Date()</code> &mdash; gives you a Date object for the current date and time. Many date operations will also involve the use of DateComponents (Objective-C NSDateComponents), and conversions between Date and DateComponents<a data-type="indexterm" data-primary="DateComponents" id="calibre_link-603" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> require use of a Calendar<a data-type="indexterm" data-primary="Calendar" id="calibre_link-326" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSCalendar). Hereâ€™s an example of constructing a date based on its calendrical values:</p>

<pre data-type="programlisting" class="calibre28">let greg = Calendar(identifier:.gregorian)
let comp = DateComponents(calendar: greg,
    year: 2019, month: 8, day: 10, hour: 15)
let d = comp.date // Optional wrapping Date</pre>

<p class="author1">Similarly, DateComponents provides the correct way to do date arithmetic. Hereâ€™s how to add one month to a given date:</p>

<pre data-type="programlisting" class="calibre28">let d = Date() // or whatever
let comp = DateComponents(month:1)
let greg = Calendar(identifier:.gregorian)
let d2 = greg.date(byAdding: comp, to:d) // Optional wrapping Date</pre>

<p class="author1">Because a Date is essentially a wrapper for a TimeInterval (a Double), Swift can overload the arithmetic operators so that you can do arithmetic directly on a Date:</p>

<pre data-type="programlisting" class="calibre28">let d = Date()
let d2 = d + 4 // 4 seconds later</pre>

<p class="author1">You can express the range between two dates as a DateInterval (Objective-C <span class="publishername">NSDateInterval</span>). DateIntervals can be compared, intersected, and checked for containment:<a data-type="indexterm" data-primary="DateInterval" id="calibre_link-605" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let greg = Calendar(identifier:.gregorian)
let d1 = DateComponents(calendar: greg,
    year: 2019, month: 1, day: 1, hour: 0).date!
let d2 = DateComponents(calendar: greg,
    year: 2019, month: 8, day: 10, hour: 15).date!
let di = DateInterval(start: d1, end: d2)
if di.contains(Date()) { // are we currently between those two dates?</pre>

<p class="author1">You will also likely be concerned with dates represented as strings. If you donâ€™t take explicit charge of a dateâ€™s string representation, it is represented by a string whose format may surprise you. For example, if you simply <code class="calibre19">print</code> a Date, you are shown the date in the GMT timezone, which can be confusing if that isnâ€™t where you live. A simple solution when youâ€™re just logging to the console is to call <code class="calibre19">description(with:)</code>, whose parameter is a Locale<a data-type="indexterm" data-primary="Locale" id="calibre_link-1245" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSLocale) comprising the userâ€™s current time zone, language, region format, and calendar settings:</p>

<pre data-type="programlisting" class="calibre28">print(d)
// 2019-08-10 22:00:00 +0000
print(d.description(with:Locale.current))
// Saturday, August 10, 2019 at 3:00:00 PM Pacific Daylight Time</pre>

<p class="author1">For full control over date strings, especially when presenting them to the user, use DateFormatter<a data-type="indexterm" data-primary="DateFormatter" id="calibre_link-604" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSDateFormatter), which takes a format string describing how the date string is laid out:</p>

<pre data-type="programlisting" class="calibre28">let df = DateFormatter()
df.dateFormat = "M/d/y"
let s = df.string(from: Date())
// 7/9/2019</pre>

<p class="author1">DateFormatter knows how to make a date string that conforms to the userâ€™s local conventions. In this example, we call the class method <code class="calibre19">dateFormat(fromTemplate:options:locale:)</code> with the current locale as configured on the userâ€™s device. The <code class="calibre19">template:</code> is a string listing the date components to be used, but their order, punctuation, and language are left up to the locale:</p>

<pre data-type="programlisting" class="calibre28">let df = DateFormatter()
let format = DateFormatter.dateFormat(
    fromTemplate:"dMMMMyyyyhmmaz", options:0,
    locale:Locale.current)
df.dateFormat = format
let s = df.string(from:Date())</pre>

<p class="author1">The result is that the date is shown in the userâ€™s time zone and language, using the correct linguistic conventions. That involves a combination of region format and language, which are two separate settings:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">On my device, the result might be â€œJuly 9, 2019, 12:34 PM PDT.â€</p>
</li>
<li class="calibre12">
<p class="calibre17">If I change my deviceâ€™s <em class="calibre11">region</em> to France, it might be â€œ9 July 2019 at 12:34 pm GMT-7.â€</p>
</li>
<li class="calibre12">
<p class="calibre17">If I also change my deviceâ€™s <em class="calibre11">language</em> to French, and if my app is localized for French, it might be â€œ9 juillet 2019 Ã  12:34 PM UTCâˆ’7.â€</p>
</li>
</ul>

<p class="author1">DateFormatter can also parse a date string into a Date &mdash; but be sure that the date format is correct. This attempt to parse a string will fail, because the date format doesnâ€™t match the way the string is constructed:</p>

<pre data-type="programlisting" class="calibre28">let df = DateFormatter()
df.locale = Locale(identifier: "en_US_POSIX")
df.dateFormat = "M/d/y"
let d = df.date(from: "31/7/2019") // nil; should have been "d/M/y"</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Setting the Locale to <code class="calibre19">"en_US_POSIX"</code> guarantees that we will override the deviceâ€™s settings. Forgetting to do this, and then wondering why parsing a string into a Date fails on some devices, is a common beginner error, particularly when you were expecting 12-hour vs. 24-hour time formatting.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSNumber" class="calibre2"><div class="preface" id="calibre_link-2652">
<h2 class="calibre42">NSNumber</h2>

<p class="author1">An NSNumber<a data-type="indexterm" data-primary="NSNumber" id="calibre_link-1456" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is an object that wraps a numeric value. The wrapped value can be any standard Objective-C numeric type (including BOOL, the Objective-C equivalent of Swift Bool).<a data-type="indexterm" data-primary="BOOL" id="calibre_link-267" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> In Swift, everything is an object &mdash; a number is a Struct instance &mdash; so it comes as a surprise to Swift users that NSNumber is needed. But an ordinary number in Objective-C is a scalar, not an object, so it cannot be used where an object is expected; and an object cannot be used where a number is expected. Thus, NSNumber solves an important problem for Objective-C, converting a number into an object and back again.</p>

<p class="author1">Swift does its best to shield you from having to deal directly with NSNumber. It bridges Swift numeric types to Objective-C in two different ways:<a data-type="indexterm" data-primary="bridged types" data-secondary="number and NSNumber" id="calibre_link-294" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="scalars" id="calibre_link-1945" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">As a scalar</dt>
<dd class="calibre16">
<p class="calibre17">If Objective-C expects an ordinary number, a Swift number is bridged to an ordinary number (a scalar):</p>

<pre data-type="programlisting" class="calibre28">UIView.animate(withDuration: 1,
    animations: whatToAnimate, completion: whatToDoLater)</pre>

<p class="calibre17">Objective-C <code class="calibre19">animateWithDuration:animations:completion:</code> takes a C double as its first parameter. The Swift numeric object that you supply as the first argument to <code class="calibre19">animate(withDuration:animations:completion:)</code> becomes a C <span class="publishername">double.</span></p>
</dd>
<dt class="calibre15">As an NSNumber</dt>
<dd class="calibre16">
<p class="calibre17">If Objective-C expects an object, a Swift numeric type is bridged to an NSNumber (including Bool, because NSNumber can wrap an Objective-C BOOL):</p>

<pre data-type="programlisting" class="calibre28">UserDefaults.standard.set(1, forKey:"Score")</pre>

<p class="calibre17">Objective-C <code class="calibre19">setObject:forKey:</code> takes an Objective-C object as its first parameter. The Swift numeric object that you supply as the first argument to <code class="calibre19">set(_:forKey:)</code> becomes an NSNumber.</p>
</dd>
</dl>

<p class="author1">Naturally, if you need to cross the bridge explicitly, you can. You can cast a Swift number to an NSNumber:</p>

<pre data-type="programlisting" class="calibre28">let n = 1 as NSNumber</pre>

<p class="author1">Coming back from Objective-C to Swift, an NSNumber (or an Any that is actually an NSNumber) can be unwrapped by casting it down to a numeric type &mdash; provided the wrapped numeric value matches the type. To illustrate, Iâ€™ll fetch the NSNumber that I created in UserDefaults by bridging a moment ago:</p>

<pre data-type="programlisting" class="calibre28">let n = UserDefaults.standard.value(forKey:"Score")
// n is an Optional&lt;Any&gt; containing an NSNumber
let i = n as! Int // legal
let d = n as! Double // legal</pre>

<p class="author1">An NSNumber object is just a wrapper and no more. It canâ€™t be used directly for numeric calculations; it isnâ€™t a number. It <em class="calibre11">wraps</em> a number. One way or another, if you want a number, you have to extract it from the NSNumber.</p>

<p class="author1">An NSNumber subclass, NSDecimalNumber, on the other hand, <em class="calibre11">can</em> be used in calculations, thanks to a bunch of arithmetic methods:<a data-type="indexterm" data-primary="NSDecimalNumber" id="calibre_link-1437" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let dec1 = 4.0 as NSDecimalNumber
let dec2 = 5.0 as NSDecimalNumber
let sum = dec1.adding(dec2) // 9.0</pre>

<p class="author1">Underlying NSDecimalNumber is the Decimal struct (Objective-C NSDecimal); it is an NSDecimalNumberâ€™s <code class="calibre19">decimalValue</code>. In Objective-C, NSDecimal comes with C functions that are faster than NSDecimalNumber methods. In Swift, things are even better, because the arithmetic operators are overloaded to allow you to do Decimal arithmetic; thus, you are likely to prefer working with Decimal rather than <span class="publishername">NSDecimalNumber</span>:<a data-type="indexterm" data-primary="Decimal" id="calibre_link-619" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let dec1 = Decimal(4.0)
let dec2 = Decimal(5.0)
let sum = dec1 + dec2</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSValue" class="calibre2"><div class="preface" id="calibre_link-2653">
<h2 class="calibre42">NSValue</h2>

<p class="author1">NSValue<a data-type="indexterm" data-primary="NSValue" id="calibre_link-1471" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is NSNumberâ€™s superclass. It is used for wrapping nonnumeric C values, such as C structs, where an object is expected. The problem being solved here is parallel to the problem solved by NSNumber: a Swift struct is an object, but a C struct is not, so a struct cannot be used in Objective-C where an object is expected, and <em class="calibre11">vice versa.</em><a data-type="indexterm" data-primary="structs" data-secondary="C structs" id="calibre_link-2123" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="C" data-secondary="structs" id="calibre_link-324" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Convenience methods provided through the NSValueUIGeometryExtensions category on NSValue allow easy wrapping and unwrapping of such common structs as CGPoint, CGSize, CGRect, CGAffineTransform, UIEdgeInsets, and <span class="publishername">UIOffset</span>:</p>

<pre data-type="programlisting" class="calibre28">let pt = self.oldButtonCenter // a CGPoint
let val = NSValue(cgPoint:pt)</pre>

<p class="author1">Additional categories allow easy wrapping and unwrapping of NSRange, <span class="publishername">CATransform3D</span>, CMTime, CMTimeMapping, CMTimeRange, MKCoordinate, and MKCoordinateSpan (and you are unlikely to need to store any other kind of C value in an NSValue, but if you do need to, you can).</p>

<p class="author1">But you will rarely need to deal with NSValue explicitly, because Swift will wrap any of those common structs in an NSValue for you as it crosses the bridge from Swift to Objective-C. Hereâ€™s an example from my own real-life code:<a data-type="indexterm" data-primary="structs" data-secondary="bridged to Objective-C classes" id="calibre_link-2121" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bridged types" data-secondary="struct and NSValue" id="calibre_link-298" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let pt = CGPoint(
    x: screenbounds.midX + r * cos(rads),
    y: screenbounds.midY + r * sin(rads)
)
// apply an animation of ourself to that point
let anim = CABasicAnimation(keyPath:"position")
anim.fromValue = self.position
anim.toValue = pt</pre>

<p class="author1">In that code, <code class="calibre19">self.position</code> and <code class="calibre19">pt</code> are both CGPoints. The CABasicAnimation properties <code class="calibre19">fromValue</code> and <code class="calibre19">toValue</code> need to be Objective-C objects (that is, class instances) so that Cocoa can obey them to perform the animation. It is therefore necessary to wrap <code class="calibre19">self.position</code> and <code class="calibre19">pt</code> as NSValue objects. But <em class="calibre11">you</em> donâ€™t have to do that; Swift wraps those CGPoints as NSValue objects for you, Cocoa is able to interpret and obey them, and the animation works correctly.</p>

<p class="author1">The same thing is true of an array of common structs. Again, animation is a case in point. If you assign an array of CGPoint to a CAKeyframeAnimationâ€™s <code class="calibre19">values</code> property, the animation will work properly, without your having to map the CGPoints to NSValues first. Thatâ€™s because Swift maps them for you as the array crosses the bridge.<a data-type="indexterm" data-primary="bridged types" data-secondary="array elements" id="calibre_link-286" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="bridging" id="calibre_link-181" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSData" class="calibre2"><div class="preface" id="calibre_link-2654">
<h2 class="calibre42">NSData</h2>

<p class="author1">Data<a data-type="indexterm" data-primary="Data" id="calibre_link-599" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSData) is a general sequence of bytes (UInt8); basically, itâ€™s just a buffer, a chunk of memory. In Objective-C, NSData is immutable; the mutable version is its subclass NSMutableData. In Swift, however, where Data is a bridged value type imposed in front of NSData, a Data object is mutable if it was declared with <code class="calibre19">var</code>, just like any other value type. Moreover, because a Data object represents a byte sequence, Swift makes it a Collection (and therefore a Sequence), causing Swift features such as enumeration with <code class="calibre19">for...in</code>, subscripting, and <code class="calibre19">append(_:)</code> to spring to life. Thus, although you can work with NSData and NSMutableData if you want to (by casting to cross the bridge), you are much more likely to prefer Data.</p>

<p class="author1">In practice, Data tends to arise in two main ways:</p>
<dl class="calibre14">
<dt class="calibre15">When downloading from the Internet</dt>
<dd class="calibre16">
<p class="calibre17">For example, URLSession (Objective-C NSURLSession) supplies whatever it retrieves from the Internet as Data. Transforming it from there into (letâ€™s say) a string, specifying the correct encoding, would then be up to you.<a data-type="indexterm" data-primary="NSKeyedArchiver" id="calibre_link-1443" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">When serializing an object</dt>
<dd class="calibre16">
<p class="calibre17">A typical use case is that youâ€™re storing an object as a file or in user preferences (UserDefaults). For example, you canâ€™t store a UIColor value directly into user preferences. So if the user has made a color choice and you need to save it, you transform the UIColor into a Data object (using NSKeyedArchiver) and save that:<a data-type="indexterm" data-primary="archive" data-secondary="object" id="calibre_link-172" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
let c = UIColor.blue
let cdata = try! NSKeyedArchiver.archivedData(
    withRootObject: c, requiringSecureCoding: true)
ud.set(cdata, forKey: "myColor")</pre>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSMeasurement and Friends" class="calibre2"><div class="preface" id="calibre_link-2655">
<h2 class="calibre42">NSMeasurement and Friends</h2>

<p class="author1">The Measurement type (Objective-C NSMeasurement) embodies the notion of a measurement by some unit (Unit, Objective-C NSUnit). A unit may be along some dimension that can be expressed in different units convertible to one another; by reducing values in different units of the same dimension to a base unit, a Measurement permits you to perform arithmetic operations and conversions.<a data-type="indexterm" data-primary="Measurement" id="calibre_link-1272" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Unit" id="calibre_link-2278" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The dimensions, which are all subclasses of the (abstract) Dimension class (Objective-C NSDimension, an NSUnit subclass), have names like UnitAngle and UnitLength (Objective-C NSUnitAngle, NSUnitLength), and have class properties vending an instance corresponding to a particular unit type; for example, UnitAngle has class properties <code class="calibre19">degrees</code> and <code class="calibre19">radians</code> and others, and UnitLength has class properties <code class="calibre19">miles</code> and <code class="calibre19">kilometers</code> and others.</p>

<p class="author1">To illustrate, Iâ€™ll add 5 miles to 6 kilometers:</p>

<pre data-type="programlisting" class="calibre28">let m1 = Measurement(value:5, unit: UnitLength.miles)
let m2 = Measurement(value:6, unit: UnitLength.kilometers)
let total = m1 + m2</pre>

<p class="author1">The answer, <code class="calibre19">total</code>, is 14046.7 meters under the hood, because meters are the base unit of length. But it can be converted to any length unit:</p>

<pre data-type="programlisting" class="calibre28">let totalFeet = total.converted(to: .feet).value // 46084.9737532808</pre>

<p class="author1">If your goal is to output a measurement as a user-facing string, use a MeasurementFormatter<a data-type="indexterm" data-primary="MeasurementFormatter" id="calibre_link-1273" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSMeasurementFormatter). Its behavior is locale-dependent by default, expressing the value and the units as the user would expect:</p>

<pre data-type="programlisting" class="calibre28">let mf = MeasurementFormatter()
let s = mf.string(from:total) // "8.728 mi"</pre>

<p class="author1">My code says nothing about miles, but the MeasurementFormatter outputs <code class="calibre19">"8.728 mi"</code> because my device is set to United States (region) and English (language). If my device is set to France (region) and French (language), the very same code outputs <code class="calibre19">"14,047 km"</code> &mdash; using the French decimal point notation and the French preferred unit of distance measurement.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Equality, Hashability, and Comparison" class="calibre2"><div class="preface" id="calibre_link-2656">
<h2 class="calibre42">Equality, Hashability, and Comparison</h2>

<p class="author1">In Swift, the equality and comparison operators can be overridden for an object type that adopts Equatable and Comparable (<a data-type="xref" href="#calibre_link-60" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œOperatorsâ€</a>). But Objective-C operators are applicable only to scalars. Objective-C therefore performs comparison of object instances in a special way, and it can be useful to know about this when working with Cocoa classes.<a data-type="indexterm" data-primary="equality" data-secondary="of Objective-C objects" id="calibre_link-770" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="equality" id="calibre_link-1519" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To permit determination of whether two objects are â€œequalâ€ &mdash; whatever that may mean for this object type &mdash; an Objective-C class must implement <code class="calibre19">isEqual(_:)</code>, which is inherited from NSObject. Swift will help out by treating NSObject as Equatable and by permitting the use of the <code class="calibre19">==</code> operator, implicitly converting it to an <code class="calibre19">isEqual(_:)</code> call. Thus, if a class derived from NSObject implements <code class="calibre19">isEqual(_:)</code>, ordinary Swift comparison will work.<a data-type="indexterm" data-primary="NSObject" data-secondary="equality" id="calibre_link-1461" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="isEqual" id="calibre_link-1166" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
If an NSObject subclass <em class="calibre11">doesnâ€™t</em> implement <code class="calibre19">isEqual(_:)</code>, it inherits NSObjectâ€™s implementation, which compares the two objects for identity (like Swiftâ€™s <code class="calibre19">===</code> operator).</p>

<p class="author1">For example, these two Dog objects can be compared with the <code class="calibre19">==</code> operator, even though Dog does not adopt Equatable, because they derive from NSObject. Dog doesnâ€™t implement <code class="calibre19">isEqual(_:)</code>, so <code class="calibre19">==</code> defaults to using NSObjectâ€™s identity <span class="publishername">comparison</span>:</p>

<pre data-type="programlisting" class="calibre28">class Dog : NSObject {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
}
let d1 = Dog(name:"Fido", license:1)
let d2 = Dog(name:"Fido", license:1)
let ok = d1 == d2 // false</pre>

<p class="author1">If we wanted two Dogs with the same <code class="calibre19">name</code> and <code class="calibre19">license</code> to be considered equal, weâ€™d need to implement <code class="calibre19">isEqual(_:)</code>, like this:</p>

<pre data-type="programlisting" class="calibre28">class Dog : NSObject {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    override func isEqual(_ object: Any?) -&gt; Bool {
        if let otherdog = object as? Dog {
            return (otherdog.name == self.name &amp;&amp;
                otherdog.license == self.license)
        }
        return false
    }
}
let d1 = Dog(name:"Fido", license:1)
let d2 = Dog(name:"Fido", license:1)
let ok = d1 == d2 // true</pre>

<p class="author1">At this point, you might be saying (thinking of <a data-type="xref" href="#calibre_link-61" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œSynthesized Protocol Implementationsâ€</a>): â€œBut wait, why donâ€™t you just declare Dog to adopt Equatable and get autosynthesis of equatability based on its properties?â€ But you canâ€™t do that. Autosynthesis of Equatable conformance doesnâ€™t work for classes, and in any case Dog is <em class="calibre11">already</em> Equatable by virtue of being an NSObject subclass. Besides, Equatable is about how to implement <code class="calibre19">==</code>, whereas  what we need to implement here is <code class="calibre19">isEqual:</code>.</p>

<p class="author1">Foundation types implement <code class="calibre19">isEqual(_:)</code> in a sensible way, so Swift equatability works as you would expect. For example, NSNumber implements <code class="calibre19">isEqual(_:)</code> by comparing the underlying numbers; thus, you can use NSNumber where a Swift Equatable is expected, and, because a Swift number will be cast automatically to an NSNumber if needed, you can even compare an NSNumber to a Swift number:</p>

<pre data-type="programlisting" class="calibre28">let n1 = 1 as NSNumber
let n2 = 2 as NSNumber
let n3 = 3 as NSNumber
let ok = n2 == 2 // true
let ix = [n1,n2,n3].firstIndex(of:2) // Optional wrapping 1</pre>

<p class="author1">By the same token, for an NSObject subclass to work properly where hashability is required &mdash; as a dictionary key or a set member, even if this is a Swift Dictionary or Set &mdash; it must conform to the NSObject notion of hashability, namely, an implementation of <code class="calibre19">isEqual(_:)</code> plus a corresponding override of the NSObject <code class="calibre19">hash</code> property, meaning that two equal objects should have equal <code class="calibre19">hash</code> values. For example, if we wanted our Dog from the previous code to be usable in a Set, weâ€™d need to override <code class="calibre19">hash</code>; in the past, that was tricky to do correctly, but nowadays the Hasher struct (introduced in Swift 4.2) makes it easy:<a data-type="indexterm" data-primary="NSObject" data-secondary="hashability" id="calibre_link-1462" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Hasher" id="calibre_link-1005" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="hashability" id="calibre_link-1521" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hash" id="calibre_link-997" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" data-secondary="hashable elements" data-tertiary="NSObject" id="calibre_link-2010" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="hashability" data-secondary="of Objective-C objects" id="calibre_link-999" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class Dog : NSObject {
    var name : String
    var license : Int
    init(name:String, license:Int) {
        self.name = name
        self.license = license
    }
    override func isEqual(_ object: Any?) -&gt; Bool {
        if let otherdog = object as? Dog {
            return (otherdog.name == self.name &amp;&amp;
                otherdog.license == self.license)
        }
        return false
    }
    override var hash: Int {
        var h = Hasher()
        h.combine(self.name)
        h.combine(self.license)
        return h.finalize()
    }
}
var set = Set&lt;Dog&gt;()
set.insert(Dog(name:"Fido", license:1))
set.insert(Dog(name:"Fido", license:1))
print(set.count) // 1</pre>

<p class="author1">Foundation types come with a built-in <code class="calibre19">hash</code> implementation (and the Swift overlay types are all both Equatable and Hashable as well).</p>

<p class="author1">In Objective-C it is also up to individual classes to supply ordered comparison methods. The standard method is <code class="calibre19">compare(_:)</code>, which returns one of three cases of ComparisonResult<a data-type="indexterm" data-primary="ComparisonResult" id="calibre_link-492" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSComparisonResult):<a data-type="indexterm" data-primary="Objective-C" data-secondary="comparison" id="calibre_link-1518" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="compare" id="calibre_link-490" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="NSObject" data-secondary="comparison" id="calibre_link-1460" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">.orderedAscending</code></dt>
<dd class="calibre16">
<p class="calibre17">The receiver is less than the argument.</p>
</dd>
<dt class="calibre15"><code class="calibre19">.orderedSame</code></dt>
<dd class="calibre16">
<p class="calibre17">The receiver is equal to the argument.</p>
</dd>
<dt class="calibre15"><code class="calibre19">.orderedDescending</code></dt>
<dd class="calibre16">
<p class="calibre17">The receiver is greater than the argument.</p>
</dd>
</dl>

<p class="author1">Swift comparison operators (<code class="calibre19">&lt;</code> and so forth) do <em class="calibre11">not</em> magically call <code class="calibre19">compare(_:)</code> for you. You canâ€™t compare two NSNumber values directly:</p>

<pre data-type="programlisting" class="calibre28">let n1 = 1 as NSNumber
let n2 = 2 as NSNumber
let ok = n1 &lt; n2 // compile error</pre>

<p class="author1">You will typically fall back on calling <code class="calibre19">compare(_:)</code> yourself:</p>

<pre data-type="programlisting" class="calibre28">let n1 = 1 as NSNumber
let n2 = 2 as NSNumber
let ok = n1.compare(n2) == .orderedAscending // true</pre>

<p class="author1">On the other hand, a Swift Foundation overlay type <em class="calibre11">can</em> adopt Comparable, and now comparison operators <em class="calibre11">do</em> work. For example, you canâ€™t compare two NSDate values with <code class="calibre19">&lt;</code>, but you <em class="calibre11">can</em> compare two Date values.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSArray and NSMutableArray" class="calibre2"><div class="preface" id="calibre_link-2657">
<h2 class="calibre42">NSArray and NSMutableArray</h2>

<p class="author1">NSArray<a data-type="indexterm" data-primary="NSArray" id="calibre_link-1430" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is Objective-Câ€™s array object type. It is fundamentally similar to Swift Array, and they are bridged to one another; but NSArray elements must be objects (classes and class instances), and they donâ€™t have to be of a single type. For a full discussion of how to bridge back and forth between Swift Array and Objective-C NSArray, implicitly and by casting, see <a data-type="xref" href="#calibre_link-62" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œSwift Array and Objective-C NSArrayâ€</a>.<a data-type="indexterm" data-primary="bridged types" data-secondary="Array and NSArray" id="calibre_link-283" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="bridging" id="calibre_link-182" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">An NSArrayâ€™s length is its <code class="calibre19">count</code>, and an element can be obtained by index number using <code class="calibre19">object(at:)</code>. The index of the first element, as with a Swift Array, is zero, so the index of the last element is <code class="calibre19">count</code> minus one.</p>

<p class="author1">Instead of calling <code class="calibre19">object(at:)</code>, you can use subscripting with an NSArray. This is not because NSArray is bridged to Swift Array, but because NSArray implements an Objective-C method, <code class="calibre19">objectAtIndexedSubscript:</code>, which is the Objective-C equivalent of a Swift <code class="calibre19">subscript</code> getter. In fact, when you examine the NSArray header file translated into Swift, that method is shown as a <code class="calibre19">subscript</code> declaration!<a data-type="indexterm" data-primary="Objective-C" data-secondary="subscripts" id="calibre_link-1542" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subscripting" data-secondary="Objective-C" id="calibre_link-2149" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can seek an object within an array with <code class="calibre19">index(of:)</code> or <code class="calibre19">indexOfObjectIdentical(to:)</code>; the formerâ€™s idea of equality is to call <code class="calibre19">isEqual(_:)</code>, whereas the latter uses object identity (like Swiftâ€™s <code class="calibre19">===</code>). If the object is not found in the array, the result is <code class="calibre19">NSNotFound</code>.</p>

<p class="author1">Like an Objective-C NSString, an NSArray is immutable. This doesnâ€™t mean you canâ€™t mutate any of the objects it contains; it means that once the NSArray is formed you canâ€™t remove an object from it, insert an object into it, or replace an object at a given index. To do those things while staying in the Objective-C world, you can derive a new array consisting of the original array plus or minus some objects, or use <span class="publishername">NSArrayâ€™s</span> subclass, NSMutableArray<a data-type="indexterm" data-primary="NSMutableArray" id="calibre_link-1448" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>.</p>

<p class="author1">Swift Array is not bridged to NSMutableArray; if you want an NSMutableArray, you must create it. The simplest way is with the NSMutableArray initializers, <code class="calibre19">init()</code> or <code class="calibre19">init(array:)</code>. Once you have an NSMutableArray, you can call methods such as <code class="calibre19">insert(_:at:)</code> and <code class="calibre19">replaceObject(at:with:)</code>. You can also assign into an NSMutableArray using subscripting. Again, this is because NSMutableArray implements a special Objective-C method, <code class="calibre19">setObject:atIndexedSubscript:</code>; Swift recognizes this as equivalent to a <code class="calibre19">subscript</code> setter.</p>

<p class="author1">Coming back the other way, you can cast an NSMutableArray down to a Swift array:</p>

<pre data-type="programlisting" class="calibre28">let marr = NSMutableArray()
marr.add(1) // an NSNumber
marr.add(2) // an NSNumber
let arr = marr as NSArray as! [Int]</pre>

<p class="author1">Cocoa provides ways to sort an array, as well as to search or filter an array by passing a function. You might prefer to perform those kinds of operation in the Swift Array world, but it can be useful to know how to do them the Cocoa way:</p>

<pre data-type="programlisting" class="calibre28">let pep = ["Manny", "Moe", "Jack"] as NSArray
let ems = pep.objects(
    at: pep.indexesOfObjects { (obj, idx, stop) -&gt; Bool in
        return (obj as! NSString).range(
            of: "m", options:.caseInsensitive
            ).location == 0
    }
) // ["Manny", "Moe"]</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSDictionary and NSMutableDictionary" class="calibre2"><div class="preface" id="calibre_link-2658">
<h2 class="calibre42">NSDictionary and NSMutableDictionary</h2>

<p class="author1">NSDictionary<a data-type="indexterm" data-primary="NSDictionary" id="calibre_link-1439" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is Objective-Câ€™s dictionary object type. It is fundamentally similar to Swift Dictionary, and they are bridged to one another. But NSDictionary keys and values must be objects (classes and class instances), and they donâ€™t have to be of a single type; the keys must conform to NSCopying and must be hashable. See <a data-type="xref" href="#calibre_link-63" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œSwift Dictionary and Objective-C NSDictionaryâ€</a> for a full discussion of how to bridge back and forth between Swift Dictionary and Objective-C NSDictionary, including casting.</p>

<p class="author1">An NSDictionary is immutable; its mutable subclass is NSMutableDictionary<a data-type="indexterm" data-primary="NSMutableDictionary" id="calibre_link-1450" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. Swift Dictionary is not bridged to NSMutableDictionary; you can most easily make an NSMutableDictionary with an initializer, <code class="calibre19">init()</code> or <code class="calibre19">init(dictionary:)</code>, and you can cast an NSMutableDictionary down to a Swift Dictionary type.</p>

<p class="author1">The keys of an NSDictionary are distinct (using <code class="calibre19">isEqual(_:)</code> for comparison). If you add a key&ndash;value pair to an NSMutableDictionary, then if that key is not already present, the pair is simply added, but if the key is already present, then the corresponding value is replaced. This is parallel to the behavior of Swift Dictionary.</p>

<p class="author1">The fundamental use of an NSDictionary is to request an entryâ€™s value by key (using <code class="calibre19">object(forKey:)</code>); if no such key exists, the result is <code class="calibre19">nil</code>. In Objective-C, <code class="calibre19">nil</code> is not an object, and thus cannot be a value in an NSDictionary; the meaning of this response is thus unambiguous. Swift handles this by treating the result of <code class="calibre19">object(forKey:)</code> as an Optional wrapping an Any.</p>

<p class="author1">Subscripting is possible on an NSDictionary or an NSMutableDictionary, for similar reasons to an NSArray or an NSMutableArray. NSDictionary implements <code class="calibre19">objectForKeyedSubscript:</code>, and Swift understands this as equivalent to a <code class="calibre19">subscript</code> getter. In addition, NSMutableDictionary implements <code class="calibre19">setObject:forKeyedSubscript:</code>, and Swift understands this as equivalent to a <code class="calibre19">subscript</code> setter.</p>

<p class="author1">Like a Swift Dictionary, an NSDictionary is unordered. You can get from an NSDictionary a list of keys (<code class="calibre19">allKeys</code>), a list of values (<code class="calibre19">allValues</code>), or a list of keys sorted by value. You can also walk through the key&ndash;value pairs, and you can even filter an NSDictionary by a test against its values.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSSet and Friends" class="calibre2"><div class="preface" id="calibre_link-2659">
<h2 class="calibre42">NSSet and Friends</h2>

<p class="author1">An NSSet<a data-type="indexterm" data-primary="NSSet" id="calibre_link-1468" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> is an unordered collection of distinct objects. Swift Set is bridged to NSSet, and the Swift Foundation overlay even allows you to initialize an NSSet from a Swift array literal. But NSSet elements must be objects (classes and class instances), and they donâ€™t have to be of a single type. For details, see <a data-type="xref" href="#calibre_link-64" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œSwift Set and Objective-C NSSetâ€</a>.</p>

<p class="author1">â€œDistinctâ€ for an NSSet means that no two objects in a set can return <code class="calibre19">true</code> when they are compared using <code class="calibre19">isEqual(_:)</code>. Learning whether an object is present in a set is much more efficient than seeking it in an array (because a setâ€™s elements are hashable), and you can ask whether one set is a subset of, or intersects, another set. You can walk through (enumerate) a set with the <code class="calibre19">for...in</code> construct, though the order is of course undefined. You can filter a set, as you can an NSArray. Indeed, much of what you can do with a set is parallel to what you can do with an array, except that of course you canâ€™t do anything with a set that involves the notion of ordering.<a data-type="indexterm" data-primary="sets" id="calibre_link-2006" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To transcend that restriction, you can use an <em class="calibre11">ordered set</em>.<a data-type="indexterm" data-primary="NSOrderedSet" id="calibre_link-1464" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> An ordered set (NSOrderedSet) is very like an array, and the methods for working with it are similar to the methods for working with an array &mdash; you can even fetch an element by subscripting (because it implements <code class="calibre19">objectAtIndexedSubscript:</code>). But an ordered setâ€™s elements must be distinct. An ordered set provides many of the advantages of sets: for example, as with an NSSet, learning whether an object is present in an ordered set is much more efficient than for an array, and you can readily take the union, intersection, or difference with another set. Since the distinctness restriction will often prove no restriction at all (because the elements were going to be distinct anyway), it can be worthwhile to use NSOrderedSet instead of NSArray where possible.</p>

<p class="author1">An NSSet is immutable. You can derive one NSSet from another by adding or removing elements, or you can use its subclass, NSMutableSet<a data-type="indexterm" data-primary="NSMutableSet" id="calibre_link-1452" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. Similarly, NSOrderedSet has its mutable counterpart, NSMutableOrderedSet<a data-type="indexterm" data-primary="NSMutableOrderedSet" id="calibre_link-1451" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (which you can insert into by subscripting, because it implements <code class="calibre19">setObject:atIndexedSubscript:</code>). There is no penalty for adding to a set an object that the set already contains; nothing is added (and so the distinctness rule is enforced), but thereâ€™s no error.<a data-type="indexterm" data-startref="idxsubscriptingobjc2" id="calibre_link-2150" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxsubscriptingobjc" id="calibre_link-1543" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">NSCountedSet<a data-type="indexterm" data-primary="NSCountedSet" id="calibre_link-1436" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, a subclass of NSMutableSet, is a mutable unordered collection of objects that are <em class="calibre11">not</em> necessarily distinct (this concept is often referred to as a <em class="calibre11">bag</em>). It is implemented as a set plus a count of how many times each element has been added.<a data-type="indexterm" data-primary="bag" id="calibre_link-243" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">NSMutableSet, NSCountedSet, NSOrderedSet, and NSMutableOrderedSet are easily formed from a set or an array using an initializer.
Coming back the other way, you can cast an NSMutableSet or NSCountedSet down to a Swift Set (similar to an NSMutableArray).
Because of their special behaviors, however, you are much more likely to leave an NSCountedSet or NSOrderedSet in its Objective-C form for as long as youâ€™re working with it.<a data-type="indexterm" data-primary="bridged types" data-secondary="Set and NSSet" id="calibre_link-295" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Classes are reference types, so they can be referred to from multiple places and can be mutated in place. Mutating an object while it is inside a Set will effectively break the Set (lookup will cease to operate correctly).</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSIndexSet" class="calibre2"><div class="preface" id="calibre_link-2660">
<h2 class="calibre42">NSIndexSet</h2>

<p class="author1">IndexSet<a data-type="indexterm" data-primary="IndexSet" id="calibre_link-1055" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (Objective-C NSIndexSet) represents a collection of unique whole numbers; its purpose is to express element numbers of an ordered collection, such as an array. Thus, for instance, to retrieve multiple elements simultaneously from an NSArray, you specify the desired indexes as an IndexSet. It is also used with other things that are array-like; for example, you pass an IndexSet to a UITableView to indicate what sections to insert or delete.<a data-type="indexterm" data-primary="collections" data-secondary="Foundation" id="calibre_link-453" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="collections" id="calibre_link-1515" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">NSIndexSet is immutable; it has a mutable subclass, NSMutableIndexSet. But IndexSet is a value type, so it is mutable if the declaration uses <code class="calibre19">var</code>. And, as with other Swift types imposed in front of Foundation types, IndexSet gets to do all sorts of convenient Swift magic.  Comparison and arithmetic operators work directly with IndexSet values. Even more important, an IndexSet acts like a Set: it adopts the SetAlgebra protocol, and methods like <code class="calibre19">contains(_:)</code> and <code class="calibre19">intersection(_:)</code> spring to life. Thus you probably wonâ€™t need NSMutableIndexSet at all.</p>

<p class="author1">To take a specific example, letâ€™s say you want to speak of the elements at indexes 1, 2, 3, 4, 8, 9, and 10 of an array. IndexSet expresses this notion in some compact implementation that can be readily queried. The actual implementation is opaque, but you can imagine that this IndexSet might consist of two Ranges, <code class="calibre19">1...4</code> and <code class="calibre19">8...10</code>, and IndexSetâ€™s methods actually invite you to think of it as a Set of Ranges:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["zero", "one", "two", "three", "four", "five",
    "six", "seven", "eight", "nine", "ten"]
var ixs = IndexSet()
ixs.insert(integersIn: Range(1...4))
ixs.insert(integersIn: Range(8...10))
let arr2 = (arr as NSArray).objects(at:ixs)
// ["one", "two", "three", "four", "eight", "nine", "ten"]</pre>

<p class="author1">To walk through (enumerate) the index values specified by an IndexSet, you can use <code class="calibre19">for...in</code>; alternatively, you can walk through an IndexSetâ€™s indexes or ranges by calling various <code class="calibre19">enumerate</code> methods that let you pass a function returning a Bool.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="NSNull" class="calibre2"><div class="preface" id="calibre_link-2661">
<h2 class="calibre42">NSNull</h2>

<p class="author1">The NSNull<a data-type="indexterm" data-primary="NSNull" id="calibre_link-1455" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> class does nothing but supply a pointer to a singleton object, <code class="calibre19">NSNull()</code>. This singleton object is used to stand for <code class="calibre19">nil</code> in situations where an actual Objective-C object is required and <code class="calibre19">nil</code> is not permitted. For example, you canâ€™t use <code class="calibre19">nil</code> as the value of an element of an Objective-C collection (such as NSArray, NSDictionary, or NSSet), so youâ€™d use <code class="calibre19">NSNull()</code> instead.</p>

<p class="author1"><code class="calibre19">NSNull()</code> makes it possible for a Swift Array of Optional to be handed to Objective-C. The Swift Array might contain <code class="calibre19">nil</code>, which is illegal in Objective-C. But Swift will bridge the Array of Optional for you, as it crosses into Objective-C, by substituting <code class="calibre19">NSNull()</code> for any <code class="calibre19">nil</code> elements. And, coming back the other way, Swift will perform the inverse operation when you cast an NSArray down to an Array of Optional, substituting <code class="calibre19">nil</code> for any <code class="calibre19">NSNull()</code> elements.<a data-type="indexterm" data-primary="nil" data-secondary="in Objective-C collections" id="calibre_link-1406" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can test an object for equality against <code class="calibre19">NSNull()</code> using the ordinary equality operator (<code class="calibre19">==</code>), because it falls back on NSObjectâ€™s <code class="calibre19">isEqual(_:)</code>, which is identity comparison. This is a singleton instance, and therefore identity comparison works.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Immutable and Mutable" class="calibre2"><div class="preface" id="calibre_link-2662">
<h2 class="calibre42">Immutable and Mutable</h2>

<p class="author1">Cocoa Foundation has a pattern of class pairs where the superclass is immutable and the subclass is mutable; Iâ€™ve given many examples already, such as NSString and NSMutableString, or NSArray and NSMutableArray. This is similar to the Swift distinction between a constant (<code class="calibre19">let</code>) and a true variable (<code class="calibre19">var</code>). For example, an NSArray being immutable means that you canâ€™t append or insert into this array, or replace or delete an element of this array; but if its elements are reference types &mdash; and of course, for an NSArray, they <em class="calibre11">are</em> reference types &mdash; you can mutate an element in place. Thatâ€™s just like the behavior of a Swift Array referred to with <code class="calibre19">let</code>.<a data-type="indexterm" data-primary="immutable Objective-C classes" id="calibre_link-1041" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutable Objective-C classes" id="calibre_link-1364" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="immutable vs. mutable classes" id="calibre_link-1525" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The reason why Cocoa needs these immutable/mutable pairs is to prevent unauthorized mutation. An NSString object, say, is an ordinary class instance &mdash; a reference type. Thus, if NSString were mutable, an NSString property of a class could be mutated by some other object, behind this classâ€™s back. To prevent that from happening, a class will work internally and temporarily with a mutable instance, but then store and vend to other classes an immutable instance, thus protecting the value from being changed by anyone else. Swift doesnâ€™t face the same issue, because its fundamental built-in object types such as String, Array, and Dictionary are structs, and therefore are value types, which cannot be mutated in place; they can be changed only by being replaced, and that is something that can be guarded against, or detected through a setter observer. NSString isnâ€™t a value <em class="calibre11">type</em>, but as far as mutability is concerned, it displays value <em class="calibre11">semantics</em> (<a data-type="xref" href="#calibre_link-65" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œValue Types and Reference Typesâ€</a>).</p>

<p class="author1">The documentation may not make it completely obvious that the mutable classes obey and, if appropriate, override the methods of their immutable superclasses. For example, dozens of NSMutableArray methods are not listed on NSMutableArrayâ€™s class documentation page, because they are inherited from NSArray. And when such methods are inherited by the mutable subclass, they may be overridden to fit the mutable subclass. For example, NSArrayâ€™s <code class="calibre19">init(array:)</code> generates an immutable array, but NSMutableArrayâ€™s <code class="calibre19">init(array:)</code> &mdash; which isnâ€™t even listed on the NSMutableArray documentation page, because it is inherited from NSArray &mdash; generates a mutable array.<a data-type="indexterm" data-primary="documentation" data-secondary="immutable vs. mutable classes" id="calibre_link-697" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">That fact also answers the question of how to make an immutable array mutable, and <em class="calibre11">vice versa</em>.
This single method, <code class="calibre19">init(array:)</code>, can transform an array between immutable and mutable in either direction. You can also use <code class="calibre19">copy</code> (produces an immutable copy) and <code class="calibre19">mutableCopy</code> (produces a mutable copy), both inherited from NSObject; but these are not as convenient because they yield an Any which must then be cast.<a data-type="indexterm" data-startref="idxobjectiveccollections" id="calibre_link-1516" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-startref="idxcollectionsfoundation" id="calibre_link-454" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">These immutable/mutable class pairs are all implemented as <em class="calibre11">class clusters</em>, which means that Cocoa uses a secret class, different from the documented class you work with.<a data-type="indexterm" data-primary="class" data-secondary="clusters" id="calibre_link-360" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> You may discover this by peeking under the hood; for example, an NSString might be characterized as an NSTaggedPointerString or an NSCFString. You should not spend any time wondering about this secret class. It is subject to change without notice and is none of your business; you should never have looked at it in the first place.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Property Lists" class="calibre2"><div class="preface" id="calibre_link-2663">
<h2 class="calibre42">Property Lists</h2>

<p class="author1">A <em class="calibre11">property list</em> is a string (XML) representation of data.<a data-type="indexterm" data-primary="property lists" id="calibre_link-1782" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The Foundation classes NSString, NSData, NSArray, and NSDictionary are the only Cocoa classes that can be expressed directly in a property list. Moreover, an NSArray or NSDictionary can be expressed in a property list only if its elements are instances of those classes, along with NSDate and NSNumber. Those are the <em class="calibre11">property list types</em>.</p>

<p class="author1">(That is why, as I mentioned earlier, you must convert a UIColor into a Data object in order to store it in user defaults; the user defaults storage <em class="calibre11">is</em> a property list, and UIColor is not a property list type. But Data <em class="calibre11">is</em> a property list type, because it is bridged to NSData.)</p>

<p class="author1">The primary use of a property list is to store data as a file. It is a way of <em class="calibre11">serializing</em> a value &mdash; saving it to disk in a form from which it can be reconstructed.<a data-type="indexterm" data-primary="serialization" id="calibre_link-2002" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> NSArray and NSDictionary provide <code class="calibre19">write</code> methods that generate property list files; conversely, they also provide initializers that create an NSArray object or an NSDictionary object based on the property list contents of a given file.
(The NSString and NSData <code class="calibre19">write</code> methods just write the data out as a file directly, not as a property list.)</p>

<p class="author1">Here, for example, Iâ€™ll create an array of strings and write it out to disk as a property list file:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["Manny", "Moe", "Jack"]
let fm = FileManager.default
let temp = fm.temporaryDirectory
let f = temp.appendingPathComponent("pep.plist")
try! (arr as NSArray).write(to: f)</pre>

<p class="author1">The result is a file that looks like this:</p>

<pre data-type="programlisting" class="calibre28">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;array&gt;
    &lt;string&gt;Manny&lt;/string&gt;
    &lt;string&gt;Moe&lt;/string&gt;
    &lt;string&gt;Jack&lt;/string&gt;
&lt;/array&gt;
&lt;/plist&gt;</pre>

<p class="author1">When you reconstruct an NSArray or NSDictionary object from a property list file in this way, the collections, string objects, and data objects in the collection are all immutable. If you want them to be mutable, or if you want to convert an instance of one of the other property list classes to a property list, youâ€™ll use the PropertyListSerialization class (Objective-C NSPropertyListSerialization; see the <em class="calibre11">Property List Programming Guide</em> in the documentation archive).</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Codable" class="calibre2"><div class="preface" id="calibre_link-2664">
<h2 class="calibre42">Codable</h2>

<p class="author1">Property lists, as Iâ€™ve just described them, are a Cocoa Objective-C construct. But in Swift you can serialize an object without crossing the bridge into the Objective-C world, provided it adopts the Codable<a data-type="indexterm" data-primary="Codable" id="calibre_link-426" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> protocol. In effect, every native Swift type and every Foundation overlay type <em class="calibre11">does</em> adopt the Codable protocol! This means, among other things, that enums and structs can easily be serialized, something that was quite tricky before Swift 4 introduced the Codable protocol.</p>

<p class="author1">There are three main use cases, involving three pairs of classes to serialize the object and extract it again later; what youâ€™re encoding to and decoding from is a Data object:<a data-type="indexterm" data-primary="encoding and decoding" id="calibre_link-734" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="decoding and encoding" id="calibre_link-633" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Property lists</dt>
<dd class="calibre16">
<p class="calibre17">Use PropertyListEncoder and PropertyListDecoder.</p>
</dd>
<dt class="calibre15">JSON</dt>
<dd class="calibre16">
<p class="calibre17">Use JSONEncoder and JSONDecoder.</p>
</dd>
<dt class="calibre15">NSCoder</dt>
<dd class="calibre16">
<p class="calibre17">Use NSKeyedArchiver and NSKeyedUnarchiver.</p>
</dd>
</dl>

<p class="author1">To illustrate, letâ€™s rewrite the previous example, serializing an array of strings to a property list, without casting it to an NSArray. This works because both Swift Array and Swift String adopt Codable; indeed, thanks to conditional conformance (<a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>), an Array is Codable only just in case its element type is Codable:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["Manny", "Moe", "Jack"]
let fm = FileManager.default
let temp = fm.temporaryDirectory
let f = temp.appendingPathComponent("pep.plist")
let penc = PropertyListEncoder()
penc.outputFormat = .xml
let d = try! penc.encode(arr)
try! d.write(to: f)</pre>

<p class="author1">The resulting file looks like this:</p>

<pre data-type="programlisting" class="calibre28">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;array&gt;
    &lt;string&gt;Manny&lt;/string&gt;
    &lt;string&gt;Moe&lt;/string&gt;
    &lt;string&gt;Jack&lt;/string&gt;
&lt;/array&gt;
&lt;/plist&gt;</pre>

<p class="author1">That example doesnâ€™t do anything that we couldnâ€™t have done with NSArray. But now consider, for instance, an index set. You canâ€™t write an NSIndexSet directly into a property list using Objective-C, because NSIndexSet is not a property list type. But the Swift Foundation overlay type, IndexSet, is Codable:</p>

<pre data-type="programlisting" class="calibre28">let penc = PropertyListEncoder()
penc.outputFormat = .xml
let d = try! penc.encode(IndexSet([1,2,3]))</pre>

<p class="author1">And hereâ€™s the result:</p>

<pre data-type="programlisting" class="calibre28">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;indexes&lt;/key&gt;
    &lt;array&gt;
        &lt;dict&gt;
            &lt;key&gt;length&lt;/key&gt;
            &lt;integer&gt;3&lt;/integer&gt;
            &lt;key&gt;location&lt;/key&gt;
            &lt;integer&gt;1&lt;/integer&gt;
        &lt;/dict&gt;
    &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;</pre>

<p class="author1">Notice how cleverly Swift has encoded this object. You canâ€™t put an IndexSet into a property list &mdash; but this property list doesnâ€™t contain any IndexSet! It is composed entirely of legal property list types &mdash; a dictionary containing an array of dictionaries whose values are numbers. And Swift can extract the encoded object from the property list:</p>

<pre data-type="programlisting" class="calibre28">let ix = try! PropertyListDecoder().decode(IndexSet.self, from: d)
// [1,2,3]</pre>

<p class="author1">Your own custom types can adopt Codable and thus make themselves encodable in the same way. In fact, in the simplest case, adopting Codable is <em class="calibre11">all</em> you have to do! If the typeâ€™s properties are themselves Codable, the right thing will happen automatically. The Codable protocol has two required methods, but we donâ€™t have to implement them because default implementations are synthesized (see <a data-type="xref" href="#calibre_link-61" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œSynthesized Protocol Implementationsâ€</a>) &mdash; though we <em class="calibre11">could</em> implement them if we wanted to customize the details of encoding and decoding.</p>

<p class="author1">For example, hereâ€™s a simple Person struct:</p>

<pre data-type="programlisting" class="calibre28">struct Person : Codable {
    let firstName : String
    let lastName : String
}</pre>

<p class="author1">Person adopts Codable, so with no further effort we can turn a Person into a property list:</p>

<pre data-type="programlisting" class="calibre28">let p = Person(firstName: "Matt", lastName: "Neuburg")
let penc = PropertyListEncoder()
penc.outputFormat = .xml
let d = try! penc.encode(p)</pre>

<p class="author1">Hereâ€™s our encoded Person:</p>

<pre data-type="programlisting" class="calibre28">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;firstName&lt;/key&gt;
    &lt;string&gt;Matt&lt;/string&gt;
    &lt;key&gt;lastName&lt;/key&gt;
    &lt;string&gt;Neuburg&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;</pre>

<p class="author1">Observe that this would work just as well for, say, an array of Person, or a dictionary with Person values, or any Codable struct with a Person property.</p>

<p class="author1">UserDefaults is a property list, so an object that isnâ€™t a property list type must be archived to a Data object in order to store it in UserDefaults.
A <span class="publishername">PropertyListEncoder</span> creates a Data object, so we can use it to store a Person object in <span class="publishername">UserDefaults</span>:<a data-type="indexterm" data-primary="UserDefaults" data-secondary="storing nonproperty-list types" id="calibre_link-2306" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="archive" data-secondary="object" id="calibre_link-173" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let ud = UserDefaults.standard
let p = Person(firstName: "Matt", lastName: "Neuburg")
let pdata = try! PropertyListEncoder().encode(p)
ud.set(pdata, forKey: "person")</pre>

<p class="author1">Encoding as JSON is similar to encoding as a property list:<a data-type="indexterm" data-primary="JSON" id="calibre_link-1172" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let p = Person(firstName: "Matt", lastName: "Neuburg")
let jenc = JSONEncoder()
jenc.outputFormatting = .prettyPrinted
let d = try! jenc.encode(p)
print(String(data:d, encoding:.utf8)!)
/*
{
  "firstName" : "Matt",
  "lastName" : "Neuburg"
}
*/</pre>

<p class="author1">The final use case is encoding or decoding through an NSCoder<a data-type="indexterm" data-primary="NSCoder" id="calibre_link-1432" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. There are various situations where Cocoa lends you an NSCoder object and invites you to put some data into it or pull some data out of it.
The NSCoder in question will be either an NSKeyedArchiver<a data-type="indexterm" data-primary="NSKeyedArchiver" id="calibre_link-1444" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, when youâ€™re encoding, or an NSKeyedUnarchiver, when youâ€™re decoding. These subclasses, respectively, provide methods <code class="calibre19">encodeEncodable(_:forKey:)</code>, which takes a Codable object, and <code class="calibre19">decodeDecodable(_:forKey:)</code>, which produces a Codable object. Thus, your Codable adopters can pass into and out of an archive by way of NSCoder.</p>

<p class="author1">As I mentioned earlier, your Codable adopter can take more control of the encoding and decoding process. You can map between your objectâ€™s property names and the encoded key names by adding a CodingKeys enum, and you can provide an explicit implementation of the <code class="calibre19">encode(to:)</code> and <code class="calibre19">decode(from:)</code> methods instead of letting them be synthesized for you. For more information, consult the help document â€œEncoding and Decoding Custom Types.â€</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Accessors, Properties, and Keyâ€“Value Coding" class="calibre2"><div class="preface" id="calibre_link-2665">
<h1 class="calibre18">Accessors, Properties, and Key&ndash;Value Coding</h1>

<p class="author1">An Objective-C instance variable is structurally similar to a Swift instance property: itâ€™s a variable that accompanies each instance of a class, with a lifetime and value associated with that particular instance. An Objective-C instance variable, however, is usually private, in the sense that instances of other classes canâ€™t see it (and Swift canâ€™t see it). If an instance variable is to be made public, an Objective-C class will typically implement <em class="calibre11">accessor methods</em>: a getter method and (if this instance variable is to be publicly writable) a setter method. This is such a common thing to do that there are naming conventions:<a data-type="indexterm" data-primary="instance" data-secondary="variables, Objective-C" id="calibre_link-1112" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="accessors" id="calibre_link-109" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="getter" id="calibre_link-971" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="setter" id="calibre_link-2020" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="names of accessors" id="calibre_link-1375" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="instance variables" id="calibre_link-1527" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="accessors" id="calibre_link-1513" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">The getter method</dt>
<dd class="calibre16">
<p class="calibre17">A getter should have the same name as the instance variable (without an initial underscore if the instance variable has one). Thus, if the instance variable is named <code class="calibre19">myVar</code> (or <code class="calibre19">_myVar</code>), the getter method should be named <code class="calibre19">myVar</code>.</p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">The setter method</dt>
<dd class="calibre16">
<p class="calibre17">A setter methodâ€™s name should start with <code class="calibre19">set</code>, followed by a capitalized version of the instance variableâ€™s name (without an initial underscore if the instance variable has one). The setter should take one parameter &mdash; the new value to be assigned to the instance variable. Thus, if the instance variable is named <code class="calibre19">myVar</code> (or <code class="calibre19">_myVar</code>), the setter should be named <code class="calibre19">setMyVar:</code>.</p>
</dd>
</dl>

<p class="author1">This pattern &mdash; a getter method, possibly accompanied by an appropriately named setter method &mdash; is so common that thereâ€™s a shorthand: an Objective-C class can declare a <em class="calibre11">property</em>, using the keyword <code class="calibre19">@property</code> and a name. Here, for example, is a line from the UIView class declaration (ignore the material in the parentheses):</p>

<pre data-type="programlisting" class="calibre28">@property(nonatomic) CGRect frame;</pre>

<p class="author1">Within Objective-C, this declaration constitutes a promise that there is a getter accessor method <code class="calibre19">frame</code> returning a CGRect, along with a setter accessor method <code class="calibre19">setFrame:</code> that takes a CGRect parameter.<a data-type="indexterm" data-primary="Objective-C" data-secondary="properties" id="calibre_link-1539" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="Objective-C" id="calibre_link-1765" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">When Objective-C formally declares a <code class="calibre19">@property</code> in this way, <em class="calibre11">Swift sees it as a Swift property</em>. Thus, UIViewâ€™s <code class="calibre19">frame</code> property declaration is translated directly into a Swift declaration of an instance property <code class="calibre19">frame</code> of type CGRect:</p>

<pre data-type="programlisting" class="calibre28">var frame: CGRect</pre>

<p class="author1">An Objective-C property name, however, is mere syntactic sugar; Objective-C objects do not really â€œhaveâ€ properties. When you apparently set a UIViewâ€™s <code class="calibre19">frame</code> property, you are actually calling its <code class="calibre19">setFrame:</code> setter method, and when you apparently get a UIViewâ€™s <code class="calibre19">frame</code> property, you are actually calling its <code class="calibre19">frame</code> getter method. In Objective-C, use of the property is optional; Objective-C code can, and often does, call the <code class="calibre19">setFrame:</code> and <code class="calibre19">frame</code> methods <em class="calibre11">directly</em>. But you canâ€™t do that in Swift! If an Objective-C class has a formal <code class="calibre19">@property</code> declaration, <em class="calibre11">the accessor methods are hidden from Swift</em>.</p>

<p class="author1">An Objective-C property declaration can include the word <code class="calibre19">readonly</code> in the parentheses. This indicates that there is a getter but no setter. So, for example (ignore the other material in the parentheses):</p>

<pre data-type="programlisting" class="calibre28">@property(nonatomic,readonly,strong) CALayer *layer;</pre>

<p class="author1">Swift will reflect this restriction with <code class="calibre19">{get}</code> after the declaration, as if this were a computed read-only property; the compiler will not permit you to assign to such a property:</p>

<pre data-type="programlisting" class="calibre28">var layer: CALayer { get }</pre>

<p class="author1">An Objective-C property and its accompanying accessor methods have a life of their own, independent of any underlying instance variable. Although accessor methods may literally be ways of accessing an invisible instance variable, they donâ€™t have to be. When you set a UIViewâ€™s <code class="calibre19">frame</code> property and the <code class="calibre19">setFrame:</code> accessor method is called, you have no way of knowing what that method is really doing: it might be setting an instance variable called <code class="calibre19">frame</code> or <code class="calibre19">_frame</code>, but who knows? In this sense, accessors and properties are a faÃ§ade, hiding the underlying implementation. This is similar to how, within Swift, you can set a variable without knowing or caring whether it is a stored variable or a computed variable (and, if it is a computed variable, without knowing what its getter and setter functions really do).</p>








<section data-type="sect2" data-pdf-bookmark="Swift Accessors" class="calibre2"><div class="preface" id="calibre_link-2666">
<h2 class="calibre42">Swift Accessors</h2>

<p class="author1">Just as Objective-C properties are actually a shorthand for accessor methods, so Objective-C treats Swift properties as a shorthand for accessor methods &mdash; even though no such methods are formally present. If you, in Swift, declare that a class has a property <code class="calibre19">prop</code>, Objective-C can call a <code class="calibre19">prop</code> method to get its value or a <code class="calibre19">setProp:</code> method to set its value, <em class="calibre11">even though you have not implemented such methods</em>. Those calls are routed to your property through <em class="calibre11">implicit</em> accessor methods.<a data-type="indexterm" data-primary="properties" data-secondary="accessors" id="calibre_link-1743" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In Swift, you should <em class="calibre11">not</em> write <em class="calibre11">explicit</em> accessor methods for a property; the compiler will stop you if you attempt to do so. If you need to implement an accessor method explicitly and formally, use a computed property. Here, for example, Iâ€™ll add to my UIViewController subclass a computed <code class="calibre19">color</code> property with a getter and a setter:</p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
    @objc var color : UIColor {
        get {
            print("someone called the getter")
            return .red
        }
        set {
            print("someone called the setter")
        }
    }
}</pre>

<p class="author1">Objective-C code can now call explicitly the implicit <code class="calibre19">setColor:</code> and <code class="calibre19">color</code> accessor methods &mdash; and when it does, the computed propertyâ€™s setter and getter methods are in fact called:</p>

<pre data-type="programlisting" class="calibre28">ViewController* vc = [ViewController new];
[vc setColor:[UIColor redColor]]; // "someone called the setter"
UIColor* c = [vc color]; // "someone called the getter"</pre>

<p class="author1">This proves that, in Objective-Câ€™s mind, you <em class="calibre11">have</em> provided <code class="calibre19">setColor:</code> and <code class="calibre19">color</code> accessor methods.</p>

<p class="author1">You can even <em class="calibre11">change</em> the Objective-C names of accessor methods! To do so, follow the <code class="calibre19">@objc</code> attribute with the Objective-C name in parentheses. You can add it to a computed propertyâ€™s setter and getter methods, or you can add it to a property itself:<a data-type="indexterm" data-primary="names of accessors" data-secondary="changing" id="calibre_link-1376" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="objc" id="calibre_link-1483" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@objc(hue) var color : UIColor?</pre>

<p class="author1">Objective-C code can now call <code class="calibre19">hue</code> and <code class="calibre19">setHue:</code> accessor methods directly.</p>

<p class="author1">If, in speaking to Objective-C, you need to pass a selector for an accessor method, precede the contents of the <code class="calibre19">#selector</code> expression with <code class="calibre19">getter:</code> or <code class="calibre19">setter:</code>. For example, <code class="calibre19">#selector(setter:color)</code> is <code class="calibre19">"setHue:"</code> if we have modified our <code class="calibre19">color</code> propertyâ€™s Objective-C name with <code class="calibre19">@objc(hue)</code> (or <code class="calibre19">"setColor:"</code> if we have not).</p>

<p class="author1">If all you want to do is add functionality to the setter, use a setter observer. For example, to add functionality to the Objective-C <code class="calibre19">setFrame:</code> method in your UIView subclass, you can override the <code class="calibre19">frame</code> property and write a <code class="calibre19">didSet</code> observer:</p>

<pre data-type="programlisting" class="calibre28">class MyView: UIView {
    override var frame : CGRect {
        didSet {
            print("the frame setter was called: \(super.frame)")
        }
    }
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Keyâ€“Value Coding" class="calibre2"><div class="preface" id="calibre_link-2667">
<h2 class="calibre42">Key&ndash;Value Coding</h2>

<p class="author1">Cocoa can dynamically call an accessor method, or access an instance variable, based on a string name specified at runtime, through a mechanism called <em class="calibre11">key&ndash;value coding</em> (KVC).<a data-type="indexterm" data-primary="KVC" id="calibre_link-1194" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The string name is the <em class="calibre11">key</em>; what is passed or returned is the <em class="calibre11">value</em>. The basis for key&ndash;value coding is the NSKeyValueCoding protocol, an informal protocol; it is actually a category injected into NSObject. A Swift class, to be susceptible to key&ndash;value coding, must therefore be derived from NSObject.<a data-type="indexterm" data-primary="Cocoa" data-secondary="keyâ€“value coding" id="calibre_link-418" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="keyâ€“value coding" id="calibre_link-1189" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The fundamental Cocoa key&ndash;value coding methods are <code class="calibre19">setValue(_:forKey:)</code> and <code class="calibre19">value(forKey:)</code>. When one of these methods is called on an object, the object is introspected.<a data-type="indexterm" data-primary="introspection" id="calibre_link-1159" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> In simplified terms, first the appropriate accessor method is sought; if it doesnâ€™t exist, the instance variable is accessed directly.
The <code class="calibre19">value</code> can be an Objective-C object of any type, so its Objective-C type is <code class="calibre19">id</code>; therefore it is typed in Swift as Any. Whatever you pass into <code class="calibre19">setValue(_:forKey:)</code> will cross the bridge from Swift to Objective-C. Coming back the other way, when calling <code class="calibre19">value(forKey:)</code>, youâ€™ll receive an Optional wrapping an Any; youâ€™ll want to cast this down safely to its expected type.</p>

<p class="author1">A class is <em class="calibre11">key&ndash;value coding compliant</em> (or <em class="calibre11">KVC compliant</em>) on a given key if it provides the accessor methods, or possesses the instance variable, required for access through that key.<a data-type="indexterm" data-primary="compliant, keyâ€“value coding" id="calibre_link-500" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> An attempt to access a key for which a class is <em class="calibre11">not</em> key&ndash;value coding compliant will likely cause a crash at runtime. It is useful to be familiar with the message youâ€™ll get when such a crash occurs, so letâ€™s cause it deliberately:</p>

<pre data-type="programlisting" class="calibre28">let obj = NSObject()
obj.setValue("hello", forKey:"keyName") // crash</pre>

<p class="author1">The console says: â€œThis class is not key value coding-compliant for the key keyName.â€<a data-type="indexterm" data-primary="crash" data-secondary="class not keyâ€“value coding compliant" id="calibre_link-562" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The last word in that error message is the key string that caused the trouble.</p>

<p class="author1">What would it take for that method call <em class="calibre11">not</em> to crash? The class of the object to which it is sent would need to have a <code class="calibre19">setKeyName:</code> setter method, or a <code class="calibre19">keyName</code> or <code class="calibre19">_keyName</code> instance variable. In Swift, as I demonstrated in the previous section, an instance property implies the existence of accessor methods. Thus, in Swift, we can use Cocoa key&ndash;value coding on an instance of any NSObject subclass that has a declared property, provided the key string is the string name of that property. Letâ€™s try it! Here is such a class:</p>

<pre data-type="programlisting" class="calibre28">class Dog : NSObject {
    @objc var name : String = ""
}</pre>

<p class="author1">And hereâ€™s our test:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
d.setValue("Fido", forKey:"name") // no crash!
print(d.name) // "Fido" - it worked!</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="How Outlets Work" class="calibre2"><div class="preface" id="calibre_link-2668">
<h2 class="calibre42">How Outlets Work</h2>

<p class="author1">Key&ndash;value coding lies at the heart of how outlet connections work (<a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>). The name of the outlet in the nib is a string. It is key&ndash;value coding that turns the string into a hunt for a matching property at nib-loading time.<a data-type="indexterm" data-primary="connections" data-secondary="outlet" id="calibre_link-531" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="outlet connections" id="calibre_link-1639" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Suppose, for example, that you have a class Dog with an <code class="calibre19">@IBOutlet</code> property <code class="calibre19">master</code> typed as Person, and youâ€™ve drawn a <code class="calibre19">"master"</code> outlet from a Dog object in the nib to a Person object in the nib. When the nib loads, the outlet name <code class="calibre19">"master"</code> is translated <em class="calibre11">through key&ndash;value coding</em> to the accessor method name <code class="calibre19">setMaster:</code>, and your Dog instanceâ€™s <code class="calibre19">setMaster:</code> implicit accessor method is called with the Person instance as its parameter &mdash; thus setting the value of your Dog instanceâ€™s <code class="calibre19">master</code> property to the Person instance (<a data-type="xref" href="#calibre_link-66" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;7-8</a>).</p>

<p class="author1">If something goes wrong with the match between the outlet name in the nib and the name of the property in the class, then at runtime, when the nib loads, Cocoaâ€™s attempt to use key&ndash;value coding to set a value in your object based on the name of the outlet will fail, and your app will crash &mdash; with an error message complaining (you guessed it) that the class is not key&ndash;value coding compliant for the key.<a data-type="indexterm" data-primary="crash" data-secondary="class not keyâ€“value coding compliant" id="calibre_link-563" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (The key here is the outlet name.) A likely way for this to happen is that you formed the outlet correctly but then later changed the name of (or deleted) the property in the class; see <a data-type="xref" href="#calibre_link-67" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œMisconfigured Outletsâ€</a>.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Cocoa Key Paths" class="calibre2"><div class="preface" id="calibre_link-2669">
<h2 class="calibre42">Cocoa Key Paths</h2>

<p class="author1">A Cocoa <em class="calibre11">key path</em> allows you to chain keys in a single expression. If an object is key&ndash;value coding compliant for a certain key, and if the value of that key is itself an object that is key&ndash;value coding compliant for another key, you can chain those keys by calling <code class="calibre19">value(forKeyPath:)</code> and <code class="calibre19">setValue(_:forKeyPath:)</code>.</p>

<p class="author1">A key path string looks like a succession of key names joined using dot-notation. For example, <code class="calibre19">valueForKeyPath("key1.key2")</code> effectively calls <code class="calibre19">value(forKey:)</code> on the message receiver, with <code class="calibre19">"key1"</code> as the key, and then takes the object returned from that call and calls <code class="calibre19">value(forKey:)</code> on that object, with <code class="calibre19">"key2"</code> as the key.<a data-type="indexterm" data-primary="dot-notation" data-secondary="key paths" id="calibre_link-706" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="key paths" data-secondary="Cocoa" id="calibre_link-1185" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To illustrate, here are two classes that form a chain of properties &mdash; a DogOwner that has a <code class="calibre19">dog</code> property which is a Dog that has a <code class="calibre19">name</code> property:</p>

<pre data-type="programlisting" class="calibre28">class Dog : NSObject {
    @objc var name : String = ""
}
class DogOwner : NSObject {
    @objc var dog : Dog?
}</pre>

<p class="author1">Now letâ€™s configure an actual chain:</p>

<pre data-type="programlisting" class="calibre28">let owner = DogOwner()
let dog = Dog()
dog.name = "Fido"
owner.dog = dog</pre>

<p class="author1">Now we can use key&ndash;value coding with a key path to work our way down the chain:</p>

<pre data-type="programlisting" class="calibre28">if let name = owner.value(forKeyPath:"dog.name") as? String {</pre>

<p class="author1">We retrieve the value as an Optional wrapping an Any which is actually a string, and we cast down safely to retrieve the real value, <code class="calibre19">"Fido"</code>.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Uses of Keyâ€“Value Coding" class="calibre2"><div class="preface" id="calibre_link-2670">
<h2 class="calibre42">Uses of Key&ndash;Value Coding</h2>

<p class="author1">Cocoa key&ndash;value coding allows you, in effect, to decide at runtime, based on a string, what accessor to call. In the simplest case, youâ€™re using a string to access a dynamically specified property. Thatâ€™s useful in Objective-C code; but such unfettered introspective dynamism is contrary to the spirit of Swift, and in translating my own Objective-C code into Swift I have generally found myself accomplishing the same ends by other means.</p>

<p class="author1">Nevertheless, key&ndash;value coding remains useful in programming iOS, especially because a number of built-in Cocoa classes permit you to use it in special ways. For example:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If you send <code class="calibre19">value(forKey:)</code> to an NSArray, it sends <code class="calibre19">value(forKey:)</code> to each of its elements and returns a new array consisting of the results, an elegant shorthand. NSSet behaves similarly.</p>
</li>
<li class="calibre12">
<p class="calibre17">NSDictionary implements <code class="calibre19">value(forKey:)</code> as an alternative to <code class="calibre19">object(forKey:)</code> (useful particularly if you have an NSArray of dictionaries). Similarly, NSMutableDictionary treats <code class="calibre19">setValue(_:forKey:)</code> as a synonym for <code class="calibre19">set(_:forKey:)</code>, except that the first parameter can be <code class="calibre19">nil</code>, in which case <code class="calibre19">removeObject(forKey:)</code> is called.</p>
</li>
<li class="calibre12">
<p class="calibre17">NSSortDescriptor sorts an NSArray by sending <code class="calibre19">value(forKey:)</code> to each of its elements. This makes it easy to sort an array of dictionaries on the value of a particular dictionary key, or an array of objects on the value of a particular property.</p>
</li>
<li class="calibre12">
<p class="calibre17">NSManagedObject, used in conjunction with Core Data, is guaranteed to be key&ndash;value coding compliant for attributes youâ€™ve configured in the entity model. Thus, itâ€™s common to access those attributes with <code class="calibre19">value(forKey:)</code> and <code class="calibre19">setValue(_:forKey:)</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">CALayer and CAAnimation permit you to use key&ndash;value coding to define and retrieve the values for <em class="calibre11">arbitrary</em> keys, as if they were a kind of dictionary; they are, in effect, key&ndash;value coding compliant for <em class="calibre11">every key</em>. This is extremely helpful for attaching extra information to an instance of one of these classes.</p>
</li>
</ul>

<p class="author1">Also, many Cocoa APIs use key&ndash;value coding indirectly: you supply a key string, and Cocoa applies it for you. For example, a CABasicAnimation must be initialized with a <code class="calibre19">keyPath</code> string parameter:</p>

<pre data-type="programlisting" class="calibre28">let anim = CABasicAnimation(keyPath:"transform")</pre>

<p class="author1">What youâ€™re really doing there is telling the animation that youâ€™re going to want to animate a CALayerâ€™s <code class="calibre19">transform</code> property. Similarly, the AV Foundation framework, used in conjunction with videos, takes string keys to specify properties whose value youâ€™re going to be interested in:</p>

<pre data-type="programlisting" class="calibre28">let url = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
let asset = AVURLAsset(url:url)
asset.loadValuesAsynchronously(forKeys:["tracks"]) {</pre>

<p class="author1">That works because an AVURLAsset has a <code class="calibre19">tracks</code> property.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="KeyPath Notation" class="calibre2"><div class="preface" id="calibre_link-2671">
<h2 class="calibre42">KeyPath Notation</h2>

<p class="author1">Using key&ndash;value coding can be dangerous, because you risk using a key for which the target object is not key&ndash;value coding compliant. But Swift can often provide some measure of safety. Instead of forming the key string yourself, you ask the Swift compiler to form it for you. To do so, use <code class="calibre19">#keyPath</code> notation.</p>

<p class="author1"><code class="calibre19">#keyPath</code> notation is similar to <code class="calibre19">#selector</code> syntax (<a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>): youâ€™re asking the Swift compiler to form the key string for you, and it will refuse if it canâ€™t confirm that the key in question is legal. We crashed by saying this:</p>

<pre data-type="programlisting" class="calibre28">let obj = NSObject()
obj.setValue("hello", forKey:"keyName") // crash</pre>

<p class="author1">But if we had used <code class="calibre19">#keyPath</code> notation, our code wouldnâ€™t have crashed &mdash; because it wouldnâ€™t even have compiled:</p>

<pre data-type="programlisting" class="calibre28">let obj = NSObject()
obj.setValue("howdy", forKey: #keyPath(NSObject.keyName)) // compile error</pre>

<p class="author1">Now return to our Dog with a <code class="calibre19">name</code> property:</p>

<pre data-type="programlisting" class="calibre28">class Dog : NSObject {
    @objc var name : String = ""
}</pre>

<p class="author1">This compiles, because Swift <em class="calibre11">knows</em> that Dog has a <code class="calibre19">name</code> property:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
d.setValue("Fido", forKey:#keyPath(Dog.name))</pre>

<p class="author1">But that code will <em class="calibre11">not</em> compile if Dog is not an NSObject subclass, or if its <code class="calibre19">name</code> property is not exposed to Objective-C. Thus the Swift compiler can often help to save us from ourselves. Some of my earlier examples can be rewritten more safely using <code class="calibre19">#keyPath</code> notation, and in real life, this is how I would write them:</p>

<pre data-type="programlisting" class="calibre28">let anim = CABasicAnimation(keyPath: #keyPath(CALayer.transform))</pre>

<p class="author1">And:</p>

<pre data-type="programlisting" class="calibre28">let url = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
let asset = AVURLAsset(url:url)
let tracks = #keyPath(AVURLAsset.tracks)
asset.loadValuesAsynchronously(forKeys:[tracks]) {</pre>

<p class="author1">But the compiler canâ€™t <em class="calibre11">always</em> save us from ourselves. There are situations where you canâ€™t form a string indirectly using <code class="calibre19">#keyPath</code> notation, and youâ€™ll just have to hand Cocoa a string that you form yourself.
For example (<code class="calibre19">self</code> is a CALayer):</p>

<pre data-type="programlisting" class="calibre28">self.rotationLayer.setValue(.pi/4.0, forKeyPath:"transform.rotation.y")</pre>

<p class="author1">You canâ€™t rewrite that using <code class="calibre19">#keyPath(CALayer.transform.rotation.y)</code>, because the compiler wonâ€™t let you form that key path. The problem is that the compiler is unaware of any <code class="calibre19">rotation</code> property of a CALayer <code class="calibre19">transform</code> &mdash; because there is no such property. That sort of key path works by a special dispensation within Cocoa: CATransform3D (the type of a CALayerâ€™s <code class="calibre19">transform</code>) is key&ndash;value coding compliant for a repertoire of keys and key paths that donâ€™t correspond to any actual properties, and Swift has no way of knowing that.</p>

<p class="author1">You may be wondering how all of this relates to Swiftâ€™s own key path mechanism (<a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>). For example, if a Dog has a <code class="calibre19">name</code> property, you can say:</p>

<pre data-type="programlisting" class="calibre28">let d = Dog()
d[keyPath:\.name] = "Rover"</pre>

<p class="author1">That is a completely different mechanism! Youâ€™ll surely prefer to use the Swift mechanism where possible. It provides complete safety, along with type information; a Swift KeyPath object is strongly typed, because it is a generic, parameterized on the type of the corresponding property. But that wonâ€™t help you when youâ€™re talking to Cocoa. Objective-C key&ndash;value coding uses string keys, and a Swift KeyPath object cannot be magically transformed into a string key.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Cocoa key&ndash;value coding is a powerful technology with many ramifications beyond what Iâ€™ve described here; see Appleâ€™s <em class="calibre11">Key-Value Coding Programming Guide</em> in the documentation archive for full information.</p>
</div>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Secret Life of NSObject" class="calibre2"><div class="preface" id="calibre_link-2672">
<h1 class="calibre18">The Secret Life of NSObject</h1>

<p class="author1">Every Objective-C class inherits from NSObject, which is constructed in a rather elaborate way:<a data-type="indexterm" data-primary="NSObject" id="calibre_link-1458" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">It defines some native class methods and instance methods having mostly to do with the basics of instantiation and of method sending and resolution.</p>
</li>
<li class="calibre12">
<p class="calibre17">It adopts the NSObject protocol. This protocol declares instance methods having mostly to do with memory management, the relationship between an instance and its class, and introspection. Because all the NSObject protocol methods are required, the NSObject class implements them all. In Swift, the NSObject protocol is called NSObjectProtocol, to avoid name clash.<a data-type="indexterm" data-primary="NSObjectProtocol" id="calibre_link-1463" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre12">
<p class="calibre17">It implements convenience methods related to the NSCopying, NSMutableCopying, and NSCoding protocols, without formally adopting those protocols. NSObject intentionally doesnâ€™t adopt these protocols because this would cause all other classes to adopt them, which would be wrong. But thanks to this architecture, if a class <em class="calibre11">does</em> adopt one of these protocols, you can call the corresponding convenience method. For example, NSObject implements the <code class="calibre19">copy</code> instance method, so you can call <code class="calibre19">copy</code> on any instance, but youâ€™ll crash unless the <span class="publishername">instanceâ€™s</span> class also adopts the NSCopying protocol and implements <code class="calibre19">copy(with:)</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">A large number of methods are injected into NSObject by more than two dozen categories on NSObject, scattered among various header files. For example, <code class="calibre19">awakeFromNib</code> (see <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>) comes from the UINibLoadingAdditions category on NSObject, declared in <em class="calibre11">UINibLoading.h</em>.</p>
</li>
<li class="calibre12">
<p class="calibre17">A class object is an object. Therefore all Objective-C classes, which are objects of type Class, inherit from NSObject. Therefore, <em class="calibre11">any instance method of NSObject can be called on a class object as a class method!</em> For example, <code class="calibre19">responds(to:)</code> is defined as an instance method by the NSObject protocol, but it can (therefore) be treated also as a class method and sent to a class object.<a data-type="indexterm" data-primary="class" data-secondary="methods" data-tertiary="of NSObject" id="calibre_link-364" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">Taken as a whole, the NSObject methods may be considered under the following rough classification:</p>
<dl class="calibre14">
<dt class="calibre15">Creation, destruction, and memory management</dt>
<dd class="calibre16">
<p class="calibre17">Methods for creating an instance, such as <code class="calibre19">alloc</code> and <code class="calibre19">copy</code>, along with methods for learning when something is happening in the lifetime of an object, such as <code class="calibre19">initialize</code> and <code class="calibre19">dealloc</code>, plus methods that manage memory.</p>
</dd>
<dt class="calibre15">Class relationships</dt>
<dd class="calibre16">
<p class="calibre17">Methods for learning an objectâ€™s class and inheritance, such as <code class="calibre19">superclass</code>, <code class="calibre19">isKind(of:)</code>, and <code class="calibre19">isMember(of:)</code>.</p>
</dd>
</dl>
<dl class="calibre14">
<dt class="calibre15">Object introspection and comparison</dt>
<dd class="calibre16">
<p class="calibre17">Methods for asking what would happen if an object were sent a certain message, such as <code class="calibre19">responds(to:)</code>, for representing an object as a string (<code class="calibre19">description</code>), and for comparing objects (<code class="calibre19">isEqual(_:)</code>).</p>
</dd>
<dt class="calibre15">Message response</dt>
<dd class="calibre16">
<p class="calibre17">Methods for meddling with what does happen when an object is sent a certain message, such as <code class="calibre19">doesNotRecognizeSelector(_:)</code>. If youâ€™re curious, see the <em class="calibre11">Objective-C Runtime Programming Guide</em> in the documentation archive.</p>
</dd>
<dt class="calibre15">Message sending</dt>
<dd class="calibre16">
<p class="calibre17">Methods for sending a message dynamically. For example, <code class="calibre19">perform(_:)</code> takes a selector as parameter, and sending it to an object tells that object to perform that selector. This might seem identical to just sending that message to that object, but what if you donâ€™t know what message to send until runtime? Moreover, variants on <code class="calibre19">perform</code> allow you to send a message on a specified thread, or send a message after a certain amount of time has passed (<code class="calibre19">perform(_:with:afterDelay:)</code> and similar).<a data-type="indexterm" data-startref="idxnsobject" id="calibre_link-1459" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-68">
<div id="calibre_link-3009" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 11. Cocoa Events" class="calibre2"><div class="preface" id="calibre_link-15">
<h1 class="calibre13"><span class="label">Chapter 11. </span>Cocoa Events</h1>


<p class="author1">All of your appâ€™s executable code lies in its functions. The impetus for a function being called must come from somewhere. One of your functions may call another, but who will call the first function in the first place? How, ultimately, will <em class="calibre11">any</em> of your code <em class="calibre11">ever</em> run?</p>

<p class="author1">After your app has completely finished launching, <em class="calibre11">none</em> of your code runs. <code class="calibre19">UIApplicationMain</code> (see <a data-type="xref" href="#calibre_link-69" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œHow an App Gets Goingâ€</a>) just sits and loops &mdash; the <em class="calibre11">event loop</em> &mdash; waiting for something to happen. In general, the user needs to <em class="calibre11">do</em> something, such as touching the screen, or switching away from your app. When something does happen, the runtime detects it and informs your app, and Cocoa can call your code.</p>

<p class="author1">But Cocoa can call your code only if your code is there to be called. Your code is like a panel of buttons, ready for Cocoa to press one. If something happens that Cocoa feels your code needs to know about and respond to, it presses the right button &mdash; if the right button is there. Cocoa wants to send your code a message, but your code must have ears to hear.<a data-type="indexterm" data-primary="code" data-secondary="location" id="calibre_link-436" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The art of Cocoa programming lies in knowing <em class="calibre11">what</em> messages Cocoa would like to send your app. You organize your code, right from the start, with those messages in mind. Cocoa makes certain promises about how and when it will dispatch messages to your code. These are Cocoaâ€™s <em class="calibre11">events</em>. Your job is to know what those events are and how they will arrive; armed with that knowledge, you can arrange for your code to respond to them.<a data-type="indexterm" data-primary="events" id="calibre_link-812" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="events" id="calibre_link-416" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Reasons for Events" class="calibre2"><div class="preface" id="calibre_link-2673">
<h1 class="calibre18">Reasons for Events</h1>

<p class="author1">Broadly speaking, the reasons you might receive an event may be divided informally into four categories. These categories are not official; I made them up. Often it isnâ€™t completely clear which of these categories an event fits into.
But they are still generally useful for visualizing how and why Cocoa interacts with your code:</p>
<dl class="calibre14">
<dt class="calibre15">User events</dt>
<dd class="calibre16">
<p class="calibre17">The user does something interactive, and an event is triggered directly. Obvious examples are events that you get when the user taps or swipes the screen, or types a key on the keyboard.<a data-type="indexterm" data-primary="user events" id="calibre_link-2303" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Lifetime events</dt>
<dd class="calibre16">
<p class="calibre17">These are events notifying you of the arrival of a stage in the life of the app, such as the fact that the app is starting up or is about to go into the background, or of a component of the app, such as the fact that a UIViewControllerâ€™s view has just loaded or is about to be removed from the screen.<a data-type="indexterm" data-primary="lifetime events" id="calibre_link-1227" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Functional events</dt>
<dd class="calibre16">
<p class="calibre17">Cocoa is about to do something by calling its own code, and is willing to let you subclass and override that code so as to modify its behavior. I would put into this category UIViewâ€™s <code class="calibre19">draw(_:)</code> (your chance to have a view draw itself),
with which we experimented in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>.<a data-type="indexterm" data-primary="functional events" id="calibre_link-897" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">Query events</dt>
<dd class="calibre16">
<p class="calibre17">Cocoa turns to you to ask a question; its behavior will depend upon your answer. For example, the way data appears in a table (a UITableView) is that Cocoa asks you how many rows the table should have, and then, for each row, asks you for the corresponding cell.<a data-type="indexterm" data-primary="query events" id="calibre_link-1826" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Subclassing" class="calibre2"><div class="preface" id="calibre_link-2674">
<h1 class="calibre18">Subclassing</h1>

<p class="author1">A built-in Cocoa class may define methods that Cocoa itself will call if you override them in a subclass, so that your custom behavior, and not (merely) the default behavior, will take place.<a data-type="indexterm" data-primary="subclassing" data-secondary="in Cocoa" id="calibre_link-2136" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="subclassing" id="calibre_link-425" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> As I explained in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>, this is not a commonly used architecture in Cocoa, but for many classes itâ€™s there if you need it, and for certain classes it is downright essential. UIView and UIViewController are the best examples.</p>

<p class="author1">UIViewâ€™s <code class="calibre19">draw(_:)</code> is what I call a functional event. By default it does nothing, but by overriding it in a UIView subclass, you dictate how a view draws itself. You donâ€™t know exactly when this method will be called, and you donâ€™t care; when it is, you draw, and this guarantees that the view will always appear the way you want it to.<a data-type="indexterm" data-primary="UIView" id="calibre_link-2262" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subclassing" data-secondary="UIView" id="calibre_link-2141" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">UIViewController is a class meant for subclassing, and is probably the only Cocoa class that you will <em class="calibre11">regularly</em> subclass. Of the methods listed in the UIViewController class documentation, just about all are methods you might have reason to override. If you create a UIViewController subclass in Xcode, youâ€™ll see that the template already includes some method overrides to get you started. For example, <code class="calibre19">viewDidLoad</code> is called to let you know that your view controller has obtained its main view (its <code class="calibre19">view</code>), so that you can perform initializations; itâ€™s an obvious example of a lifetime event. And UIViewController has many other lifetime events that you can and will override in order to get fine control over what happens when.
<a data-type="indexterm" data-primary="UIViewController" id="calibre_link-2264" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="subclassing" data-secondary="UIViewController" id="calibre_link-2143" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Not only methods but also properties may be overridden in order to get an event. A case in point is UIViewControllerâ€™s <code class="calibre19">supportedInterfaceOrientations</code>. Youâ€™ll override this property as a computed variable in order to receive what I call a query event. Whenever Cocoa wants to know what orientations your view can appear in, it fetches the value of this property; your getter is a function that is called at that moment, and its job is to return a bitmask (<a data-type="xref" href="#calibre_link-70" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œOption setsâ€</a>) providing the answer to that question. You trust Cocoa to trigger this call at the appropriate moments, so that if the user rotates the device, your appâ€™s interface will or wonâ€™t be rotated to compensate, depending on what value you return.</p>

<p class="author1">When youâ€™re looking for events that you can receive through subclassing, be sure to look upward though the inheritance hierarchy. For example, if youâ€™re wondering how to get an event when your custom UILabel subclass is embedded into another view, you wonâ€™t find the answer in the UILabel class documentation; a UILabel receives the appropriate event by virtue of being a UIView. In the UIView class documentation, youâ€™ll learn that you can override <code class="calibre19">didMoveToSuperview</code> to be informed when this happens.</p>

<p class="author1">By the same token, look upward through adopted protocols as well. If youâ€™re wondering how to get an event when your view controllerâ€™s view is about to undergo app rotation, you wonâ€™t find out by looking in the UIViewController class documentation; a UIViewController receives the appropriate event by virtue of adopting the UIContentContainer protocol. In the UIContentContainer protocol documentation, youâ€™ll learn that you can override <code class="calibre19">viewWillTransition(to:with:)</code>.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Notifications" class="calibre2"><div class="preface" id="calibre_link-2675">
<h1 class="calibre18">Notifications</h1>

<p class="author1">Cocoa provides your app with a single NotificationCenter<a data-type="indexterm" data-primary="NotificationCenter" id="calibre_link-1419" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> instance (Objective-C NSNotificationCenter), available as <code class="calibre19">NotificationCenter.default</code>. This instance, the <em class="calibre11">notification center</em>, is the basis of a mechanism for sending and receiving messages called <em class="calibre11">notifications</em>. A notification is a Notification<a data-type="indexterm" data-primary="Notification" id="calibre_link-1416" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> instance (Objective-C NSNotification).</p>

<p class="author1">Think of a notification as having a topic and a sender. The topic is some subject matter that might be of interest to others; the sender is some object that others might be interested in hearing from. The notification center functions as a kind of broker for message transmission:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">A potential recipient of messages can <em class="calibre11">register</em> with the notification center, saying: â€œHey, if any messages on this topic or from this sender arrive, please pass them on to me.â€</p>
</li>
<li class="calibre4">
<p class="calibre17">A sender does in fact hand the notification center a message to send out; this is called <em class="calibre11">posting</em> a notification.</p>
</li>
<li class="calibre4">
<p class="calibre17">When the notification center receives a posting on a certain topic or from a certain sender, it looks through its list of registered recipients and passes along the message to any recipients that match.<a data-type="indexterm" data-primary="posting a notification" id="calibre_link-1714" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="notifications" id="calibre_link-421" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="notifications" id="calibre_link-1420" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>

</ol>

<p class="author1">More than one recipient can register for messages with the same topic or sender. The notification mechanism is thus well described as a dispatching or broadcasting mechanism. It lets the poster send a message without knowing or caring whether there are recipients or, if there are, who or how many they many be. And it lets the recipient arrange to receive the message without being in direct contact with the sender (possibly without even knowing who the sender is).</p>

<p class="author1">Who can post a notification? Anyone who cares to! There are two main posters of notifications to consider &mdash; Cocoa and you:</p>
<dl class="calibre14">
<dt class="calibre15">Cocoa</dt>
<dd class="calibre16">
<p class="calibre17">Cocoa posts notifications through the notification center, and your code can register to receive them. Thus, notifications are a way of receiving events from Cocoa. Youâ€™ll find a separate Notifications section in the documentation for a class that provides them.</p>
</dd>
<dt class="calibre15">You</dt>
<dd class="calibre16">
<p class="calibre17">You can post notifications yourself as a way of communicating with your own code. This relieves your appâ€™s architecture from the formal responsibility of somehow hooking up instances just so a message can pass from one to the other (which can sometimes be quite tricky or onerous, as Iâ€™ll discuss in <a data-type="xref" href="#calibre_link-50" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;13</a>). When objects are conceptually â€œdistantâ€ from one another, notifications can be a fairly lightweight way of permitting one to message the other.</p>
</dd>
</dl>

<p class="author1">A Notification instance has three pieces of information associated with it, which can be retrieved through properties:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">name</code></dt>
<dd class="calibre16">
<p class="calibre17">A string which identifies the topic of the notification. This string is typed as <span class="publishername">Notification.Name</span>, a struct adopting RawRepresentable with a String <code class="calibre19">rawValue</code>. Built-in Cocoa notification names are vended as static/class <span class="publishername">Notification.Name</span> properties, either of <span class="publishername">Notification.Name</span> itself or of the class that sends them.<a data-type="indexterm" data-primary="Notification.Name" id="calibre_link-1417" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15"><code class="calibre19">object</code></dt>
<dd class="calibre16">
<p class="calibre17">An instance associated with the notification; typically, the sender who posted it.</p>
</dd>
<dt class="calibre15"><code class="calibre19">userInfo</code></dt>
<dd class="calibre16">
<p class="calibre17">An Optional dictionary; if not <code class="calibre19">nil</code>, it contains additional information associated with the notification. What information it will contain, and under what keys, depends on the particular notification; you have to consult the documentation. For example, the documentation tells us that <code class="calibre19">UIApplication.didChangeStatusBarOrientationNotification</code> includes a <code class="calibre19">userInfo</code> dictionary with a key <code class="calibre19">UIApplication.statusBarOrientationUserInfoKey</code> whose value is the status barâ€™s previous orientation. When you post a <span class="publishername">notification</span> yourself, you can put anything you like into the <code class="calibre19">userInfo</code> for the notificationâ€™s recipient(s) to retrieve.</p>
</dd>
</dl>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Do <em class="calibre11">not</em> misuse a notificationâ€™s <code class="calibre19">object</code> as a way of passing along a value. I see that kind of misuse a lot, and itâ€™s wrong. Thatâ€™s what the <code class="calibre19">userInfo</code> is for. For example, in a <code class="calibre19">"weather"</code> notification stating that the weather is now <code class="calibre19">"rainy"</code>, that information goes into the <code class="calibre19">userInfo</code>, not the <code class="calibre19">object</code>.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Receiving a Notification" class="calibre2"><div class="preface" id="calibre_link-2676">
<h2 class="calibre42">Receiving a Notification</h2>

<p class="author1">To register to receive a notification, you send one of two messages to the notification center. One is <code class="calibre19">addObserver(_:selector:name:object:)</code>. The parameters are as <span class="publishername">follows:</span><a data-type="indexterm" data-primary="notifications" data-secondary="registering" id="calibre_link-1423" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="registering for a notification" id="calibre_link-1883" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">observer:</code></dt>
<dd class="calibre16">
<p class="calibre17">The first parameter is the instance to which the notification is to be sent. This will typically be <code class="calibre19">self</code>; it would be quite unusual for one instance to register a different instance as the receiver of a notification.</p>
</dd>
<dt class="calibre15"><code class="calibre19">selector:</code></dt>
<dd class="calibre16">
<p class="calibre17">The message to be sent to the observer instance when the notification occurs. The designated method should take one parameter, which will be the Notification instance. The selector must specify correctly a method that is exposed to Objective-C; Swiftâ€™s <code class="calibre19">#selector</code> syntax will help you with that (see <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>).</p>
</dd>
<dt class="calibre15"><code class="calibre19">name:</code></dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre19">name</code> of the notification youâ€™d like to receive. (This is what Iâ€™ve been calling the topic.) If this is <code class="calibre19">nil</code>, youâ€™re asking to receive <em class="calibre11">all</em> notifications associated with the object designated in the <code class="calibre19">object:</code> parameter.</p>
</dd>
<dt class="calibre15"><code class="calibre19">object:</code></dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre19">object</code> of the notification youâ€™re interested in, which will usually be the object that posted it. (This is what Iâ€™ve been calling the sender.) If this is <code class="calibre19">nil</code>, youâ€™re asking to receive <em class="calibre11">all</em> notifications with the name designated in the <code class="calibre19">name:</code> parameter. (If both the <code class="calibre19">name:</code> and <code class="calibre19">object:</code> parameters are <code class="calibre19">nil</code>, youâ€™re asking to receive all notifications!)</p>
</dd>
</dl>

<p class="author1">Hereâ€™s a real-life example. There is a music player belonging to the MPMusicPlayerController class; this class promises to post a notification whenever the music player starts playing a different song. (To find this out, I look under Notifications in the MPMusicPlayerController class documentation; the notification in question is called <code class="calibre19">MPMusicPlayerControllerNowPlayingItemDidChange</code>.) In my app, I want to receive that notification and change my interface accordingly.</p>

<p class="author1">It turns out that this notification wonâ€™t be posted unless I first call MPMusicPlayerControllerâ€™s <code class="calibre19">beginGeneratingPlaybackNotifications</code> instance method. This architecture is not uncommon; Cocoa saves itself some time and effort by not sending out certain notifications unless they are switched on, as it were. So my first job is to get an instance of MPMusicPlayerController and call this method:</p>

<pre data-type="programlisting" class="calibre28">let mp = MPMusicPlayerController.systemMusicPlayer
mp.beginGeneratingPlaybackNotifications()</pre>

<p class="author1">Now I register myself to receive the desired playback notification:</p>

<pre data-type="programlisting" class="calibre28">NotificationCenter.default.addObserver(self,
    selector: #selector(nowPlayingItemChanged),
    name: .MPMusicPlayerControllerNowPlayingItemDidChange,
    object: nil)</pre>

<p class="author1">As a result, whenever an <code class="calibre19">MPMusicPlayerControllerNowPlayingItemDidChange</code> notification is posted, my <code class="calibre19">nowPlayingItemChanged</code> method will be called. Note that this method must be marked <code class="calibre19">@objc</code> so that Objective-C can see it (the Swift compiler will help out by ensuring this when you use <code class="calibre19">#selector</code> syntax):</p>

<pre data-type="programlisting" class="calibre28">@objc func nowPlayingItemChanged (_ n:Notification) {
    self.updateNowPlayingItem()
    // ... and so on ...
}</pre>

<p class="author1">So far, so good. But heavy use of <code class="calibre19">addObserver(_:selector:name:object:)</code> means that your code ends up peppered with methods that exist solely in order to be called by the notification center. There is nothing about these methods that tells you what they are for &mdash; you may want to use explicit comments to remind yourself &mdash; and the methods are separate from the registration call, which can make your code rather confusing.</p>

<p class="author1">One way to solve that problem is to use the <em class="calibre11">other</em> way of registering to receive a notification &mdash; by calling <code class="calibre19">addObserver(forName:object:queue:using:)</code>. It returns a value, whose purpose Iâ€™ll explain in a moment. The <code class="calibre19">queue:</code> will usually be <code class="calibre19">nil</code>; a non-<code class="calibre19">nil</code> <code class="calibre19">queue:</code> is for background threading. The <code class="calibre19">name:</code> and <code class="calibre19">object:</code> parameters are just like those of <code class="calibre19">addObserver(_:selector:name:object:)</code>. But instead of providing an observer and a selector, you provide a <em class="calibre11">function</em> consisting of the actual code to be executed when the notification arrives. This function should take one parameter &mdash; the Notification itself. You can use an anonymous function, and typically you will.</p>

<p class="author1">The outcome is that your registration for a notification and your response when the notification arrives are encapsulated in a single call:</p>

<pre data-type="programlisting" class="calibre28">let ob = NotificationCenter.default.addObserver(
    forName: .MPMusicPlayerControllerNowPlayingItemDidChange,
    object: nil, queue: nil) { _ in
        self.updateNowPlayingItem()
        // ... and so on ...
    }</pre>

<p class="author1">That can be a much cleaner way of dealing with notifications. Unfortunately, though, using <code class="calibre19">addObserver(forName:...)</code> correctly is a little more complicated than that, because you still need to unregister the observer, as Iâ€™ll discuss in the next <span class="publishername">section</span>.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The notification center has no API for introspecting it in code, but you can introspect it while paused in the debugger; enter <code class="calibre19">po NotificationCenter.default</code> to see a list of registered notifications, with the name, object, recipient, and options for each. The object and recipient are listed as memory addresses, but you can learn more from such an address by entering <code class="calibre19">expr -l objc -O --</code> followed by the address.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Unregistering" class="calibre2"><div class="preface" id="calibre_link-2677">
<h2 class="calibre42">Unregistering</h2>

<p class="author1">To unregister an object as a recipient of notifications, call the notification centerâ€™s <code class="calibre19">removeObserver(_:)</code> method. Alternatively, you can unregister an object for just a specific set of notifications with <code class="calibre19">removeObserver(_:name:object:)</code>. The object passed as the first argument is the object that is no longer to receive notifications. What object that is depends on how you registered it in the first place:
<a data-type="indexterm" data-primary="notifications" data-secondary="unregistering" id="calibre_link-1425" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="unregistering for a notification" id="calibre_link-2286" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">You called <code class="calibre19">addObserver(_:selector:name:object:)</code></dt>
<dd class="calibre16">
<p class="calibre17">You <em class="calibre11">supplied</em> an observer originally, as the first argument; that is the observer you will now unregister. This will typically be <code class="calibre19">self</code>.</p>
</dd>
<dt class="calibre15">You called <code class="calibre19">addObserver(forName:object:queue:using:)</code></dt>
<dd class="calibre16">
<p class="calibre17">The call <em class="calibre11">returned</em> an observer token object typed as an NSObjectProtocol (its real class and nature are undocumented); that is the observer you will now unregister.</p>
</dd>
</dl>

<p class="author1">In the old days, if you failed to unregister an object as a notification recipient and that object went out of existence, your app would crash the next time the notification was sent &mdash; because the runtime was trying to send a message to an object that was now missing in action. But in iOS 9, Apple introduced a safety check. Nowadays, if the notification center tries to send a message to a nonexistent object, there is no crash, and the notification center helpfully unregisters the object for you.</p>

<p class="author1">What you need to do as you go out of existence depends, once again, on how you registered in the first place:</p>
<dl class="calibre14">
<dt class="calibre15">You called <code class="calibre19">addObserver(_:selector:name:object:)</code></dt>
<dd class="calibre16">
<p class="calibre17">You probably donâ€™t need to unregister the object passed as the first argument. If that object goes out of existence, and if the notification is posted subsequently, there wonâ€™t be any crash.</p>
</dd>
<dt class="calibre15">You called <code class="calibre19">addObserver(forName:object:queue:using:)</code></dt>
<dd class="calibre16">
<p class="calibre17">You <em class="calibre11">do</em> need to unregister the observer, because otherwise the notification center <em class="calibre11">keeps it alive</em> and can continue to send notifications to it (which means that the attached function will continue to be called).</p>
</dd>
</dl>

<p class="author1">So the question now boils down to how youâ€™re going to unregister the observer returned by a call to <code class="calibre19">addObserver(forName:object:queue:using:)</code>. If you only need to receive a notification <em class="calibre11">once,</em> you can unregister from within the anonymous function that runs when the notification is received (because the observer is in scope within the anonymous function). Otherwise, youâ€™ll have to keep a separate persistent reference to the observer object so that you can unregister it later.</p>

<p class="author1">Whatâ€™s a good way to do that? Letâ€™s assume youâ€™re going to be calling <code class="calibre19">addObserver(forName:object:queue:using:)</code> many times from within the same class. Then youâ€™re going to end up receiving many observer tokens, and youâ€™ll need to preserve a reference to all of them. One obvious approach is to store the observers in an instance property that is a mutable collection. My favored approach is a Set property:</p>

<pre data-type="programlisting" class="calibre28">var observers = Set&lt;NSObject&gt;()</pre>

<p class="author1">Each time I register for a notification by calling <code class="calibre19">addObserver(forName:object:queue:using:)</code>, I capture the result and add it to the set:</p>

<pre data-type="programlisting" class="calibre28">let ob = NotificationCenter.default.addObserver(
    forName: .MPMusicPlayerControllerNowPlayingItemDidChange,
    object: nil, queue: nil) { _ in
        self.updateNowPlayingItem()
        // ... and so on ...
    }
self.observers.insert(ob as! NSObject)</pre>

<p class="author1">When itâ€™s time to unregister all observers, I enumerate the set and empty it:</p>

<pre data-type="programlisting" class="calibre28">for ob in self.observers {
    NotificationCenter.default.removeObserver(ob)
}
self.observers.removeAll()</pre>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Use of <code class="calibre19">addObserver(forName:...)</code> can also involve you in some memory management complications that Iâ€™ll talk about in <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Posting a Notification" class="calibre2"><div class="preface" id="calibre_link-2678">
<h2 class="calibre42">Posting a Notification</h2>

<p class="author1">Notifications can be a way of communicating between your own objects. You post a notification yourself (in one object) and receive it yourself (in another object). This is probably not good way to compensate for a failure to devise proper lines of communication between objects, but it can be appropriate when the objects are conceptually distant or independent from one another, or when you need the flexibility of broadcasting to multiple recipients.
<a data-type="indexterm" data-primary="notifications" data-secondary="when appropriate" id="calibre_link-1427" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="notifications" data-secondary="posting" id="calibre_link-1422" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To post a notification, send <code class="calibre19">post(name:object:userInfo:)</code> to the notification center. You are defining the <code class="calibre19">name:</code> yourself, so youâ€™ll have to coerce a string into a <span class="publishername">Notification.Name</span>.
There are two main places to do this:<a data-type="indexterm" data-primary="strings" data-secondary="notification names" id="calibre_link-2110" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Notification.Name" data-secondary="forming from string" id="calibre_link-1418" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">In the <code class="calibre19">name:</code> argument</dt>
<dd class="calibre16">
<p class="calibre17">You perform the coercion directly in the method call. Thatâ€™s simple but error-prone: youâ€™ll need to perform the same coercion twice (to post the notification and to register to receive it), and the repeated string literal is an invitation to make a typing mistake and have things mysteriously go wrong.</p>
</dd>
<dt class="calibre15">As a globally available constant</dt>
<dd class="calibre16">
<p class="calibre17">You define a namespaced constant and use it both when posting the notification and when registering for it. This approach localizes the coercion in a single place; itâ€™s a little more work than the first approach, but itâ€™s more correct and you should use it.</p>
</dd>
</dl>

<p class="author1">For example, one of my apps is a simple card game. The game needs to know when a card is tapped. But a card knows nothing about the game; when it is tapped, it simply emits a virtual shriek by posting a notification. Iâ€™ve defined my notification name by extending my Card class:</p>

<pre data-type="programlisting" class="calibre28">extension Card {
    static let tappedNotification = Notification.Name("cardTapped")
}</pre>

<p class="author1">When a card is tapped, it responds like this:</p>

<pre data-type="programlisting" class="calibre28">NotificationCenter.default.post(name: Self.tappedNotification, object: self)</pre>

<p class="author1">The game object has registered for <code class="calibre19">Card.tappedNotification</code>, so it hears about this and retrieves the notificationâ€™s <code class="calibre19">object</code>; now it knows what card was tapped and can proceed appropriately.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Timer" class="calibre2"><div class="preface" id="calibre_link-2679">
<h2 class="calibre42">Timer</h2>

<p class="author1">A Timer (Objective-C NSTimer) is not a notification, but it behaves quite similarly.<a data-type="indexterm" data-primary="timers" id="calibre_link-2216" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> It gives off a signal (<em class="calibre11">fires</em>) after the lapse of a certain time interval. Thus you can arrange to get an event when a certain time has elapsed. The timing is not perfectly accurate, nor is it intended to be, but itâ€™s good enough for most purposes.</p>

<p class="author1">A timer that is actively watching the clock is said to be <em class="calibre11">scheduled</em>. A timer may fire once, or it may be a <em class="calibre11">repeating</em> timer. To stop a timer, it must be <em class="calibre11">invalidated</em>. A timer that is set to fire once is invalidated automatically after it fires; a repeating timer repeats until <em class="calibre11">you</em> invalidate it by sending it the <code class="calibre19">invalidate</code> message. An invalidated timer should be regarded as dead: you cannot revive it or use it for anything further, and you should probably not send any messages to it.</p>

<p class="author1">For example, one of my apps is a game with a score; I want to penalize the user by diminishing the score for every ten seconds that elapses after each move without the user making a further move. So I create and schedule a repeating timer whose time interval is ten seconds. Whenever the timer fires, I diminish the score. Whenever the user moves, I invalidate the existing timer and start over with a new repeating timer.</p>

<p class="author1">The simplest way to create a timer is with a class method that also schedules the timer, so that it begins watching the clock immediately:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">scheduledTimer(timeInterval:target:selector:userInfo:repeats:)</code></dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre19">target:</code> and <code class="calibre19">selector:</code> determine what message will be sent to what object when the timer fires; the method in question should take one parameter, which will be a reference to the timer. The <code class="calibre19">userInfo:</code> is just like the <code class="calibre19">userInfo:</code> of a notification.</p>
</dd>
<dt class="calibre15"><code class="calibre19">scheduledTimer(withTimeInterval:repeats:block:)</code></dt>
<dd class="calibre16">
<p class="calibre17">You provide a function to be called when the timer fires; the function should take one parameter, which will be a reference to the timer.</p>
</dd>
</dl>

<p class="author1">A repeating Timer is often maintained as an instance property, so that you can invalidate it later on. But be careful! There is a temptation to call <code class="calibre19">scheduledTimer(timeInterval:target:selector:userInfo:repeats:)</code> directly as the initializer in your declaration of a Timer instance property, like this:</p>

<pre data-type="programlisting" class="calibre28">class ViewController : UIViewController {
    var timer = Timer.scheduledTimer(timeInterval: 1, target: self,
        selector: #selector(timerFired), userInfo: nil, repeats: true)</pre>

<p class="author1">If the <code class="calibre19">target</code> is <code class="calibre19">self</code>, that wonâ€™t work, because <code class="calibre19">self</code> doesnâ€™t exist yet at the time youâ€™re initializing the instance property.
(In my opinion, Swift should warn you about this, and I regard its failure to do so as a bug.) Use deferred initialization instead (<a data-type="xref" href="#calibre_link-71" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œDeferred initialization of propertiesâ€</a>):</p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
    var timer : Timer!
    override func viewDidLoad() {
        super.viewDidLoad()
        self.timer = Timer.scheduledTimer(timeInterval: 1, target: self,
            selector: #selector(timerFired), userInfo: nil, repeats: true)
    }</pre>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Timers have some memory management implications that Iâ€™ll be discussing in <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>.</p>
</div>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Delegation" class="calibre2"><div class="preface" id="calibre_link-2680">
<h1 class="calibre18">Delegation</h1>

<p class="author1"><em class="calibre11">Delegation</em> is an object-oriented design pattern, a relationship between two objects in which a primary objectâ€™s behavior is customized or assisted by a secondary object. The secondary object is the primary objectâ€™s <em class="calibre11">delegate</em>.<a data-type="indexterm" data-primary="delegate" id="calibre_link-642" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> No subclassing is involved, and indeed the primary object is agnostic about the delegateâ€™s class.<a data-type="indexterm" data-primary="Cocoa" data-secondary="delegation" id="calibre_link-415" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-primary="delegation" data-see="delegate" id="calibre_link-3010" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The class of the primary object can be Cocoaâ€™s class or your class. As with notifications, youâ€™ll want to understand Cocoaâ€™s delegation pattern because itâ€™s an important way of getting events from Cocoa, but you might also want to implement the pattern yourself as a useful way of communicating between your own objects.</p>








<section data-type="sect2" data-pdf-bookmark="Cocoa Delegation" class="calibre2"><div class="preface" id="calibre_link-2681">
<h2 class="calibre42">Cocoa Delegation</h2>

<p class="author1">As implemented by Cocoa, hereâ€™s how delegation works:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">A built-in Cocoa class has an instance property, usually called <code class="calibre19">delegate</code> (it will certainly have <code class="calibre19">delegate</code> in its name).</p>
</li>
<li class="calibre4">
<p class="calibre17">The Cocoa class promises that at certain moments it will turn to its delegate for instructions by sending it a certain message.</p>
</li>
<li class="calibre4">
<p class="calibre17">If the Cocoa instance finds that its delegate is not <code class="calibre19">nil</code>, and that its delegate is prepared to receive that message, the Cocoa instance sends the message to the delegate.</p>
</li>

</ol>

<p class="author1">Delegation is one of Cocoaâ€™s main uses of protocols (<a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>). In the old days, delegate methods were listed in the Cocoa classâ€™s documentation, and their names were made known to the compiler through an informal protocol (a category on NSObject). Nowadays, a classâ€™s delegate methods are usually listed in a genuine protocol with its own documentation. There are over 70 Cocoa delegate protocols, showing how heavily Cocoa relies on delegation. Most delegate methods are optional, but in a few cases youâ€™ll discover some that are required.</p>

<p class="author1">To take advantage of Cocoa delegation, youâ€™ll have one of <em class="calibre11">your</em> classes adopt a Cocoa delegate protocol, and youâ€™ll set some Cocoa objectâ€™s <code class="calibre19">delegate</code> (typed as that protocol) to an instance of your class. Now <em class="calibre11">you</em> are the delegate, and you get to help determine the Cocoa objectâ€™s behavior. You might form the connection in code; alternatively, you might do it in a nib by connecting an objectâ€™s <code class="calibre19">delegate</code> outlet to an appropriate object within the nib.</p>

<p class="author1">Your delegate class will probably do other things besides serving as this instanceâ€™s delegate. Indeed, one of the nice things about delegation is that it leaves you free to slot delegate code into your class architecture however you like; the delegate type is a protocol, so the actual delegate can be an instance of <em class="calibre11">any</em> class.</p>

<p class="author1">Hereâ€™s a typical example. I want to ensure that my appâ€™s root view controller, a UINavigationController, should appear only in portrait orientation when this view controller is in charge. But UINavigationController isnâ€™t my class; my class is a <em class="calibre11">different</em> view controller, a UIViewController subclass, which acts as the UINavigationControllerâ€™s child. How can the child tell the parent how to rotate?</p>

<p class="author1">Delegation to the rescue! UINavigationController has a <code class="calibre19">delegate</code> property, typed as UINavigationControllerDelegate (a protocol). It promises to send this delegate the <code class="calibre19">navigationControllerSupportedInterfaceOrientations(_:)</code> message when it needs to know how to rotate. So my view controller, very early in its lifetime, sets itself as the UINavigationControllerâ€™s delegate. It also implements the <code class="calibre19">navigationControllerSupportedInterfaceOrientations(_:)</code> method. Presto, the problem is solved:</p>

<pre data-type="programlisting" class="calibre28">class ViewController : UIViewController, UINavigationControllerDelegate {
    override func viewDidLoad() {
        super.viewDidLoad()
        self.navigationController?.delegate = self
    }
    func navigationControllerSupportedInterfaceOrientations(
        _ nav: UINavigationController) -&gt; UIInterfaceOrientationMask {
            return .portrait
    }
}</pre>

<p class="author1">When youâ€™re searching the documentation for how you can be notified of a certain event, be sure to consult the corresponding delegate protocol, if there is one. For example, youâ€™d like to know when the user taps in a UITextField to start editing it. You wonâ€™t find anything relevant in the UITextField class documentation; what youâ€™re after is <code class="calibre19">textFieldDidBeginEditing(_:)</code> in the UITextFieldDelegate protocol.<a data-type="indexterm" data-primary="documentation" data-secondary="delegate" id="calibre_link-696" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">You might be tempted to try to inject a method into a class that adopts a Cocoa delegate protocol by extending the protocol and implementing the delegate method in the protocol extension. That isnâ€™t going to work, because Objective-C canâ€™t see Swift protocol extensions (see <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>). You can call such a method from Swift, but Cocoa is <em class="calibre11">never</em> going to call it, because it doesnâ€™t know that the method implementation exists.<a data-type="indexterm" data-primary="protocols" data-secondary="extensions" data-tertiary="invisible to Objective-C" id="calibre_link-1804" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Implementing Delegation" class="calibre2"><div class="preface" id="calibre_link-2682">
<h2 class="calibre42">Implementing Delegation</h2>

<p class="author1">The Cocoa protocol-and-delegate pattern is very useful, and youâ€™ll probably want to adopt it in your own code. Setting up the pattern takes some practice, and can be a little time-consuming. But itâ€™s a clean solution to the problem of apportioning knowledge and responsibilities among your objects.<a data-type="indexterm" data-primary="protocols" data-secondary="delegate" id="calibre_link-1799" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Iâ€™ll demonstrate with an example from one of my apps.</p>

<p class="author1">The app declares a view controller, a UIViewController subclass called ColorPickerController; its view contains three sliders that the user can move to choose a color. Some other view controller will create and present the ColorPickerController instance, displaying its view. When the user taps Done or Cancel, the view should be dismissed and the ColorPickerController instance can go out of existence; but first, I need to send a message from the ColorPickerController instance <em class="calibre11">back to the view controller that presented it</em>, reporting what color the user chose.</p>

<p class="author1">Hereâ€™s the declaration for the message that I want the ColorPickerController to send before it goes out of existence:</p>

<pre data-type="programlisting" class="calibre28">func colorPicker(_ picker:ColorPickerController,
    didSetColorNamed theName:String?,
    to theColor:UIColor?)</pre>

<p class="author1">The question is: where and how should this method be declared?</p>

<p class="author1">Now, it happens that in my app I know the class of the instance that will in fact present the ColorPickerController: it is a SettingsController. So I could simply declare this method in SettingsController and stop. But that would mean that the ColorPickerController, in order to send this message to the SettingsController, must <em class="calibre11">know</em> that the instance that presented it <em class="calibre11">is</em> a SettingsController. Thatâ€™s wrong. Surely it is a mere <em class="calibre11">contingent</em> fact that the instance being sent this message is a SettingsController; it should be open to <em class="calibre11">any</em> class to present and dismiss a ColorPickerController.</p>

<p class="author1">Therefore we want ColorPickerController <em class="calibre11">itself</em> to declare the method that <em class="calibre11">it itself is going to call</em>; and we want it to send that message blindly to some receiver, without regard to the class of that receiver. Thatâ€™s what a protocol is for!</p>

<p class="author1">The solution, then, is for ColorPickerController to define a protocol, with this method as part of that protocol, and for the class that presents a ColorPickerController to conform to that protocol. ColorPickerController will also need an appropriately typed <code class="calibre19">delegate</code> instance property; this provides the channel of communication, and tells the compiler that sending this message is legal:</p>

<pre data-type="programlisting" class="calibre28">protocol ColorPickerDelegate : AnyObject {
    // color == nil on cancel
    func colorPicker(_ picker:ColorPickerController,
        didSetColorNamed theName:String?,
        to theColor:UIColor?)
}
class ColorPickerController : UIViewController {
    weak var delegate: ColorPickerDelegate?
    // ...
}</pre>

<p class="author1">(For the <code class="calibre19">weak</code> attribute and the <code class="calibre19">AnyObject</code> designation, see <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>.) When my SettingsController instance creates and configures and presents a ColorPickerController instance, it also sets itself as that ColorPickerControllerâ€™s <code class="calibre19">delegate</code> &mdash; which it can do, because it adopts the protocol:</p>

<pre data-type="programlisting" class="calibre28">extension SettingsController : ColorPickerDelegate {
    func showColorPicker() {
        let colorName = // ...
        let c = // ...
        let cpc = ColorPickerController(colorName:colorName, color:c)
        cpc.delegate = self
        self.present(cpc, animated: true)
    }
    func colorPicker(_ picker:ColorPickerController,
        didSetColorNamed theName:String?,
        to theColor:UIColor?) {
            // ...
    }
}</pre>

<p class="author1">When the user picks a color, the ColorPickerController <em class="calibre11">knows</em> to whom it should send <code class="calibre19">colorPicker(_:didSetColorNamed:to:)</code> &mdash; namely, its delegate! And the compiler allows this, because the delegate has adopted the ColorPickerDelegate <span class="publishername">protocol:</span></p>

<pre data-type="programlisting" class="calibre28">@IBAction func dismissColorPicker(_ sender : Any?) { // user tapped Done
    let c : UIColor? = self.color
    self.delegate?.colorPicker(self, didSetColorNamed: self.colorName, to: c)
}</pre>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Data Sources" class="calibre2"><div class="preface" id="calibre_link-2683">
<h1 class="calibre18">Data Sources</h1>

<p class="author1">A <em class="calibre11">data source</em> is like a delegate, except that its methods supply the data for another object to display.<a data-type="indexterm" data-primary="data sources" id="calibre_link-600" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The chief Cocoa classes with data sources are UITableView, UICollectionView, UIPickerView, and UIPageViewController. In each case, the data source must formally adopt a data source protocol with required methods.<a data-type="indexterm" data-primary="Cocoa" data-secondary="data sources" id="calibre_link-414" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">It comes as a surprise to some beginners that a data source is necessary at all. Why isnâ€™t a tableâ€™s data just a property of the table? The reason is that such an architecture would violate generality. A view displays data; the structure and management of that data is a separate matter, and is up to the data source. The only requirement is that the data source must be able to supply information quickly, because it will be asked for it in real time when the data needs displaying.</p>

<p class="author1">Another surprise is that the data source is different from the delegate. But this again is only for generality; itâ€™s an option, not a requirement. There is no reason why the data source and the delegate should not be the same object, and most of the time they probably will be.</p>

<p class="author1">In this example from one of my apps, I implement a UIPickerView<a data-type="indexterm" data-primary="UIPickerView" id="calibre_link-2257" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> that allows the user to configure a game by saying how many stages it should consist of (â€œ1 Stage,â€ â€œ2 Stages,â€ and so on). The first two methods are UIPickerView data source methods; the third method is a UIPickerView delegate method. It takes all three methods to supply the picker viewâ€™s content:</p>

<pre data-type="programlisting" class="calibre28">extension NewGameController: UIPickerViewDataSource, UIPickerViewDelegate {
    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
        return 1
    }
    func pickerView(_ pickerView: UIPickerView,
        numberOfRowsInComponent component: Int) -&gt; Int {
            return 9
    }
    func pickerView(_ pickerView: UIPickerView,
        titleForRow row: Int, forComponent component: Int) -&gt; String? {
            return "\(row+1) Stage" + ( row &gt; 0 ? "s" : "")
    }
}</pre>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Actions" class="calibre2"><div class="preface" id="calibre_link-2684">
<h1 class="calibre18">Actions</h1>

<p class="author1">An <em class="calibre11">action</em> is a message emitted by an instance of a UIControl subclass (a <em class="calibre11">control</em>) reporting a significant user event taking place in that control. The <span class="publishername">UIControl</span> subclasses are all simple interface objects that the user can interact with directly, such as a button (UIButton) or a segmented control (UISegmentedControl).<a data-type="indexterm" data-primary="UIControl" id="calibre_link-2255" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="actions" id="calibre_link-412" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="actions" id="calibre_link-114" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The significant user events (<em class="calibre11">control events</em>) are listed under <span class="publishername">UIControl.Event</span> in the Constants section of the UIControl class documentation.<a data-type="indexterm" data-primary="control events" id="calibre_link-550" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Different controls implement different control events: for example, a segmented controlâ€™s Value Changed event signifies that the user has tapped a segment, but a buttonâ€™s Touch Up Inside event signifies that the user has tapped the button. Of itself, a control event has no external effect; the control responds visually (for example, a tapped button looks tapped), but it doesnâ€™t automatically share the information that the event has taken place. If you want to know when a control event takes place, so that you can respond to it in your code, <em class="calibre11">you</em> must arrange for that control event to trigger an <em class="calibre11">action message</em>.</p>

<p class="author1">Hereâ€™s how it works. A control maintains an internal dispatch table<a data-type="indexterm" data-primary="dispatch table" id="calibre_link-681" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>: for each control event, there can be any number of target&ndash;action pairs, in each of which the <em class="calibre11">action</em> is a selector designating the name of a method, and the <em class="calibre11">target</em> is an object on which that method is to be called.<a data-type="indexterm" data-primary="actions" data-secondary="target" id="calibre_link-122" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="targetâ€“action" id="calibre_link-2195" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> When a control event occurs, the control consults its dispatch table, finds all the target&ndash;action pairs associated with that control event, and sends each action message to the corresponding target (<a data-type="xref" href="#calibre_link-72" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;11-1</a>).</p>

<figure class="calibre32"><div id="calibre_link-72" class="figure">
<img src="images/000004.png" alt="ios8 1101" class="calibre76" />
<h6 class="calibre34"><span class="publishername">Figure 11-1. </span>The target&ndash;action architecture</h6>
</div>
</figure>

<p class="author1">There are two ways to manipulate a controlâ€™s action dispatch table:</p>
<dl class="calibre14">
<dt class="calibre15">Action connection</dt>
<dd class="calibre16">
<p class="calibre17">You can configure an action connection in a nib. I described in <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a> how to do this, but I didnâ€™t completely explain the underlying mechanism. Now all is revealed: an action connection formed in the nib editor is a visual way of configuring a controlâ€™s action dispatch table.</p>
</dd>
<dt class="calibre15">Code</dt>
<dd class="calibre16">
<p class="calibre17">Your code can directly configure the controlâ€™s action dispatch table. The key method here is the UIControl instance method <code class="calibre19">addTarget(_:action:for:)</code>, where the <code class="calibre19">target:</code> is an object, the <code class="calibre19">action:</code> is a selector, and the <code class="calibre19">for:</code> parameter is a <span class="publishername">UIControl.Event</span> bitmask (<a data-type="xref" href="#calibre_link-70" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œOption setsâ€</a>).</p>
</dd>
</dl>

<p class="author1">Recall the example of a control and its action from <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>. We have a <code class="calibre19">buttonPressed(_:)</code> method:</p>

<pre data-type="programlisting" class="calibre28">@IBAction func buttonPressed(_ sender: Any) {
    let alert = UIAlertController(
        title: "Howdy!", message: "You tapped me!", preferredStyle: .alert)
    alert.addAction(
        UIAlertAction(title: "OK", style: .cancel))
    self.present(alert, animated: true)
}</pre>

<p class="author1">That sort of method is an <em class="calibre11">action handler</em>. Its purpose is to be called when the user taps a certain button in the interface. In <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>, we arranged for that to happen by setting up an action connection in the nib: we connected the buttonâ€™s Touch Up Inside event to the ViewController <code class="calibre19">buttonPressed(_:)</code> method. In reality, we were forming a target&ndash;action pair and adding that target&ndash;action pair to the buttonâ€™s dispatch table for the Touch Up Inside control event.<a data-type="indexterm" data-primary="actions" data-secondary="handler" id="calibre_link-118" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Instead of making that arrangement in the nib, we could have done the same thing in code. Suppose we had <em class="calibre11">never</em> drawn that action connection. And suppose that, instead, we have an outlet connection from the view controller to the button, called <code class="calibre19">self.button</code>. Then the view controller, after the nib loads, can configure the buttonâ€™s dispatch table like this:</p>

<pre data-type="programlisting" class="calibre28">self.button.addTarget(self,
    action: #selector(buttonPressed),
    for: .touchUpInside)</pre>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">A control event can have multiple target&ndash;action pairs. You might configure it this way intentionally, but it is also possible to do so accidentally. Unintentionally giving a control event a target&ndash;action pair without removing its <em class="calibre11">existing</em> target-action pair is an easy mistake to make, and can cause some very mysterious behavior. For example, if we had formed an action connection in the nib <em class="calibre11">and</em> configured the dispatch table in code, a tap on the button would cause <code class="calibre19">buttonPressed(_:)</code> to be called <em class="calibre11">twice</em>.</p>
</div>

<p class="author1">The signature for the action selector can be in any of three forms:<a data-type="indexterm" data-primary="actions" data-secondary="selector signatures" id="calibre_link-121" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The fullest form takes two parameters:</p>

<ul class="calibre48">
<li class="calibre12">
<p class="pcalibre5 calibre17">The control.</p>
</li>
<li class="calibre12">
<p class="pcalibre5 calibre17">The UIEvent that generated the control event. This
will rarely be needed. (Iâ€™ll talk more about UIEvents in the next section.)</p>
</li>
</ul>
</li>
<li class="calibre12">
<p class="calibre17">A shorter form, the one most commonly used, omits the second parameter. <code class="calibre19">buttonPressed(_:)</code> is an example; it takes one parameter. When <code class="calibre19">buttonPressed(_:)</code> is called through an action message emanating from the button, its parameter will be a reference to the button.</p>
</li>
<li class="calibre12">
<p class="calibre17">There is a still shorter form that omits both parameters.</p>
</li>
</ul>

<p class="author1">Curiously, none of the action selector parameters provide any way to learn <em class="calibre11">which</em> control event triggered the current action selector call! For example, to distinguish a Touch Up Inside control event from a Touch Up Outside control event, their corresponding target&ndash;action pairs must specify two different action handlers; if you dispatch them to the same action handler, that handler cannot discover which control event occurred.</p>








<section data-type="sect2" data-pdf-bookmark="The Responder Chain" class="calibre2"><div class="preface" id="calibre_link-2685">
<h2 class="calibre42">The Responder Chain</h2>

<p class="author1">Now I want to tell you about nil-targeted actions. To do that, I need first to explain the responder chain.</p>

<p class="author1">Whenever the user does something with a finger (sets it down on the screen, moves it, raises it from the screen), a touch object (UITouch) is used to represent that finger. UIEvents are the lowest-level objects charged with communication of touch objects to your app; a UIEvent is basically a timestamp (a Double) along with a collection (Set) of touch objects. As I said in the previous section, you can receive a UIEvent along with a control event, but you will rarely need to do so.</p>

<p class="author1">A <em class="calibre11">responder</em> is an object that knows how to receive UIEvents directly.<a data-type="indexterm" data-primary="responder" id="calibre_link-1914" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> It is an instance of UIResponder<a data-type="indexterm" data-primary="UIResponder" id="calibre_link-2258" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> or a UIResponder subclass. If you examine the Cocoa class hierarchy, youâ€™ll find that just about any class that has anything to do with display on the screen is a responder. A UIView is a responder. A UIWindow is a responder. A UIViewController is a responder. Even a UIApplication is a responder. Even the app delegate is a responder!<a data-type="indexterm" data-primary="Cocoa" data-secondary="responder chain" id="calibre_link-423" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A UIResponder has four low-level methods for receiving touch-related UIEvents:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><code class="calibre19">touchesBegan(_:with:)</code></p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">touchesMoved(_:with:)</code></p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">touchesEnded(_:with:)</code></p>
</li>
<li class="calibre12">
<p class="calibre17"><code class="calibre19">touchesCancelled(_:with:)</code></p>
</li>
</ul>

<p class="author1">These methods &mdash; the <em class="calibre11">touch methods</em> &mdash; are called to notify a responder that a touch event has occurred: the user has placed, moved, or lifted a finger from the screen. No matter how your code ultimately hears about a user-related touch event &mdash; indeed, even if your code <em class="calibre11">never</em> hears about a touch event directly &mdash; the touch was initially communicated to a responder through one of the touch methods.</p>

<p class="author1">The mechanism for this communication starts by deciding which responder the user touched. The UIView methods <code class="calibre19">hitTest(_:with:)</code> and <code class="calibre19">point(inside:with:)</code> are called until the correct view (the <em class="calibre11">hit-test view</em>) is located. Then UIApplicationâ€™s <code class="calibre19">sendEvent(_:)</code> method is called, which calls UIWindowâ€™s <code class="calibre19">sendEvent(_:)</code>, which now wants to call the correct touch method in some responder.</p>

<p class="author1">So now the runtime starts looking for a responder that <em class="calibre11">implements</em> the correct touch method, so that the touch event can be reported by calling it. That responder need not be the hit-test view! The hit-test view is just the starting place for the search. The search depends upon the fact that all the responders in your app participate in a <em class="calibre11">responder chain</em>, which essentially links them up through the view hierarchy.<a data-type="indexterm" data-primary="responder chain" id="calibre_link-1915" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
The responder chain, from bottom to top, looks roughly like this:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">The UIView that we start with (here, the hit-test view).</p>
</li>
<li class="calibre4">
<p class="calibre17">If this UIView is a UIViewControllerâ€™s <code class="calibre19">view</code>, that UIViewController.</p>
</li>
<li class="calibre4">
<p class="calibre17">The UIViewâ€™s superview.</p>
</li>
<li class="calibre4">
<p class="calibre17">Go back to step 2 and repeat! Keep repeating until we reachâ€¦</p>
</li>
<li class="calibre4">
<p class="calibre17">The UIWindow (and, new in iOS 13, the UIWindowScene).</p>
</li>
<li class="calibre4">
<p class="calibre17">The UIApplication.</p>
</li>
<li class="calibre4">
<p class="calibre17">The UIApplicationâ€™s delegate.</p>
</li>

</ol>

<p class="author1">The next responder up the responder chain is a responderâ€™s <em class="calibre11">next responder</em>, which is obtained from a responder through its <code class="calibre19">next</code> property (which returns an Optional wrapping a UIResponder). Thus the responder chain can be walked upward from any responder to the top of the chain.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Nil-Targeted Actions" class="calibre2"><div class="preface" id="calibre_link-2686">
<h2 class="calibre42">Nil-Targeted Actions</h2>

<p class="author1">A <em class="calibre11">nil-targeted</em> action is a UIControl target&ndash;action pair in which the target is <code class="calibre19">nil</code>.<a data-type="indexterm" data-primary="actions" data-secondary="nil-targeted" id="calibre_link-120" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> There is no designated target object, so the following rule is used: starting with the hit-test view (the view with which the user is interacting), Cocoa walks up the responder chain looking for an object that can respond to the action message:<a data-type="indexterm" data-primary="nil-targeted actions" id="calibre_link-1412" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If a responder is found that handles this message, that method is called on that responder, and thatâ€™s the end.</p>
</li>
<li class="calibre12">
<p class="calibre17">If we get all the way to the top of the responder chain without finding a responder to handle this message, nothing happens; the message goes unhandled, with no penalty.</p>
</li>
</ul>

<p class="author1">Here, for example, is a UIButton subclass that configures itself to call a nil-targeted action when tapped:</p>

<pre data-type="programlisting" class="calibre28">override func awakeFromNib() {
    super.awakeFromNib()
    class Dummy {
        @objc func buttonPressed(_:Any) {}
    }
    self.addTarget(nil, // nil-targeted
        action: #selector(Dummy.buttonPressed),
        for: .touchUpInside)
}</pre>

<p class="author1">Thatâ€™s a nil-targeted action. So what happens when the user taps the button? First, Cocoa looks in the UIButton itself to see whether it responds to <code class="calibre19">buttonPressed</code>. If not, it looks in the UIView that is its superview. And so on, up the responder chain. For example, there is surely a view controller that owns the view that contains the button. If the view controller is the first responder encountered in the search whose class implements <code class="calibre19">buttonPressed</code>, tapping the button will cause the view controllerâ€™s <code class="calibre19">buttonPressed</code> to be called &mdash; even though the view controller is not the target!</p>

<p class="author1">Itâ€™s obvious how to construct a nil-targeted action in code: you set up a target&ndash;action pair where the target is <code class="calibre19">nil</code>, as in the preceding example. But how do you construct a nil-targeted action in a nib? The answer is: you form a connection to the First Responder proxy object (in the dock).<a data-type="indexterm" data-primary="First Responder proxy object" id="calibre_link-864" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Thatâ€™s what the First Responder proxy object is for! The First Responder isnâ€™t a real object with a known class, so before you can connect an action to it, you have to define the action message within the First Responder proxy object, like this:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Select the First Responder proxy in the nib, and switch to the Attributes <span class="publishername">inspector.</span></p>
</li>
<li class="calibre4">
<p class="calibre17">Youâ€™ll see a table (probably empty) of user-defined nil-targeted First Responder actions. Click the Plus button and give the new action a name; it must take a single parameter (so that its name will end with a colon).</p>
</li>
<li class="calibre4">
<p class="calibre17">Now you can Control-drag from a control, such as a UIButton, to the First Responder proxy to specify a nil-targeted action with the name you specified.</p>
</li>

</ol>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">The declaration for your action handler method (such as <code class="calibre19">buttonPressed</code>) must be marked <code class="calibre19">@objc</code> (or <code class="calibre19">@IBAction</code>). Otherwise, Cocoa wonâ€™t be able to find it as it walks up the responder chain.</p>
</div>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Keyâ€“Value Observing" class="calibre2"><div class="preface" id="calibre_link-2687">
<h1 class="calibre18">Key&ndash;Value Observing</h1>

<p class="author1">Key&ndash;value observing, or <em class="calibre11">KVO</em>, is rather like a target&ndash;action mechanism that works between <em class="calibre11">any</em> two objects. One object (the observer) registers directly with another object (the observed) so as to be notified <em class="calibre11">when a value in the observed object changes</em>. The observed object doesnâ€™t actually have to <em class="calibre11">do</em> anything; when the value in the observed object changes, the observer is <em class="calibre11">automatically</em> notified.<a data-type="indexterm" data-primary="keyâ€“value observing" id="calibre_link-1190" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="KVO" id="calibre_link-1195" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Cocoa" data-secondary="keyâ€“value observing" id="calibre_link-419" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The process of using KVO may be broken down into stages:</p>
<dl class="calibre14">
<dt class="calibre15">Registration</dt>
<dd class="calibre16">
<p class="calibre17">The observer &mdash; that is, the object that desires to hear about future changes in a value belonging to the observed object &mdash; must register with that observed object.</p>
</dd>
<dt class="calibre15">Change</dt>
<dd class="calibre16">
<p class="calibre17">A change takes place in the value belonging to the observed object, and it must take place in a special way &mdash; a KVO compliant way. Typically, this means using a key&ndash;value coding compliant accessor to make the change. Setting a property passes through a key&ndash;value coding compliant accessor.</p>
</dd>
<dt class="calibre15">Notification</dt>
<dd class="calibre16">
<p class="calibre17">The observer is automatically notified that the value in the observed object has changed.</p>
</dd>
<dt class="calibre15">Unregistration</dt>
<dd class="calibre16">
<p class="calibre17">The observer eventually unregisters to prevent the arrival of further notifications about the observed value of the observed object.</p>
</dd>
</dl>

<p class="author1">As with notifications and delegations, you can use KVO with Cocoa objects or you can implement it as a form of communication between your own objects. When you use KVO with Cocoa:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The observer will be <em class="calibre11">your</em> object; you will write the code that will respond when the observer is notified of the change for which it has registered.</p>
</li>
<li class="calibre12">
<p class="calibre17">The observed object will be <em class="calibre11">Cocoaâ€™s</em> object. Many Cocoa objects promise to behave in a KVO compliant way. Certain frameworks, such as the AVFoundation framework, donâ€™t implement delegation or notifications very much; instead, they expect you to use KVO to hear about what they are doing. Thus, KVO notifications can be an important form of Cocoa event.</p>
</li>
</ul>

<p class="author1">When you use KVO with your own observed object, you have to configure that object to to be KVO compliant for one or more values. Iâ€™ll explain later how to do that.</p>








<section data-type="sect2" data-pdf-bookmark="Registration and Notification" class="calibre2"><div class="preface" id="calibre_link-2688">
<h2 class="calibre42">Registration and Notification</h2>

<p class="author1">The Cocoa API for registration and notification works in two different ways. The first way is the Cocoa way; it basically just translates the Objective-C API directly into Swift. The second way is provided by Swift; it uses the Cocoa way under the hood, but it shields you from some of the messy details.</p>

<p class="author1">Iâ€™ll describe the Cocoa way just so that you understand the mess that the Swift way shields you from. In the Cocoa way, you call <code class="calibre19">addObserver(_:forKeyPath:options:context:)</code> on the object whose property you want to observe, using a Cocoa key path (<a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>). Subsequently, the observerâ€™s <code class="calibre19">observeValue(forKeyPath:of:change:context:)</code> is called for every change for which this observer has been registered. This single observer method constitutes a nasty bottleneck, especially if this observer is observing more than one value, possibly in more than one observed object. Thatâ€™s what the Swift way protects you from.<a data-type="indexterm" data-primary="registering for keyâ€“value observing" id="calibre_link-1884" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s how the Swift way works. You register by calling <code class="calibre19">observe(_:options:changeHandler:)</code> on the object whose property you want to observe, with these parameters:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">keyPath:</code></dt>
<dd class="calibre16">
<p class="calibre17">The first parameter is a Swift key path (<a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>), not a Cocoa key path.</p>
</dd>
<dt class="calibre15"><code class="calibre19">options:</code></dt>
<dd class="calibre16">
<p class="calibre17">An NSKeyValueObservingOptions bitmask (an option set) specifying such things as when you want to be notified (only when the observed value changes, or now as well) and what information you want included in the notification (the old value, the new value, or both).</p>
</dd>
<dt class="calibre15"><code class="calibre19">changeHandler:</code></dt>
<dd class="calibre16">
<p class="calibre17">A function to be called as a way of sending the notification. It will typically be an anonymous function, thus making it part of the registration. It should take two parameters:</p>
<dl class="calibre14">
<dt class="calibre15">The object</dt>
<dd class="calibre16">
<p class="calibre17">This will be the observed object with which we are registered.</p>
</dd>
<dt class="calibre15">The change</dt>
<dd class="calibre16">
<p class="calibre17">An NSKeyValueObservedChange object. Its properties give you information such as the old value and the new value if you requested them in the <code class="calibre19">options:</code> argument.</p>
</dd>
</dl>
</dd>
</dl>

<p class="author1">The Swift key&ndash;value observing API is a <em class="calibre11">language</em> feature, not an SDK feature. It puts a convenient mechanism in front of the Cocoa API, but it still <em class="calibre11">uses</em> the Cocoa API. When you call <code class="calibre19">observe(_:options:changeHandler:)</code>, Swift calls <code class="calibre19">addObserver(_:forKeyPath:options:context:)</code> to register the observer with the observed object. And the NSKeyValueObservation object implements the bottleneck method <code class="calibre19">observeValue(forKeyPath:of:change:context:)</code> to receive notification messages, which it passes on to you.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Unregistering" class="calibre2"><div class="preface" id="calibre_link-2689">
<h2 class="calibre42">Unregistering</h2>

<p class="author1">Unregistration is performed through a message to the observed object, namely <code class="calibre19">removeObserver(_:forKeyPath:context:)</code>. If the observer goes out of existence without unregistering, the observed object might later try to send a message to a nonexistent observer, resulting in a crash. So the observer needs to maintain a reference to the observed object and, at the latest, must unregister itself when going out of existence.<a data-type="indexterm" data-primary="unregistering for keyâ€“value observing" id="calibre_link-2288" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">That can be a daunting responsibility &mdash; and is yet another thing that the Swift API helps you with. The original registration call to <code class="calibre19">observe(_:options:changeHandler:)</code> returns an object of class NSKeyValueObservation. <em class="calibre11">That</em> is the registered observer &mdash; and <em class="calibre11">it</em> maintains a reference to the observed object, so you donâ€™t have to. It will unregister itself (by calling <code class="calibre19">removeObserver(_:forKeyPath:context:)</code> on the observed object) either if you send it the <code class="calibre19">invalidate</code> message or <em class="calibre11">automatically</em> when it itself is about to go out of existence.</p>

<p class="author1">Your job is to capture the NSKeyValueObservation object and maintain it, probably in an instance property of the observer. Thatâ€™s all, because this means it will go out of existence, at the latest, when the observer does &mdash; and at that moment will unregister itself in good order. But you <em class="calibre11">must</em> capture and maintain that object somehow! If you donâ€™t, it will go out of existence and unregister itself <em class="calibre11">immediately</em> &mdash; before a notification is ever sent &mdash; and thus youâ€™ll never get any notifications in the first place.</p>

<p class="author1">Another problem is what happens if <em class="calibre11">the observed object</em> goes out of existence when observers are still registered on it. There are two cases:</p>
<dl class="calibre14">
<dt class="calibre15">In iOS 11 and later</dt>
<dd class="calibre16">
<p class="calibre17">Nothing happens. This isnâ€™t anything to worry about.</p>
</dd>
<dt class="calibre15">In iOS 10 and before</dt>
<dd class="calibre16">
<p class="calibre17">Your app will crash immediately. To prevent that, if the observed object is about to go out of existence while the observer continues to exist, you must unregister the NSKeyValueObservation object explicitly by sending it <code class="calibre19">invalidate</code>.</p>
</dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Keyâ€“Value Observing Example" class="calibre2"><div class="preface" id="calibre_link-2690">
<h2 class="calibre42">Key&ndash;Value Observing Example</h2>

<p class="author1">To demonstrate KVO, Iâ€™ll declare classes to play both roles, the observer and the observed.</p>

<p class="author1">First, the observed. My Observed class has a <code class="calibre19">value</code> instance property that we want other objects to be able to observe:</p>

<pre data-type="programlisting" class="calibre28">class Observed : NSObject { <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-75" href="#calibre_link-73"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    @objc dynamic var value : Bool = false <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-76" href="#calibre_link-74"><img src="images/000008.png" alt="2" class="calibre39" /></a>
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-73" href="#calibre_link-75"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The observed objectâ€™s class must derive from NSObject; otherwise, you wonâ€™t be able to call <code class="calibre19">observe(_:options:changeHandler:)</code> on it. Thatâ€™s because the mechanism for being observed is a feature of NSObject.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-74" href="#calibre_link-76"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The property to be observed must be declared <code class="calibre19">@objc</code> in order to expose it to Objective-C &mdash; and it must also be declared <code class="calibre19">dynamic</code>. Thatâ€™s because KVO works by <em class="calibre11">swizzling</em> the accessor methods; Cocoa needs to be able to reach right in and change this objectâ€™s code, and it canâ€™t do that unless the property is <code class="calibre19">dynamic</code>.<a data-type="indexterm" data-primary="dynamic" id="calibre_link-719" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="dynamic" id="calibre_link-1752" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="swizzling" id="calibre_link-2183" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
</dl>

<p class="author1">The Observer class contains code that registers with an Observed to hear about changes in its <code class="calibre19">value</code> property:</p>

<pre data-type="programlisting" class="calibre28">class Observer {
    var obs = Set&lt;NSKeyValueObservation&gt;() <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-80" href="#calibre_link-77"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    func registerWith(_ observed:Observed) {
        let opts : NSKeyValueObservingOptions = [.old, .new]
        let ob = observed.observe(\.value, options: opts) { obj,change in <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-81" href="#calibre_link-78"><img src="images/000008.png" alt="2" class="calibre39" /></a>
            if let oldValue = change.oldValue {
                print("old value was \(oldValue)")
            }
            if let newValue = change.newValue {
                print("new value is \(newValue)")
            }
        }
        obs.insert(ob) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-82" href="#calibre_link-79"><img src="images/000029.png" alt="3" class="calibre39" /></a>
    }
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-77" href="#calibre_link-80"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Observer has an instance property for maintaining NSKeyValueObservation objects. As with Notification observer tokens (discussed earlier in this chapter), I like to use a Set for this purpose.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-78" href="#calibre_link-81"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">Observer (in its <code class="calibre19">registerWith(_:)</code> method) will register with an Observed instance by calling <code class="calibre19">observe(_:options:changeHandler:)</code>, using a Swift key path to specify the <code class="calibre19">value</code> property. Iâ€™ve illustrated the use of <span class="publishername">NSKeyValueObservingOptions</span> by asking for both the old and new values of the observed property when a notification arrives. That information will arrive into the notification function inside an NSKeyValueObservedChange object.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-79" href="#calibre_link-82"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The call to <code class="calibre19">observe(_:options:changeHandler:)</code> returns an NSKeyValueObservation object. It is <em class="calibre11">crucial</em> to ensure the continued existence of this object; otherwise, it will go out of existence and unregister itself before the notification can ever arrive. Therefore, I immediately store it in the Set instance property that was declared for this purpose.</p></dd>
</dl>

<p class="author1">Presume now that we have a persistent Observer instance, <code class="calibre19">observer</code>, and that its <code class="calibre19">registerWith(_:)</code> has been called with argument <code class="calibre19">observed</code>, an Observed instance that is also persistent. So much for registration!</p>

<p class="author1">Now letâ€™s talk about change and notification. Somehow, someone sets <code class="calibre19">observed</code>â€™s <code class="calibre19">value</code> to <code class="calibre19">true</code>, thus changing it in a KVO compliant way. At that moment, the notification is sent and the anonymous function is called! The following appears in the console:</p>

<pre data-type="programlisting" class="calibre28">old value was false
new value is true</pre>

<p class="author1">Finally, letâ€™s talk about unregistering. As long as we are running in iOS 11 or later, there is nothing to talk about! It doesnâ€™t matter whether <code class="calibre19">observed</code> or <code class="calibre19">observer</code> goes out of existence first; everything happens automatically and in good order:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If <code class="calibre19">observed</code> goes out of existence first, there is no crash and there will be no further notifications.</p>
</li>
<li class="calibre12">
<p class="calibre17">When <code class="calibre19">observer</code> goes out of existence, the <code class="calibre19">obs</code> property is destroyed, and so the NSKeyValueObservation object is destroyed &mdash; and at that moment, if <code class="calibre19">observed</code> still exists, the NSKeyValueObservation object unregisters itself (and if <code class="calibre19">observed</code> no longer exists, nothing bad happens).</p>
</li>
</ul>

<p class="author1">In general your real-life use of KVO in programming iOS will likely be no more complex than that. Cocoa key&ndash;value observing, however, is a deep and complex mechanism; consult Appleâ€™s <em class="calibre11">Key-Value Observing Programming Guide</em> in the documentation archive for full information.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Swamped by Events" class="calibre2"><div class="preface" id="calibre_link-2691">
<h1 class="calibre18">Swamped by Events</h1>

<p class="author1">Cocoa has the potential to send <em class="calibre11">lots</em> of events, telling you what the user has done, informing you of each stage in the lifetime of your app and its objects, asking for your input on how to proceed. To receive the events that you need to hear about, your code is peppered with <em class="calibre11">entry points</em> &mdash; methods that you have written with just the right name and in just the right class so that they can be called as Cocoa events. In fact, it is easy to imagine that in many cases your code for a class will consist almost entirely of entry points.<a data-type="indexterm" data-primary="entry point" data-secondary="code" id="calibre_link-741" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="event-based programming" id="calibre_link-810" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Arranging all those entry points is one of your primary challenges as a Cocoa programmer. You know what you want to do, but you donâ€™t get to â€œjust do it.â€ You have to divide up your appâ€™s functionality and allocate it in accordance with when and how Cocoa is going to call into your code. You know the events that Cocoa is going to want to send you, and you need to be prepared to receive them. Thus, before youâ€™ve written a single line of your own code, the skeleton structure of a class is likely to have been largely mapped out for you.</p>

<p class="author1">Suppose, for example, that your iPhone app presents an interface consisting of a table view. Youâ€™ll probably subclass UITableViewController (a built-in UIViewController subclass); an instance of your subclass will own and control the table view, and youâ€™ll probably use it as the table viewâ€™s data source and delegate as well. In this single class, then, youâ€™re likely to want to implement <em class="calibre11">at a minimum</em> the following methods:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">init(coder:)</code> or <code class="calibre19">init(nibName:bundle:)</code></dt>
<dd class="calibre16">
<p class="calibre17">UIViewController lifetime method, where you perform instance initializations.</p>
</dd>
<dt class="calibre15"><code class="calibre19">viewDidLoad</code></dt>
<dd class="calibre16">
<p class="calibre17">UIViewController lifetime method, where you perform view-related initializations and deferred initializations.</p>
</dd>
<dt class="calibre15"><code class="calibre19">viewDidAppear</code></dt>
<dd class="calibre16">
<p class="calibre17">UIViewController lifetime method, where you set up states that need to apply only while your view is onscreen. For example, if youâ€™re going to register for a notification or set up a timer, this is a likely place to do it.</p>
</dd>
<dt class="calibre15"><code class="calibre19">viewDidDisappear</code></dt>
<dd class="calibre16">
<p class="calibre17">UIViewController lifetime method, where you reverse what you did in <code class="calibre19">viewDidAppear</code>. For example, this would be a likely place to unregister for a notification or invalidate a repeating timer that you set up in <code class="calibre19">viewDidAppear</code>.</p>
</dd>
<dt class="calibre15"><code class="calibre19">supportedInterfaceOrientations</code></dt>
<dd class="calibre16">
<p class="calibre17">UIViewController query method, where you specify what device orientations are allowed for this view controllerâ€™s main view.</p>
</dd>
<dt class="calibre15"><code class="calibre19">numberOfSections(in:)</code></dt>
<dt class="calibre15"><code class="calibre19">tableView(_:numberOfRowsInSection:)</code></dt>
<dt class="calibre15"><code class="calibre19">tableView(_:cellForRowAt:)</code></dt>
<dd class="calibre16">
<p class="calibre17">UITableView data source query methods, where you specify the contents of the table.</p>
</dd>
<dt class="calibre15"><code class="calibre19">tableView(_:didSelectRowAt:)</code></dt>
<dd class="calibre16">
<p class="calibre17">UITableView delegate user action method, where you respond when the user taps a row of the table.</p>
</dd>
<dt class="calibre15"><code class="calibre19">deinit</code></dt>
<dd class="calibre16">
<p class="calibre17">Swift class instance lifetime method, where you perform end-of-life cleanup.</p>
</dd>
</dl>

<p class="author1">Suppose, further, that you do in fact use <code class="calibre19">viewDidAppear</code> to register for a notification and to set up a timer, using the target&ndash;selector architecture; then you must also implement the methods specified by those selectors.</p>

<p class="author1">We already have, then, about a dozen methods whose presence is effectively boilerplate. These are not <em class="calibre11">your</em> methods; <em class="calibre11">you</em> are never going to call them. They are <em class="calibre11">Cocoaâ€™s</em> methods, which you have placed here so that each can be called at the appropriate moment in the life story of your app.</p>

<p class="author1">A Cocoa program thus consists of numerous disconnected entry points, each with its own meaning, each called at its own set moment. The logic of such a program is far from obvious; a Cocoa program, even <em class="calibre11">your</em> program, even while youâ€™re writing it, is hard to read and hard to understand. To figure out what our hypothetical class does, you have to know <em class="calibre11">already</em> such things as when <code class="calibre19">viewDidAppear</code> is called and how it is typically used; otherwise, you donâ€™t know what this method is for. Moreover, because of your codeâ€™s object-oriented structure, multiple methods in this class (and perhaps others) will be managing the same instance properties; your programâ€™s logic is divided among methods and even among classes.</p>

<p class="author1">Your challenges are compounded by surprises involving the <em class="calibre11">order</em> of events. Beginners (and even experienced programmers) are often mystified when their program doesnâ€™t work as expected, because they have wrong expectations about <em class="calibre11">when</em> an entry point will be called, or what the state of an instance will be when it <em class="calibre11">is</em> called. To make matters worse, the order of events isnâ€™t even reliable; my apps often break when I upgrade them from one iOS version to the next, because the new version of iOS is sending certain events in a different order from the old version.</p>

<p class="author1">How will you find your way through the swamp of events that a Cocoa program consists of? Thereâ€™s no easy solution, but hereâ€™s some simple advice:</p>
<dl class="calibre14">
<dt class="calibre15">Write comments</dt>
<dd class="calibre16">
<p class="calibre17">Comment every method, quite heavily if need be, saying what that method does and under what circumstances you expect it to be called &mdash; especially if it is an entry point, where it is Cocoa itself that will do the calling.</p>
</dd>
<dt class="calibre15">Debug</dt>
<dd class="calibre16">
<p class="calibre17">Instrument your code heavily during development with caveman debugging (see <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>). As you test your code, keep an eye on the console output and check whether the messages make sense. You may be surprised at what you discover. If things donâ€™t work as expected, add breakpoints and run the app again so you can see the order of execution and watch the variables and properties as they change.</p>
</dd>
</dl>

<p class="author1">Perhaps the most common kind of mistake in writing a Cocoa app is not that thereâ€™s a bug in your code itself, but that youâ€™ve put the code <em class="calibre11">in the wrong place</em>. Your code isnâ€™t running, or itâ€™s running at the wrong time, or the pieces are running in the wrong order. I see questions about this sort of thing all the time on the various online user forums (these are all actual examples that appeared over the course of just two days):<a data-type="indexterm" data-primary="code" data-secondary="location" id="calibre_link-437" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17"><em class="calibre11">Thereâ€™s a delay between the time when my view appears and when my button takes on its correct title.</em></p>

<p class="calibre17">Thatâ€™s because you put the code that sets the buttonâ€™s title in <code class="calibre19">viewDidAppear</code>. Thatâ€™s <em class="calibre11">too late</em>; your code needs to run earlier, perhaps in <code class="calibre19">viewWillAppear</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17"><em class="calibre11">My subviews are positioned in code and theyâ€™re turning out all wrong.</em></p>

<p class="calibre17">Thatâ€™s because you put the code that positions your subviews in <code class="calibre19">viewDidLoad</code>. Thatâ€™s <em class="calibre11">too early</em>; your code needs to run later, when your viewâ€™s dimensions have been determined.</p>
</li>
<li class="calibre12">
<p class="calibre17"><em class="calibre11">My view is rotating even though my view controllerâ€™s <code class="calibre22">supportedInterfaceOrientations</code> says not to.</em></p>

<p class="calibre17">Thatâ€™s because you implemented <code class="calibre19">supportedInterfaceOrientations</code> in the <em class="calibre11">wrong class</em>. Only the topmost view controller in the view controller hierarchy is consulted through this property.</p>
</li>
<li class="calibre12">
<p class="calibre17"><em class="calibre11">I set up an action connection for Value Changed on a text field, but my code isnâ€™t being called when the user edits.</em></p>

<p class="calibre17">Thatâ€™s because you connected the <em class="calibre11">wrong control event</em>; a text field emits Editing Changed, not Value Changed.</p>
</li>
</ul>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Delayed Performance" class="calibre2"><div class="preface" id="calibre_link-2692">
<h1 class="calibre18">Delayed Performance</h1>

<p class="author1">Your code is executed in response to some event; but your code in turn may trigger a new event or chain of events. Sometimes this causes bad things to happen: there might be a crash, or Cocoa might appear not to have done what you said to do. To solve this problem, sometimes you just need to step outside Cocoaâ€™s own chain of events for a moment and wait for everything to settle down before proceeding.</p>

<p class="author1">The technique for doing this is called <em class="calibre11">delayed performance</em>.<a data-type="indexterm" data-primary="delayed performance" id="calibre_link-641" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> You tell Cocoa to do something, not right this moment, but in a little while, when things have settled down. Perhaps you need only a very short delay,
just to let Cocoa finish doing something, such as laying out the interface. Technically, youâ€™re allowing the current run loop to finish, completing and unwinding the entire current call stack, before proceeding further with your own code.</p>

<p class="author1">When you program Cocoa, youâ€™re likely to be using delayed performance a lot more than you might expect. With experience, youâ€™ll develop a kind of sixth sense for when delayed performance might be the solution to your difficulties.</p>

<p class="author1">The main way to get delayed performance is by calling DispatchQueueâ€™s <code class="calibre19">after(when:execute:)</code> method. It takes a function stating what should happen after the specified time has passed. Hereâ€™s a utility function that encapsulates the call:</p>

<pre data-type="programlisting" class="calibre28">func delay(_ delay:Double, closure:@escaping () -&gt; ()) {
    let when = DispatchTime.now() + delay
    DispatchQueue.main.asyncAfter(deadline: when, execute: closure)
}</pre>

<p class="author1">That utility function is so important that I routinely paste it at the top level of the AppDelegate class file in every app I write.
To use it, I call <code class="calibre19">delay</code> with a delay time (usually a very small number of seconds such as <code class="calibre19">0.1</code>) and an anonymous function saying what to do after the delay. Note that what you propose to do in this anonymous function will be done later on; youâ€™re deliberately breaking out of your own codeâ€™s line-by-line sequence of execution. So a delayed performance call will typically be the last call in its own surrounding function, and cannot return any value.</p>

<p class="author1">In this example from one of my own apps, the user has tapped a row of a table, and my code responds by creating and showing a new view controller:</p>

<pre data-type="programlisting" class="calibre28">override func tableView(_ tableView: UITableView,
    didSelectRowAt indexPath: IndexPath) {
        let t = TracksViewController(
            mediaItemCollection: self.albums[indexPath.row])
        self.navigationController?.pushViewController(t, animated: true)
}</pre>

<p class="author1">Unfortunately, the innocent-looking call to my TracksViewController initializer <code class="calibre19">init(mediaItemCollection:)</code> can take a moment to complete, so the app comes to a stop with the table row highlighted &mdash; very briefly, but just long enough to startle the user. To cover this delay with a sense of activity, Iâ€™ve rigged my UITableViewCell subclass to show a spinning activity indicator when itâ€™s selected:</p>

<pre data-type="programlisting" class="calibre28">override func setSelected(_ selected: Bool, animated: Bool) {
    if selected {
        self.activityIndicator.startAnimating()
    } else {
        self.activityIndicator.stopAnimating()
    }
    super.setSelected(selected, animated: animated)
}</pre>

<p class="author1">But thereâ€™s a problem: the spinning activity indicator never appears and never spins. The reason is that the events are stumbling over one another here. UITableViewCellâ€™s <code class="calibre19">setSelected(_:animated:)</code> isnâ€™t called until the UITableView delegate method <code class="calibre19">tableView(_:didSelectRowAt:)</code> has finished. But the delay weâ€™re trying to paper over is <em class="calibre11">during</em> <code class="calibre19">tableView(_:didSelectRowAt:)</code>; the whole problem is that it <em class="calibre11">doesnâ€™t</em> finish fast enough.</p>

<p class="author1">Delayed performance to the rescue! Iâ€™ll rewrite <code class="calibre19">tableView(_:didSelectRowAt:)</code> so that it finishes immediately &mdash; thus triggering <code class="calibre19">setSelected(_:animated:)</code> immediately and causing the activity indicator to appear and spin &mdash; and Iâ€™ll use delayed performance to call <code class="calibre19">init(mediaItemCollection:)</code> later on, when the interface has <span class="publishername">ironed</span> itself out:</p>

<pre data-type="programlisting" class="calibre28">override func tableView(_ tableView: UITableView,
    didSelectRowAt indexPath: IndexPath) {
        delay(0.1) {
            let t = TracksViewController(
                mediaItemCollection: self.albums[indexPath.row])
            self.navigationController?.pushViewController(t, animated: true)
        }
}</pre>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-83">
<div id="calibre_link-3011" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 12. Memory Management" class="calibre2"><div class="preface" id="calibre_link-49">
<h1 class="calibre13"><span class="label">Chapter 12. </span>Memory Management</h1>


<p class="author1">Classes, both in Swift and in Objective-C, are <em class="calibre11">reference types</em> (see <a data-type="xref" href="#calibre_link-65" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œValue Types and Reference Typesâ€</a>). Behind the scenes, Swift and Objective-C memory management for reference types works essentially the same way. Such memory management, as I pointed out in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, can be a tricky business.</p>

<p class="author1">Fortunately, Swift uses ARC (automatic reference counting), so you donâ€™t have to manage the memory for every reference type object explicitly and individually, as was once necessary in Objective-C. Thanks to ARC, you are far less likely to make a memory management mistake, and more of your time is liberated to concentrate on what your app actually does instead of dealing with memory management concerns.<a data-type="indexterm" data-primary="ARC" data-seealso="memory management" id="calibre_link-169" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Still, even in Swift, even with ARC, it is possible to make a memory management mistake, or to be caught unawares by Cocoaâ€™s memory management behavior. A memory management mistake can lead to runaway excessive memory usage, crashes, or mysterious misbehavior of your app. Cocoa memory management can be surprising in individual cases, and you need to understand, and prepare for, what Cocoa is going to do.<a data-type="indexterm" data-primary="Cocoa" data-secondary="memory management" id="calibre_link-420" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" id="calibre_link-1286" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>






<section data-type="sect1" data-pdf-bookmark="Principles of Cocoa Memory Management" class="calibre2"><div class="preface" id="calibre_link-2693">
<h1 class="calibre18">Principles of Cocoa Memory Management</h1>

<p class="author1">The reason why reference type memory must be managed at all is that references to reference type objects are merely pointers to the actual object, and there can be multiple references (pointers) to the very same object. This means that every reference must deal carefully with that object, out of consideration for the needs of other possible references. At the very latest, the object <em class="calibre11">should</em> go out of existence when there are <em class="calibre11">no</em> pointers to it. But so long as there are <em class="calibre11">any</em> pointers to it, the object must <em class="calibre11">not</em> go out of existence.</p>

<p class="author1">To illustrate, imagine three objects, Manny, Moe, and Jack, where both Manny and Moe have references to Jack. Jack is the object whose memory we are concerned to manage:</p>
<dl class="calibre14">
<dt class="calibre15">The object must not go out of existence too late</dt>
<dd class="calibre16">
<p class="calibre17">If both Manny and Moe go out of existence, and if no other object has a reference to Jack, Jack should go out of existence too. An object without a pointer to it is useless; it is occupying memory, but no other object has, or can ever get, a reference to it. This is a <em class="calibre11">memory leak</em>.<a data-type="indexterm" data-primary="leaks, memory" id="calibre_link-1218" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory leaks" id="calibre_link-1282" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="leaks" id="calibre_link-1302" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">The object must not go out of existence too soon</dt>
<dd class="calibre16">
<p class="calibre17">If both Manny and Moe have a pointer to Jack, and if Manny somehow causes Jack to go out of existence, poor old Moe is left with a pointer to nothing (or worse, to garbage). A pointer whose object has been destroyed behind the pointerâ€™s back is a <em class="calibre11">dangling pointer</em>. If Moe subsequently uses that dangling pointer to send a message to the object that he thinks is there, the app will crash.<a data-type="indexterm" data-primary="pointers" data-secondary="dangling" id="calibre_link-1706" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="dangling pointers" id="calibre_link-598" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="dangling pointers" id="calibre_link-1294" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">To prevent both memory leakage and dangling pointers, there is a policy of manual memory management based on a number, maintained by every reference type object, called its <em class="calibre11">retain count</em>.<a data-type="indexterm" data-primary="retain count" id="calibre_link-1921" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> The rule is that other objects can increment or decrement an objectâ€™s retain count &mdash; and thatâ€™s all they are allowed to do. As long as an objectâ€™s retain count is positive, the object will persist. No object has the direct power to tell another object to be destroyed; rather, as soon as an objectâ€™s retain count is decremented to zero, it is destroyed automatically.</p>

<p class="author1">By this policy, every object that needs Jack to persist should increment Jackâ€™s retain count, and should decrement it once again when it no longer needs Jack to persist. As long as all objects are well-behaved in accordance with this policy, the problem of manual memory management is effectively solved:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">There cannot be any dangling pointers, because any object that has a pointer to Jack has incremented Jackâ€™s retain count, thus ensuring that Jack persists.</p>
</li>
<li class="calibre12">
<p class="calibre17">There cannot be any memory leaks, because any object that no longer needs Jack decrements Jackâ€™s retain count. If every object that doesnâ€™t need Jack any longer behaves this way, then when <em class="calibre11">no</em> object needs Jack any longer, Jackâ€™s retain count will reach zero and Jack will go out of existence.</p>
</li>
</ul>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Rules of Cocoa Memory Management" class="calibre2"><div class="preface" id="calibre_link-2694">
<h1 class="calibre18">Rules of Cocoa Memory Management</h1>

<p class="author1">An object is well-behaved with respect to memory management as long as it adheres to certain very simple, well-defined rules in conformity with the basic concepts of memory management. The underlying ethic is that <em class="calibre11">each</em> object that has a reference to a reference type object is responsible solely for <em class="calibre11">its own</em> memory management of that object, in accordance with these rules. If <em class="calibre11">all</em> objects that ever get a reference to this reference type object behave correctly with respect to these rules, the objectâ€™s memory will be managed correctly and it will go out of existence exactly when it is no longer needed:<a data-type="indexterm" data-primary="retain" id="calibre_link-1920" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">If Manny or Moe <em class="calibre11">explicitly instantiates</em> Jack &mdash; by directly calling an initializer &mdash; then the initializer <em class="calibre11">increments</em> Jackâ€™s retain count.</p>
</li>
<li class="calibre12">
<p class="calibre17">If Manny or Moe <em class="calibre11">makes a copy</em> of Jack &mdash; by calling <code class="calibre19">copy</code> or <code class="calibre19">mutableCopy</code> or any other method with <code class="calibre19">copy</code> in its name &mdash; then the copy method <em class="calibre11">increments</em> the retain count of this new, duplicate Jack.</p>
</li>
<li class="calibre12">
<p class="calibre17">If Manny or Moe <em class="calibre11">acquires</em> a reference to Jack (not through explicit instantiation or copying), and needs Jack to <em class="calibre11">persist</em> &mdash; long enough to work with Jack in code, or long enough to be the value of an instance property &mdash; then he himself <em class="calibre11">increments</em> Jackâ€™s retain count. (This is called <em class="calibre11">retaining</em> Jack.)</p>
</li>
<li class="calibre12">
<p class="calibre17">If and only if Manny or Moe has done any of those things &mdash; that is, if Manny or Moe has ever directly or indirectly caused Jackâ€™s retain count to be incremented &mdash; then when he himself no longer needs his reference to Jack, before letting go of that reference, he <em class="calibre11">decrements</em> Jackâ€™s retain count to balance exactly all previous increments that he himself has performed. (This is called <em class="calibre11">releasing</em> Jack.) Having released Jack, Manny or Moe should then assume that Jack no longer exists, because if this causes Jackâ€™s retain count to drop to zero, Jack <em class="calibre11">will</em> no longer exist. This is the <em class="calibre11">golden rule of memory management</em> &mdash; the rule that makes memory management work coherently and correctly.<a data-type="indexterm" data-primary="golden rule of memory management" id="calibre_link-984" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="golden rule" id="calibre_link-1297" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="release" id="calibre_link-1887" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">A general way to understand the golden rule of memory management is in terms of <em class="calibre11">ownership</em>. If Manny has created, copied, or retained Jack &mdash; that is, if Manny has ever incremented Jackâ€™s retain count &mdash; Manny has asserted ownership of Jack. Both Manny and Moe can own Jack at the same time, but each is responsible only for managing his own ownership of Jack correctly. It is the responsibility of an owner of Jack eventually to decrement Jackâ€™s retain count &mdash; to release Jack, thus resigning ownership of Jack. The owner thus says: â€œJack may or may not persist after this, but as for me, Iâ€™m done with Jack, and Jack can go out of existence as far as Iâ€™m concerned.â€ At the same time, a nonowner of Jack must <em class="calibre11">never</em> release Jack. As long as all objects behave this way with respect to Jack, Jack will not leak nor will any pointer to Jack be left dangling.<a data-type="indexterm" data-primary="memory management" data-secondary="ownership" id="calibre_link-1307" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="owner" data-secondary="memory management" id="calibre_link-1657" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="What ARC Is and What It Does" class="calibre2"><div class="preface" id="calibre_link-2695">
<h1 class="calibre18">What ARC Is and What It Does</h1>

<p class="author1">Once upon a time, retaining and releasing an object was a matter of you, the programmer, literally sending <code class="calibre19">retain</code> and <code class="calibre19">release</code> messages to it. NSObject still implements <code class="calibre19">retain</code> and <code class="calibre19">release</code>, but under ARC (and in Swift) you canâ€™t call them. Thatâ€™s because ARC is calling them for you! Thatâ€™s ARCâ€™s job &mdash; to do for you what you would have had to do if memory management were still up to the programmer.<a data-type="indexterm" data-primary="memory management" data-secondary="ARC" id="calibre_link-1289" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">ARC is implemented as part of the compiler. The compiler is literally modifying your code by inserting <code class="calibre19">retain</code> and <code class="calibre19">release</code> calls behind the scenes. For example, when you receive a reference type object by calling some method, ARC immediately retains it so that it will persist for as long as this same code continues to run; then ARC releases it when the code comes to an end. Similarly, when you create or copy a reference type object, ARC knows that its retain count has been incremented, and releases it when the code comes to an end.</p>

<p class="author1">ARC is very conservative, but also very accurate. In effect, ARC retains at every juncture that might have the slightest implications for memory management: it retains when an object is received as an argument, it retains when an object is assigned to a variable, and so forth. It may even insert temporary variables, behind the scenes, to enable it to refer sufficiently early to an object so that it can retain it. But of course it eventually also releases to match.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="How Cocoa Objects Manage Memory" class="calibre2"><div class="preface" id="calibre_link-2696">
<h1 class="calibre18">How Cocoa Objects Manage Memory</h1>

<p class="author1">Built-in Cocoa objects will take ownership of objects that you hand to them, by retaining them, if it makes sense for them to do so, and will of course then balance that retain with a release later. Indeed, this is so generally true that if a Cocoa object is <em class="calibre11">not</em> going to retain an object you hand it, there will be a note to that effect in the <span class="publishername">documentation.</span><a data-type="indexterm" data-primary="collections" data-secondary="memory management" id="calibre_link-455" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="collections" id="calibre_link-1292" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A collection, such as an array or dictionary, is a particularly obvious case in point. An object can hardly be an element of a collection if that object can go out of existence at any time; so when you add an element to a collection, the collection asserts ownership of the object by retaining it. Thereafter, the collection acts as a well-behaved owner. If this is a mutable collection, then if an element is removed from it, the collection releases that element. If the collection object goes out of existence, it releases all its elements.</p>

<p class="author1">Prior to ARC, removing an object from a mutable collection constituted a potential trap. Consider the following Objective-C code:</p>

<pre data-type="programlisting" class="calibre28">id obj = myMutableArray[0]; // an NSMutableArray
[myMutableArray removeObjectAtIndex: 0]; // bad idea in non-ARC code!
// ... could crash here by referring to obj ...</pre>

<p class="author1">As I just said, when you remove an object from a mutable collection, the collection releases it. So, without ARC, the second line of that code involves an implicit release of the object that used to be the first element of <code class="calibre19">myMutableArray</code>. If this reduces the objectâ€™s retain count to zero, it will be destroyed. The pointer <code class="calibre19">obj</code> will then be a dangling pointer, and a crash may be in our future when we try to use it as if it were a real object.</p>

<p class="author1">With ARC, however, that sort of danger doesnâ€™t exist. Assigning a reference type object to a variable retains it! But we <em class="calibre11">did</em> assign this object to a variable, <code class="calibre19">obj</code>, <em class="calibre11">before</em> we removed it from the collection. Thus that code is perfectly safe, and so is its Swift equivalent:</p>

<pre data-type="programlisting" class="calibre28">let obj = myMutableArray[0] // retain
myMutableArray.removeObject(at:0) // release
// ... safe to refer to obj ...</pre>

<p class="author1">The first line retains the object. The second line releases the object, but that release balances the retain that was placed on the object when the object was placed in the collection originally. Thus the objectâ€™s retain count is still more than zero, and it continues to exist for the duration of this code.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Autorelease Pool" class="calibre2"><div class="preface" id="calibre_link-2697">
<h1 class="calibre18">Autorelease Pool</h1>

<p class="author1">When a method creates an instance and returns that instance, some memory management hanky-panky has to take place. For example, consider this simple code:</p>

<pre data-type="programlisting" class="calibre28">func makeImage() -&gt; UIImage? {
    if let im = UIImage(named:"myImage") {
        return im
    }
    return nil
}</pre>

<p class="author1">Think about the retain count of <code class="calibre19">im</code>, the UIImage we are returning. This retain count has been incremented by our call to the UIImage initializer <code class="calibre19">UIImage(named:)</code>. According to the golden rule of memory management, as we pass <code class="calibre19">im</code> out of our own control by returning it, we should decrement the retain count of <code class="calibre19">im</code>, thus balancing the increment and surrendering ownership. But when can we possibly do that? If we do it <em class="calibre11">before</em> the line <code class="calibre19">return im</code>, the retain count of <code class="calibre19">im</code> will be zero and it will vanish in a puff of smoke; we will be returning a dangling pointer. But we canâ€™t do it <em class="calibre11">after</em> the line <code class="calibre19">return im</code>, because when that line is executed, our code comes to an end.</p>

<p class="author1">Clearly, we need a way to vend this object without decrementing its retain count <em class="calibre11">now</em> &mdash; so that it stays in existence long enough for the caller to receive and work with it &mdash; while ensuring that at some future time we <em class="calibre11">will</em> decrement its retain count, so as to balance our <code class="calibre19">init(named:)</code> call and fulfill our own management of this objectâ€™s memory. The solution is something midway between releasing the object and not releasing it &mdash; ARC <em class="calibre11">autoreleases</em> it.<a data-type="indexterm" data-primary="autorelease" id="calibre_link-236" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="autorelease pool" id="calibre_link-1290" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s how autoreleasing works. Your code runs in the presence of something called an <em class="calibre11">autorelease pool</em>.<a data-type="indexterm" data-primary="pool, autorelease" id="calibre_link-1710" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> When ARC autoreleases an object, that object is placed in the autorelease pool, and a number is incremented saying how many times this object has been placed in this autorelease pool. From time to time, when nothing else is going on, the autorelease pool is automatically <em class="calibre11">drained</em>. This means that the autorelease pool releases each of its objects, the same number of times as that object was placed in this autorelease pool, and empties itself of all objects. If that causes an objectâ€™s retain count to be zero, so be it; the object is destroyed in the usual way. So autoreleasing an object is just like releasing it, but with a proviso, â€œlater, not right this second.â€</p>

<p class="author1">In general, autoreleasing and the autorelease pool are merely an implementation detail. You canâ€™t see them; they are just part of how ARC works. But sometimes, on very rare occasions, you might want to drain the autorelease pool yourself. Consider the following code (itâ€™s slightly artificial, but thatâ€™s because demonstrating the need to drain the autorelease pool isnâ€™t easy):</p>

<pre data-type="programlisting" class="calibre28">func test() {
    let path = Bundle.main.path(forResource:"001", ofType: "png")!
    for j in 0 ..&lt; 50 {
        for i in 0 ..&lt; 100 {
            let im = UIImage(contentsOfFile: path)
        }
    }
}</pre>

<p class="author1">That method does something that looks utterly innocuous; it loads an image. But it loads it repeatedly in a loop. As the loop runs, memory climbs constantly (<a data-type="xref" href="#calibre_link-84" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;12-1</a>); by the time our method comes to an end, our appâ€™s memory usage has reached almost 34MB. This is not because the images arenâ€™t being released each time through the loop; itâ€™s because a lot of <em class="calibre11">intermediate</em> objects &mdash; things youâ€™ve never even heard of, such as NSPathStore2 objects &mdash; are secondarily generated by our call to <code class="calibre19">init(contentsOfFile:)</code> <em class="calibre11">and are autoreleased</em>. As we keep looping, those objects are all sitting there, piling up in the autorelease pool by the tens of thousands, waiting for the pool to be drained. When our code finally comes to an end, the autorelease pool <em class="calibre11">is</em> drained, and our memory usage drops precipitately back down to almost nothing.</p>

<figure class="calibre32"><div id="calibre_link-84" class="figure">
<img src="images/000013.png" alt="ios9 1200" class="calibre77" />
<h6 class="calibre34"><span class="publishername">Figure 12-1. </span>Memory usage grows during a loop</h6>
</div>
</figure>

<p class="author1">Granted, 34MB isnâ€™t exactly a massive amount of memory. But you may imagine that a more elaborate inner loop might generate more and larger autoreleased objects, and that our memory usage could potentially rise quite significantly. Thus, it would be nice to have a way to drain the autorelease pool <em class="calibre11">manually</em> now and then during the course of a loop with many iterations. Swift provides such a way &mdash; the global <code class="calibre19">autoreleasepool</code> function, which takes a single argument that youâ€™ll supply as a trailing anonymous function. Before the anonymous function is called, a special temporary autorelease pool is created, and is used for all autoreleased objects thereafter. After the anonymous function exits, the temporary autorelease pool is drained and goes out of existence. Hereâ€™s the same method with an <code class="calibre19">autoreleasepool</code> call wrapping the inner loop:</p>

<pre data-type="programlisting" class="calibre28">func test() {
    let path = Bundle.main.path(forResource:"001", ofType: "png")!
    for j in 0 ..&lt; 50 {
        autoreleasepool {
            for i in 0 ..&lt; 100 {
                let im = UIImage(contentsOfFile: path)
            }
        }
    }
}</pre>

<p class="author1">The difference in memory usage is dramatic: memory holds roughly steady at less than 2MB (<a data-type="xref" href="#calibre_link-85" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;12-2</a>). Setting up and draining the temporary autorelease pool probably involves some overhead, so if possible you may want to divide your loop into an outer and an inner loop, as shown in the example, so that the autorelease pool is not set up and torn down on every iteration.</p>

<figure class="calibre32"><div id="calibre_link-85" class="figure">
<img src="images/000005.png" alt="ios9 1200b" class="calibre78" />
<h6 class="calibre34"><span class="publishername">Figure 12-2. </span>Memory usage holds steady with an autorelease pool</h6>
</div>
</figure>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Memory Management of Instance Properties" class="calibre2"><div class="preface" id="calibre_link-2698">
<h1 class="calibre18">Memory Management of Instance Properties</h1>

<p class="author1">Before ARC, managing memory for instance properties (Objective-C instance variables, <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>) was one of the trickiest parts of Cocoa programming. The correct behavior is to retain a reference type object when you assign it to a property, and then release it when either of these things happens:<a data-type="indexterm" data-primary="properties" data-secondary="memory management" id="calibre_link-1764" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="properties" id="calibre_link-1308" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">You assign a different value to the same property.</p>
</li>
<li class="calibre12">
<p class="calibre17">The instance whose instance property this is goes out of existence.</p>
</li>
</ul>

<p class="author1">Memory management for a property therefore had to be distributed in two places:</p>
<dl class="calibre14">
<dt class="calibre15">The setter method for the property</dt>
<dd class="calibre16">
<p class="calibre17">The setter must release whatever object is currently the value of the property, and must retain whatever object is being assigned to that property. The exact details can be quite tricky (what if they are the same object?), and before ARC it was easy for programmers to get them wrong.</p>
</dd>
<dt class="calibre15">The ownerâ€™s <code class="calibre19">dealloc</code> method</dt>
<dd class="calibre16">
<p class="calibre17">This is the Objective-C equivalent of <code class="calibre19">deinit</code>. This method must be implemented to release every object being retained as the value of a property, or the object will leak when the owner goes out of existence.</p>
</dd>
</dl>

<p class="author1">Fortunately, ARC understands all that, and in Swift the memory of instance properties, like the memory of all variables, is managed correctly for you.</p>

<p class="author1">That fact also gives us a clue as to how to <em class="calibre11">release an object on demand</em> when you are holding it in an instance property. This is a valuable thing to be able to do, because an object may be using a lot of memory. You donâ€™t want to put too great a strain on the deviceâ€™s memory, so you want to release the object as soon as youâ€™re done with it. Also, when your app goes into the background and is suspended, the Watchdog process will terminate it in the background if it is found to be using too much memory; so you might want to release this object when you are notified that the app is about to be backgrounded.<a data-type="indexterm" data-primary="releasing a property" id="calibre_link-1888" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="properties" data-secondary="releasing" id="calibre_link-1772" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You canâ€™t call <code class="calibre19">release</code> explicitly, so you need another way to do it, some way that is consonant with the design and behavior of ARC. The solution is to <em class="calibre11">assign something else</em> &mdash; something small &mdash; to this property. That causes the object that was previously the value of this property to be released. A commonly used approach is to type this property as an Optional. This means that <code class="calibre19">nil</code> can be assigned to it, purely as a way of replacing the object that is the instance propertyâ€™s current value and releasing it.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Retain Cycles and Weak References" class="calibre2"><div class="preface" id="calibre_link-2699">
<h1 class="calibre18">Retain Cycles and Weak References</h1>

<p class="author1">As I explained in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, you can get yourself into a retain cycle where two reference type objects have references to one another: for example, each is the value of the otherâ€™s instance property. If such a situation is allowed to persist until no other objects have a reference to either of these objects, then neither can go out of existence, because each has a retain count greater than zero and neither will â€œgo firstâ€ and release the other. Since these two objects, <em class="calibre11">ex hypothesi</em>, can no longer be referred to by any object except one another, this situation can now never be remedied &mdash; these objects are leaking.<a data-type="indexterm" data-primary="leaks, memory" id="calibre_link-1219" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory leaks" id="calibre_link-1283" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="retain cycles" id="calibre_link-1923" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="retain cycles" id="calibre_link-1312" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The solution is to step in and modify how the memory is managed for one of these references. By default, a reference is a strong reference: assigning to it retains the assigned value. In Swift, you can declare a reference type variable as <code class="calibre19">weak</code> or as <code class="calibre19">unowned</code> to change the way its memory is <span class="publishername">managed:</span></p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">weak</code></dt>
<dd class="calibre16">
<p class="calibre17">When a reference is <code class="calibre19">weak</code>, ARC does <em class="calibre11">not</em> retain the object assigned to it. This seems dangerous, because it means that the object might go out of existence behind our backs, leaving us with a dangling pointer and leading to a potential crash later on. But ARC is very clever about this. A reference marked as <code class="calibre19">weak</code> <em class="calibre11">must be a <code class="calibre22">var</code> reference to an Optional</em>. ARC keeps track of all weak references and all objects assigned to them. When such an objectâ€™s retain count drops to zero and the object is about to be destroyed, just before the objectâ€™s <code class="calibre19">deinit</code> is called, ARC sneaks in and assigns <code class="calibre19">nil</code> to the reference. Thus, provided you handle the Optional coherently (by coping with the fact that it might suddenly be <code class="calibre19">nil</code>), nothing bad can happen.<a data-type="indexterm" data-primary="weak references" id="calibre_link-2362" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="weak references" id="calibre_link-1321" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="weak" id="calibre_link-1879" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15"><code class="calibre19">unowned</code></dt>
<dd class="calibre16">
<p class="calibre17">An <code class="calibre19">unowned</code> reference is a different kettle of fish. When you mark a reference as <code class="calibre19">unowned</code>, youâ€™re telling ARC to take its hands off completely: it does no memory management at all when something is assigned to this reference. This really <em class="calibre11">is</em> dangerous &mdash; if the object referred to goes out of existence, you really <em class="calibre11">can</em> be left with a dangling pointer and you really <em class="calibre11">can</em> crash. That is why you must never use <code class="calibre19">unowned</code> unless you know that the object referred to will <em class="calibre11">not</em> go out of existence: <code class="calibre19">unowned</code> is safe, provided the object referred to will outlive the object that refers to it. So an <code class="calibre19">unowned</code> reference should point at all times to some single independent object, retained in some other way,
without which the referrer cannot exist at all.<a data-type="indexterm" data-primary="unowned references" id="calibre_link-2285" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="unowned references" id="calibre_link-1317" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="unowned" id="calibre_link-1876" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">A weak reference is commonly used to connect an object to its delegate (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>):</p>

<pre data-type="programlisting" class="calibre28">class ColorPickerController : UIViewController {
    weak var delegate: ColorPickerDelegate?
    // ...
}</pre>

<p class="author1">A delegate is an independent entity; there is usually no reason why an object needs to claim ownership of its delegate. Indeed, an object is usually its delegateâ€™s servant, not its owner, and ownership, if there is any, runs the other way; Object A might create <em class="calibre11">and retain</em> Object B, and make itself Object Bâ€™s delegate:</p>

<pre data-type="programlisting" class="calibre28">let cpc = ColorPickerController(colorName:colorName, color:c)
cpc.delegate = self
self.present(cpc, animated: true) // retains cpc</pre>

<p class="author1">Thereâ€™s no danger of a retain cycle in that code, because the <code class="calibre19">delegate</code> property is <code class="calibre19">weak</code>. This view controller (<code class="calibre19">self</code>) is not somehow retaining itself.<a data-type="indexterm" data-primary="memory management" data-secondary="delegates" id="calibre_link-1296" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="delegate" data-secondary="memory management" id="calibre_link-643" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Very rarely, you may encounter properties of built-in Cocoa classes that keep weak references as <em class="calibre11">non-ARC</em> weak references (because they are old and backward-compatible, whereas ARC is new). Such properties are declared in Objective-C using the keyword <code class="calibre19">assign</code>. For example, NSCacheâ€™s <code class="calibre19">delegate</code> property is declared like this:</p>

<pre data-type="programlisting" class="calibre28">@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;</pre>

<p class="author1">In Swift, that declaration is translated like this:</p>

<pre data-type="programlisting" class="calibre28">unowned(unsafe) var delegate: NSCacheDelegate?</pre>

<p class="author1">The Swift term <code class="calibre19">unowned</code> and the Objective-C term <code class="calibre19">assign</code> are synonyms; they tell you that thereâ€™s no ARC memory management here. The <code class="calibre19">unsafe</code> designation is a further warning inserted by Swift; unlike your own code, where you wonâ€™t use <code class="calibre19">unowned</code> unless it is safe, Cocoaâ€™s <code class="calibre19">unowned</code> is potentially dangerous and you need to exercise caution.<a data-type="indexterm" data-primary="unsafe references" id="calibre_link-2290" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="unsafe" id="calibre_link-1877" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="unsafe references" id="calibre_link-1318" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">A reference such as an NSCacheâ€™s <code class="calibre19">delegate</code> can end up as a dangling pointer, pointing at garbage, if the object to which that reference was pointing has gone out of existence. If anyone tries to send a message by way of such a reference, the app will then crash. This is the delegate, so what usually happens is that Cocoa tries to send it a delegate message. The tell-tale sign of such a crash is that <code class="calibre19">EXC_BAD_ACCESS</code> is reported somewhere in <code class="calibre19">objc_msgSend</code> (<a data-type="xref" href="#calibre_link-86" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Figure&nbsp;12-3</a>).<a data-type="indexterm" data-primary="crash" data-secondary="deallocated object" id="calibre_link-565" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<figure class="calibre32"><div id="calibre_link-86" class="figure">
<img src="images/000007.png" alt="ios11 1201" class="calibre79" />
<h6 class="calibre34"><span class="publishername">Figure 12-3. </span>A crash from messaging a dangling pointer</h6>
</div>
</figure>

<p class="author1">Figuring out the cause of a crash like that can be quite difficult, especially since the crash itself typically takes place long after the point where the real mistake occurred, namely that some object went out of existence while a reference to it continued to exist. You might not even know <em class="calibre11">what</em> object went out of existence. (This is the sort of situation in which you might need to â€œturn on zombiesâ€ in order to debug, as Iâ€™ll describe at the end of this chapter.)</p>

<p class="author1">Non-ARC weak references of this kind are few and far between nowadays; but they were once relatively common, so the earlier the iOS version on which youâ€™re running, the more likely you are to encounter one. Fortunately, itâ€™s easy to avoid a dangling pointer by making sure there is always something to point to. With an NSCacheâ€™s <code class="calibre19">delegate</code>, for example, if the delegate object is about to go out of existence at a time when the NSCache instance still exists, we would assign <code class="calibre19">nil</code> (or some other object) to the <code class="calibre19">delegate</code> property, thus rendering it harmless.<a data-type="indexterm" data-primary="nilifying unsafe references" id="calibre_link-1413" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="nilifying unsafe references" id="calibre_link-1305" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Unusual Memory Management Situations" class="calibre2"><div class="preface" id="calibre_link-2700">
<h1 class="calibre18">Unusual Memory Management Situations</h1>

<p class="author1">This section discusses some situations that call for some special memory management handling on your part.</p>








<section data-type="sect2" data-pdf-bookmark="Notification Observers" class="calibre2"><div class="preface" id="calibre_link-2701">
<h2 class="calibre42">Notification Observers</h2>

<p class="author1">Recall the example I gave in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>, where you register with the notification center by calling <code class="calibre19">addObserver(forName:object:queue:using:)</code>, like this:</p>

<pre data-type="programlisting" class="calibre28">let ob = NotificationCenter.default.addObserver(
    forName: .MPMusicPlayerControllerNowPlayingItemDidChange,
    object: nil, queue: nil) { _ in
        self.updateNowPlayingItem()
        // ... and so on ...
    }
self.observers.insert(ob as! NSObject)</pre>

<p class="author1">I didnâ€™t tell you at the time, but that code has the potential to cause a serious memory leak.<a data-type="indexterm" data-primary="memory management" data-secondary="notifications" id="calibre_link-1306" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="notifications" data-secondary="unregistering" id="calibre_link-1426" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="unregistering for a notification" id="calibre_link-2287" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="retain cycles" data-secondary="notifications" id="calibre_link-1926" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="notifications" data-secondary="retain cycles" id="calibre_link-1424" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
The reason is that the observer token object (<code class="calibre19">ob</code>) returned from the registration call is <em class="calibre11">retained by the notification center</em> until you unregister it. (I regard this as something of a dirty trick on the notification centerâ€™s part; I think I understand Appleâ€™s reasoning in designing things this way, but I also think they reasoned incorrectly.)</p>

<p class="author1">So the observer token object is likely to leak &mdash; but that isnâ€™t the serious part. The serious part is that the observer token object is <em class="calibre11">also</em> retaining <em class="calibre11">the view controller</em> (<code class="calibre19">self</code>) through the anonymous function. The reason is that functions are closures, and this function refers to <code class="calibre19">self</code>. So the view controller is leaking along with the observer token. Thatâ€™s bad. A view controller together with its properties, including its view, constitutes a heavyweight object and needs to go out existence when it is no longer needed. You cannot solve the problem merely by unregistering the observer token from the notification center in the view controllerâ€™s <code class="calibre19">deinit</code>, because <em class="calibre11">ex hypothesi</em> <code class="calibre19">deinit</code> isnâ€™t going to be called; that is what leaking <em class="calibre11">means</em>.<a data-type="indexterm" data-primary="deinit" data-secondary="not called" id="calibre_link-640" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The solution to the leakage of <code class="calibre19">self</code> is to mark <code class="calibre19">self</code> as <code class="calibre19">weak</code> or (preferably) <code class="calibre19">unowned</code> in the anonymous function. Now <code class="calibre19">deinit</code> will be called and the view controller can go out of existence in good order. But we must <em class="calibre11">still</em> remember to unregister the observer token object, because otherwise the observer token itself will still leak, and its function can be called again even though <code class="calibre19">self</code> no longer exists (and if we marked <code class="calibre19">self</code> as <code class="calibre19">unowned</code>, the app will crash at that moment with a dangling pointer). Thus, a complete solution looks something like this:</p>

<pre data-type="programlisting" class="calibre28">var observers = Set&lt;NSObject&gt;()
override func viewDidLoad() {
    super.viewDidLoad()
    let ob = NotificationCenter.default.addObserver(
        forName: .MPMusicPlayerControllerNowPlayingItemDidChange,
        object: nil, queue: nil) { [unowned self] _ in <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-89" href="#calibre_link-87"><img src="images/000019.png" alt="1" class="calibre39" /></a>
            self.updateNowPlayingItem()
            // ... and so on ...
        }
    self.observers.insert(ob as! NSObject)
}
deinit {
    for ob in self.observers {
        NotificationCenter.default.removeObserver(ob) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-90" href="#calibre_link-88"><img src="images/000008.png" alt="2" class="calibre39" /></a>
    }
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-87" href="#calibre_link-89"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">If you omit <code class="calibre19">unowned self</code>, then <code class="calibre19">self</code> will leak (and <code class="calibre19">deinit</code> will never be called).</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-88" href="#calibre_link-90"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">If you omit <code class="calibre19">removeObserver</code>, then any observers will leak, and we can crash if the notification center later sends a notification to an observer with an <code class="calibre19">unowned</code> reference to a <code class="calibre19">self</code> that no longer exists.</p></dd>
</dl>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="KVO Observers" class="calibre2"><div class="preface" id="calibre_link-2702">
<h2 class="calibre42">KVO Observers</h2>

<p class="author1">The NSKeyValueObservation observer object that you get when you call <code class="calibre19">observe(_:options:changeHandler:)</code> (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) is quite similar to the observer token object you get from the notification center. You maintain a reference to the observer object, because otherwise the notification message wonâ€™t arrive. And youâ€™ll probably want to let the observer object just go out of existence when you yourself go out of existence, because it will then unregister itself automatically, which is just what you want.<a data-type="indexterm" data-primary="retain cycles" data-secondary="keyâ€“value observing" id="calibre_link-1925" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="keyâ€“value observing" data-secondary="retain cycles" id="calibre_link-1192" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="unregistering for keyâ€“value observing" id="calibre_link-2289" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="keyâ€“value observing" id="calibre_link-1299" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The problem is that if your notification function refers to <code class="calibre19">self</code>, thatâ€™s a retain cycle, because you are retaining an observer whose function is also retaining you. Therefore you <em class="calibre11">wonâ€™t</em> go out of existence, so the observer wonâ€™t go out of existence either and wonâ€™t be automatically unregistered. The solution, once again, is to mark <code class="calibre19">self</code> as <code class="calibre19">unowned</code> in the notification function:</p>

<pre data-type="programlisting" class="calibre28">var obs = Set&lt;NSKeyValueObservation&gt;()
func registerWith(_ mc:MyClass1) {
    let opts : NSKeyValueObservingOptions = [.old, .new]
    let ob = mc.observe(\.value, options: opts) {
        [unowned self] obj, change in
        print(self) // potential leak
    }
    obs.insert(ob)
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Timers" class="calibre2"><div class="preface" id="calibre_link-2703">
<h2 class="calibre42">Timers</h2>

<p class="author1">The class documentation for Timer (<a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>) says that â€œrun loops maintain strong references to their timersâ€; it then says of <code class="calibre19">scheduledTimer(timeInterval:target:selector:userInfo:repeats:)</code> that â€œThe timer maintains a strong reference to <code class="calibre19">target</code> until it (the timer) is invalidated.â€ This should set off alarm bells in your head: â€œDanger, Will Robinson, danger!â€ The documentation is warning you that as long as a repeating timer has not been invalidated, the target is being retained by the run loop; the only way to stop this is to send the <code class="calibre19">invalidate</code> message to the timer. (With a non-repeating timer, the problem arises less starkly, because the timer invalidates itself immediately after firing.)<a data-type="indexterm" data-primary="memory management" data-secondary="timers" id="calibre_link-1314" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="retain cycles" data-secondary="timers" id="calibre_link-1927" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="timers" data-secondary="retain cycles" id="calibre_link-2217" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Moreover, the <code class="calibre19">target:</code> argument is probably <code class="calibre19">self</code>. This means that you (<code class="calibre19">self</code>) are being retained, and cannot go out of existence until you invalidate the timer. So when will you that? You canâ€™t do it in your <code class="calibre19">deinit</code> implementation, because as long as the timer is repeating and has not been sent the <code class="calibre19">invalidate</code> message, <code class="calibre19">deinit</code> wonâ€™t be called. You therefore need to find another appropriate moment for sending <code class="calibre19">invalidate</code> to the timer, such as <code class="calibre19">viewDidDisappear</code>:</p>

<pre data-type="programlisting" class="calibre28">var timer : Timer!
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    self.timer = Timer.scheduledTimer(timeInterval: 1, target: self,
        selector: #selector(fired), userInfo: nil, repeats: true)
    self.timer.tolerance = 0.1
}
@objc func fired(_ t:Timer) {
    print("timer fired")
}
override func viewDidDisappear(_ animated: Bool) {
    super.viewDidDisappear(animated)
    self.timer.invalidate()
}</pre>

<p class="author1">A more flexible approach is to call <code class="calibre19">scheduledTimer(withTimeInterval:repeats:block:)</code> instead. Now there is no retained <code class="calibre19">target:</code> &mdash; but there is a retained function. If the timer is a repeating timer, you are retaining it so that you can invalidate it later, but the timer is retaining the function, and if that function involves a reference to <code class="calibre19">self</code>, it will retain <code class="calibre19">self</code>, causing a retain cycle. But we know what to do about that! Mark <code class="calibre19">self</code> as <code class="calibre19">weak</code> or <code class="calibre19">unowned</code> in the function. Now you <em class="calibre11">can</em> invalidate the timer in <code class="calibre19">deinit</code>. This is similar to the two-part solution I described earlier for notification observer token objects:</p>

<pre data-type="programlisting" class="calibre28">var timer : Timer!
override func viewDidLoad() {
    super.viewDidLoad()
    self.timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) {
        [unowned self] t in // *
        self.fired(t)
    }
}
func fired(_ t:Timer) {
    print("timer fired")
}
deinit {
    self.timer.invalidate() // *
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Other Unusual Situations" class="calibre2"><div class="preface" id="calibre_link-2704">
<h2 class="calibre42">Other Unusual Situations</h2>

<p class="author1">Other Cocoa objects with unusual memory management behavior will usually be called out clearly in the documentation. For example,
a CAAnimation object <em class="calibre11">retains its delegate</em>; this is exceptional and can cause serious trouble if youâ€™re not conscious of it (as usual, I speak from bitter experience).<a data-type="indexterm" data-primary="retains, unusual" id="calibre_link-1928" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="retains, unusual" id="calibre_link-1313" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">There are also situations where the documentation fails to warn of any special memory management considerations, but you can wind up with a retain cycle anyway. Discovering the problem can be tricky. Areas of Cocoa that have given me trouble include UIKit Dynamics (a UIDynamicBehaviorâ€™s <code class="calibre19">action</code> handler) and WebKit (a WKWebKitâ€™s WKScriptMessageHandler).</p>

<p class="author1">Three Foundation collection classes &mdash; NSPointerArray<a data-type="indexterm" data-primary="NSPointerArray" id="calibre_link-1465" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, NSHashTable<a data-type="indexterm" data-primary="NSHashTable" id="calibre_link-1442" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>, and <span class="publishername">NSMapTable</span><a data-type="indexterm" data-primary="NSMapTable" id="calibre_link-1446" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> &mdash; are similar respectively to NSMutableArray, NSMutableSet, and NSMutableDictionary, except that (among other things) their memory management policy is up to you. An NSHashTable created with the <code class="calibre19">weakObjects</code> class method, for example, maintains ARC-weak references to its elements, meaning that they are replaced by <code class="calibre19">nil</code> if the retain count of the object to which they were pointing has dropped to zero. You may find uses for these classes as a way of avoiding retain cycles.<a data-type="indexterm" data-primary="collections" data-secondary="memory management" id="calibre_link-456" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="collections" id="calibre_link-1293" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Nib Loading and Memory Management" class="calibre2"><div class="preface" id="calibre_link-94">
<h1 class="calibre18">Nib Loading and Memory Management</h1>

<p class="author1">When a nib loads, it instantiates its nib objects (<a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>). What happens to these instantiated objects? A view retains its subviews, but what about the top-level objects, which are not subviews of any view? They do <em class="calibre11">not</em> have elevated retain counts; if someone doesnâ€™t immediately retain them, theyâ€™ll simply vanish in a puff of smoke.<a data-type="indexterm" data-primary="nib-based instantiation" id="calibre_link-1402" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="nib-loaded objects" id="calibre_link-1304" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="nib-based" data-tertiary="memory management" id="calibre_link-1132" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If you donâ€™t want that to happen &mdash; and if you did, why would you be loading this nib in the first place? &mdash; you need to capture a reference to the top-level objects instantiated from the nib. There are two ways of doing that.</p>

<p class="author1">The first approach is to capture the result of the nib-loading code. When a nib is loaded by calling Bundleâ€™s <code class="calibre19">loadNibNamed(_:owner:options:)</code> or UINibâ€™s <code class="calibre19">instantiate(withOwner:options:)</code>, an array is returned consisting of the top-level objects instantiated by the nib-loading mechanism. So itâ€™s sufficient to retain this array, or the objects in it. We did that in <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a> when we loaded a nib and assigned the result to a variable, like this:</p>

<pre data-type="programlisting" class="calibre28">let arr = Bundle.main.loadNibNamed("View", owner: nil)!
let v = arr[0] as! UIView
self.view.addSubview(v)</pre>

<p class="author1">The other possibility is to configure the nib owner with outlets that will retain the nibâ€™s top-level objects when they are instantiated. We did that in <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a> when we set up an outlet like this:</p>

<pre data-type="programlisting" class="calibre28">class ViewController: UIViewController {
    @IBOutlet var coolview : UIView!</pre>

<p class="author1">We then loaded the nib with this view controller as owner:</p>

<pre data-type="programlisting" class="calibre28">Bundle.main.loadNibNamed("View", owner: self)
self.view.addSubview(self.coolview)</pre>

<p class="author1">In the first line, the nib-loading mechanism instantiates the top-level view from the nib and assigns it to <code class="calibre19">self.coolview</code>. Since <code class="calibre19">self.coolview</code> is a strong reference, it retains the view. Thus, the view is still there when we insert it into the interface in the second line.</p>

<p class="author1">On the other hand, <code class="calibre19">@IBOutlet</code> properties that will be set by the loading of a nib are usually marked <code class="calibre19">weak</code>.<a data-type="indexterm" data-primary="IBOutlet" data-secondary="weak" id="calibre_link-1027" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This is not obligatory, but they work properly as long as you use this designation only when this is an outlet to an object that will be retained by someone else &mdash; in particular, because itâ€™s already a subview of your view controllerâ€™s main view. A view controller retains its main view, and a view is retained by its superview, so the nib-loading process will cause this view to be retained, and there is no need for your <code class="calibre19">@IBOutlet</code> property to retain it as well.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Memory Management of CFTypeRefs" class="calibre2"><div class="preface" id="calibre_link-2705">
<h1 class="calibre18">Memory Management of CFTypeRefs</h1>

<p class="author1">A CFTypeRef is a pure C analog to an Objective-C object. In Objective-C, CFTypeRef types are distinguished by the suffix <code class="calibre19">Ref</code> at the end of their name; in Swift, this <code class="calibre19">Ref</code> suffix is dropped. For example, a CGContextRef is a CFTypeRef, and is known in Swift as a CGContext.</p>

<p class="author1">A CFTypeRef is a pointer to an opaque C struct (see <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a>), where â€œopaqueâ€ means that the struct has no directly accessible components. This struct acts as a pseudo-object; a CFTypeRef is analogous to an object type. In Objective-C, the fact that this thing is not an object is particularly obvious, because the code that operates upon a CFTypeRef is not object-oriented. A CFTypeRef has no properties or methods, and you do not send any messages to it; you work with CFTypeRefs entirely through global C functions. In Swiftâ€™s Core Graphics overlay, however, those global C functions are hand-tweaked to <em class="calibre11">look</em> like methods; for example, the <code class="calibre19">CGContextDrawLinearGradient</code> C function is called, in Swift, by sending <code class="calibre19">drawLinearGradient(_:start:end:options:)</code> to a CGContext pseudo-object, just as if a CGContext were an object and <code class="calibre19">drawLinearGradient</code> were an instance method.<a data-type="indexterm" data-primary="memory management" data-secondary="CFTypeRefs" id="calibre_link-1291" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="CFTypeRefs" data-secondary="memory management" id="calibre_link-352" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Hereâ€™s some actual Swift code for drawing a gradient; <code class="calibre19">con</code> is a CGContext, <code class="calibre19">sp</code> is a CGColorSpace, and <code class="calibre19">grad</code> is a CGGradient (all of them being CFTypeRefs):</p>

<pre data-type="programlisting" class="calibre28">let con = UIGraphicsGetCurrentContext()!
let locs : [CGFloat] = [ 0.0, 0.5, 1.0 ]
let colors : [CGFloat] = [
    0.8, 0.4, // starting color, transparent light gray
    0.1, 0.5, // intermediate color, darker less transparent gray
    0.8, 0.4, // ending color, transparent light gray
]
let sp = CGColorSpaceCreateDeviceGray()
let grad = CGGradient(colorSpace: sp,
    colorComponents: colors, locations: locs, count: 3)!
con.drawLinearGradient(grad,
    start: CGPoint(x:89,y:0), end: CGPoint(x:111,y:0), options:[])</pre>

<p class="author1">Despite being only a pseudo-object, a CFTypeRef is a reference type, and its memory must be managed in just the same way as that of a real object. Therefore, a CFTypeRef pseudo-object has a retain count! And this retain count works exactly as for a true object, in accordance with the golden rule of memory management. A CFTypeRef must be retained when it comes within the sphere of influence of an owner who wants it to persist, and it must be released when that owner no longer needs it.</p>

<p class="author1">In Objective-C, the golden rule, as applied to CFTypeRefs, is that if you obtained a CFTypeRef object through a function whose name contains the word <code class="calibre19">Create</code> or <code class="calibre19">Copy</code>, its retain count has been incremented. In addition, if you are worried about the object persisting, youâ€™ll retain it explicitly by calling the <code class="calibre19">CFRetain</code> function to increment its retain count. To balance your <code class="calibre19">Create</code>, <code class="calibre19">Copy</code>, or <code class="calibre19">CFRetain</code> call, you must eventually release the object. By default, youâ€™ll do that by calling the <code class="calibre19">CFRelease</code> function; some CFTypeRefs, however, have their own dedicated object release functions &mdash; for example, for CGPath, thereâ€™s a dedicated <code class="calibre19">CGPathRelease</code> function. Thereâ€™s no ARC management of CFTypeRefs in Objective-C, so you have to do all of this yourself, explicitly.</p>

<p class="author1">In Swift, however, you will <em class="calibre11">never</em> need to call <code class="calibre19">CFRetain</code>, or any form of <code class="calibre19">CFRelease</code>; indeed, you cannot. Swift will do it for you, behind the scenes, automatically.</p>

<p class="author1">Think of CFTypeRefs as living in two worlds: the CFTypeRef world of pure C, and the memory-managed object-oriented world of Swift. When you obtain a CFTypeRef pseudo-object, it <em class="calibre11">crosses the bridge</em> from the CFTypeRef world into the Swift world. From that moment on, until you are done with it, it needs memory management. Swift is aware of this, and for the most part, Swift itself will use the golden rule and will apply correct memory management. For example, the code I showed earlier for drawing a gradient is in fact memory-management complete. In Objective-C, we would have to release <code class="calibre19">sp</code> and <code class="calibre19">grad</code>, because they arrived into our world through <code class="calibre19">Create</code> calls; if we failed to do this, they would leak. In Swift, however, there is no need, because Swift will do it for us. (See <a data-type="xref" href="#calibre_link-51" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Appendix&nbsp;A</a> for more about how objects move between the CFTypeRef world and the memory-managed object world.)</p>

<p class="author1">Working with CFTypeRefs in Swift is thus much easier than in Objective-C. In Swift, you can treat CFTypeRef pseudo-objects as actual objects! For example, you can assign a CFTypeRef to a property in Swift, or pass it as an argument to a Swift function, and its memory will be managed correctly; in Objective-C, those are tricky things to do.</p>

<p class="author1">It is possible that you may receive a CFTypeRef through some API that lacks memory management information. Such a value will come forcibly to your attention, because it will arrive into Swift, not as a CFTypeRef, but as an Unmanaged generic wrapping the actual CFTypeRef. That situation alerts you to the fact that Swift does not know how to proceed with the memory management of this pseudo-object. You will be unable to proceed until you unwrap the CFTypeRef by calling the Unmanaged objectâ€™s <code class="calibre19">takeRetainedValue</code> or <code class="calibre19">takeUnretainedValue</code> method. You will call whichever method tells Swift how to manage the memory for this object correctly. For a CFTypeRef with an incremented retain count (usually acquired through a function with <code class="calibre19">Create</code> or <code class="calibre19">Copy</code> in its name), call <code class="calibre19">takeRetainedValue</code>; otherwise, call <code class="calibre19">takeUnretainedValue</code>.<a data-type="indexterm" data-primary="Unmanaged" id="calibre_link-2283" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="Unmanaged" id="calibre_link-1315" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Property Memory Management Policies" class="calibre2"><div class="preface" id="calibre_link-2706">
<h1 class="calibre18">Property Memory Management Policies</h1>

<p class="author1">In Objective-C, a <code class="calibre19">@property</code> declaration (see <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>) includes a statement of the memory management policy implemented by the corresponding setter accessor method. It is useful to be aware of this and to know how such policy statements are translated into Swift.</p>

<p class="author1">For example, earlier I said that a UIViewController retains its <code class="calibre19">view</code> (its main view). How do I know this? Because the <code class="calibre19">@property</code> declaration tells me so:<a data-type="indexterm" data-primary="properties" data-secondary="Objective-C" data-tertiary="memory management" id="calibre_link-1766" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="properties" data-tertiary="Objective-C" id="calibre_link-1309" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@property(null_resettable, nonatomic, strong) UIView *view;</pre>

<p class="author1">The term <code class="calibre19">strong</code> means that the setter retains the incoming UIView object. The Swift translation of this declaration doesnâ€™t add any attribute to the variable:</p>

<pre data-type="programlisting" class="calibre28">var view: UIView!</pre>

<p class="author1">The default in Swift is that a variable referring to a reference object type <em class="calibre11">is</em> a strong reference. This means that it retains the object. Thus, you can safely conclude from this declaration that a UIViewController retains its <code class="calibre19">view</code>.</p>

<p class="author1">The possible memory management policies for a Cocoa property are:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">strong</code>, <code class="calibre19">retain</code> (no Swift equivalent term)</dt>
<dd class="calibre16">
<p class="calibre17">The default. The two terms are pure synonyms; <code class="calibre19">retain</code> is the term inherited from pre-ARC days. Assignment to this property releases the existing value (if any) and retains the incoming value.</p>
</dd>
<dt class="calibre15"><code class="calibre19">copy</code> (Swift <code class="calibre19">@NSCopying</code>)</dt>
<dd class="calibre16">
<p class="calibre17">The same as <code class="calibre19">strong</code> or <code class="calibre19">retain</code>, except that the setter copies the incoming value by sending <code class="calibre19">copy</code> to it; the incoming value must be an object of a type that adopts NSCopying, to ensure that this is possible. The copy, which has an increased retain count already, becomes the new value.</p>
</dd>
<dt class="calibre15"><code class="calibre19">weak</code> (Swift <code class="calibre19">weak</code>)</dt>
<dd class="calibre16">
<p class="calibre17">An ARC-weak reference. The incoming object value is not retained, but if it goes out of existence behind our back, ARC will magically substitute <code class="calibre19">nil</code> as the value of this property, which must be typed as an Optional declared with <code class="calibre19">var</code>.</p>
</dd>
<dt class="calibre15"><code class="calibre19">assign</code> (Swift <code class="calibre19">unowned(unsafe)</code>)</dt>
<dd class="calibre16">
<p class="calibre17">No memory management. This policy is inherited from pre-ARC days, and is inherently unsafe (hence the additional <code class="calibre19">unsafe</code> warning in the Swift translation of the name): if the object referred to goes out of existence, this reference will become a dangling pointer and can cause a crash if you subsequently try to use it.</p>
</dd>
</dl>

<p class="author1">The <code class="calibre19">copy</code> policy is used by Cocoa particularly when an immutable class has a mutable subclass (such as NSString and NSMutableString, or NSArray and NSMutableArray; see <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>). The idea is to deal with the danger of the setterâ€™s caller passing an object of the mutable subclass. This is possible because, in accordance with the substitution principle of polymorphism (<a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>), wherever an instance of a class is expected, an instance of its subclass can be used instead. It would be bad if this were to happen, because now the caller might keep a reference to the incoming value and, since it is in fact mutable, could later mutate it behind our back. To prevent this, the setter calls <code class="calibre19">copy</code> on the incoming object; this creates a new instance, separate from the object provided &mdash; and belonging to the immutable class.</p>

<p class="author1">In Swift, this problem is unlikely to arise with strings and arrays, because on the Swift side these are value types (structs) and are effectively copied when assigned, passed as an argument, or received as a return value. Thus, Cocoaâ€™s NSString and NSArray property declarations, when translated into Swift as String and Array property declarations, donâ€™t show any special marking corresponding to Objective-C <code class="calibre19">copy</code>. But Cocoa types that are <em class="calibre11">not</em> bridged to Swift value types <em class="calibre11">do</em> show a marking: <code class="calibre19">@NSCopying</code>. For example, the declaration of the <code class="calibre19">attributedText</code> property of a UILabel appears like this in Swift:<a data-type="indexterm" data-primary="NSCopying" id="calibre_link-1435" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="mutable Objective-C classes" id="calibre_link-1303" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mutable Objective-C classes" data-secondary="NSCopying" id="calibre_link-1365" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@NSCopying var attributedText: NSAttributedString?</pre>

<p class="author1">NSAttributedString has a mutable subclass, NSMutableAttributedString. Youâ€™ve probably configured this attributed string as an NSMutableAttributedString, and now youâ€™re assigning it as a UILabelâ€™s <code class="calibre19">attributedText</code>. The UILabel doesnâ€™t want you keeping a reference to this mutable string and mutating it in place, since that would change the value of the property without passing through the setter. Thus, it copies the incoming value to ensure that what it has is a separate immutable NSAttributedString.</p>

<p class="author1">Youâ€™ll want to do the same thing in your own code, and you can. Simply mark your property with the <code class="calibre19">@NSCopying</code> attribute; Swift will enforce the <code class="calibre19">copy</code> policy and will take care of the actual copying for you whenever this property is assigned to:</p>

<pre data-type="programlisting" class="calibre28">class StringDrawer {
    @NSCopying var attributedString : NSAttributedString!
    // ...
}</pre>

<p class="author1">If, as is sometimes the case, your own class wants the internal ability to mutate the value of this property while preventing a mutable value from arriving from outside, put a private computed property faÃ§ade in front of it whose getter transforms it to the corresponding mutable type:</p>

<pre data-type="programlisting" class="calibre28">class StringDrawer {
    @NSCopying var attributedString : NSAttributedString!
    private var mutableAttributedString : NSMutableAttributedString! {
        get {
            if self.attributedString == nil {return nil}
            return NSMutableAttributedString(
                attributedString:self.attributedString)
        }
        set {
            self.attributedString = newValue
        }
    }
    // ...
}</pre>

<p class="author1"><code class="calibre19">@NSCopying</code> can be used <em class="calibre11">only</em> for instance properties of classes, not of structs or enums &mdash; and only in the presence of Foundation, because that is where the NSCopying protocol is defined, which the type of a variable marked as <code class="calibre19">@NSCopying</code> must adopt.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Debugging Memory Management Mistakes" class="calibre2"><div class="preface" id="calibre_link-2707">
<h1 class="calibre18">Debugging Memory Management Mistakes</h1>

<p class="author1">Though far less likely to occur under ARC (and Swift), memory management mistakes <em class="calibre11">can</em> still occur, especially because a programmer is apt to assume that they canâ€™t. Experience suggests that you should use every tool at your disposal to ferret out possible mistakes. Here are some of those tools (and see <a data-type="xref" href="#calibre_link-5" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;9</a>):<a data-type="indexterm" data-primary="debugging" data-secondary="memory management" id="calibre_link-618" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="memory management" data-secondary="debugging" id="calibre_link-1295" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The memory gauge in the Debug navigator charts memory usage whenever your app runs, allowing you to observe possible memory leakage or other unwarranted heavy memory use. Note that memory management in the Simulator is not necessarily indicative of reality! Always observe the memory gauge with the app running on a device before making a judgment.</p>
</li>
<li class="calibre12">
<p class="calibre17">Instruments (Product â†’ Profile) has excellent tools for discerning leaks and tracking memory management of individual objects.<a data-type="indexterm" data-primary="Instruments" id="calibre_link-1145" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
<li class="calibre12">
<p class="calibre17">Good old caveman debugging can help confirm that your objects are behaving as you want them to. Implement <code class="calibre19">deinit</code> with a <code class="calibre19">print</code> call. If it isnâ€™t called, your object is not going out of existence. This technique can reveal problems that even Instruments will not directly expose.</p>
</li>
<li class="calibre12">
<p class="calibre17">Memory graphing (<a data-type="xref" href="#calibre_link-91" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œMemory Debuggingâ€</a>) will draw you a picture of the ownership relations between your objects; in conjunction with Malloc Stack, it will trace that ownership through the actual retain calls.</p>
</li>
<li class="calibre12">
<p class="calibre17">Dangling pointers are particularly difficult to track down, but they can often be located by â€œturning on zombies.â€ This is easy in Instruments with the Zombies template.<a data-type="indexterm" data-primary="zombies" id="calibre_link-2381" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> Alternatively, edit the Run action in your scheme, switch to the Diagnostics tab, and check Enable Zombie Objects. The result is that an object that goes out of existence is replaced by a â€œzombieâ€ that will report to the console if a message is sent to it (â€œmessage sent to deallocated instanceâ€). Moreover, the zombie knows what <em class="calibre11">kind</em> of object it replaces, so you can learn <em class="calibre11">what</em> got deallocated. Be sure to turn zombies back off when youâ€™ve finished tracking down your dangling pointers. Donâ€™t use zombies with the Leaks instrument: zombies <em class="calibre11">are</em> leaks.</p>
</li>
<li class="calibre12">
<p class="calibre17">The Address Sanitizer<a data-type="indexterm" data-primary="Address Sanitizer" id="calibre_link-127" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (also in the schemeâ€™s Run actionâ€™s Diagnostics tab) lets you debug even more subtle forms of memory misuse. Here, for example, weâ€™re doing a Very Bad Thing, writing directly into memory that doesnâ€™t belong to us:</p>

<pre data-type="programlisting" class="calibre38">let b = UnsafeMutablePointer&lt;CGFloat&gt;.allocate(capacity:3)
b.initializeFrom([0.1, 0.2, 0.3])
b[4] = 0.4</pre>

<p class="calibre17">That code probably wonâ€™t crash; it corrupts memory silently, which is even worse. But if we run our app under Address Sanitizer, it detects the problem and reports a heap buffer overflow. <a data-type="indexterm" data-startref="idxmemmanage2" id="calibre_link-1287" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-93">
<div id="calibre_link-3012" class="calibre1"><section data-type="chapter" {http://www.idpf.org/2007/ops}type="chapter" data-pdf-bookmark="Chapter 13. Communication Between Objects" class="calibre2"><div class="preface" id="calibre_link-50">
<h1 class="calibre13"><span class="label">Chapter 13. </span>Communication Between Objects</h1>


<p class="author1">As soon as an app grows to more than a few objects, puzzling questions can arise about how to send a message or communicate data between one object and another.
It may require some planning to construct your code so that all the pieces fit together and information can be shared as needed at the right moment. This chapter presents some organizational considerations that will help you arrange for one object to be able to communicate with another.</p>






<section data-type="sect1" data-pdf-bookmark="Visibility Through an Instance Property" class="calibre2"><div class="preface" id="calibre_link-2708">
<h1 class="calibre18">Visibility Through an Instance Property</h1>

<p class="author1">The problem of communication often comes down to one object being able to <em class="calibre11">see</em> another: the object Manny needs to be able to find the object Jack repeatedly and reliably over the long term so as to be able to send Jack messages.<a data-type="indexterm" data-primary="references" data-secondary="getting" id="calibre_link-1865" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="getting a reference" id="calibre_link-1122" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="visibility, instance" id="calibre_link-2356" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
One obvious solution is an instance property of Manny whose value <em class="calibre11">is</em> Jack.</p>

<p class="author1">An instance property is appropriate particularly when Manny and Jack share certain responsibilities or supplement one anotherâ€™s functionality. Here are some cases where one object needs to have an instance property pointing at another:<a data-type="indexterm" data-primary="communication between objects" id="calibre_link-487" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="objects" data-secondary="communication between" id="calibre_link-1549" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The application object and its delegate</p>
</li>
<li class="calibre12">
<p class="calibre17">A table view and its data source</p>
</li>
<li class="calibre12">
<p class="calibre17">A view controller and the view that it controls</p>
</li>
</ul>

<p class="author1">Manny may have an instance property pointing to Jack, but this does not necessarily imply that Manny needs to assert <em class="calibre11">ownership</em> of Jack as a matter of memory management policy (see <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>). For example:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">An object does not typically retain its delegate or its data source.</p>
</li>
<li class="calibre12">
<p class="calibre17">An object that implements the target&ndash;action pattern, such as a UIControl, does not retain its target.</p>
</li>
</ul>

<p class="author1">By using a weak reference and typing the property as an Optional, and then treating the Optional coherently and safely, Manny can keep a reference to Jack without owning Jack (while coping with the possibility that his supposed reference to Jack will turn out to be <code class="calibre19">nil</code>). On the other hand, sometimes ownership is appropriate and crucial. A view controller is useless without a view to control, and its view truly belongs to the view controller and to no one else; once a view controller has a view, it will retain it, releasing it only when it itself goes out of existence.</p>

<p class="author1">Objects can perform two-way communication without both of them holding references to one another. It may be sufficient for <em class="calibre11">one</em> of them to have a reference to the other &mdash; because the former, as part of a message to the latter, can include a reference to himself. For example, Manny might send a message to Jack where one of the parameters is a reference to Manny; this might merely constitute a form of identification, or an invitation to Jack to send a message back to Manny if Jack needs further information while doing whatever this method does. Manny thus makes himself, as it were, momentarily visible to Jack; Jack should not wantonly retain Manny (especially since thereâ€™s an obvious risk of a retain cycle). Again, this is a common pattern:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The parameter of the delegate message <code class="calibre19">textFieldShouldBeginEditing(_:)</code> is a reference to the UITextField that sent the message.</p>
</li>
<li class="calibre12">
<p class="calibre17">The first parameter of a target&ndash;action message is a reference to the control that sent the message.</p>
</li>
</ul>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Visibility by Instantiation" class="calibre2"><div class="preface" id="calibre_link-2709">
<h1 class="calibre18">Visibility by Instantiation</h1>

<p class="author1">Every instance comes from somewhere and at someoneâ€™s behest: some object sent a message commanding this instance to come into existence in the first place. The commanding object therefore has a reference to the new instance at the moment of instantiation. When Manny creates Jack, Manny has a reference to Jack.</p>

<p class="author1">That simple fact can serve as the starting point for establishing future communication. If Manny creates Jack and knows that he (Manny) will need a reference to Jack later on, Manny can keep the reference that he obtained by creating Jack in the first place.</p>

<p class="author1">Or it might be the other way around: Manny creates Jack and knows that Jack will need a reference to Manny later on, so Manny can supply that reference immediately after creating Jack, and Jack will then keep it.
Delegation is a case in point. Manny may create Jack and immediately make himself Jackâ€™s delegate, as in my example code in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>:</p>

<pre data-type="programlisting" class="calibre28">let cpc = ColorPickerController(colorName:colorName, color:c)
cpc.delegate = self</pre>

<p class="author1">When Manny creates Jack, it might not be a reference to Manny himself that Jack needs, but to something that Manny knows or has. You will presumably endow Jack with a method so that Manny can hand over that information. In fact, if Jack simply cannot live without the information, it might be reasonable to endow Jack with an initializer that <em class="calibre11">requires</em> this information as part of the very act of creation.</p>

<p class="author1">This example (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) comes from a table view controller. The user has tapped a row of the table. In response, we create a secondary table view controller, a TracksViewController instance; we hand it the data it will need, and display the secondary table view:</p>

<pre data-type="programlisting" class="calibre28">override func tableView(_ tableView: UITableView,
    didSelectRowAt indexPath: IndexPath) {
        delay(0.1) {
            let t = TracksViewController(
                mediaItemCollection: self.albums[indexPath.row])
            self.navigationController?.pushViewController(t, animated: true)
        }
}</pre>

<p class="author1">In that code, I instantiate the TracksViewController by calling its initializer, <code class="calibre19">init(mediaItemCollection:)</code>, which requires me to hand over the media item collection that the view controller will need as the basis of its table view. And where did this initializer come from? I made it up! I have deliberately devised TracksViewController to have a designated initializer <code class="calibre19">init(mediaItemCollection:)</code>, making it virtually obligatory for a TracksViewController to have access, from the moment it comes into existence, to the data it needs.</p>

<p class="author1">In that example, I (<code class="calibre19">self</code>)
create the TracksViewController instance, and so, for one brief shining moment, I have a reference to it. Therefore I take advantage of that moment to hand the TracksViewController instance the information it needs. There will be no better moment to do this. Knowing the moment, and taking care not to miss it, is part of the art of data communication.</p>

<p class="author1">Nib-loading is also a case in point. The loading of a nib is a way of instantiating objects from the nib. Proper preparation is essential in order to ensure that those objects are assigned to strong references, so that they donâ€™t simply vanish in a puff of smoke (<a data-type="xref" href="#calibre_link-94" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œNib Loading and Memory Managementâ€</a>). At the moment the nib loads, the nibâ€™s owner or the code that loads the nib is in contact with those objects; it takes advantage of that moment to secure those references.</p>

<p class="author1">Another key moment is when a segue in a storyboard is triggered. There are two view controllers that may need to meet &mdash; the view controllers at the two ends of the segue, the source view controller and the destination view controller. This is parallel to the situation where one view controller creates another view controller and presents it, but thereâ€™s an important difference: with a triggered segue, the source view controller <em class="calibre11">doesnâ€™t</em> create the destination view controller. But it probably still needs a reference to the destination view controller, very early in the life of the latter, so that it can hand over any needed informtation. How will it get that reference?</p>

<p class="author1">At the moment the segue is triggered, the source view controller already exists, and the segue knows what view controller it is; and the segue itself instantiates the destination view controller. So the segue immediately turns to the source view controller and <em class="calibre11">hands</em> it a reference to the destination view controller. For example, it may call the source view controllerâ€™s <code class="calibre19">prepare(for:sender:)</code> method. This is the source view controllerâ€™s chance to obtain a reference to the newly instantiated destination view controller &mdash; and now the source view controller can make itself the destination view controllerâ€™s delegate, or hand it any needed information, and so forth.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Getting a Reference" class="calibre2"><div class="preface" id="calibre_link-2710">
<h1 class="calibre18">Getting a Reference</h1>

<p class="author1">A source of particular frustration arises when you know that another object exists somewhere out there but you donâ€™t know how to refer to it. Letâ€™s say youâ€™re a view controller and thereâ€™s some other controller you need to talk to. But you <em class="calibre11">didnâ€™t</em> instantiate the other view controller, and you are <em class="calibre11">not</em> the source view controller for the segue that instantiated the other view controller. You know a lot about this other view controller &mdash; you might know, for example, what its class is, and maybe you can see its view sitting there in the interface when you run the app &mdash; but you cannot get hold of it in code.<a data-type="indexterm" data-primary="instances" id="calibre_link-1116" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instantiation" id="calibre_link-1142" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="lifetime" id="calibre_link-1126" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="creation" id="calibre_link-1121" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="instances" data-secondary="getting a reference" id="calibre_link-1123" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="references" data-secondary="getting" id="calibre_link-1866" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="persistence" data-see="lifetime" id="calibre_link-3013" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">When youâ€™re faced with this situation, donâ€™t make the elementary mistake that beginners all too often do make: you know the class of the view controller youâ€™re looking for, so you make an instance of that class. Thatâ€™s wrong. Youâ€™ve gotten yourself a reference to an instance of that class, but it isnâ€™t the <em class="calibre11">particular</em> instance that you wanted a reference to. Distinguish between situations where you need to <em class="calibre11">create</em> an instance and situations where the instance you are interested in exists in some persistent fashion <em class="calibre11">already</em>. The problem, in the latter case, is to find a way of <em class="calibre11">getting a reference</em> to that existing instance &mdash; and you must not confuse that with instantiation.</p>

<p class="author1">Letâ€™s say, for example, that this is a real-life iOS app. You will certainly have a root view controller, which will be an instance of some type of UIViewController. Letâ€™s say itâ€™s an instance of the ViewController class. Once your app is up and running, this instance already exists. Now then, suppose we are in some other view controller, and we want to talk to the View Controller instance that is serving as the root view controller of the app. It would be utterly counterproductive to attempt to speak to the root view controller by <em class="calibre11">instantiating</em> the ViewController class:</p>

<pre data-type="programlisting" class="calibre28">let theVC = ViewController() // legal but stupid</pre>

<p class="author1">All that does is to make a <em class="calibre11">second, different</em> instance of the ViewController class, and your messages to that instance will be wasted, as it is not <em class="calibre11">the particular already existing instance</em> of ViewController that you wanted to talk to. What you want is to <em class="calibre11">get a reference</em> to that already existing instance.</p>








<section data-type="sect2" data-pdf-bookmark="Visibility by Relationship" class="calibre2"><div class="preface" id="calibre_link-2711">
<h2 class="calibre42">Visibility by Relationship</h2>

<p class="author1">It is not the <em class="calibre11">class</em> of an already existing object that will get you a reference to that object, but rather the <em class="calibre11">relationship</em> between you and that object. Objects may acquire the ability to see one another automatically by virtue of their position in a containing structure. Before worrying about how to supply one object with a reference to another, consider whether there may <em class="calibre11">already</em> be a chain of references leading from one to the other.<a data-type="indexterm" data-primary="instances" data-secondary="relationships between" id="calibre_link-1133" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, a subview can see its superview, through its <code class="calibre19">superview</code> property. A superview can see all its subviews, through its <code class="calibre19">subviews</code> property, and can pick out a specific subview through that subviewâ€™s <code class="calibre19">tag</code> property, by calling the <code class="calibre19">viewWithTag(_:)</code> method. A subview in a window can see its window, through its <code class="calibre19">window</code> property. Thus, by working your way up or down the view hierarchy by means of these properties, it may be possible to obtain the desired reference.</p>

<p class="author1">A view controller can see its view through its <code class="calibre19">view</code> property, and from there can work its way down to subviews to which it may not have an outlet. What about going in the other direction? A responder (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) can see the next object up the responder chain, through the <code class="calibre19">next</code> property &mdash; which also means, because of the structure of the responder chain, that a view controllerâ€™s main view can see the view controller.</p>

<p class="author1">View controllers are themselves part of a hierarchy and therefore can see one another. If a view controller is currently presenting a view through a second view controller, the latter is the formerâ€™s <code class="calibre19">presentedViewController</code>, and the former is the latterâ€™s <code class="calibre19">presentingViewController</code>. If a view controller is the child of a UINavigationController, the latter is its <code class="calibre19">navigationController</code>. A UINavigationControllerâ€™s visible view is controlled by its <code class="calibre19">visibleViewController</code>. And so forth.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Global Visibility" class="calibre2"><div class="preface" id="calibre_link-2712">
<h2 class="calibre42">Global Visibility</h2>

<p class="author1">Some objects are globally visible &mdash; that is, they are visible to all other objects. Object types themselves are an important example. As I pointed out in <a data-type="xref" href="#calibre_link-19" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;4</a>, it is perfectly reasonable to use a Swift struct with static members as a way of providing globally available namespaced constants (<a data-type="xref" href="#calibre_link-95" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œStruct As Namespaceâ€</a>).</p>

<p class="author1">Classes sometimes have class methods or properties that vend singleton instances. Some of these singletons, in turn, have properties pointing to other objects, making those other objects likewise globally visible. For example, any object can see the singleton UIApplication instance as <code class="calibre19">UIApplication.shared</code>. So any object can also see the appâ€™s primary window, because that is the first element of the singleton UIApplication instanceâ€™s <code class="calibre19">windows</code> property, and any object can see the app delegate, because that is its <code class="calibre19">delegate</code> property. And the chain continues: any object can see the appâ€™s root view controller, because that is the primary windowâ€™s <code class="calibre19">rootViewController</code> &mdash; and from there, as I said in the previous section, we can navigate the view controller hierarchy and the view hierarchy.<a data-type="indexterm" data-primary="instances" data-secondary="globally visible" id="calibre_link-1124" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="globally visible instances" id="calibre_link-983" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">So now we know how to solve the problem I posed earlier of getting a reference to the appâ€™s root view controller. We start with the globally visible shared application instance:</p>

<pre data-type="programlisting" class="calibre28">let app = UIApplication.shared</pre>

<p class="author1">From there we can get the window:</p>

<pre data-type="programlisting" class="calibre28">let window = app.windows.first</pre>

<p class="author1">That window owns the root view controller, and will hand us a reference to it through its <code class="calibre19">rootViewController</code> property:</p>

<pre data-type="programlisting" class="calibre28">let vc = window?.rootViewController</pre>

<p class="author1">And voilÃ  &mdash; a reference to our appâ€™s root view controller. To obtain the reference to this persistent instance, we have created, in effect, a chain leading from the known to the unknown, from a globally available class to the particular desired instance.</p>

<p class="author1">You can make your own objects globally visible by attaching them to a globally visible object. For example, a public property of the app delegate, which you are free to create, is globally visible by virtue of the app delegate being globally visible (by virtue of the shared application being globally visible).</p>

<p class="author1">Another globally visible object is the shared defaults object obtained as <code class="calibre19">UserDefaults.standard</code>.<a data-type="indexterm" data-primary="UserDefaults" id="calibre_link-2305" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> This object is the gateway to storage and retrieval of user defaults, which is similar to a dictionary (a collection of values named by keys). The user defaults are automatically saved when your application quits and are automatically available when your application is launched again later, so they are one of the ways in which your app maintains information between launches. But, being globally visible, they are also a conduit for communicating values within your app.</p>

<p class="author1">For example, in one of my apps thereâ€™s a preference setting I call <code class="calibre19">Default.hazyStripy</code>. This determines whether a certain visible interface object (a card in a game) is drawn with a hazy fill or a stripy fill. This is a setting that the user can change, so there is a preferences interface allowing the user to make this change. When the user displays this preferences interface, I examine the <code class="calibre19">Default.hazyStripy</code> setting in the user defaults to configure the preferences interface to reflect it in a segmented control (called <code class="calibre19">self.hazyStripy</code>):</p>

<pre data-type="programlisting" class="calibre28">func setHazyStripy () {
    let hs = UserDefaults.standard
        .object(forKey:Default.hazyStripy) as! Int
    self.hazyStripy.selectedSegmentIndex = hs
}</pre>

<p class="author1">Conversely, if the user interacts with the preferences interface, tapping the <code class="calibre19">hazyStripy</code> segmented control to change its setting, I respond by changing the actual <code class="calibre19">Default.hazyStripy</code> setting in the user defaults:</p>

<pre data-type="programlisting" class="calibre28">@IBAction func hazyStripyChange(_ sender: Any) {
    let hs = self.hazyStripy.selectedSegmentIndex
    UserDefaults.standard.set(hs, forKey: Default.hazyStripy)
}</pre>

<p class="author1">But hereâ€™s the really interesting part. The preferences interface is not the only object that uses the <code class="calibre19">Default.hazyStripy</code> setting in the user defaults; the drawing code that actually draws the hazy-or-stripy-filled card also uses it, so as to know how the card should draw itself! When the user leaves the preferences interface and the card game reappears, the cards are redrawn &mdash; consulting the <code class="calibre19">Default.hazyStripy</code> setting in UserDefaults in order to do so:</p>

<pre data-type="programlisting" class="calibre28">override func draw(_ rect: CGRect) {
    let hazy : Bool = UserDefaults.standard
        .integer(forKey:Default.hazyStripy) == HazyStripy.hazy.rawValue
    CardPainter.shared.drawCard(self.card, hazy:hazy)
}</pre>

<p class="author1">Thus there is no need for the card object and the view controller object that manages the preferences interface to be able to see one another, because they can both see this common object, the <code class="calibre19">Default.hazyStripy</code> user default. UserDefaults becomes, in itself, a global conduit for communicating information from one part of my app to another.</p>
</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Notifications and Keyâ€“Value Observing" class="calibre2"><div class="preface" id="calibre_link-2713">
<h1 class="calibre18">Notifications and Key&ndash;Value Observing</h1>

<p class="author1">Notifications (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) can be a way to communicate between objects that are conceptually distant from one another without bothering to provide <em class="calibre11">any</em> way for one to see the other. All they really need to have in common is a knowledge of the name of the notification. Every object can see the notification center &mdash; it is a globally visible object &mdash; so every object can arrange to post or receive a notification.</p>

<p class="author1">Using a notification in this way may seem lazy, an evasion of your responsibility to architect your objects sensibly. But sometimes one object doesnâ€™t need to know, and indeed shouldnâ€™t know, what object (or objects) it is sending a message to.<a data-type="indexterm" data-primary="notifications" data-secondary="when appropriate" id="calibre_link-1428" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Recall the example I gave in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>. In a simple card game app, the game needs to know when a card is tapped. A card, when it is tapped, knowing nothing about the game, simply emits a virtual shriek by posting a notification; the game object has registered for this notification and takes over from there:</p>

<pre data-type="programlisting" class="calibre28">NotificationCenter.default.post(name: Self.tappedNotification, object: self)</pre>

<p class="author1">Hereâ€™s another example, taking advantage of the fact that notifications are a broadcast mechanism. In one of my apps, the app delegate may detect a need to tear down the interface and build it back up again from scratch. If this is to happen without causing memory leaks (and all sorts of other havoc), every view controller that is currently running a repeating Timer needs to invalidate that timer (<a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>). Rather than my having to work out what view controllers those might be, and endowing every view controller with a method that can be called, I simply have the app delegate shout â€œEverybody stop timers!â€ by posting a notification. All my view controllers that run timers have registered for this notification, and they know what to do when they receive it.</p>

<p class="author1">By the same token, Cocoa itself provides notification versions of many delegate and action messages. For example, the app delegate has a method for being told when the app goes into the background, but other objects might need to know this too; those objects can register for the corresponding notification.</p>

<p class="author1">Similarly, key&ndash;value observing can be used to keep two conceptually distant objects synchronized with one another: a property of one object changes, and the other object hears about the change. As I said in <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>, entire areas of Cocoa routinely expect you to use KVO when you want to be notified of a change in an object property. You can configure the same sort of thing with your own objects.</p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Combine Framework" class="calibre2"><div class="preface" id="calibre_link-2714">
<h1 class="calibre18">The Combine Framework</h1>

<p class="author1">There is some commonality between mechanisms such as the notification center and key&ndash;value observing. In both cases, you register with some other object to receive a certain message whenever that other object cares to send it. Basically, youâ€™re opening and configuring a pipeline of communication, and leaving it in place until you no longer need it. Looked at in that way, notifications and key&ndash;value observing seem closely related to one another. In fact, the target&ndash;action mechanism of reporting control events seems related as well. So does a Timer. So does delayed performance.<a data-type="indexterm" data-primary="pipeline" data-secondary="Combine framework" id="calibre_link-1693" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>
<a data-type="indexterm" data-primary="Combine framework" id="calibre_link-470" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">New in Swift 5.1 and iOS 13, the Combine framework offers to unify these architectures (and others) under a single head. At its heart, Combine depends upon an abstract notion of publish-and-subscribe, and reifies that abstraction with two protocols, Publisher and Subscriber:<a data-type="indexterm" data-primary="Publisher" id="calibre_link-1824" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Subscriber" id="calibre_link-2144" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<dl class="calibre14">
<dt class="calibre15">Publisher</dt>
<dd class="calibre16">
<p class="calibre17">A publisher promises to provide a certain kind of a value, perhaps repeatedly, at some time in the future.</p>
</dd>
<dt class="calibre15">Subscriber</dt>
<dd class="calibre16">
<p class="calibre17">A Subscriber registers itself with (subscribes to) a Publisher to receive its value whenever it comes along.</p>
</dd>
</dl>

<p class="author1">When a Subscriber subscribes to a Publisher, hereâ€™s what happens:</p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">The Publisher responds by handing the Subscriber a Subscription (another protocol).</p>
</li>
<li class="calibre4">
<p class="calibre17">The Subscriber can then use the Subscription to ask the Publisher for a value.</p>
</li>
<li class="calibre4">
<p class="calibre17">The Publisher can respond by sending, whenever it cares to, a value to the Subscriber. It can do this as many times as it likes.</p>
</li>
<li class="calibre4">
<p class="calibre17">In some situations, the entire connection can be cancelled when the Subscriber no longer wishes to receive values.</p>
</li>

</ol>

<p class="author1">Thatâ€™s a rather elaborate-sounding dance, but in most cases you wonâ€™t experience it that way. You wonâ€™t experience the dance at all! Instead, youâ€™ll just hook up a built-in subscriber directly to a built-in publisher and all the right things will happen.</p>

<p class="author1">To illustrate, Iâ€™ll start with a trivial example. One of the simplest forms of publisher is a Subject. Every time you call <code class="calibre19">send(_:)</code> on a Subject, handing it a value, it sends that value to its subscribers. There are just two kinds of Subject:</p>
<dl class="calibre14">
<dt class="calibre15">PassthroughSubject</dt>
<dd class="calibre16">
<p class="calibre17">Produces the value sent to it with <code class="calibre19">send</code>.</p>
</dd>
<dt class="calibre15">CurrentValueSubject</dt>
<dd class="calibre16">
<p class="calibre17">Like a PassthroughSubject, except that it has a value at the outset, and produces it to any new subscriber.</p>
</dd>
</dl>

<p class="author1">Letâ€™s make a Subject:</p>

<pre data-type="programlisting" class="calibre28">let pass = PassthroughSubject&lt;String,Never&gt;()
pass.send("howdy")</pre>

<p class="author1">That compiles and runs, but we donâ€™t know that anything happened because we have no subscriber. There are just two built-in independent subscribers, and each can be created with a convenience method sent to a publisher; the method subscribes the subscriber to the publisher and returns it:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre19">sink</code></dt>
<dd class="calibre16">
<p class="calibre17">Takes a function to be called whenever a value is received. The function takes a single parameter, namely the value.</p>
</dd>
<dt class="calibre15"><code class="calibre19">assign</code></dt>
<dd class="calibre16">
<p class="calibre17">Takes a Swift key path and an object. Whenever a value is received, assigns that value to the property of that object designated by the key path.</p>
</dd>
</dl>

<p class="author1">So hereâ€™s a complete publish-and-subscribe example:</p>

<pre data-type="programlisting" class="calibre28">let pass = PassthroughSubject&lt;String,Never&gt;()
let sink = pass.sink { print($0) }
pass.send("howdy") // howdy</pre>

<p class="author1">A Subject can also be a subscriber &mdash; and that completes the list of built-in subscribers. There are, on the other hand, a <em class="calibre11">lot</em> of built-in publishers. We can divide these into two broad categories:</p>
<dl class="calibre14">
<dt class="calibre15">Origins</dt>
<dd class="calibre16">
<p class="calibre17">An origin (a term Iâ€™ve made up) is a true source of values. A number of Foundation types vend publishers that act as origins. Here are some:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The notification center</p>
</li>
<li class="calibre12">
<p class="calibre17">A KVO compliant property</p>
</li>
<li class="calibre12">
<p class="calibre17">A computed property declared with the <code class="calibre19">@Published</code> property wrapper</p>
</li>
<li class="calibre12">
<p class="calibre17">The Timer class</p>
</li>
<li class="calibre12">
<p class="calibre17">A Scheduler (used for delayed performance; DispatchQueue, OperationQueue, and RunLoop are all Schedulers)</p>
</li>
<li class="calibre12">
<p class="calibre17">A URLSession (for obtaining a value via the network)</p>
</li>
</ul>
</dd>
<dt class="calibre15">Operators</dt>
<dd class="calibre16">
<p class="calibre17">An operator is a Publisher that is somewhat like a Subscriber. You attach it to a Publisher, and it produces another Publisher.</p>
</dd>
</dl>

<p class="author1">The real power of the Combine framework lies in the operators (of which there are a great many). By chaining operators, you construct a pipeline that passes along only the information youâ€™re really interested in; the logic of analyzing, filtering, and transforming that information is pushed up into the pipeline itself.<a data-type="indexterm" data-primary="operators" data-secondary="Combine framework" id="calibre_link-1566" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To illustrate, Iâ€™ll use the notification center as my origin. Letâ€™s go back to my example of a Card view that emits a virtual shriek when it is tapped by posting a notification:<a data-type="indexterm" data-primary="notifications" data-secondary="Combine framework" id="calibre_link-1421" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">static let tapped = Notification.Name("tapped")
@objc func tapped() {
    NotificationCenter.default.post(name: Self.tapped, object: self)
}</pre>

<p class="author1">Now letâ€™s say, for purposes of the example, that what the game is interested in when it receives one of these notifications is the string value of the <code class="calibre19">name</code> property of the Card that posted the notification. Getting that information is a two-stage process. First, we have to register to receive notifications at all:</p>

<pre data-type="programlisting" class="calibre28">NotificationCenter.default.addObserver(self,
    selector: #selector(cardTapped), name: Card.tapped, object: nil)</pre>

<p class="author1">Then, when we receive a notification, we have to look to see that its <code class="calibre19">object</code> really is a Card, and if it is, fetch its <code class="calibre19">name</code> property and do something with it:</p>

<pre data-type="programlisting" class="calibre28">@objc func cardTapped(_ n:Notification) {
    if let card = n.object as? Card {
        let name = card.name
        print(name) // or something
    }
}</pre>

<p class="author1">Now letâ€™s do the same thing using the Combine framework. We obtain a publisher from the notification center by calling its <code class="calibre19">publisher</code> method. But we donâ€™t stop there. We donâ€™t want to receive a notification if the <code class="calibre19">object</code> isnâ€™t a Card, so we use the <code class="calibre19">compactMap</code> operator to cast it safely to Card (and if it isnâ€™t a Card, the pipeline just stops as if nothing had happened). We only want the Cardâ€™s <code class="calibre19">name</code>, so we use the <code class="calibre19">map</code> operator to get it. Hereâ€™s the result:</p>

<pre data-type="programlisting" class="calibre28">let cardTappedCardNamePublisher =
    NotificationCenter.default.publisher(for: Card.tapped)
        .compactMap {$0.object as? Card}
        .map {$0.name}</pre>

<p class="author1">Letâ€™s say this is an instance property of our view controller. Then what we now have is an instance property that publishes a string if a Card posts the <code class="calibre19">tapped</code> notification, and otherwise does nothing. Do you see what I mean when I say that the logic is pushed up into the pipeline? Just for completeness, letâ€™s arrange to receive that string by subscribing to the publisher:</p>

<pre data-type="programlisting" class="calibre28">let sink = self.cardTappedCardNamePublisher.sink {
    print($0) // the string name of a card
}</pre>

<p class="author1">Hereâ€™s another example. You may have noticed that I didnâ€™t list controls (UIControl) among the built-in publishers. This means we canâ€™t automatically replace the control target&ndash;action mechanism using the Combine framework. However, with just a little modification, we can turn a control into a publisher. Iâ€™ll demonstrate with a switch control (UISwitch). It has an <code class="calibre19">isOn</code> property, which is changed when the user toggles the switch on or off. The target&ndash;action way to learn that this has happened is through the switchâ€™s <code class="calibre19">.valueChanged</code> control event. Instead, letâ€™s write a UISwitch subclass where we vend a publisher and funnel the <code class="calibre19">isOn</code> value through it:<a data-type="indexterm" data-primary="actions" data-secondary="Combine framework" id="calibre_link-115" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">class MySwitch : UISwitch {
    required init?(coder: NSCoder) {
        super.init(coder:coder)
        self.isOnPublisher = self.isOn
        self.addTarget(self, action: #selector(didChangeOn), for: .valueChanged)
    }
    @Published var isOnPublisher = false
    @objc func didChangeOn() {
        self.isOnPublisher = self.isOn
    }
}</pre>

<p class="author1">That code illustrates the <code class="calibre19">@Published</code> property wrapper. This creates a publisher behind the scenes, and vends it through the dollar-sign <code class="calibre19">projectedValue</code>. With our subclass, the way to be kept informed about changes to the switchâ€™s <code class="calibre19">isOn</code> property is to subscribe to its publisher, namely <code class="calibre19">$isOnPublisher</code>. Suppose we have an outlet to such a switch:<a data-type="indexterm" data-primary="Published" id="calibre_link-1823" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@IBOutlet var mySwitch : MySwitch!</pre>

<p class="author1">Then we can subscribe with <code class="calibre19">sink</code> once again:</p>

<pre data-type="programlisting" class="calibre28">let sink = self.mySwitch.$isOnPublisher.sink {
    print($0)
}</pre>

<p class="author1">But wait &mdash; doesnâ€™t that look awfully familiar? Yes, it does &mdash; and thatâ€™s the point. Using Combine, weâ€™ve effectively reduced the notification center mechanism and the control target&ndash;action mechanism to the <em class="calibre11">same mechanism.</em> Moreover, we made our UISwitch send us messages when a property changes, without bothering to use key&ndash;value observing. We <em class="calibre11">could</em> use key&ndash;value observing &mdash; there is an NSObject <code class="calibre19">publisher(for:)</code> method that lets us specify a key&ndash;value observable property &mdash; but itâ€™s simpler to use the <code class="calibre19">@Published</code> property wrapper, and unlike key&ndash;value observing, it works without our object being an NSObject (or even a class).<a data-type="indexterm" data-primary="keyâ€“value observing" data-secondary="Published instead" id="calibre_link-1191" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The <em class="calibre11">real</em> power of the Combine framework emerges when we build complex pipelines. To illustrate, letâ€™s combine (sorry about that) the notification center pipeline and the switch pipeline. Imagine that our interface consists of Cards along with a switch. When the switch is on, the cards are interactive: the user can tap one, and we hear about it. When the switch is off, the userâ€™s taps do nothing.</p>

<p class="author1">To implement this, we can put the notification center publisher and the switch publisher together into a single pipeline. The Combine publisher that does that is CombineLatest:</p>

<pre data-type="programlisting" class="calibre28">lazy var combination =
    Publishers.CombineLatest(
        self.cardTappedCardNamePublisher, self.mySwitch.$isOnPublisher)</pre>

<p class="author1">What we now have is a publisher that channels the pipelines from our other two publishers into one. It remembers every value that last arrived from either source, and when it gets a new value, it emits a tuple consisting of both values. In our case, thatâ€™s a <code class="calibre19">(String,Bool)</code>.</p>

<p class="author1">However, thatâ€™s not what we actually want to have coming down the pipeline at us. We still want just the string name of the tapped card. So weâ€™ll use the <code class="calibre19">compactMap</code> operator to extract it:</p>

<pre data-type="programlisting" class="calibre28">lazy var combination =
    Publishers.CombineLatest(
        self.cardTappedCardNamePublisher, self.mySwitch.$isOnPublisher)
            .compactMap { $0.0 }</pre>

<p class="author1">Now weâ€™re getting just the string name, but weâ€™re getting <em class="calibre11">too many</em> string names; the switch isnâ€™t having any effect. The pipeline is emitting values in response to user taps even when the switch is off! The whole idea of combining these two publishers was to <em class="calibre11">eliminate</em> any output when the switch is off. So weâ€™ll interpose the <code class="calibre19">filter</code> operator to block any tuples whose Bool is <code class="calibre19">false</code>:</p>

<pre data-type="programlisting" class="calibre28">lazy var combination =
    Publishers.CombineLatest(
        self.cardTappedCardNamePublisher, self.mySwitch.$isOnPublisher)
            .filter { $0.1 }
            .compactMap { $0.0 }</pre>

<p class="author1">This is looking much better. If the user taps while the switch is on, we get the card name. If the user taps while the switch is off, nothing happens. But thereâ€™s still one little problem. The CombineLatest publisher publishes if it gets a value from <em class="calibre11">either</em> of its source publishers. That means we donâ€™t just get a value when the user taps a Card; we also get a value when the user toggles the switch. We donâ€™t want that value to come out the end of the pipeline; we just want to use it to allow or prevent the arrival of the Card name.</p>

<p class="author1">What we want to do here is compare <em class="calibre11">two</em> values: the new tuple coming down the pipeline, and the <em class="calibre11">previous</em> tuple that came down the pipeline most recently. If the difference between the new tuple and the old tuple is merely that the Bool changed, we donâ€™t want to emit a value from the pipeline. The way to compare the current value with the previous value is with the <code class="calibre19">scan</code> operator. Iâ€™ll use that operator to replace the card name string with <code class="calibre19">nil</code> whenever the Bool changes; the <code class="calibre19">compactMap</code> operator will catch this <code class="calibre19">nil</code> and block it from coming out the end of the pipeline:</p>

<pre data-type="programlisting" class="calibre28">lazy var combination =
    Publishers.CombineLatest(
        self.cardTappedCardNamePublisher, self.mySwitch.$isOnPublisher)
            .scan((nil,true)) { $0.1 != $1.1 ? (nil,$1.1) : $1 }
            .filter { $0.1 }
            .compactMap { $0.0 }</pre>

<p class="author1">Our goal is accomplished. If the user taps a Card while the switch is on, the pipeline produces its name. If the user taps a Card while the switch is off, or toggles the switch, nothing happens.</p>

<p class="author1">These examples have only scratched the surface of what the Combine framework can do; but they demonstrate its spirit. And the potential benefits are profound. In <a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a> I complained that the event-driven nature of the Cocoa framework means that youâ€™re bombarded with events through different entry points at different times, so that state has to be maintained in shared instance properties, and understanding the implications of any single entry point method call can be difficult. The Combine framework offers the potential of funneling events into pipelines whose logic can be manipulated internally, so that what comes out is just the information you need when you need it.
<a data-type="indexterm" data-startref="idxCombine" id="calibre_link-471" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect1" data-pdf-bookmark="The Promise of SwiftUI" class="calibre2"><div class="preface" id="calibre_link-2715">
<h1 class="calibre18">The Promise of SwiftUI</h1>

<p class="author1">The SwiftUI framework is a wholesale alternative to Cocoa. Whether it talks to Cocoa under the hood or replaces it altogether isnâ€™t clear and doesnâ€™t matter. It operates on a programming paradigm thatâ€™s completely different from Cocoaâ€™s, and offers the promise of writing iOS apps in a totally different way &mdash; not to mention that the same code might be reusable on Apple TV, Apple Watch, and desktop Macs.
<a data-type="indexterm" data-primary="SwiftUI" id="calibre_link-2178" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">SwiftUI as a whole is outside the scope of this book; it needs a book of its own. The subject here is how objects see and communicate with one another. To illustrate how SwiftUI deals with this question, Iâ€™ll start with the prototypical â€œHello Worldâ€ app:</p>

<pre data-type="programlisting" class="calibre28">struct ContentView : View {
    var body: some View {
        Text("Hello World")
    }
}</pre>

<p class="author1">That code puts the text â€œHello Worldâ€ in the middle of the screen. But how? It doesnâ€™t seem to contain any runnable code. Well, actually it does: <code class="calibre19">body</code> is a computed property, and the curly braces that surround <code class="calibre19">Text("Hello World")</code> are its getter (with <code class="calibre19">return</code> omitted). The interface is constructed in code and returned. But thatâ€™s not quite accurate; it isnâ€™t the <em class="calibre11">interface</em> thatâ€™s returned &mdash; itâ€™s a <em class="calibre11">description</em> of the interface.</p>

<p class="author1">A SwiftUI View is extremely lightweight, and is barely persistent. The <code class="calibre19">body</code> is merely the answer to an occasional question, â€œWhat should this view look like?â€ There is no UIViewController; there isnâ€™t even a UIView &mdash; Text is a struct and View is a protocol. There are no entry points other than the <code class="calibre19">body</code> getter. There is no storyboard; there are no nibs; there are no outlets.</p>

<p class="author1">Now then, letâ€™s say our goal is to add to the interface a button that the user can tap to toggle the text between â€œHello Worldâ€ and â€œGoodbye World.â€ Iâ€™ll start by adding the button without giving it any functionality:</p>

<pre data-type="programlisting" class="calibre28">struct ContentView : View {
    var body: some View {
        HStack {
            Text("Hello World")
            Spacer()
            Button("Tap Me") {
                //
            }
        }.frame(width: 200)
    }
}</pre>

<p class="author1">The Text object returned by the <code class="calibre19">body</code> getter has been replaced by an HStack, which lines up views horizontally. Inside the HStackâ€™s curly braces are three objects in series. That seems impossible syntactically. Whatâ€™s happening? The curly braces after <code class="calibre19">HStack</code> are the body of an anonymous function, supplied using trailing closure syntax as a parameter to HStackâ€™s initializer. That initializer is allowed to â€œlistâ€ three objects because it is fed to a ViewBuilder, which is a function builder (<a data-type="xref" href="#calibre_link-96" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œFunction Buildersâ€</a>); the ViewBuilder wraps up those objects in a TupleView, and that is what is returned from the anonymous function.</p>

<p class="author1">Notice also the <code class="calibre19">frame</code> method being called on the HStack. It determines the width of the HStack on the screen. Whatâ€™s interesting about it is that it <em class="calibre11">is</em> a method. Instead of getting a reference to the HStack object and setting a property of that object, we apply a method directly to that object. This sort of method is called a <em class="calibre11">modifier,</em> and it returns in effect the very same instance to which it was sent. Therefore, modifiers can be chained (just like operators in the Combine framework). For example, if we wanted our text-and-button HStack to have a yellow background with 20-pixel margins, we could write:<a data-type="indexterm" data-primary="SwiftUI" data-secondary="modifiers" id="calibre_link-2180" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="modifiers" id="calibre_link-1358" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">HStack {
    Text("Hello World")
    Spacer()
    Button("Tap Me") {
        //
    }
}.frame(width: 200)
    .padding(20)
    .background(Color.yellow)</pre>

<p class="author1">SwiftUIâ€™s syntax for constructing interfaces is thus declarative and functional rather than imperative and sequential. We do not have to â€œget a referenceâ€ to our HStack in order to customize its appearance; we customize its appearance as part of its initialization.</p>

<p class="author1">The real point I want to get to is how you allow the user to interact with the interface. I promised to give the button some functionality; now Iâ€™m going to do that:</p>

<pre data-type="programlisting" class="calibre28">struct ContentView : View {
    @State var isHello = true <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-100" href="#calibre_link-97"><img src="images/000019.png" alt="1" class="calibre39" /></a>
    var greeting : String {
        self.isHello ? "Hello" : "Goodbye" <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-101" href="#calibre_link-98"><img src="images/000008.png" alt="2" class="calibre39" /></a>
    }
    var body: some View {
        HStack {
            Text(self.greeting + " World")
            Spacer()
            Button("Tap Me") {
                self.isHello.toggle() <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-102" href="#calibre_link-99"><img src="images/000029.png" alt="3" class="calibre39" /></a>
            }
        }.frame(width: 200)
            .padding(20)
            .background(Color.yellow)
    }
}</pre>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-97" href="#calibre_link-100"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">An instance property on which the interface depends &mdash; in this case, whether the text should read â€œHello Worldâ€ or â€œGoodbye Worldâ€ &mdash; is declared with the <code class="calibre19">@State</code> property wrapper. This means that if this propertyâ€™s value changes, and if it is accessed from within the <code class="calibre19">body</code> getter, the <code class="calibre19">body</code> getter should be called again.<a data-type="indexterm" data-primary="State" id="calibre_link-2066" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-98" href="#calibre_link-101"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">For simplicity and clarity, we also declare a computed instance property that translates the Bool of the <code class="calibre19">@State</code> variable into a corresponding string.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-99" href="#calibre_link-102"><img src="images/000029.png" alt="3" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">The buttonâ€™s action &mdash; what it should do when tapped &mdash; is supplied as an anonymous function, using trailing closure syntax, as part of its initializer. That action changes the value of the <code class="calibre19">@State</code> variable. The content of the Text inside the <code class="calibre19">body</code> getter depends upon <code class="calibre19">self.greeting</code> which depends upon <code class="calibre19">isHello</code>, the <code class="calibre19">@State</code> variable. Therefore, when the <code class="calibre19">@State</code> variable changes in reponse to the tapping of the button, the <code class="calibre19">body</code> getter is called again, and the Text content takes on its new value. That is what we set out to accomplish: tapping the button changes the text displayed on the screen.</p></dd>
</dl>

<p class="author1">Notice what did <em class="calibre11">not</em> happen in that example. The button did not use an action&ndash;target architecture: there is no separate target to send a message to, and there is no separate action function. Instead, the action function is part of the button. The action function did not talk to the Text to change what it displays; it talked only to the <code class="calibre19">@State</code> variable. Nor does the <code class="calibre19">@State</code> variable have a setter observer that talks to the Text. Instead, the change in the <code class="calibre19">@State</code> variable effectively flows â€œdownhillâ€ to the <code class="calibre19">body</code> of the View, automatically.</p>

<p class="author1">In that code, then, there are no event handlers, no events, and no action handlers. And there are no references from one object to another. In effect, there is no problem of communicating data from one object to another, because objects donâ€™t try to communicate with one another. There is just a View and its state at any given moment.</p>

<p class="author1">Moreover, state can be maintained <em class="calibre11">only</em> through <code class="calibre19">@State</code> variables. Thatâ€™s because a View stored property canâ€™t be settable; a view is a struct and isnâ€™t mutable. A <code class="calibre19">@State</code> variable, on the other hand, is backed by a property wrapper whose underlying State struct <em class="calibre11">is</em> mutable. In this way, SwiftUI forces you to clarify the locus of state throughout your app.</p>

<p class="author1">Some views have even tighter coupling with a <code class="calibre19">@State</code>. In our Button example, we used an action function to set the value of our <code class="calibre19">@State</code> variable. But a view such as a Toggle takes a Binding:</p>

<pre data-type="programlisting" class="calibre28">Toggle("Friendly", isOn: $isHello)</pre>

<p class="author1">A Toggle is drawn in iOS as text and a UISwitch. The State property wrapper vends a Binding property as its <code class="calibre19">projectedValue</code>. Our <code class="calibre19">@State</code> property is <code class="calibre19">isHello</code>, so its binding is <code class="calibre19">$isHello</code>. We handed that binding to the Toggle when we initialized it. When the user changes the UISwitch value, that bindingâ€™s value is toggled. That change takes place in the <code class="calibre19">@State</code> variable, and so the Text changes accordingly. This is somewhat similar to what we did in the previous section, where we modified a UISwitch to vend a Publisher of its own <code class="calibre19">isOn</code> value &mdash; except that in SwiftUI, the communication between the <code class="calibre19">@State</code> variable and the Toggle is two-way and automatic by way of the Binding. Thus a Toggle has no action function at all, and doesnâ€™t need one, because it is tightly integrated with a Bool property through a Binding.<a data-type="indexterm" data-primary="Binding" id="calibre_link-251" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The pattern of â€œvisibility by instantiationâ€ that I discussed at the start of this chapter is extremely pervasive in SwiftUI. In the examples so far, a string is displayed because we create the Text object directly, calling an initializer to hand it the string. When the button is tapped or the toggleâ€™s UISwitch is changed, where a Cocoa view controller would need an outlet to a UILabel and would use it to change the UILabelâ€™s <code class="calibre19">text</code> property, SwiftUI simply calls the <code class="calibre19">body</code> getter <em class="calibre11">again</em> and the Text object is created <em class="calibre11">again</em> with a different string in its initializer.</p>

<p class="author1">When one view wraps another, if the outer view is a custom view, a custom property of the outer view will often be used as an intermediary. Once again, the data will typically be handed off in the outer viewâ€™s initializer. This is easy to arrange because View is just a protocol; we adopt it with a custom struct, and we are free to design that struct however we like. Typically, you wonâ€™t even bother to write an initializer; the implicit memberwise initializer will be sufficient. In this example, we present a secondary view modally:</p>

<pre data-type="programlisting" class="calibre28">struct ContentView : View {
    @State var isHello = true
    var greeting : String {
        self.isHello ? "Hello" : "Goodbye"
    }
    @State var showSheet = false
    var body: some View {
        VStack {
            Button("Show Message") {
                self.showSheet.toggle()
            }.sheet(isPresented: $showSheet) {
                Greeting(greeting: self.greeting)
            }
            Spacer()
            Toggle("Friendly", isOn: $isHello)
        }.frame(width: 150, height: 100)
            .padding(20)
            .background(Color.yellow)
    }
}
struct Greeting : View {
    let greeting : String
    var body: some View {
        Text(greeting + " World")
    }
}</pre>

<p class="author1">The <code class="calibre19">sheet</code> modifier is the equivalent of a Cocoa presented view controller. It describes a view that we intend to present modally. Whether it is actively presenting that view modally depends upon a binding to a Bool, which we have supplied by adding a <code class="calibre19">@State</code> variable called <code class="calibre19">showSheet</code>. The Button toggles <code class="calibre19">showSheet</code> to <code class="calibre19">true</code>, and the binding <code class="calibre19">$showSheet</code> toggles to <code class="calibre19">true</code> in response, and causes the view to be presented.</p>

<p class="author1">The view we want to present is a wrapper for a Text that will display the â€œHello worldâ€ greeting; we have named that wrapper view Greeting, and we instantiate it in an anonymous function that we supply as the last parameter to the <code class="calibre19">sheet</code> modifier, using trailing closure syntax. When we instantiate Greeting, we must also  <em class="calibre11">configure</em> the Greeting instance we are creating. We do that through the Greeting initializer. The Greeting struct belongs to us, so weâ€™re free to give it a <code class="calibre19">greeting</code> property, and Swift synthesizes the memberwise initializer with a <code class="calibre19">greeting:</code> parameter. All we have to do is set that property as we create the Greeting. Once again, the data flows â€œdownhill.â€</p>

<p class="author1">What about when the data needs to flow â€œuphillâ€ out of the secondary view back to the view that presented it? This is the sort of problem that youâ€™d solve in UIKit using the Cocoa protocol-and-delegate pattern. In SwiftUI, you simply â€œlendâ€ the secondary view the binding from a <code class="calibre19">@State</code> variable. For example, suppose our Greeting view is to contain a text field (SwiftUI TextField) in which is to be entered the userâ€™s name, and that this information is to be communicated back to our ContentView. Then ContentView would contain another <code class="calibre19">@State</code> variable:</p>

<pre data-type="programlisting" class="calibre28">@State var name = ""</pre>

<p class="author1">And Greeting would containg a <code class="calibre19">@Binding</code> variable:</p>

<pre data-type="programlisting" class="calibre28">@Binding var username : String</pre>

<p class="author1">When ContentView initializes Greeting, the memberwise initializer now has a <code class="calibre19">username:</code> parameter that takes a string Binding; we hand it the binding from the <code class="calibre19">@State</code> variable:</p>

<pre data-type="programlisting" class="calibre28">Button("Show Message") {
    self.showSheet.toggle()
}.sheet(isPresented: $showSheet) {
    Greeting(greeting: self.greeting,
             username: self.$name)
}</pre>

<p class="author1">And Greetingâ€™s TextField is initialized with that binding:</p>

<pre data-type="programlisting" class="calibre28">TextField("Your Name", text:$username)
    .frame(width:200)
    .textFieldStyle(.roundedBorder)</pre>

<p class="author1">Thus, whatever the user types in this text field in the Greeting view flows â€œuphillâ€ through the <code class="calibre19">username</code> binding, which is the <code class="calibre19">@State</code> variable <code class="calibre19">name</code> binding, and changes the value of the <code class="calibre19">@State</code> variable <code class="calibre19">name</code> back in the ContentView. And now the data flows â€œdownhillâ€ once more: the ContentView <code class="calibre19">body</code> getter will be called again, and all views that depend upon this <code class="calibre19">@State</code> variable will change to match.</p>

<p class="author1">Once again, whatâ€™s most significant in that example is what we <em class="calibre11">didnâ€™t</em> do. We didnâ€™t get a reference from the Greeting back to the ContentView. The Greeting didnâ€™t call any method of the ContentView. It didnâ€™t set a property of the ContentView. It set its <em class="calibre11">own</em> property, <code class="calibre19">username</code>. Communication between objects functions through bindings in SwiftUI. They are like little pipelines from one object to another &mdash; and the object at one end (our Greeting) doesnâ€™t have to know anything about whatâ€™s at the other end.<a data-type="indexterm" data-primary="pipeline" data-secondary="SwiftUI binding" id="calibre_link-1694" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can construct your own binding by writing a custom class that conforms to the BindableObject protocol. You assign an instance of this class into an <code class="calibre19">@ObjectBinding</code> variable, and then you can access the binding through the dollar-sign <code class="calibre19">wrappedValue</code> of the underlying ObjectBinding property wrapper struct. Typically youâ€™ll use BindableObject to embody some general functionality or state. For example, your appâ€™s data might reside in a BindableObject.<a data-type="indexterm" data-primary="BindableObject" id="calibre_link-250" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To illustrate, suppose we want the name entered by the user to persist between launches. We can use the global UserDefaults for this. One way to implement access to UserDefaults is through a BindableObject. Iâ€™ll write a simple Defaults class with a <code class="calibre19">username</code> property that is a computed variable backed by a UserDefaults entry:</p>

<pre data-type="programlisting" class="calibre28">class Defaults : BindableObject {
    var willChange = PassthroughSubject&lt;Void, Never&gt;()
    var username : String {
        get {
            UserDefaults.standard.string(forKey: "name") ?? ""
        }
        set {
            self.willChange.send()
            UserDefaults.standard.set(newValue, forKey: "name")
        }
    }
}</pre>

<p class="author1">The sole requirement of the BindableObject protocol is a <code class="calibre19">willChange</code> property that is a Publisher (as described in the previous section). The minimal Publisher is a simple PassthroughSubject that doesnâ€™t pass any value; it simply notifies its subscribers whenever its <code class="calibre19">send</code> method is called. We call <code class="calibre19">send</code> whenever our <code class="calibre19">username</code> computed property is set, thus fulfilling the requirement.</p>

<p class="author1">In our ContentView, there is no longer a <code class="calibre19">@State</code> property called <code class="calibre19">name</code>; it is replaced by an <code class="calibre19">@ObjectBinding</code> property of type Defaults:</p>

<pre data-type="programlisting" class="calibre28">@ObjectBinding var defaults = Defaults()</pre>

<p class="author1">When we need to access the value of the Defaults <code class="calibre19">username</code> property, we do so directly:</p>

<pre data-type="programlisting" class="calibre28">Text(self.defaults.username.isEmpty ? "" :
    greeting + ", " + self.defaults.username)</pre>

<p class="author1">When we need a binding to the Defaults <code class="calibre19">username</code> property, we pass through the binding from <code class="calibre19">defaults</code>, namely <code class="calibre19">$defaults</code>:</p>

<pre data-type="programlisting" class="calibre28">Button("Show Message") {
    self.showSheet.toggle()
}.sheet(isPresented: $showSheet) {
    Greeting(greeting: self.greeting,
             username: self.$defaults.username)
}</pre>

<p class="author1">SwiftUI also has a notion of global objects that all views can access (â€œglobal visibilityâ€). Swift maintains an EnvironmentValues object containing a miscellaneous grab-bag of information and settings. Any view can reach into this object through a property that uses the <code class="calibre19">@Environment</code> property wrapper, whose initializer takes a key path.</p>

<p class="author1">There is also a global Environment into which you can inject your own objects with the <code class="calibre19">environmentObject</code> modifier. Such an object needs to be a BindableObject. Objects that you inject flow â€œdownhillâ€ through the view hierarchy, so if you want an object to be global to your <em class="calibre11">entire</em> app, call <code class="calibre19">environmentObject</code> on the root object created in the scene delegate:</p>

<pre data-type="programlisting" class="calibre28">window.rootViewController =
    UIHostingController(
        rootView: ContentView()
           .environmentObject(Defaults())
)</pre>

<p class="author1">A view retrieves an Environment object through a property that uses the <code class="calibre19">@EnvironmentObject</code> property wrapper; simple declaration of the objectâ€™s type is sufficient to capture a reference to the instance:</p>

<pre data-type="programlisting" class="calibre28">@EnvironmentObject var defaults : Defaults</pre>

<p class="author1">The examples in this section have demonstrated the heart of SwiftUI, namely its object and data flow architecture. SwiftUIâ€™s heart is in the right place! The designers of SwiftUI have understood that in Cocoa, being bombarded by events, and having to maintain consistent state, and coordinating that state with the interface, is hard. The SwiftUI approach promises a welcome paradigm shift to a completely different way of communicating data and coordinating state and interface.
<a data-type="indexterm" data-startref="idxSwiftUI" id="calibre_link-2179" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-2738">
<div id="calibre_link-3014" class="calibre1"><section data-type="appendix" {http://www.idpf.org/2007/ops}type="appendix" data-pdf-bookmark="Appendix A. C, Objective-C, and Swift" class="calibre2"><div class="preface" id="calibre_link-51">
<h1 class="calibre13"><span class="label">Appendix A. </span>C, Objective-C, and Swift</h1>


<p class="author1">Programming iOS involves communicating with Cocoa and its supplementary frameworks. The APIs for those frameworks are written in Objective-C or in its underlying base language, C. Messages that you send to Cocoa using Swift are being translated for you into Objective-C. Objects that you send and receive back and forth across the Swift/Objective-C bridge are Objective-C objects. Some objects that you send from Swift to Objective-C are even being translated for you into other object types, or into nonobject types.<a data-type="indexterm" data-primary="Objective-C" data-seealso="bridged types" id="calibre_link-1510" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">This appendix summarizes the relevant linguistic features of C and Objective-C, and describes how Swift interfaces with those features. I do not explain here how to write Objective-C! For example, Iâ€™ll talk about Objective-C methods and method declarations, because you need to know how to call an Objective-C method from Swift; but Iâ€™m not going to explain how to call an Objective-C method using Objective-C.</p>






<section data-type="sect1" data-pdf-bookmark="The C Language" class="calibre2"><div class="preface" id="calibre_link-2716">
<h1 class="calibre18">The C Language</h1>

<p class="author1">Objective-C is a superset of C; to put it another way, C provides the linguistic underpinnings of Objective-C. Everything that is true of C is true also of Objective-C. It is possible, and often necessary, to write long stretches of Objective-C code that are, in effect, pure C. Some of the Cocoa APIs are written in C. Therefore, in order to know about Objective-C, it is necessary to know about C.<a data-type="indexterm" data-primary="C" data-seealso="Objective-C" id="calibre_link-310" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">C statements, including declarations, must end in a semicolon. Variables must be declared before use. A variable declaration consists of a data type name followed by the variable name, optionally followed by assignment of an initial value:</p>

<pre data-type="programlisting" class="calibre28">int i;
double d = 3.14159;</pre>

<p class="author1">The C <code class="calibre19">typedef</code> statement starts with an existing type name and defines a new synonym for it:</p>

<pre data-type="programlisting" class="calibre28">typedef double NSTimeInterval;</pre>








<section data-type="sect2" data-pdf-bookmark="C Data Types" class="calibre2"><div class="preface" id="calibre_link-2717">
<h2 class="calibre42">C Data Types</h2>

<p class="author1">C is not an object-oriented language; its data types are not objects (they are <em class="calibre11">scalars</em>). The basic built-in C data types are all numeric: char (one byte), int (four bytes), float and double (floating-point numbers), and varieties such as short (short integer), long (long integer), unsigned short, and so on. Objective-C adds NSInteger, NSUInteger (unsigned), and CGFloat. The C bool type is actually a numeric, with zero representing false; Objective-C adds BOOL, which is also a numeric. The C native text type (string) is actually a null-terminated array of char.<a data-type="indexterm" data-primary="scalars" id="calibre_link-1946" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="C" data-secondary="data types" id="calibre_link-314" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Swift supplies numeric types that interface directly with C numeric types, even though Swiftâ€™s types are objects and Câ€™s types are not. Swift type aliases provide names that correspond to the C type names: a Swift CBool (Bool) is a C bool, a Swift CChar (Int8) is a C char, a Swift CInt (Int32) is a C int, a Swift CFloat (Float) is a C float, and so on. Swift Int interchanges with NSInteger; Swift UInt interchanges with NSUInteger. Swift ObjCBool represents Objective-C BOOL. CGFloat is adopted as a Swift type name.</p>

<p class="author1">A major difference between C and Swift is that C (and therefore Objective-C) implicitly coerces when values of different numeric types are assigned, passed, compared to, or combined with one another; Swift doesnâ€™t, so you must coerce explicitly to make types match exactly, as I described in <a data-type="xref" href="#calibre_link-58" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;3</a>.<a data-type="indexterm" data-primary="coercion" data-secondary="numeric" id="calibre_link-450" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The native C string type, a null-terminated array of char, may be typed in Swift as <code class="calibre19">[Int8]</code> or <code class="calibre19">[CChar]</code> (because CChar <em class="calibre11">is</em> Int8) or, for reasons that will be clear later, as <code class="calibre19">UnsafePointer&lt;Int8&gt;</code> or <code class="calibre19">UnsafePointer&lt;CChar&gt;</code>. A C string canâ€™t be formed as a literal in Swift, but you can pass a Swift String where a C string is expected. If you need to create a C string variable, the NSString <code class="calibre19">utf8String</code> property or the Swift Foundation overlayâ€™s <code class="calibre19">cString(using:)</code> method can be used to form a C string. Alternatively, you can use the String <code class="calibre19">utf8CString</code> property (a <code class="calibre19">ContiguousArray&lt;CChar&gt;</code>) or the <code class="calibre19">withCString</code> method; in this example, I cycle through the bytes of the C string until I reach the null terminator (Iâ€™ll explain the <code class="calibre19">pointee</code> property a bit later):<a data-type="indexterm" data-primary="C" data-secondary="strings" id="calibre_link-323" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="C strings" id="calibre_link-2090" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">"hello".withCString {
    var cs = $0 // UnsafePointer&lt;Int8&gt;
    while cs.pointee != 0 {
        print(cs.pointee)
        cs += 1 // or: cs = cs.successor()
    }
}</pre>

<p class="author1">In the other direction, a UTF-8 C string (including ASCII) can be rendered into a Swift String by way of a Swift String initializer such as <code class="calibre19">init(cString:)</code> or <code class="calibre19">init?(validatingUTF8:)</code>. To specify some other encoding, call the static method <code class="calibre19">decodeCString(_:as:)</code>.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="C Enums" class="calibre2"><div class="preface" id="calibre_link-2718">
<h2 class="calibre42">C Enums</h2>

<p class="author1">A C enum is numeric; values are some sort of integer, and can be implicit (starting from 0) or explicit. Enums arrive in various forms into Swift, depending on how they are declared.</p>










<section data-type="sect3" data-pdf-bookmark="Old-fashioned C enum" class="calibre2"><div class="preface" id="calibre_link-3015">
<h3 class="calibre44">Old-fashioned C enum</h3>

<p class="author1">This is the simplest and oldest form:<a data-type="indexterm" data-primary="C" data-secondary="enums" id="calibre_link-315" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="enums" data-secondary="C enums" id="calibre_link-753" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">enum State {
    kDead,
    kAlive
};
typedef enum State State;</pre>

<p class="author1">(The <code class="calibre19">typedef</code> in the last line merely allows C programs to use the term <code class="calibre19">State</code> as the name of this type instead of the more verbose <code class="calibre19">enum State</code>.) In C, enumerand names <code class="calibre19">kDead</code> and <code class="calibre19">kAlive</code> are not â€œcasesâ€ of anything; they are not namespaced. They are constants, and as they are not explicitly initialized, they represent 0 and 1 respectively. An enum declaration can specify the integer type further; this one doesnâ€™t, so the values are typed in Swift as UInt32.</p>

<p class="author1">This old-fashioned sort of C enum arrives as a Swift struct adopting the RawRepresentable protocol, and its enumerands (here, <code class="calibre19">kDead</code> and <code class="calibre19">kAlive</code>) arrive into Swift as synonyms for instances of the State struct with an appropriate <code class="calibre19">rawValue</code> (here, 0 and 1 respectively). Notice that I didnâ€™t say anything about namespacing! The enumerands are bare names, not members of the State struct; you say <code class="calibre19">kDead</code>, not <code class="calibre19">State.kDead</code>.</p>

<p class="author1">The result is that you can use the enumerand names as a medium of interchange wherever a State enum arrives from or is expected by C. For example, if a C function <code class="calibre19">setState</code> takes a State enum parameter, you can call it with one of the State enumerand names:</p>

<pre data-type="programlisting" class="calibre28">setState(kDead)</pre>

<p class="author1">If you are curious about what integer is represented by the name <code class="calibre19">kDead</code>, you have to take its <code class="calibre19">rawValue</code>. You can also create an arbitrary State value by calling its <code class="calibre19">init(rawValue:)</code> initializer &mdash; there is no compiler or runtime check to see whether this value is one of the defined constants. But you arenâ€™t expected to do either of those things.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="NS_ENUM" class="calibre2"><div class="preface" id="calibre_link-3016">
<h3 class="calibre44">NS_ENUM</h3>

<p class="author1">Starting back in Xcode 4.4, a C enum notation was introduced that uses the <code class="calibre19">NS_ENUM</code> macro:<a data-type="indexterm" data-primary="NS_ENUM" id="calibre_link-1472" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">typedef NS_ENUM(NSInteger, UIStatusBarAnimation) {
    UIStatusBarAnimationNone,
    UIStatusBarAnimationFade,
    UIStatusBarAnimationSlide,
};</pre>

<p class="author1">That notation both specifies the integer type and associates a type name with this enum as a whole. Swift imports an enum declared this way <em class="calibre11">as a Swift enum</em> with the name and raw value type intact; the enumerand names become namespaced case names, with the common prefix subtracted:</p>

<pre data-type="programlisting" class="calibre28">enum UIStatusBarAnimation : Int {
    case none
    case fade
    case slide
}</pre>

<p class="author1">Going the other way, a Swift enum with an Int raw value type can be exposed to Objective-C using the <code class="calibre19">@objc</code> attribute:<a data-type="indexterm" data-primary="objc" id="calibre_link-1484" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@objc enum Star : Int {
    case blue
    case white
    case yellow
    case red
}</pre>

<p class="author1">Objective-C sees that as an enum with type NSInteger and enumerand names <code class="calibre19">StarBlue</code>, <code class="calibre19">StarWhite</code>, and so on.</p>

<p class="author1">A knotty problem arises when you write a Swift switch statement that exhausts a C enum tagâ€™s cases. What if, in a future release, the C code is changed to add a case to this enum? If that happens, and if your â€œexhaustiveâ€ switch receives an unknown case, youâ€™ll crash. New in Swift 5, thereâ€™s a solution:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">When you compile your code, youâ€™ll be warned by the compiler that this enum â€œmay have additional unknown values.â€ To remove the warning, you add a <code class="calibre19">default</code> case. Normally, the compiler would warn you that your <code class="calibre19">default</code> case will never be executed, because your switch is exhaustive; but in this situation, your switch might <em class="calibre11">not</em> be exhaustive some day, so that warning doesnâ€™t appear.</p>
</li>
<li class="calibre12">
<p class="calibre17">In addition, you mark the <code class="calibre19">default</code> case with the <code class="calibre19">@unknown</code> attribute. This tells the compiler that you <em class="calibre11">think</em> your switch is exhaustive (without the <code class="calibre19">default</code>), and youâ€™d like to be warned if it isnâ€™t. If your switch isnâ€™t exhaustive, youâ€™ll get the warning now; if some day a new case is added to the enum, youâ€™ll get the warning then, and you can silence it by adding the new case to your switch.<a data-type="indexterm" data-primary="unknown default" id="calibre_link-2282" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="switch" id="calibre_link-2182" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">Letâ€™s demonstrate. Hereâ€™s a C enum:</p>

<pre data-type="programlisting" class="calibre28">typedef NS_ENUM(NSInteger, TestEnum) {
    TestEnumOne
    TestEnumTwo
};</pre>

<p class="author1">This arrives into Swift as an enum called TestEnum. Hereâ€™s an exhaustive switch over a TestEnum:</p>

<pre data-type="programlisting" class="calibre28">switch test { // test is a TestEnum
case .one : break
case .two : break
} // compiler warns</pre>

<p class="author1">We get a warning from the compiler. Our switch looks exhaustive, but in the future it might not be. So we add an <code class="calibre19">@unknown default</code> case, and the warning goes away:</p>

<pre data-type="programlisting" class="calibre28">switch test { // test is a TestEnum
case .one : break
case .two : break
@unknown default: break
}</pre>

<p class="author1">Suppose the C enum later acquires another case (<code class="calibre19">case .three</code>). No problem! Our Swift switch is crash-proof, because thereâ€™s a <code class="calibre19">default</code> case. Even better, when we compile against the C code, our Swift switch will get another warning, telling us that the switch is no longer exhaustive.</p>

<p class="author1">If the Objective-C code is our own, and if weâ€™re sure that the C enum will never acquire a new case, we can mark it with <code class="calibre19">NS_CLOSED_ENUM</code> instead of <code class="calibre19">NS_ENUM</code>; this will cause Swift to treat TestEnum like an ordinary Swift enum.</p>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Some enums in the Swift standard library and Foundation overlays are marked as open to future additional cases in the same way as <code class="calibre19">NS_ENUM</code>.</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="NS_OPTIONS" class="calibre2"><div class="preface" id="calibre_link-3017">
<h3 class="calibre44">NS_OPTIONS</h3>

<p class="author1">Another variant of C enum notation, using the <code class="calibre19">NS_OPTIONS</code> macro, is suitable for <span class="publishername">bitmasks:</span><a data-type="indexterm" data-primary="bitmasks" id="calibre_link-257" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="NS_OPTIONS" id="calibre_link-1473" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
    UIViewAutoresizingNone                 = 0,
    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,
    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,
    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,
    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,
    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,
    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5
};</pre>

<p class="author1">An enum declared like that arrives into Swift as a struct adopting the OptionSet protocol. The OptionSet protocol adopts the RawRepresentable protocol, so this is a struct with a <code class="calibre19">rawValue</code> instance property holding the underlying integer. The C enum case names are represented by static properties, each of whose values is an instance of this struct; the names of these static properties are imported with the common prefix subtracted. Starting in Swift 4.2, this particular struct is namespaced by nesting it into the UIView class as <span class="publishername">UIView.AutoresizingMask</span>:<a data-type="indexterm" data-primary="OptionSet" id="calibre_link-1632" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="option sets" id="calibre_link-1585" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="sets" data-secondary="option sets" id="calibre_link-2016" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct AutoresizingMask : OptionSet {
    init(rawValue: UInt)
    static var flexibleLeftMargin: UIView.AutoresizingMask { get }
    static var flexibleWidth: UIView.AutoresizingMask { get }
    static var flexibleRightMargin: UIView.AutoresizingMask { get }
    static var flexibleTopMargin: UIView.AutoresizingMask { get }
    static var flexibleHeight: UIView.AutoresizingMask { get }
    static var flexibleBottomMargin: UIView.AutoresizingMask { get }
}</pre>

<p class="author1">When you say something like <code class="calibre19">UIView.AutoresizingMask.flexibleLeftMargin</code>, it <em class="calibre11">looks</em> as if you are initializing a case of a Swift enum, but in fact this is an instance of the <span class="publishername">UIView.AutoresizingMask</span> struct, whose <code class="calibre19">rawValue</code> property has been set to the value declared by the original C enum &mdash; which, for <code class="calibre19">.flexibleLeftMargin</code>, is <code class="calibre19">1&lt;&lt;0</code>. Because a static property of this struct is an instance of the same struct, you can, as I explained in <a data-type="xref" href="#calibre_link-2739" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œInference of Type Name with Static/Class Membersâ€</a>, omit the struct name when supplying a static property name where the struct is expected:</p>

<pre data-type="programlisting" class="calibre28">self.view.autoresizingMask = .flexibleWidth</pre>

<p class="author1">Because this is an OptionSet struct, you can represent and manipulate the bitmask as if it were a Set:</p>

<pre data-type="programlisting" class="calibre28">self.view.autoresizingMask = [.flexibleWidth, .flexibleHeight]</pre>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">In Objective-C, where an <code class="calibre19">NS_OPTIONS</code> enum is expected, you pass <code class="calibre19">0</code> to indicate that no options are provided. In Swift, where a corresponding struct is expected, you pass <code class="calibre19">[]</code> (an empty set) or omit the <code class="calibre19">options:</code> parameter entirely. Some <code class="calibre19">NS_OPTIONS</code> enums have an explicit option that <em class="calibre11">means</em> <code class="calibre19">0</code>; Swift sometimes wonâ€™t bother to import its name, because passing <code class="calibre19">[]</code> means the same thing. For example, to set a <span class="publishername">UIView.AutoresizingMask</span> value to <code class="calibre19">UIViewAutoresizingNone</code> in Swift, set it to <code class="calibre19">[]</code> (not <code class="calibre19">.none</code>).</p>
</div>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Global string constants" class="calibre2"><div class="preface" id="calibre_link-3018">
<h3 class="calibre44">Global string constants</h3>

<p class="author1">The names of many Objective-C global string constants (referred to jokingly by Apple as â€œstringly typedâ€) are namespaced by importing them into Swift as static struct properties. This is accomplished by means of the <code class="calibre19">NS_STRING_ENUM</code> and <code class="calibre19">NS_EXTENSIBLE_STRING_ENUM</code> Objective-C macros. For example, the names of the NSAttributedString attribute keys used to be simple global string constants (type <code class="calibre19">NSString*</code>):<a data-type="indexterm" data-primary="stringly typed" id="calibre_link-2087" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="strings" data-secondary="constants, global" id="calibre_link-2095" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="constants" data-secondary="global string" id="calibre_link-541" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">NSString* const NSFontAttributeName;
NSString* const NSParagraphStyleAttributeName;
NSString* const NSForegroundColorAttributeName;
// ... and so on ...</pre>

<p class="author1">This meant that they were global string constants in Swift as well. Now, however, they are typed as NSAttributedStringKey values:</p>

<pre data-type="programlisting" class="calibre28">NSAttributedStringKey const NSFontAttributeName;
NSAttributedStringKey const NSParagraphStyleAttributeName;
NSAttributedStringKey const NSForegroundColorAttributeName;
// ... and so on ...</pre>

<p class="author1">NSAttributedStringKey, in Objective-C, is just a synonym for NSString, but it is marked with the <code class="calibre19">NS_EXTENSIBLE_STRING_ENUM</code> macro:</p>

<pre data-type="programlisting" class="calibre28">typedef NSString * NSAttributedStringKey NS_EXTENSIBLE_STRING_ENUM;</pre>

<p class="author1">The result is that these names are imported into Swift as namespaced static properties of an <span class="publishername">NSAttributedString.Key</span> struct
with names like <code class="calibre19">.name</code>, <code class="calibre19">.paragraphStyle</code>,
and so on. Moreover, a dictionary that expects these keys has a key type of <span class="publishername">NSAttributedString.Key</span>, so you can write compact code like this:</p>

<pre data-type="programlisting" class="calibre28">UINavigationBar.appearance().titleTextAttributes = [
    .font: UIFont(name: "ChalkboardSE-Bold", size: 20)!,
    .foregroundColor: UIColor.darkText
]</pre>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="C Structs" class="calibre2"><div class="preface" id="calibre_link-2719">
<h2 class="calibre42">C Structs</h2>

<p class="author1">A C struct is a compound type whose elements can be accessed by name using dot-notation after a reference to the struct:<a data-type="indexterm" data-primary="C" data-secondary="structs" id="calibre_link-325" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="C structs" id="calibre_link-2124" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">struct CGPoint {
   CGFloat x;
   CGFloat y;
};
typedef struct CGPoint CGPoint;</pre>

<p class="author1">After that declaration, it becomes possible to talk like this in C:</p>

<pre data-type="programlisting" class="calibre28">CGPoint p;
p.x = 100;
p.y = 200;</pre>

<p class="author1">A C struct arrives wholesale into Swift as a Swift struct, which is thereupon endowed with Swift struct features. CGPoint in Swift has CGFloat instance properties <code class="calibre19">x</code> and <code class="calibre19">y</code>, but it also magically acquires the implicit memberwise initializer! In addition, a zeroing initializer with no parameters is injected; thus, saying <code class="calibre19">CGPoint()</code> makes a CGPoint whose <code class="calibre19">x</code> and <code class="calibre19">y</code> are both 0. Extensions can supply additional features, and the Swift CoreGraphics header adds a few to CGPoint:</p>

<pre data-type="programlisting" class="calibre28">extension CGPoint {
    static var zero: CGPoint { get }
    init(x: Int, y: Int)
    init(x: Double, y: Double)
}</pre>

<p class="author1">As you can see, a Swift CGPoint has additional initializers accepting Int or Double arguments, along with another way of making a zero CGPoint, <code class="calibre19">CGPoint.zero</code>. CGSize is treated similarly. CGRect is particularly well endowed with added methods and properties in Swift.</p>

<p class="author1">The fact that a Swift struct is an object, while a C struct is not, does not pose any problems of communication. You can assign or pass a Swift CGPoint where a C CGPoint is expected, because CGPoint came from C in the first place. The fact that Swift has endowed CGPoint with object methods and properties doesnâ€™t matter; C doesnâ€™t see them. All C cares about are the <code class="calibre19">x</code> and <code class="calibre19">y</code> elements of this CGPoint, which are communicated from Swift to C without difficulty.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="C Pointers" class="calibre2"><div class="preface" id="calibre_link-2720">
<h2 class="calibre42">C Pointers</h2>

<p class="author1">A C pointer is an integer designating the location in memory (the <em class="calibre11">address</em>) where the real data resides. Allocating and disposing of that memory is a separate matter. The declaration for a pointer to a data type is written with an asterisk after the data type name; a space can appear on either or both sides of the asterisk. These are equivalent declarations of a pointer-to-int:<a data-type="indexterm" data-primary="C" data-secondary="pointers" id="calibre_link-322" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="pointers" data-secondary="C" id="calibre_link-1705" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">int *intPtr1;
int* intPtr2;
int * intPtr3;</pre>

<p class="author1">The type name itself is <code class="calibre19">int*</code> (or, with a space, <code class="calibre19">int&nbsp;*</code>). Objective-C, for reasons that Iâ€™ll explain later, uses C pointers heavily, so youâ€™re going to be seeing that asterisk a lot if you look at any Objective-C.</p>

<p class="author1">A C pointer arrives into Swift as an UnsafePointer or, if writable, an UnsafeMutablePointer; this is a generic, and is specified to the actual type of data pointed to. (A pointer is â€œunsafeâ€ because Swift isnâ€™t managing the memory for, and canâ€™t even guarantee the integrity of, what is pointed to.)<a data-type="indexterm" data-primary="UnsafePointer" id="calibre_link-2294" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="UnsafeMutablePointer" id="calibre_link-2292" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">To illustrate, hereâ€™s an Objective-C UIColor method declaration; I havenâ€™t discussed this syntax yet, but just concentrate on the types in parentheses:</p>

<pre data-type="programlisting" class="calibre28">- (BOOL) getRed: (CGFloat *) red
    green: (CGFloat *) green
    blue: (CGFloat *) blue
    alpha: (CGFloat *) alpha;</pre>

<p class="author1">CGFloat is a basic numeric type. The type <code class="calibre19">CGFloat&nbsp;*</code>, despite the space, states that these parameters are all <code class="calibre19">CGFloat*</code> &mdash; that is, pointer-to-CGFloat.</p>

<p class="author1">The Swift translation of that declaration looks, in effect, like this:</p>

<pre data-type="programlisting" class="calibre28">func getRed(_ red: UnsafeMutablePointer&lt;CGFloat&gt;,
    green: UnsafeMutablePointer&lt;CGFloat&gt;,
    blue: UnsafeMutablePointer&lt;CGFloat&gt;,
    alpha: UnsafeMutablePointer&lt;CGFloat&gt;) -&gt; Bool</pre>

<p class="author1">UnsafeMutablePointer in this context is used like a Swift <code class="calibre19">inout</code> parameter: you declare and initialize a <code class="calibre19">var</code> of the appropriate type beforehand, and then pass its address as argument by way of the <code class="calibre19">&amp;</code> prefix operator. When you pass the address of a reference in this way, you are in fact creating and passing a pointer:<a data-type="indexterm" data-primary="address operator" id="calibre_link-126" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-primary="ampersand" data-see="address operator" id="calibre_link-3019" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">var r : CGFloat = 0
var g : CGFloat = 0
var b : CGFloat = 0
var a : CGFloat = 0
c.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</pre>

<p class="author1">In C, to access the memory pointed to by a pointer, you use an asterisk before the pointerâ€™s name: <code class="calibre19">*intPtr</code> is â€œthe thing pointed to by the pointer <code class="calibre19">intPtr</code>.â€ In Swift, you use the pointerâ€™s <code class="calibre19">pointee</code> property.<a data-type="indexterm" data-primary="pointee" id="calibre_link-1699" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In this example, we receive a <code class="calibre19">stop</code> parameter typed originally as a <code class="calibre19">BOOL*</code>, a pointer-to-BOOL; in Swift, itâ€™s an <code class="calibre19">UnsafeMutablePointer&lt;ObjCBool&gt;</code>. To set the BOOL at the far end of this pointer, we set the pointerâ€™s <code class="calibre19">pointee</code>:</p>

<pre data-type="programlisting" class="calibre28">// mas is an NSMutableAttributedString, r is an NSRange, f is a UIFont
mas.enumerateAttribute(.font, in: r) { value, r, stop in
    if let value = value as? UIFont, value == f  {
        // ...
        stop.pointee = true
    }
}</pre>

<p class="author1">The most general type of C pointer is pointer-to-void (<code class="calibre19">void*</code>), also known as the <em class="calibre11">generic pointer</em>. The term <code class="calibre19">void</code> here means that no type is specified; it is legal in C to use a generic pointer wherever a specific type of pointer is expected, and <em class="calibre11">vice versa</em>. In effect, pointer-to-void casts away type checking as to whatâ€™s at the far end of the pointer. This will appear in Swift as a â€œrawâ€ pointer, either UnsafeRawPointer<a data-type="indexterm" data-primary="UnsafeRawPointer" id="calibre_link-2296" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> or UnsafeMutableRawPointer<a data-type="indexterm" data-primary="UnsafeMutableRawPointer" id="calibre_link-2293" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a>. In general, when you encounter pointers of this type, if you need to access the underlying data, youâ€™ll start by <em class="calibre11">rebinding</em> its memory to an unsafe pointer generic specified to the underlying type:<a data-type="indexterm" data-primary="generic pointer" id="calibre_link-945" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="pointers" data-secondary="generic" id="calibre_link-1707" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="pointer-to-void" id="calibre_link-1700" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="void" id="calibre_link-2359" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="C" data-secondary="pointer-to-void" id="calibre_link-321" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// buff is a CVImageBuffer
if let baseAddress = CVPixelBufferGetBaseAddress(buff) {
    // baseAddress is an UnsafeMutableRawPointer
    let addrptr = baseAddress.assumingMemoryBound(to: UInt8.self)
    // addrptr is an UnsafeMutablePointer&lt;UInt8&gt;
    // ...
}</pre>
<div data-type="warning" {http://www.idpf.org/2007/ops}type="warning" class="calibre25"><h6 class="calibre26">Warning</h6>
<p class="author1">Itâ€™s fine to take the address of a variable reference and hand it to a C function that returns immediately, but do not <em class="calibre11">persist</em> such an address yourself. If <code class="calibre19">r</code> is a CGFloat, saying <code class="calibre19">let rPtr = &amp;r</code> is a really bad idea. If you need to do that sort of thing, call some form of <code class="calibre19">withUnsafePointer</code>, which takes an anonymous function within which the pointer is valid.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="C Arrays" class="calibre2"><div class="preface" id="calibre_link-2721">
<h2 class="calibre42">C Arrays</h2>

<p class="author1">A C array contains a fixed number of elements of a single data type. Under the hood, it is a contiguous block of memory sized to accommodate this number of elements of this data type. For this reason, the name of an array in C is the name of a pointer to the first element of the array. For example, if <code class="calibre19">arr</code> has been declared as an array of int, the term <code class="calibre19">arr</code> can be used wherever a value of type <code class="calibre19">int*</code> (a pointer-to-int) is expected. The C language will indicate an array type either by appending square brackets to a reference or as a pointer.<a data-type="indexterm" data-primary="C" data-secondary="arrays" id="calibre_link-312" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="C arrays" id="calibre_link-184" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> (That explains why C strings may be typed in Swift as an unsafe pointer to Int8 or CChar: a C string is an array of char, so itâ€™s a pointer to char.)</p>

<p class="author1">For example, the C function <code class="calibre19">CGContextStrokeLineSegments</code> is declared like this:</p>

<pre data-type="programlisting" class="calibre28">void CGContextStrokeLineSegments(CGContextRef c,
   const CGPoint points[],
   size_t count
);</pre>

<p class="author1">The second parameter is a C array of CGPoints; thatâ€™s what the square brackets tell you. A C array carries no information about how many elements it contains, so to pass this C array to this function, you must also <em class="calibre11">tell</em> the function how many elements the array contains; thatâ€™s what the third parameter is for. A C array of CGPoint is a pointer to a CGPoint, so this functionâ€™s declaration is translated into Swift like this:</p>

<pre data-type="programlisting" class="calibre28">func __strokeLineSegments(
    between points: UnsafePointer&lt;CGPoint&gt;?,
    count: Int)</pre>

<p class="author1">Now, youâ€™re not really expected to call this function; the CGContext Swift overlay provides a pure Swift version, <code class="calibre19">strokeLineSegments</code>, which takes a Swift array of CGPoint with no need to provide a <code class="calibre19">count</code>. But letâ€™s say you wanted to call <code class="calibre19">__strokeLineSegments</code> instead. How would you do it?</p>

<p class="author1">To call <code class="calibre19">__strokeLineSegments</code> and pass it a C array of CGPoints, it would appear that you need to <em class="calibre11">make</em> a C array of CGPoints. A C array is not, by any stretch of the imagination, a Swift array; so how on earth will you do this? Surprise! You donâ€™t have to. Even though a Swift array is not a C array, you can pass a pointer to a Swift array here. Here, you donâ€™t even need to pass a pointer; you can pass a reference to a Swift array <em class="calibre11">itself</em>. And since this is not a mutable pointer, you can declare the array with <code class="calibre19">let</code>; indeed, you can even pass a Swift array literal! No matter which approach you choose, Swift will convert to a C array for you as the argument crosses the bridge from Swift to C:</p>

<pre data-type="programlisting" class="calibre28">let c = UIGraphicsGetCurrentContext()!
let arr = [CGPoint(x:0,y:0),
    CGPoint(x:50,y:50),
    CGPoint(x:50,y:50),
    CGPoint(x:0,y:100),
]
c.__strokeLineSegments(between: arr, count: arr.count)</pre>

<p class="author1">However, you <em class="calibre11">can</em> form a C array if you really want to. To do so, you must first set aside the block of memory yourself: declare an UnsafeMutablePointer of the desired type, calling the class method <code class="calibre19">allocate(capacity:)</code> with the desired number of elements. You can then write the element values directly into memory. You could do this by manipulating the <code class="calibre19">pointee</code>, but you can also use subscripting, which might be a lot more convenient. Finally, since the UnsafeMutablePointer <em class="calibre11">is</em> a pointer, you pass <em class="calibre11">it</em>, not a pointer to it, as argument:</p>

<pre data-type="programlisting" class="calibre28">let c = UIGraphicsGetCurrentContext()!
let arr = UnsafeMutablePointer&lt;CGPoint&gt;.allocate(capacity:4)
arr[0] = CGPoint(x:0,y:0)
arr[1] = CGPoint(x:50,y:50)
arr[2] = CGPoint(x:50,y:50)
arr[3] = CGPoint(x:0,y:100)
c.__strokeLineSegments(between: arr, count: 4)</pre>

<p class="author1">If youâ€™re going to do that sort of thing, you really need to take upon yourself the full details of memory management. Having allocated this pointerâ€™s memory and assigned values into it, you should eventually remove the values and deallocate the memory:<a data-type="indexterm" data-primary="memory management" data-secondary="UnsafePointer" id="calibre_link-1319" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="UnsafePointer" data-secondary="memory management" id="calibre_link-2295" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let arr = UnsafeMutablePointer&lt;CGPoint&gt;.allocate(capacity:4)
defer {
    arr.deinitialize(count:4)
    arr.deallocate()
}</pre>

<p class="author1">The same convenient subscripting is available when you <em class="calibre11">receive</em> a C array. In this example, <code class="calibre19">col</code> is a UIColor; <code class="calibre19">comp</code> is typed as an UnsafePointer to CGFloat. That is really a C array of CGFloat, and so you can access its elements by subscripting:</p>

<pre data-type="programlisting" class="calibre28">if let comp = col.cgColor.__unsafeComponents,
    let sp = col.cgColor.colorSpace,
    sp.model == .rgb {
        let red = comp[0]
        let green = comp[1]
        let blue = comp[2]
        let alpha = comp[3]
        // ...
}</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="C Functions" class="calibre2"><div class="preface" id="calibre_link-2722">
<h2 class="calibre42">C Functions</h2>

<p class="author1">A C function declaration starts with the return type (which might be <code class="calibre19">void</code>, meaning no returned value), followed by the function name, followed by a parameter list &mdash; parentheses containing comma-separated pairs consisting of the type followed by the parameter name. The parameter names are purely internal. C functions are global, and Swift can call them directly.<a data-type="indexterm" data-primary="C" data-secondary="functions" id="calibre_link-316" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="C functions" id="calibre_link-906" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s the C declaration for an Audio Services function:</p>

<pre data-type="programlisting" class="calibre28">OSStatus AudioServicesCreateSystemSoundID(
    CFURLRef inFileURL,
    SystemSoundID* outSystemSoundID)</pre>

<p class="author1">An OSStatus is basically an Int32. A CFURLRef is a CFTypeRef (<a data-type="xref" href="#calibre_link-2705" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">â€œMemory Management of CFTypeRefsâ€</a>) and is called CFURL in Swift. A SystemSoundID is a UInt32, and the <code class="calibre19">*</code> makes this a C pointer, as we already know. The whole thing thus translates directly into Swift:</p>

<pre data-type="programlisting" class="calibre28">func AudioServicesCreateSystemSoundID(
    _ inFileURL: CFURL,
    _ outSystemSoundID: UnsafeMutablePointer&lt;SystemSoundID&gt;) -&gt; OSStatus</pre>

<p class="author1">CFURL is (for reasons that Iâ€™ll explain later) interchangeable with NSURL and Swift URL; so here we are, calling this C function in Swift:</p>

<pre data-type="programlisting" class="calibre28">let sndurl = Bundle.main.url(forResource: "test", withExtension: "aif")!
var snd : SystemSoundID = 0
AudioServicesCreateSystemSoundID(sndurl as CFURL, &amp;snd)</pre>










<section data-type="sect3" data-pdf-bookmark="Struct functions" class="calibre2"><div class="preface" id="calibre_link-3020">
<h3 class="calibre44">Struct functions</h3>

<p class="author1">In iOS programming, most commonly used C global functions operate on a struct; they have the name of that struct as the first element of their name, and have that struct itself as their first parameter. In Swift, where structs are objects, these functions are often transformed into methods on the struct.<a data-type="indexterm" data-primary="C" data-secondary="global functions" id="calibre_link-317" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="global functions" data-secondary="C, overshadowed by instance methods" id="calibre_link-978" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="global" data-tertiary="C, overshadowed" id="calibre_link-919" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, in Objective-C, the way to construct a CGRect from scratch is with the <code class="calibre19">CGRectMake</code> function, and the way to divide a CGRect is with the <code class="calibre19">CGRectDivide</code> <span class="publishername">function:</span></p>

<pre data-type="programlisting" class="calibre28">CGRect rect = CGRectMake(10,10,100,100);
CGRect arrow;
CGRect body;
CGRectDivide(rect, &amp;arrow, &amp;body, arrowHeight, CGRectMinYEdge);</pre>

<p class="author1">In Swift, <code class="calibre19">CGRectMake</code> is overshadowed by the CGRect struct initializer <code class="calibre19">init(x:y:width:height:)</code>, and <code class="calibre19">CGRectDivide</code> is overshadowed by the CGRect <code class="calibre19">divided</code> method:</p>

<pre data-type="programlisting" class="calibre28">let rect = CGRect(x: 10, y: 10, width: 100, height: 100)
let (arrow, body) = rect.divided(atDistance: arrowHeight, from: .minYEdge)</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Pointer-to-function" class="calibre2"><div class="preface" id="calibre_link-3021">
<h3 class="calibre44">Pointer-to-function</h3>

<p class="author1">In C, a function has a type based on its signature, and the name of a function is a reference to the function, and so it is possible to pass a function &mdash; sometimes termed a <em class="calibre11">pointer-to-function</em> &mdash; by using the functionâ€™s name where a function of that type is expected.<a data-type="indexterm" data-primary="C" data-secondary="pointer-to-function" id="calibre_link-319" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s the declaration for a C function from the Audio Toolbox framework:</p>

<pre data-type="programlisting" class="calibre28">OSStatus AudioServicesAddSystemSoundCompletion(SystemSoundID inSystemSoundID,
    CFRunLoopRef __nullable inRunLoop,
    CFStringRef __nullable inRunLoopMode,
    AudioServicesSystemSoundCompletionProc inCompletionRoutine,
    void * __nullable inClientData)</pre>

<p class="author1">(Iâ€™ll explain the term <code class="calibre19">__nullable</code> later.) Whatâ€™s an AudioServicesSystemSoundCompletionProc? Hereâ€™s how itâ€™s declared:</p>

<pre data-type="programlisting" class="calibre28">typedef void (*AudioServicesSystemSoundCompletionProc)(
    SystemSoundID ssID,
    void* __nullable clientData);</pre>

<p class="author1">In the first line, the asterisk and name in parentheses means that this is the name of a pointer-to-function. A SystemSoundID is a UInt32. So this declaration means that an AudioServicesSystemSoundCompletionProc is a pointer to a function taking two parameters (typed UInt32 and pointer-to-void) and returning no result.</p>

<p class="author1">Amazingly, you can pass a Swift function where a C pointer-to-function is expected! As always when passing a function, you can define the function separately and pass its name, or you can form the function inline as an anonymous function. If youâ€™re going to define the function separately, it cannot be a method. A function defined at the top level of a file is fine; so is a function defined locally within a function.</p>

<p class="author1">So hereâ€™s my AudioServicesSystemSoundCompletionProc, declared at the top level of a file:</p>

<pre data-type="programlisting" class="calibre28">func soundFinished(_ snd:UInt32, _ c:UnsafeMutableRawPointer?) {
    AudioServicesRemoveSystemSoundCompletion(snd)
    AudioServicesDisposeSystemSoundID(snd)
}</pre>

<p class="author1">And hereâ€™s my code for playing a sound file as a system sound, including a call to <code class="calibre19">AudioServicesAddSystemSoundCompletion</code>:<a data-type="indexterm" data-startref="idxclanguage" id="calibre_link-311" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let sndurl = Bundle.main.url(forResource: "test", withExtension: "aif")!
var snd : SystemSoundID = 0
AudioServicesCreateSystemSoundID(sndurl as CFURL, &amp;snd)
AudioServicesAddSystemSoundCompletion(snd, nil, nil, soundFinished, nil)
AudioServicesPlaySystemSound(snd)</pre>
</div>
</section>



</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Objective-C" class="calibre2"><div class="preface" id="calibre_link-2723">
<h1 class="calibre18">Objective-C</h1>

<p class="author1">Objective-C is built on top of C. It adds some syntax and features, but it continues at the same time to use C syntax and data types, and remains C under the hood.</p>

<p class="author1">Unlike Swift, Objective-C has no namespaces. For this reason, different frameworks distinguish their contents by starting the names of types, functions, and constants with distinct prefixes. The â€œCGâ€ in â€œCGFloatâ€ stands for Core Graphics, because it is declared in the Core Graphics framework. The â€œNSâ€ in â€œNSStringâ€ stands for NeXTStep, a historical name for the framework that later became Cocoa. And so on.<a data-type="indexterm" data-primary="namespaces" data-secondary="Objective-C" id="calibre_link-1381" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="namespaces" id="calibre_link-1535" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>








<section data-type="sect2" data-pdf-bookmark="Objective-C Objects and C Pointers" class="calibre2"><div class="preface" id="calibre_link-2724">
<h2 class="calibre42">Objective-C Objects and C Pointers</h2>

<p class="author1">All the data types and syntax of C are part of Objective-C. But Objective-C is object-oriented, so it needs a way of adding objects to C. It does this by taking advantage of C pointers. C pointers accommodate having anything at all at the far end of the pointer; management of whatever is pointed to is a separate matter, and thatâ€™s just what Objective-C takes care of. Thus, Objective-C object types are expressed using C pointer syntax.<a data-type="indexterm" data-primary="references" data-secondary="to object types" data-tertiary="Objective-C" id="calibre_link-1872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="object types" data-secondary="references to" data-tertiary="Objective-C" id="calibre_link-1506" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="object references" id="calibre_link-1536" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">For example, hereâ€™s the Objective-C declaration for the <code class="calibre19">addSubview:</code> method:</p>

<pre data-type="programlisting" class="calibre28">- (void)addSubview:(UIView *)view;</pre>

<p class="author1">I havenâ€™t discussed Objective-C method declaration syntax yet, but focus on the type declaration for the <code class="calibre19">view</code> parameter, in parentheses: it is <code class="calibre19">UIView*</code>. This appears to mean â€œa pointer to a UIView.â€ It does mean that &mdash; and it doesnâ€™t. Whatâ€™s at the far end of the pointer is certainly a UIView instance. But <em class="calibre11">all</em> Objective-C object references are pointers. Thus, the fact that this is a pointer is merely a consequence of the fact that itâ€™s an object.</p>

<p class="author1">The Swift translation of this method declaration doesnâ€™t appear to involve any <span class="publishername">pointers:</span></p>

<pre data-type="programlisting" class="calibre28">func addSubview(_ view: UIView)</pre>

<p class="author1">In general, in Swift, you will simply pass a reference to a class instance where Objective-C expects a class instance; the asterisk used in Objective-C to express the fact that this is an object wonâ€™t matter. What you pass as argument when calling <code class="calibre19">addSubview(_:)</code> from Swift is a UIView instance &mdash; which is exactly what Objective-C expects. There is, of course, a sense in which you <em class="calibre11">are</em> passing a pointer when you pass a class instance &mdash; because classes are reference types! Thus, a class instance is actually seen the same way by both Swift and Objective-C; the difference is that Swift doesnâ€™t use pointer <em class="calibre11">notation</em>.<a data-type="indexterm" data-primary="pointers" id="calibre_link-1703" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Objective-Câ€™s <code class="calibre19">id</code> type is a general pointer to an object &mdash; the object equivalent of C pointer-to-void. Any object type can be assigned or cast to or from an <code class="calibre19">id</code>. Because <code class="calibre19">id</code> is itself a pointer, a reference declared as <code class="calibre19">id</code> doesnâ€™t use an asterisk; it is rare (though not impossible) to encounter an <code class="calibre19">id*</code>.<a data-type="indexterm" data-primary="Objective-C" data-secondary="id" id="calibre_link-1524" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="id" id="calibre_link-1032" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Objective-C Objects and Swift Objects" class="calibre2"><div class="preface" id="calibre_link-2725">
<h2 class="calibre42">Objective-C Objects and Swift Objects</h2>

<p class="author1">Objective-C objects are classes and instances of classes. They arrive into Swift more or less intact. You wonâ€™t have any trouble subclassing Objective-C classes or working with instances of Objective-C classes. (For how Swift sees Objective-C properties and accessors, see <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>.)<a data-type="indexterm" data-primary="object types" data-secondary="Objective-C" id="calibre_link-1499" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="object types" id="calibre_link-1537" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Going the other way, when Objective-C expects an object, it expects a class or an instance of a class, and Swift can provide it. But what Objective-C means by a class, in general, is a subclass of NSObject.
Every other kind of object has to be bridged or boxed in order to survive the journey into Objective-Câ€™s world.
Moreover, many features of Swift are meaningless to Objective-C, and those features are invisible to Objective-C. Objective-C canâ€™t see any of the following:<a data-type="indexterm" data-primary="Objective-C" data-secondary="Swift features invisible to" id="calibre_link-1545" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Swift enums, except for an <code class="calibre19">@objc</code> enum with an Int raw value</p>
</li>
<li class="calibre12">
<p class="calibre17">Swift structs, except for structs that come ultimately from C or that are bridged to Objective-C classes</p>
</li>
<li class="calibre12">
<p class="calibre17">Swift classes not derived from NSObject</p>
</li>
<li class="calibre12">
<p class="calibre17">Swift protocols not marked <code class="calibre19">@objc</code></p>
</li>
<li class="calibre12">
<p class="calibre17">Protocol extensions</p>
</li>
<li class="calibre12">
<p class="calibre17">Generics</p>
</li>
<li class="calibre12">
<p class="calibre17">Tuples</p>
</li>
<li class="calibre12">
<p class="calibre17">Nested types</p>
</li>
</ul>

<p class="author1">Nothing in that list can be directly exposed to Objective-C &mdash; and, by implication, nothing that <em class="calibre11">involves</em> anything in that list can be exposed to Objective-C. For example, suppose we have a class MyClass not derived from NSObject. Then if your UIViewController subclass has a property typed as MyClass, that property cannot be exposed to Objective-C; and if your UIViewController subclass has a method that receives or returns a value typed as MyClass, that method cannot be exposed to Objective-C.</p>

<p class="author1">Nevertheless, you are perfectly free to use such properties and methods, even in a class (such as a UIViewController subclass) that <em class="calibre11">is</em> exposed to Objective-C. Objective-C simply wonâ€™t be able to see those aspects of the class that would be meaningless to it.</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Exposure of Swift to Objective-C" class="calibre2"><div class="preface" id="calibre_link-2726">
<h2 class="calibre42">Exposure of Swift to Objective-C</h2>

<p class="author1">Starting in Swift 4, invisibility of Swift code to Objective-C <em class="calibre11">is the norm</em>. With a few exceptions, even if Objective-C <em class="calibre11">can</em> theoretically see a thing, it <em class="calibre11">wonâ€™t</em> see it unless you explicitly expose it to Objective-C. You do that with the <code class="calibre19">@objc</code> attribute.<a data-type="indexterm" data-primary="objc" id="calibre_link-1485" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="Swift class member exposure to" id="calibre_link-1544" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">Letâ€™s talk first about the exceptions. These are things in your Swift code that Objective-C will be able to see automatically, <em class="calibre11">without</em> an explicit <code class="calibre19">@objc</code> attribute:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A class derived from NSObject. Such a class will be declared in Swift either as subclassing NSObject itself or as subclassing some NSObject subclass, typically a class defined by Cocoa (such as UIViewController).</p>
</li>
<li class="calibre12">
<p class="calibre17">Within such a class, an override of a method defined in Objective-C (such as UIViewControllerâ€™s <code class="calibre19">viewDidLoad</code>) or defined in Swift but marked <code class="calibre19">@objc</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Within such a class, an implementation of a member of a protocol adopted by the class, if the protocol is defined in Objective-C (such as NSCodingâ€™s <code class="calibre19">init(coder:)</code>) or defined in Swift but marked <code class="calibre19">@objc</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Within such a class, an instance property marked <code class="calibre19">@IBOutlet</code> or <code class="calibre19">@IBInspectable</code> or <code class="calibre19">@NSManaged</code>, or a method marked <code class="calibre19">@IBAction</code> (see <a data-type="xref" href="#calibre_link-16" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;7</a>).</p>
</li>
</ul>

<p class="author1">Otherwise, to expose to Objective-C a property, method, or protocol, mark it with <code class="calibre19">@objc</code>. The compiler will stop you if you try to expose to Objective-C something that it is unable to see (such as a property whose type Objective-C cannot see or cannot understand). A protocol marked as <code class="calibre19">@objc</code> automatically becomes a class protocol.</p>

<p class="author1">A useful trick, if you have several methods that you need to expose explicitly to Objective-C, is to clump them into an extension which is itself marked <code class="calibre19">@objc</code>; there is then no need to mark those methods with <code class="calibre19">@objc</code> individually. If most or all of a classâ€™s members are to be exposed to Objective-C, you can mark the class <code class="calibre19">@objcMembers</code>; again, there is then no need to mark those members with <code class="calibre19">@objc</code> individually. Conversely, if a class member would be exposed to Objective-C and you want to prevent this, you can mark it <code class="calibre19">@nonobjc</code>.<a data-type="indexterm" data-primary="nonobjc" id="calibre_link-1415" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="objcMembers" id="calibre_link-1486" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">There are two additional uses of <code class="calibre19">@objc</code>:</p>
<dl class="calibre14">
<dt class="calibre15">Expose a member of a nonObjective-C class</dt>
<dd class="calibre16">
<p class="calibre17">Even if a class is not exposed to Objective-C, it can be useful to mark a member of that class with <code class="calibre19">@objc</code> so that your Swift code can take advantage of Objective-C language features with regard to that member. For example, a Timer using the target&ndash;action pattern (<a data-type="xref" href="#calibre_link-15" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;11</a>) can have a method of a nonObjective-C class as its <code class="calibre19">action</code>, but only if that method is marked <code class="calibre19">@objc</code>, because the method is specified with a selector (<a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>) and selectors are an Objective-C feature.</p>
</dd>
<dt class="calibre15">Change the Objective-C name of something</dt>
<dd class="calibre16">
<p class="calibre17">When you mark something with <code class="calibre19">@objc</code>, you can add parentheses containing the name by which you want Objective-C to see this thing. You are free to do this even for a class or a class member that Objective-C can see already. An example appeared in <a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a> when I changed the name by which Objective-C sees a property accessor. When using this feature, you bypass Swiftâ€™s behind-the-scenes <em class="calibre11">name mangling</em> designed to prevent clashes with any existing Objective-C names, so you must take responsibility for avoiding such a clash yourself.<a data-type="indexterm" data-primary="name mangling" id="calibre_link-1371" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="mangling, name" id="calibre_link-1263" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>
<div data-type="tip" class="calibre23"><h6 class="calibre24">Tip</h6>
<p class="author1">Class members marked <code class="calibre19">@objc</code>, <code class="calibre19">@IBAction</code>, and <code class="calibre19">@IBOutlet</code> can be marked <code class="calibre19">private</code> to speed up compilation and reduce the footprint of the classâ€™s exposure to Objective-C. However, as I mentioned in <a data-type="xref" href="#calibre_link-20" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;5</a>, you shouldnâ€™t do that with an implementation of an optional member of an adopted Objective-C protocol.</p>
</div>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Bridged Types and Boxed Types" class="calibre2"><div class="preface" id="calibre_link-2727">
<h2 class="calibre42">Bridged Types and Boxed Types</h2>

<p class="author1">Swift will convert certain native nonclass types to their Objective-C class equivalents for you. The following native Swift structs are bridged to Objective-C class types:<a data-type="indexterm" data-primary="bridged types" id="calibre_link-277" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="structs" data-secondary="bridged to Objective-C classes" id="calibre_link-2122" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">String to NSString</p>
</li>
<li class="calibre12">
<p class="calibre17">Numbers (and Bool) to NSNumber</p>
</li>
<li class="calibre12">
<p class="calibre17">Array to NSArray</p>
</li>
<li class="calibre12">
<p class="calibre17">Dictionary to NSDictionary</p>
</li>
<li class="calibre12">
<p class="calibre17">Set to NSSet</p>
</li>
</ul>

<p class="author1">Bridging has two immediate practical consequences for your code:</p>
<dl class="calibre14">
<dt class="calibre15">Parameter passing</dt>
<dd class="calibre16">
<p class="calibre17">You can pass an instance of the Swift struct where the Objective-C class is expected. In fact, in general youâ€™ll rarely even encounter the Objective-C class, because the Swift rendering of the API will display it as the Swift struct: if an Objective-C method takes an NSString, youâ€™ll see it in Swift as taking a String, and so on.</p>
</dd>
<dt class="calibre15">Casting</dt>
<dd class="calibre16">
<p class="calibre17">You can cast between the Swift struct and the Objective-C class. When casting from Swift to Objective-C, this is not a downcast, so the bare <code class="calibre19">as</code> operator is all you need. But casting from Objective-C to Swift, except for NSString to String, involves adding type information &mdash; NSNumber wraps some specific numeric type, and the collection types contain elements of some specific type &mdash; so you might need to cast down with <code class="calibre19">as!</code> or <code class="calibre19">as?</code> in order to specify that type.</p>
</dd>
</dl>

<p class="author1">Also, certain common Objective-C structs that can easily be wrapped by NSValue in Objective-C are bridged to NSValue in Swift. The common structs are CGPoint, CGSize, CGRect, CGAffineTransform, UIEdgeInsets, UIOffset, NSRange, CATransform3D, CMTime, CMTimeMapping, CMTimeRange, MKCoordinate, and MKCoordinateSpan.<a data-type="indexterm" data-primary="bridged types" data-secondary="struct and NSValue" id="calibre_link-299" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In addition, various Cocoa Foundation classes are overlaid by Swift types whose names are the same but without the â€œNSâ€ prefix. Often, extra functionality is injected to make the type behave in a more Swift-like way; and, where appropriate, the Swift type may be a struct, allowing you to take advantage of Swift value type semantics. For example, NSMutableData becomes largely otiose, because Data, the overlay for Objective-C NSData, is a struct with mutating methods and can thus be declared with <code class="calibre19">let</code> or <code class="calibre19">var</code>. And Date, the overlay for Objective-C NSDate, adopts Equatable and Comparable, so that an NSDate method like <code class="calibre19">earlierDate:</code> can be replaced by the <code class="calibre19">&gt;</code> operator.<a data-type="indexterm" data-primary="bridged types" data-secondary="Foundation" id="calibre_link-293" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Swift overlay (Foundation)" id="calibre_link-2173" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="overlay, Swift" id="calibre_link-1647" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The Swift overlay types are all bridged to their Foundation counterparts. The Swift rendering of an Objective-C API will show you the Swift overlay type rather than the Objective-C type: a Cocoa method that takes or returns an NSDate in Objective-C will take or return a Date in Swift, and so on. If necessary, you can cast between bridged types; for example, you can turn a Date into an NSDate with <code class="calibre19">as</code>.</p>

<p class="author1">The Swift Any type can accept any type of instance, directly. Objective-C <code class="calibre19">id</code> is rendered as Any in Swift. This means that wherever an Objective-C API accepts an <code class="calibre19">id</code> parameter, that parameter is typed in Swift as Any and can be passed any Swift value whatever. If that value is of a bridged type, <em class="calibre11">the bridge is crossed automatically</em>, just as if you had cast explicitly with <code class="calibre19">as</code>. A String becomes an NSString, an Array becomes an NSArray, a number is wrapped in an NSNumber, a CGPoint or other common struct is wrapped in an NSValue, a Data becomes an NSData, and so forth.<a data-type="indexterm" data-primary="bridged types" data-secondary="Any and id" id="calibre_link-280" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The same rule applies when you pass a Swift collection to Objective-C, with regard to the collectionâ€™s elements. If an element is of a bridged type, <em class="calibre11">the bridge is crossed automatically</em>. The typical case in point is when you pass a Swift array to Objective-C: an array of Int becomes an NSArray of NSNumbers; an array of CGPoint becomes an NSArray of NSValues; for an array with an Optional element type, any <code class="calibre19">nil</code> elements become NSNull instances (<a data-type="xref" href="#calibre_link-48" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;10</a>).<a data-type="indexterm" data-primary="bridged types" data-secondary="array elements" id="calibre_link-287" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bridged types" data-secondary="Array and NSArray" id="calibre_link-284" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="arrays" data-secondary="bridging" id="calibre_link-183" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">What happens when an object tries to cross the bridge from Swift to Objective-C, but that instance is <em class="calibre11">not</em> of a bridged type? (Such an object might be an enum, a struct of a nonbridged type, or a class that doesnâ€™t derive from NSObject.) On the one hand, Objective-C canâ€™t do anything with this object. On the other hand, the object needs to be allowed to cross the bridge somehow, especially because you, on the Swift side, might ask for the object back again later, and it needs to be returned to you intact.</p>

<p class="author1">To illustrate, suppose Person is a struct with a <code class="calibre19">firstName</code> and a <code class="calibre19">lastName</code> property. Then you might need to be able to do something like this:<a data-type="indexterm" data-primary="boxing" id="calibre_link-269" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a> <a data-type="indexterm" data-primary="bridged types" data-seealso="boxing" id="calibre_link-278" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// lay is a CALayer
let p = Person(firstName: "Matt", lastName: "Neuburg")
lay.setValue(p, forKey: "person")
// ... time passes ...
if let p2 = lay.value(forKey: "person") as? Person {
    print(p2.firstName, p2.lastName) // Matt Neuburg
}</pre>

<p class="author1">Amazingly, this works. How? The answer, in a nutshell, is that Swift <em class="calibre11">boxes</em> this object into something that Objective-C can see <em class="calibre11">as</em> an object, even though Objective-C canâ€™t <em class="calibre11">do</em> anything with that object other than store and retrieve it. How Swift does this is irrelevant; itâ€™s an implementation detail, and none of your business. It happens that in this case the Person object is wrapped up in a <code class="calibre19">_SwiftValue</code>, but that name is unimportant; whatâ€™s important is that it is an Objective-C object, wrapping the value we provided. In this way, Objective-C is able to store the object for us, in its box, and hand it back to us intact upon request. Like Pandora, Objective-C will cope perfectly well as long as it doesnâ€™t look in the box!</p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Objective-C Methods" class="calibre2"><div class="preface" id="calibre_link-2728">
<h2 class="calibre42">Objective-C Methods</h2>

<p class="author1">In Objective-C, method parameters can (and nearly always do) have external names, and the name of a method as a whole is not distinct from the external names of the parameters: the parameter names are <em class="calibre11">part</em> of the method name, with a colon appearing where each parameter would need to go. Hereâ€™s a typical Objective-C method declaration from Cocoaâ€™s NSString class:<a data-type="indexterm" data-primary="Objective-C" data-secondary="methods" id="calibre_link-1530" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="Objective-C" id="calibre_link-1342" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="methods" data-secondary="external parameter names" id="calibre_link-1334" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="external parameter names" data-secondary="methods" id="calibre_link-839" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="parameters" data-secondary="external names" data-tertiary="methods" id="calibre_link-1668" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target
                                        withString:(NSString *)replacement</pre>

<p class="author1">The Objective-C name of that method is <code class="calibre19">stringByReplacingOccurrencesOfString:withString:</code>. The name contains two colons, so the method takes two parameters, which the declaration tells us are NSString parameters.</p>

<p class="author1">A declaration for an Objective-C method, such as the one in that example, has three parts:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Either <code class="calibre19">+</code> or <code class="calibre19">-</code>, meaning that the method is a class method or an instance method, respectively.</p>
</li>
<li class="calibre12">
<p class="calibre17">The data type of the return value, in parentheses. It might be <code class="calibre19">void</code>, meaning no returned value.</p>
</li>
<li class="calibre12">
<p class="calibre17">The name of the method, split after each colon so as to make room for the parameters. Following each colon is the data type of the parameter, in parentheses, followed by a placeholder (internal) name for the parameter.</p>
</li>
</ul>










<section data-type="sect3" data-pdf-bookmark="Renamification" class="calibre2"><div class="preface" id="calibre_link-3022">
<h3 class="calibre44">Renamification</h3>

<p class="author1">When Swift calls an Objective-C method, thereâ€™s an obvious mismatch between the rules and conventions of the two languages:<a data-type="indexterm" data-primary="renamification" id="calibre_link-1895" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="methods" data-tertiary="renamification" id="calibre_link-1533" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">A Swift method is a function; the name of the function is followed by parentheses, and if the functionâ€™s parameters have external names (labels), they appear inside the parentheses, like this: <code class="calibre19">swiftFunction(parameter:)</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">An Objective-C method name involves <em class="calibre11">no</em> parentheses; if it takes parameters, the stuff before the first colon is effectively the external name of the first parameter, like this: <code class="calibre19">objectiveCMethodWithParameter:</code>.</p>
</li>
</ul>

<p class="author1">To cope with this mismatch, Swift renders the Objective-C methodâ€™s name more Swift-like by a process called <em class="calibre11">renamification</em>, which is performed by a component called the <em class="calibre11">Clang importer</em>, mediating between the two languages. The renamification rules are rather elaborate, but you donâ€™t need to know the details; you can get a general sense of how they behave from the way they transform the <code class="calibre19">stringByReplacingOccurrencesOfString:withString:</code> method into a Swift function:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">Swift prunes redundant initial type names. Weâ€™re starting with a string, and itâ€™s obvious from the return type that a string is returned, so thereâ€™s no point saying <code class="calibre19">string</code> at the start. We are thus left with <code class="calibre19">byReplacingOccurrencesOfString:withString:</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Swift prunes initial <code class="calibre19">by</code>. Thatâ€™s a common Cocoa locution, but Swift finds it merely verbose. Now weâ€™re down to <code class="calibre19">replacingOccurrencesOfString:withString:</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Swift prunes redundant final type names. Itâ€™s obvious that the parameters are strings, so thereâ€™s no point saying <code class="calibre19">string</code> at the end of the parameter names. That leaves <code class="calibre19">replacingOccurrencesOf:with:</code>.</p>
</li>
<li class="calibre12">
<p class="calibre17">Finally, Swift decides where to split the first parameter name into the Swift method name (before the parentheses) and the external first parameter name (inside the parentheses). Here, Swift sees that the first parameter name now ends with a known preposition, <code class="calibre19">of</code>, so it splits before that preposition.</p>
</li>
</ul>

<p class="author1">Hereâ€™s the resulting renamification of that method:</p>

<pre data-type="programlisting" class="calibre28">func replacingOccurrences(of target:String, with replacement:String)</pre>

<p class="author1">And hereâ€™s an actual example of calling it:</p>

<pre data-type="programlisting" class="calibre28">let s = "hello"
let s2 = s.replacingOccurrences(of: "ell", with:"ipp")
// s2 is now "hippo"</pre>

<p class="author1">If the Objective-C method being renamified belongs to you, you can intervene manually and <em class="calibre11">tell</em> Swift how to renamify this method, by appending <code class="calibre19">NS_SWIFT_NAME(...)</code> to the declaration (before the semicolon), where whatâ€™s inside the parentheses is a Swift function reference. Hereâ€™s an example:</p>

<pre data-type="programlisting" class="calibre28">- (void) triumphOverThing: (Thing*) otherThing NS_SWIFT_NAME(triumph(over:));</pre>

<p class="author1">The Clang importer would normally renamify that in Swift as:</p>

<pre data-type="programlisting" class="calibre28">func triumphOverThing(_ otherThing: Thing)</pre>

<p class="author1">Presumably thatâ€™s because the importer doesnâ€™t understand <code class="calibre19">over</code> as a preposition. But by intervening manually, weâ€™ve told it to use this instead:</p>

<pre data-type="programlisting" class="calibre28">func triumph(over otherThing: Thing)</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Internal parameter names" class="calibre2"><div class="preface" id="calibre_link-3023">
<h3 class="calibre44">Internal parameter names</h3>

<p class="author1">When you <em class="calibre11">call</em> an Objective-C method from Swift, Objective-Câ€™s internal names for the parameters donâ€™t matter; you donâ€™t use them, and you donâ€™t need to know or care what they are.</p>

<p class="author1">When you <em class="calibre11">override</em> an Objective-C method in Swift, code completion will suggest internal names corresponding to the Objective-C internal names, but you are free to change them. Hereâ€™s the Objective-C declaration of the UIViewController <code class="calibre19">prepareForSegue:sender:</code> instance method:<a data-type="indexterm" data-primary="Objective-C" data-secondary="methods" data-tertiary="internal parameter names" id="calibre_link-1531" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(nullable id)sender;</pre>

<p class="author1">When you override that method in your UIViewController subclass, the suggested template, in accordance with the renamification rules, looks like this:</p>

<pre data-type="programlisting" class="calibre28">override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    // ...
}</pre>

<p class="author1">But the internal names are local variable names for your use inside the function body, and Objective-C doesnâ€™t care about them; so you can change them. This is a valid (but weird) override of <code class="calibre19">prepareForSegue:sender:</code> in Swift:</p>

<pre data-type="programlisting" class="calibre28">override func prepare(for war: UIStoryboardSegue, sender bow: Any?) {
    // ...
}</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Reverse renamification" class="calibre2"><div class="preface" id="calibre_link-3024">
<h3 class="calibre44">Reverse renamification</h3>

<p class="author1">Now letâ€™s talk about what happens going the other way: How does Objective-C see methods declared in Swift? The simplest case is when the first parameter has no external name. Hereâ€™s a Swift method intended as the action method of a button in the interface:</p>

<pre data-type="programlisting" class="calibre28">@IBAction func doButton(_ sender: Any?) {
    // ...
}</pre>

<p class="author1">That method is seen by Objective-C as <code class="calibre19">doButton:</code>. That is the canonical form for an action method with one parameter, and for that reason I like to declare my action methods along those lines.</p>

<p class="author1">If a Swift methodâ€™s first parameter does have an external name, then, as seen by Objective-C, that external name is appended to what precedes the parentheses following an inserted preposition <code class="calibre19">with</code>. Hereâ€™s a Swift method:</p>

<pre data-type="programlisting" class="calibre28">func makeHash(ingredients stuff:[String]) {
    // ...
}</pre>

<p class="author1">That method is seen by Objective-C as <code class="calibre19">makeHashWithIngredients:</code>.</p>

<p class="author1">But if the external name of the first parameter is a preposition, then it is appended directly to what precedes the parentheses. Hereâ€™s another Swift method:</p>

<pre data-type="programlisting" class="calibre28">func makeHash(of stuff:[String]) {
    // ...
}</pre>

<p class="author1">That method is seen by Objective-C as <code class="calibre19">makeHashOf:</code>.</p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Overloading" class="calibre2"><div class="preface" id="calibre_link-3025">
<h3 class="calibre44">Overloading</h3>

<p class="author1">Unlike Swift, Objective-C does not permit overloading of methods. Two ViewController instance methods called <code class="calibre19">myMethod:</code> returning no result, one taking a CGFloat parameter and one taking an NSString parameter, would be illegal in Objective-C. Therefore, two such Swift methods, though legal as far as Swift is concerned, would be illegal if they were both visible to Objective-C.</p>

<p class="author1">So if methods are overloads of one another in Swift, donâ€™t expose <em class="calibre11">more than one</em> of those methods to Objective-C.<a data-type="indexterm" data-primary="overloading" data-secondary="Objective-C" id="calibre_link-1649" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="methods" data-tertiary="overloading" id="calibre_link-1532" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Variadics" class="calibre2"><div class="preface" id="calibre_link-3026">
<h3 class="calibre44">Variadics</h3>

<p class="author1">Objective-C has its own version of a variadic parameter. The NSArray instance method <code class="calibre19">arrayWithObjects:</code> is declared like this:<a data-type="indexterm" data-primary="variadic parameters" data-secondary="Objective-C" id="calibre_link-2344" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="methods" data-tertiary="variadic parameters" id="calibre_link-1534" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">+ (id)arrayWithObjects:(id)firstObj, ... ;</pre>

<p class="author1">Unlike Swift, such methods in Objective-C must somehow be told explicitly how many arguments are being supplied. Many such methods, including <code class="calibre19">arrayWithObjects:</code>, use a <code class="calibre19">nil</code> terminator; that is, the caller supplies <code class="calibre19">nil</code> after the last argument, and the callee knows when it has reached the last argument because it encounters <code class="calibre19">nil</code>. A call to <code class="calibre19">arrayWithObjects:</code> in Objective-C would look something like this:</p>

<pre data-type="programlisting" class="calibre28">NSArray* pep = [NSArray arrayWithObjects: manny, moe, jack, nil];</pre>

<p class="author1">Objective-C cannot call (or see) a Swift method that takes a variadic parameter. Swift, however, <em class="calibre11">can</em> call an Objective-C method that takes a variadic parameter, provided it is marked <code class="calibre19">NS_REQUIRES_NIL_TERMINATION</code>. And in fact, <code class="calibre19">arrayWithObjects:</code> <em class="calibre11">is</em> marked in this way, so you can say <code class="calibre19">NSArray(objects:1, 2, 3)</code> and Swift will supply the missing <code class="calibre19">nil</code> terminator.</p>
</div>
</section>



</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Objective-C Initializers and Factories" class="calibre2"><div class="preface" id="calibre_link-2729">
<h2 class="calibre42">Objective-C Initializers and Factories</h2>

<p class="author1">Objective-C initializer methods are instance methods; actual instantiation is performed using the NSObject class method <code class="calibre19">alloc</code>, for which Swift has no equivalent (and doesnâ€™t need one), and the initializer message is sent to the instance that results. Hereâ€™s how you create a UIColor instance by supplying red, green, blue, and alpha values in Objective-C:<a data-type="indexterm" data-primary="initializers" data-secondary="Objective-C" id="calibre_link-1096" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="initializers" id="calibre_link-1526" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">UIColor* col = [[UIColor alloc] initWithRed:0.5 green:0.6 blue:0.7 alpha:1];</pre>

<p class="author1">The name of that initializer, in Objective-C, is <code class="calibre19">initWithRed:green:blue:alpha:</code>. Itâ€™s declared like this:</p>

<pre data-type="programlisting" class="calibre28">- (UIColor *)initWithRed:(CGFloat)red green:(CGFloat)green
    blue:(CGFloat)blue alpha:(CGFloat)alpha;</pre>

<p class="author1">In short, an initializer method, to all outward appearances, is just an instance method like any other in Objective-C.</p>

<p class="author1">Swift, nevertheless, is able to detect that an Objective-C initializer <em class="calibre11">is</em> an initializer, because the name is special &mdash; it starts with <code class="calibre19">init</code>! Therefore, Swift is able to translate an Objective-C initializer into a Swift initializer. The word <code class="calibre19">init</code> is stripped from the start of the method name, and the preposition <code class="calibre19">with</code>, if it appears, is stripped as well. Whatâ€™s left is the external name of the first parameter. Thus, Swift translates the Objective-C initializer <code class="calibre19">initWithRed:green:blue:alpha:</code> into the Swift initializer <code class="calibre19">init(red:green:blue:alpha:)</code>, which is declared like this:</p>

<pre data-type="programlisting" class="calibre28">init(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)</pre>

<p class="author1">And youâ€™d call it like this:</p>

<pre data-type="programlisting" class="calibre28">let col = UIColor(red: 0.5, green: 0.6, blue: 0.7, alpha: 1.0)</pre>

<p class="author1">The same principle operates in reverse: a Swift initializer <code class="calibre19">init(value:)</code> is visible to and callable by Objective-C under the name <code class="calibre19">initWithValue:</code>.</p>

<p class="author1">There is a second way to create an instance in Objective-C. Very commonly, a class will supply a <em class="calibre11">class</em> method that is a <em class="calibre11">factory</em> for instances. For example, the UIColor class has a class factory method <code class="calibre19">colorWithRed:green:blue:alpha:</code>, declared as <span class="publishername">follows:</span></p>

<pre data-type="programlisting" class="calibre28">+ (UIColor*) colorWithRed: (CGFloat) red green: (CGFloat) green
                     blue: (CGFloat) blue alpha: (CGFloat) alpha;</pre>

<p class="author1">Swift detects a factory method of this kind by some pattern-matching rules &mdash; a class method that returns an instance of the class, and whose name begins with the name of the class, stripped of its prefix &mdash; and translates it <em class="calibre11">as an initializer</em>, stripping the class name (and the <code class="calibre19">with</code>) from the start of the first parameter name. If the resulting initializer exists already, as it does in this example, then Swift treats the factory method as superfluous and suppresses it completely! Thus, the Objective-C class method <code class="calibre19">colorWithRed:green:blue:alpha:</code> isnâ€™t callable from Swift, because it would be identical to <code class="calibre19">init(red:green:blue:alpha:)</code> which already exists.<a data-type="indexterm" data-primary="factory" data-secondary="methods, Objective-C" id="calibre_link-843" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="factory methods" id="calibre_link-1520" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Selectors" class="calibre2"><div class="preface" id="calibre_link-2730">
<h2 class="calibre42">Selectors</h2>

<p class="author1">An Objective-C method will sometimes expect as parameter the name of a method to be called later. Such a name is called a <em class="calibre11">selector</em>. For example, the Objective-C <span class="publishername">UIControl</span> <code class="calibre19">addTarget:action:forControlEvents:</code> method can be called as a way of telling a button in the interface, â€œFrom now on, whenever you are tapped, send this message to this object.â€ The object is the <code class="calibre19">target:</code> parameter. The message, the <code class="calibre19">action:</code> parameter, is a selector.<a data-type="indexterm" data-primary="selectors" id="calibre_link-1973" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You may imagine that, if this were a Swift method, youâ€™d be passing a function here. But a selector is not the same as a function. Itâ€™s just a name. Objective-C, unlike Swift, is so dynamic that it is able at runtime to construct and send an arbitrary message to an arbitrary object based on the name alone. Still, a selector is not exactly a string, either; itâ€™s a separate object type, designated in Objective-C declarations as SEL and in Swift declarations as Selector.<a data-type="indexterm" data-primary="Selector" id="calibre_link-1971" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">You can create a Selector by calling the Selector initializer, which takes a string. In the following examples, <code class="calibre19">b</code> is a UIButton:</p>

<pre data-type="programlisting" class="calibre28">b.addTarget(self, action: Selector("doNewGame:"), for: .touchUpInside)</pre>

<p class="author1">As a shorthand, you can even pass a string literal where a Selector is expected, even though a Selector is not a string:</p>

<pre data-type="programlisting" class="calibre28">b.addTarget(self, action: "doNewGame:", for: .touchUpInside)</pre>

<p class="author1">But donâ€™t do either of those things! Forming a literal selector string by hand is an invitation to form the string incorrectly, resulting in a selector that at best will fail to work, and at worst will cause your app to crash. Swift solves this problem by providing <code class="calibre19">#selector</code> syntax (described in <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a>):</p>

<pre data-type="programlisting" class="calibre28">b.addTarget(self, action: #selector(doNewGame), for: .touchUpInside)</pre>

<p class="author1">The use of <code class="calibre19">#selector</code> syntax has numerous advantages. In addition to translating the method name to a selector for you, the compiler can check for the existence of the method in question, and can stop you from telling Objective-C to use a selector to call a method that isnâ€™t exposed to Objective-C (which would cause a crash at runtime).</p>

<p class="author1">Indeed, <code class="calibre19">#selector</code> syntax means that you will probably <em class="calibre11">never</em> need to form a selector from a string! Nevertheless, you can do so if you really want to. The rules for deriving an Objective-C name string from a Swift method name are completely mechanical:<a data-type="indexterm" data-primary="Objective-C" data-secondary="selectors" id="calibre_link-1541" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">The string starts with everything that precedes the left parenthesis in the method name.</p>
</li>
<li class="calibre4">
<p class="calibre17">If the method takes <em class="calibre11">no parameters</em>, stop. Thatâ€™s the end of the string.</p>
</li>
<li class="calibre4">
<p class="calibre17">If the methodâ€™s first parameter has an external parameter name, append <code class="calibre19">With</code> and a capitalized version of that name, unless it is a preposition, in which case append a capitalized version of it directly.</p>
</li>
<li class="calibre4">
<p class="calibre17">Add a colon.</p>
</li>
<li class="calibre4">
<p class="calibre17">If the method takes exactly <em class="calibre11">one parameter</em>, stop. Thatâ€™s the end of the string.</p>
</li>
<li class="calibre4">
<p class="calibre17">If the method takes more than one parameter, add the external names of all remaining parameters, with a colon after each external parameter name.</p>
</li>

</ol>

<p class="author1">Observe that this means that if the method takes any parameters, its Objective-C name string <em class="calibre11">will end with a colon</em>. Capitalization counts, and the name should contain no spaces or other punctuation except for the colons.</p>

<p class="author1">To illustrate, here are some Swift method declarations, with their Objective-C name strings given in a comment:</p>

<pre data-type="programlisting" class="calibre28">func sayHello() -&gt; String         // "sayHello"
func say(_ s:String)              // "say:"
func say(string s:String)         // "sayWithString:"
func say(of s:String)             // "sayOf:"
func say(_ s:String, times n:Int) // "say:times:"</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="CFTypeRefs" class="calibre2"><div class="preface" id="calibre_link-2731">
<h2 class="calibre42">CFTypeRefs</h2>

<p class="author1">A CFTypeRef is a pointer to an opaque struct that acts as a pseudo-object. (I talked about CFTypeRef pseudo-objects and their memory management in <a data-type="xref" href="#calibre_link-49" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;12</a>.) CFTypeRef functions are global C functions. Swift can call C functions, and before Swift 3 introduced renamification, CFTypeRef code looked almost as if Swift were C:<a data-type="indexterm" data-primary="CFTypeRefs" id="calibre_link-351" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">// before Swift 3:
let con = UIGraphicsGetCurrentContext()!
let sp = CGColorSpaceCreateDeviceGray()
// ... colors and locs are arrays of CGFloat ...
let grad = CGGradientCreateWithColorComponents (sp, colors, locs, 3) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2742" href="#calibre_link-2740"><img src="images/000019.png" alt="1" class="calibre39" /></a>
CGContextDrawLinearGradient (
    con, grad, CGPointMake(89,0), CGPointMake(111,0), []) <a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2743" href="#calibre_link-2741"><img src="images/000008.png" alt="2" class="calibre39" /></a></pre>

<p class="author1">Nowadays, as part of renamification, many commonly used CFTypeRef functions (such as those in the Core Graphics framework) are recast as if the CFTypeRef objects were genuine class instances, with the functions themselves as instance methods. The last two lines of the preceding code are a case in point:</p>
<dl class="calibre14">
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2740" href="#calibre_link-2742"><img src="images/000019.png" alt="1" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">In Objective-C, a CFTypeRef is created with some sort of <code class="calibre19">Create</code> function. In Swift, the CFTypeRef is treated as an object type name, and the syntax looks more like an initializer, complete with external parameter names.</p></dd>
<dt class="calibre15"><a class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2" id="calibre_link-2741" href="#calibre_link-2743"><img src="images/000008.png" alt="2" class="calibre39" /></a></dt>
<dd class="calibre40"><p class="calibre41">In Objective-C, a CFTypeRef function operating on a CFTypeRef pseudo-object takes that object as its first parameter (<code class="calibre19">con</code> in this example). In Swift, the pseudo-object is treated as a real object, and the function becomes a method call sent to it, again with external parameter names.</p></dd>
</dl>

<p class="author1">Thus, those lines are recast in Swift like this:</p>

<pre data-type="programlisting" class="calibre28">let con = UIGraphicsGetCurrentContext()!
let sp = CGColorSpaceCreateDeviceGray()
// ... colors and locs are arrays of CGFloat ...
let grad = CGGradient(colorSpace: sp,
    colorComponents: colors, locations: locs, count: 3)
con.drawLinearGradient(grad,
    start: CGPoint(x:89,y:0), end: CGPoint(x:111,y:0), options:[])</pre>

<p class="author1">Many CFTypeRefs are <em class="calibre11">toll-free bridged</em> to corresponding Objective-C object types. CFString and NSString, CFNumber and NSNumber, CFArray and NSArray, CFDictionary and NSDictionary are all toll-free bridged (and there are many others). Such pairs are interchangeable by casting. This is much easier in Swift than in Objective-C. In Objective-C, ARC memory management doesnâ€™t apply to CFTypeRefs; therefore you must perform a <em class="calibre11">bridging cast</em>, to tell Objective-C how to manage this objectâ€™s memory as it crosses between the memory-managed world of Objective-C objects and the unmanaged world of C and CFTypeRefs. But in Swift, CFTypeRefs <em class="calibre11">are</em> memory-managed, and so there is no need for a bridging cast; you can just cast, plain and simple.<a data-type="indexterm" data-primary="bridged types" data-secondary="CFTypeRefs" id="calibre_link-289" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In this code from one of my apps, Iâ€™m using the ImageIO framework. This framework has a C API (which has not been renamified) and uses CFTypeRefs. <code class="calibre19">CGImageSourceCopyPropertiesAtIndex</code> returns a CFDictionary whose keys are CFStrings. The easiest way to obtain a value from a dictionary is by subscripting, but you canâ€™t do that with a CFDictionary, because it isnâ€™t an object &mdash; so I cast it to a Swift dictionary. The key <code class="calibre19">kCGImagePropertyPixelWidth</code> is a CFString, but when I try to use it directly in a subscript, Swift allows me to do so:</p>

<pre data-type="programlisting" class="calibre28">let d = CGImageSourceCopyPropertiesAtIndex(src, 0, nil) as! [AnyHashable:Any]
let width = d[kCGImagePropertyPixelWidth] as! CGFloat</pre>

<p class="author1">Similarly, in this code, I form a dictionary <code class="calibre19">d</code> using CFString keys &mdash; and then I pass it to the <code class="calibre19">CGImageSourceCreateThumbnailAtIndex</code> function where a CFDictionary is expected:</p>

<pre data-type="programlisting" class="calibre28">let d : [AnyHashable:Any] = [
    kCGImageSourceShouldAllowFloat : true,
    kCGImageSourceCreateThumbnailWithTransform : true,
    kCGImageSourceCreateThumbnailFromImageAlways : true,
    kCGImageSourceThumbnailMaxPixelSize : w
]
let imref = CGImageSourceCreateThumbnailAtIndex(src, 0, d as CFDictionary)!</pre>

<p class="author1">A CFTypeRef is a pointer (to a pseudo-object), so it is interchangeable with C pointer-to-void.
This can result in a perplexing situation in Swift. If a C API casts a CFTypeRef as a pointer-to-void, Swift will see it as an UnsafeRawPointer. How can you cast between this and the actual CFTypeRef? You cannot use the memory binding technique that I used earlier to turn an UnsafeRawPointer into an UnsafePointer generic, because the CFTypeRef does not lie at the far end of the pointer; it <em class="calibre11">is</em> the pointer.<a data-type="indexterm" data-primary="pointers" id="calibre_link-1704" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="UnsafeRawPointer" data-secondary="casting to CFTypeRef" id="calibre_link-2297" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">We might simply call the global <code class="calibre19">unsafeBitCast</code> function, but thatâ€™s dangerous (as the name suggests), because it gives the resulting CFTypeRef no memory management. The correct approach is to pass through an Unmanaged generic to apply memory management; its <code class="calibre19">fromOpaque</code> static method takes an UnsafeRawPointer, and its <code class="calibre19">toOpaque</code> instance method yields an UnsafeMutableRawPointer. (I owe this technique to Martin R.; see <a href="http://stackoverflow.com/a/33310021/1187415" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"><em class="calibre11">http://stackoverflow.com/a/33310021/1187415</em></a>.)</p>

<p class="author1">To illustrate, Iâ€™ll repeat the preceding example where I called <code class="calibre19">CGImageSourceCopyPropertiesAtIndex</code>, but this time I wonâ€™t cast to a Swift dictionary; Iâ€™ll work with the result as a CFDictionary to extract the value of its <code class="calibre19">kCGImagePropertyPixelWidth</code> key. To do so, Iâ€™ll call <code class="calibre19">CFDictionaryGetValue</code>, which takes an UnsafeRawPointer parameter and returns an UnsafeRawPointer result. To form the parameter, Iâ€™ll cast a CFString to an UnsafeMutableRawPointer; to work with the result, Iâ€™ll cast an <span class="publishername">UnsafeRawPointer</span> to a CFNumber. No one in his right mind would ever write this code, but it does work:</p>

<pre data-type="programlisting" class="calibre28">let result = CGImageSourceCopyPropertiesAtIndex(src, 0, nil)!
let key = kCGImagePropertyPixelWidth // CFString
let p1 = Unmanaged.passUnretained(key).toOpaque() // UnsafeMutableRawPointer
let p2 = CFDictionaryGetValue(result, p1) // UnsafeRawPointer
let n = Unmanaged&lt;CFNumber&gt;.fromOpaque(p2!).takeUnretainedValue() // CFNumber
var width : CGFloat = 0
CFNumberGetValue(n, .cgFloatType, &amp;width) // width is now 640.0</pre>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="Blocks" class="calibre2"><div class="preface" id="calibre_link-2732">
<h2 class="calibre42">Blocks</h2>

<p class="author1">A <em class="calibre11">block</em> is a C language feature introduced by Apple starting in iOS 4. It is very like a C function, but it behaves as a closure and can be passed around as a reference type. A block, in fact, is parallel to a Swift function, and the two are interchangeable: you can pass a Swift function where a block is expected, and when a block is handed to you by Cocoa it appears as a function.<a data-type="indexterm" data-primary="C" data-secondary="blocks" id="calibre_link-313" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="blocks" data-secondary="C" id="calibre_link-262" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="functions" data-secondary="C blocks" id="calibre_link-905" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">In C and Objective-C, a block declaration is signified by the caret character (<code class="calibre19">^</code>), which appears where an asterisk would appear in a C pointer-to-function declaration. The NSArray instance method <code class="calibre19">sortedArrayUsingComparator:</code> takes an NSComparator parameter, which is defined through a <code class="calibre19">typedef</code> like this:</p>

<pre data-type="programlisting" class="calibre28">typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);</pre>

<p class="author1">That says: â€œAn NSComparator is a block taking two <code class="calibre19">id</code> parameters and returning an NSComparisonResult.â€ In Swift, therefore, that <code class="calibre19">typedef</code> is translated as the function signature <code class="calibre19">(Any,&nbsp;Any)&nbsp;-&gt;&nbsp;ComparisonResult</code>. It is then trivial to supply a function of the required type as argument when you call <code class="calibre19">sortedArray(comparator:)</code> in Swift:</p>

<pre data-type="programlisting" class="calibre28">let arr = ["Mannyz", "Moey", "Jackx"]
let arr2 = (arr as NSArray).sortedArray { s1, s2 in
    let c1 = String((s1 as! String).last!)
    let c2 = String((s2 as! String).last!)
    return c1.compare(c2)
} // [Jackx, Moey, Mannyz]</pre>

<p class="author1">In many cases, there wonâ€™t be a <code class="calibre19">typedef</code>, and the type of the block will appear directly in a method declaration. Hereâ€™s the Objective-C declaration for a UIView class method that takes two block parameters:</p>

<pre data-type="programlisting" class="calibre28">+ (void)animateWithDuration:(NSTimeInterval)duration
    animations:(void (^)(void))animations
    completion:(void (^ __nullable)(BOOL finished))completion;</pre>

<p class="author1">In that declaration, <code class="calibre19">animations:</code> is a block taking no parameters (<code class="calibre19">void</code>) and returning no value, and <code class="calibre19">completion:</code> is a block taking one BOOL parameter and returning no value. Hereâ€™s the Swift translation:</p>

<pre data-type="programlisting" class="calibre28">class func animate(withDuration duration: TimeInterval,
    animations: @escaping () -&gt; Void,
    completion: ((Bool) -&gt; Void)? = nil)</pre>

<p class="author1">Thatâ€™s a method that you would <em class="calibre11">call</em>, passing a function as argument where a block parameter is expected (and see <a data-type="xref" href="#calibre_link-56" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Chapter&nbsp;2</a> for an example of actually doing so). Hereâ€™s a method that you would <em class="calibre11">implement</em>, where a function is passed <em class="calibre11">to you</em>. This is the Objective-C declaration:</p>

<pre data-type="programlisting" class="calibre28">- (void)webView:(WKWebView *)webView
    decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction
    decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;</pre>

<p class="author1">You implement this method, and it is called when the user taps a link in a web view, so that you can decide how to respond. The third parameter is a block that takes one parameter &mdash; a WKNavigationActionPolicy, which is an enum &mdash; and returns no value. The block is passed to you as a Swift function, and you respond by <em class="calibre11">calling</em> the function to report your decision:</p>

<pre data-type="programlisting" class="calibre28">func webView(_ webView: WKWebView,
    decidePolicyFor navigationAction: WKNavigationAction,
    decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) {
        // ...
        decisionHandler(.allow)
}</pre>

<p class="author1">A C function is not a block, but you can also use a Swift function where a C function is expected, as I demonstrated earlier. Going in the other direction, to declare a type as a C pointer-to-function, mark the type as <code class="calibre19">@convention(c)</code>. Here are two Swift method declarations:<a data-type="indexterm" data-primary="convention(c)" id="calibre_link-552" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">func blockTaker(_ f:() -&gt; ()) {}
func functionTaker(_ f:@convention(c)() -&gt; ()) {}</pre>

<p class="author1">Objective-C sees the first as taking a block, and the second as taking a pointer-to-function.<a data-type="indexterm" data-primary="C" data-secondary="pointer-to-function" id="calibre_link-320" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</div>
</section>













<section data-type="sect2" data-pdf-bookmark="API Markup" class="calibre2"><div class="preface" id="calibre_link-2733">
<h2 class="calibre42">API Markup</h2>

<p class="author1">In the early days of Swift, its strict specific typing was a poor match for Objective-Câ€™s dynamic loose typing, and this made the Swift versions of Objective-C methods ugly and unpleasant:</p>
<dl class="calibre14">
<dt class="calibre15">Too many Optionals</dt>
<dd class="calibre16">
<p class="calibre17">In Objective-C, any object instance reference can be <code class="calibre19">nil</code>. But in Swift, only an Optional can be <code class="calibre19">nil</code>. The default solution was to use implicitly unwrapped Optionals as the medium of object interchange between Objective-C and Swift. But this was ugly, and a blunt instrument, especially because most objects arriving from Objective-C were never <em class="calibre11">in fact</em> going to be <code class="calibre19">nil</code>.</p>
</dd>
<dt class="calibre15">Too many umbrella collections</dt>
<dd class="calibre16">
<p class="calibre17">In Objective-C, a collection type such as NSArray can contain elements of multiple object types, and the collection itself is agnostic as to what types of elements it contains. But a Swift collection type can contain elements of just one type, and is itself typed according to that element type. The default solution was for every collection to arrive from Objective-C typed as having AnyObject elements; it then had to be cast down explicitly on the Swift side. This was infuriating. You would ask for a viewâ€™s <code class="calibre19">subviews</code> and get back an <code class="calibre19">[AnyObject]</code> which had to be cast down to a <code class="calibre19">[UIView]</code> &mdash; when nothing could be more obvious than that a viewâ€™s subviews would in fact all be UIView objects.</p>
</dd>
</dl>

<p class="author1">These problems were subsequently solved by modifying the Objective-C language to permit <em class="calibre11">markup</em> of declarations in such a way as to communicate to Swift a more specific knowledge of what to expect.<a data-type="indexterm" data-primary="hand-tweaking the APIs" id="calibre_link-995" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="API" data-secondary="tweaking" id="calibre_link-150" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>










<section data-type="sect3" data-pdf-bookmark="Nullability" class="calibre2"><div class="preface" id="calibre_link-3027">
<h3 class="calibre44">Nullability</h3>

<p class="author1">An Objective-C object type can be marked as <code class="calibre19">nullable</code> or <code class="calibre19">nonnull</code>, to specify, respectively, that it might or will never be <code class="calibre19">nil</code>. In the same way, C pointer types can be marked <code class="calibre19">__nullable</code> or <code class="calibre19">__nonnull</code>. Using these markers generally obviates the need for implicitly unwrapped Optionals as a medium of interchange; every type can be either a normal type or a simple Optional, and if itâ€™s an Optional, thereâ€™s a good reason for it. Thus, implicitly unwrapped Optionals are a rare sight in the Cocoa APIs nowadays.<a data-type="indexterm" data-primary="nonnull" id="calibre_link-1414" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="nullable" id="calibre_link-1474" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Optionals" data-secondary="implicitly unwrapped" id="calibre_link-1613" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">If youâ€™re writing an Objective-C header file and you donâ€™t mark up any of it as to nullability, youâ€™ll return to the bad old days: Swift will see your types as implicitly unwrapped Optionals. Hereâ€™s an Objective-C method declaration:</p>

<pre data-type="programlisting" class="calibre28">- (NSString*) badMethod: (NSString*) s;</pre>

<p class="author1">In the absence of markup, Swift sees that as follows:</p>

<pre data-type="programlisting" class="calibre28">func badMethod(_ s: String!) -&gt; String!</pre>

<p class="author1">As soon as your header file contains any markup, the Objective-C compiler will complain until it is completely marked up. As a shortcut, you can mark an entire stretch of your header file with a default <code class="calibre19">nonnull</code> setting, so that only the exceptional <code class="calibre19">nullable</code> types will need explicit markup, like this:</p>

<pre data-type="programlisting" class="calibre28">NS_ASSUME_NONNULL_BEGIN
- (NSString*) badMethod: (NSString*) s;
- (nullable NSString*) goodMethod: (NSString*) s;
NS_ASSUME_NONNULL_END</pre>

<p class="author1">Swift sees that with no implicitly unwrapped Optionals:</p>

<pre data-type="programlisting" class="calibre28">func badMethod(_ s: String) -&gt; String
func goodMethod(_ s: String) -&gt; String?</pre>
</div>
</section>













<section data-type="sect3" data-pdf-bookmark="Lightweight generics" class="calibre2"><div class="preface" id="calibre_link-3028">
<h3 class="calibre44">Lightweight generics</h3>

<p class="author1">To mark an Objective-C collection type as containing a certain type of element, the element type can appear in angle brackets (<code class="calibre19">&lt;&gt;</code>) between the name of the collection type and the asterisk. Hereâ€™s an Objective-C method that returns an array of strings:<a data-type="indexterm" data-primary="Objective-C" data-secondary="collections" id="calibre_link-1517" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">- (NSArray&lt;NSString*&gt;*) pepBoys;</pre>

<p class="author1">Swift sees the return type of that method as <code class="calibre19">[String]</code>, and there will be no need to cast it down.</p>

<p class="author1">In the declaration of an actual Objective-C collection type, a placeholder name stands for the type in angle brackets. The declaration for NSArray starts like this:<a data-type="indexterm" data-primary="lightweight generics" id="calibre_link-1229" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="lightweight generics" id="calibre_link-1529" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">@interface NSArray&lt;ObjectType&gt;
- (NSArray&lt;ObjectType&gt; *)arrayByAddingObject:(ObjectType)anObject;
// ...</pre>

<p class="author1">The first line says that weâ€™re going to use ObjectType as the placeholder name for the element type. The second line says that the <code class="calibre19">arrayByAddingObject:</code> method takes an object of the element type and returns an array of the element type. If a particular array is declared as <code class="calibre19">NSArray&lt;NSString*&gt;*</code>, the ObjectType placeholder would be resolved to <code class="calibre19">NSString*</code>. Apple refers to this sort of markup as a â€œlightweight generic,â€ and you can readily see why.</p>

<p class="author1">In Swift, classes marked up as lightweight generics are imported into Swift as actual generics even if they are not bridged collection types. Suppose I declare my own Objective-C class, parallel to NSArray:</p>

<pre data-type="programlisting" class="calibre28">@interface Thing&lt;ObjectType&gt; : NSObject
- (void) giveMeAThing:(nonnull ObjectType)anObject;
@end</pre>

<p class="author1">The Thing class arrives into Swift declared as a generic:</p>

<pre data-type="programlisting" class="calibre28">class Thing&lt;ObjectType&gt; : NSObject where ObjectType : AnyObject {</pre>

<p class="author1">Thing thus has to be instantiated by resolving the generic somehow. Often, it will be resolved explicitly:
<a data-type="indexterm" data-startref="idxobjectivecappendix" id="calibre_link-1511" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<pre data-type="programlisting" class="calibre28">let t = Thing&lt;NSString&gt;()
t.giveMeAThing("howdy") // an Int would be illegal here</pre>
</div>
</section>



</div>
</section>





</div>
</section>













<section data-type="sect1" data-pdf-bookmark="Bilingual Targets" class="calibre2"><div class="preface" id="calibre_link-2734">
<h1 class="calibre18">Bilingual Targets</h1>

<p class="author1">It is legal for a target to be a <em class="calibre11">bilingual target</em> &mdash; one that contains both Swift files and Objective-C files. A bilingual target can be useful for various reasons. You might want to take advantage of Objective-C language features. You might want to incorporate third-party code written in Objective-C. You might want to incorporate your own existing code written in Objective-C. Your app itself may have been written in Objective-C originally, and now you want to migrate part of it (or all of it, in stages) into Swift.<a data-type="indexterm" data-primary="target" data-secondary="bilingual" id="calibre_link-2191" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bilingual target" id="calibre_link-248" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Swift and Objective-C in one target" id="calibre_link-2170" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="Objective-C" data-secondary="Swift, in one target with" id="calibre_link-1546" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>

<p class="author1">The key question is how, within a single target, Swift and Objective-C hear about one anotherâ€™s code in the first place. Recall that Objective-C, unlike Swift, has a visibility problem already: Objective-C files cannot automatically see one another. Instead, each Objective-C file that needs to see another Objective-C file must be instructed explicitly to see that file, usually with an <code class="calibre19">#import</code> directive at the top of the first file:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">In order to prevent unwanted exposure of private information, an Objective-C class declaration is conventionally spread over <em class="calibre11">two</em> files: a header file (<em class="calibre11">.h</em>) containing the <code class="calibre19">@interface</code> section, and a code file (<em class="calibre11">.m</em>) containing the <code class="calibre19">@implementation</code> section.</p>
</li>
<li class="calibre12">
<p class="calibre17">Also conventionally, only <em class="calibre11">.h</em> files are ever imported. Thus, if declarations of class members, constants, and so forth are to be public, they are placed in a <em class="calibre11">.h</em> file.<a data-type="indexterm" data-primary="Objective-C" data-secondary="header files" id="calibre_link-1522" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="header files" data-secondary="Objective-C" id="calibre_link-1014" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</li>
</ul>

<p class="author1">Visibility of Swift and Objective-C to one another depends upon those conventions: it works through <em class="calibre11">.h</em> files. There are two directions of visibility, and they operate separately through two special Objective-C header files:</p>
<dl class="calibre14">
<dt class="calibre15">How Swift sees Objective-C</dt>
<dd class="calibre16">
<p class="calibre17">When you add a Swift file to an Objective-C target, or an Objective-C file to a Swift target, Xcode offers to create a <em class="calibre11">bridging header</em>. This is a <em class="calibre11">.h</em> file <em class="calibre11">in the project</em>. Its default name is derived from the target name &mdash; such as <em class="calibre11">MyCoolApp-Bridging-Header.h</em> &mdash; but the name is arbitrary and can be changed, provided you change the targetâ€™s Objective-C Bridging Header build setting to match. (Similarly, if you decline the bridging header and you decide later that you want one, create a <em class="calibre11">.h</em> file manually and point to it in the targetâ€™s Objective-C Bridging Header build setting.) An Objective-C <em class="calibre11">.h</em> file will then be visible to Swift if you <code class="calibre19">#import</code> it in this bridging header.<a data-type="indexterm" data-primary="header files" data-secondary="bridging" id="calibre_link-1010" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="bridging header" id="calibre_link-300" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
<dt class="calibre15">How Objective-C sees Swift</dt>
<dd class="calibre16">
<p class="calibre17">When you build your target, the appropriate top-level declarations of <em class="calibre11">all</em> your Swift files are <em class="calibre11">automatically</em> translated into Objective-C and are used to construct a <em class="calibre11">generated interface header</em> within the <em class="calibre11">Intermediates</em> build folder for this target, deep inside your <em class="calibre11">DerivedData</em> folder. For a target called MyCoolApp, the generated interface header is called <em class="calibre11">MyCoolApp-Swift.h</em>. The name may involve some transformation; for example, a space in the target name is translated into an underscore. You can examine or change the header name with the targetâ€™s Objective-C Generated Interface Header Name build setting. The generated interface header is how your Swift code is exposed to Objective-C in general (even in a single-language Swift project); your own Objective-C files will be able to see your Swift declarations if you <code class="calibre19">#import</code> the generated interface header into each Objective-C file that needs to see them.<a data-type="indexterm" data-primary="generated interface header" id="calibre_link-944" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a><a data-type="indexterm" data-primary="header files" data-secondary="generated interface" id="calibre_link-1012" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
</dd>
</dl>

<p class="author1">To sum up:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">The <em class="calibre11">bridging header</em> is visible in your project navigator; you write an <code class="calibre19">#import</code> statement here to make your Objective-C declarations visible to Swift.</p>
</li>
<li class="calibre12">
<p class="calibre17">The <em class="calibre11">generated interface header</em> is squirreled away in the DerivedData folder; you <code class="calibre19">#import</code> it to make your Swift declarations visible to your Objective-C code.</p>
</li>
</ul>

<p class="author1">Hereâ€™s an actual example. Letâ€™s say that Iâ€™ve added to my Swift target, called MyCoolApp, a Thing class written in Objective-C. It is distributed over two files, <em class="calibre11">Thing.h</em> and <em class="calibre11">Thing.m</em>. Then:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">For Swift code to see the Thing class, I need to <code class="calibre19">#import "Thing.h"</code> in the <em class="calibre11">bridging</em> header (<em class="calibre11">MyCoolApp-Bridging-Header.h</em>).</p>
</li>
<li class="calibre12">
<p class="calibre17">For Thing class code to see my Swift declarations, I need to <code class="calibre19">#import "MyCoolApp-Swift.h"</code> (the generated bridging header) at the top of <em class="calibre11">Thing.m</em>.</p>
</li>
</ul>

<p class="author1">Thatâ€™s how Objective-C and Swift are <em class="calibre11">able</em> to see one another; but <em class="calibre11">what</em> do Objective-C and Swift see when they see one another? Xcode makes it easy to find out, using the editorâ€™s Related Items menu (Control-1). It contains a Generated Interface hierarchical menu:</p>

<ul class="stafflist">
<li class="calibre12">
<p class="calibre17">In an Objective-C header file (such as <em class="calibre11">Thing.h</em>), the Generated Interface menu lists the Swift interface. Choose it to see how these Objective-C declarations are translated into Swift.</p>
</li>
<li class="calibre12">
<p class="calibre17">In a Swift file, the Generated Interface menu lists the Objective-C generated interface header (new in Xcode 11). Choose it to see how your targetâ€™s Swift declarations are translated into Objective-C.</p>
</li>
</ul>

<p class="author1">Before Swift existed, all my iOS apps were written in Objective-C. When Swift came along, I translated those apps into Swift. I quickly developed a step-by-step procedure for doing that; here it is:<a data-type="indexterm" data-primary="Objective-C" data-secondary="Swift, translating app into" id="calibre_link-1547" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2"></a></p>
<ol class="calibre3">
<li class="calibre4">
<p class="calibre17">Pick a <em class="calibre11">.m</em> file to be translated into Swift. Objective-C cannot subclass a Swift class, so if you have defined both a class and its subclass in Objective-C, start with the subclass. (Leave the app delegate class for last.)</p>
</li>
<li class="calibre4">
<p class="calibre17">Remove that <em class="calibre11">.m</em> file from the target. To do so, select the <em class="calibre11">.m</em> file and use the File inspector.</p>
</li>
<li class="calibre4">
<p class="calibre17">In every Objective-C file that <code class="calibre19">#import</code>s the corresponding <em class="calibre11">.h</em> file, remove that <code class="calibre19">#import</code> statement and import in its place the generated interface header (if you arenâ€™t importing it in this file already).</p>
</li>
<li class="calibre4">
<p class="calibre17">If you were importing the corresponding <em class="calibre11">.h</em> file in the bridging header, remove the <code class="calibre19">#import</code> statement.</p>
</li>
<li class="calibre4">
<p class="calibre17">Create the <em class="calibre11">.swift</em> file for this class. Make sure it is added to the target.</p>
</li>
<li class="calibre4">
<p class="calibre17">In the <em class="calibre11">.swift</em> file, declare the class and provide stub declarations for all members that were being made public in the <em class="calibre11">.h</em> file. If this class needs to adopt Cocoa protocols, adopt them; you may have to provide stub declarations of required protocol methods as well. If this file needs to refer to any other classes that your target still declares in Objective-C, import their <em class="calibre11">.h</em> files in the bridging header.</p>
</li>
<li class="calibre4">
<p class="calibre17">The project should now compile! It doesnâ€™t work, of course, because you have not written any real code in the <em class="calibre11">.swift</em> file. But who cares about that? Time for a beer!</p>
</li>
<li class="calibre4">
<p class="calibre17">Now fill out the code in the <em class="calibre11">.swift</em> file. My technique is to translate more or less line-by-line from the original Objective-C code at first, even though the outcome is not particularly idiomatic or Swifty.</p>
</li>
<li class="calibre4">
<p class="calibre17">When the code for this <em class="calibre11">.m</em> file is completely translated into Swift, build and run and test. If the runtime complains (probably accompanied by crashing) that it canâ€™t find this class, find all references to it in the nib editor and reenter the classâ€™s name in the Identity inspector (and press Tab to set the change). Save and try again.</p>
</li>
<li class="calibre4">
<p class="calibre17">On to the next <em class="calibre11">.m</em> file! Repeat all of the above steps.</p>
</li>
<li class="calibre4">
<p class="calibre17">When all of the other files have been translated, translate the app delegate class. At this point, if there are no Objective-C files left in the target, you can delete the <em class="calibre11">main.m</em> file (replacing it with a <code class="calibre19">@UIApplicationMain</code> attribute in the app delegate class declaration) and the <em class="calibre11">.pch</em> (precompiled header) file.</p>
</li>

</ol>

<p class="author1">Your app should now run, and is rewritten in pure Swift (or is, at least, as pure as you intend to make it). Now go back and think about the code, making it more Swifty and idiomatic. You may well find that things that were clumsy or tricky in Objective-C can be made much neater and clearer in Swift.</p>

<p class="author1">You can also do a <em class="calibre11">partial</em> conversion of an Objective-C class by <em class="calibre11">extending</em> it in Swift. That can be useful as a stage along the path to total conversion, or you might quite reasonably write only one or two methods of an Objective-C class in Swift, just because Swift makes it so much easier to say or understand certain kinds of thing. However, Swift cannot see the Objective-C classâ€™s members unless they are made public, so methods and properties that you were previously keeping private in the Objective-C classâ€™s <em class="calibre11">.m</em> file may have to be declared in its <em class="calibre11">.h</em> file.</p>
</div>
</section>







</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-103">
<div id="calibre_link-3029" class="calibre1"><section data-type="index" {http://www.idpf.org/2007/ops}type="index" class="calibre2"><div class="index" id="calibre_link-2735"><h1 class="calibre13">Index</h1>
<div data-type="index" class="preface"><div data-type="indexdiv" class="preface"><h3 class="calibre80">A</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">ABI stability</span>, <a data-type="index:locator" href="#calibre_link-104" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">aborting</span>, <a data-type="index:locator" href="#calibre_link-105" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Aborting the whole program</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">access control</span>, <a data-type="index:locator" href="#calibre_link-106" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">access, exclusive</span>, <a data-type="index:locator" href="#calibre_link-107" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">accessibility</span>, <a data-type="index:locator" href="#calibre_link-108" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Interface Tests</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">accessors</span>, <a data-type="index:locator" href="#calibre_link-109" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Accounts preferences</span>, <a data-type="index:locator" href="#calibre_link-110" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a>, <a data-type="index:locator" href="#calibre_link-111" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Obtaining a Developer Program Membership</a>, <a data-type="index:locator" href="#calibre_link-112" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Certificate</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">actions</span>, <a data-type="index:locator" href="#calibre_link-113" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a>, <a data-type="index:locator" href="#calibre_link-114" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Combine framework</span>, <a data-type="index:locator" href="#calibre_link-115" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">connections</span>, <a data-type="index:locator" href="#calibre_link-116" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-117" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">handler</span>, <a data-type="index:locator" href="#calibre_link-118" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">misconfiguring</span>, <a data-type="index:locator" href="#calibre_link-119" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Actions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nil-targeted</span>, <a data-type="index:locator" href="#calibre_link-120" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nil-Targeted Actions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">selector signatures</span>, <a data-type="index:locator" href="#calibre_link-121" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">target</span>, <a data-type="index:locator" href="#calibre_link-122" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Ad Hoc distribution</span>, <a data-type="index:locator" href="#calibre_link-123" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution</a>, <a data-type="index:locator" href="#calibre_link-124" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution for Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">address operator</span>, <a data-type="index:locator" href="#calibre_link-125" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-126" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Address Sanitizer</span>, <a data-type="index:locator" href="#calibre_link-127" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">adopt a protocol</span>, <a data-type="index:locator" href="#calibre_link-128" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">allCases</span>, <a data-type="index:locator" href="#calibre_link-129" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Case Iteration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Allocations instrument</span>, <a data-type="index:locator" href="#calibre_link-130" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instruments</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">allSatisfy</span>, <a data-type="index:locator" href="#calibre_link-131" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ampersand</span> (<span data-gentext="see" class="publishername">see</span> address operator)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">anonymous functions</span>, <a data-type="index:locator" href="#calibre_link-132" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">abbreviated syntax</span>, <a data-type="index:locator" href="#calibre_link-133" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">capture list</span>, <a data-type="index:locator" href="#calibre_link-134" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">define-and-call</span>, <a data-type="index:locator" href="#calibre_link-135" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Define-and-Call</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">parameter list and return type</span>, <a data-type="index:locator" href="#calibre_link-136" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-137" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">throws</span>, <a data-type="index:locator" href="#calibre_link-138" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">trailing</span>, <a data-type="index:locator" href="#calibre_link-139" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Any</span>, <a data-type="index:locator" href="#calibre_link-140" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Any</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">AnyClass</span>, <a data-type="index:locator" href="#calibre_link-141" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">AnyClass</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">AnyHashable</span>, <a data-type="index:locator" href="#calibre_link-142" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Dictionary and Objective-C NSDictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">AnyObject</span>, <a data-type="index:locator" href="#calibre_link-143" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">AnyObject</a>-<a data-type="index:locator" href="#calibre_link-144" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object identity</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">object identity</span>, <a data-type="index:locator" href="#calibre_link-145" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object identity</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">suppressing type checking</span>, <a data-type="index:locator" href="#calibre_link-146" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Suppressing type checking</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">API</span>, <a data-type="index:locator" href="#calibre_link-147" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Preface</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">tweaking</span>, <a data-type="index:locator" href="#calibre_link-148" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-149" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Failable initializers</a>, <a data-type="index:locator" href="#calibre_link-150" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">API Markup</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">app</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">bundle</span>, <a data-type="index:locator" href="#calibre_link-151" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">delegate</span>, <a data-type="index:locator" href="#calibre_link-152" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">launch process</span>, <a data-type="index:locator" href="#calibre_link-153" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The App Launch Process</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">name</span>, <a data-type="index:locator" href="#calibre_link-154" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a>, <a data-type="index:locator" href="#calibre_link-155" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a>, <a data-type="index:locator" href="#calibre_link-156" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">localizing</span>, <a data-type="index:locator" href="#calibre_link-157" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">registering</span>, <a data-type="index:locator" href="#calibre_link-158" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Manual Signing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">target</span>, <a data-type="index:locator" href="#calibre_link-159" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Target</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">version number</span>, <a data-type="index:locator" href="#calibre_link-160" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">without main storyboard</span>, <a data-type="index:locator" href="#calibre_link-161" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">App Without a Storyboard</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">App Store</span>, <a data-type="index:locator" href="#calibre_link-162" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">distribution</span>, <a data-type="index:locator" href="#calibre_link-163" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">App Store Connect</span>, <a data-type="index:locator" href="#calibre_link-164" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution for Testing</a>, <a data-type="index:locator" href="#calibre_link-165" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">append</span>, <a data-type="index:locator" href="#calibre_link-166" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-167" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Apple ID</span>, <a data-type="index:locator" href="#calibre_link-168" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Obtaining a Developer Program Membership</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ARC</span>, <a data-type="index:locator" href="#calibre_link-169" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> memory management)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">archive</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">app</span>, <a data-type="index:locator" href="#calibre_link-170" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Making an Archive</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">documentation</span>, <a data-type="index:locator" href="#calibre_link-171" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Documentation Window</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">object</span>, <a data-type="index:locator" href="#calibre_link-172" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSData</a>, <a data-type="index:locator" href="#calibre_link-173" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">arguments</span>, <a data-type="index:locator" href="#calibre_link-174" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">arguments passed on launch</span>, <a data-type="index:locator" href="#calibre_link-175" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arguments and Environment Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">arithmetic operators</span>, <a data-type="index:locator" href="#calibre_link-176" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Array</span>, <a data-type="index:locator" href="#calibre_link-177" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">arrays</span>, <a data-type="index:locator" href="#calibre_link-178" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a>-<a data-type="index:locator" href="#calibre_link-179" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">bridging</span>, <a data-type="index:locator" href="#calibre_link-180" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-181" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a>, <a data-type="index:locator" href="#calibre_link-182" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a>, <a data-type="index:locator" href="#calibre_link-183" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">C arrays</span>, <a data-type="index:locator" href="#calibre_link-184" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Arrays</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">casting</span>, <a data-type="index:locator" href="#calibre_link-185" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array casting and type testing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">concatenating</span>, <a data-type="index:locator" href="#calibre_link-186" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-187" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enumerating</span>, <a data-type="index:locator" href="#calibre_link-188" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-189" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">flattening</span>, <a data-type="index:locator" href="#calibre_link-190" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-191" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">indexing</span>, <a data-type="index:locator" href="#calibre_link-192" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-193" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">literal</span>, <a data-type="index:locator" href="#calibre_link-194" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutating</span>, <a data-type="index:locator" href="#calibre_link-195" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nested</span>, <a data-type="index:locator" href="#calibre_link-196" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested arrays</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Optional</span>, <a data-type="index:locator" href="#calibre_link-197" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array casting and type testing</a>, <a data-type="index:locator" href="#calibre_link-198" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties and methods</span>, <a data-type="index:locator" href="#calibre_link-199" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">randomizing</span>, <a data-type="index:locator" href="#calibre_link-200" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">searching</span>, <a data-type="index:locator" href="#calibre_link-201" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">sorting</span>, <a data-type="index:locator" href="#calibre_link-202" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripting</span>, <a data-type="index:locator" href="#calibre_link-203" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">testing all elements</span>, <a data-type="index:locator" href="#calibre_link-204" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">testing element type</span>, <a data-type="index:locator" href="#calibre_link-205" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array casting and type testing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">transforming</span>, <a data-type="index:locator" href="#calibre_link-206" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">uniquing</span>, <a data-type="index:locator" href="#calibre_link-207" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ArraySlice</span>, <a data-type="index:locator" href="#calibre_link-208" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">arrow operator</span>, <a data-type="index:locator" href="#calibre_link-209" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">as</span>, <a data-type="index:locator" href="#calibre_link-210" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Casting Down</a>, <a data-type="index:locator" href="#calibre_link-211" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Type Testing and Casting</a>, <a data-type="index:locator" href="#calibre_link-212" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">assert</span>, <a data-type="index:locator" href="#calibre_link-213" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Aborting the whole program</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">asset catalog</span>, <a data-type="index:locator" href="#calibre_link-214" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in an asset catalog</a>, <a data-type="index:locator" href="#calibre_link-215" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Icons in the app</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">compiled</span>, <a data-type="index:locator" href="#calibre_link-216" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">assignment</span>, <a data-type="index:locator" href="#calibre_link-217" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">compound</span>, <a data-type="index:locator" href="#calibre_link-218" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">conditional</span>, <a data-type="index:locator" href="#calibre_link-219" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">multiple</span>, <a data-type="index:locator" href="#calibre_link-220" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">assistant</span>, <a data-type="index:locator" href="#calibre_link-221" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Assistant panes</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">associated type</span>, <a data-type="index:locator" href="#calibre_link-222" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">associated type chains</span>, <a data-type="index:locator" href="#calibre_link-223" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Type Chains</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">associated value</span>, <a data-type="index:locator" href="#calibre_link-224" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Values</a>, <a data-type="index:locator" href="#calibre_link-225" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-226" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a>, <a data-type="index:locator" href="#calibre_link-227" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Attributes inspector</span>, <a data-type="index:locator" href="#calibre_link-228" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a>, <a data-type="index:locator" href="#calibre_link-229" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">attributes, custom</span>, <a data-type="index:locator" href="#calibre_link-230" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">authors (version control)</span>, <a data-type="index:locator" href="#calibre_link-231" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">autoclosure</span>, <a data-type="index:locator" href="#calibre_link-232" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Aborting the whole program</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">autocompletion</span>, <a data-type="index:locator" href="#calibre_link-233" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autocompletion and Placeholders</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">automatic signing</span>, <a data-type="index:locator" href="#calibre_link-234" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">automatic variables</span>, <a data-type="index:locator" href="#calibre_link-235" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">autorelease</span>, <a data-type="index:locator" href="#calibre_link-236" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autorelease Pool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">availability</span>, <a data-type="index:locator" href="#calibre_link-237" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Documentation Pages</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">available</span>, <a data-type="index:locator" href="#calibre_link-238" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">awakeFromNib</span>, <a data-type="index:locator" href="#calibre_link-239" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">B</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">backslash</span>, <a data-type="index:locator" href="#calibre_link-240" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-241" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key Paths</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">backward compatibility</span>, <a data-type="index:locator" href="#calibre_link-242" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bag</span>, <a data-type="index:locator" href="#calibre_link-243" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">balancing delimiters</span>, <a data-type="index:locator" href="#calibre_link-244" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">base class</span>, <a data-type="index:locator" href="#calibre_link-245" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Behaviors preferences</span>, <a data-type="index:locator" href="#calibre_link-246" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">beta testing</span>, <a data-type="index:locator" href="#calibre_link-247" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution for Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bilingual target</span>, <a data-type="index:locator" href="#calibre_link-248" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">binary numbers</span>, <a data-type="index:locator" href="#calibre_link-249" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Int</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">BindableObject</span>, <a data-type="index:locator" href="#calibre_link-250" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Binding</span>, <a data-type="index:locator" href="#calibre_link-251" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">binding, conditional</span>, <a data-type="index:locator" href="#calibre_link-252" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a>, <a data-type="index:locator" href="#calibre_link-253" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a>, <a data-type="index:locator" href="#calibre_link-254" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Bitbucket</span>, <a data-type="index:locator" href="#calibre_link-255" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bitmasks</span>, <a data-type="index:locator" href="#calibre_link-256" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a>, <a data-type="index:locator" href="#calibre_link-257" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_OPTIONS</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bitwise operators</span>, <a data-type="index:locator" href="#calibre_link-258" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a>, <a data-type="index:locator" href="#calibre_link-259" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> option sets)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">blame (version control)</span>, <a data-type="index:locator" href="#calibre_link-260" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">blocks</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">C</span>, <a data-type="index:locator" href="#calibre_link-261" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a>, <a data-type="index:locator" href="#calibre_link-262" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Blocks</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">flow control</span>, <a data-type="index:locator" href="#calibre_link-263" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">body of a function</span>, <a data-type="index:locator" href="#calibre_link-264" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bookmarking a line of code</span>, <a data-type="index:locator" href="#calibre_link-265" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Bool</span>, <a data-type="index:locator" href="#calibre_link-266" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">BOOL</span>, <a data-type="index:locator" href="#calibre_link-267" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Boolean operators</span>, <a data-type="index:locator" href="#calibre_link-268" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">boxing</span>, <a data-type="index:locator" href="#calibre_link-269" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">branching</span>, <a data-type="index:locator" href="#calibre_link-270" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a>-<a data-type="index:locator" href="#calibre_link-271" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">shortcircuiting</span>, <a data-type="index:locator" href="#calibre_link-272" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">break</span>, <a data-type="index:locator" href="#calibre_link-273" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Breakpoint navigator</span>, <a data-type="index:locator" href="#calibre_link-274" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">breakpoints</span>, <a data-type="index:locator" href="#calibre_link-275" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Breakpoints</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bridged types</span>, <a data-type="index:locator" href="#calibre_link-276" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a>, <a data-type="index:locator" href="#calibre_link-277" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a>, <a data-type="index:locator" href="#calibre_link-278" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> boxing)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">Any and id</span>, <a data-type="index:locator" href="#calibre_link-279" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Any</a>, <a data-type="index:locator" href="#calibre_link-280" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">AnyObject and id</span>, <a data-type="index:locator" href="#calibre_link-281" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">AnyObject</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Array and NSArray</span>, <a data-type="index:locator" href="#calibre_link-282" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-283" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a>, <a data-type="index:locator" href="#calibre_link-284" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">array elements</span>, <a data-type="index:locator" href="#calibre_link-285" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-286" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a>, <a data-type="index:locator" href="#calibre_link-287" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">casting</span>, <a data-type="index:locator" href="#calibre_link-288" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridging to Objective-C</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">CFTypeRefs</span>, <a data-type="index:locator" href="#calibre_link-289" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">CFTypeRefs</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Dictionary and NSDictionary</span>, <a data-type="index:locator" href="#calibre_link-290" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Dictionary and Objective-C NSDictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Error and NSError</span>, <a data-type="index:locator" href="#calibre_link-291" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Foundation</span>, <a data-type="index:locator" href="#calibre_link-292" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a>, <a data-type="index:locator" href="#calibre_link-293" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">number and NSNumber</span>, <a data-type="index:locator" href="#calibre_link-294" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Set and NSSet</span>, <a data-type="index:locator" href="#calibre_link-295" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">String and NSString</span>, <a data-type="index:locator" href="#calibre_link-296" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-297" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">struct and NSValue</span>, <a data-type="index:locator" href="#calibre_link-298" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a>, <a data-type="index:locator" href="#calibre_link-299" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bridging header</span>, <a data-type="index:locator" href="#calibre_link-300" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">build</span>, <a data-type="index:locator" href="#calibre_link-301" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">configurations</span>, <a data-type="index:locator" href="#calibre_link-302" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Configurations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">phases</span>, <a data-type="index:locator" href="#calibre_link-303" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Phases</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">settings</span>, <a data-type="index:locator" href="#calibre_link-304" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Settings</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">bundle</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">app</span>, <a data-type="index:locator" href="#calibre_link-305" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">display name</span>, <a data-type="index:locator" href="#calibre_link-306" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a>, <a data-type="index:locator" href="#calibre_link-307" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">identifier</span>, <a data-type="index:locator" href="#calibre_link-308" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">test</span>, <a data-type="index:locator" href="#calibre_link-309" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
</ul></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">C</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">C</span>, <a data-type="index:locator" href="#calibre_link-310" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The C Language</a>-<a data-type="index:locator" href="#calibre_link-311" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Pointer-to-function</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> Objective-C)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">arrays</span>, <a data-type="index:locator" href="#calibre_link-312" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Arrays</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">blocks</span>, <a data-type="index:locator" href="#calibre_link-313" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Blocks</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">data types</span>, <a data-type="index:locator" href="#calibre_link-314" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Data Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enums</span>, <a data-type="index:locator" href="#calibre_link-315" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Old-fashioned C enum</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">functions</span>, <a data-type="index:locator" href="#calibre_link-316" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">global functions</span>, <a data-type="index:locator" href="#calibre_link-317" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">numeric types</span>, <a data-type="index:locator" href="#calibre_link-318" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other numeric types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">pointer-to-function</span>, <a data-type="index:locator" href="#calibre_link-319" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Pointer-to-function</a>, <a data-type="index:locator" href="#calibre_link-320" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Blocks</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">pointer-to-void</span>, <a data-type="index:locator" href="#calibre_link-321" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">pointers</span>, <a data-type="index:locator" href="#calibre_link-322" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">strings</span>, <a data-type="index:locator" href="#calibre_link-323" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Data Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">structs</span>, <a data-type="index:locator" href="#calibre_link-324" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a>, <a data-type="index:locator" href="#calibre_link-325" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Structs</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Calendar</span>, <a data-type="index:locator" href="#calibre_link-326" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">call stack</span>, <a data-type="index:locator" href="#calibre_link-327" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Return</a>, <a data-type="index:locator" href="#calibre_link-328" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-329" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">calling a function</span>, <a data-type="index:locator" href="#calibre_link-330" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>, <a data-type="index:locator" href="#calibre_link-331" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">canvas</span>, <a data-type="index:locator" href="#calibre_link-332" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Editor Interface</a>, <a data-type="index:locator" href="#calibre_link-333" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Canvas</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Capabilities pane</span>, <a data-type="index:locator" href="#calibre_link-334" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">capitalization</span>, <a data-type="index:locator" href="#calibre_link-335" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">capture list</span>, <a data-type="index:locator" href="#calibre_link-336" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">captured variable references</span>, <a data-type="index:locator" href="#calibre_link-337" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closures</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">preserving</span>, <a data-type="index:locator" href="#calibre_link-338" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closure Preserving Captured Environment</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">setting</span>, <a data-type="index:locator" href="#calibre_link-339" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closure Setting a Captured Variable</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">case</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">enum</span>, <a data-type="index:locator" href="#calibre_link-340" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">switch statement</span>, <a data-type="index:locator" href="#calibre_link-341" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">CaseIterable</span>, <a data-type="index:locator" href="#calibre_link-342" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Case Iteration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">casting</span>, <a data-type="index:locator" href="#calibre_link-343" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Casting</a>-<a data-type="index:locator" href="#calibre_link-344" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridging to Objective-C</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">safely</span>, <a data-type="index:locator" href="#calibre_link-345" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a>, <a data-type="index:locator" href="#calibre_link-346" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">categories</span>, <a data-type="index:locator" href="#calibre_link-347" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Categories and Extensions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">caveman debugging</span>, <a data-type="index:locator" href="#calibre_link-348" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">certificate</span>, <a data-type="index:locator" href="#calibre_link-349" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">exporting</span>, <a data-type="index:locator" href="#calibre_link-350" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Certificate</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">CFTypeRefs</span>, <a data-type="index:locator" href="#calibre_link-351" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">CFTypeRefs</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-352" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of CFTypeRefs</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">chains</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">associated type</span>, <a data-type="index:locator" href="#calibre_link-353" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Type Chains</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Optional</span>, <a data-type="index:locator" href="#calibre_link-354" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">change bars</span>, <a data-type="index:locator" href="#calibre_link-355" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Character</span>, <a data-type="index:locator" href="#calibre_link-356" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">character sequence</span>, <a data-type="index:locator" href="#calibre_link-357" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">characters vs. codepoints</span>, <a data-type="index:locator" href="#calibre_link-358" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">characters, escaped</span>, <a data-type="index:locator" href="#calibre_link-359" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">class</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">clusters</span>, <a data-type="index:locator" href="#calibre_link-360" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">documentation page</span>, <a data-type="index:locator" href="#calibre_link-361" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Documentation Pages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">members</span>, <a data-type="index:locator" href="#calibre_link-362" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-363" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">of NSObject</span>, <a data-type="index:locator" href="#calibre_link-364" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Secret Life of NSObject</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">vs. static methods</span>, <a data-type="index:locator" href="#calibre_link-365" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static methods vs. class methods</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of object in nib, changing</span>, <a data-type="index:locator" href="#calibre_link-366" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-367" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-368" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How properties are accessed</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">vs. static properties</span>, <a data-type="index:locator" href="#calibre_link-369" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-370" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Protocols</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">classes</span>, <a data-type="index:locator" href="#calibre_link-371" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Classes</a>-<a data-type="index:locator" href="#calibre_link-372" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> object types)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">class methods</span>, <a data-type="index:locator" href="#calibre_link-373" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static methods vs. class methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">class properties</span>, <a data-type="index:locator" href="#calibre_link-374" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deinitializers</span>, <a data-type="index:locator" href="#calibre_link-375" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Deinitializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">documentation</span>, <a data-type="index:locator" href="#calibre_link-376" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Documentation Pages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic, subclassing</span>, <a data-type="index:locator" href="#calibre_link-377" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">hierarchy</span>, <a data-type="index:locator" href="#calibre_link-378" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">inheritance</span>, <a data-type="index:locator" href="#calibre_link-379" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inheritance</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-380" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Initializers</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">inheritance</span>, <a data-type="index:locator" href="#calibre_link-381" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">instances</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">multiple references</span>, <a data-type="index:locator" href="#calibre_link-382" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instance references are pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutating</span>, <a data-type="index:locator" href="#calibre_link-383" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reference Type Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-384" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods, overriding</span>, <a data-type="index:locator" href="#calibre_link-385" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-386" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">preventing</span>, <a data-type="index:locator" href="#calibre_link-387" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a>, <a data-type="index:locator" href="#calibre_link-388" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting type name</span>, <a data-type="index:locator" href="#calibre_link-389" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">polymorphism</span>, <a data-type="index:locator" href="#calibre_link-390" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties, overriding</span>, <a data-type="index:locator" href="#calibre_link-391" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">reference types</span>, <a data-type="index:locator" href="#calibre_link-392" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Value Types and Reference Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">static methods</span>, <a data-type="index:locator" href="#calibre_link-393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static methods vs. class methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">static properties</span>, <a data-type="index:locator" href="#calibre_link-394" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subclass and superclass</span>, <a data-type="index:locator" href="#calibre_link-395" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subclassing, preventing</span>, <a data-type="index:locator" href="#calibre_link-396" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a>, <a data-type="index:locator" href="#calibre_link-397" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts, overriding</span>, <a data-type="index:locator" href="#calibre_link-398" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword super</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">umbrella type</span>, <a data-type="index:locator" href="#calibre_link-399" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Umbrella Types</a>, <a data-type="index:locator" href="#calibre_link-400" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">AnyClass</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">vs. structs</span>, <a data-type="index:locator" href="#calibre_link-401" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Classes</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">cleaning</span>, <a data-type="index:locator" href="#calibre_link-402" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Clean</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">closures</span>, <a data-type="index:locator" href="#calibre_link-403" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closures</a>-<a data-type="index:locator" href="#calibre_link-404" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Escaping Closures</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> anonymous functions)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">captured variable references</span>, <a data-type="index:locator" href="#calibre_link-405" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closures</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">preserving</span>, <a data-type="index:locator" href="#calibre_link-406" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closure Preserving Captured Environment</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">setting</span>, <a data-type="index:locator" href="#calibre_link-407" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closure Setting a Captured Variable</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">escaping</span>, <a data-type="index:locator" href="#calibre_link-408" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Escaping Closures</a>, <a data-type="index:locator" href="#calibre_link-409" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">returned from function</span>, <a data-type="index:locator" href="#calibre_link-410" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Returning Function</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Cocoa</span>, <a data-type="index:locator" href="#calibre_link-411" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Classes</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">actions</span>, <a data-type="index:locator" href="#calibre_link-412" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">categories</span>, <a data-type="index:locator" href="#calibre_link-413" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Categories and Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">data sources</span>, <a data-type="index:locator" href="#calibre_link-414" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Data Sources</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">delegation</span>, <a data-type="index:locator" href="#calibre_link-415" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">events</span>, <a data-type="index:locator" href="#calibre_link-416" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Events</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Foundation classes</span>, <a data-type="index:locator" href="#calibre_link-417" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">key&ndash;value coding</span>, <a data-type="index:locator" href="#calibre_link-418" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">key&ndash;value observing</span>, <a data-type="index:locator" href="#calibre_link-419" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-420" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">notifications</span>, <a data-type="index:locator" href="#calibre_link-421" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-422" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">responder chain</span>, <a data-type="index:locator" href="#calibre_link-423" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Responder Chain</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subclassing</span>, <a data-type="index:locator" href="#calibre_link-424" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a>, <a data-type="index:locator" href="#calibre_link-425" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Codable</span>, <a data-type="index:locator" href="#calibre_link-426" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">code</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">bookmarking</span>, <a data-type="index:locator" href="#calibre_link-427" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">change bars</span>, <a data-type="index:locator" href="#calibre_link-428" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">completion</span>, <a data-type="index:locator" href="#calibre_link-429" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autocompletion and Placeholders</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">coverage</span>, <a data-type="index:locator" href="#calibre_link-430" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">editing</span>, <a data-type="index:locator" href="#calibre_link-431" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Text Editing Preferences</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">folding</span>, <a data-type="index:locator" href="#calibre_link-432" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Display</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">font</span>, <a data-type="index:locator" href="#calibre_link-433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing and Navigating Your Code</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">indentation</span>, <a data-type="index:locator" href="#calibre_link-434" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Indentation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">location</span>, <a data-type="index:locator" href="#calibre_link-435" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>, <a data-type="index:locator" href="#calibre_link-436" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Events</a>, <a data-type="index:locator" href="#calibre_link-437" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swamped by Events</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">minimap</span>, <a data-type="index:locator" href="#calibre_link-438" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">navigating</span>, <a data-type="index:locator" href="#calibre_link-439" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">refactoring</span>, <a data-type="index:locator" href="#calibre_link-440" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Refactoring and Structure Editing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">searching</span>, <a data-type="index:locator" href="#calibre_link-441" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Finding</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">selecting</span>, <a data-type="index:locator" href="#calibre_link-442" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Multiple Selection</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">snippets</span>, <a data-type="index:locator" href="#calibre_link-443" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Snippets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">strings, localizing</span>, <a data-type="index:locator" href="#calibre_link-444" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Code Review editor</span>, <a data-type="index:locator" href="#calibre_link-445" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">code signing</span> (<span data-gentext="see" class="publishername">see</span> signing an app)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">codepoints, Unicode</span>, <a data-type="index:locator" href="#calibre_link-446" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">vs. characters</span>, <a data-type="index:locator" href="#calibre_link-447" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">coercion</span>, <a data-type="index:locator" href="#calibre_link-448" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Numeric coercion</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">numeric</span>, <a data-type="index:locator" href="#calibre_link-449" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Numeric coercion</a>, <a data-type="index:locator" href="#calibre_link-450" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Data Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Range and NSRange</span>, <a data-type="index:locator" href="#calibre_link-451" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSRange</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">String and Int</span>, <a data-type="index:locator" href="#calibre_link-452" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">collections</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Foundation</span>, <a data-type="index:locator" href="#calibre_link-453" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSIndexSet</a>-<a data-type="index:locator" href="#calibre_link-454" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-455" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Cocoa Objects Manage Memory</a>, <a data-type="index:locator" href="#calibre_link-456" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift</span>, <a data-type="index:locator" href="#calibre_link-457" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Collection Types</a>-<a data-type="index:locator" href="#calibre_link-458" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Set and Objective-C NSSet</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">colon</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">adopting protocol</span>, <a data-type="index:locator" href="#calibre_link-459" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">argument label</span>, <a data-type="index:locator" href="#calibre_link-460" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enum raw value type</span>, <a data-type="index:locator" href="#calibre_link-461" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic type constraint</span>, <a data-type="index:locator" href="#calibre_link-462" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">key&ndash;value</span>, <a data-type="index:locator" href="#calibre_link-463" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">label</span>, <a data-type="index:locator" href="#calibre_link-464" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">parameter name</span>, <a data-type="index:locator" href="#calibre_link-465" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">superclass</span>, <a data-type="index:locator" href="#calibre_link-466" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inheritance</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">ternary operator</span>, <a data-type="index:locator" href="#calibre_link-467" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variable type</span>, <a data-type="index:locator" href="#calibre_link-468" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Colors library</span>, <a data-type="index:locator" href="#calibre_link-469" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Combine framework</span>, <a data-type="index:locator" href="#calibre_link-470" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a>-<a data-type="index:locator" href="#calibre_link-471" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">comma</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">arguments</span>, <a data-type="index:locator" href="#calibre_link-472" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">array literal</span>, <a data-type="index:locator" href="#calibre_link-473" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">condition list</span>, <a data-type="index:locator" href="#calibre_link-474" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dictionary literal</span>, <a data-type="index:locator" href="#calibre_link-475" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic constraints</span>, <a data-type="index:locator" href="#calibre_link-476" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic placeholders</span>, <a data-type="index:locator" href="#calibre_link-477" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">parameters</span>, <a data-type="index:locator" href="#calibre_link-478" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocol</span>, <a data-type="index:locator" href="#calibre_link-479" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a>, <a data-type="index:locator" href="#calibre_link-480" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">switch case</span>, <a data-type="index:locator" href="#calibre_link-481" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">tuples</span>, <a data-type="index:locator" href="#calibre_link-482" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variadics</span>, <a data-type="index:locator" href="#calibre_link-483" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">comments</span>, <a data-type="index:locator" href="#calibre_link-484" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">MARK</span>, <a data-type="index:locator" href="#calibre_link-485" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">self-documenting</span>, <a data-type="index:locator" href="#calibre_link-486" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Quick Help</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">communication between objects</span>, <a data-type="index:locator" href="#calibre_link-487" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility Through an Instance Property</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compactMap</span>, <a data-type="index:locator" href="#calibre_link-488" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Comparable</span>, <a data-type="index:locator" href="#calibre_link-489" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compare</span>, <a data-type="index:locator" href="#calibre_link-490" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">comparison operators</span>, <a data-type="index:locator" href="#calibre_link-491" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparison</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ComparisonResult</span>, <a data-type="index:locator" href="#calibre_link-492" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compatibility, backward</span>, <a data-type="index:locator" href="#calibre_link-493" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compilation, conditional</span>, <a data-type="index:locator" href="#calibre_link-494" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional Compilation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compile error</span>, <a data-type="index:locator" href="#calibre_link-495" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Compile Sources build phase</span>, <a data-type="index:locator" href="#calibre_link-496" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Phases</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compiler</span>, <a data-type="index:locator" href="#calibre_link-497" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">completion</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">code</span>, <a data-type="index:locator" href="#calibre_link-498" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autocompletion and Placeholders</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type-over</span>, <a data-type="index:locator" href="#calibre_link-499" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compliant, key&ndash;value coding</span>, <a data-type="index:locator" href="#calibre_link-500" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Components preferences</span>, <a data-type="index:locator" href="#calibre_link-501" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Schemes and Destinations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">composition of protocols</span>, <a data-type="index:locator" href="#calibre_link-502" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Composition</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">compound assignment operators</span>, <a data-type="index:locator" href="#calibre_link-503" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">computed initializer</span>, <a data-type="index:locator" href="#calibre_link-504" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variable Initializer</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">computed properties</span>, <a data-type="index:locator" href="#calibre_link-505" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Properties</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">computed variables</span>, <a data-type="index:locator" href="#calibre_link-506" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">concatenating arrays</span>, <a data-type="index:locator" href="#calibre_link-507" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">concatenating strings</span>, <a data-type="index:locator" href="#calibre_link-508" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">condition list</span>, <a data-type="index:locator" href="#calibre_link-509" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditional assignment</span>, <a data-type="index:locator" href="#calibre_link-510" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditional binding</span>, <a data-type="index:locator" href="#calibre_link-511" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a>, <a data-type="index:locator" href="#calibre_link-512" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a>, <a data-type="index:locator" href="#calibre_link-513" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditional compilation</span>, <a data-type="index:locator" href="#calibre_link-514" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional Compilation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditional conformance</span>, <a data-type="index:locator" href="#calibre_link-515" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditional evaluation</span>, <a data-type="index:locator" href="#calibre_link-516" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditional initialization</span>, <a data-type="index:locator" href="#calibre_link-517" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conditions</span>, <a data-type="index:locator" href="#calibre_link-518" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a>, <a data-type="index:locator" href="#calibre_link-519" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">configurations</span>, <a data-type="index:locator" href="#calibre_link-520" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Configurations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conform to a protocol</span>, <a data-type="index:locator" href="#calibre_link-521" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">conformance, conditional</span>, <a data-type="index:locator" href="#calibre_link-522" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">connections</span>, <a data-type="index:locator" href="#calibre_link-523" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Connections</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">action</span>, <a data-type="index:locator" href="#calibre_link-524" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">between nibs</span>, <a data-type="index:locator" href="#calibre_link-525" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Connections Between Nibs &mdash; Not!</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-526" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a>, <a data-type="index:locator" href="#calibre_link-527" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">More Ways to Create Outlets</a>, <a data-type="index:locator" href="#calibre_link-528" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deleting</span>, <a data-type="index:locator" href="#calibre_link-529" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deleting an Outlet</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">outlet</span>, <a data-type="index:locator" href="#calibre_link-530" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Outlets</a>, <a data-type="index:locator" href="#calibre_link-531" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Outlets Work</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Connections inspector</span>, <a data-type="index:locator" href="#calibre_link-532" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a>, <a data-type="index:locator" href="#calibre_link-533" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatically Configured Nibs</a>, <a data-type="index:locator" href="#calibre_link-534" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deleting an Outlet</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">console</span>, <a data-type="index:locator" href="#calibre_link-535" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-536" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Console application</span>, <a data-type="index:locator" href="#calibre_link-537" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">constants</span>, <a data-type="index:locator" href="#calibre_link-538" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-539" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a>, <a data-type="index:locator" href="#calibre_link-540" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">global string</span>, <a data-type="index:locator" href="#calibre_link-541" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global string constants</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">constraints, type</span>, <a data-type="index:locator" href="#calibre_link-542" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-543" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">multiple</span>, <a data-type="index:locator" href="#calibre_link-544" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">contains</span>, <a data-type="index:locator" href="#calibre_link-545" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-546" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-547" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">continue</span>, <a data-type="index:locator" href="#calibre_link-548" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">control events</span>, <a data-type="index:locator" href="#calibre_link-549" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a>, <a data-type="index:locator" href="#calibre_link-550" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">control flow</span> (<span data-gentext="see" class="publishername">see</span> flow control)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">convenience initializers</span>, <a data-type="index:locator" href="#calibre_link-551" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">convention(c)</span>, <a data-type="index:locator" href="#calibre_link-552" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Blocks</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Copy Bundle Resources build phase</span>, <a data-type="index:locator" href="#calibre_link-553" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Build Phases</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">copying instances</span>, <a data-type="index:locator" href="#calibre_link-554" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instance references are pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">count</span>, <a data-type="index:locator" href="#calibre_link-555" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-556" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-557" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">covariant</span>, <a data-type="index:locator" href="#calibre_link-558" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a>, <a data-type="index:locator" href="#calibre_link-559" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Invariance</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">coverage, code</span>, <a data-type="index:locator" href="#calibre_link-560" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">crash</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">class not key&ndash;value coding compliant</span>, <a data-type="index:locator" href="#calibre_link-561" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Outlets</a>, <a data-type="index:locator" href="#calibre_link-562" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a>, <a data-type="index:locator" href="#calibre_link-563" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Outlets Work</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">could not cast value</span>, <a data-type="index:locator" href="#calibre_link-564" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deallocated object</span>, <a data-type="index:locator" href="#calibre_link-565" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">loaded nib but view outlet was not set</span>, <a data-type="index:locator" href="#calibre_link-566" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Outlets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">not enough bits</span>, <a data-type="index:locator" href="#calibre_link-567" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other numeric types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">simultaneous accesses</span>, <a data-type="index:locator" href="#calibre_link-568" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unexpectedly found nil</span>, <a data-type="index:locator" href="#calibre_link-569" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a>, <a data-type="index:locator" href="#calibre_link-570" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Outlets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unrecognized selector</span>, <a data-type="index:locator" href="#calibre_link-571" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a>, <a data-type="index:locator" href="#calibre_link-572" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Actions</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">creating an action connection</span>, <a data-type="index:locator" href="#calibre_link-573" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">creating an enum</span>, <a data-type="index:locator" href="#calibre_link-574" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">creating an instance</span>, <a data-type="index:locator" href="#calibre_link-575" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-576" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a>, <a data-type="index:locator" href="#calibre_link-577" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">creating an outlet</span>, <a data-type="index:locator" href="#calibre_link-578" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">More Ways to Create Outlets</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">curly braces</span>, <a data-type="index:locator" href="#calibre_link-579" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a>, <a data-type="index:locator" href="#calibre_link-580" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a>, <a data-type="index:locator" href="#calibre_link-581" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a>, <a data-type="index:locator" href="#calibre_link-582" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a>, <a data-type="index:locator" href="#calibre_link-583" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Setter Observers</a>, <a data-type="index:locator" href="#calibre_link-584" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-585" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a>, <a data-type="index:locator" href="#calibre_link-586" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a>, <a data-type="index:locator" href="#calibre_link-587" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a>, <a data-type="index:locator" href="#calibre_link-588" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Deinitializer</a>, <a data-type="index:locator" href="#calibre_link-589" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Declaring a Protocol</a>, <a data-type="index:locator" href="#calibre_link-590" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a>, <a data-type="index:locator" href="#calibre_link-591" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">currying</span>, <a data-type="index:locator" href="#calibre_link-592" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Curried Functions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">custom attributes</span>, <a data-type="index:locator" href="#calibre_link-593" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">CustomNSError</span>, <a data-type="index:locator" href="#calibre_link-594" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">CustomReflectable</span>, <a data-type="index:locator" href="#calibre_link-595" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Introspection</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">CustomStringConvertible</span>, <a data-type="index:locator" href="#calibre_link-596" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">D</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">dance, weak&ndash;strong</span>, <a data-type="index:locator" href="#calibre_link-597" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dangling pointers</span>, <a data-type="index:locator" href="#calibre_link-598" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Data</span>, <a data-type="index:locator" href="#calibre_link-599" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSData</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">data sources</span>, <a data-type="index:locator" href="#calibre_link-600" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Data Sources</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">data tips</span>, <a data-type="index:locator" href="#calibre_link-601" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Date</span>, <a data-type="index:locator" href="#calibre_link-602" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">DateComponents</span>, <a data-type="index:locator" href="#calibre_link-603" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">DateFormatter</span>, <a data-type="index:locator" href="#calibre_link-604" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">DateInterval</span>, <a data-type="index:locator" href="#calibre_link-605" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dates</span>, <a data-type="index:locator" href="#calibre_link-606" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">debug bar</span>, <a data-type="index:locator" href="#calibre_link-607" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Debug menu (Simulator)</span>, <a data-type="index:locator" href="#calibre_link-608" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running in the Simulator</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Debug navigator</span>, <a data-type="index:locator" href="#calibre_link-609" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-610" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a>, <a data-type="index:locator" href="#calibre_link-611" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Gauges</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Debug pane</span>, <a data-type="index:locator" href="#calibre_link-612" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-613" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">debugger, Xcode</span>, <a data-type="index:locator" href="#calibre_link-614" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Xcode Debugger</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">debugging</span>, <a data-type="index:locator" href="#calibre_link-615" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging</a>-<a data-type="index:locator" href="#calibre_link-616" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-617" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a>, <a data-type="index:locator" href="#calibre_link-618" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Decimal</span>, <a data-type="index:locator" href="#calibre_link-619" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">decimal point</span>, <a data-type="index:locator" href="#calibre_link-620" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Double</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">declaration</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">jumping to</span>, <a data-type="index:locator" href="#calibre_link-621" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Symbol Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of arrays</span>, <a data-type="index:locator" href="#calibre_link-622" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of dictionaries</span>, <a data-type="index:locator" href="#calibre_link-623" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of enums</span>, <a data-type="index:locator" href="#calibre_link-624" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of extensions</span>, <a data-type="index:locator" href="#calibre_link-625" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of functions</span>, <a data-type="index:locator" href="#calibre_link-626" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of generics</span>, <a data-type="index:locator" href="#calibre_link-627" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of object types</span>, <a data-type="index:locator" href="#calibre_link-628" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of operators</span>, <a data-type="index:locator" href="#calibre_link-629" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of protocols</span>, <a data-type="index:locator" href="#calibre_link-630" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Declaring a Protocol</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of sets</span>, <a data-type="index:locator" href="#calibre_link-631" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of variables</span>, <a data-type="index:locator" href="#calibre_link-632" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">decoding and encoding</span>, <a data-type="index:locator" href="#calibre_link-633" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">defer statement</span>, <a data-type="index:locator" href="#calibre_link-634" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Defer statement</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">deferred initialization</span>, <a data-type="index:locator" href="#calibre_link-635" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-636" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">define-and-call</span>, <a data-type="index:locator" href="#calibre_link-637" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Define-and-Call</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">deinit</span>, <a data-type="index:locator" href="#calibre_link-638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Deinitializer</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">not called</span>, <a data-type="index:locator" href="#calibre_link-639" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a>, <a data-type="index:locator" href="#calibre_link-640" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">delayed performance</span>, <a data-type="index:locator" href="#calibre_link-641" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delayed Performance</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">delegate</span>, <a data-type="index:locator" href="#calibre_link-642" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegation</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-643" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">delegating initializers</span>, <a data-type="index:locator" href="#calibre_link-644" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegating initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">delegation</span> (<span data-gentext="see" class="publishername">see</span> delegate)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">deleting an outlet</span>, <a data-type="index:locator" href="#calibre_link-645" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deleting an Outlet</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">delimiters, balancing</span>, <a data-type="index:locator" href="#calibre_link-646" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dependencies</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">compile-time</span>, <a data-type="index:locator" href="#calibre_link-647" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional Compilation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">runtime</span>, <a data-type="index:locator" href="#calibre_link-648" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Permissible Runtime Environment</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Deployment Target build setting</span>, <a data-type="index:locator" href="#calibre_link-649" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Permissible Runtime Environment</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">description</span>, <a data-type="index:locator" href="#calibre_link-650" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">designated initializers</span>, <a data-type="index:locator" href="#calibre_link-651" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a>, <a data-type="index:locator" href="#calibre_link-652" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">destinations</span>, <a data-type="index:locator" href="#calibre_link-653" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Schemes and Destinations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">developer member center</span>, <a data-type="index:locator" href="#calibre_link-654" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Development Asset build setting</span>, <a data-type="index:locator" href="#calibre_link-655" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in an asset catalog</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">development provisioning profile</span>, <a data-type="index:locator" href="#calibre_link-656" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">device</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">registering</span>, <a data-type="index:locator" href="#calibre_link-657" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a>, <a data-type="index:locator" href="#calibre_link-658" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Manual Signing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">running on</span>, <a data-type="index:locator" href="#calibre_link-659" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running on a Device</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type</span>, <a data-type="index:locator" href="#calibre_link-660" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Devices and Simulators window</span>, <a data-type="index:locator" href="#calibre_link-661" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Managing Development Certificates and Devices</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dictionaries</span>, <a data-type="index:locator" href="#calibre_link-662" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a>-<a data-type="index:locator" href="#calibre_link-663" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Dictionary and Objective-C NSDictionary</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">casting</span>, <a data-type="index:locator" href="#calibre_link-664" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary casting and comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-665" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-666" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enumerating</span>, <a data-type="index:locator" href="#calibre_link-667" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-668" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary casting and comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">hashable keys</span>, <a data-type="index:locator" href="#calibre_link-669" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">keys</span>, <a data-type="index:locator" href="#calibre_link-670" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">literals</span>, <a data-type="index:locator" href="#calibre_link-671" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">merging</span>, <a data-type="index:locator" href="#calibre_link-672" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutating</span>, <a data-type="index:locator" href="#calibre_link-673" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary subscripting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-674" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripting</span>, <a data-type="index:locator" href="#calibre_link-675" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary subscripting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">testing type</span>, <a data-type="index:locator" href="#calibre_link-676" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary casting and comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">transformations</span>, <a data-type="index:locator" href="#calibre_link-677" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">values</span>, <a data-type="index:locator" href="#calibre_link-678" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Dictionary</span>, <a data-type="index:locator" href="#calibre_link-679" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">didSet</span>, <a data-type="index:locator" href="#calibre_link-680" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Setter Observers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dispatch table</span>, <a data-type="index:locator" href="#calibre_link-681" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dispatch, dynamic</span>, <a data-type="index:locator" href="#calibre_link-682" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">display name</span>, <a data-type="index:locator" href="#calibre_link-683" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a>, <a data-type="index:locator" href="#calibre_link-684" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">distributing your app</span>, <a data-type="index:locator" href="#calibre_link-685" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">distribution provisioning profile</span>, <a data-type="index:locator" href="#calibre_link-686" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Profile</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">do</span>, <a data-type="index:locator" href="#calibre_link-687" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested scopes</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">do...catch</span>, <a data-type="index:locator" href="#calibre_link-688" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dock</span>, <a data-type="index:locator" href="#calibre_link-689" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">document outline</span>, <a data-type="index:locator" href="#calibre_link-690" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">documentation</span>, <a data-type="index:locator" href="#calibre_link-691" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Documentation</a>-<a data-type="index:locator" href="#calibre_link-692" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Internet Resources</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">archive</span>, <a data-type="index:locator" href="#calibre_link-693" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Documentation Window</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">class</span>, <a data-type="index:locator" href="#calibre_link-694" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Documentation Pages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">comments</span>, <a data-type="index:locator" href="#calibre_link-695" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Quick Help</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">delegate</span>, <a data-type="index:locator" href="#calibre_link-696" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Delegation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">immutable vs. mutable classes</span>, <a data-type="index:locator" href="#calibre_link-697" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-698" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">searching</span>, <a data-type="index:locator" href="#calibre_link-699" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Documentation Window</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">window</span>, <a data-type="index:locator" href="#calibre_link-700" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Documentation</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dollar sign</span>, <a data-type="index:locator" href="#calibre_link-701" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">doom, pyramid of</span>, <a data-type="index:locator" href="#calibre_link-702" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dot-notation</span>, <a data-type="index:locator" href="#calibre_link-703" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Everything Is an Object?</a>, <a data-type="index:locator" href="#calibre_link-704" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Namespaces</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">function references</span>, <a data-type="index:locator" href="#calibre_link-705" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Reference Scope</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">key paths</span>, <a data-type="index:locator" href="#calibre_link-706" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Key Paths</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Optionals</span>, <a data-type="index:locator" href="#calibre_link-707" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">tuples</span>, <a data-type="index:locator" href="#calibre_link-708" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Double</span>, <a data-type="index:locator" href="#calibre_link-709" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Double</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">downcasting</span> (<span data-gentext="see" class="publishername">see</span> casting)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">drawing a view</span>, <a data-type="index:locator" href="#calibre_link-710" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">drawing text</span>, <a data-type="index:locator" href="#calibre_link-711" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">drop</span>, <a data-type="index:locator" href="#calibre_link-712" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dropFirst</span>, <a data-type="index:locator" href="#calibre_link-713" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-714" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dropLast</span>, <a data-type="index:locator" href="#calibre_link-715" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-716" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dump</span>, <a data-type="index:locator" href="#calibre_link-717" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Introspection</a>, <a data-type="index:locator" href="#calibre_link-718" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dynamic</span>, <a data-type="index:locator" href="#calibre_link-719" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing Example</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dynamic dispatch</span>, <a data-type="index:locator" href="#calibre_link-720" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">dynamic members</span>, <a data-type="index:locator" href="#calibre_link-721" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dynamic Membership</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">E</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">early exit</span>, <a data-type="index:locator" href="#calibre_link-722" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Jumping</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">editing</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">a storyboard</span>, <a data-type="index:locator" href="#calibre_link-723" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Editor Interface</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">a xib file</span>, <a data-type="index:locator" href="#calibre_link-724" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">the project</span>, <a data-type="index:locator" href="#calibre_link-725" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Target</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">the target</span>, <a data-type="index:locator" href="#calibre_link-726" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Target</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">your code</span>, <a data-type="index:locator" href="#calibre_link-727" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing and Navigating Your Code</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">editor</span>, <a data-type="index:locator" href="#calibre_link-728" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Editor</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">nib</span>, <a data-type="index:locator" href="#calibre_link-729" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">panes</span>, <a data-type="index:locator" href="#calibre_link-730" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editor panes</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Empty Window example project</span>, <a data-type="index:locator" href="#calibre_link-731" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a>, <a data-type="index:locator" href="#calibre_link-732" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Canvas</a>, <a data-type="index:locator" href="#calibre_link-733" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">encoding and decoding</span>, <a data-type="index:locator" href="#calibre_link-734" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">endIndex</span>, <a data-type="index:locator" href="#calibre_link-735" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-736" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ensure code is executed</span>, <a data-type="index:locator" href="#calibre_link-737" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Defer statement</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">entitlements</span>, <a data-type="index:locator" href="#calibre_link-738" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a>, <a data-type="index:locator" href="#calibre_link-739" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">entry point</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">code</span>, <a data-type="index:locator" href="#calibre_link-740" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Entry Point</a>, <a data-type="index:locator" href="#calibre_link-741" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swamped by Events</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">storyboard</span>, <a data-type="index:locator" href="#calibre_link-742" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">enumerated</span>, <a data-type="index:locator" href="#calibre_link-743" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a>, <a data-type="index:locator" href="#calibre_link-744" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a>, <a data-type="index:locator" href="#calibre_link-745" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">enums</span>, <a data-type="index:locator" href="#calibre_link-746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a>-<a data-type="index:locator" href="#calibre_link-747" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Enums?</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> object types)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">associated value</span>, <a data-type="index:locator" href="#calibre_link-748" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Values</a>, <a data-type="index:locator" href="#calibre_link-749" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-750" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a>, <a data-type="index:locator" href="#calibre_link-751" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a>, <a data-type="index:locator" href="#calibre_link-752" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equatable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">C enums</span>, <a data-type="index:locator" href="#calibre_link-753" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Old-fashioned C enum</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">cases</span>, <a data-type="index:locator" href="#calibre_link-754" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">enumerating</span>, <a data-type="index:locator" href="#calibre_link-755" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Case Iteration</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-756" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-757" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a>, <a data-type="index:locator" href="#calibre_link-758" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Values</a>, <a data-type="index:locator" href="#calibre_link-759" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equatable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">indirect</span>, <a data-type="index:locator" href="#calibre_link-760" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Advantages of value types vs. reference types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-761" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializing</span>, <a data-type="index:locator" href="#calibre_link-762" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-763" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting type name</span>, <a data-type="index:locator" href="#calibre_link-764" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-765" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">raw value</span>, <a data-type="index:locator" href="#calibre_link-766" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-767" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">environment variables</span>, <a data-type="index:locator" href="#calibre_link-768" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arguments and Environment Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">equal sign</span>, <a data-type="index:locator" href="#calibre_link-769" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">equality</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">of Objective-C objects</span>, <a data-type="index:locator" href="#calibre_link-770" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of Swift objects</span>, <a data-type="index:locator" href="#calibre_link-771" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Synthesized Protocol Implementations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">operators</span>, <a data-type="index:locator" href="#calibre_link-772" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparison</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Equatable</span>, <a data-type="index:locator" href="#calibre_link-773" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Values</a>, <a data-type="index:locator" href="#calibre_link-774" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a>, <a data-type="index:locator" href="#calibre_link-775" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-776" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">synthesizing implemention</span>, <a data-type="index:locator" href="#calibre_link-777" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Synthesized Protocol Implementations</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Error</span>, <a data-type="index:locator" href="#calibre_link-778" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ErrorPointer</span>, <a data-type="index:locator" href="#calibre_link-779" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">errors</span>, <a data-type="index:locator" href="#calibre_link-780" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a>-<a data-type="index:locator" href="#calibre_link-781" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">catching</span>, <a data-type="index:locator" href="#calibre_link-782" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-783" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">throwing</span>, <a data-type="index:locator" href="#calibre_link-784" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">asynchronous</span>, <a data-type="index:locator" href="#calibre_link-785" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Result</a></li>
</ul></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">errors, compile</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">trailing closure requires parentheses</span>, <a data-type="index:locator" href="#calibre_link-786" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">errors, compiler</span>, <a data-type="index:locator" href="#calibre_link-787" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">ambiguous</span>, <a data-type="index:locator" href="#calibre_link-788" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overloading</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">cannot convert value to specified type</span>, <a data-type="index:locator" href="#calibre_link-789" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Contradictory Resolution is Impossible</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">cannot invoke index</span>, <a data-type="index:locator" href="#calibre_link-790" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">cannot use instance member</span>, <a data-type="index:locator" href="#calibre_link-791" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">escaping closure captures mutating self</span>, <a data-type="index:locator" href="#calibre_link-792" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">expected declaration</span>, <a data-type="index:locator" href="#calibre_link-793" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">expressions are not allowed</span>, <a data-type="index:locator" href="#calibre_link-794" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">heterogeneous collection</span>, <a data-type="index:locator" href="#calibre_link-795" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializer requirement</span>, <a data-type="index:locator" href="#calibre_link-796" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Initializing from a metatype value must reference init explicitly</span>, <a data-type="index:locator" href="#calibre_link-797" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type as Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overlapping accesses</span>, <a data-type="index:locator" href="#calibre_link-798" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocol can only be used</span>, <a data-type="index:locator" href="#calibre_link-799" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">required initializer must be provided</span>, <a data-type="index:locator" href="#calibre_link-800" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">return from initializer</span>, <a data-type="index:locator" href="#calibre_link-801" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">self used</span>, <a data-type="index:locator" href="#calibre_link-802" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Referring to self</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unable to infer return type</span>, <a data-type="index:locator" href="#calibre_link-803" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">use of unresolved identifier self</span>, <a data-type="index:locator" href="#calibre_link-804" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">value of Optional type must be unwrapped</span>, <a data-type="index:locator" href="#calibre_link-805" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">escaped characters</span>, <a data-type="index:locator" href="#calibre_link-806" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">escaping</span>, <a data-type="index:locator" href="#calibre_link-807" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Escaping Closures</a>, <a data-type="index:locator" href="#calibre_link-808" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">evaluation, conditional</span>, <a data-type="index:locator" href="#calibre_link-809" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">event-based programming</span>, <a data-type="index:locator" href="#calibre_link-810" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swamped by Events</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">events</span>, <a data-type="index:locator" href="#calibre_link-811" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a>, <a data-type="index:locator" href="#calibre_link-812" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Events</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">exception breakpoint</span>, <a data-type="index:locator" href="#calibre_link-813" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Breakpoints</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">exclamation mark</span>, <a data-type="index:locator" href="#calibre_link-814" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unwrapping an Optional</a>, <a data-type="index:locator" href="#calibre_link-815" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly unwrapped Optional</a>, <a data-type="index:locator" href="#calibre_link-816" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a>, <a data-type="index:locator" href="#calibre_link-817" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Casting Down</a>, <a data-type="index:locator" href="#calibre_link-818" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional members</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">exclusive access</span>, <a data-type="index:locator" href="#calibre_link-819" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">exit, early</span>, <a data-type="index:locator" href="#calibre_link-820" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Jumping</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">explicit specialization</span>, <a data-type="index:locator" href="#calibre_link-821" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">explicit variable type</span>, <a data-type="index:locator" href="#calibre_link-822" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">exporting certificates</span>, <a data-type="index:locator" href="#calibre_link-823" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Certificate</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">exporting from an archive</span>, <a data-type="index:locator" href="#calibre_link-824" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Making an Archive</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">extend</span> (<span data-gentext="see" class="publishername">see</span> extensions)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-825" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a>, <a data-type="index:locator" href="#calibre_link-826" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Swift Uses Extensions</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> categories)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaring</span>, <a data-type="index:locator" href="#calibre_link-827" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generics</span>, <a data-type="index:locator" href="#calibre_link-828" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">type constraints</span>, <a data-type="index:locator" href="#calibre_link-829" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">object types</span>, <a data-type="index:locator" href="#calibre_link-830" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a>, <a data-type="index:locator" href="#calibre_link-831" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overrides</span>, <a data-type="index:locator" href="#calibre_link-832" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-833" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Protocols</a>, <a data-type="index:locator" href="#calibre_link-834" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How You Use Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">restrictions on</span>, <a data-type="index:locator" href="#calibre_link-835" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">structs</span>, <a data-type="index:locator" href="#calibre_link-836" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">external parameter names</span>, <a data-type="index:locator" href="#calibre_link-837" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-838" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-839" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-840" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a></li>
</ul></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">F</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">factory</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">for functions</span>, <a data-type="index:locator" href="#calibre_link-841" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Returning Function</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">for instances</span>, <a data-type="index:locator" href="#calibre_link-842" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods, Objective-C</span>, <a data-type="index:locator" href="#calibre_link-843" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Initializers and Factories</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">failable initializers</span>, <a data-type="index:locator" href="#calibre_link-844" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Failable initializers</a>, <a data-type="index:locator" href="#calibre_link-845" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">fallthrough</span>, <a data-type="index:locator" href="#calibre_link-846" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-847" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">false</span>, <a data-type="index:locator" href="#calibre_link-848" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">fatal error</span> (<span data-gentext="see" class="publishername">see</span> crash)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">fatalError</span>, <a data-type="index:locator" href="#calibre_link-849" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Aborting the whole program</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">File inspector</span>, <a data-type="index:locator" href="#calibre_link-850" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">file templates</span>, <a data-type="index:locator" href="#calibre_link-851" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Code Files</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">file, Swift, structure</span>, <a data-type="index:locator" href="#calibre_link-852" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">fileprivate</span>, <a data-type="index:locator" href="#calibre_link-853" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Fileâ€™s Owner</span>, <a data-type="index:locator" href="#calibre_link-854" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">filter</span>, <a data-type="index:locator" href="#calibre_link-855" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a>, <a data-type="index:locator" href="#calibre_link-856" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">final</span>, <a data-type="index:locator" href="#calibre_link-857" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a>, <a data-type="index:locator" href="#calibre_link-858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Find navigator</span>, <a data-type="index:locator" href="#calibre_link-859" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-860" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Finding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">finding</span>, <a data-type="index:locator" href="#calibre_link-861" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Finding</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> searching)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">first</span>, <a data-type="index:locator" href="#calibre_link-862" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-863" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">First Responder proxy object</span>, <a data-type="index:locator" href="#calibre_link-864" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nil-Targeted Actions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">firstIndex</span>, <a data-type="index:locator" href="#calibre_link-865" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-866" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Fix-it</span>, <a data-type="index:locator" href="#calibre_link-867" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Fix-it and Live Syntax Checking</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">flag</span>, <a data-type="index:locator" href="#calibre_link-868" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">flatMap</span>, <a data-type="index:locator" href="#calibre_link-869" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional map and flatMap</a>, <a data-type="index:locator" href="#calibre_link-870" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">flavors (of object type)</span>, <a data-type="index:locator" href="#calibre_link-871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Three Flavors of Object Type</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Float</span>, <a data-type="index:locator" href="#calibre_link-872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other numeric types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">flow control</span>, <a data-type="index:locator" href="#calibre_link-873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a>-<a data-type="index:locator" href="#calibre_link-874" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">folder-linked group</span>, <a data-type="index:locator" href="#calibre_link-875" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Groups</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">renaming</span>, <a data-type="index:locator" href="#calibre_link-876" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">folders in an Xcode project</span>, <a data-type="index:locator" href="#calibre_link-877" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Contents of the Project Folder</a>, <a data-type="index:locator" href="#calibre_link-878" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in the Project navigator</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">folding, code</span>, <a data-type="index:locator" href="#calibre_link-879" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Display</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">font</span>, <a data-type="index:locator" href="#calibre_link-880" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">for</span>, <a data-type="index:locator" href="#calibre_link-881" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">for case</span>, <a data-type="index:locator" href="#calibre_link-882" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">for...in</span>, <a data-type="index:locator" href="#calibre_link-883" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">forced unwrap operator</span>, <a data-type="index:locator" href="#calibre_link-884" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unwrapping an Optional</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">forEach</span>, <a data-type="index:locator" href="#calibre_link-885" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">format string</span>, <a data-type="index:locator" href="#calibre_link-886" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Foundation framework</span>, <a data-type="index:locator" href="#calibre_link-887" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a>, <a data-type="index:locator" href="#calibre_link-888" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">frameworks</span>, <a data-type="index:locator" href="#calibre_link-889" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a>, <a data-type="index:locator" href="#calibre_link-890" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-891" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">embedded</span>, <a data-type="index:locator" href="#calibre_link-892" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">linking</span>, <a data-type="index:locator" href="#calibre_link-893" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift</span>, <a data-type="index:locator" href="#calibre_link-894" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">function builders</span>, <a data-type="index:locator" href="#calibre_link-895" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Builders</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">function in function</span>, <a data-type="index:locator" href="#calibre_link-896" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function in Function</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">functional events</span>, <a data-type="index:locator" href="#calibre_link-897" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reasons for Events</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">functions</span>, <a data-type="index:locator" href="#calibre_link-898" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>, <a data-type="index:locator" href="#calibre_link-899" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>-<a data-type="index:locator" href="#calibre_link-900" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">anonymous</span>, <a data-type="index:locator" href="#calibre_link-901" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-902" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">throws</span>, <a data-type="index:locator" href="#calibre_link-903" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">body</span>, <a data-type="index:locator" href="#calibre_link-904" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">C blocks</span>, <a data-type="index:locator" href="#calibre_link-905" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Blocks</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">C functions</span>, <a data-type="index:locator" href="#calibre_link-906" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">calling</span>, <a data-type="index:locator" href="#calibre_link-907" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>, <a data-type="index:locator" href="#calibre_link-908" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">closures</span>, <a data-type="index:locator" href="#calibre_link-909" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Closures</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">curried</span>, <a data-type="index:locator" href="#calibre_link-910" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Curried Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-911" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>, <a data-type="index:locator" href="#calibre_link-912" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">default parameter values</span>, <a data-type="index:locator" href="#calibre_link-913" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Default Parameter Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">define-and-call</span>, <a data-type="index:locator" href="#calibre_link-914" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Define-and-Call</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">external parameter names</span>, <a data-type="index:locator" href="#calibre_link-915" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic</span>, <a data-type="index:locator" href="#calibre_link-916" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">global</span>, <a data-type="index:locator" href="#calibre_link-917" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-918" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">C, overshadowed</span>, <a data-type="index:locator" href="#calibre_link-919" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">class method instead</span>, <a data-type="index:locator" href="#calibre_link-920" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">ignored parameters</span>, <a data-type="index:locator" href="#calibre_link-921" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ignored Parameters</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">internal parameter names</span>, <a data-type="index:locator" href="#calibre_link-922" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">local</span>, <a data-type="index:locator" href="#calibre_link-923" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function in Function</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mathematical</span>, <a data-type="index:locator" href="#calibre_link-924" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">modifiable parameters</span>, <a data-type="index:locator" href="#calibre_link-925" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modifiable Parameters</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overloading</span>, <a data-type="index:locator" href="#calibre_link-926" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overloading</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">recursion</span>, <a data-type="index:locator" href="#calibre_link-927" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Recursion</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">reference</span>, <a data-type="index:locator" href="#calibre_link-928" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function References and Selectors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">result</span>, <a data-type="index:locator" href="#calibre_link-929" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">ignoring</span>, <a data-type="index:locator" href="#calibre_link-930" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">rethrows</span>, <a data-type="index:locator" href="#calibre_link-931" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">return value</span>, <a data-type="index:locator" href="#calibre_link-932" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">returned from function</span>, <a data-type="index:locator" href="#calibre_link-933" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Returning Function</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">signature</span>, <a data-type="index:locator" href="#calibre_link-934" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Signature</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">throws</span>, <a data-type="index:locator" href="#calibre_link-935" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">calling</span>, <a data-type="index:locator" href="#calibre_link-936" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">trailing</span>, <a data-type="index:locator" href="#calibre_link-937" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type</span>, <a data-type="index:locator" href="#calibre_link-938" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">values</span>, <a data-type="index:locator" href="#calibre_link-939" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variadic parameters</span>, <a data-type="index:locator" href="#calibre_link-940" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a></li>
</ul></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">G</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">garbage collection</span>, <a data-type="index:locator" href="#calibre_link-941" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">gauges</span>, <a data-type="index:locator" href="#calibre_link-942" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-943" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Profiling</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">generated interface header</span>, <a data-type="index:locator" href="#calibre_link-944" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">generic pointer</span>, <a data-type="index:locator" href="#calibre_link-945" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">generics</span>, <a data-type="index:locator" href="#calibre_link-946" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a>-<a data-type="index:locator" href="#calibre_link-947" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">adopting protocol conditionally</span>, <a data-type="index:locator" href="#calibre_link-948" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">associated type chains</span>, <a data-type="index:locator" href="#calibre_link-949" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Type Chains</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">classes, subclassing</span>, <a data-type="index:locator" href="#calibre_link-950" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-951" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">explicit specialization</span>, <a data-type="index:locator" href="#calibre_link-952" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-953" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">functions</span>, <a data-type="index:locator" href="#calibre_link-954" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">object types</span>, <a data-type="index:locator" href="#calibre_link-955" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">polymorphism</span>, <a data-type="index:locator" href="#calibre_link-956" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Invariance</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-957" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">constraining associated type</span>, <a data-type="index:locator" href="#calibre_link-958" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">resolution</span>, <a data-type="index:locator" href="#calibre_link-959" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">contradictory</span>, <a data-type="index:locator" href="#calibre_link-960" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Contradictory Resolution is Impossible</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">explicit</span>, <a data-type="index:locator" href="#calibre_link-961" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">reverse</span>, <a data-type="index:locator" href="#calibre_link-962" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">specialization</span>, <a data-type="index:locator" href="#calibre_link-963" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> generics, resolution)</li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type constraints</span>, <a data-type="index:locator" href="#calibre_link-964" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-965" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">multiple</span>, <a data-type="index:locator" href="#calibre_link-966" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type, telling compiler</span>, <a data-type="index:locator" href="#calibre_link-967" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">where clauses</span>, <a data-type="index:locator" href="#calibre_link-968" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-969" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
</ul></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">getter</span>, <a data-type="index:locator" href="#calibre_link-970" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a>, <a data-type="index:locator" href="#calibre_link-971" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">git</span>, <a data-type="index:locator" href="#calibre_link-972" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">GitHub</span>, <a data-type="index:locator" href="#calibre_link-973" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">GitLab</span>, <a data-type="index:locator" href="#calibre_link-974" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">global constants</span>, <a data-type="index:locator" href="#calibre_link-975" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">global functions</span>, <a data-type="index:locator" href="#calibre_link-976" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-977" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">C, overshadowed by instance methods</span>, <a data-type="index:locator" href="#calibre_link-978" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">class method instead</span>, <a data-type="index:locator" href="#calibre_link-979" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">global variables</span>, <a data-type="index:locator" href="#calibre_link-980" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-981" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-982" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">globally visible instances</span>, <a data-type="index:locator" href="#calibre_link-983" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global Visibility</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">golden rule of memory management</span>, <a data-type="index:locator" href="#calibre_link-984" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">groups</span>, <a data-type="index:locator" href="#calibre_link-985" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-986" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Groups</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">blue</span>, <a data-type="index:locator" href="#calibre_link-987" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in the Project navigator</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">folder-linked</span>, <a data-type="index:locator" href="#calibre_link-988" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Groups</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">renaming</span>, <a data-type="index:locator" href="#calibre_link-989" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">guard</span>, <a data-type="index:locator" href="#calibre_link-990" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">guard case</span>, <a data-type="index:locator" href="#calibre_link-991" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">guard let</span>, <a data-type="index:locator" href="#calibre_link-992" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">H</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">hand-tweaking the APIs</span>, <a data-type="index:locator" href="#calibre_link-993" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-994" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Failable initializers</a>, <a data-type="index:locator" href="#calibre_link-995" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">API Markup</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">handlers</span>, <a data-type="index:locator" href="#calibre_link-996" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> functions)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hash</span>, <a data-type="index:locator" href="#calibre_link-997" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hash character</span>, <a data-type="index:locator" href="#calibre_link-998" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hashability</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">of Objective-C objects</span>, <a data-type="index:locator" href="#calibre_link-999" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of Swift objects</span>, <a data-type="index:locator" href="#calibre_link-1000" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Hashable</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Hashable</span>, <a data-type="index:locator" href="#calibre_link-1001" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a>, <a data-type="index:locator" href="#calibre_link-1002" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">synthesizing implementation</span>, <a data-type="index:locator" href="#calibre_link-1003" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Hashable</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Hasher</span>, <a data-type="index:locator" href="#calibre_link-1004" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Hashable</a>, <a data-type="index:locator" href="#calibre_link-1005" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hashValue</span>, <a data-type="index:locator" href="#calibre_link-1006" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Hashable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hasPrefix</span>, <a data-type="index:locator" href="#calibre_link-1007" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hasSuffix</span>, <a data-type="index:locator" href="#calibre_link-1008" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">header files</span>, <a data-type="index:locator" href="#calibre_link-1009" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Header Files</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">bridging</span>, <a data-type="index:locator" href="#calibre_link-1010" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Core Graphics</span>, <a data-type="index:locator" href="#calibre_link-1011" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Swift Uses Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generated interface</span>, <a data-type="index:locator" href="#calibre_link-1012" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">jumping to</span>, <a data-type="index:locator" href="#calibre_link-1013" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Header Files</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1014" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift</span>, <a data-type="index:locator" href="#calibre_link-1015" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a>, <a data-type="index:locator" href="#calibre_link-1016" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Header Files</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">heads-up display</span>, <a data-type="index:locator" href="#calibre_link-1017" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hexadecimal number</span>, <a data-type="index:locator" href="#calibre_link-1018" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Int</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hierarchy of classes</span>, <a data-type="index:locator" href="#calibre_link-1019" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">hierarchy of views</span>, <a data-type="index:locator" href="#calibre_link-1020" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">History inspector</span>, <a data-type="index:locator" href="#calibre_link-1021" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a>, <a data-type="index:locator" href="#calibre_link-1022" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">HUD</span>, <a data-type="index:locator" href="#calibre_link-1023" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">I</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">IBAction</span>, <a data-type="index:locator" href="#calibre_link-1024" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">IBInspectable</span>, <a data-type="index:locator" href="#calibre_link-1025" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">IBOutlet</span>, <a data-type="index:locator" href="#calibre_link-1026" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">weak</span>, <a data-type="index:locator" href="#calibre_link-1027" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Loading and Memory Management</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">icons</span>, <a data-type="index:locator" href="#calibre_link-1028" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a>, <a data-type="index:locator" href="#calibre_link-1029" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Icons in the app</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">marketing</span>, <a data-type="index:locator" href="#calibre_link-1030" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Marketing icon</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">id</span>, <a data-type="index:locator" href="#calibre_link-1031" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Umbrella Types</a>, <a data-type="index:locator" href="#calibre_link-1032" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">identifiers and reserved words</span>, <a data-type="index:locator" href="#calibre_link-1033" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Identity inspector</span>, <a data-type="index:locator" href="#calibre_link-1034" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a>, <a data-type="index:locator" href="#calibre_link-1035" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">identity operator</span>, <a data-type="index:locator" href="#calibre_link-1036" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object identity</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">identity, developer</span>, <a data-type="index:locator" href="#calibre_link-1037" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">if</span>, <a data-type="index:locator" href="#calibre_link-1038" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">If construct</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">if case</span>, <a data-type="index:locator" href="#calibre_link-1039" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">If case</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">if let</span>, <a data-type="index:locator" href="#calibre_link-1040" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">immutable Objective-C classes</span>, <a data-type="index:locator" href="#calibre_link-1041" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">implicit initializer</span>, <a data-type="index:locator" href="#calibre_link-1042" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a>, <a data-type="index:locator" href="#calibre_link-1043" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Initializers</a>, <a data-type="index:locator" href="#calibre_link-1044" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">implicitly unwrapped Optional</span>, <a data-type="index:locator" href="#calibre_link-1045" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly unwrapped Optional</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">import statement</span>, <a data-type="index:locator" href="#calibre_link-1046" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-1047" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">in</span>, <a data-type="index:locator" href="#calibre_link-1048" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">index, enumerate with</span>, <a data-type="index:locator" href="#calibre_link-1049" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a>, <a data-type="index:locator" href="#calibre_link-1050" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a>, <a data-type="index:locator" href="#calibre_link-1051" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">indexing a string</span>, <a data-type="index:locator" href="#calibre_link-1052" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-1053" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">indexing an array</span>, <a data-type="index:locator" href="#calibre_link-1054" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">IndexSet</span>, <a data-type="index:locator" href="#calibre_link-1055" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSIndexSet</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">indices</span>, <a data-type="index:locator" href="#calibre_link-1056" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-1057" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">indirect</span>, <a data-type="index:locator" href="#calibre_link-1058" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Advantages of value types vs. reference types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">inferred variable type</span>, <a data-type="index:locator" href="#calibre_link-1059" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">learning</span>, <a data-type="index:locator" href="#calibre_link-1060" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other numeric types</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Info.plist</span>, <a data-type="index:locator" href="#calibre_link-1061" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a>, <a data-type="index:locator" href="#calibre_link-1062" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a>, <a data-type="index:locator" href="#calibre_link-1063" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> property list settings)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">informal protocols</span>, <a data-type="index:locator" href="#calibre_link-1064" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Informal Protocols</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">inheritance</span>, <a data-type="index:locator" href="#calibre_link-1065" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inheritance</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">init</span>, <a data-type="index:locator" href="#calibre_link-1066" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">with self</span>, <a data-type="index:locator" href="#calibre_link-1067" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegating initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">with super</span>, <a data-type="index:locator" href="#calibre_link-1068" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">with type reference</span>, <a data-type="index:locator" href="#calibre_link-1069" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">init(coder:)</span>, <a data-type="index:locator" href="#calibre_link-1070" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-1071" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-1072" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">conditional</span>, <a data-type="index:locator" href="#calibre_link-1073" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deferred</span>, <a data-type="index:locator" href="#calibre_link-1074" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-1075" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lazy</span>, <a data-type="index:locator" href="#calibre_link-1076" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of enums</span>, <a data-type="index:locator" href="#calibre_link-1077" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of nib-based instances</span>, <a data-type="index:locator" href="#calibre_link-1078" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of Optionals</span>, <a data-type="index:locator" href="#calibre_link-1079" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of properties</span>, <a data-type="index:locator" href="#calibre_link-1080" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a>, <a data-type="index:locator" href="#calibre_link-1081" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property initialization</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-1082" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a>, <a data-type="index:locator" href="#calibre_link-1083" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">class</span>, <a data-type="index:locator" href="#calibre_link-1084" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">convenience</span>, <a data-type="index:locator" href="#calibre_link-1085" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">delegating</span>, <a data-type="index:locator" href="#calibre_link-1086" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegating initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">designated</span>, <a data-type="index:locator" href="#calibre_link-1087" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enum</span>, <a data-type="index:locator" href="#calibre_link-1088" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">failable</span>, <a data-type="index:locator" href="#calibre_link-1089" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Failable initializers</a>, <a data-type="index:locator" href="#calibre_link-1090" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">implicit</span>, <a data-type="index:locator" href="#calibre_link-1091" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">class</span>, <a data-type="index:locator" href="#calibre_link-1092" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enum</span>, <a data-type="index:locator" href="#calibre_link-1093" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">struct</span>, <a data-type="index:locator" href="#calibre_link-1094" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Initializers</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">inheritance</span>, <a data-type="index:locator" href="#calibre_link-1095" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1096" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Initializers and Factories</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overriding</span>, <a data-type="index:locator" href="#calibre_link-1097" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">recursive</span>, <a data-type="index:locator" href="#calibre_link-1098" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegating initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">required</span>, <a data-type="index:locator" href="#calibre_link-1099" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Required initializers</a>, <a data-type="index:locator" href="#calibre_link-1100" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a>, <a data-type="index:locator" href="#calibre_link-1101" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">struct</span>, <a data-type="index:locator" href="#calibre_link-1102" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Initializers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">inout</span>, <a data-type="index:locator" href="#calibre_link-1103" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modifiable Parameters</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">input</span>, <a data-type="index:locator" href="#calibre_link-1104" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">insert</span>, <a data-type="index:locator" href="#calibre_link-1105" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-1106" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">instance</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-1107" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1108" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-1109" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1110" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-1111" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How properties are accessed</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variables, Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1112" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">instances</span>, <a data-type="index:locator" href="#calibre_link-1113" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1114" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>-<a data-type="index:locator" href="#calibre_link-1115" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Keyword self</a>, <a data-type="index:locator" href="#calibre_link-1116" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">copying</span>, <a data-type="index:locator" href="#calibre_link-1117" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instance references are pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">creation</span>, <a data-type="index:locator" href="#calibre_link-1118" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1119" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a>, <a data-type="index:locator" href="#calibre_link-1120" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a>, <a data-type="index:locator" href="#calibre_link-1121" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">getting a reference</span>, <a data-type="index:locator" href="#calibre_link-1122" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility Through an Instance Property</a>, <a data-type="index:locator" href="#calibre_link-1123" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">globally visible</span>, <a data-type="index:locator" href="#calibre_link-1124" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global Visibility</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initial</span>, <a data-type="index:locator" href="#calibre_link-1125" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Entry Point</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lifetime</span>, <a data-type="index:locator" href="#calibre_link-1126" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">literals instead</span>, <a data-type="index:locator" href="#calibre_link-1127" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Literal Convertibles</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">multiple references</span>, <a data-type="index:locator" href="#calibre_link-1128" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instance references are pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutating</span>, <a data-type="index:locator" href="#calibre_link-1129" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reference Type Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-1130" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nib-based</span>, <a data-type="index:locator" href="#calibre_link-1131" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Nib</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1132" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Loading and Memory Management</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">relationships between</span>, <a data-type="index:locator" href="#calibre_link-1133" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility by Relationship</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">state</span>, <a data-type="index:locator" href="#calibre_link-1134" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Instances?</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type</span>, <a data-type="index:locator" href="#calibre_link-1135" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">learning</span>, <a data-type="index:locator" href="#calibre_link-1136" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">telling compiler</span>, <a data-type="index:locator" href="#calibre_link-1137" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Casting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">testing</span>, <a data-type="index:locator" href="#calibre_link-1138" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a></li>
</ul></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">instantiation</span>, <a data-type="index:locator" href="#calibre_link-1139" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1140" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a>, <a data-type="index:locator" href="#calibre_link-1141" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a>, <a data-type="index:locator" href="#calibre_link-1142" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">nib-based</span>, <a data-type="index:locator" href="#calibre_link-1143" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Instruments</span>, <a data-type="index:locator" href="#calibre_link-1144" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Profiling</a>, <a data-type="index:locator" href="#calibre_link-1145" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Int</span>, <a data-type="index:locator" href="#calibre_link-1146" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Int</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Interface Builder</span>, <a data-type="index:locator" href="#calibre_link-1147" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">interface tests</span>, <a data-type="index:locator" href="#calibre_link-1148" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">internal</span>, <a data-type="index:locator" href="#calibre_link-1149" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">internal identity principle</span>, <a data-type="index:locator" href="#calibre_link-1150" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">internal parameter names</span>, <a data-type="index:locator" href="#calibre_link-1151" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">internationalization</span> (<span data-gentext="see" class="publishername">see</span> localization)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">Internet as documentation</span>, <a data-type="index:locator" href="#calibre_link-1152" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Internet Resources</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">interpolation, string</span>, <a data-type="index:locator" href="#calibre_link-1153" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-1154" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">custom</span>, <a data-type="index:locator" href="#calibre_link-1155" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Custom String Interpolation</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">interval operators</span>, <a data-type="index:locator" href="#calibre_link-1156" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">introspection</span>, <a data-type="index:locator" href="#calibre_link-1157" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Introspection</a>, <a data-type="index:locator" href="#calibre_link-1158" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a>, <a data-type="index:locator" href="#calibre_link-1159" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">iOS Deployment Target build setting</span>, <a data-type="index:locator" href="#calibre_link-1160" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Permissible Runtime Environment</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">is</span>, <a data-type="index:locator" href="#calibre_link-1161" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a>, <a data-type="index:locator" href="#calibre_link-1162" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Type Testing and Casting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">isEmpty</span>, <a data-type="index:locator" href="#calibre_link-1163" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-1164" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-1165" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">isEqual</span>, <a data-type="index:locator" href="#calibre_link-1166" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Issue navigator</span>, <a data-type="index:locator" href="#calibre_link-1167" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">issues, live</span>, <a data-type="index:locator" href="#calibre_link-1168" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Fix-it and Live Syntax Checking</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">iteration</span>, <a data-type="index:locator" href="#calibre_link-1169" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">iTunes Connect</span> (<span data-gentext="see" class="publishername">see</span> App Store Connect)</li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">J</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">joined</span>, <a data-type="index:locator" href="#calibre_link-1170" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-1171" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">JSON</span>, <a data-type="index:locator" href="#calibre_link-1172" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">jump bar</span>, <a data-type="index:locator" href="#calibre_link-1173" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Editor</a>, <a data-type="index:locator" href="#calibre_link-1174" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Debug pane</span>, <a data-type="index:locator" href="#calibre_link-1175" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">documentation</span>, <a data-type="index:locator" href="#calibre_link-1176" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Documentation Pages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">injecting comments</span>, <a data-type="index:locator" href="#calibre_link-1177" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nib editor</span>, <a data-type="index:locator" href="#calibre_link-1178" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Related Items menu</span>, <a data-type="index:locator" href="#calibre_link-1179" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Editor</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">jumping</span>, <a data-type="index:locator" href="#calibre_link-1180" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Jumping</a>-<a data-type="index:locator" href="#calibre_link-1181" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">jumping (navigating)</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">to declaration</span>, <a data-type="index:locator" href="#calibre_link-1182" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Symbol Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">to header files</span>, <a data-type="index:locator" href="#calibre_link-1183" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Header Files</a></li>
</ul></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">K</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">Key Bindings preferences</span>, <a data-type="index:locator" href="#calibre_link-1184" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Project Window</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">key paths</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Cocoa</span>, <a data-type="index:locator" href="#calibre_link-1185" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Key Paths</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift</span>, <a data-type="index:locator" href="#calibre_link-1186" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key Paths</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">keyboard shortcuts in Xcode</span>, <a data-type="index:locator" href="#calibre_link-1187" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Project Window</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">keys (dictionary)</span>, <a data-type="index:locator" href="#calibre_link-1188" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">key&ndash;value coding</span>, <a data-type="index:locator" href="#calibre_link-1189" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">key&ndash;value observing</span>, <a data-type="index:locator" href="#calibre_link-1190" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Published instead</span>, <a data-type="index:locator" href="#calibre_link-1191" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-1192" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">KVO Observers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">key&ndash;value pairs</span>, <a data-type="index:locator" href="#calibre_link-1193" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">KVC</span>, <a data-type="index:locator" href="#calibre_link-1194" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Coding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">KVO</span>, <a data-type="index:locator" href="#calibre_link-1195" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">L</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">labels</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">flow control</span>, <a data-type="index:locator" href="#calibre_link-1196" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">function call</span>, <a data-type="index:locator" href="#calibre_link-1197" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nib editor</span>, <a data-type="index:locator" href="#calibre_link-1198" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">changed by outlet</span>, <a data-type="index:locator" href="#calibre_link-1199" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">tuples</span>, <a data-type="index:locator" href="#calibre_link-1200" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">labels in function calls</span>, <a data-type="index:locator" href="#calibre_link-1201" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> external parameter names)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">last</span>, <a data-type="index:locator" href="#calibre_link-1202" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-1203" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lastIndex</span>, <a data-type="index:locator" href="#calibre_link-1204" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-1205" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">launch images</span>, <a data-type="index:locator" href="#calibre_link-1206" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Launch images</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">launch nib</span>, <a data-type="index:locator" href="#calibre_link-1207" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Launch images</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">launch process of an app</span>, <a data-type="index:locator" href="#calibre_link-1208" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The App Launch Process</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">layer, configuring in the nib</span>, <a data-type="index:locator" href="#calibre_link-1209" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lazy initialization</span>, <a data-type="index:locator" href="#calibre_link-1210" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">instance properties</span>, <a data-type="index:locator" href="#calibre_link-1211" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property initialization</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lazy loading of views</span>, <a data-type="index:locator" href="#calibre_link-1212" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Main View</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lazy sequence</span>, <a data-type="index:locator" href="#calibre_link-1213" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Leaks instrument</span>, <a data-type="index:locator" href="#calibre_link-1214" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instruments</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">leaks, memory</span>, <a data-type="index:locator" href="#calibre_link-1215" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a>, <a data-type="index:locator" href="#calibre_link-1216" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Gauges</a>, <a data-type="index:locator" href="#calibre_link-1217" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a>, <a data-type="index:locator" href="#calibre_link-1218" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a>, <a data-type="index:locator" href="#calibre_link-1219" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">let</span>, <a data-type="index:locator" href="#calibre_link-1220" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-1221" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a>, <a data-type="index:locator" href="#calibre_link-1222" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Library</span>, <a data-type="index:locator" href="#calibre_link-1223" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Canvas</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">library</span>, <a data-type="index:locator" href="#calibre_link-1224" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lifetime</span>, <a data-type="index:locator" href="#calibre_link-1225" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-1226" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Scope and Lifetime</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> scope)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lifetime events</span>, <a data-type="index:locator" href="#calibre_link-1227" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reasons for Events</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lightweight generics</span>, <a data-type="index:locator" href="#calibre_link-1228" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-1229" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lightweight generics</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">line</span>, <a data-type="index:locator" href="#calibre_link-1230" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">linking</span>, <a data-type="index:locator" href="#calibre_link-1231" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">literals</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">array</span>, <a data-type="index:locator" href="#calibre_link-1232" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dictionary</span>, <a data-type="index:locator" href="#calibre_link-1233" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">logging</span>, <a data-type="index:locator" href="#calibre_link-1234" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">numeric</span>, <a data-type="index:locator" href="#calibre_link-1235" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Int</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">string</span>, <a data-type="index:locator" href="#calibre_link-1236" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">multiline</span>, <a data-type="index:locator" href="#calibre_link-1237" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">raw</span>, <a data-type="index:locator" href="#calibre_link-1238" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">where instance expected</span>, <a data-type="index:locator" href="#calibre_link-1239" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Literal Convertibles</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">live issues</span>, <a data-type="index:locator" href="#calibre_link-1240" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Fix-it and Live Syntax Checking</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">LLDB</span>, <a data-type="index:locator" href="#calibre_link-1241" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">loading a nib</span>, <a data-type="index:locator" href="#calibre_link-1242" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a>, <a data-type="index:locator" href="#calibre_link-1243" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Nib</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">local variables</span>, <a data-type="index:locator" href="#calibre_link-1244" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Locale</span>, <a data-type="index:locator" href="#calibre_link-1245" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">localization</span>, <a data-type="index:locator" href="#calibre_link-1246" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Localization</a>-<a data-type="index:locator" href="#calibre_link-1247" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing Localization</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">LocalizedError</span>, <a data-type="index:locator" href="#calibre_link-1248" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">logging</span>, <a data-type="index:locator" href="#calibre_link-1249" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">logical operators</span>, <a data-type="index:locator" href="#calibre_link-1250" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">looping</span>, <a data-type="index:locator" href="#calibre_link-1251" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Flow Control</a>, <a data-type="index:locator" href="#calibre_link-1252" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loops</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">shortcircuiting</span>, <a data-type="index:locator" href="#calibre_link-1253" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">lowercased</span>, <a data-type="index:locator" href="#calibre_link-1254" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">M</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">main function</span>, <a data-type="index:locator" href="#calibre_link-1255" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Entry Point</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">main storyboard</span>, <a data-type="index:locator" href="#calibre_link-1256" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a>, <a data-type="index:locator" href="#calibre_link-1257" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">app without</span>, <a data-type="index:locator" href="#calibre_link-1258" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">App Without a Storyboard</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">main view of view controller</span>, <a data-type="index:locator" href="#calibre_link-1259" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">loaded from nib</span>, <a data-type="index:locator" href="#calibre_link-1260" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Main View</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">main.swift file</span>, <a data-type="index:locator" href="#calibre_link-1261" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Functions</a>, <a data-type="index:locator" href="#calibre_link-1262" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Entry Point</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">mangling, name</span>, <a data-type="index:locator" href="#calibre_link-1263" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">map</span>, <a data-type="index:locator" href="#calibre_link-1264" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional map and flatMap</a>, <a data-type="index:locator" href="#calibre_link-1265" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">mapValues</span>, <a data-type="index:locator" href="#calibre_link-1266" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">MARK comments</span>, <a data-type="index:locator" href="#calibre_link-1267" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Markdown</span>, <a data-type="index:locator" href="#calibre_link-1268" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Quick Help</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">marketing icon</span>, <a data-type="index:locator" href="#calibre_link-1269" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Marketing icon</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">math functions</span>, <a data-type="index:locator" href="#calibre_link-1270" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">max</span>, <a data-type="index:locator" href="#calibre_link-1271" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Measurement</span>, <a data-type="index:locator" href="#calibre_link-1272" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSMeasurement and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">MeasurementFormatter</span>, <a data-type="index:locator" href="#calibre_link-1273" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSMeasurement and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Media library</span>, <a data-type="index:locator" href="#calibre_link-1274" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">member center</span>, <a data-type="index:locator" href="#calibre_link-1275" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">members</span>, <a data-type="index:locator" href="#calibre_link-1276" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Members</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">memberwise initializer</span>, <a data-type="index:locator" href="#calibre_link-1277" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">memory graph</span>, <a data-type="index:locator" href="#calibre_link-1278" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">memory leaks</span>, <a data-type="index:locator" href="#calibre_link-1279" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a>, <a data-type="index:locator" href="#calibre_link-1280" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Gauges</a>, <a data-type="index:locator" href="#calibre_link-1281" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a>, <a data-type="index:locator" href="#calibre_link-1282" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a>, <a data-type="index:locator" href="#calibre_link-1283" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1284" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management</a>-<a data-type="index:locator" href="#calibre_link-1285" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a>, <a data-type="index:locator" href="#calibre_link-1286" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management</a>-<a data-type="index:locator" href="#calibre_link-1287" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">anonymous functions</span>, <a data-type="index:locator" href="#calibre_link-1288" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">ARC</span>, <a data-type="index:locator" href="#calibre_link-1289" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">What ARC Is and What It Does</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">autorelease pool</span>, <a data-type="index:locator" href="#calibre_link-1290" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autorelease Pool</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">CFTypeRefs</span>, <a data-type="index:locator" href="#calibre_link-1291" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of CFTypeRefs</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">collections</span>, <a data-type="index:locator" href="#calibre_link-1292" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Cocoa Objects Manage Memory</a>, <a data-type="index:locator" href="#calibre_link-1293" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dangling pointers</span>, <a data-type="index:locator" href="#calibre_link-1294" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">debugging</span>, <a data-type="index:locator" href="#calibre_link-1295" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">delegates</span>, <a data-type="index:locator" href="#calibre_link-1296" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">golden rule</span>, <a data-type="index:locator" href="#calibre_link-1297" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">graph</span>, <a data-type="index:locator" href="#calibre_link-1298" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">key&ndash;value observing</span>, <a data-type="index:locator" href="#calibre_link-1299" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">KVO Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">leaks</span>, <a data-type="index:locator" href="#calibre_link-1300" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a>, <a data-type="index:locator" href="#calibre_link-1301" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a>, <a data-type="index:locator" href="#calibre_link-1302" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutable Objective-C classes</span>, <a data-type="index:locator" href="#calibre_link-1303" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Memory Management Policies</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nib-loaded objects</span>, <a data-type="index:locator" href="#calibre_link-1304" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Loading and Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nilifying unsafe references</span>, <a data-type="index:locator" href="#calibre_link-1305" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">notifications</span>, <a data-type="index:locator" href="#calibre_link-1306" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">ownership</span>, <a data-type="index:locator" href="#calibre_link-1307" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-1308" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Instance Properties</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1309" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Memory Management Policies</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocol references</span>, <a data-type="index:locator" href="#calibre_link-1310" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory management of protocol-typed references</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-1311" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a>, <a data-type="index:locator" href="#calibre_link-1312" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">retains, unusual</span>, <a data-type="index:locator" href="#calibre_link-1313" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">timers</span>, <a data-type="index:locator" href="#calibre_link-1314" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Timers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Unmanaged</span>, <a data-type="index:locator" href="#calibre_link-1315" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of CFTypeRefs</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unowned references</span>, <a data-type="index:locator" href="#calibre_link-1316" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unowned references</a>, <a data-type="index:locator" href="#calibre_link-1317" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unsafe references</span>, <a data-type="index:locator" href="#calibre_link-1318" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">UnsafePointer</span>, <a data-type="index:locator" href="#calibre_link-1319" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Arrays</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">weak references</span>, <a data-type="index:locator" href="#calibre_link-1320" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Weak references</a>, <a data-type="index:locator" href="#calibre_link-1321" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">merging dictionaries</span>, <a data-type="index:locator" href="#calibre_link-1322" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic dictionary properties and enumeration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">messages</span>, <a data-type="index:locator" href="#calibre_link-1323" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Everything Is an Object?</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">sending optionally</span>, <a data-type="index:locator" href="#calibre_link-1324" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional members</a>, <a data-type="index:locator" href="#calibre_link-1325" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">to Optionals</span>, <a data-type="index:locator" href="#calibre_link-1326" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">to self</span>, <a data-type="index:locator" href="#calibre_link-1327" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Keyword self</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">metatype</span>, <a data-type="index:locator" href="#calibre_link-1328" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type as Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-1329" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Members</a>, <a data-type="index:locator" href="#calibre_link-1330" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> functions)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">class</span>, <a data-type="index:locator" href="#calibre_link-1331" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dynamic</span>, <a data-type="index:locator" href="#calibre_link-1332" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dynamic Membership</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enums</span>, <a data-type="index:locator" href="#calibre_link-1333" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">external parameter names</span>, <a data-type="index:locator" href="#calibre_link-1334" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">inheritance</span>, <a data-type="index:locator" href="#calibre_link-1335" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inheritance</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">instance</span>, <a data-type="index:locator" href="#calibre_link-1336" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1337" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">secret life</span>, <a data-type="index:locator" href="#calibre_link-1338" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutating</span>, <a data-type="index:locator" href="#calibre_link-1339" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a>, <a data-type="index:locator" href="#calibre_link-1340" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a>, <a data-type="index:locator" href="#calibre_link-1341" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1342" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting type name</span>, <a data-type="index:locator" href="#calibre_link-1343" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">optional</span>, <a data-type="index:locator" href="#calibre_link-1344" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a>, <a data-type="index:locator" href="#calibre_link-1345" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overriding</span>, <a data-type="index:locator" href="#calibre_link-1346" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-1347" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">polymorphism and</span>, <a data-type="index:locator" href="#calibre_link-1348" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">preventing</span>, <a data-type="index:locator" href="#calibre_link-1349" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a>, <a data-type="index:locator" href="#calibre_link-1350" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">selectors</span>, <a data-type="index:locator" href="#calibre_link-1351" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">static</span>, <a data-type="index:locator" href="#calibre_link-1352" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">vs. class</span>, <a data-type="index:locator" href="#calibre_link-1353" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static methods vs. class methods</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">structs</span>, <a data-type="index:locator" href="#calibre_link-1354" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">min</span>, <a data-type="index:locator" href="#calibre_link-1355" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">minimap</span>, <a data-type="index:locator" href="#calibre_link-1356" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Mirror</span>, <a data-type="index:locator" href="#calibre_link-1357" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Introspection</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">modifiers</span>, <a data-type="index:locator" href="#calibre_link-1358" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">modules</span>, <a data-type="index:locator" href="#calibre_link-1359" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-1360" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a>, <a data-type="index:locator" href="#calibre_link-1361" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">privacy</span>, <a data-type="index:locator" href="#calibre_link-1362" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">multiple selection</span>, <a data-type="index:locator" href="#calibre_link-1363" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Multiple Selection</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">mutable Objective-C classes</span>, <a data-type="index:locator" href="#calibre_link-1364" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">NSCopying</span>, <a data-type="index:locator" href="#calibre_link-1365" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Memory Management Policies</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">mutating an instance</span>, <a data-type="index:locator" href="#calibre_link-1366" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reference Type Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-1367" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">mutating methods</span>, <a data-type="index:locator" href="#calibre_link-1368" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a>, <a data-type="index:locator" href="#calibre_link-1369" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a>, <a data-type="index:locator" href="#calibre_link-1370" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">N</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">name mangling</span>, <a data-type="index:locator" href="#calibre_link-1371" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">name of app</span>, <a data-type="index:locator" href="#calibre_link-1372" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a>, <a data-type="index:locator" href="#calibre_link-1373" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">localizing</span>, <a data-type="index:locator" href="#calibre_link-1374" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">names of accessors</span>, <a data-type="index:locator" href="#calibre_link-1375" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">changing</span>, <a data-type="index:locator" href="#calibre_link-1376" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Accessors</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">namespaces</span>, <a data-type="index:locator" href="#calibre_link-1377" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Namespaces</a>, <a data-type="index:locator" href="#calibre_link-1378" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested Object Types</a>, <a data-type="index:locator" href="#calibre_link-1379" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a>, <a data-type="index:locator" href="#calibre_link-1380" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1381" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">navigating your code</span>, <a data-type="index:locator" href="#calibre_link-1382" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Navigator pane</span>, <a data-type="index:locator" href="#calibre_link-1383" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nested arrays</span>, <a data-type="index:locator" href="#calibre_link-1384" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested arrays</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nested scopes</span>, <a data-type="index:locator" href="#calibre_link-1385" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested scopes</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nested types</span>, <a data-type="index:locator" href="#calibre_link-1386" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Namespaces</a>, <a data-type="index:locator" href="#calibre_link-1387" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a>, <a data-type="index:locator" href="#calibre_link-1388" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested Object Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Never</span>, <a data-type="index:locator" href="#calibre_link-1389" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Aborting the whole program</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NeXTStep</span>, <a data-type="index:locator" href="#calibre_link-1390" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nib editor</span>, <a data-type="index:locator" href="#calibre_link-1391" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nib files</span>, <a data-type="index:locator" href="#calibre_link-1392" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a>, <a data-type="index:locator" href="#calibre_link-1393" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a>-<a data-type="index:locator" href="#calibre_link-1394" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">dependent on device type</span>, <a data-type="index:locator" href="#calibre_link-1395" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">launch</span>, <a data-type="index:locator" href="#calibre_link-1396" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Launch images</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">loading</span>, <a data-type="index:locator" href="#calibre_link-1397" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Nib</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">localizing</span>, <a data-type="index:locator" href="#calibre_link-1398" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Creating Localized Content</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nib objects</span>, <a data-type="index:locator" href="#calibre_link-1399" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nib owner</span>, <a data-type="index:locator" href="#calibre_link-1400" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nib-based instantiation</span>, <a data-type="index:locator" href="#calibre_link-1401" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a>, <a data-type="index:locator" href="#calibre_link-1402" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Loading and Memory Management</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nib-loading mechanism</span>, <a data-type="index:locator" href="#calibre_link-1403" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Nib</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nibs</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">connections between</span>, <a data-type="index:locator" href="#calibre_link-1404" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Connections Between Nibs &mdash; Not!</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nil</span>, <a data-type="index:locator" href="#calibre_link-1405" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">in Objective-C collections</span>, <a data-type="index:locator" href="#calibre_link-1406" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNull</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">signaling failure</span>, <a data-type="index:locator" href="#calibre_link-1407" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">signaling no data</span>, <a data-type="index:locator" href="#calibre_link-1408" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-1409" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unwrapping</span>, <a data-type="index:locator" href="#calibre_link-1410" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nil-coalescing operator</span>, <a data-type="index:locator" href="#calibre_link-1411" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nil-targeted actions</span>, <a data-type="index:locator" href="#calibre_link-1412" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nil-Targeted Actions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nilifying unsafe references</span>, <a data-type="index:locator" href="#calibre_link-1413" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nonnull</span>, <a data-type="index:locator" href="#calibre_link-1414" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nullability</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nonobjc</span>, <a data-type="index:locator" href="#calibre_link-1415" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Notification</span>, <a data-type="index:locator" href="#calibre_link-1416" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Notification.Name</span>, <a data-type="index:locator" href="#calibre_link-1417" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">forming from string</span>, <a data-type="index:locator" href="#calibre_link-1418" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Posting a Notification</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NotificationCenter</span>, <a data-type="index:locator" href="#calibre_link-1419" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">notifications</span>, <a data-type="index:locator" href="#calibre_link-1420" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Combine framework</span>, <a data-type="index:locator" href="#calibre_link-1421" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">posting</span>, <a data-type="index:locator" href="#calibre_link-1422" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Posting a Notification</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">registering</span>, <a data-type="index:locator" href="#calibre_link-1423" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Receiving a Notification</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-1424" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unregistering</span>, <a data-type="index:locator" href="#calibre_link-1425" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unregistering</a>, <a data-type="index:locator" href="#calibre_link-1426" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">when appropriate</span>, <a data-type="index:locator" href="#calibre_link-1427" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Posting a Notification</a>, <a data-type="index:locator" href="#calibre_link-1428" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications and Key&ndash;Value Observing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSArray</span>, <a data-type="index:locator" href="#calibre_link-1429" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-1430" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSAttributedString</span>, <a data-type="index:locator" href="#calibre_link-1431" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSCoder</span>, <a data-type="index:locator" href="#calibre_link-1432" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSCoding</span>, <a data-type="index:locator" href="#calibre_link-1433" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSCopying</span>, <a data-type="index:locator" href="#calibre_link-1434" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a>, <a data-type="index:locator" href="#calibre_link-1435" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Memory Management Policies</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSCountedSet</span>, <a data-type="index:locator" href="#calibre_link-1436" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSDecimalNumber</span>, <a data-type="index:locator" href="#calibre_link-1437" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSDictionary</span>, <a data-type="index:locator" href="#calibre_link-1438" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Dictionary and Objective-C NSDictionary</a>, <a data-type="index:locator" href="#calibre_link-1439" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDictionary and NSMutableDictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSError</span>, <a data-type="index:locator" href="#calibre_link-1440" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSErrorPointer</span>, <a data-type="index:locator" href="#calibre_link-1441" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSHashTable</span>, <a data-type="index:locator" href="#calibre_link-1442" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSKeyedArchiver</span>, <a data-type="index:locator" href="#calibre_link-1443" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSData</a>, <a data-type="index:locator" href="#calibre_link-1444" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSLog</span>, <a data-type="index:locator" href="#calibre_link-1445" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSMapTable</span>, <a data-type="index:locator" href="#calibre_link-1446" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSMutableArray</span>, <a data-type="index:locator" href="#calibre_link-1447" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-1448" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSMutableDictionary</span>, <a data-type="index:locator" href="#calibre_link-1449" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Dictionary and Objective-C NSDictionary</a>, <a data-type="index:locator" href="#calibre_link-1450" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDictionary and NSMutableDictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSMutableOrderedSet</span>, <a data-type="index:locator" href="#calibre_link-1451" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSMutableSet</span>, <a data-type="index:locator" href="#calibre_link-1452" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSMutableString</span>, <a data-type="index:locator" href="#calibre_link-1453" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSNotFound</span>, <a data-type="index:locator" href="#calibre_link-1454" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNotFound</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSNull</span>, <a data-type="index:locator" href="#calibre_link-1455" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNull</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSNumber</span>, <a data-type="index:locator" href="#calibre_link-1456" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSObject</span>, <a data-type="index:locator" href="#calibre_link-1457" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a>, <a data-type="index:locator" href="#calibre_link-1458" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Secret Life of NSObject</a>-<a data-type="index:locator" href="#calibre_link-1459" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Secret Life of NSObject</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">comparison</span>, <a data-type="index:locator" href="#calibre_link-1460" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-1461" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">hashability</span>, <a data-type="index:locator" href="#calibre_link-1462" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSObjectProtocol</span>, <a data-type="index:locator" href="#calibre_link-1463" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Secret Life of NSObject</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSOrderedSet</span>, <a data-type="index:locator" href="#calibre_link-1464" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSPointerArray</span>, <a data-type="index:locator" href="#calibre_link-1465" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSRange</span>, <a data-type="index:locator" href="#calibre_link-1466" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSRange</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSRegularExpression</span>, <a data-type="index:locator" href="#calibre_link-1467" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSSet</span>, <a data-type="index:locator" href="#calibre_link-1468" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSString</span>, <a data-type="index:locator" href="#calibre_link-1469" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-1470" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NSValue</span>, <a data-type="index:locator" href="#calibre_link-1471" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NS_ENUM</span>, <a data-type="index:locator" href="#calibre_link-1472" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_ENUM</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">NS_OPTIONS</span>, <a data-type="index:locator" href="#calibre_link-1473" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_OPTIONS</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">nullable</span>, <a data-type="index:locator" href="#calibre_link-1474" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nullability</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">numeric literals</span>, <a data-type="index:locator" href="#calibre_link-1475" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Int</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">numeric types, C</span>, <a data-type="index:locator" href="#calibre_link-1476" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other numeric types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">numeric types, Swift</span>, <a data-type="index:locator" href="#calibre_link-1477" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Numbers</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">O</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">objc</span>, <a data-type="index:locator" href="#calibre_link-1478" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a>, <a data-type="index:locator" href="#calibre_link-1479" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a>, <a data-type="index:locator" href="#calibre_link-1480" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Suppressing type checking</a>, <a data-type="index:locator" href="#calibre_link-1481" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Private and Fileprivate</a>, <a data-type="index:locator" href="#calibre_link-1482" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory management of protocol-typed references</a>, <a data-type="index:locator" href="#calibre_link-1483" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Accessors</a>, <a data-type="index:locator" href="#calibre_link-1484" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_ENUM</a>, <a data-type="index:locator" href="#calibre_link-1485" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">objcMembers</span>, <a data-type="index:locator" href="#calibre_link-1486" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">object types</span>, <a data-type="index:locator" href="#calibre_link-1487" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Types</a>-<a data-type="index:locator" href="#calibre_link-1488" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">comparison</span>, <a data-type="index:locator" href="#calibre_link-1489" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparing Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-1490" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">definition over multiple files</span>, <a data-type="index:locator" href="#calibre_link-1491" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-1492" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">flavors</span>, <a data-type="index:locator" href="#calibre_link-1493" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Three Flavors of Object Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic</span>, <a data-type="index:locator" href="#calibre_link-1494" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-1495" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-1496" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-1497" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nested</span>, <a data-type="index:locator" href="#calibre_link-1498" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested Object Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1499" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and Swift Objects</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">passing or assigning</span>, <a data-type="index:locator" href="#calibre_link-1500" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type as Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">polymorphism</span>, <a data-type="index:locator" href="#calibre_link-1501" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">printing</span>, <a data-type="index:locator" href="#calibre_link-1502" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-1503" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">reference vs. value</span>, <a data-type="index:locator" href="#calibre_link-1504" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Value Types and Reference Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">references to</span>, <a data-type="index:locator" href="#calibre_link-1505" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1506" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">scope</span>, <a data-type="index:locator" href="#calibre_link-1507" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-1508" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">umbrella types</span>, <a data-type="index:locator" href="#calibre_link-1509" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Umbrella Types</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1510" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C, Objective-C, and Swift</a>-<a data-type="index:locator" href="#calibre_link-1511" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lightweight generics</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> bridged types)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">accessors</span>, <a data-type="index:locator" href="#calibre_link-1512" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Properties</a>, <a data-type="index:locator" href="#calibre_link-1513" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">categories</span>, <a data-type="index:locator" href="#calibre_link-1514" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Categories and Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">collections</span>, <a data-type="index:locator" href="#calibre_link-1515" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSIndexSet</a>-<a data-type="index:locator" href="#calibre_link-1516" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a>, <a data-type="index:locator" href="#calibre_link-1517" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lightweight generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">comparison</span>, <a data-type="index:locator" href="#calibre_link-1518" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-1519" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">factory methods</span>, <a data-type="index:locator" href="#calibre_link-1520" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Initializers and Factories</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">hashability</span>, <a data-type="index:locator" href="#calibre_link-1521" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">header files</span>, <a data-type="index:locator" href="#calibre_link-1522" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">id</span>, <a data-type="index:locator" href="#calibre_link-1523" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Umbrella Types</a>, <a data-type="index:locator" href="#calibre_link-1524" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">immutable vs. mutable classes</span>, <a data-type="index:locator" href="#calibre_link-1525" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Immutable and Mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-1526" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Initializers and Factories</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">instance variables</span>, <a data-type="index:locator" href="#calibre_link-1527" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lightweight generics</span>, <a data-type="index:locator" href="#calibre_link-1528" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Array and Objective-C NSArray</a>, <a data-type="index:locator" href="#calibre_link-1529" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lightweight generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-1530" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Methods</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">internal parameter names</span>, <a data-type="index:locator" href="#calibre_link-1531" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Internal parameter names</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overloading</span>, <a data-type="index:locator" href="#calibre_link-1532" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overloading</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">renamification</span>, <a data-type="index:locator" href="#calibre_link-1533" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renamification</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variadic parameters</span>, <a data-type="index:locator" href="#calibre_link-1534" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadics</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">namespaces</span>, <a data-type="index:locator" href="#calibre_link-1535" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">object references</span>, <a data-type="index:locator" href="#calibre_link-1536" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">object types</span>, <a data-type="index:locator" href="#calibre_link-1537" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and Swift Objects</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Optionals and</span>, <a data-type="index:locator" href="#calibre_link-1538" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-1539" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-1540" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">selectors</span>, <a data-type="index:locator" href="#calibre_link-1541" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-1542" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a>-<a data-type="index:locator" href="#calibre_link-1543" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift class member exposure to</span>, <a data-type="index:locator" href="#calibre_link-1544" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exposure of Swift to Objective-C</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift features invisible to</span>, <a data-type="index:locator" href="#calibre_link-1545" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and Swift Objects</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift, in one target with</span>, <a data-type="index:locator" href="#calibre_link-1546" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Swift, translating app into</span>, <a data-type="index:locator" href="#calibre_link-1547" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">objects</span>, <a data-type="index:locator" href="#calibre_link-1548" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Everything Is an Object?</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> object types)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">communication between</span>, <a data-type="index:locator" href="#calibre_link-1549" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility Through an Instance Property</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">graphing</span>, <a data-type="index:locator" href="#calibre_link-1550" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Debugging</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">identity of two</span>, <a data-type="index:locator" href="#calibre_link-1551" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object identity</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Objects library</span>, <a data-type="index:locator" href="#calibre_link-1552" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Canvas</a>, <a data-type="index:locator" href="#calibre_link-1553" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">octal numbers</span>, <a data-type="index:locator" href="#calibre_link-1554" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Int</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">opaque types</span>, <a data-type="index:locator" href="#calibre_link-1555" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">open</span>, <a data-type="index:locator" href="#calibre_link-1556" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">operator syntax</span>, <a data-type="index:locator" href="#calibre_link-1557" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Everything Is an Object?</a>, <a data-type="index:locator" href="#calibre_link-1558" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">operators</span>, <a data-type="index:locator" href="#calibre_link-1559" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a>-<a data-type="index:locator" href="#calibre_link-1560" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">arithmetic</span>, <a data-type="index:locator" href="#calibre_link-1561" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">custom</span>, <a data-type="index:locator" href="#calibre_link-1562" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">bitwise</span>, <a data-type="index:locator" href="#calibre_link-1563" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a>, <a data-type="index:locator" href="#calibre_link-1564" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> option sets)</li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Boolean</span>, <a data-type="index:locator" href="#calibre_link-1565" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Combine framework</span>, <a data-type="index:locator" href="#calibre_link-1566" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">comparison</span>, <a data-type="index:locator" href="#calibre_link-1567" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparison</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">compound assignment</span>, <a data-type="index:locator" href="#calibre_link-1568" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-1569" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-1570" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-1571" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparison</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">custom</span>, <a data-type="index:locator" href="#calibre_link-1572" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Synthesized Protocol Implementations</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">identity</span>, <a data-type="index:locator" href="#calibre_link-1573" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object identity</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">interval</span>, <a data-type="index:locator" href="#calibre_link-1574" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nil-coalescing</span>, <a data-type="index:locator" href="#calibre_link-1575" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overriding</span>, <a data-type="index:locator" href="#calibre_link-1576" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">precedence</span>, <a data-type="index:locator" href="#calibre_link-1577" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a>, <a data-type="index:locator" href="#calibre_link-1578" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">ternary</span>, <a data-type="index:locator" href="#calibre_link-1579" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unwrap</span>, <a data-type="index:locator" href="#calibre_link-1580" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unwrapping an Optional</a>, <a data-type="index:locator" href="#calibre_link-1581" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Optimization Level build setting</span>, <a data-type="index:locator" href="#calibre_link-1582" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Configurations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">optimizing</span>, <a data-type="index:locator" href="#calibre_link-1583" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Profiling</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">option sets</span>, <a data-type="index:locator" href="#calibre_link-1584" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a>, <a data-type="index:locator" href="#calibre_link-1585" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_OPTIONS</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">empty</span>, <a data-type="index:locator" href="#calibre_link-1586" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Optional chains</span>, <a data-type="index:locator" href="#calibre_link-1587" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">optional message sending</span>, <a data-type="index:locator" href="#calibre_link-1588" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional members</a>, <a data-type="index:locator" href="#calibre_link-1589" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">optional methods</span>, <a data-type="index:locator" href="#calibre_link-1590" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a>, <a data-type="index:locator" href="#calibre_link-1591" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">optional properties</span>, <a data-type="index:locator" href="#calibre_link-1592" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">optional unwrap operator</span>, <a data-type="index:locator" href="#calibre_link-1593" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Optionals</span>, <a data-type="index:locator" href="#calibre_link-1594" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a>-<a data-type="index:locator" href="#calibre_link-1595" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">array of</span>, <a data-type="index:locator" href="#calibre_link-1596" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array casting and type testing</a>, <a data-type="index:locator" href="#calibre_link-1597" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">casting</span>, <a data-type="index:locator" href="#calibre_link-1598" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Optionals</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">chain</span>, <a data-type="index:locator" href="#calibre_link-1599" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">comparison</span>, <a data-type="index:locator" href="#calibre_link-1600" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparison with Optional</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-1601" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-1602" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deferred initialization</span>, <a data-type="index:locator" href="#calibre_link-1603" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-1604" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">double-wrapped</span>, <a data-type="index:locator" href="#calibre_link-1605" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional properties</a>, <a data-type="index:locator" href="#calibre_link-1606" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">empty</span>, <a data-type="index:locator" href="#calibre_link-1607" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enum</span>, <a data-type="index:locator" href="#calibre_link-1608" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Values</a>, <a data-type="index:locator" href="#calibre_link-1609" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-1610" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Comparison with Optional</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">flatMap</span>, <a data-type="index:locator" href="#calibre_link-1611" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional map and flatMap</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">implicitly unwrapped</span>, <a data-type="index:locator" href="#calibre_link-1612" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly unwrapped Optional</a>, <a data-type="index:locator" href="#calibre_link-1613" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nullability</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-1614" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">map</span>, <a data-type="index:locator" href="#calibre_link-1615" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional map and flatMap</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">messages to</span>, <a data-type="index:locator" href="#calibre_link-1616" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">without unwrapping</span>, <a data-type="index:locator" href="#calibre_link-1617" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional map and flatMap</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nil</span>, <a data-type="index:locator" href="#calibre_link-1618" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C and</span>, <a data-type="index:locator" href="#calibre_link-1619" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-1620" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type</span>, <a data-type="index:locator" href="#calibre_link-1621" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">testing</span>, <a data-type="index:locator" href="#calibre_link-1622" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Optionals</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unwrapping</span>, <a data-type="index:locator" href="#calibre_link-1623" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unwrapping an Optional</a>, <a data-type="index:locator" href="#calibre_link-1624" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a>, <a data-type="index:locator" href="#calibre_link-1625" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a>, <a data-type="index:locator" href="#calibre_link-1626" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-1627" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a>, <a data-type="index:locator" href="#calibre_link-1628" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a>, <a data-type="index:locator" href="#calibre_link-1629" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Guard</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">wrapping</span>, <a data-type="index:locator" href="#calibre_link-1630" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">OptionSet</span>, <a data-type="index:locator" href="#calibre_link-1631" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a>, <a data-type="index:locator" href="#calibre_link-1632" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_OPTIONS</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">organization identifier</span>, <a data-type="index:locator" href="#calibre_link-1633" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Organizer window</span>, <a data-type="index:locator" href="#calibre_link-1634" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Making an Archive</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">orientation of interface</span>, <a data-type="index:locator" href="#calibre_link-1635" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">OSLog</span>, <a data-type="index:locator" href="#calibre_link-1636" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">outlet collections</span>, <a data-type="index:locator" href="#calibre_link-1637" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Outlet Collections</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">outlet connections</span>, <a data-type="index:locator" href="#calibre_link-1638" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Outlets</a>, <a data-type="index:locator" href="#calibre_link-1639" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How Outlets Work</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">outlets</span>, <a data-type="index:locator" href="#calibre_link-1640" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Outlets</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-1641" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">More Ways to Create Outlets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deleting</span>, <a data-type="index:locator" href="#calibre_link-1642" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deleting an Outlet</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">misconfiguring</span>, <a data-type="index:locator" href="#calibre_link-1643" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Misconfigured Outlets</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">output</span>, <a data-type="index:locator" href="#calibre_link-1644" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">overflow</span>, <a data-type="index:locator" href="#calibre_link-1645" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">overlay, Swift</span>, <a data-type="index:locator" href="#calibre_link-1646" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a>, <a data-type="index:locator" href="#calibre_link-1647" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">overloading</span>, <a data-type="index:locator" href="#calibre_link-1648" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overloading</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1649" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overloading</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">overriding</span>, <a data-type="index:locator" href="#calibre_link-1650" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-1651" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-1652" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">polymorphism and</span>, <a data-type="index:locator" href="#calibre_link-1653" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">preventing</span>, <a data-type="index:locator" href="#calibre_link-1654" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Overriding</a>, <a data-type="index:locator" href="#calibre_link-1655" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">overscroll</span>, <a data-type="index:locator" href="#calibre_link-1656" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">owner</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1657" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nib</span>, <a data-type="index:locator" href="#calibre_link-1658" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
</ul></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">P</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">pane</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">assistant</span>, <a data-type="index:locator" href="#calibre_link-1659" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Assistant panes</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">editor</span>, <a data-type="index:locator" href="#calibre_link-1660" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editor panes</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">parameter list</span>, <a data-type="index:locator" href="#calibre_link-1661" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">in anonymous function</span>, <a data-type="index:locator" href="#calibre_link-1662" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting</span>, <a data-type="index:locator" href="#calibre_link-1663" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">parameters</span>, <a data-type="index:locator" href="#calibre_link-1664" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">default values</span>, <a data-type="index:locator" href="#calibre_link-1665" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Default Parameter Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">external names</span>, <a data-type="index:locator" href="#calibre_link-1666" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-1667" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-1668" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-1669" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">functions as</span>, <a data-type="index:locator" href="#calibre_link-1670" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">ignoring</span>, <a data-type="index:locator" href="#calibre_link-1671" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ignored Parameters</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">internal names</span>, <a data-type="index:locator" href="#calibre_link-1672" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">modifiable</span>, <a data-type="index:locator" href="#calibre_link-1673" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modifiable Parameters</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variadic</span>, <a data-type="index:locator" href="#calibre_link-1674" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">parentheses</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">calling a function</span>, <a data-type="index:locator" href="#calibre_link-1675" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">coercion</span>, <a data-type="index:locator" href="#calibre_link-1676" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Numeric coercion</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaring a function</span>, <a data-type="index:locator" href="#calibre_link-1677" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">instantiating an object type</span>, <a data-type="index:locator" href="#calibre_link-1678" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1679" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a>, <a data-type="index:locator" href="#calibre_link-1680" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">order of operations</span>, <a data-type="index:locator" href="#calibre_link-1681" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a>, <a data-type="index:locator" href="#calibre_link-1682" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">signifying Void</span>, <a data-type="index:locator" href="#calibre_link-1683" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Void Return Type and Parameters</a>, <a data-type="index:locator" href="#calibre_link-1684" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">tuples</span>, <a data-type="index:locator" href="#calibre_link-1685" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">partial range</span>, <a data-type="index:locator" href="#calibre_link-1686" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-1687" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a>, <a data-type="index:locator" href="#calibre_link-1688" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-1689" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a>, <a data-type="index:locator" href="#calibre_link-1690" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">patterns, switch statement</span>, <a data-type="index:locator" href="#calibre_link-1691" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">persistence</span> (<span data-gentext="see" class="publishername">see</span> lifetime)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">persisting references</span>, <a data-type="index:locator" href="#calibre_link-1692" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">pipeline</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Combine framework</span>, <a data-type="index:locator" href="#calibre_link-1693" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">SwiftUI binding</span>, <a data-type="index:locator" href="#calibre_link-1694" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">placeholders</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">code</span>, <a data-type="index:locator" href="#calibre_link-1695" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autocompletion and Placeholders</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic</span>, <a data-type="index:locator" href="#calibre_link-1696" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> generics)</li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nib editor</span> (<span data-gentext="see" class="publishername">see</span> proxy objects)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">playgrounds</span>, <a data-type="index:locator" href="#calibre_link-1697" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Scope of This Book</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">pointee</span>, <a data-type="index:locator" href="#calibre_link-1698" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Called by Objective-C with Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-1699" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">pointer-to-void</span>, <a data-type="index:locator" href="#calibre_link-1700" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">pointers</span>, <a data-type="index:locator" href="#calibre_link-1701" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Calling Objective-C with Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-1702" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instance references are pointers</a>, <a data-type="index:locator" href="#calibre_link-1703" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a>, <a data-type="index:locator" href="#calibre_link-1704" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">CFTypeRefs</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">C</span>, <a data-type="index:locator" href="#calibre_link-1705" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dangling</span>, <a data-type="index:locator" href="#calibre_link-1706" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic</span>, <a data-type="index:locator" href="#calibre_link-1707" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">polymorphism</span>, <a data-type="index:locator" href="#calibre_link-1708" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">generics</span>, <a data-type="index:locator" href="#calibre_link-1709" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Invariance</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">pool, autorelease</span>, <a data-type="index:locator" href="#calibre_link-1710" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Autorelease Pool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">popFirst</span>, <a data-type="index:locator" href="#calibre_link-1711" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">popLast</span>, <a data-type="index:locator" href="#calibre_link-1712" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Portal</span>, <a data-type="index:locator" href="#calibre_link-1713" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">posting a notification</span>, <a data-type="index:locator" href="#calibre_link-1714" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notifications</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">precedence</span>, <a data-type="index:locator" href="#calibre_link-1715" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">precondition</span>, <a data-type="index:locator" href="#calibre_link-1716" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Aborting the whole program</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">prefix</span>, <a data-type="index:locator" href="#calibre_link-1717" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-1718" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-1719" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">previews, video</span>, <a data-type="index:locator" href="#calibre_link-1720" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Screenshots and Video Previews</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">print</span>, <a data-type="index:locator" href="#calibre_link-1721" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a>, <a data-type="index:locator" href="#calibre_link-1722" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a>, <a data-type="index:locator" href="#calibre_link-1723" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a>, <a data-type="index:locator" href="#calibre_link-1724" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> logging)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">privacy</span>, <a data-type="index:locator" href="#calibre_link-1725" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a>, <a data-type="index:locator" href="#calibre_link-1726" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">private</span>, <a data-type="index:locator" href="#calibre_link-1727" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">product name</span>, <a data-type="index:locator" href="#calibre_link-1728" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">profile</span> (<span data-gentext="see" class="publishername">see</span> provisioning profile)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">profiling</span>, <a data-type="index:locator" href="#calibre_link-1729" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Profiling</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">project</span>, <a data-type="index:locator" href="#calibre_link-1730" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anatomy of an Xcode Project</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">file</span>, <a data-type="index:locator" href="#calibre_link-1731" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Contents of the Project Folder</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">folder</span>, <a data-type="index:locator" href="#calibre_link-1732" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Project File and Dependents</a>, <a data-type="index:locator" href="#calibre_link-1733" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">renaming</span>, <a data-type="index:locator" href="#calibre_link-1734" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">templates</span>, <a data-type="index:locator" href="#calibre_link-1735" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a>, <a data-type="index:locator" href="#calibre_link-1736" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">window</span>, <a data-type="index:locator" href="#calibre_link-1737" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Project Window</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Project navigator</span>, <a data-type="index:locator" href="#calibre_link-1738" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-1739" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-1740" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Members</a>, <a data-type="index:locator" href="#calibre_link-1741" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-1742" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Properties</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> variables)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">accessors</span>, <a data-type="index:locator" href="#calibre_link-1743" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Accessors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">class</span>, <a data-type="index:locator" href="#calibre_link-1744" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-1745" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How properties are accessed</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">computed</span>, <a data-type="index:locator" href="#calibre_link-1746" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Properties</a>, <a data-type="index:locator" href="#calibre_link-1747" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Properties</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> variables, computed)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">property wrappers</span>, <a data-type="index:locator" href="#calibre_link-1748" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a>, <a data-type="index:locator" href="#calibre_link-1749" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">computed initialization</span>, <a data-type="index:locator" href="#calibre_link-1750" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variable Initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dynamic</span>, <a data-type="index:locator" href="#calibre_link-1751" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dynamic Membership</a>, <a data-type="index:locator" href="#calibre_link-1752" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing Example</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enums</span>, <a data-type="index:locator" href="#calibre_link-1753" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-1754" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How to write an initializer</a>, <a data-type="index:locator" href="#calibre_link-1755" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property initialization</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">classes</span>, <a data-type="index:locator" href="#calibre_link-1756" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">deferred</span>, <a data-type="index:locator" href="#calibre_link-1757" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-1758" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lazy</span>, <a data-type="index:locator" href="#calibre_link-1759" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization of Instance Properties</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">inspectable</span>, <a data-type="index:locator" href="#calibre_link-1760" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">instance</span>, <a data-type="index:locator" href="#calibre_link-1761" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a>, <a data-type="index:locator" href="#calibre_link-1762" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-1763" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How properties are accessed</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1764" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Instance Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1765" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1766" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Memory Management Policies</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting type name</span>, <a data-type="index:locator" href="#calibre_link-1767" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Optional</span>, <a data-type="index:locator" href="#calibre_link-1768" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Deferred initialization of properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">optional</span>, <a data-type="index:locator" href="#calibre_link-1769" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overriding</span>, <a data-type="index:locator" href="#calibre_link-1770" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">private</span>, <a data-type="index:locator" href="#calibre_link-1771" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">releasing</span>, <a data-type="index:locator" href="#calibre_link-1772" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Instance Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">static</span>, <a data-type="index:locator" href="#calibre_link-1773" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-1774" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How properties are accessed</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-1775" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">struct</span>, <a data-type="index:locator" href="#calibre_link-1776" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">vs. class</span>, <a data-type="index:locator" href="#calibre_link-1777" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">structs</span>, <a data-type="index:locator" href="#calibre_link-1778" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Properties</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">property list settings</span>, <a data-type="index:locator" href="#calibre_link-1779" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a>, <a data-type="index:locator" href="#calibre_link-1780" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">dependent on device type</span>, <a data-type="index:locator" href="#calibre_link-1781" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">property lists</span>, <a data-type="index:locator" href="#calibre_link-1782" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Lists</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">property wrappers</span>, <a data-type="index:locator" href="#calibre_link-1783" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a>, <a data-type="index:locator" href="#calibre_link-1784" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">protocols</span>, <a data-type="index:locator" href="#calibre_link-1785" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a>-<a data-type="index:locator" href="#calibre_link-1786" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Literal Convertibles</a>, <a data-type="index:locator" href="#calibre_link-1787" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">adopter</span>, <a data-type="index:locator" href="#calibre_link-1788" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">adopting</span>, <a data-type="index:locator" href="#calibre_link-1789" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">conditionally</span>, <a data-type="index:locator" href="#calibre_link-1790" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">associated type</span>, <a data-type="index:locator" href="#calibre_link-1791" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">chaining</span>, <a data-type="index:locator" href="#calibre_link-1792" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Type Chains</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">constraining</span>, <a data-type="index:locator" href="#calibre_link-1793" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">casting</span>, <a data-type="index:locator" href="#calibre_link-1794" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Type Testing and Casting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">class</span>, <a data-type="index:locator" href="#calibre_link-1795" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">composition</span>, <a data-type="index:locator" href="#calibre_link-1796" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Composition</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">conforming to</span>, <a data-type="index:locator" href="#calibre_link-1797" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-1798" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Declaring a Protocol</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">delegate</span>, <a data-type="index:locator" href="#calibre_link-1799" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implementing Delegation</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">documentation</span>, <a data-type="index:locator" href="#calibre_link-1800" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-1801" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Protocols</a>, <a data-type="index:locator" href="#calibre_link-1802" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How You Use Extensions</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">constraining associated type</span>, <a data-type="index:locator" href="#calibre_link-1803" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">invisible to Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1804" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Cocoa Delegation</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generic</span>, <a data-type="index:locator" href="#calibre_link-1805" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">constraining associated type</span>, <a data-type="index:locator" href="#calibre_link-1806" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">implicitly required initializers</span>, <a data-type="index:locator" href="#calibre_link-1807" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">informal</span>, <a data-type="index:locator" href="#calibre_link-1808" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Informal Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">literal convertible</span>, <a data-type="index:locator" href="#calibre_link-1809" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Literal Convertibles</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1810" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory management of protocol-typed references</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1811" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocols</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">optional members</span>, <a data-type="index:locator" href="#calibre_link-1812" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Protocol Members</a>, <a data-type="index:locator" href="#calibre_link-1813" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">synthesizing</span>, <a data-type="index:locator" href="#calibre_link-1814" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Synthesized Protocol Implementations</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">testing type</span>, <a data-type="index:locator" href="#calibre_link-1815" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Protocol Type Testing and Casting</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">provisioning profile</span>, <a data-type="index:locator" href="#calibre_link-1816" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">development</span>, <a data-type="index:locator" href="#calibre_link-1817" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">distribution</span>, <a data-type="index:locator" href="#calibre_link-1818" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Distribution Profile</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">universal</span>, <a data-type="index:locator" href="#calibre_link-1819" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">proxy objects</span>, <a data-type="index:locator" href="#calibre_link-1820" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a>, <a data-type="index:locator" href="#calibre_link-1821" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Owner</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">public</span>, <a data-type="index:locator" href="#calibre_link-1822" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Published</span>, <a data-type="index:locator" href="#calibre_link-1823" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Publisher</span>, <a data-type="index:locator" href="#calibre_link-1824" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">pyramid of doom</span>, <a data-type="index:locator" href="#calibre_link-1825" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional binding</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">Q</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">query events</span>, <a data-type="index:locator" href="#calibre_link-1826" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reasons for Events</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">question mark</span>, <a data-type="index:locator" href="#calibre_link-1827" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a>, <a data-type="index:locator" href="#calibre_link-1828" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional chains</a>, <a data-type="index:locator" href="#calibre_link-1829" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a>, <a data-type="index:locator" href="#calibre_link-1830" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional members</a>, <a data-type="index:locator" href="#calibre_link-1831" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-1832" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Quick Help</span>, <a data-type="index:locator" href="#calibre_link-1833" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a>, <a data-type="index:locator" href="#calibre_link-1834" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Quick Help</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Quick Look a variable</span>, <a data-type="index:locator" href="#calibre_link-1835" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">quotes</span>, <a data-type="index:locator" href="#calibre_link-1836" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">R</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">random</span>, <a data-type="index:locator" href="#calibre_link-1837" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">randomElement</span>, <a data-type="index:locator" href="#calibre_link-1838" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Range</span>, <a data-type="index:locator" href="#calibre_link-1839" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ranges</span>, <a data-type="index:locator" href="#calibre_link-1840" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">coercion to NSRange</span>, <a data-type="index:locator" href="#calibre_link-1841" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSRange</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">indexing with</span>, <a data-type="index:locator" href="#calibre_link-1842" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-1843" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">iterating in reverse</span>, <a data-type="index:locator" href="#calibre_link-1844" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Operators</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">partial</span>, <a data-type="index:locator" href="#calibre_link-1845" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-1846" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a>, <a data-type="index:locator" href="#calibre_link-1847" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a>, <a data-type="index:locator" href="#calibre_link-1848" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a>, <a data-type="index:locator" href="#calibre_link-1849" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">string</span>, <a data-type="index:locator" href="#calibre_link-1850" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-1851" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a>, <a data-type="index:locator" href="#calibre_link-1852" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSRange</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">raw value</span>, <a data-type="index:locator" href="#calibre_link-1853" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">RawRepresentable</span>, <a data-type="index:locator" href="#calibre_link-1854" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">read-only variables</span>, <a data-type="index:locator" href="#calibre_link-1855" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">recursion</span>, <a data-type="index:locator" href="#calibre_link-1856" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Recursion</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">recursive initializers</span>, <a data-type="index:locator" href="#calibre_link-1857" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Delegating initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">recursive references</span>, <a data-type="index:locator" href="#calibre_link-1858" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Advantages of value types vs. reference types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">reduce</span>, <a data-type="index:locator" href="#calibre_link-1859" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array enumeration and transformation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">refactoring</span>, <a data-type="index:locator" href="#calibre_link-1860" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Refactoring and Structure Editing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">reference</span>, <a data-type="index:locator" href="#calibre_link-1861" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-1862" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables and Simple Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">reference types</span>, <a data-type="index:locator" href="#calibre_link-1863" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Value Types and Reference Types</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-1864" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">references</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">getting</span>, <a data-type="index:locator" href="#calibre_link-1865" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility Through an Instance Property</a>, <a data-type="index:locator" href="#calibre_link-1866" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Getting a Reference</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">persisting</span>, <a data-type="index:locator" href="#calibre_link-1867" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">recursive</span>, <a data-type="index:locator" href="#calibre_link-1868" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Advantages of value types vs. reference types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">strong</span>, <a data-type="index:locator" href="#calibre_link-1869" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">to functions</span>, <a data-type="index:locator" href="#calibre_link-1870" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function References and Selectors</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">to object types</span>, <a data-type="index:locator" href="#calibre_link-1871" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-1872" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Objective-C Objects and C Pointers</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">to same object</span>, <a data-type="index:locator" href="#calibre_link-1873" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instance references are pointers</a>, <a data-type="index:locator" href="#calibre_link-1874" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object identity</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unowned</span>, <a data-type="index:locator" href="#calibre_link-1875" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unowned references</a>, <a data-type="index:locator" href="#calibre_link-1876" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">unsafe</span>, <a data-type="index:locator" href="#calibre_link-1877" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">weak</span>, <a data-type="index:locator" href="#calibre_link-1878" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Weak references</a>, <a data-type="index:locator" href="#calibre_link-1879" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">registering a device</span>, <a data-type="index:locator" href="#calibre_link-1880" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a>, <a data-type="index:locator" href="#calibre_link-1881" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Manual Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">registering an app</span>, <a data-type="index:locator" href="#calibre_link-1882" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Manual Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">registering for a notification</span>, <a data-type="index:locator" href="#calibre_link-1883" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Receiving a Notification</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">registering for key&ndash;value observing</span>, <a data-type="index:locator" href="#calibre_link-1884" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Registration and Notification</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">regular expressions</span>, <a data-type="index:locator" href="#calibre_link-1885" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Related Items menu</span>, <a data-type="index:locator" href="#calibre_link-1886" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Editor</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">release</span>, <a data-type="index:locator" href="#calibre_link-1887" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">releasing a property</span>, <a data-type="index:locator" href="#calibre_link-1888" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Instance Properties</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">remove</span>, <a data-type="index:locator" href="#calibre_link-1889" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-1890" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">removeFirst</span>, <a data-type="index:locator" href="#calibre_link-1891" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">removeLast</span>, <a data-type="index:locator" href="#calibre_link-1892" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">removeSubrange</span>, <a data-type="index:locator" href="#calibre_link-1893" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">removeValue</span>, <a data-type="index:locator" href="#calibre_link-1894" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary subscripting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">renamification</span>, <a data-type="index:locator" href="#calibre_link-1895" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renamification</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">renaming a project</span>, <a data-type="index:locator" href="#calibre_link-1896" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">REPL</span>, <a data-type="index:locator" href="#calibre_link-1897" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Scope of This Book</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">replaceSubrange</span>, <a data-type="index:locator" href="#calibre_link-1898" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">replacing</span>, <a data-type="index:locator" href="#calibre_link-1899" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Finding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Report navigator</span>, <a data-type="index:locator" href="#calibre_link-1900" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-1901" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">required initializers</span>, <a data-type="index:locator" href="#calibre_link-1902" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Required initializers</a>, <a data-type="index:locator" href="#calibre_link-1903" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a>, <a data-type="index:locator" href="#calibre_link-1904" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Implicitly Required Initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">reserved words</span>, <a data-type="index:locator" href="#calibre_link-1905" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Privacy</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">resolution, screen</span>, <a data-type="index:locator" href="#calibre_link-1906" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">resolving a generic</span>, <a data-type="index:locator" href="#calibre_link-1907" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a>, <a data-type="index:locator" href="#calibre_link-1908" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">resources</span>, <a data-type="index:locator" href="#calibre_link-1909" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Resources</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">app bundle</span>, <a data-type="index:locator" href="#calibre_link-1910" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in the Project navigator</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">asset catalog</span>, <a data-type="index:locator" href="#calibre_link-1911" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in an asset catalog</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dependent on build type</span>, <a data-type="index:locator" href="#calibre_link-1912" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Resources in an asset catalog</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dependent on device type</span>, <a data-type="index:locator" href="#calibre_link-1913" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">responder</span>, <a data-type="index:locator" href="#calibre_link-1914" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Responder Chain</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">responder chain</span>, <a data-type="index:locator" href="#calibre_link-1915" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Responder Chain</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">responds</span>, <a data-type="index:locator" href="#calibre_link-1916" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional Members</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Result</span>, <a data-type="index:locator" href="#calibre_link-1917" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Result</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">result of a function</span>, <a data-type="index:locator" href="#calibre_link-1918" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">ignoring</span>, <a data-type="index:locator" href="#calibre_link-1919" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">retain</span>, <a data-type="index:locator" href="#calibre_link-1920" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Rules of Cocoa Memory Management</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">retain count</span>, <a data-type="index:locator" href="#calibre_link-1921" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Principles of Cocoa Memory Management</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-1922" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a>, <a data-type="index:locator" href="#calibre_link-1923" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">anonymous functions</span>, <a data-type="index:locator" href="#calibre_link-1924" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">key&ndash;value observing</span>, <a data-type="index:locator" href="#calibre_link-1925" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">KVO Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">notifications</span>, <a data-type="index:locator" href="#calibre_link-1926" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">timers</span>, <a data-type="index:locator" href="#calibre_link-1927" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Timers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">retains, unusual</span>, <a data-type="index:locator" href="#calibre_link-1928" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Other Unusual Situations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">rethrows</span>, <a data-type="index:locator" href="#calibre_link-1929" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">return</span>, <a data-type="index:locator" href="#calibre_link-1930" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">function from function</span>, <a data-type="index:locator" href="#calibre_link-1931" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Returning Function</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting</span>, <a data-type="index:locator" href="#calibre_link-1932" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a>, <a data-type="index:locator" href="#calibre_link-1933" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">value of anonymous function</span>, <a data-type="index:locator" href="#calibre_link-1934" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Functions</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">value of function</span>, <a data-type="index:locator" href="#calibre_link-1935" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">reverse generics</span>, <a data-type="index:locator" href="#calibre_link-1936" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">reversed</span>, <a data-type="index:locator" href="#calibre_link-1937" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-1938" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">root class</span>, <a data-type="index:locator" href="#calibre_link-1939" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">root view controller</span>, <a data-type="index:locator" href="#calibre_link-1940" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">run</span>, <a data-type="index:locator" href="#calibre_link-1941" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">running on a device</span>, <a data-type="index:locator" href="#calibre_link-1942" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running on a Device</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">S</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">sample code, Appleâ€™s</span>, <a data-type="index:locator" href="#calibre_link-1943" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Sample Code</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">scalars</span>, <a data-type="index:locator" href="#calibre_link-1944" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Everything Is an Object?</a>, <a data-type="index:locator" href="#calibre_link-1945" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSNumber</a>, <a data-type="index:locator" href="#calibre_link-1946" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Data Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Scanner</span>, <a data-type="index:locator" href="#calibre_link-1947" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">scene</span>, <a data-type="index:locator" href="#calibre_link-1948" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">scene dock</span>, <a data-type="index:locator" href="#calibre_link-1949" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Scheme pop-up menu</span>, <a data-type="index:locator" href="#calibre_link-1950" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Schemes and Destinations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">schemes</span>, <a data-type="index:locator" href="#calibre_link-1951" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Schemes and Destinations</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">renaming</span>, <a data-type="index:locator" href="#calibre_link-1952" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Renaming Parts of a Project</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">scientific notation</span>, <a data-type="index:locator" href="#calibre_link-1953" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Double</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">scope</span>, <a data-type="index:locator" href="#calibre_link-1954" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Scope and Lifetime</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">exiting early</span>, <a data-type="index:locator" href="#calibre_link-1955" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Jumping</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">nested</span>, <a data-type="index:locator" href="#calibre_link-1956" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nested scopes</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">object types</span>, <a data-type="index:locator" href="#calibre_link-1957" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">variable</span>, <a data-type="index:locator" href="#calibre_link-1958" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">screen resolution</span>, <a data-type="index:locator" href="#calibre_link-1959" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">screencasts</span>, <a data-type="index:locator" href="#calibre_link-1960" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Screenshots and Video Previews</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">screenshots</span>, <a data-type="index:locator" href="#calibre_link-1961" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Persisting screenshots</a>, <a data-type="index:locator" href="#calibre_link-1962" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Screenshots and Video Previews</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">SDKs</span>, <a data-type="index:locator" href="#calibre_link-1963" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Schemes and Destinations</a>, <a data-type="index:locator" href="#calibre_link-1964" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">older</span>, <a data-type="index:locator" href="#calibre_link-1965" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">searching arrays</span>, <a data-type="index:locator" href="#calibre_link-1966" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">searching for symbols</span>, <a data-type="index:locator" href="#calibre_link-1967" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Symbol Declarations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">searching the documentation</span>, <a data-type="index:locator" href="#calibre_link-1968" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Documentation Window</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">searching your code</span>, <a data-type="index:locator" href="#calibre_link-1969" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Finding</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">selection, multiple</span>, <a data-type="index:locator" href="#calibre_link-1970" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Multiple Selection</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Selector</span>, <a data-type="index:locator" href="#calibre_link-1971" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">selectors</span>, <a data-type="index:locator" href="#calibre_link-1972" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a>, <a data-type="index:locator" href="#calibre_link-1973" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Selectors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">self</span>, <a data-type="index:locator" href="#calibre_link-1974" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Keyword self</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">in escaping functions</span>, <a data-type="index:locator" href="#calibre_link-1975" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Escaping Closures</a>, <a data-type="index:locator" href="#calibre_link-1976" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">in initializers</span>, <a data-type="index:locator" href="#calibre_link-1977" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Referring to self</a>, <a data-type="index:locator" href="#calibre_link-1978" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Kinds of class initializer</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">in instance methods</span>, <a data-type="index:locator" href="#calibre_link-1979" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Keyword self</a>, <a data-type="index:locator" href="#calibre_link-1980" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">in property initialization</span>, <a data-type="index:locator" href="#calibre_link-1981" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">in static/class methods</span>, <a data-type="index:locator" href="#calibre_link-1982" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">polymorphism</span>, <a data-type="index:locator" href="#calibre_link-1983" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type of</span>, <a data-type="index:locator" href="#calibre_link-1984" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">with type name</span>, <a data-type="index:locator" href="#calibre_link-1985" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type as Value</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Self</span>, <a data-type="index:locator" href="#calibre_link-1986" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From self to Type</a>, <a data-type="index:locator" href="#calibre_link-1987" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generic Declarations</a>, <a data-type="index:locator" href="#calibre_link-1988" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Associated Type Chains</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">semicolon</span>, <a data-type="index:locator" href="#calibre_link-1989" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">sequence</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">array initializer</span>, <a data-type="index:locator" href="#calibre_link-1990" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">character</span>, <a data-type="index:locator" href="#calibre_link-1991" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">cycling makes a copy</span>, <a data-type="index:locator" href="#calibre_link-1992" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">cycling through</span>, <a data-type="index:locator" href="#calibre_link-1993" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enumerating with index</span>, <a data-type="index:locator" href="#calibre_link-1994" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a>, <a data-type="index:locator" href="#calibre_link-1995" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">function</span>, <a data-type="index:locator" href="#calibre_link-1996" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">generating</span>, <a data-type="index:locator" href="#calibre_link-1997" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lazy</span>, <a data-type="index:locator" href="#calibre_link-1998" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">range indexing</span>, <a data-type="index:locator" href="#calibre_link-1999" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">transforming</span>, <a data-type="index:locator" href="#calibre_link-2000" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Sequence</span>, <a data-type="index:locator" href="#calibre_link-2001" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">serialization</span>, <a data-type="index:locator" href="#calibre_link-2002" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Lists</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Set</span>, <a data-type="index:locator" href="#calibre_link-2003" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">sets</span>, <a data-type="index:locator" href="#calibre_link-2004" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a>-<a data-type="index:locator" href="#calibre_link-2005" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Set and Objective-C NSSet</a>, <a data-type="index:locator" href="#calibre_link-2006" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-2007" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-2008" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">hashable elements</span>, <a data-type="index:locator" href="#calibre_link-2009" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">NSObject</span>, <a data-type="index:locator" href="#calibre_link-2010" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Equality, Hashability, and Comparison</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-2011" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">literals</span>, <a data-type="index:locator" href="#calibre_link-2012" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mutating</span>, <a data-type="index:locator" href="#calibre_link-2013" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">operations</span>, <a data-type="index:locator" href="#calibre_link-2014" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">option sets</span>, <a data-type="index:locator" href="#calibre_link-2015" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Option sets</a>, <a data-type="index:locator" href="#calibre_link-2016" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_OPTIONS</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">sampling</span>, <a data-type="index:locator" href="#calibre_link-2017" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">transformations</span>, <a data-type="index:locator" href="#calibre_link-2018" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">setter</span>, <a data-type="index:locator" href="#calibre_link-2019" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a>, <a data-type="index:locator" href="#calibre_link-2020" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Accessors, Properties, and Key&ndash;Value Coding</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">private</span>, <a data-type="index:locator" href="#calibre_link-2021" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Private and Fileprivate</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">setter observers</span>, <a data-type="index:locator" href="#calibre_link-2022" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Setter Observers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">shared application instance</span>, <a data-type="index:locator" href="#calibre_link-2023" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">shortcircuiting</span>, <a data-type="index:locator" href="#calibre_link-2024" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Shortcircuiting and labels</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">shuffle</span>, <a data-type="index:locator" href="#calibre_link-2025" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">side effects</span>, <a data-type="index:locator" href="#calibre_link-2026" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">signature of a function</span>, <a data-type="index:locator" href="#calibre_link-2027" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Signature</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">signing an app</span>, <a data-type="index:locator" href="#calibre_link-2028" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">automatic</span>, <a data-type="index:locator" href="#calibre_link-2029" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">manual</span>, <a data-type="index:locator" href="#calibre_link-2030" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Manual Signing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">signposts</span>, <a data-type="index:locator" href="#calibre_link-2031" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instruments</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">simd</span>, <a data-type="index:locator" href="#calibre_link-2032" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Simulator</span>, <a data-type="index:locator" href="#calibre_link-2033" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Running in the Simulator</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Single View App template</span>, <a data-type="index:locator" href="#calibre_link-2034" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Single View app template</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">not backward compatible</span>, <a data-type="index:locator" href="#calibre_link-2035" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">singleton</span>, <a data-type="index:locator" href="#calibre_link-2036" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Singleton</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Size inspector</span>, <a data-type="index:locator" href="#calibre_link-2037" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a>, <a data-type="index:locator" href="#calibre_link-2038" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Inspectors and Libraries</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">slice</span>, <a data-type="index:locator" href="#calibre_link-2039" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">snippets</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">creating</span>, <a data-type="index:locator" href="#calibre_link-2040" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Snippets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Snippets library</span>, <a data-type="index:locator" href="#calibre_link-2041" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Snippets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">structural</span>, <a data-type="index:locator" href="#calibre_link-2042" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Refactoring and Structure Editing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">some</span>, <a data-type="index:locator" href="#calibre_link-2043" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">sort</span>, <a data-type="index:locator" href="#calibre_link-2044" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">sorted</span>, <a data-type="index:locator" href="#calibre_link-2045" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">sorting arrays</span>, <a data-type="index:locator" href="#calibre_link-2046" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Source Control navigator</span>, <a data-type="index:locator" href="#calibre_link-2047" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-2048" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Source Control preferences and menu</span>, <a data-type="index:locator" href="#calibre_link-2049" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">specializing a generic</span>, <a data-type="index:locator" href="#calibre_link-2050" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a>, <a data-type="index:locator" href="#calibre_link-2051" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Explicit Specialization</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">splatting</span>, <a data-type="index:locator" href="#calibre_link-2052" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">split</span>, <a data-type="index:locator" href="#calibre_link-2053" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-2054" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">square brackets</span>, <a data-type="index:locator" href="#calibre_link-2055" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a>, <a data-type="index:locator" href="#calibre_link-2056" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array</a>, <a data-type="index:locator" href="#calibre_link-2057" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">stack, call</span>, <a data-type="index:locator" href="#calibre_link-2058" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Return</a>, <a data-type="index:locator" href="#calibre_link-2059" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-2060" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">startIndex</span>, <a data-type="index:locator" href="#calibre_link-2061" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-2062" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">starts</span>, <a data-type="index:locator" href="#calibre_link-2063" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">state</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">instance</span>, <a data-type="index:locator" href="#calibre_link-2064" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Instances?</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">State</span>, <a data-type="index:locator" href="#calibre_link-2065" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a>, <a data-type="index:locator" href="#calibre_link-2066" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">statement</span>, <a data-type="index:locator" href="#calibre_link-2067" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">static members</span>, <a data-type="index:locator" href="#calibre_link-2068" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instances</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">static methods</span>, <a data-type="index:locator" href="#calibre_link-2069" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Methods</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">vs. class methods</span>, <a data-type="index:locator" href="#calibre_link-2070" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static methods vs. class methods</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">static properties</span>, <a data-type="index:locator" href="#calibre_link-2071" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a>, <a data-type="index:locator" href="#calibre_link-2072" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How properties are accessed</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-2073" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">struct</span>, <a data-type="index:locator" href="#calibre_link-2074" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">vs. class properties</span>, <a data-type="index:locator" href="#calibre_link-2075" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Static properties vs. class properties</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">stepping</span>, <a data-type="index:locator" href="#calibre_link-2076" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">stored variables</span>, <a data-type="index:locator" href="#calibre_link-2077" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">storyboard files</span>, <a data-type="index:locator" href="#calibre_link-2078" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> main storyboard)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">compiled</span>, <a data-type="index:locator" href="#calibre_link-2079" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Project to Built App</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">dependent on device type</span>, <a data-type="index:locator" href="#calibre_link-2080" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Device Type</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">editing</span>, <a data-type="index:locator" href="#calibre_link-2081" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Nib Editor Interface</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">entry point</span>, <a data-type="index:locator" href="#calibre_link-2082" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">launch</span>, <a data-type="index:locator" href="#calibre_link-2083" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Launch images</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">stride</span>, <a data-type="index:locator" href="#calibre_link-2084" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">String</span>, <a data-type="index:locator" href="#calibre_link-2085" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">String.Index</span>, <a data-type="index:locator" href="#calibre_link-2086" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">stringly typed</span>, <a data-type="index:locator" href="#calibre_link-2087" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global string constants</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">strings</span>, <a data-type="index:locator" href="#calibre_link-2088" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>-<a data-type="index:locator" href="#calibre_link-2089" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">C strings</span>, <a data-type="index:locator" href="#calibre_link-2090" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Data Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">characters</span>, <a data-type="index:locator" href="#calibre_link-2091" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">coercion</span>, <a data-type="index:locator" href="#calibre_link-2092" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">comparison</span>, <a data-type="index:locator" href="#calibre_link-2093" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">concatenating</span>, <a data-type="index:locator" href="#calibre_link-2094" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">constants, global</span>, <a data-type="index:locator" href="#calibre_link-2095" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global string constants</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">equality</span>, <a data-type="index:locator" href="#calibre_link-2096" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">format</span>, <a data-type="index:locator" href="#calibre_link-2097" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Caveman Debugging</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">indexing</span>, <a data-type="index:locator" href="#calibre_link-2098" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-2099" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-2100" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">interpolation</span>, <a data-type="index:locator" href="#calibre_link-2101" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-2102" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Adopting a Library Protocol</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">custom</span>, <a data-type="index:locator" href="#calibre_link-2103" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Custom String Interpolation</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">length</span>, <a data-type="index:locator" href="#calibre_link-2104" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-2105" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">literals</span>, <a data-type="index:locator" href="#calibre_link-2106" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">multiline</span>, <a data-type="index:locator" href="#calibre_link-2107" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">raw</span>, <a data-type="index:locator" href="#calibre_link-2108" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">modifying</span>, <a data-type="index:locator" href="#calibre_link-2109" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">notification names</span>, <a data-type="index:locator" href="#calibre_link-2110" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Posting a Notification</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">range</span>, <a data-type="index:locator" href="#calibre_link-2111" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>, <a data-type="index:locator" href="#calibre_link-2112" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSRange</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">searching</span>, <a data-type="index:locator" href="#calibre_link-2113" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">substrings</span>, <a data-type="index:locator" href="#calibre_link-2114" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a>-<a data-type="index:locator" href="#calibre_link-2115" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-2116" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">Unicode</span>, <a data-type="index:locator" href="#calibre_link-2117" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">strong references</span>, <a data-type="index:locator" href="#calibre_link-2118" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of Reference Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">structs</span>, <a data-type="index:locator" href="#calibre_link-2119" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Structs</a>-<a data-type="index:locator" href="#calibre_link-2120" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> object types)</li>
<li class="calibre82"><span data-type="index-term" class="publishername">bridged to Objective-C classes</span>, <a data-type="index:locator" href="#calibre_link-2121" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a>, <a data-type="index:locator" href="#calibre_link-2122" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">C structs</span>, <a data-type="index:locator" href="#calibre_link-2123" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSValue</a>, <a data-type="index:locator" href="#calibre_link-2124" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Structs</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initializers</span>, <a data-type="index:locator" href="#calibre_link-2125" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Initializers</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">extensions</span>, <a data-type="index:locator" href="#calibre_link-2126" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extensions</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">methods</span>, <a data-type="index:locator" href="#calibre_link-2127" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">omitting type name</span>, <a data-type="index:locator" href="#calibre_link-2128" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Raw Values</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">properties</span>, <a data-type="index:locator" href="#calibre_link-2129" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">static properties</span>, <a data-type="index:locator" href="#calibre_link-2130" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-2131" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">vs. classes</span>, <a data-type="index:locator" href="#calibre_link-2132" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Classes</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">styled text</span>, <a data-type="index:locator" href="#calibre_link-2133" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">subclass</span>, <a data-type="index:locator" href="#calibre_link-2134" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">subclassing</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">in Cocoa</span>, <a data-type="index:locator" href="#calibre_link-2135" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a>, <a data-type="index:locator" href="#calibre_link-2136" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">preventing</span>, <a data-type="index:locator" href="#calibre_link-2137" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a>, <a data-type="index:locator" href="#calibre_link-2138" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Public and Open</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">UILabel</span>, <a data-type="index:locator" href="#calibre_link-2139" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">UIView</span>, <a data-type="index:locator" href="#calibre_link-2140" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a>, <a data-type="index:locator" href="#calibre_link-2141" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">UIViewController</span>, <a data-type="index:locator" href="#calibre_link-2142" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a>, <a data-type="index:locator" href="#calibre_link-2143" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Subscriber</span>, <a data-type="index:locator" href="#calibre_link-2144" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Combine Framework</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">subscripting</span>, <a data-type="index:locator" href="#calibre_link-2145" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-2146" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Range</a>, <a data-type="index:locator" href="#calibre_link-2147" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Array subscripting</a>, <a data-type="index:locator" href="#calibre_link-2148" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary subscripting</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-2149" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSArray and NSMutableArray</a>-<a data-type="index:locator" href="#calibre_link-2150" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSSet and Friends</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">subscripts</span>, <a data-type="index:locator" href="#calibre_link-2151" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subscripts</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">classes</span>, <a data-type="index:locator" href="#calibre_link-2152" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword super</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">enums</span>, <a data-type="index:locator" href="#calibre_link-2153" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enum Methods</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">overriding</span>, <a data-type="index:locator" href="#calibre_link-2154" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword super</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">structs</span>, <a data-type="index:locator" href="#calibre_link-2155" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct Methods</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">substitution principle</span>, <a data-type="index:locator" href="#calibre_link-2156" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Substring</span>, <a data-type="index:locator" href="#calibre_link-2157" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">subview</span>, <a data-type="index:locator" href="#calibre_link-2158" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">suffix</span>, <a data-type="index:locator" href="#calibre_link-2159" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Character and String Index</a>, <a data-type="index:locator" href="#calibre_link-2160" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">super</span>, <a data-type="index:locator" href="#calibre_link-2161" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword super</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">in initializers</span>, <a data-type="index:locator" href="#calibre_link-2162" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass initializers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">superclass</span>, <a data-type="index:locator" href="#calibre_link-2163" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclass and Superclass</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">superview</span>, <a data-type="index:locator" href="#calibre_link-2164" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">supported interface orientations</span>, <a data-type="index:locator" href="#calibre_link-2165" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">swapAt</span>, <a data-type="index:locator" href="#calibre_link-2166" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Basic array properties and methods</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">swapping variables</span>, <a data-type="index:locator" href="#calibre_link-2167" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Swift</span>, <a data-type="index:locator" href="#calibre_link-2168" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Architecture of Swift</a>-<a data-type="index:locator" href="#calibre_link-2169" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Swift and Objective-C in one target</span>, <a data-type="index:locator" href="#calibre_link-2170" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Swift header</span>, <a data-type="index:locator" href="#calibre_link-2171" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Swift overlay (Foundation)</span>, <a data-type="index:locator" href="#calibre_link-2172" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Some Foundation Classes</a>, <a data-type="index:locator" href="#calibre_link-2173" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bridged Types and Boxed Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">SwiftUI</span>, <a data-type="index:locator" href="#calibre_link-2174" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Scope of This Book</a>, <a data-type="index:locator" href="#calibre_link-2175" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a>, <a data-type="index:locator" href="#calibre_link-2176" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a>, <a data-type="index:locator" href="#calibre_link-2177" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a>, <a data-type="index:locator" href="#calibre_link-2178" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a>-<a data-type="index:locator" href="#calibre_link-2179" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">modifiers</span>, <a data-type="index:locator" href="#calibre_link-2180" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Promise of SwiftUI</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">switch</span>, <a data-type="index:locator" href="#calibre_link-2181" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-2182" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_ENUM</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">swizzling</span>, <a data-type="index:locator" href="#calibre_link-2183" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Key&ndash;Value Observing Example</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Symbol navigator</span>, <a data-type="index:locator" href="#calibre_link-2184" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-2185" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Navigation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">symbolic breakpoint</span>, <a data-type="index:locator" href="#calibre_link-2186" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Breakpoints</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">symbols, searching for</span>, <a data-type="index:locator" href="#calibre_link-2187" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Symbol Declarations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">syntax checking</span>, <a data-type="index:locator" href="#calibre_link-2188" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Fix-it and Live Syntax Checking</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">synthesizing protocols</span>, <a data-type="index:locator" href="#calibre_link-2189" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Synthesized Protocol Implementations</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">T</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">target</span>, <a data-type="index:locator" href="#calibre_link-2190" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Target</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">bilingual</span>, <a data-type="index:locator" href="#calibre_link-2191" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bilingual Targets</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">framework</span>, <a data-type="index:locator" href="#calibre_link-2192" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Frameworks, SDKs, and Packages</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">test</span>, <a data-type="index:locator" href="#calibre_link-2193" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Targeted Device Family build setting</span>, <a data-type="index:locator" href="#calibre_link-2194" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Permissible Runtime Environment</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">target&ndash;action</span>, <a data-type="index:locator" href="#calibre_link-2195" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">team</span>, <a data-type="index:locator" href="#calibre_link-2196" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Obtaining a Developer Program Membership</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">templates</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">file</span>, <a data-type="index:locator" href="#calibre_link-2197" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Code Files</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">project</span>, <a data-type="index:locator" href="#calibre_link-2198" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">New Project</a>, <a data-type="index:locator" href="#calibre_link-2199" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">ternary operator</span>, <a data-type="index:locator" href="#calibre_link-2200" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Conditional evaluation</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">test bundle</span>, <a data-type="index:locator" href="#calibre_link-2201" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Test Failure breakpoint</span>, <a data-type="index:locator" href="#calibre_link-2202" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Test navigator</span>, <a data-type="index:locator" href="#calibre_link-2203" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-2204" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">test plans</span>, <a data-type="index:locator" href="#calibre_link-2205" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Test Plans</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">test target</span>, <a data-type="index:locator" href="#calibre_link-2206" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">testable</span>, <a data-type="index:locator" href="#calibre_link-2207" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unit Tests</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">TestFlight</span>, <a data-type="index:locator" href="#calibre_link-2208" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution for Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">tests</span>, <a data-type="index:locator" href="#calibre_link-2209" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">text, drawing</span>, <a data-type="index:locator" href="#calibre_link-2210" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">text, styled</span>, <a data-type="index:locator" href="#calibre_link-2211" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">thinning an app</span>, <a data-type="index:locator" href="#calibre_link-2212" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Distribution for Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">throw</span>, <a data-type="index:locator" href="#calibre_link-2213" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">throws</span>, <a data-type="index:locator" href="#calibre_link-2214" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Time Profiler instrument</span>, <a data-type="index:locator" href="#calibre_link-2215" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Instruments</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">timers</span>, <a data-type="index:locator" href="#calibre_link-2216" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Timer</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">retain cycles</span>, <a data-type="index:locator" href="#calibre_link-2217" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Timers</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">times</span>, <a data-type="index:locator" href="#calibre_link-2218" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSDate and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">top level</span>, <a data-type="index:locator" href="#calibre_link-2219" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-2220" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Modules</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> global)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">top-level objects (nib)</span>, <a data-type="index:locator" href="#calibre_link-2221" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">trailing function</span>, <a data-type="index:locator" href="#calibre_link-2222" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Transporter</span>, <a data-type="index:locator" href="#calibre_link-2223" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">true</span>, <a data-type="index:locator" href="#calibre_link-2224" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Bool</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">try</span>, <a data-type="index:locator" href="#calibre_link-2225" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Throwing and catching errors</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">tuples</span>, <a data-type="index:locator" href="#calibre_link-2226" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">tweaking the APIs</span>, <a data-type="index:locator" href="#calibre_link-2227" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Why Optionals?</a>, <a data-type="index:locator" href="#calibre_link-2228" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Failable initializers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">type</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">checking, suppressing</span>, <a data-type="index:locator" href="#calibre_link-2229" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Suppressing type checking</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">constraints</span>, <a data-type="index:locator" href="#calibre_link-2230" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Constraints</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">multiple</span>, <a data-type="index:locator" href="#calibre_link-2231" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">eraser</span>, <a data-type="index:locator" href="#calibre_link-2232" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Swift Dictionary and Objective-C NSDictionary</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">name, omitting</span>, <a data-type="index:locator" href="#calibre_link-2233" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Enums</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of function</span>, <a data-type="index:locator" href="#calibre_link-2234" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of instance vs. type of variable</span>, <a data-type="index:locator" href="#calibre_link-2235" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of instance, testing</span>, <a data-type="index:locator" href="#calibre_link-2236" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type Testing and Casting Down Safely</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of Optional</span>, <a data-type="index:locator" href="#calibre_link-2237" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Optional</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">of variable</span>, <a data-type="index:locator" href="#calibre_link-2238" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-2239" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">opaque</span>, <a data-type="index:locator" href="#calibre_link-2240" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reverse Generics</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">placeholders</span>, <a data-type="index:locator" href="#calibre_link-2241" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Generics</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> generics)</li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">references</span>, <a data-type="index:locator" href="#calibre_link-2242" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Type</span>, <a data-type="index:locator" href="#calibre_link-2243" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Type as Value</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">type alias</span>, <a data-type="index:locator" href="#calibre_link-2244" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a>, <a data-type="index:locator" href="#calibre_link-2245" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">type(of:)</span>, <a data-type="index:locator" href="#calibre_link-2246" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">From Instance to Type</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">type-over completions</span>, <a data-type="index:locator" href="#calibre_link-2247" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Editing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">typecasting</span> (<span data-gentext="see" class="publishername">see</span> casting)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">types</span>, <a data-type="index:locator" href="#calibre_link-2248" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Object Type Declarations and Features</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> object types)</li>
</ul></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">U</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">UDID</span>, <a data-type="index:locator" href="#calibre_link-2249" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Signing an App</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UI tests</span>, <a data-type="index:locator" href="#calibre_link-2250" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIApplication</span>, <a data-type="index:locator" href="#calibre_link-2251" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIApplicationMain</span>, <a data-type="index:locator" href="#calibre_link-2252" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIBackgroundTaskIdentifier</span>, <a data-type="index:locator" href="#calibre_link-2253" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIControl</span>, <a data-type="index:locator" href="#calibre_link-2254" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Action Connections</a>, <a data-type="index:locator" href="#calibre_link-2255" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Actions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UILabel</span>, <a data-type="index:locator" href="#calibre_link-2256" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIPickerView</span>, <a data-type="index:locator" href="#calibre_link-2257" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Data Sources</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIResponder</span>, <a data-type="index:locator" href="#calibre_link-2258" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Responder Chain</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UISceneSession</span>, <a data-type="index:locator" href="#calibre_link-2259" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a>, <a data-type="index:locator" href="#calibre_link-2260" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Backward Compatibility</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIView</span>, <a data-type="index:locator" href="#calibre_link-2261" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a>, <a data-type="index:locator" href="#calibre_link-2262" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> views)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIViewController</span>, <a data-type="index:locator" href="#calibre_link-2263" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a>, <a data-type="index:locator" href="#calibre_link-2264" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> view controller)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UIWindowScene</span>, <a data-type="index:locator" href="#calibre_link-2265" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">umbrella types</span>, <a data-type="index:locator" href="#calibre_link-2266" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Umbrella Types</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">underflow</span>, <a data-type="index:locator" href="#calibre_link-2267" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Arithmetic operations</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">underscore</span><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">argument label</span>, <a data-type="index:locator" href="#calibre_link-2268" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">External Parameter Names</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">assignment to</span>, <a data-type="index:locator" href="#calibre_link-2269" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function Parameters and Return Value</a>, <a data-type="index:locator" href="#calibre_link-2270" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">mop-up switch case</span>, <a data-type="index:locator" href="#calibre_link-2271" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">parameter name</span>, <a data-type="index:locator" href="#calibre_link-2272" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ignored Parameters</a>, <a data-type="index:locator" href="#calibre_link-2273" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function References and Selectors</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">anonymous function</span>, <a data-type="index:locator" href="#calibre_link-2274" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anonymous Function Abbreviated Syntax</a></li>
</ul></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Unicode</span>, <a data-type="index:locator" href="#calibre_link-2275" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UnicodeScalar</span>, <a data-type="index:locator" href="#calibre_link-2276" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unique an array</span>, <a data-type="index:locator" href="#calibre_link-2277" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Set</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Unit</span>, <a data-type="index:locator" href="#calibre_link-2278" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSMeasurement and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unit tests</span>, <a data-type="index:locator" href="#calibre_link-2279" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Testing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">universal app</span>, <a data-type="index:locator" href="#calibre_link-2280" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Permissible Runtime Environment</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">universal provisioning profile</span>, <a data-type="index:locator" href="#calibre_link-2281" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Automatic Signing</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unknown default</span>, <a data-type="index:locator" href="#calibre_link-2282" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NS_ENUM</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Unmanaged</span>, <a data-type="index:locator" href="#calibre_link-2283" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Memory Management of CFTypeRefs</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unowned references</span>, <a data-type="index:locator" href="#calibre_link-2284" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unowned references</a>, <a data-type="index:locator" href="#calibre_link-2285" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unregistering for a notification</span>, <a data-type="index:locator" href="#calibre_link-2286" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unregistering</a>, <a data-type="index:locator" href="#calibre_link-2287" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Notification Observers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unregistering for key&ndash;value observing</span>, <a data-type="index:locator" href="#calibre_link-2288" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unregistering</a>, <a data-type="index:locator" href="#calibre_link-2289" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">KVO Observers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unsafe references</span>, <a data-type="index:locator" href="#calibre_link-2290" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UnsafeMutablePointer</span>, <a data-type="index:locator" href="#calibre_link-2291" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Calling Objective-C with Modifiable Parameters</a>, <a data-type="index:locator" href="#calibre_link-2292" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UnsafeMutableRawPointer</span>, <a data-type="index:locator" href="#calibre_link-2293" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UnsafePointer</span>, <a data-type="index:locator" href="#calibre_link-2294" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-2295" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Arrays</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UnsafeRawPointer</span>, <a data-type="index:locator" href="#calibre_link-2296" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">casting to CFTypeRef</span>, <a data-type="index:locator" href="#calibre_link-2297" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">CFTypeRefs</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">unwrapping an Optional</span>, <a data-type="index:locator" href="#calibre_link-2298" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Unwrapping an Optional</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">updateValue</span>, <a data-type="index:locator" href="#calibre_link-2299" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary subscripting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">uppercased</span>, <a data-type="index:locator" href="#calibre_link-2300" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">URL</span>, <a data-type="index:locator" href="#calibre_link-2301" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">NSString and Friends</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">User Defined Runtime Attributes</span>, <a data-type="index:locator" href="#calibre_link-2302" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Additional Configuration of Nib-Based Instances</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">user events</span>, <a data-type="index:locator" href="#calibre_link-2303" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Reasons for Events</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UserDefaults</span>, <a data-type="index:locator" href="#calibre_link-2304" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Struct As Namespace</a>, <a data-type="index:locator" href="#calibre_link-2305" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Global Visibility</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">storing nonproperty-list types</span>, <a data-type="index:locator" href="#calibre_link-2306" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Codable</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">UTF-8, UTF-16, UTF-32</span>, <a data-type="index:locator" href="#calibre_link-2307" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">String</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Utilities pane</span>, <a data-type="index:locator" href="#calibre_link-2308" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Utilities Pane</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">V</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">value types</span>, <a data-type="index:locator" href="#calibre_link-2309" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Value Types and Reference Types</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">memory management</span>, <a data-type="index:locator" href="#calibre_link-2310" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exclusive Access to Value Types</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">values (dictionary)</span>, <a data-type="index:locator" href="#calibre_link-2311" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">var</span>, <a data-type="index:locator" href="#calibre_link-2312" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-2313" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a>, <a data-type="index:locator" href="#calibre_link-2314" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Class instances are mutable</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">variables</span>, <a data-type="index:locator" href="#calibre_link-2315" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-2316" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables and Simple Types</a>-<a data-type="index:locator" href="#calibre_link-2317" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Built-In Simple Types</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">coercion</span>, <a data-type="index:locator" href="#calibre_link-2318" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Numeric coercion</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">computed</span>, <a data-type="index:locator" href="#calibre_link-2319" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">declaration</span>, <a data-type="index:locator" href="#calibre_link-2320" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-2321" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">faÃ§ade</span>, <a data-type="index:locator" href="#calibre_link-2322" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Properties</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">functions as value of</span>, <a data-type="index:locator" href="#calibre_link-2323" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Function As Value</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">global</span>, <a data-type="index:locator" href="#calibre_link-2324" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Structure of a Swift File</a>, <a data-type="index:locator" href="#calibre_link-2325" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-2326" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">initialization</span>, <a data-type="index:locator" href="#calibre_link-2327" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">of Optional</span>, <a data-type="index:locator" href="#calibre_link-2328" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The keyword nil</a></li>
</ul></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lazy</span>, <a data-type="index:locator" href="#calibre_link-2329" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Lazy Initialization</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">lifetime</span>, <a data-type="index:locator" href="#calibre_link-2330" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-2331" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">local</span>, <a data-type="index:locator" href="#calibre_link-2332" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">read-only</span>, <a data-type="index:locator" href="#calibre_link-2333" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">scope</span>, <a data-type="index:locator" href="#calibre_link-2334" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Scope and Lifetime</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">setter observers</span>, <a data-type="index:locator" href="#calibre_link-2335" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Setter Observers</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">stored</span>, <a data-type="index:locator" href="#calibre_link-2336" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Computed Variables</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">swapping</span>, <a data-type="index:locator" href="#calibre_link-2337" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre82"><span data-type="index-term" class="publishername">type</span>, <a data-type="index:locator" href="#calibre_link-2338" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variables</a>, <a data-type="index:locator" href="#calibre_link-2339" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variable Declaration</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">vs. instance type</span>, <a data-type="index:locator" href="#calibre_link-2340" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Polymorphism</a></li>
</ul></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">variables list</span>, <a data-type="index:locator" href="#calibre_link-2341" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">The Navigator Pane</a>, <a data-type="index:locator" href="#calibre_link-2342" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">variadic parameters</span>, <a data-type="index:locator" href="#calibre_link-2343" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadic Parameters</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">Objective-C</span>, <a data-type="index:locator" href="#calibre_link-2344" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Variadics</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">version control</span>, <a data-type="index:locator" href="#calibre_link-2345" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Version Control</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">version string</span>, <a data-type="index:locator" href="#calibre_link-2346" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property List Settings</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">video previews</span>, <a data-type="index:locator" href="#calibre_link-2347" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Screenshots and Video Previews</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">view controller</span>, <a data-type="index:locator" href="#calibre_link-2348" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a>, <a data-type="index:locator" href="#calibre_link-2349" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a Main View</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">initial</span>, <a data-type="index:locator" href="#calibre_link-2350" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">How an App Gets Going</a>, <a data-type="index:locator" href="#calibre_link-2351" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a>, <a data-type="index:locator" href="#calibre_link-2352" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Loading a View Controller</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">view debugging</span>, <a data-type="index:locator" href="#calibre_link-2353" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Paused at a breakpoint</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">views</span>, <a data-type="index:locator" href="#calibre_link-2354" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">drawing</span>, <a data-type="index:locator" href="#calibre_link-2355" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Subclassing</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">visibility</span> (<span data-gentext="see" class="publishername">see</span> scope)</li>
<li class="calibre81"><span data-type="index-term" class="publishername">visibility, instance</span>, <a data-type="index:locator" href="#calibre_link-2356" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Visibility Through an Instance Property</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Void</span>, <a data-type="index:locator" href="#calibre_link-2357" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Void Return Type and Parameters</a>, <a data-type="index:locator" href="#calibre_link-2358" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Tuple</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">void</span>, <a data-type="index:locator" href="#calibre_link-2359" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">C Pointers</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">W</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">warnings, compiler</span>, <a data-type="index:locator" href="#calibre_link-2360" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Ground of Being</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">weak references</span>, <a data-type="index:locator" href="#calibre_link-2361" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Weak references</a>, <a data-type="index:locator" href="#calibre_link-2362" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Retain Cycles and Weak References</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">weak&ndash;strong dance</span>, <a data-type="index:locator" href="#calibre_link-2363" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Stored anonymous functions</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">where</span>, <a data-type="index:locator" href="#calibre_link-2364" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Where Clauses</a>, <a data-type="index:locator" href="#calibre_link-2365" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Extending Generics</a>, <a data-type="index:locator" href="#calibre_link-2366" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Switch statement</a>, <a data-type="index:locator" href="#calibre_link-2367" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">For loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">while</span>, <a data-type="index:locator" href="#calibre_link-2368" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">while case</span>, <a data-type="index:locator" href="#calibre_link-2369" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">while let</span>, <a data-type="index:locator" href="#calibre_link-2370" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">While loops</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">willSet</span>, <a data-type="index:locator" href="#calibre_link-2371" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Setter Observers</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">wrappers, property</span>, <a data-type="index:locator" href="#calibre_link-2372" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a>, <a data-type="index:locator" href="#calibre_link-2373" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Property Wrappers</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">X</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">xcloc bundle</span>, <a data-type="index:locator" href="#calibre_link-2374" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Exporting</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">Xcode</span>, <a data-type="index:locator" href="#calibre_link-2375" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Anatomy of an Xcode Project</a>-<a data-type="index:locator" href="#calibre_link-2376" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Submission to the App Store</a><ul class="calibre48"><li class="calibre82">(<span data-gentext="see" class="publishername">see also</span> nib editor)</li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">xib files</span>, <a data-type="index:locator" href="#calibre_link-2377" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Nib Files</a><ul class="calibre48"><li class="calibre82"><span data-type="index-term" class="publishername">editing</span>, <a data-type="index:locator" href="#calibre_link-2378" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Document Outline</a></li>
</ul></li>
<li class="calibre81"><span data-type="index-term" class="publishername">xliff files</span>, <a data-type="index:locator" href="#calibre_link-2379" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Localization</a></li>
</ul>
</div>
<div data-type="indexdiv" class="preface"><h3 class="calibre80">Z</h3>
<ul class="calibre48"><li class="calibre81"><span data-type="index-term" class="publishername">zip</span>, <a data-type="index:locator" href="#calibre_link-2380" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Dictionary</a></li>
<li class="calibre81"><span data-type="index-term" class="publishername">zombies</span>, <a data-type="index:locator" href="#calibre_link-2381" class="pcalibre1 pcalibre calibre5 pcalibre3 pcalibre2">Debugging Memory Management Mistakes</a></li>
</ul>
</div>
</div>
</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-52">
<div id="calibre_link-3030" class="calibre1"><section data-type="colophon" {http://www.idpf.org/2007/ops}type="colophon" class="calibre2" data-pdf-bookmark="About the Author"><div class="preface" id="calibre_link-3031">
  <h1 class="calibre10">About the Author</h1>
    <p class="author1"><strong class="calibre20">Matt Neuburg</strong> started programming computers in 1968, when he was 14 years old, as a member of a literally underground high school club, which met once a week to do timesharing on a bank of PDP-10s by way of primitive teletype machines. He also occasionally used Princeton Universityâ€™s IBM-360/67, but gave it up in frustration when one day he dropped his punch cards. He majored in Greek at Swarthmore College, and received his PhD from Cornell University in 1981, writing his doctoral dissertation (about Aeschylus) on a mainframe. He proceeded to teach Classical languages, literature, and culture at many well-known institutions of higher learning, most of which now disavow knowledge of his existence, and to publish numerous scholarly articles unlikely to interest anyone. Meanwhile he obtained an Apple IIc and became hopelessly hooked on computers again, migrating to a Macintosh in 1990. He wrote some educational and utility freeware, became an early regular contributor to the online journal <em class="calibre11">TidBITS</em>, and in 1995 left academe to edit <em class="calibre11">MacTech</em> magazine. In August 1996 he became a freelancer, which means he has been looking for work ever since. He is the author of <em class="calibre11">Frontier: The Definitive Guide</em>, <em class="calibre11">REALbasic: The Definitive Guide</em>, and <em class="calibre11">AppleScript: The Definitive Guide</em>, as well as <em class="calibre11">Programming iOS 12</em> (all for Oâ€™Reilly Media).</p>
</div>
</section>
</div>
</div>


<div class="calibre" id="calibre_link-92">
<div id="calibre_link-3032" class="calibre1"><section data-type="colophon" {http://www.idpf.org/2007/ops}type="colophon" data-pdf-bookmark="Colophon" class="calibre2"><div class="preface" id="calibre_link-3033">
<h1 class="calibre10">Colophon</h1>

<p class="author1">The animal on the cover of <em class="calibre11">iOS 13 Programming Fundamentals with Swift</em> is a harp seal (<em class="calibre11">Pagophilus groenlandicus</em>), a Latin name that translates to â€œice-lover from Greenland.â€ These animals are native to the northern Atlantic and Arctic Oceans, and spend most of their time in the water, only going onto ice packs to give birth and molt. As earless (â€œtrueâ€) seals, their streamlined bodies and energy-efficient swimming style make them well-equipped for aquatic life. While eared seal species like sea lions are powerful swimmers, they are considered semiaquatic because they mate and rest on land.</p>

<p class="author1">The harp seal has silvery-gray fur, with a large black marking on its back that resembles a harp or wishbone. They grow to be 5&ndash;6 feet long, and weigh 300&ndash;400 pounds as adults. Due to their cold habitat, they have a thick coat of blubber for insulation. A harp sealâ€™s diet is very varied, including several species of fish and crustaceans. They can remain underwater for an average of 16 minutes to hunt for food and are able to dive several hundred feet.</p>

<p class="author1">Harp seal pups are born without any protective fat, but are kept warm by their white coat, which absorbs heat from the sun. After nursing for 12 days, the seal pups are abandoned, having tripled their weight due to their motherâ€™s high-fat milk. In the subsequent weeks until they are able to swim off the ice, the pups are very vulnerable to predators and will lose nearly half of their weight. Those that survive reach maturity after 4&ndash;8 years (depending on their sex) and have an average lifespan of 35 years.</p>

<p class="author1">Harp seals are hunted commercially off the coasts of Canada, Norway, Russia, and Greenland for their meat, oil, and fur. Though some of these governments have regulations and enforce hunting quotas, it is believed that the number of animals killed every year is underreported. Public outcry and efforts by conservationists have resulted in a decline in market demand for seal pelts and other products, however.</p>

<p class="author1">The cover illustration is by Karen Montgomery, based on a black and white engraving from Woodâ€™s <em class="calibre11">Animate Creation</em>. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maagâ€™s Ubuntu Mono.</p>
</div>
</section>
</div>
</div>


</body></html>