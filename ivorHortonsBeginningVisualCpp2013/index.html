<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>ivor Horton’s Beginning Visual C++® 2013</title></head><body><div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-236">
<nav class="toclist" {http://www.idpf.org/2007/ops}type="toc" id="calibre_link-1348">
<h1 class="calibre1">Contents</h1>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-237" class="calibre3">Chapter 1: Programming with Visual C++</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-238" class="calibre3">Learning with Visual C++</a></li>
<li class="contentsh"><a href="#calibre_link-239" class="calibre3">Writing C++ Applications</a></li>
<li class="contentsh"><a href="#calibre_link-240" class="calibre3">Learning Desktop Applications Programming</a></li>
<li class="contentsh"><a href="#calibre_link-241" class="calibre3">The Integrated Development Environment</a></li>
<li class="contentsh"><a href="#calibre_link-242" class="calibre3">Using the IDE</a></li>
<li class="contentsh"><a href="#calibre_link-243" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-46" class="calibre3">Chapter 2: Data, Variables, and Calculations</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-244" class="calibre3">The Structure of a C++ Program</a></li>
<li class="contentsh"><a href="#calibre_link-245" class="calibre3">Defining Variables</a></li>
<li class="contentsh"><a href="#calibre_link-246" class="calibre3">Fundamental Data Types</a></li>
<li class="contentsh"><a href="#calibre_link-247" class="calibre3">Basic Input/Output Operations</a></li>
<li class="contentsh"><a href="#calibre_link-248" class="calibre3">Calculating in C++</a></li>
<li class="contentsh"><a href="#calibre_link-249" class="calibre3">Type Conversion and Casting</a></li>
<li class="contentsh"><a href="#calibre_link-250" class="calibre3">The auto Keyword</a></li>
<li class="contentsh"><a href="#calibre_link-251" class="calibre3">Discovering Types</a></li>
<li class="contentsh"><a href="#calibre_link-252" class="calibre3">The Bitwise Operators</a></li>
<li class="contentsh"><a href="#calibre_link-253" class="calibre3">Introducing Lvalues and Rvalues</a></li>
<li class="contentsh"><a href="#calibre_link-254" class="calibre3">Understanding Storage Duration and Scope</a></li>
<li class="contentsh"><a href="#calibre_link-255" class="calibre3">Variables with Specific Sets of Values</a></li>
<li class="contentsh"><a href="#calibre_link-256" class="calibre3">Namespaces</a></li>
<li class="contentsh"><a href="#calibre_link-257" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-32" class="calibre3">Chapter 3: Decisions and Loops</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-258" class="calibre3">Comparing Values</a></li>
<li class="contentsh"><a href="#calibre_link-259" class="calibre3">Repeating a Block of Statements</a></li>
<li class="contentsh"><a href="#calibre_link-260" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-154" class="calibre3">Chapter 4: Arrays, Strings, and Pointers</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-261" class="calibre3">Handling Multiple Data Values of the Same Type</a></li>
<li class="contentsh"><a href="#calibre_link-262" class="calibre3">Working with C-Style Strings</a></li>
<li class="contentsh"><a href="#calibre_link-263" class="calibre3">Indirect Data Access</a></li>
<li class="contentsh"><a href="#calibre_link-264" class="calibre3">Dynamic Memory Allocation</a></li>
<li class="contentsh"><a href="#calibre_link-265" class="calibre3">Using References</a></li>
<li class="contentsh"><a href="#calibre_link-266" class="calibre3">Library Functions for Strings</a></li>
<li class="contentsh"><a href="#calibre_link-267" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-2" class="calibre3">Chapter 5: Introducing Structure into Your Programs</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-268" class="calibre3">Understanding Functions</a></li>
<li class="contentsh"><a href="#calibre_link-269" class="calibre3">Passing Arguments to a Function</a></li>
<li class="contentsh"><a href="#calibre_link-270" class="calibre3">Returning Values from a Function</a></li>
<li class="contentsh"><a href="#calibre_link-271" class="calibre3">Recursive Function Calls</a></li>
<li class="contentsh"><a href="#calibre_link-272" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-171" class="calibre3">Chapter 6: More about Program Structure</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-273" class="calibre3">Pointers to Functions</a></li>
<li class="contentsh"><a href="#calibre_link-274" class="calibre3">Initializing Function Parameters</a></li>
<li class="contentsh"><a href="#calibre_link-275" class="calibre3">Exceptions</a></li>
<li class="contentsh"><a href="#calibre_link-276" class="calibre3">Handling Memory Allocation Errors</a></li>
<li class="contentsh"><a href="#calibre_link-277" class="calibre3">Function Overloading</a></li>
<li class="contentsh"><a href="#calibre_link-278" class="calibre3">Function Templates</a></li>
<li class="contentsh"><a href="#calibre_link-279" class="calibre3">Using the decltype Operator</a></li>
<li class="contentsh"><a href="#calibre_link-280" class="calibre3">An Example Using Functions</a></li>
<li class="contentsh"><a href="#calibre_link-281" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-282" class="calibre3">Chapter 7: Defining Your Own Data Types</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-283" class="calibre3">The struct in C++</a></li>
<li class="contentsh"><a href="#calibre_link-284" class="calibre3">Types, Objects, Classes, and Instances</a></li>
<li class="contentsh"><a href="#calibre_link-285" class="calibre3">Understanding Classes</a></li>
<li class="contentsh"><a href="#calibre_link-286" class="calibre3">Class Constructors</a></li>
<li class="contentsh"><a href="#calibre_link-287" class="calibre3">Private Members of a Class</a></li>
<li class="contentsh"><a href="#calibre_link-288" class="calibre3">The Pointer this</a></li>
<li class="contentsh"><a href="#calibre_link-289" class="calibre3">Const Objects</a></li>
<li class="contentsh"><a href="#calibre_link-290" class="calibre3">Arrays of Objects</a></li>
<li class="contentsh"><a href="#calibre_link-291" class="calibre3">Static Members of a Class</a></li>
<li class="contentsh"><a href="#calibre_link-292" class="calibre3">Pointers and References to Objects</a></li>
<li class="contentsh"><a href="#calibre_link-293" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-294" class="calibre3">Chapter 8: More on Classes</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-295" class="calibre3">Class Destructors</a></li>
<li class="contentsh"><a href="#calibre_link-296" class="calibre3">Implementing a Copy Constructor</a></li>
<li class="contentsh"><a href="#calibre_link-297" class="calibre3">Operator Overloading</a></li>
<li class="contentsh"><a href="#calibre_link-298" class="calibre3">The Object Copying Problem</a></li>
<li class="contentsh"><a href="#calibre_link-299" class="calibre3">Default Class Members</a></li>
<li class="contentsh"><a href="#calibre_link-300" class="calibre3">Class Templates</a></li>
<li class="contentsh"><a href="#calibre_link-301" class="calibre3">Perfect Forwarding</a></li>
<li class="contentsh"><a href="#calibre_link-302" class="calibre3">Default Arguments for Template Parameters</a></li>
<li class="contentsh"><a href="#calibre_link-303" class="calibre3">Aliases for Class Templates</a></li>
<li class="contentsh"><a href="#calibre_link-304" class="calibre3">Template Specialization</a></li>
<li class="contentsh"><a href="#calibre_link-305" class="calibre3">Using Classes</a></li>
<li class="contentsh"><a href="#calibre_link-306" class="calibre3">Organizing Your Program Code</a></li>
<li class="contentsh"><a href="#calibre_link-307" class="calibre3">Library Classes for Strings</a></li>
<li class="contentsh"><a href="#calibre_link-308" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-190" class="calibre3">Chapter 9: Class Inheritance and Virtual Functions</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-309" class="calibre3">Object-Oriented Programming Basics</a></li>
<li class="contentsh"><a href="#calibre_link-310" class="calibre3">Inheritance in Classes</a></li>
<li class="contentsh"><a href="#calibre_link-311" class="calibre3">Access Control Under Inheritance</a></li>
<li class="contentsh"><a href="#calibre_link-312" class="calibre3">The Copy Constructor in a Derived Class</a></li>
<li class="contentsh"><a href="#calibre_link-313" class="calibre3">Preventing Class Derivation</a></li>
<li class="contentsh"><a href="#calibre_link-314" class="calibre3">Class Members as Friends</a></li>
<li class="contentsh"><a href="#calibre_link-315" class="calibre3">Virtual Functions</a></li>
<li class="contentsh"><a href="#calibre_link-316" class="calibre3">Casting Between Class Types</a></li>
<li class="contentsh"><a href="#calibre_link-317" class="calibre3">Nested Classes</a></li>
<li class="contentsh"><a href="#calibre_link-318" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-319" class="calibre3">Chapter 10: The Standard Template Library</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-320" class="calibre3">What Is the Standard Template Library?</a></li>
<li class="contentsh"><a href="#calibre_link-321" class="calibre3">Smart Pointers</a></li>
<li class="contentsh"><a href="#calibre_link-322" class="calibre3">Algorithms</a></li>
<li class="contentsh"><a href="#calibre_link-323" class="calibre3">Function Objects in the STL</a></li>
<li class="contentsh"><a href="#calibre_link-324" class="calibre3">Function Adapters</a></li>
<li class="contentsh"><a href="#calibre_link-325" class="calibre3">The Range of STL Containers</a></li>
<li class="contentsh"><a href="#calibre_link-326" class="calibre3">Sequence Containers</a></li>
<li class="contentsh"><a href="#calibre_link-327" class="calibre3">Associative Containers</a></li>
<li class="contentsh"><a href="#calibre_link-328" class="calibre3">More on Iterators</a></li>
<li class="contentsh"><a href="#calibre_link-329" class="calibre3">More on Function Objects</a></li>
<li class="contentsh"><a href="#calibre_link-330" class="calibre3">More on Algorithms</a></li>
<li class="contentsh"><a href="#calibre_link-331" class="calibre3">Type Traits and Static Assertions</a></li>
<li class="contentsh"><a href="#calibre_link-332" class="calibre3">Lambda Expressions</a></li>
<li class="contentsh"><a href="#calibre_link-333" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-20" class="calibre3">Chapter 11: Windows Programming Concepts</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-334" class="calibre3">Windows Programming Basics</a></li>
<li class="contentsh"><a href="#calibre_link-335" class="calibre3">The Structure of a Windows Program</a></li>
<li class="contentsh"><a href="#calibre_link-336" class="calibre3">The Microsoft Foundation Classes</a></li>
<li class="contentsh"><a href="#calibre_link-337" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-338" class="calibre3">Chapter 12: Windows Programming with the Microsoft Foundation Classes (MFC)</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-339" class="calibre3">The MFC Document/View Concept</a></li>
<li class="contentsh"><a href="#calibre_link-340" class="calibre3">Creating MFC Applications</a></li>
<li class="contentsh"><a href="#calibre_link-341" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-70" class="calibre3">Chapter 13: Working with Menus and Toolbars</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-342" class="calibre3">Communicating with Windows</a></li>
<li class="contentsh"><a href="#calibre_link-343" class="calibre3">Extending the Sketcher Program</a></li>
<li class="contentsh"><a href="#calibre_link-344" class="calibre3">Elements of a Menu</a></li>
<li class="contentsh"><a href="#calibre_link-345" class="calibre3">Adding Menu Message Handlers</a></li>
<li class="contentsh"><a href="#calibre_link-346" class="calibre3">Adding Toolbar Buttons</a></li>
<li class="contentsh"><a href="#calibre_link-347" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-100" class="calibre3">Chapter 14: Drawing in a Window</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-348" class="calibre3">Basics of Drawing in a Window</a></li>
<li class="contentsh"><a href="#calibre_link-349" class="calibre3">The MFC Drawing Mechanism</a></li>
<li class="contentsh"><a href="#calibre_link-350" class="calibre3">Drawing Graphics in Practice</a></li>
<li class="contentsh"><a href="#calibre_link-351" class="calibre3">Programming for the Mouse</a></li>
<li class="contentsh"><a href="#calibre_link-352" class="calibre3">Drawing a Sketch</a></li>
<li class="contentsh"><a href="#calibre_link-353" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-11" class="calibre3">Chapter 15: Improving the View</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-354" class="calibre3">Sketcher Limitations</a></li>
<li class="contentsh"><a href="#calibre_link-355" class="calibre3">Improving the View</a></li>
<li class="contentsh"><a href="#calibre_link-356" class="calibre3">Deleting and Moving Elements</a></li>
<li class="contentsh"><a href="#calibre_link-357" class="calibre3">Implementing a Context Menu</a></li>
<li class="contentsh"><a href="#calibre_link-358" class="calibre3">Identifying an Element under the Cursor</a></li>
<li class="contentsh"><a href="#calibre_link-359" class="calibre3">Dealing with Masked Elements</a></li>
<li class="contentsh"><a href="#calibre_link-360" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-203" class="calibre3">Chapter 16: Working with Dialogs and Controls</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-361" class="calibre3">Understanding Dialogs</a></li>
<li class="contentsh"><a href="#calibre_link-362" class="calibre3">Understanding Controls</a></li>
<li class="contentsh"><a href="#calibre_link-363" class="calibre3">Creating a Dialog Resource</a></li>
<li class="contentsh"><a href="#calibre_link-364" class="calibre3">Programming for a Dialog</a></li>
<li class="contentsh"><a href="#calibre_link-365" class="calibre3">Supporting the Dialog Controls</a></li>
<li class="contentsh"><a href="#calibre_link-366" class="calibre3">Completing Dialog Operations</a></li>
<li class="contentsh"><a href="#calibre_link-367" class="calibre3">Using a Spin Button Control</a></li>
<li class="contentsh"><a href="#calibre_link-368" class="calibre3">Using the Scale Factor</a></li>
<li class="contentsh"><a href="#calibre_link-369" class="calibre3">Working with Status Bars</a></li>
<li class="contentsh"><a href="#calibre_link-370" class="calibre3">The CString Class</a></li>
<li class="contentsh"><a href="#calibre_link-371" class="calibre3">Using an Edit Box Control</a></li>
<li class="contentsh"><a href="#calibre_link-372" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-135" class="calibre3">Chapter 17: Storing and Printing Documents</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-373" class="calibre3">Understanding Serialization</a></li>
<li class="contentsh"><a href="#calibre_link-374" class="calibre3">Serializing a Document</a></li>
<li class="contentsh"><a href="#calibre_link-375" class="calibre3">Applying Serialization</a></li>
<li class="contentsh"><a href="#calibre_link-376" class="calibre3">Exercising Serialization</a></li>
<li class="contentsh"><a href="#calibre_link-377" class="calibre3">Printing a Document</a></li>
<li class="contentsh"><a href="#calibre_link-378" class="calibre3">Implementing Multipage Printing</a></li>
<li class="contentsh"><a href="#calibre_link-379" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-380" class="calibre3">Chapter 18: Programming for Windows 8</a>
<ol class="calibre2">
<li class="contentsh"><a href="#calibre_link-381" class="calibre3">Windows Store Applications</a></li>
<li class="contentsh"><a href="#calibre_link-382" class="calibre3">Developing Windows Store Apps</a></li>
<li class="contentsh"><a href="#calibre_link-383" class="calibre3">Windows Runtime Concepts</a></li>
<li class="contentsh"><a href="#calibre_link-384" class="calibre3">C++ Component Extensions (C++/CX)</a></li>
<li class="contentsh"><a href="#calibre_link-385" class="calibre3">The Extensible Application Markup Language (XAML)</a></li>
<li class="contentsh"><a href="#calibre_link-386" class="calibre3">Creating a Windows Store App</a></li>
<li class="contentsh"><a href="#calibre_link-387" class="calibre3">Scaling UI Elements</a></li>
<li class="contentsh"><a href="#calibre_link-388" class="calibre3">Transitions</a></li>
<li class="contentsh"><a href="#calibre_link-389" class="calibre3">Summary</a></li></ol></li>
<li class="contentsh"><a href="#calibre_link-0" class="calibre3">Introduction</a></li>
<li class="contentsh"><a href="#calibre_link-390" class="calibre3">Advertisement</a></li>
<li class="contentsh"><a href="#calibre_link-391" class="calibre3">End User License Agreement</a></li>
</ol>
</nav>
<nav {http://www.idpf.org/2007/ops}type="loi" class="toclist">
<h2 class="calibre4">List of Illustrations</h2>
<ol class="calibre5">
<li class="contentsh1"><a href="#calibre_link-392" class="calibre3">FIGURE 1-1</a></li>
<li class="contentsh1"><a href="#calibre_link-393" class="calibre3">FIGURE 1-2</a></li>
<li class="contentsh1"><a href="#calibre_link-394" class="calibre3">FIGURE 1-3</a></li>
<li class="contentsh1"><a href="#calibre_link-395" class="calibre3">FIGURE 1-4</a></li>
<li class="contentsh1"><a href="#calibre_link-396" class="calibre3">FIGURE 1-5</a></li>
<li class="contentsh1"><a href="#calibre_link-397" class="calibre3">FIGURE 1-6</a></li>
<li class="contentsh1"><a href="#calibre_link-398" class="calibre3">FIGURE 1-7</a></li>
<li class="contentsh1"><a href="#calibre_link-399" class="calibre3">FIGURE 1-8</a></li>
<li class="contentsh1"><a href="#calibre_link-400" class="calibre3">FIGURE 1-9</a></li>
<li class="contentsh1"><a href="#calibre_link-401" class="calibre3">FIGURE 1-10</a></li>
<li class="contentsh1"><a href="#calibre_link-402" class="calibre3">FIGURE 1-11</a></li>
<li class="contentsh1"><a href="#calibre_link-403" class="calibre3">FIGURE 1-12</a></li>
<li class="contentsh1"><a href="#calibre_link-404" class="calibre3">FIGURE 1-13</a></li>
<li class="contentsh1"><a href="#calibre_link-47" class="calibre3">FIGURE 2-1</a></li>
<li class="contentsh1"><a href="#calibre_link-49" class="calibre3">FIGURE 2-2</a></li>
<li class="contentsh1"><a href="#calibre_link-51" class="calibre3">FIGURE 2-3</a></li>
<li class="contentsh1"><a href="#calibre_link-53" class="calibre3">FIGURE 2-4</a></li>
<li class="contentsh1"><a href="#calibre_link-55" class="calibre3">FIGURE 2-5</a></li>
<li class="contentsh1"><a href="#calibre_link-57" class="calibre3">FIGURE 2-6</a></li>
<li class="contentsh1"><a href="#calibre_link-59" class="calibre3">FIGURE 2-7</a></li>
<li class="contentsh1"><a href="#calibre_link-61" class="calibre3">FIGURE 2-8</a></li>
<li class="contentsh1"><a href="#calibre_link-63" class="calibre3">FIGURE 2-9</a></li>
<li class="contentsh1"><a href="#calibre_link-65" class="calibre3">FIGURE 2-10</a></li>
<li class="contentsh1"><a href="#calibre_link-67" class="calibre3">FIGURE 2-11</a></li>
<li class="contentsh1"><a href="#calibre_link-33" class="calibre3">FIGURE 3-1</a></li>
<li class="contentsh1"><a href="#calibre_link-35" class="calibre3">FIGURE 3-2</a></li>
<li class="contentsh1"><a href="#calibre_link-37" class="calibre3">FIGURE 3-3</a></li>
<li class="contentsh1"><a href="#calibre_link-39" class="calibre3">FIGURE 3-4</a></li>
<li class="contentsh1"><a href="#calibre_link-41" class="calibre3">FIGURE 3-5</a></li>
<li class="contentsh1"><a href="#calibre_link-43" class="calibre3">FIGURE 3-6</a></li>
<li class="contentsh1"><a href="#calibre_link-155" class="calibre3">FIGURE 4-1</a></li>
<li class="contentsh1"><a href="#calibre_link-157" class="calibre3">FIGURE 4-2</a></li>
<li class="contentsh1"><a href="#calibre_link-159" class="calibre3">FIGURE 4-3</a></li>
<li class="contentsh1"><a href="#calibre_link-161" class="calibre3">FIGURE 4-4</a></li>
<li class="contentsh1"><a href="#calibre_link-163" class="calibre3">FIGURE 4-5</a></li>
<li class="contentsh1"><a href="#calibre_link-165" class="calibre3">FIGURE 4-6</a></li>
<li class="contentsh1"><a href="#calibre_link-167" class="calibre3">FIGURE 4-7</a></li>
<li class="contentsh1"><a href="#calibre_link-169" class="calibre3">FIGURE 4-8</a></li>
<li class="contentsh1"><a href="#calibre_link-3" class="calibre3">FIGURE 5-1</a></li>
<li class="contentsh1"><a href="#calibre_link-5" class="calibre3">FIGURE 5-2</a></li>
<li class="contentsh1"><a href="#calibre_link-7" class="calibre3">FIGURE 5-3</a></li>
<li class="contentsh1"><a href="#calibre_link-9" class="calibre3">FIGURE 5-4</a></li>
<li class="contentsh1"><a href="#calibre_link-172" class="calibre3">FIGURE 6-1</a></li>
<li class="contentsh1"><a href="#calibre_link-174" class="calibre3">FIGURE 6-2</a></li>
<li class="contentsh1"><a href="#calibre_link-176" class="calibre3">FIGURE 6-3</a></li>
<li class="contentsh1"><a href="#calibre_link-178" class="calibre3">FIGURE 6-4</a></li>
<li class="contentsh1"><a href="#calibre_link-180" class="calibre3">FIGURE 6-5</a></li>
<li class="contentsh1"><a href="#calibre_link-182" class="calibre3">FIGURE 6-6</a></li>
<li class="contentsh1"><a href="#calibre_link-184" class="calibre3">FIGURE 6-7</a></li>
<li class="contentsh1"><a href="#calibre_link-186" class="calibre3">FIGURE 6-8</a></li>
<li class="contentsh1"><a href="#calibre_link-23" class="calibre3">FIGURE 7-1</a></li>
<li class="contentsh1"><a href="#calibre_link-405" class="calibre3">FIGURE 7-2</a></li>
<li class="contentsh1"><a href="#calibre_link-406" class="calibre3">FIGURE 7-3</a></li>
<li class="contentsh1"><a href="#calibre_link-407" class="calibre3">FIGURE 7-4</a></li>
<li class="contentsh1"><a href="#calibre_link-408" class="calibre3">FIGURE 7-5</a></li>
<li class="contentsh1"><a href="#calibre_link-409" class="calibre3">FIGURE 7-6</a></li>
<li class="contentsh1"><a href="#calibre_link-410" class="calibre3">FIGURE 7-7</a></li>
<li class="contentsh1"><a href="#calibre_link-411" class="calibre3">FIGURE 8-1</a></li>
<li class="contentsh1"><a href="#calibre_link-412" class="calibre3">FIGURE 8-2</a></li>
<li class="contentsh1"><a href="#calibre_link-413" class="calibre3">FIGURE 8-3</a></li>
<li class="contentsh1"><a href="#calibre_link-414" class="calibre3">FIGURE 8-4</a></li>
<li class="contentsh1"><a href="#calibre_link-415" class="calibre3">FIGURE 8-5</a></li>
<li class="contentsh1"><a href="#calibre_link-416" class="calibre3">FIGURE 8-6</a></li>
<li class="contentsh1"><a href="#calibre_link-417" class="calibre3">FIGURE 8-7</a></li>
<li class="contentsh1"><a href="#calibre_link-418" class="calibre3">FIGURE 8-8</a></li>
<li class="contentsh1"><a href="#calibre_link-419" class="calibre3">FIGURE 8-9</a></li>
<li class="contentsh1"><a href="#calibre_link-420" class="calibre3">FIGURE 8-10</a></li>
<li class="contentsh1"><a href="#calibre_link-191" class="calibre3">FIGURE 9-1</a></li>
<li class="contentsh1"><a href="#calibre_link-193" class="calibre3">FIGURE 9-2</a></li>
<li class="contentsh1"><a href="#calibre_link-195" class="calibre3">FIGURE 9-3</a></li>
<li class="contentsh1"><a href="#calibre_link-197" class="calibre3">FIGURE 9-4</a></li>
<li class="contentsh1"><a href="#calibre_link-199" class="calibre3">FIGURE 9-5</a></li>
<li class="contentsh1"><a href="#calibre_link-201" class="calibre3">FIGURE 9-6</a></li>
<li class="contentsh1"><a href="#calibre_link-421" class="calibre3">FIGURE 10-1</a></li>
<li class="contentsh1"><a href="#calibre_link-422" class="calibre3">FIGURE 10-2</a></li>
<li class="contentsh1"><a href="#calibre_link-423" class="calibre3">FIGURE 10-3</a></li>
<li class="contentsh1"><a href="#calibre_link-424" class="calibre3">FIGURE 10-4</a></li>
<li class="contentsh1"><a href="#calibre_link-21" class="calibre3">FIGURE 11-1</a></li>
<li class="contentsh1"><a href="#calibre_link-24" class="calibre3">FIGURE 11-2</a></li>
<li class="contentsh1"><a href="#calibre_link-26" class="calibre3">FIGURE 11-3</a></li>
<li class="contentsh1"><a href="#calibre_link-28" class="calibre3">FIGURE 11-4</a></li>
<li class="contentsh1"><a href="#calibre_link-30" class="calibre3">FIGURE 11-5</a></li>
<li class="contentsh1"><a href="#calibre_link-425" class="calibre3">FIGURE 12-1</a></li>
<li class="contentsh1"><a href="#calibre_link-426" class="calibre3">FIGURE 12-2</a></li>
<li class="contentsh1"><a href="#calibre_link-427" class="calibre3">FIGURE 12-3</a></li>
<li class="contentsh1"><a href="#calibre_link-428" class="calibre3">FIGURE 12-4</a></li>
<li class="contentsh1"><a href="#calibre_link-429" class="calibre3">FIGURE 12-5</a></li>
<li class="contentsh1"><a href="#calibre_link-430" class="calibre3">FIGURE 12-6</a></li>
<li class="contentsh1"><a href="#calibre_link-431" class="calibre3">FIGURE 12-7</a></li>
<li class="contentsh1"><a href="#calibre_link-432" class="calibre3">FIGURE 12-8</a></li>
<li class="contentsh1"><a href="#calibre_link-433" class="calibre3">FIGURE 12-9</a></li>
<li class="contentsh1"><a href="#calibre_link-434" class="calibre3">FIGURE 12-10</a></li>
<li class="contentsh1"><a href="#calibre_link-435" class="calibre3">FIGURE 12-11</a></li>
<li class="contentsh1"><a href="#calibre_link-436" class="calibre3">FIGURE 12-12</a></li>
<li class="contentsh1"><a href="#calibre_link-437" class="calibre3">FIGURE 12-13</a></li>
<li class="contentsh1"><a href="#calibre_link-71" class="calibre3">FIGURE 13-1</a></li>
<li class="contentsh1"><a href="#calibre_link-73" class="calibre3">FIGURE 13-2</a></li>
<li class="contentsh1"><a href="#calibre_link-75" class="calibre3">FIGURE 13-3</a></li>
<li class="contentsh1"><a href="#calibre_link-77" class="calibre3">FIGURE 13-4</a></li>
<li class="contentsh1"><a href="#calibre_link-79" class="calibre3">FIGURE 13-5</a></li>
<li class="contentsh1"><a href="#calibre_link-81" class="calibre3">FIGURE 13-6</a></li>
<li class="contentsh1"><a href="#calibre_link-83" class="calibre3">FIGURE 13-7</a></li>
<li class="contentsh1"><a href="#calibre_link-85" class="calibre3">FIGURE 13-8</a></li>
<li class="contentsh1"><a href="#calibre_link-87" class="calibre3">FIGURE 13-9</a></li>
<li class="contentsh1"><a href="#calibre_link-89" class="calibre3">FIGURE 13-10</a></li>
<li class="contentsh1"><a href="#calibre_link-91" class="calibre3">FIGURE 13-11</a></li>
<li class="contentsh1"><a href="#calibre_link-93" class="calibre3">FIGURE 13-12</a></li>
<li class="contentsh1"><a href="#calibre_link-95" class="calibre3">FIGURE 13-13</a></li>
<li class="contentsh1"><a href="#calibre_link-97" class="calibre3">FIGURE 13-14</a></li>
<li class="contentsh1"><a href="#calibre_link-101" class="calibre3">FIGURE 14-1</a></li>
<li class="contentsh1"><a href="#calibre_link-103" class="calibre3">FIGURE 14-2</a></li>
<li class="contentsh1"><a href="#calibre_link-105" class="calibre3">FIGURE 14-3</a></li>
<li class="contentsh1"><a href="#calibre_link-107" class="calibre3">FIGURE 14-4</a></li>
<li class="contentsh1"><a href="#calibre_link-109" class="calibre3">FIGURE 14-5</a></li>
<li class="contentsh1"><a href="#calibre_link-111" class="calibre3">FIGURE 14-6</a></li>
<li class="contentsh1"><a href="#calibre_link-113" class="calibre3">FIGURE 14-7</a></li>
<li class="contentsh1"><a href="#calibre_link-115" class="calibre3">FIGURE 14-8</a></li>
<li class="contentsh1"><a href="#calibre_link-117" class="calibre3">FIGURE 14-9</a></li>
<li class="contentsh1"><a href="#calibre_link-119" class="calibre3">FIGURE 14-10</a></li>
<li class="contentsh1"><a href="#calibre_link-121" class="calibre3">FIGURE 14-11</a></li>
<li class="contentsh1"><a href="#calibre_link-123" class="calibre3">FIGURE 14-12</a></li>
<li class="contentsh1"><a href="#calibre_link-125" class="calibre3">FIGURE 14-13</a></li>
<li class="contentsh1"><a href="#calibre_link-127" class="calibre3">FIGURE 14-14</a></li>
<li class="contentsh1"><a href="#calibre_link-129" class="calibre3">FIGURE 14-15</a></li>
<li class="contentsh1"><a href="#calibre_link-131" class="calibre3">FIGURE 14-16</a></li>
<li class="contentsh1"><a href="#calibre_link-133" class="calibre3">FIGURE 14-17</a></li>
<li class="contentsh1"><a href="#calibre_link-12" class="calibre3">FIGURE 15-1</a></li>
<li class="contentsh1"><a href="#calibre_link-14" class="calibre3">FIGURE 15-2</a></li>
<li class="contentsh1"><a href="#calibre_link-16" class="calibre3">FIGURE 15-3</a></li>
<li class="contentsh1"><a href="#calibre_link-18" class="calibre3">FIGURE 15-4</a></li>
<li class="contentsh1"><a href="#calibre_link-204" class="calibre3">FIGURE 16-1</a></li>
<li class="contentsh1"><a href="#calibre_link-206" class="calibre3">FIGURE 16-2</a></li>
<li class="contentsh1"><a href="#calibre_link-208" class="calibre3">FIGURE 16-3</a></li>
<li class="contentsh1"><a href="#calibre_link-210" class="calibre3">FIGURE 16-4</a></li>
<li class="contentsh1"><a href="#calibre_link-212" class="calibre3">FIGURE 16-5</a></li>
<li class="contentsh1"><a href="#calibre_link-214" class="calibre3">FIGURE 16-6</a></li>
<li class="contentsh1"><a href="#calibre_link-216" class="calibre3">FIGURE 16-7</a></li>
<li class="contentsh1"><a href="#calibre_link-218" class="calibre3">FIGURE 16-8</a></li>
<li class="contentsh1"><a href="#calibre_link-220" class="calibre3">FIGURE 16-9</a></li>
<li class="contentsh1"><a href="#calibre_link-222" class="calibre3">FIGURE 16-10</a></li>
<li class="contentsh1"><a href="#calibre_link-224" class="calibre3">FIGURE 16-11</a></li>
<li class="contentsh1"><a href="#calibre_link-226" class="calibre3">FIGURE 16-12</a></li>
<li class="contentsh1"><a href="#calibre_link-228" class="calibre3">FIGURE 16-13</a></li>
<li class="contentsh1"><a href="#calibre_link-230" class="calibre3">FIGURE 16-14</a></li>
<li class="contentsh1"><a href="#calibre_link-232" class="calibre3">FIGURE 16-15</a></li>
<li class="contentsh1"><a href="#calibre_link-234" class="calibre3">FIGURE 16-16</a></li>
<li class="contentsh1"><a href="#calibre_link-136" class="calibre3">FIGURE 17-1</a></li>
<li class="contentsh1"><a href="#calibre_link-138" class="calibre3">FIGURE 17-2</a></li>
<li class="contentsh1"><a href="#calibre_link-140" class="calibre3">FIGURE 17-3</a></li>
<li class="contentsh1"><a href="#calibre_link-142" class="calibre3">FIGURE 17-4</a></li>
<li class="contentsh1"><a href="#calibre_link-144" class="calibre3">FIGURE 17-5</a></li>
<li class="contentsh1"><a href="#calibre_link-146" class="calibre3">FIGURE 17-6</a></li>
<li class="contentsh1"><a href="#calibre_link-148" class="calibre3">FIGURE 17-7</a></li>
<li class="contentsh1"><a href="#calibre_link-150" class="calibre3">FIGURE 17-8</a></li>
<li class="contentsh1"><a href="#calibre_link-152" class="calibre3">FIGURE 17-9</a></li>
<li class="contentsh1"><a href="#calibre_link-438" class="calibre3">FIGURE 18-1</a></li>
<li class="contentsh1"><a href="#calibre_link-439" class="calibre3">FIGURE 18-2</a></li>
<li class="contentsh1"><a href="#calibre_link-440" class="calibre3">FIGURE 18-3</a></li>
<li class="contentsh1"><a href="#calibre_link-441" class="calibre3">FIGURE 18-4</a></li>
<li class="contentsh1"><a href="#calibre_link-442" class="calibre3">FIGURE 18-5</a></li>
<li class="contentsh1"><a href="#calibre_link-443" class="calibre3">FIGURE 18-6</a></li>
<li class="contentsh1"><a href="#calibre_link-444" class="calibre3">FIGURE 18-7</a></li>
<li class="contentsh1"><a href="#calibre_link-445" class="calibre3">FIGURE 18-8</a></li>
<li class="contentsh1"><a href="#calibre_link-446" class="calibre3">FIGURE 18-9</a></li>
</ol>
</nav>
<nav class="pagelist" {http://www.idpf.org/2007/ops}type="page-list" id="calibre_link-1408" hidden="hidden">
<h2 class="calibre4">Pages</h2>
<ol class="calibre5">
<li id="calibre_link-1409" class="calibre6"><a href="#calibre_link-447" class="calibre3">v</a></li>
<li id="calibre_link-1410" class="calibre6"><a href="#calibre_link-448" class="calibre3">vi</a></li>
<li id="calibre_link-1411" class="calibre6"><a href="#calibre_link-449" class="calibre3">vii</a></li>
<li id="calibre_link-1412" class="calibre6"><a href="#calibre_link-450" class="calibre3">viii</a></li>
<li id="calibre_link-1413" class="calibre6"><a href="#calibre_link-451" class="calibre3">ix</a></li>
<li id="calibre_link-1414" class="calibre6"><a href="#calibre_link-452" class="calibre3">x</a></li>
<li id="calibre_link-1415" class="calibre6"><a href="#calibre_link-453" class="calibre3">xi</a></li>
<li id="calibre_link-1416" class="calibre6"><a href="#calibre_link-454" class="calibre3">xii</a></li>
<li id="calibre_link-1417" class="calibre6"><a href="#calibre_link-455" class="calibre3">xiii</a></li>
<li id="calibre_link-1418" class="calibre6"><a href="#calibre_link-456" class="calibre3">xiv</a></li>
<li id="calibre_link-1419" class="calibre6"><a href="#calibre_link-457" class="calibre3">xxxiii</a></li>
<li id="calibre_link-1420" class="calibre6"><a href="#calibre_link-458" class="calibre3">xxxiv</a></li>
<li id="calibre_link-1421" class="calibre6"><a href="#calibre_link-459" class="calibre3">xxxv</a></li>
<li id="calibre_link-1422" class="calibre6"><a href="#calibre_link-460" class="calibre3">xxxvi</a></li>
<li id="calibre_link-1423" class="calibre6"><a href="#calibre_link-461" class="calibre3">xxxvii</a></li>
<li id="calibre_link-1424" class="calibre6"><a href="#calibre_link-462" class="calibre3">xxxviii</a></li>
<li id="calibre_link-1425" class="calibre6"><a href="#calibre_link-463" class="calibre3">1</a></li>
<li id="calibre_link-1426" class="calibre6"><a href="#calibre_link-464" class="calibre3">2</a></li>
<li id="calibre_link-1427" class="calibre6"><a href="#calibre_link-465" class="calibre3">3</a></li>
<li id="calibre_link-1428" class="calibre6"><a href="#calibre_link-466" class="calibre3">4</a></li>
<li id="calibre_link-1429" class="calibre6"><a href="#calibre_link-467" class="calibre3">5</a></li>
<li id="calibre_link-1430" class="calibre6"><a href="#calibre_link-468" class="calibre3">6</a></li>
<li id="calibre_link-1431" class="calibre6"><a href="#calibre_link-469" class="calibre3">7</a></li>
<li id="calibre_link-1432" class="calibre6"><a href="#calibre_link-470" class="calibre3">8</a></li>
<li id="calibre_link-1433" class="calibre6"><a href="#calibre_link-471" class="calibre3">9</a></li>
<li id="calibre_link-1434" class="calibre6"><a href="#calibre_link-472" class="calibre3">10</a></li>
<li id="calibre_link-1435" class="calibre6"><a href="#calibre_link-473" class="calibre3">11</a></li>
<li id="calibre_link-1436" class="calibre6"><a href="#calibre_link-474" class="calibre3">12</a></li>
<li id="calibre_link-1437" class="calibre6"><a href="#calibre_link-475" class="calibre3">13</a></li>
<li id="calibre_link-1438" class="calibre6"><a href="#calibre_link-476" class="calibre3">14</a></li>
<li id="calibre_link-1439" class="calibre6"><a href="#calibre_link-477" class="calibre3">15</a></li>
<li id="calibre_link-1440" class="calibre6"><a href="#calibre_link-478" class="calibre3">16</a></li>
<li id="calibre_link-1441" class="calibre6"><a href="#calibre_link-479" class="calibre3">17</a></li>
<li id="calibre_link-1442" class="calibre6"><a href="#calibre_link-480" class="calibre3">18</a></li>
<li id="calibre_link-1443" class="calibre6"><a href="#calibre_link-481" class="calibre3">19</a></li>
<li id="calibre_link-1444" class="calibre6"><a href="#calibre_link-482" class="calibre3">20</a></li>
<li id="calibre_link-1445" class="calibre6"><a href="#calibre_link-483" class="calibre3">21</a></li>
<li id="calibre_link-1446" class="calibre6"><a href="#calibre_link-484" class="calibre3">22</a></li>
<li id="calibre_link-1447" class="calibre6"><a href="#calibre_link-485" class="calibre3">23</a></li>
<li id="calibre_link-1448" class="calibre6"><a href="#calibre_link-486" class="calibre3">24</a></li>
<li id="calibre_link-1449" class="calibre6"><a href="#calibre_link-487" class="calibre3">25</a></li>
<li id="calibre_link-1450" class="calibre6"><a href="#calibre_link-488" class="calibre3">26</a></li>
<li id="calibre_link-1451" class="calibre6"><a href="#calibre_link-489" class="calibre3">27</a></li>
<li id="calibre_link-1452" class="calibre6"><a href="#calibre_link-490" class="calibre3">28</a></li>
<li id="calibre_link-1453" class="calibre6"><a href="#calibre_link-491" class="calibre3">29</a></li>
<li id="calibre_link-1454" class="calibre6"><a href="#calibre_link-492" class="calibre3">30</a></li>
<li id="calibre_link-1455" class="calibre6"><a href="#calibre_link-493" class="calibre3">31</a></li>
<li id="calibre_link-1456" class="calibre6"><a href="#calibre_link-494" class="calibre3">32</a></li>
<li id="calibre_link-1457" class="calibre6"><a href="#calibre_link-495" class="calibre3">33</a></li>
<li id="calibre_link-1458" class="calibre6"><a href="#calibre_link-496" class="calibre3">34</a></li>
<li id="calibre_link-1459" class="calibre6"><a href="#calibre_link-497" class="calibre3">35</a></li>
<li id="calibre_link-1460" class="calibre6"><a href="#calibre_link-498" class="calibre3">36</a></li>
<li id="calibre_link-1461" class="calibre6"><a href="#calibre_link-499" class="calibre3">37</a></li>
<li id="calibre_link-1462" class="calibre6"><a href="#calibre_link-500" class="calibre3">38</a></li>
<li id="calibre_link-1463" class="calibre6"><a href="#calibre_link-501" class="calibre3">39</a></li>
<li id="calibre_link-1464" class="calibre6"><a href="#calibre_link-502" class="calibre3">40</a></li>
<li id="calibre_link-1465" class="calibre6"><a href="#calibre_link-503" class="calibre3">41</a></li>
<li id="calibre_link-1466" class="calibre6"><a href="#calibre_link-504" class="calibre3">42</a></li>
<li id="calibre_link-1467" class="calibre6"><a href="#calibre_link-505" class="calibre3">43</a></li>
<li id="calibre_link-1468" class="calibre6"><a href="#calibre_link-506" class="calibre3">44</a></li>
<li id="calibre_link-1469" class="calibre6"><a href="#calibre_link-507" class="calibre3">45</a></li>
<li id="calibre_link-1470" class="calibre6"><a href="#calibre_link-508" class="calibre3">46</a></li>
<li id="calibre_link-1471" class="calibre6"><a href="#calibre_link-509" class="calibre3">47</a></li>
<li id="calibre_link-1472" class="calibre6"><a href="#calibre_link-510" class="calibre3">48</a></li>
<li id="calibre_link-1473" class="calibre6"><a href="#calibre_link-511" class="calibre3">49</a></li>
<li id="calibre_link-1474" class="calibre6"><a href="#calibre_link-512" class="calibre3">50</a></li>
<li id="calibre_link-1475" class="calibre6"><a href="#calibre_link-513" class="calibre3">51</a></li>
<li id="calibre_link-1476" class="calibre6"><a href="#calibre_link-514" class="calibre3">52</a></li>
<li id="calibre_link-1477" class="calibre6"><a href="#calibre_link-515" class="calibre3">53</a></li>
<li id="calibre_link-1478" class="calibre6"><a href="#calibre_link-516" class="calibre3">54</a></li>
<li id="calibre_link-1479" class="calibre6"><a href="#calibre_link-517" class="calibre3">55</a></li>
<li id="calibre_link-1480" class="calibre6"><a href="#calibre_link-518" class="calibre3">56</a></li>
<li id="calibre_link-1481" class="calibre6"><a href="#calibre_link-519" class="calibre3">57</a></li>
<li id="calibre_link-1482" class="calibre6"><a href="#calibre_link-520" class="calibre3">58</a></li>
<li id="calibre_link-1483" class="calibre6"><a href="#calibre_link-521" class="calibre3">59</a></li>
<li id="calibre_link-1484" class="calibre6"><a href="#calibre_link-522" class="calibre3">60</a></li>
<li id="calibre_link-1485" class="calibre6"><a href="#calibre_link-523" class="calibre3">61</a></li>
<li id="calibre_link-1486" class="calibre6"><a href="#calibre_link-524" class="calibre3">62</a></li>
<li id="calibre_link-1487" class="calibre6"><a href="#calibre_link-525" class="calibre3">63</a></li>
<li id="calibre_link-1488" class="calibre6"><a href="#calibre_link-526" class="calibre3">64</a></li>
<li id="calibre_link-1489" class="calibre6"><a href="#calibre_link-527" class="calibre3">65</a></li>
<li id="calibre_link-1490" class="calibre6"><a href="#calibre_link-528" class="calibre3">66</a></li>
<li id="calibre_link-1491" class="calibre6"><a href="#calibre_link-529" class="calibre3">67</a></li>
<li id="calibre_link-1492" class="calibre6"><a href="#calibre_link-530" class="calibre3">68</a></li>
<li id="calibre_link-1493" class="calibre6"><a href="#calibre_link-531" class="calibre3">69</a></li>
<li id="calibre_link-1494" class="calibre6"><a href="#calibre_link-532" class="calibre3">70</a></li>
<li id="calibre_link-1495" class="calibre6"><a href="#calibre_link-533" class="calibre3">71</a></li>
<li id="calibre_link-1496" class="calibre6"><a href="#calibre_link-534" class="calibre3">72</a></li>
<li id="calibre_link-1497" class="calibre6"><a href="#calibre_link-535" class="calibre3">73</a></li>
<li id="calibre_link-1498" class="calibre6"><a href="#calibre_link-536" class="calibre3">74</a></li>
<li id="calibre_link-1499" class="calibre6"><a href="#calibre_link-537" class="calibre3">75</a></li>
<li id="calibre_link-1500" class="calibre6"><a href="#calibre_link-538" class="calibre3">76</a></li>
<li id="calibre_link-1501" class="calibre6"><a href="#calibre_link-539" class="calibre3">77</a></li>
<li id="calibre_link-1502" class="calibre6"><a href="#calibre_link-540" class="calibre3">78</a></li>
<li id="calibre_link-1503" class="calibre6"><a href="#calibre_link-541" class="calibre3">79</a></li>
<li id="calibre_link-1504" class="calibre6"><a href="#calibre_link-542" class="calibre3">80</a></li>
<li id="calibre_link-1505" class="calibre6"><a href="#calibre_link-543" class="calibre3">81</a></li>
<li id="calibre_link-1506" class="calibre6"><a href="#calibre_link-544" class="calibre3">82</a></li>
<li id="calibre_link-1507" class="calibre6"><a href="#calibre_link-545" class="calibre3">83</a></li>
<li id="calibre_link-1508" class="calibre6"><a href="#calibre_link-546" class="calibre3">84</a></li>
<li id="calibre_link-1509" class="calibre6"><a href="#calibre_link-547" class="calibre3">85</a></li>
<li id="calibre_link-1510" class="calibre6"><a href="#calibre_link-548" class="calibre3">86</a></li>
<li id="calibre_link-1511" class="calibre6"><a href="#calibre_link-549" class="calibre3">87</a></li>
<li id="calibre_link-1512" class="calibre6"><a href="#calibre_link-550" class="calibre3">88</a></li>
<li id="calibre_link-1513" class="calibre6"><a href="#calibre_link-551" class="calibre3">89</a></li>
<li id="calibre_link-1514" class="calibre6"><a href="#calibre_link-552" class="calibre3">90</a></li>
<li id="calibre_link-1515" class="calibre6"><a href="#calibre_link-553" class="calibre3">91</a></li>
<li id="calibre_link-1516" class="calibre6"><a href="#calibre_link-554" class="calibre3">92</a></li>
<li id="calibre_link-1517" class="calibre6"><a href="#calibre_link-555" class="calibre3">93</a></li>
<li id="calibre_link-1518" class="calibre6"><a href="#calibre_link-556" class="calibre3">94</a></li>
<li id="calibre_link-1519" class="calibre6"><a href="#calibre_link-557" class="calibre3">95</a></li>
<li id="calibre_link-1520" class="calibre6"><a href="#calibre_link-558" class="calibre3">96</a></li>
<li id="calibre_link-1521" class="calibre6"><a href="#calibre_link-559" class="calibre3">97</a></li>
<li id="calibre_link-1522" class="calibre6"><a href="#calibre_link-560" class="calibre3">98</a></li>
<li id="calibre_link-1523" class="calibre6"><a href="#calibre_link-561" class="calibre3">99</a></li>
<li id="calibre_link-1524" class="calibre6"><a href="#calibre_link-562" class="calibre3">100</a></li>
<li id="calibre_link-1525" class="calibre6"><a href="#calibre_link-563" class="calibre3">101</a></li>
<li id="calibre_link-1526" class="calibre6"><a href="#calibre_link-564" class="calibre3">102</a></li>
<li id="calibre_link-1527" class="calibre6"><a href="#calibre_link-565" class="calibre3">103</a></li>
<li id="calibre_link-1528" class="calibre6"><a href="#calibre_link-566" class="calibre3">104</a></li>
<li id="calibre_link-1529" class="calibre6"><a href="#calibre_link-567" class="calibre3">105</a></li>
<li id="calibre_link-1530" class="calibre6"><a href="#calibre_link-568" class="calibre3">106</a></li>
<li id="calibre_link-1531" class="calibre6"><a href="#calibre_link-569" class="calibre3">107</a></li>
<li id="calibre_link-1532" class="calibre6"><a href="#calibre_link-570" class="calibre3">108</a></li>
<li id="calibre_link-1533" class="calibre6"><a href="#calibre_link-571" class="calibre3">109</a></li>
<li id="calibre_link-1534" class="calibre6"><a href="#calibre_link-572" class="calibre3">110</a></li>
<li id="calibre_link-1535" class="calibre6"><a href="#calibre_link-573" class="calibre3">111</a></li>
<li id="calibre_link-1536" class="calibre6"><a href="#calibre_link-574" class="calibre3">112</a></li>
<li id="calibre_link-1537" class="calibre6"><a href="#calibre_link-575" class="calibre3">113</a></li>
<li id="calibre_link-1538" class="calibre6"><a href="#calibre_link-576" class="calibre3">114</a></li>
<li id="calibre_link-1539" class="calibre6"><a href="#calibre_link-577" class="calibre3">115</a></li>
<li id="calibre_link-1540" class="calibre6"><a href="#calibre_link-578" class="calibre3">116</a></li>
<li id="calibre_link-1541" class="calibre6"><a href="#calibre_link-579" class="calibre3">117</a></li>
<li id="calibre_link-1542" class="calibre6"><a href="#calibre_link-580" class="calibre3">118</a></li>
<li id="calibre_link-1543" class="calibre6"><a href="#calibre_link-581" class="calibre3">119</a></li>
<li id="calibre_link-1544" class="calibre6"><a href="#calibre_link-582" class="calibre3">120</a></li>
<li id="calibre_link-1545" class="calibre6"><a href="#calibre_link-583" class="calibre3">121</a></li>
<li id="calibre_link-1546" class="calibre6"><a href="#calibre_link-584" class="calibre3">122</a></li>
<li id="calibre_link-1547" class="calibre6"><a href="#calibre_link-585" class="calibre3">123</a></li>
<li id="calibre_link-1548" class="calibre6"><a href="#calibre_link-586" class="calibre3">124</a></li>
<li id="calibre_link-1549" class="calibre6"><a href="#calibre_link-587" class="calibre3">125</a></li>
<li id="calibre_link-1550" class="calibre6"><a href="#calibre_link-588" class="calibre3">126</a></li>
<li id="calibre_link-1551" class="calibre6"><a href="#calibre_link-589" class="calibre3">127</a></li>
<li id="calibre_link-1552" class="calibre6"><a href="#calibre_link-590" class="calibre3">128</a></li>
<li id="calibre_link-1553" class="calibre6"><a href="#calibre_link-591" class="calibre3">129</a></li>
<li id="calibre_link-1554" class="calibre6"><a href="#calibre_link-592" class="calibre3">130</a></li>
<li id="calibre_link-1555" class="calibre6"><a href="#calibre_link-593" class="calibre3">131</a></li>
<li id="calibre_link-1556" class="calibre6"><a href="#calibre_link-594" class="calibre3">132</a></li>
<li id="calibre_link-1557" class="calibre6"><a href="#calibre_link-595" class="calibre3">133</a></li>
<li id="calibre_link-1558" class="calibre6"><a href="#calibre_link-596" class="calibre3">134</a></li>
<li id="calibre_link-1559" class="calibre6"><a href="#calibre_link-597" class="calibre3">135</a></li>
<li id="calibre_link-1560" class="calibre6"><a href="#calibre_link-598" class="calibre3">136</a></li>
<li id="calibre_link-1561" class="calibre6"><a href="#calibre_link-599" class="calibre3">137</a></li>
<li id="calibre_link-1562" class="calibre6"><a href="#calibre_link-600" class="calibre3">138</a></li>
<li id="calibre_link-1563" class="calibre6"><a href="#calibre_link-601" class="calibre3">139</a></li>
<li id="calibre_link-1564" class="calibre6"><a href="#calibre_link-602" class="calibre3">140</a></li>
<li id="calibre_link-1565" class="calibre6"><a href="#calibre_link-603" class="calibre3">141</a></li>
<li id="calibre_link-1566" class="calibre6"><a href="#calibre_link-604" class="calibre3">142</a></li>
<li id="calibre_link-1567" class="calibre6"><a href="#calibre_link-605" class="calibre3">143</a></li>
<li id="calibre_link-1568" class="calibre6"><a href="#calibre_link-606" class="calibre3">144</a></li>
<li id="calibre_link-1569" class="calibre6"><a href="#calibre_link-607" class="calibre3">145</a></li>
<li id="calibre_link-1570" class="calibre6"><a href="#calibre_link-608" class="calibre3">146</a></li>
<li id="calibre_link-1571" class="calibre6"><a href="#calibre_link-609" class="calibre3">147</a></li>
<li id="calibre_link-1572" class="calibre6"><a href="#calibre_link-610" class="calibre3">148</a></li>
<li id="calibre_link-1573" class="calibre6"><a href="#calibre_link-611" class="calibre3">149</a></li>
<li id="calibre_link-1574" class="calibre6"><a href="#calibre_link-612" class="calibre3">150</a></li>
<li id="calibre_link-1575" class="calibre6"><a href="#calibre_link-613" class="calibre3">151</a></li>
<li id="calibre_link-1576" class="calibre6"><a href="#calibre_link-614" class="calibre3">152</a></li>
<li id="calibre_link-1577" class="calibre6"><a href="#calibre_link-615" class="calibre3">153</a></li>
<li id="calibre_link-1578" class="calibre6"><a href="#calibre_link-616" class="calibre3">154</a></li>
<li id="calibre_link-1579" class="calibre6"><a href="#calibre_link-617" class="calibre3">155</a></li>
<li id="calibre_link-1580" class="calibre6"><a href="#calibre_link-618" class="calibre3">156</a></li>
<li id="calibre_link-1581" class="calibre6"><a href="#calibre_link-619" class="calibre3">157</a></li>
<li id="calibre_link-1582" class="calibre6"><a href="#calibre_link-620" class="calibre3">158</a></li>
<li id="calibre_link-1583" class="calibre6"><a href="#calibre_link-621" class="calibre3">159</a></li>
<li id="calibre_link-1584" class="calibre6"><a href="#calibre_link-622" class="calibre3">160</a></li>
<li id="calibre_link-1585" class="calibre6"><a href="#calibre_link-623" class="calibre3">161</a></li>
<li id="calibre_link-1586" class="calibre6"><a href="#calibre_link-624" class="calibre3">162</a></li>
<li id="calibre_link-1587" class="calibre6"><a href="#calibre_link-625" class="calibre3">163</a></li>
<li id="calibre_link-1588" class="calibre6"><a href="#calibre_link-626" class="calibre3">164</a></li>
<li id="calibre_link-1589" class="calibre6"><a href="#calibre_link-627" class="calibre3">165</a></li>
<li id="calibre_link-1590" class="calibre6"><a href="#calibre_link-628" class="calibre3">166</a></li>
<li id="calibre_link-1591" class="calibre6"><a href="#calibre_link-629" class="calibre3">167</a></li>
<li id="calibre_link-1592" class="calibre6"><a href="#calibre_link-630" class="calibre3">168</a></li>
<li id="calibre_link-1593" class="calibre6"><a href="#calibre_link-631" class="calibre3">169</a></li>
<li id="calibre_link-1594" class="calibre6"><a href="#calibre_link-632" class="calibre3">170</a></li>
<li id="calibre_link-1595" class="calibre6"><a href="#calibre_link-633" class="calibre3">171</a></li>
<li id="calibre_link-1596" class="calibre6"><a href="#calibre_link-634" class="calibre3">172</a></li>
<li id="calibre_link-1597" class="calibre6"><a href="#calibre_link-635" class="calibre3">173</a></li>
<li id="calibre_link-1598" class="calibre6"><a href="#calibre_link-636" class="calibre3">174</a></li>
<li id="calibre_link-1599" class="calibre6"><a href="#calibre_link-637" class="calibre3">175</a></li>
<li id="calibre_link-1600" class="calibre6"><a href="#calibre_link-638" class="calibre3">176</a></li>
<li id="calibre_link-1601" class="calibre6"><a href="#calibre_link-639" class="calibre3">177</a></li>
<li id="calibre_link-1602" class="calibre6"><a href="#calibre_link-640" class="calibre3">178</a></li>
<li id="calibre_link-1603" class="calibre6"><a href="#calibre_link-641" class="calibre3">179</a></li>
<li id="calibre_link-1604" class="calibre6"><a href="#calibre_link-642" class="calibre3">180</a></li>
<li id="calibre_link-1605" class="calibre6"><a href="#calibre_link-643" class="calibre3">181</a></li>
<li id="calibre_link-1606" class="calibre6"><a href="#calibre_link-644" class="calibre3">182</a></li>
<li id="calibre_link-1607" class="calibre6"><a href="#calibre_link-645" class="calibre3">183</a></li>
<li id="calibre_link-1608" class="calibre6"><a href="#calibre_link-646" class="calibre3">184</a></li>
<li id="calibre_link-1609" class="calibre6"><a href="#calibre_link-647" class="calibre3">185</a></li>
<li id="calibre_link-1610" class="calibre6"><a href="#calibre_link-648" class="calibre3">186</a></li>
<li id="calibre_link-1611" class="calibre6"><a href="#calibre_link-649" class="calibre3">187</a></li>
<li id="calibre_link-1612" class="calibre6"><a href="#calibre_link-650" class="calibre3">188</a></li>
<li id="calibre_link-1613" class="calibre6"><a href="#calibre_link-651" class="calibre3">189</a></li>
<li id="calibre_link-1614" class="calibre6"><a href="#calibre_link-652" class="calibre3">190</a></li>
<li id="calibre_link-1615" class="calibre6"><a href="#calibre_link-653" class="calibre3">191</a></li>
<li id="calibre_link-1616" class="calibre6"><a href="#calibre_link-654" class="calibre3">192</a></li>
<li id="calibre_link-1617" class="calibre6"><a href="#calibre_link-655" class="calibre3">193</a></li>
<li id="calibre_link-1618" class="calibre6"><a href="#calibre_link-656" class="calibre3">194</a></li>
<li id="calibre_link-1619" class="calibre6"><a href="#calibre_link-657" class="calibre3">195</a></li>
<li id="calibre_link-1620" class="calibre6"><a href="#calibre_link-658" class="calibre3">196</a></li>
<li id="calibre_link-1621" class="calibre6"><a href="#calibre_link-659" class="calibre3">197</a></li>
<li id="calibre_link-1622" class="calibre6"><a href="#calibre_link-660" class="calibre3">198</a></li>
<li id="calibre_link-1623" class="calibre6"><a href="#calibre_link-661" class="calibre3">199</a></li>
<li id="calibre_link-1624" class="calibre6"><a href="#calibre_link-662" class="calibre3">200</a></li>
<li id="calibre_link-1625" class="calibre6"><a href="#calibre_link-663" class="calibre3">201</a></li>
<li id="calibre_link-1626" class="calibre6"><a href="#calibre_link-664" class="calibre3">202</a></li>
<li id="calibre_link-1627" class="calibre6"><a href="#calibre_link-665" class="calibre3">203</a></li>
<li id="calibre_link-1628" class="calibre6"><a href="#calibre_link-666" class="calibre3">204</a></li>
<li id="calibre_link-1629" class="calibre6"><a href="#calibre_link-667" class="calibre3">205</a></li>
<li id="calibre_link-1630" class="calibre6"><a href="#calibre_link-668" class="calibre3">206</a></li>
<li id="calibre_link-1631" class="calibre6"><a href="#calibre_link-669" class="calibre3">207</a></li>
<li id="calibre_link-1632" class="calibre6"><a href="#calibre_link-670" class="calibre3">208</a></li>
<li id="calibre_link-1633" class="calibre6"><a href="#calibre_link-671" class="calibre3">209</a></li>
<li id="calibre_link-1634" class="calibre6"><a href="#calibre_link-672" class="calibre3">210</a></li>
<li id="calibre_link-1635" class="calibre6"><a href="#calibre_link-673" class="calibre3">211</a></li>
<li id="calibre_link-1636" class="calibre6"><a href="#calibre_link-674" class="calibre3">212</a></li>
<li id="calibre_link-1637" class="calibre6"><a href="#calibre_link-675" class="calibre3">213</a></li>
<li id="calibre_link-1638" class="calibre6"><a href="#calibre_link-676" class="calibre3">214</a></li>
<li id="calibre_link-1639" class="calibre6"><a href="#calibre_link-677" class="calibre3">215</a></li>
<li id="calibre_link-1640" class="calibre6"><a href="#calibre_link-678" class="calibre3">216</a></li>
<li id="calibre_link-1641" class="calibre6"><a href="#calibre_link-679" class="calibre3">217</a></li>
<li id="calibre_link-1642" class="calibre6"><a href="#calibre_link-680" class="calibre3">218</a></li>
<li id="calibre_link-1643" class="calibre6"><a href="#calibre_link-681" class="calibre3">219</a></li>
<li id="calibre_link-1644" class="calibre6"><a href="#calibre_link-682" class="calibre3">220</a></li>
<li id="calibre_link-1645" class="calibre6"><a href="#calibre_link-683" class="calibre3">221</a></li>
<li id="calibre_link-1646" class="calibre6"><a href="#calibre_link-684" class="calibre3">222</a></li>
<li id="calibre_link-1647" class="calibre6"><a href="#calibre_link-685" class="calibre3">223</a></li>
<li id="calibre_link-1648" class="calibre6"><a href="#calibre_link-686" class="calibre3">224</a></li>
<li id="calibre_link-1649" class="calibre6"><a href="#calibre_link-687" class="calibre3">225</a></li>
<li id="calibre_link-1650" class="calibre6"><a href="#calibre_link-688" class="calibre3">226</a></li>
<li id="calibre_link-1651" class="calibre6"><a href="#calibre_link-689" class="calibre3">227</a></li>
<li id="calibre_link-1652" class="calibre6"><a href="#calibre_link-690" class="calibre3">228</a></li>
<li id="calibre_link-1653" class="calibre6"><a href="#calibre_link-691" class="calibre3">229</a></li>
<li id="calibre_link-1654" class="calibre6"><a href="#calibre_link-692" class="calibre3">230</a></li>
<li id="calibre_link-1655" class="calibre6"><a href="#calibre_link-693" class="calibre3">231</a></li>
<li id="calibre_link-1656" class="calibre6"><a href="#calibre_link-694" class="calibre3">232</a></li>
<li id="calibre_link-1657" class="calibre6"><a href="#calibre_link-695" class="calibre3">233</a></li>
<li id="calibre_link-1658" class="calibre6"><a href="#calibre_link-696" class="calibre3">234</a></li>
<li id="calibre_link-1659" class="calibre6"><a href="#calibre_link-697" class="calibre3">235</a></li>
<li id="calibre_link-1660" class="calibre6"><a href="#calibre_link-698" class="calibre3">236</a></li>
<li id="calibre_link-1661" class="calibre6"><a href="#calibre_link-699" class="calibre3">237</a></li>
<li id="calibre_link-1662" class="calibre6"><a href="#calibre_link-700" class="calibre3">238</a></li>
<li id="calibre_link-1663" class="calibre6"><a href="#calibre_link-701" class="calibre3">239</a></li>
<li id="calibre_link-1664" class="calibre6"><a href="#calibre_link-702" class="calibre3">240</a></li>
<li id="calibre_link-1665" class="calibre6"><a href="#calibre_link-703" class="calibre3">241</a></li>
<li id="calibre_link-1666" class="calibre6"><a href="#calibre_link-704" class="calibre3">242</a></li>
<li id="calibre_link-1667" class="calibre6"><a href="#calibre_link-705" class="calibre3">243</a></li>
<li id="calibre_link-1668" class="calibre6"><a href="#calibre_link-706" class="calibre3">244</a></li>
<li id="calibre_link-1669" class="calibre6"><a href="#calibre_link-707" class="calibre3">245</a></li>
<li id="calibre_link-1670" class="calibre6"><a href="#calibre_link-708" class="calibre3">246</a></li>
<li id="calibre_link-1671" class="calibre6"><a href="#calibre_link-709" class="calibre3">247</a></li>
<li id="calibre_link-1672" class="calibre6"><a href="#calibre_link-710" class="calibre3">248</a></li>
<li id="calibre_link-1673" class="calibre6"><a href="#calibre_link-711" class="calibre3">249</a></li>
<li id="calibre_link-1674" class="calibre6"><a href="#calibre_link-712" class="calibre3">250</a></li>
<li id="calibre_link-1675" class="calibre6"><a href="#calibre_link-713" class="calibre3">251</a></li>
<li id="calibre_link-1676" class="calibre6"><a href="#calibre_link-714" class="calibre3">252</a></li>
<li id="calibre_link-1677" class="calibre6"><a href="#calibre_link-715" class="calibre3">253</a></li>
<li id="calibre_link-1678" class="calibre6"><a href="#calibre_link-716" class="calibre3">254</a></li>
<li id="calibre_link-1679" class="calibre6"><a href="#calibre_link-717" class="calibre3">255</a></li>
<li id="calibre_link-1680" class="calibre6"><a href="#calibre_link-718" class="calibre3">256</a></li>
<li id="calibre_link-1681" class="calibre6"><a href="#calibre_link-719" class="calibre3">257</a></li>
<li id="calibre_link-1682" class="calibre6"><a href="#calibre_link-720" class="calibre3">258</a></li>
<li id="calibre_link-1683" class="calibre6"><a href="#calibre_link-721" class="calibre3">259</a></li>
<li id="calibre_link-1684" class="calibre6"><a href="#calibre_link-722" class="calibre3">260</a></li>
<li id="calibre_link-1685" class="calibre6"><a href="#calibre_link-723" class="calibre3">261</a></li>
<li id="calibre_link-1686" class="calibre6"><a href="#calibre_link-724" class="calibre3">262</a></li>
<li id="calibre_link-1687" class="calibre6"><a href="#calibre_link-725" class="calibre3">263</a></li>
<li id="calibre_link-1688" class="calibre6"><a href="#calibre_link-726" class="calibre3">264</a></li>
<li id="calibre_link-1689" class="calibre6"><a href="#calibre_link-727" class="calibre3">265</a></li>
<li id="calibre_link-1690" class="calibre6"><a href="#calibre_link-728" class="calibre3">266</a></li>
<li id="calibre_link-1691" class="calibre6"><a href="#calibre_link-729" class="calibre3">267</a></li>
<li id="calibre_link-1692" class="calibre6"><a href="#calibre_link-730" class="calibre3">268</a></li>
<li id="calibre_link-1693" class="calibre6"><a href="#calibre_link-731" class="calibre3">269</a></li>
<li id="calibre_link-1694" class="calibre6"><a href="#calibre_link-732" class="calibre3">270</a></li>
<li id="calibre_link-1695" class="calibre6"><a href="#calibre_link-733" class="calibre3">271</a></li>
<li id="calibre_link-1696" class="calibre6"><a href="#calibre_link-734" class="calibre3">272</a></li>
<li id="calibre_link-1697" class="calibre6"><a href="#calibre_link-735" class="calibre3">273</a></li>
<li id="calibre_link-1698" class="calibre6"><a href="#calibre_link-736" class="calibre3">274</a></li>
<li id="calibre_link-1699" class="calibre6"><a href="#calibre_link-737" class="calibre3">275</a></li>
<li id="calibre_link-1700" class="calibre6"><a href="#calibre_link-738" class="calibre3">276</a></li>
<li id="calibre_link-1701" class="calibre6"><a href="#calibre_link-739" class="calibre3">277</a></li>
<li id="calibre_link-1702" class="calibre6"><a href="#calibre_link-740" class="calibre3">278</a></li>
<li id="calibre_link-1703" class="calibre6"><a href="#calibre_link-741" class="calibre3">279</a></li>
<li id="calibre_link-1704" class="calibre6"><a href="#calibre_link-742" class="calibre3">280</a></li>
<li id="calibre_link-1705" class="calibre6"><a href="#calibre_link-743" class="calibre3">281</a></li>
<li id="calibre_link-1706" class="calibre6"><a href="#calibre_link-744" class="calibre3">282</a></li>
<li id="calibre_link-1707" class="calibre6"><a href="#calibre_link-745" class="calibre3">283</a></li>
<li id="calibre_link-1708" class="calibre6"><a href="#calibre_link-746" class="calibre3">284</a></li>
<li id="calibre_link-1709" class="calibre6"><a href="#calibre_link-747" class="calibre3">285</a></li>
<li id="calibre_link-1710" class="calibre6"><a href="#calibre_link-748" class="calibre3">286</a></li>
<li id="calibre_link-1711" class="calibre6"><a href="#calibre_link-749" class="calibre3">287</a></li>
<li id="calibre_link-1712" class="calibre6"><a href="#calibre_link-750" class="calibre3">288</a></li>
<li id="calibre_link-1713" class="calibre6"><a href="#calibre_link-751" class="calibre3">289</a></li>
<li id="calibre_link-1714" class="calibre6"><a href="#calibre_link-752" class="calibre3">290</a></li>
<li id="calibre_link-1715" class="calibre6"><a href="#calibre_link-753" class="calibre3">291</a></li>
<li id="calibre_link-1716" class="calibre6"><a href="#calibre_link-754" class="calibre3">292</a></li>
<li id="calibre_link-1717" class="calibre6"><a href="#calibre_link-755" class="calibre3">293</a></li>
<li id="calibre_link-1718" class="calibre6"><a href="#calibre_link-756" class="calibre3">294</a></li>
<li id="calibre_link-1719" class="calibre6"><a href="#calibre_link-757" class="calibre3">295</a></li>
<li id="calibre_link-1720" class="calibre6"><a href="#calibre_link-758" class="calibre3">296</a></li>
<li id="calibre_link-1721" class="calibre6"><a href="#calibre_link-759" class="calibre3">297</a></li>
<li id="calibre_link-1722" class="calibre6"><a href="#calibre_link-760" class="calibre3">298</a></li>
<li id="calibre_link-1723" class="calibre6"><a href="#calibre_link-761" class="calibre3">299</a></li>
<li id="calibre_link-1724" class="calibre6"><a href="#calibre_link-762" class="calibre3">300</a></li>
<li id="calibre_link-1725" class="calibre6"><a href="#calibre_link-763" class="calibre3">301</a></li>
<li id="calibre_link-1726" class="calibre6"><a href="#calibre_link-764" class="calibre3">302</a></li>
<li id="calibre_link-1727" class="calibre6"><a href="#calibre_link-765" class="calibre3">303</a></li>
<li id="calibre_link-1728" class="calibre6"><a href="#calibre_link-766" class="calibre3">304</a></li>
<li id="calibre_link-1729" class="calibre6"><a href="#calibre_link-767" class="calibre3">305</a></li>
<li id="calibre_link-1730" class="calibre6"><a href="#calibre_link-768" class="calibre3">306</a></li>
<li id="calibre_link-1731" class="calibre6"><a href="#calibre_link-769" class="calibre3">307</a></li>
<li id="calibre_link-1732" class="calibre6"><a href="#calibre_link-770" class="calibre3">308</a></li>
<li id="calibre_link-1733" class="calibre6"><a href="#calibre_link-771" class="calibre3">309</a></li>
<li id="calibre_link-1734" class="calibre6"><a href="#calibre_link-772" class="calibre3">310</a></li>
<li id="calibre_link-1735" class="calibre6"><a href="#calibre_link-773" class="calibre3">311</a></li>
<li id="calibre_link-1736" class="calibre6"><a href="#calibre_link-774" class="calibre3">312</a></li>
<li id="calibre_link-1737" class="calibre6"><a href="#calibre_link-775" class="calibre3">313</a></li>
<li id="calibre_link-1738" class="calibre6"><a href="#calibre_link-776" class="calibre3">314</a></li>
<li id="calibre_link-1739" class="calibre6"><a href="#calibre_link-777" class="calibre3">315</a></li>
<li id="calibre_link-1740" class="calibre6"><a href="#calibre_link-778" class="calibre3">316</a></li>
<li id="calibre_link-1741" class="calibre6"><a href="#calibre_link-779" class="calibre3">317</a></li>
<li id="calibre_link-1742" class="calibre6"><a href="#calibre_link-780" class="calibre3">318</a></li>
<li id="calibre_link-1743" class="calibre6"><a href="#calibre_link-781" class="calibre3">319</a></li>
<li id="calibre_link-1744" class="calibre6"><a href="#calibre_link-782" class="calibre3">320</a></li>
<li id="calibre_link-1745" class="calibre6"><a href="#calibre_link-783" class="calibre3">321</a></li>
<li id="calibre_link-1746" class="calibre6"><a href="#calibre_link-784" class="calibre3">322</a></li>
<li id="calibre_link-1747" class="calibre6"><a href="#calibre_link-785" class="calibre3">323</a></li>
<li id="calibre_link-1748" class="calibre6"><a href="#calibre_link-786" class="calibre3">324</a></li>
<li id="calibre_link-1749" class="calibre6"><a href="#calibre_link-787" class="calibre3">325</a></li>
<li id="calibre_link-1750" class="calibre6"><a href="#calibre_link-788" class="calibre3">326</a></li>
<li id="calibre_link-1751" class="calibre6"><a href="#calibre_link-789" class="calibre3">327</a></li>
<li id="calibre_link-1752" class="calibre6"><a href="#calibre_link-790" class="calibre3">328</a></li>
<li id="calibre_link-1753" class="calibre6"><a href="#calibre_link-791" class="calibre3">329</a></li>
<li id="calibre_link-1754" class="calibre6"><a href="#calibre_link-792" class="calibre3">330</a></li>
<li id="calibre_link-1755" class="calibre6"><a href="#calibre_link-793" class="calibre3">331</a></li>
<li id="calibre_link-1756" class="calibre6"><a href="#calibre_link-794" class="calibre3">332</a></li>
<li id="calibre_link-1757" class="calibre6"><a href="#calibre_link-795" class="calibre3">333</a></li>
<li id="calibre_link-1758" class="calibre6"><a href="#calibre_link-796" class="calibre3">334</a></li>
<li id="calibre_link-1759" class="calibre6"><a href="#calibre_link-797" class="calibre3">335</a></li>
<li id="calibre_link-1760" class="calibre6"><a href="#calibre_link-798" class="calibre3">336</a></li>
<li id="calibre_link-1761" class="calibre6"><a href="#calibre_link-799" class="calibre3">337</a></li>
<li id="calibre_link-1762" class="calibre6"><a href="#calibre_link-800" class="calibre3">338</a></li>
<li id="calibre_link-1763" class="calibre6"><a href="#calibre_link-801" class="calibre3">339</a></li>
<li id="calibre_link-1764" class="calibre6"><a href="#calibre_link-802" class="calibre3">340</a></li>
<li id="calibre_link-1765" class="calibre6"><a href="#calibre_link-803" class="calibre3">341</a></li>
<li id="calibre_link-1766" class="calibre6"><a href="#calibre_link-804" class="calibre3">342</a></li>
<li id="calibre_link-1767" class="calibre6"><a href="#calibre_link-805" class="calibre3">343</a></li>
<li id="calibre_link-1768" class="calibre6"><a href="#calibre_link-806" class="calibre3">344</a></li>
<li id="calibre_link-1769" class="calibre6"><a href="#calibre_link-807" class="calibre3">345</a></li>
<li id="calibre_link-1770" class="calibre6"><a href="#calibre_link-808" class="calibre3">346</a></li>
<li id="calibre_link-1771" class="calibre6"><a href="#calibre_link-809" class="calibre3">347</a></li>
<li id="calibre_link-1772" class="calibre6"><a href="#calibre_link-810" class="calibre3">348</a></li>
<li id="calibre_link-1773" class="calibre6"><a href="#calibre_link-811" class="calibre3">349</a></li>
<li id="calibre_link-1774" class="calibre6"><a href="#calibre_link-812" class="calibre3">350</a></li>
<li id="calibre_link-1775" class="calibre6"><a href="#calibre_link-813" class="calibre3">351</a></li>
<li id="calibre_link-1776" class="calibre6"><a href="#calibre_link-814" class="calibre3">352</a></li>
<li id="calibre_link-1777" class="calibre6"><a href="#calibre_link-815" class="calibre3">353</a></li>
<li id="calibre_link-1778" class="calibre6"><a href="#calibre_link-816" class="calibre3">354</a></li>
<li id="calibre_link-1779" class="calibre6"><a href="#calibre_link-817" class="calibre3">355</a></li>
<li id="calibre_link-1780" class="calibre6"><a href="#calibre_link-818" class="calibre3">356</a></li>
<li id="calibre_link-1781" class="calibre6"><a href="#calibre_link-819" class="calibre3">357</a></li>
<li id="calibre_link-1782" class="calibre6"><a href="#calibre_link-820" class="calibre3">358</a></li>
<li id="calibre_link-1783" class="calibre6"><a href="#calibre_link-821" class="calibre3">359</a></li>
<li id="calibre_link-1784" class="calibre6"><a href="#calibre_link-822" class="calibre3">360</a></li>
<li id="calibre_link-1785" class="calibre6"><a href="#calibre_link-823" class="calibre3">361</a></li>
<li id="calibre_link-1786" class="calibre6"><a href="#calibre_link-824" class="calibre3">362</a></li>
<li id="calibre_link-1787" class="calibre6"><a href="#calibre_link-825" class="calibre3">363</a></li>
<li id="calibre_link-1788" class="calibre6"><a href="#calibre_link-826" class="calibre3">364</a></li>
<li id="calibre_link-1789" class="calibre6"><a href="#calibre_link-827" class="calibre3">365</a></li>
<li id="calibre_link-1790" class="calibre6"><a href="#calibre_link-828" class="calibre3">366</a></li>
<li id="calibre_link-1791" class="calibre6"><a href="#calibre_link-829" class="calibre3">367</a></li>
<li id="calibre_link-1792" class="calibre6"><a href="#calibre_link-830" class="calibre3">368</a></li>
<li id="calibre_link-1793" class="calibre6"><a href="#calibre_link-831" class="calibre3">369</a></li>
<li id="calibre_link-1794" class="calibre6"><a href="#calibre_link-832" class="calibre3">370</a></li>
<li id="calibre_link-1795" class="calibre6"><a href="#calibre_link-833" class="calibre3">371</a></li>
<li id="calibre_link-1796" class="calibre6"><a href="#calibre_link-834" class="calibre3">372</a></li>
<li id="calibre_link-1797" class="calibre6"><a href="#calibre_link-835" class="calibre3">373</a></li>
<li id="calibre_link-1798" class="calibre6"><a href="#calibre_link-836" class="calibre3">374</a></li>
<li id="calibre_link-1799" class="calibre6"><a href="#calibre_link-837" class="calibre3">375</a></li>
<li id="calibre_link-1800" class="calibre6"><a href="#calibre_link-838" class="calibre3">376</a></li>
<li id="calibre_link-1801" class="calibre6"><a href="#calibre_link-839" class="calibre3">377</a></li>
<li id="calibre_link-1802" class="calibre6"><a href="#calibre_link-840" class="calibre3">378</a></li>
<li id="calibre_link-1803" class="calibre6"><a href="#calibre_link-841" class="calibre3">379</a></li>
<li id="calibre_link-1804" class="calibre6"><a href="#calibre_link-842" class="calibre3">380</a></li>
<li id="calibre_link-1805" class="calibre6"><a href="#calibre_link-843" class="calibre3">381</a></li>
<li id="calibre_link-1806" class="calibre6"><a href="#calibre_link-844" class="calibre3">382</a></li>
<li id="calibre_link-1807" class="calibre6"><a href="#calibre_link-845" class="calibre3">383</a></li>
<li id="calibre_link-1808" class="calibre6"><a href="#calibre_link-846" class="calibre3">384</a></li>
<li id="calibre_link-1809" class="calibre6"><a href="#calibre_link-847" class="calibre3">385</a></li>
<li id="calibre_link-1810" class="calibre6"><a href="#calibre_link-848" class="calibre3">386</a></li>
<li id="calibre_link-1811" class="calibre6"><a href="#calibre_link-849" class="calibre3">387</a></li>
<li id="calibre_link-1812" class="calibre6"><a href="#calibre_link-850" class="calibre3">388</a></li>
<li id="calibre_link-1813" class="calibre6"><a href="#calibre_link-851" class="calibre3">389</a></li>
<li id="calibre_link-1814" class="calibre6"><a href="#calibre_link-852" class="calibre3">390</a></li>
<li id="calibre_link-1815" class="calibre6"><a href="#calibre_link-853" class="calibre3">391</a></li>
<li id="calibre_link-1816" class="calibre6"><a href="#calibre_link-854" class="calibre3">392</a></li>
<li id="calibre_link-1817" class="calibre6"><a href="#calibre_link-855" class="calibre3">393</a></li>
<li id="calibre_link-1818" class="calibre6"><a href="#calibre_link-856" class="calibre3">394</a></li>
<li id="calibre_link-1819" class="calibre6"><a href="#calibre_link-857" class="calibre3">395</a></li>
<li id="calibre_link-1820" class="calibre6"><a href="#calibre_link-858" class="calibre3">396</a></li>
<li id="calibre_link-1821" class="calibre6"><a href="#calibre_link-859" class="calibre3">397</a></li>
<li id="calibre_link-1822" class="calibre6"><a href="#calibre_link-860" class="calibre3">398</a></li>
<li id="calibre_link-1823" class="calibre6"><a href="#calibre_link-861" class="calibre3">399</a></li>
<li id="calibre_link-1824" class="calibre6"><a href="#calibre_link-862" class="calibre3">400</a></li>
<li id="calibre_link-1825" class="calibre6"><a href="#calibre_link-863" class="calibre3">401</a></li>
<li id="calibre_link-1826" class="calibre6"><a href="#calibre_link-864" class="calibre3">402</a></li>
<li id="calibre_link-1827" class="calibre6"><a href="#calibre_link-865" class="calibre3">403</a></li>
<li id="calibre_link-1828" class="calibre6"><a href="#calibre_link-866" class="calibre3">404</a></li>
<li id="calibre_link-1829" class="calibre6"><a href="#calibre_link-867" class="calibre3">405</a></li>
<li id="calibre_link-1830" class="calibre6"><a href="#calibre_link-868" class="calibre3">406</a></li>
<li id="calibre_link-1831" class="calibre6"><a href="#calibre_link-869" class="calibre3">407</a></li>
<li id="calibre_link-1832" class="calibre6"><a href="#calibre_link-870" class="calibre3">408</a></li>
<li id="calibre_link-1833" class="calibre6"><a href="#calibre_link-871" class="calibre3">409</a></li>
<li id="calibre_link-1834" class="calibre6"><a href="#calibre_link-872" class="calibre3">410</a></li>
<li id="calibre_link-1835" class="calibre6"><a href="#calibre_link-873" class="calibre3">411</a></li>
<li id="calibre_link-1836" class="calibre6"><a href="#calibre_link-874" class="calibre3">412</a></li>
<li id="calibre_link-1837" class="calibre6"><a href="#calibre_link-875" class="calibre3">413</a></li>
<li id="calibre_link-1838" class="calibre6"><a href="#calibre_link-876" class="calibre3">414</a></li>
<li id="calibre_link-1839" class="calibre6"><a href="#calibre_link-877" class="calibre3">415</a></li>
<li id="calibre_link-1840" class="calibre6"><a href="#calibre_link-878" class="calibre3">416</a></li>
<li id="calibre_link-1841" class="calibre6"><a href="#calibre_link-879" class="calibre3">417</a></li>
<li id="calibre_link-1842" class="calibre6"><a href="#calibre_link-880" class="calibre3">418</a></li>
<li id="calibre_link-1843" class="calibre6"><a href="#calibre_link-881" class="calibre3">419</a></li>
<li id="calibre_link-1844" class="calibre6"><a href="#calibre_link-882" class="calibre3">420</a></li>
<li id="calibre_link-1845" class="calibre6"><a href="#calibre_link-883" class="calibre3">421</a></li>
<li id="calibre_link-1846" class="calibre6"><a href="#calibre_link-884" class="calibre3">422</a></li>
<li id="calibre_link-1847" class="calibre6"><a href="#calibre_link-885" class="calibre3">423</a></li>
<li id="calibre_link-1848" class="calibre6"><a href="#calibre_link-886" class="calibre3">424</a></li>
<li id="calibre_link-1849" class="calibre6"><a href="#calibre_link-887" class="calibre3">425</a></li>
<li id="calibre_link-1850" class="calibre6"><a href="#calibre_link-888" class="calibre3">426</a></li>
<li id="calibre_link-1851" class="calibre6"><a href="#calibre_link-889" class="calibre3">427</a></li>
<li id="calibre_link-1852" class="calibre6"><a href="#calibre_link-890" class="calibre3">428</a></li>
<li id="calibre_link-1853" class="calibre6"><a href="#calibre_link-891" class="calibre3">429</a></li>
<li id="calibre_link-1854" class="calibre6"><a href="#calibre_link-892" class="calibre3">430</a></li>
<li id="calibre_link-1855" class="calibre6"><a href="#calibre_link-893" class="calibre3">431</a></li>
<li id="calibre_link-1856" class="calibre6"><a href="#calibre_link-894" class="calibre3">432</a></li>
<li id="calibre_link-1857" class="calibre6"><a href="#calibre_link-895" class="calibre3">433</a></li>
<li id="calibre_link-1858" class="calibre6"><a href="#calibre_link-896" class="calibre3">434</a></li>
<li id="calibre_link-1859" class="calibre6"><a href="#calibre_link-897" class="calibre3">435</a></li>
<li id="calibre_link-1860" class="calibre6"><a href="#calibre_link-898" class="calibre3">436</a></li>
<li id="calibre_link-1861" class="calibre6"><a href="#calibre_link-899" class="calibre3">437</a></li>
<li id="calibre_link-1862" class="calibre6"><a href="#calibre_link-900" class="calibre3">438</a></li>
<li id="calibre_link-1863" class="calibre6"><a href="#calibre_link-901" class="calibre3">439</a></li>
<li id="calibre_link-1864" class="calibre6"><a href="#calibre_link-902" class="calibre3">440</a></li>
<li id="calibre_link-1865" class="calibre6"><a href="#calibre_link-903" class="calibre3">441</a></li>
<li id="calibre_link-1866" class="calibre6"><a href="#calibre_link-904" class="calibre3">442</a></li>
<li id="calibre_link-1867" class="calibre6"><a href="#calibre_link-905" class="calibre3">443</a></li>
<li id="calibre_link-1868" class="calibre6"><a href="#calibre_link-906" class="calibre3">444</a></li>
<li id="calibre_link-1869" class="calibre6"><a href="#calibre_link-907" class="calibre3">445</a></li>
<li id="calibre_link-1870" class="calibre6"><a href="#calibre_link-908" class="calibre3">446</a></li>
<li id="calibre_link-1871" class="calibre6"><a href="#calibre_link-909" class="calibre3">447</a></li>
<li id="calibre_link-1872" class="calibre6"><a href="#calibre_link-910" class="calibre3">448</a></li>
<li id="calibre_link-1873" class="calibre6"><a href="#calibre_link-911" class="calibre3">449</a></li>
<li id="calibre_link-1874" class="calibre6"><a href="#calibre_link-912" class="calibre3">450</a></li>
<li id="calibre_link-1875" class="calibre6"><a href="#calibre_link-913" class="calibre3">451</a></li>
<li id="calibre_link-1876" class="calibre6"><a href="#calibre_link-914" class="calibre3">452</a></li>
<li id="calibre_link-1877" class="calibre6"><a href="#calibre_link-915" class="calibre3">453</a></li>
<li id="calibre_link-1878" class="calibre6"><a href="#calibre_link-916" class="calibre3">454</a></li>
<li id="calibre_link-1879" class="calibre6"><a href="#calibre_link-917" class="calibre3">455</a></li>
<li id="calibre_link-1880" class="calibre6"><a href="#calibre_link-918" class="calibre3">456</a></li>
<li id="calibre_link-1881" class="calibre6"><a href="#calibre_link-919" class="calibre3">457</a></li>
<li id="calibre_link-1882" class="calibre6"><a href="#calibre_link-920" class="calibre3">458</a></li>
<li id="calibre_link-1883" class="calibre6"><a href="#calibre_link-921" class="calibre3">459</a></li>
<li id="calibre_link-1884" class="calibre6"><a href="#calibre_link-922" class="calibre3">460</a></li>
<li id="calibre_link-1885" class="calibre6"><a href="#calibre_link-923" class="calibre3">461</a></li>
<li id="calibre_link-1886" class="calibre6"><a href="#calibre_link-924" class="calibre3">462</a></li>
<li id="calibre_link-1887" class="calibre6"><a href="#calibre_link-925" class="calibre3">463</a></li>
<li id="calibre_link-1888" class="calibre6"><a href="#calibre_link-926" class="calibre3">464</a></li>
<li id="calibre_link-1889" class="calibre6"><a href="#calibre_link-927" class="calibre3">465</a></li>
<li id="calibre_link-1890" class="calibre6"><a href="#calibre_link-928" class="calibre3">466</a></li>
<li id="calibre_link-1891" class="calibre6"><a href="#calibre_link-929" class="calibre3">467</a></li>
<li id="calibre_link-1892" class="calibre6"><a href="#calibre_link-930" class="calibre3">468</a></li>
<li id="calibre_link-1893" class="calibre6"><a href="#calibre_link-931" class="calibre3">469</a></li>
<li id="calibre_link-1894" class="calibre6"><a href="#calibre_link-932" class="calibre3">470</a></li>
<li id="calibre_link-1895" class="calibre6"><a href="#calibre_link-933" class="calibre3">471</a></li>
<li id="calibre_link-1896" class="calibre6"><a href="#calibre_link-934" class="calibre3">472</a></li>
<li id="calibre_link-1897" class="calibre6"><a href="#calibre_link-935" class="calibre3">473</a></li>
<li id="calibre_link-1898" class="calibre6"><a href="#calibre_link-936" class="calibre3">474</a></li>
<li id="calibre_link-1899" class="calibre6"><a href="#calibre_link-937" class="calibre3">475</a></li>
<li id="calibre_link-1900" class="calibre6"><a href="#calibre_link-938" class="calibre3">476</a></li>
<li id="calibre_link-1901" class="calibre6"><a href="#calibre_link-939" class="calibre3">477</a></li>
<li id="calibre_link-1902" class="calibre6"><a href="#calibre_link-940" class="calibre3">478</a></li>
<li id="calibre_link-1903" class="calibre6"><a href="#calibre_link-941" class="calibre3">479</a></li>
<li id="calibre_link-1904" class="calibre6"><a href="#calibre_link-942" class="calibre3">480</a></li>
<li id="calibre_link-1905" class="calibre6"><a href="#calibre_link-943" class="calibre3">481</a></li>
<li id="calibre_link-1906" class="calibre6"><a href="#calibre_link-944" class="calibre3">482</a></li>
<li id="calibre_link-1907" class="calibre6"><a href="#calibre_link-945" class="calibre3">483</a></li>
<li id="calibre_link-1908" class="calibre6"><a href="#calibre_link-946" class="calibre3">484</a></li>
<li id="calibre_link-1909" class="calibre6"><a href="#calibre_link-947" class="calibre3">485</a></li>
<li id="calibre_link-1910" class="calibre6"><a href="#calibre_link-948" class="calibre3">486</a></li>
<li id="calibre_link-1911" class="calibre6"><a href="#calibre_link-949" class="calibre3">487</a></li>
<li id="calibre_link-1912" class="calibre6"><a href="#calibre_link-950" class="calibre3">488</a></li>
<li id="calibre_link-1913" class="calibre6"><a href="#calibre_link-951" class="calibre3">489</a></li>
<li id="calibre_link-1914" class="calibre6"><a href="#calibre_link-952" class="calibre3">490</a></li>
<li id="calibre_link-1915" class="calibre6"><a href="#calibre_link-953" class="calibre3">491</a></li>
<li id="calibre_link-1916" class="calibre6"><a href="#calibre_link-954" class="calibre3">492</a></li>
<li id="calibre_link-1917" class="calibre6"><a href="#calibre_link-955" class="calibre3">493</a></li>
<li id="calibre_link-1918" class="calibre6"><a href="#calibre_link-956" class="calibre3">494</a></li>
<li id="calibre_link-1919" class="calibre6"><a href="#calibre_link-957" class="calibre3">495</a></li>
<li id="calibre_link-1920" class="calibre6"><a href="#calibre_link-958" class="calibre3">496</a></li>
<li id="calibre_link-1921" class="calibre6"><a href="#calibre_link-959" class="calibre3">497</a></li>
<li id="calibre_link-1922" class="calibre6"><a href="#calibre_link-960" class="calibre3">498</a></li>
<li id="calibre_link-1923" class="calibre6"><a href="#calibre_link-961" class="calibre3">499</a></li>
<li id="calibre_link-1924" class="calibre6"><a href="#calibre_link-962" class="calibre3">500</a></li>
<li id="calibre_link-1925" class="calibre6"><a href="#calibre_link-963" class="calibre3">501</a></li>
<li id="calibre_link-1926" class="calibre6"><a href="#calibre_link-964" class="calibre3">502</a></li>
<li id="calibre_link-1927" class="calibre6"><a href="#calibre_link-965" class="calibre3">503</a></li>
<li id="calibre_link-1928" class="calibre6"><a href="#calibre_link-966" class="calibre3">504</a></li>
<li id="calibre_link-1929" class="calibre6"><a href="#calibre_link-967" class="calibre3">505</a></li>
<li id="calibre_link-1930" class="calibre6"><a href="#calibre_link-968" class="calibre3">506</a></li>
<li id="calibre_link-1931" class="calibre6"><a href="#calibre_link-969" class="calibre3">507</a></li>
<li id="calibre_link-1932" class="calibre6"><a href="#calibre_link-970" class="calibre3">508</a></li>
<li id="calibre_link-1933" class="calibre6"><a href="#calibre_link-971" class="calibre3">509</a></li>
<li id="calibre_link-1934" class="calibre6"><a href="#calibre_link-972" class="calibre3">510</a></li>
<li id="calibre_link-1935" class="calibre6"><a href="#calibre_link-973" class="calibre3">511</a></li>
<li id="calibre_link-1936" class="calibre6"><a href="#calibre_link-974" class="calibre3">512</a></li>
<li id="calibre_link-1937" class="calibre6"><a href="#calibre_link-975" class="calibre3">513</a></li>
<li id="calibre_link-1938" class="calibre6"><a href="#calibre_link-976" class="calibre3">514</a></li>
<li id="calibre_link-1939" class="calibre6"><a href="#calibre_link-977" class="calibre3">515</a></li>
<li id="calibre_link-1940" class="calibre6"><a href="#calibre_link-978" class="calibre3">516</a></li>
<li id="calibre_link-1941" class="calibre6"><a href="#calibre_link-979" class="calibre3">517</a></li>
<li id="calibre_link-1942" class="calibre6"><a href="#calibre_link-980" class="calibre3">518</a></li>
<li id="calibre_link-1943" class="calibre6"><a href="#calibre_link-981" class="calibre3">519</a></li>
<li id="calibre_link-1944" class="calibre6"><a href="#calibre_link-982" class="calibre3">520</a></li>
<li id="calibre_link-1945" class="calibre6"><a href="#calibre_link-983" class="calibre3">521</a></li>
<li id="calibre_link-1946" class="calibre6"><a href="#calibre_link-984" class="calibre3">522</a></li>
<li id="calibre_link-1947" class="calibre6"><a href="#calibre_link-985" class="calibre3">523</a></li>
<li id="calibre_link-1948" class="calibre6"><a href="#calibre_link-986" class="calibre3">524</a></li>
<li id="calibre_link-1949" class="calibre6"><a href="#calibre_link-987" class="calibre3">525</a></li>
<li id="calibre_link-1950" class="calibre6"><a href="#calibre_link-988" class="calibre3">526</a></li>
<li id="calibre_link-1951" class="calibre6"><a href="#calibre_link-989" class="calibre3">527</a></li>
<li id="calibre_link-1952" class="calibre6"><a href="#calibre_link-990" class="calibre3">528</a></li>
<li id="calibre_link-1953" class="calibre6"><a href="#calibre_link-991" class="calibre3">529</a></li>
<li id="calibre_link-1954" class="calibre6"><a href="#calibre_link-992" class="calibre3">530</a></li>
<li id="calibre_link-1955" class="calibre6"><a href="#calibre_link-993" class="calibre3">531</a></li>
<li id="calibre_link-1956" class="calibre6"><a href="#calibre_link-994" class="calibre3">532</a></li>
<li id="calibre_link-1957" class="calibre6"><a href="#calibre_link-995" class="calibre3">533</a></li>
<li id="calibre_link-1958" class="calibre6"><a href="#calibre_link-996" class="calibre3">534</a></li>
<li id="calibre_link-1959" class="calibre6"><a href="#calibre_link-997" class="calibre3">535</a></li>
<li id="calibre_link-1960" class="calibre6"><a href="#calibre_link-998" class="calibre3">536</a></li>
<li id="calibre_link-1961" class="calibre6"><a href="#calibre_link-999" class="calibre3">537</a></li>
<li id="calibre_link-1962" class="calibre6"><a href="#calibre_link-1000" class="calibre3">538</a></li>
<li id="calibre_link-1963" class="calibre6"><a href="#calibre_link-1001" class="calibre3">539</a></li>
<li id="calibre_link-1964" class="calibre6"><a href="#calibre_link-1002" class="calibre3">540</a></li>
<li id="calibre_link-1965" class="calibre6"><a href="#calibre_link-1003" class="calibre3">541</a></li>
<li id="calibre_link-1966" class="calibre6"><a href="#calibre_link-1004" class="calibre3">542</a></li>
<li id="calibre_link-1967" class="calibre6"><a href="#calibre_link-1005" class="calibre3">543</a></li>
<li id="calibre_link-1968" class="calibre6"><a href="#calibre_link-1006" class="calibre3">544</a></li>
<li id="calibre_link-1969" class="calibre6"><a href="#calibre_link-1007" class="calibre3">545</a></li>
<li id="calibre_link-1970" class="calibre6"><a href="#calibre_link-1008" class="calibre3">546</a></li>
<li id="calibre_link-1971" class="calibre6"><a href="#calibre_link-1009" class="calibre3">547</a></li>
<li id="calibre_link-1972" class="calibre6"><a href="#calibre_link-1010" class="calibre3">548</a></li>
<li id="calibre_link-1973" class="calibre6"><a href="#calibre_link-1011" class="calibre3">549</a></li>
<li id="calibre_link-1974" class="calibre6"><a href="#calibre_link-1012" class="calibre3">550</a></li>
<li id="calibre_link-1975" class="calibre6"><a href="#calibre_link-1013" class="calibre3">551</a></li>
<li id="calibre_link-1976" class="calibre6"><a href="#calibre_link-1014" class="calibre3">552</a></li>
<li id="calibre_link-1977" class="calibre6"><a href="#calibre_link-1015" class="calibre3">553</a></li>
<li id="calibre_link-1978" class="calibre6"><a href="#calibre_link-1016" class="calibre3">554</a></li>
<li id="calibre_link-1979" class="calibre6"><a href="#calibre_link-1017" class="calibre3">555</a></li>
<li id="calibre_link-1980" class="calibre6"><a href="#calibre_link-1018" class="calibre3">556</a></li>
<li id="calibre_link-1981" class="calibre6"><a href="#calibre_link-1019" class="calibre3">557</a></li>
<li id="calibre_link-1982" class="calibre6"><a href="#calibre_link-1020" class="calibre3">558</a></li>
<li id="calibre_link-1983" class="calibre6"><a href="#calibre_link-1021" class="calibre3">559</a></li>
<li id="calibre_link-1984" class="calibre6"><a href="#calibre_link-1022" class="calibre3">560</a></li>
<li id="calibre_link-1985" class="calibre6"><a href="#calibre_link-1023" class="calibre3">561</a></li>
<li id="calibre_link-1986" class="calibre6"><a href="#calibre_link-1024" class="calibre3">562</a></li>
<li id="calibre_link-1987" class="calibre6"><a href="#calibre_link-1025" class="calibre3">563</a></li>
<li id="calibre_link-1988" class="calibre6"><a href="#calibre_link-1026" class="calibre3">564</a></li>
<li id="calibre_link-1989" class="calibre6"><a href="#calibre_link-1027" class="calibre3">565</a></li>
<li id="calibre_link-1990" class="calibre6"><a href="#calibre_link-1028" class="calibre3">566</a></li>
<li id="calibre_link-1991" class="calibre6"><a href="#calibre_link-1029" class="calibre3">567</a></li>
<li id="calibre_link-1992" class="calibre6"><a href="#calibre_link-1030" class="calibre3">568</a></li>
<li id="calibre_link-1993" class="calibre6"><a href="#calibre_link-1031" class="calibre3">569</a></li>
<li id="calibre_link-1994" class="calibre6"><a href="#calibre_link-1032" class="calibre3">570</a></li>
<li id="calibre_link-1995" class="calibre6"><a href="#calibre_link-1033" class="calibre3">571</a></li>
<li id="calibre_link-1996" class="calibre6"><a href="#calibre_link-1034" class="calibre3">572</a></li>
<li id="calibre_link-1997" class="calibre6"><a href="#calibre_link-1035" class="calibre3">573</a></li>
<li id="calibre_link-1998" class="calibre6"><a href="#calibre_link-1036" class="calibre3">574</a></li>
<li id="calibre_link-1999" class="calibre6"><a href="#calibre_link-1037" class="calibre3">575</a></li>
<li id="calibre_link-2000" class="calibre6"><a href="#calibre_link-1038" class="calibre3">576</a></li>
<li id="calibre_link-2001" class="calibre6"><a href="#calibre_link-1039" class="calibre3">577</a></li>
<li id="calibre_link-2002" class="calibre6"><a href="#calibre_link-1040" class="calibre3">578</a></li>
<li id="calibre_link-2003" class="calibre6"><a href="#calibre_link-1041" class="calibre3">579</a></li>
<li id="calibre_link-2004" class="calibre6"><a href="#calibre_link-1042" class="calibre3">580</a></li>
<li id="calibre_link-2005" class="calibre6"><a href="#calibre_link-1043" class="calibre3">581</a></li>
<li id="calibre_link-2006" class="calibre6"><a href="#calibre_link-1044" class="calibre3">582</a></li>
<li id="calibre_link-2007" class="calibre6"><a href="#calibre_link-1045" class="calibre3">583</a></li>
<li id="calibre_link-2008" class="calibre6"><a href="#calibre_link-1046" class="calibre3">584</a></li>
<li id="calibre_link-2009" class="calibre6"><a href="#calibre_link-1047" class="calibre3">585</a></li>
<li id="calibre_link-2010" class="calibre6"><a href="#calibre_link-1048" class="calibre3">586</a></li>
<li id="calibre_link-2011" class="calibre6"><a href="#calibre_link-1049" class="calibre3">587</a></li>
<li id="calibre_link-2012" class="calibre6"><a href="#calibre_link-1050" class="calibre3">588</a></li>
<li id="calibre_link-2013" class="calibre6"><a href="#calibre_link-1051" class="calibre3">589</a></li>
<li id="calibre_link-2014" class="calibre6"><a href="#calibre_link-1052" class="calibre3">590</a></li>
<li id="calibre_link-2015" class="calibre6"><a href="#calibre_link-1053" class="calibre3">591</a></li>
<li id="calibre_link-2016" class="calibre6"><a href="#calibre_link-1054" class="calibre3">592</a></li>
<li id="calibre_link-2017" class="calibre6"><a href="#calibre_link-1055" class="calibre3">593</a></li>
<li id="calibre_link-2018" class="calibre6"><a href="#calibre_link-1056" class="calibre3">594</a></li>
<li id="calibre_link-2019" class="calibre6"><a href="#calibre_link-1057" class="calibre3">595</a></li>
<li id="calibre_link-2020" class="calibre6"><a href="#calibre_link-1058" class="calibre3">596</a></li>
<li id="calibre_link-2021" class="calibre6"><a href="#calibre_link-1059" class="calibre3">597</a></li>
<li id="calibre_link-2022" class="calibre6"><a href="#calibre_link-1060" class="calibre3">598</a></li>
<li id="calibre_link-2023" class="calibre6"><a href="#calibre_link-1061" class="calibre3">599</a></li>
<li id="calibre_link-2024" class="calibre6"><a href="#calibre_link-1062" class="calibre3">600</a></li>
<li id="calibre_link-2025" class="calibre6"><a href="#calibre_link-1063" class="calibre3">601</a></li>
<li id="calibre_link-2026" class="calibre6"><a href="#calibre_link-1064" class="calibre3">602</a></li>
<li id="calibre_link-2027" class="calibre6"><a href="#calibre_link-1065" class="calibre3">603</a></li>
<li id="calibre_link-2028" class="calibre6"><a href="#calibre_link-1066" class="calibre3">604</a></li>
<li id="calibre_link-2029" class="calibre6"><a href="#calibre_link-1067" class="calibre3">605</a></li>
<li id="calibre_link-2030" class="calibre6"><a href="#calibre_link-1068" class="calibre3">606</a></li>
<li id="calibre_link-2031" class="calibre6"><a href="#calibre_link-1069" class="calibre3">607</a></li>
<li id="calibre_link-2032" class="calibre6"><a href="#calibre_link-1070" class="calibre3">608</a></li>
<li id="calibre_link-2033" class="calibre6"><a href="#calibre_link-1071" class="calibre3">609</a></li>
<li id="calibre_link-2034" class="calibre6"><a href="#calibre_link-1072" class="calibre3">610</a></li>
<li id="calibre_link-2035" class="calibre6"><a href="#calibre_link-1073" class="calibre3">611</a></li>
<li id="calibre_link-2036" class="calibre6"><a href="#calibre_link-1074" class="calibre3">612</a></li>
<li id="calibre_link-2037" class="calibre6"><a href="#calibre_link-1075" class="calibre3">613</a></li>
<li id="calibre_link-2038" class="calibre6"><a href="#calibre_link-1076" class="calibre3">614</a></li>
<li id="calibre_link-2039" class="calibre6"><a href="#calibre_link-1077" class="calibre3">615</a></li>
<li id="calibre_link-2040" class="calibre6"><a href="#calibre_link-1078" class="calibre3">616</a></li>
<li id="calibre_link-2041" class="calibre6"><a href="#calibre_link-1079" class="calibre3">617</a></li>
<li id="calibre_link-2042" class="calibre6"><a href="#calibre_link-1080" class="calibre3">618</a></li>
<li id="calibre_link-2043" class="calibre6"><a href="#calibre_link-1081" class="calibre3">619</a></li>
<li id="calibre_link-2044" class="calibre6"><a href="#calibre_link-1082" class="calibre3">620</a></li>
<li id="calibre_link-2045" class="calibre6"><a href="#calibre_link-1083" class="calibre3">621</a></li>
<li id="calibre_link-2046" class="calibre6"><a href="#calibre_link-1084" class="calibre3">622</a></li>
<li id="calibre_link-2047" class="calibre6"><a href="#calibre_link-1085" class="calibre3">623</a></li>
<li id="calibre_link-2048" class="calibre6"><a href="#calibre_link-1086" class="calibre3">624</a></li>
<li id="calibre_link-2049" class="calibre6"><a href="#calibre_link-1087" class="calibre3">625</a></li>
<li id="calibre_link-2050" class="calibre6"><a href="#calibre_link-1088" class="calibre3">626</a></li>
<li id="calibre_link-2051" class="calibre6"><a href="#calibre_link-1089" class="calibre3">627</a></li>
<li id="calibre_link-2052" class="calibre6"><a href="#calibre_link-1090" class="calibre3">628</a></li>
<li id="calibre_link-2053" class="calibre6"><a href="#calibre_link-1091" class="calibre3">629</a></li>
<li id="calibre_link-2054" class="calibre6"><a href="#calibre_link-1092" class="calibre3">630</a></li>
<li id="calibre_link-2055" class="calibre6"><a href="#calibre_link-1093" class="calibre3">631</a></li>
<li id="calibre_link-2056" class="calibre6"><a href="#calibre_link-1094" class="calibre3">632</a></li>
<li id="calibre_link-2057" class="calibre6"><a href="#calibre_link-1095" class="calibre3">633</a></li>
<li id="calibre_link-2058" class="calibre6"><a href="#calibre_link-1096" class="calibre3">634</a></li>
<li id="calibre_link-2059" class="calibre6"><a href="#calibre_link-1097" class="calibre3">635</a></li>
<li id="calibre_link-2060" class="calibre6"><a href="#calibre_link-1098" class="calibre3">636</a></li>
<li id="calibre_link-2061" class="calibre6"><a href="#calibre_link-1099" class="calibre3">637</a></li>
<li id="calibre_link-2062" class="calibre6"><a href="#calibre_link-1100" class="calibre3">638</a></li>
<li id="calibre_link-2063" class="calibre6"><a href="#calibre_link-1101" class="calibre3">639</a></li>
<li id="calibre_link-2064" class="calibre6"><a href="#calibre_link-1102" class="calibre3">640</a></li>
<li id="calibre_link-2065" class="calibre6"><a href="#calibre_link-1103" class="calibre3">641</a></li>
<li id="calibre_link-2066" class="calibre6"><a href="#calibre_link-1104" class="calibre3">642</a></li>
<li id="calibre_link-2067" class="calibre6"><a href="#calibre_link-1105" class="calibre3">643</a></li>
<li id="calibre_link-2068" class="calibre6"><a href="#calibre_link-1106" class="calibre3">644</a></li>
<li id="calibre_link-2069" class="calibre6"><a href="#calibre_link-1107" class="calibre3">645</a></li>
<li id="calibre_link-2070" class="calibre6"><a href="#calibre_link-1108" class="calibre3">646</a></li>
<li id="calibre_link-2071" class="calibre6"><a href="#calibre_link-1109" class="calibre3">647</a></li>
<li id="calibre_link-2072" class="calibre6"><a href="#calibre_link-1110" class="calibre3">648</a></li>
<li id="calibre_link-2073" class="calibre6"><a href="#calibre_link-1111" class="calibre3">649</a></li>
<li id="calibre_link-2074" class="calibre6"><a href="#calibre_link-1112" class="calibre3">650</a></li>
<li id="calibre_link-2075" class="calibre6"><a href="#calibre_link-1113" class="calibre3">651</a></li>
<li id="calibre_link-2076" class="calibre6"><a href="#calibre_link-1114" class="calibre3">652</a></li>
<li id="calibre_link-2077" class="calibre6"><a href="#calibre_link-1115" class="calibre3">653</a></li>
<li id="calibre_link-2078" class="calibre6"><a href="#calibre_link-1116" class="calibre3">654</a></li>
<li id="calibre_link-2079" class="calibre6"><a href="#calibre_link-1117" class="calibre3">655</a></li>
<li id="calibre_link-2080" class="calibre6"><a href="#calibre_link-1118" class="calibre3">656</a></li>
<li id="calibre_link-2081" class="calibre6"><a href="#calibre_link-1119" class="calibre3">657</a></li>
<li id="calibre_link-2082" class="calibre6"><a href="#calibre_link-1120" class="calibre3">658</a></li>
<li id="calibre_link-2083" class="calibre6"><a href="#calibre_link-1121" class="calibre3">659</a></li>
<li id="calibre_link-2084" class="calibre6"><a href="#calibre_link-1122" class="calibre3">660</a></li>
<li id="calibre_link-2085" class="calibre6"><a href="#calibre_link-1123" class="calibre3">661</a></li>
<li id="calibre_link-2086" class="calibre6"><a href="#calibre_link-1124" class="calibre3">662</a></li>
<li id="calibre_link-2087" class="calibre6"><a href="#calibre_link-1125" class="calibre3">663</a></li>
<li id="calibre_link-2088" class="calibre6"><a href="#calibre_link-1126" class="calibre3">664</a></li>
<li id="calibre_link-2089" class="calibre6"><a href="#calibre_link-1127" class="calibre3">665</a></li>
<li id="calibre_link-2090" class="calibre6"><a href="#calibre_link-1128" class="calibre3">666</a></li>
<li id="calibre_link-2091" class="calibre6"><a href="#calibre_link-1129" class="calibre3">667</a></li>
<li id="calibre_link-2092" class="calibre6"><a href="#calibre_link-1130" class="calibre3">668</a></li>
<li id="calibre_link-2093" class="calibre6"><a href="#calibre_link-1131" class="calibre3">669</a></li>
<li id="calibre_link-2094" class="calibre6"><a href="#calibre_link-1132" class="calibre3">670</a></li>
<li id="calibre_link-2095" class="calibre6"><a href="#calibre_link-1133" class="calibre3">671</a></li>
<li id="calibre_link-2096" class="calibre6"><a href="#calibre_link-1134" class="calibre3">672</a></li>
<li id="calibre_link-2097" class="calibre6"><a href="#calibre_link-1135" class="calibre3">673</a></li>
<li id="calibre_link-2098" class="calibre6"><a href="#calibre_link-1136" class="calibre3">674</a></li>
<li id="calibre_link-2099" class="calibre6"><a href="#calibre_link-1137" class="calibre3">675</a></li>
<li id="calibre_link-2100" class="calibre6"><a href="#calibre_link-1138" class="calibre3">676</a></li>
<li id="calibre_link-2101" class="calibre6"><a href="#calibre_link-1139" class="calibre3">677</a></li>
<li id="calibre_link-2102" class="calibre6"><a href="#calibre_link-1140" class="calibre3">678</a></li>
<li id="calibre_link-2103" class="calibre6"><a href="#calibre_link-1141" class="calibre3">679</a></li>
<li id="calibre_link-2104" class="calibre6"><a href="#calibre_link-1142" class="calibre3">680</a></li>
<li id="calibre_link-2105" class="calibre6"><a href="#calibre_link-1143" class="calibre3">681</a></li>
<li id="calibre_link-2106" class="calibre6"><a href="#calibre_link-1144" class="calibre3">682</a></li>
<li id="calibre_link-2107" class="calibre6"><a href="#calibre_link-1145" class="calibre3">683</a></li>
<li id="calibre_link-2108" class="calibre6"><a href="#calibre_link-1146" class="calibre3">684</a></li>
<li id="calibre_link-2109" class="calibre6"><a href="#calibre_link-1147" class="calibre3">685</a></li>
<li id="calibre_link-2110" class="calibre6"><a href="#calibre_link-1148" class="calibre3">686</a></li>
<li id="calibre_link-2111" class="calibre6"><a href="#calibre_link-1149" class="calibre3">687</a></li>
<li id="calibre_link-2112" class="calibre6"><a href="#calibre_link-1150" class="calibre3">688</a></li>
<li id="calibre_link-2113" class="calibre6"><a href="#calibre_link-1151" class="calibre3">689</a></li>
<li id="calibre_link-2114" class="calibre6"><a href="#calibre_link-1152" class="calibre3">690</a></li>
<li id="calibre_link-2115" class="calibre6"><a href="#calibre_link-1153" class="calibre3">691</a></li>
<li id="calibre_link-2116" class="calibre6"><a href="#calibre_link-1154" class="calibre3">692</a></li>
<li id="calibre_link-2117" class="calibre6"><a href="#calibre_link-1155" class="calibre3">693</a></li>
<li id="calibre_link-2118" class="calibre6"><a href="#calibre_link-1156" class="calibre3">694</a></li>
<li id="calibre_link-2119" class="calibre6"><a href="#calibre_link-1157" class="calibre3">695</a></li>
<li id="calibre_link-2120" class="calibre6"><a href="#calibre_link-1158" class="calibre3">696</a></li>
<li id="calibre_link-2121" class="calibre6"><a href="#calibre_link-1159" class="calibre3">697</a></li>
<li id="calibre_link-2122" class="calibre6"><a href="#calibre_link-1160" class="calibre3">698</a></li>
<li id="calibre_link-2123" class="calibre6"><a href="#calibre_link-1161" class="calibre3">699</a></li>
<li id="calibre_link-2124" class="calibre6"><a href="#calibre_link-1162" class="calibre3">700</a></li>
<li id="calibre_link-2125" class="calibre6"><a href="#calibre_link-1163" class="calibre3">701</a></li>
<li id="calibre_link-2126" class="calibre6"><a href="#calibre_link-1164" class="calibre3">702</a></li>
<li id="calibre_link-2127" class="calibre6"><a href="#calibre_link-1165" class="calibre3">703</a></li>
<li id="calibre_link-2128" class="calibre6"><a href="#calibre_link-1166" class="calibre3">704</a></li>
<li id="calibre_link-2129" class="calibre6"><a href="#calibre_link-1167" class="calibre3">705</a></li>
<li id="calibre_link-2130" class="calibre6"><a href="#calibre_link-1168" class="calibre3">706</a></li>
<li id="calibre_link-2131" class="calibre6"><a href="#calibre_link-1169" class="calibre3">707</a></li>
<li id="calibre_link-2132" class="calibre6"><a href="#calibre_link-1170" class="calibre3">708</a></li>
<li id="calibre_link-2133" class="calibre6"><a href="#calibre_link-1171" class="calibre3">709</a></li>
<li id="calibre_link-2134" class="calibre6"><a href="#calibre_link-1172" class="calibre3">710</a></li>
<li id="calibre_link-2135" class="calibre6"><a href="#calibre_link-1173" class="calibre3">711</a></li>
<li id="calibre_link-2136" class="calibre6"><a href="#calibre_link-1174" class="calibre3">712</a></li>
<li id="calibre_link-2137" class="calibre6"><a href="#calibre_link-1175" class="calibre3">713</a></li>
<li id="calibre_link-2138" class="calibre6"><a href="#calibre_link-1176" class="calibre3">714</a></li>
<li id="calibre_link-2139" class="calibre6"><a href="#calibre_link-1177" class="calibre3">715</a></li>
<li id="calibre_link-2140" class="calibre6"><a href="#calibre_link-1178" class="calibre3">716</a></li>
<li id="calibre_link-2141" class="calibre6"><a href="#calibre_link-1179" class="calibre3">717</a></li>
<li id="calibre_link-2142" class="calibre6"><a href="#calibre_link-1180" class="calibre3">718</a></li>
<li id="calibre_link-2143" class="calibre6"><a href="#calibre_link-1181" class="calibre3">719</a></li>
<li id="calibre_link-2144" class="calibre6"><a href="#calibre_link-1182" class="calibre3">720</a></li>
<li id="calibre_link-2145" class="calibre6"><a href="#calibre_link-1183" class="calibre3">721</a></li>
<li id="calibre_link-2146" class="calibre6"><a href="#calibre_link-1184" class="calibre3">722</a></li>
<li id="calibre_link-2147" class="calibre6"><a href="#calibre_link-1185" class="calibre3">723</a></li>
<li id="calibre_link-2148" class="calibre6"><a href="#calibre_link-1186" class="calibre3">724</a></li>
<li id="calibre_link-2149" class="calibre6"><a href="#calibre_link-1187" class="calibre3">725</a></li>
<li id="calibre_link-2150" class="calibre6"><a href="#calibre_link-1188" class="calibre3">726</a></li>
<li id="calibre_link-2151" class="calibre6"><a href="#calibre_link-1189" class="calibre3">727</a></li>
<li id="calibre_link-2152" class="calibre6"><a href="#calibre_link-1190" class="calibre3">728</a></li>
<li id="calibre_link-2153" class="calibre6"><a href="#calibre_link-1191" class="calibre3">729</a></li>
<li id="calibre_link-2154" class="calibre6"><a href="#calibre_link-1192" class="calibre3">730</a></li>
<li id="calibre_link-2155" class="calibre6"><a href="#calibre_link-1193" class="calibre3">731</a></li>
<li id="calibre_link-2156" class="calibre6"><a href="#calibre_link-1194" class="calibre3">732</a></li>
<li id="calibre_link-2157" class="calibre6"><a href="#calibre_link-1195" class="calibre3">733</a></li>
<li id="calibre_link-2158" class="calibre6"><a href="#calibre_link-1196" class="calibre3">734</a></li>
<li id="calibre_link-2159" class="calibre6"><a href="#calibre_link-1197" class="calibre3">735</a></li>
<li id="calibre_link-2160" class="calibre6"><a href="#calibre_link-1198" class="calibre3">736</a></li>
<li id="calibre_link-2161" class="calibre6"><a href="#calibre_link-1199" class="calibre3">737</a></li>
<li id="calibre_link-2162" class="calibre6"><a href="#calibre_link-1200" class="calibre3">738</a></li>
<li id="calibre_link-2163" class="calibre6"><a href="#calibre_link-1201" class="calibre3">739</a></li>
<li id="calibre_link-2164" class="calibre6"><a href="#calibre_link-1202" class="calibre3">740</a></li>
<li id="calibre_link-2165" class="calibre6"><a href="#calibre_link-1203" class="calibre3">741</a></li>
<li id="calibre_link-2166" class="calibre6"><a href="#calibre_link-1204" class="calibre3">742</a></li>
<li id="calibre_link-2167" class="calibre6"><a href="#calibre_link-1205" class="calibre3">743</a></li>
<li id="calibre_link-2168" class="calibre6"><a href="#calibre_link-1206" class="calibre3">744</a></li>
<li id="calibre_link-2169" class="calibre6"><a href="#calibre_link-1207" class="calibre3">745</a></li>
<li id="calibre_link-2170" class="calibre6"><a href="#calibre_link-1208" class="calibre3">746</a></li>
<li id="calibre_link-2171" class="calibre6"><a href="#calibre_link-1209" class="calibre3">747</a></li>
<li id="calibre_link-2172" class="calibre6"><a href="#calibre_link-1210" class="calibre3">748</a></li>
<li id="calibre_link-2173" class="calibre6"><a href="#calibre_link-1211" class="calibre3">749</a></li>
<li id="calibre_link-2174" class="calibre6"><a href="#calibre_link-1212" class="calibre3">750</a></li>
<li id="calibre_link-2175" class="calibre6"><a href="#calibre_link-1213" class="calibre3">751</a></li>
<li id="calibre_link-2176" class="calibre6"><a href="#calibre_link-1214" class="calibre3">752</a></li>
<li id="calibre_link-2177" class="calibre6"><a href="#calibre_link-1215" class="calibre3">753</a></li>
<li id="calibre_link-2178" class="calibre6"><a href="#calibre_link-1216" class="calibre3">754</a></li>
<li id="calibre_link-2179" class="calibre6"><a href="#calibre_link-1217" class="calibre3">755</a></li>
<li id="calibre_link-2180" class="calibre6"><a href="#calibre_link-1218" class="calibre3">756</a></li>
<li id="calibre_link-2181" class="calibre6"><a href="#calibre_link-1219" class="calibre3">757</a></li>
<li id="calibre_link-2182" class="calibre6"><a href="#calibre_link-1220" class="calibre3">758</a></li>
<li id="calibre_link-2183" class="calibre6"><a href="#calibre_link-1221" class="calibre3">759</a></li>
<li id="calibre_link-2184" class="calibre6"><a href="#calibre_link-1222" class="calibre3">760</a></li>
<li id="calibre_link-2185" class="calibre6"><a href="#calibre_link-1223" class="calibre3">761</a></li>
<li id="calibre_link-2186" class="calibre6"><a href="#calibre_link-1224" class="calibre3">762</a></li>
<li id="calibre_link-2187" class="calibre6"><a href="#calibre_link-1225" class="calibre3">763</a></li>
<li id="calibre_link-2188" class="calibre6"><a href="#calibre_link-1226" class="calibre3">764</a></li>
<li id="calibre_link-2189" class="calibre6"><a href="#calibre_link-1227" class="calibre3">765</a></li>
<li id="calibre_link-2190" class="calibre6"><a href="#calibre_link-1228" class="calibre3">766</a></li>
<li id="calibre_link-2191" class="calibre6"><a href="#calibre_link-1229" class="calibre3">767</a></li>
<li id="calibre_link-2192" class="calibre6"><a href="#calibre_link-1230" class="calibre3">768</a></li>
<li id="calibre_link-2193" class="calibre6"><a href="#calibre_link-1231" class="calibre3">769</a></li>
<li id="calibre_link-2194" class="calibre6"><a href="#calibre_link-1232" class="calibre3">770</a></li>
<li id="calibre_link-2195" class="calibre6"><a href="#calibre_link-1233" class="calibre3">771</a></li>
<li id="calibre_link-2196" class="calibre6"><a href="#calibre_link-1234" class="calibre3">772</a></li>
<li id="calibre_link-2197" class="calibre6"><a href="#calibre_link-1235" class="calibre3">773</a></li>
<li id="calibre_link-2198" class="calibre6"><a href="#calibre_link-1236" class="calibre3">774</a></li>
<li id="calibre_link-2199" class="calibre6"><a href="#calibre_link-1237" class="calibre3">775</a></li>
<li id="calibre_link-2200" class="calibre6"><a href="#calibre_link-1238" class="calibre3">776</a></li>
<li id="calibre_link-2201" class="calibre6"><a href="#calibre_link-1239" class="calibre3">777</a></li>
<li id="calibre_link-2202" class="calibre6"><a href="#calibre_link-1240" class="calibre3">778</a></li>
<li id="calibre_link-2203" class="calibre6"><a href="#calibre_link-1241" class="calibre3">779</a></li>
<li id="calibre_link-2204" class="calibre6"><a href="#calibre_link-1242" class="calibre3">780</a></li>
<li id="calibre_link-2205" class="calibre6"><a href="#calibre_link-1243" class="calibre3">781</a></li>
<li id="calibre_link-2206" class="calibre6"><a href="#calibre_link-1244" class="calibre3">782</a></li>
<li id="calibre_link-2207" class="calibre6"><a href="#calibre_link-1245" class="calibre3">783</a></li>
<li id="calibre_link-2208" class="calibre6"><a href="#calibre_link-1246" class="calibre3">784</a></li>
<li id="calibre_link-2209" class="calibre6"><a href="#calibre_link-1247" class="calibre3">785</a></li>
<li id="calibre_link-2210" class="calibre6"><a href="#calibre_link-1248" class="calibre3">786</a></li>
<li id="calibre_link-2211" class="calibre6"><a href="#calibre_link-1249" class="calibre3">787</a></li>
<li id="calibre_link-2212" class="calibre6"><a href="#calibre_link-1250" class="calibre3">788</a></li>
<li id="calibre_link-2213" class="calibre6"><a href="#calibre_link-1251" class="calibre3">789</a></li>
<li id="calibre_link-2214" class="calibre6"><a href="#calibre_link-1252" class="calibre3">790</a></li>
<li id="calibre_link-2215" class="calibre6"><a href="#calibre_link-1253" class="calibre3">791</a></li>
<li id="calibre_link-2216" class="calibre6"><a href="#calibre_link-1254" class="calibre3">792</a></li>
<li id="calibre_link-2217" class="calibre6"><a href="#calibre_link-1255" class="calibre3">793</a></li>
<li id="calibre_link-2218" class="calibre6"><a href="#calibre_link-1256" class="calibre3">794</a></li>
<li id="calibre_link-2219" class="calibre6"><a href="#calibre_link-1257" class="calibre3">795</a></li>
<li id="calibre_link-2220" class="calibre6"><a href="#calibre_link-1258" class="calibre3">796</a></li>
<li id="calibre_link-2221" class="calibre6"><a href="#calibre_link-1259" class="calibre3">797</a></li>
<li id="calibre_link-2222" class="calibre6"><a href="#calibre_link-1260" class="calibre3">798</a></li>
<li id="calibre_link-2223" class="calibre6"><a href="#calibre_link-1261" class="calibre3">799</a></li>
<li id="calibre_link-2224" class="calibre6"><a href="#calibre_link-1262" class="calibre3">800</a></li>
<li id="calibre_link-2225" class="calibre6"><a href="#calibre_link-1263" class="calibre3">801</a></li>
<li id="calibre_link-2226" class="calibre6"><a href="#calibre_link-1264" class="calibre3">802</a></li>
<li id="calibre_link-2227" class="calibre6"><a href="#calibre_link-1265" class="calibre3">803</a></li>
<li id="calibre_link-2228" class="calibre6"><a href="#calibre_link-1266" class="calibre3">804</a></li>
<li id="calibre_link-2229" class="calibre6"><a href="#calibre_link-1267" class="calibre3">805</a></li>
<li id="calibre_link-2230" class="calibre6"><a href="#calibre_link-1268" class="calibre3">806</a></li>
<li id="calibre_link-2231" class="calibre6"><a href="#calibre_link-1269" class="calibre3">807</a></li>
<li id="calibre_link-2232" class="calibre6"><a href="#calibre_link-1270" class="calibre3">808</a></li>
<li id="calibre_link-2233" class="calibre6"><a href="#calibre_link-1271" class="calibre3">809</a></li>
<li id="calibre_link-2234" class="calibre6"><a href="#calibre_link-1272" class="calibre3">810</a></li>
<li id="calibre_link-2235" class="calibre6"><a href="#calibre_link-1273" class="calibre3">811</a></li>
<li id="calibre_link-2236" class="calibre6"><a href="#calibre_link-1274" class="calibre3">812</a></li>
<li id="calibre_link-2237" class="calibre6"><a href="#calibre_link-1275" class="calibre3">813</a></li>
<li id="calibre_link-2238" class="calibre6"><a href="#calibre_link-1276" class="calibre3">814</a></li>
<li id="calibre_link-2239" class="calibre6"><a href="#calibre_link-1277" class="calibre3">815</a></li>
<li id="calibre_link-2240" class="calibre6"><a href="#calibre_link-1278" class="calibre3">816</a></li>
<li id="calibre_link-2241" class="calibre6"><a href="#calibre_link-1279" class="calibre3">817</a></li>
<li id="calibre_link-2242" class="calibre6"><a href="#calibre_link-1280" class="calibre3">818</a></li>
<li id="calibre_link-2243" class="calibre6"><a href="#calibre_link-1281" class="calibre3">819</a></li>
<li id="calibre_link-2244" class="calibre6"><a href="#calibre_link-1282" class="calibre3">820</a></li>
<li id="calibre_link-2245" class="calibre6"><a href="#calibre_link-1283" class="calibre3">821</a></li>
<li id="calibre_link-2246" class="calibre6"><a href="#calibre_link-1284" class="calibre3">822</a></li>
<li id="calibre_link-2247" class="calibre6"><a href="#calibre_link-1285" class="calibre3">823</a></li>
<li id="calibre_link-2248" class="calibre6"><a href="#calibre_link-1286" class="calibre3">824</a></li>
<li id="calibre_link-2249" class="calibre6"><a href="#calibre_link-1287" class="calibre3">825</a></li>
<li id="calibre_link-2250" class="calibre6"><a href="#calibre_link-1288" class="calibre3">826</a></li>
<li id="calibre_link-2251" class="calibre6"><a href="#calibre_link-1289" class="calibre3">827</a></li>
<li id="calibre_link-2252" class="calibre6"><a href="#calibre_link-1290" class="calibre3">828</a></li>
<li id="calibre_link-2253" class="calibre6"><a href="#calibre_link-1291" class="calibre3">829</a></li>
<li id="calibre_link-2254" class="calibre6"><a href="#calibre_link-1292" class="calibre3">830</a></li>
<li id="calibre_link-2255" class="calibre6"><a href="#calibre_link-1293" class="calibre3">831</a></li>
<li id="calibre_link-2256" class="calibre6"><a href="#calibre_link-1294" class="calibre3">832</a></li>
<li id="calibre_link-2257" class="calibre6"><a href="#calibre_link-1295" class="calibre3">833</a></li>
<li id="calibre_link-2258" class="calibre6"><a href="#calibre_link-1296" class="calibre3">834</a></li>
<li id="calibre_link-2259" class="calibre6"><a href="#calibre_link-1297" class="calibre3">835</a></li>
<li id="calibre_link-2260" class="calibre6"><a href="#calibre_link-1298" class="calibre3">836</a></li>
<li id="calibre_link-2261" class="calibre6"><a href="#calibre_link-1299" class="calibre3">837</a></li>
<li id="calibre_link-2262" class="calibre6"><a href="#calibre_link-1300" class="calibre3">838</a></li>
<li id="calibre_link-2263" class="calibre6"><a href="#calibre_link-1301" class="calibre3">839</a></li>
<li id="calibre_link-2264" class="calibre6"><a href="#calibre_link-1302" class="calibre3">840</a></li>
<li id="calibre_link-2265" class="calibre6"><a href="#calibre_link-1303" class="calibre3">841</a></li>
<li id="calibre_link-2266" class="calibre6"><a href="#calibre_link-1304" class="calibre3">842</a></li>
<li id="calibre_link-2267" class="calibre6"><a href="#calibre_link-1305" class="calibre3">843</a></li>
<li id="calibre_link-2268" class="calibre6"><a href="#calibre_link-1306" class="calibre3">844</a></li>
<li id="calibre_link-2269" class="calibre6"><a href="#calibre_link-1307" class="calibre3">845</a></li>
<li id="calibre_link-2270" class="calibre6"><a href="#calibre_link-1308" class="calibre3">846</a></li>
<li id="calibre_link-2271" class="calibre6"><a href="#calibre_link-1309" class="calibre3">847</a></li>
<li id="calibre_link-2272" class="calibre6"><a href="#calibre_link-1310" class="calibre3">848</a></li>
<li id="calibre_link-2273" class="calibre6"><a href="#calibre_link-1311" class="calibre3">849</a></li>
<li id="calibre_link-2274" class="calibre6"><a href="#calibre_link-1312" class="calibre3">850</a></li>
<li id="calibre_link-2275" class="calibre6"><a href="#calibre_link-1313" class="calibre3">851</a></li>
<li id="calibre_link-2276" class="calibre6"><a href="#calibre_link-1314" class="calibre3">852</a></li>
<li id="calibre_link-2277" class="calibre6"><a href="#calibre_link-1315" class="calibre3">853</a></li>
<li id="calibre_link-2278" class="calibre6"><a href="#calibre_link-1316" class="calibre3">854</a></li>
<li id="calibre_link-2279" class="calibre6"><a href="#calibre_link-1317" class="calibre3">855</a></li>
<li id="calibre_link-2280" class="calibre6"><a href="#calibre_link-1318" class="calibre3">856</a></li>
<li id="calibre_link-2281" class="calibre6"><a href="#calibre_link-1319" class="calibre3">857</a></li>
<li id="calibre_link-2282" class="calibre6"><a href="#calibre_link-1320" class="calibre3">858</a></li>
<li id="calibre_link-2283" class="calibre6"><a href="#calibre_link-1321" class="calibre3">859</a></li>
<li id="calibre_link-2284" class="calibre6"><a href="#calibre_link-1322" class="calibre3">860</a></li>
<li id="calibre_link-2285" class="calibre6"><a href="#calibre_link-1323" class="calibre3">861</a></li>
<li id="calibre_link-2286" class="calibre6"><a href="#calibre_link-1324" class="calibre3">862</a></li>
<li id="calibre_link-2287" class="calibre6"><a href="#calibre_link-1325" class="calibre3">863</a></li>
<li id="calibre_link-2288" class="calibre6"><a href="#calibre_link-1326" class="calibre3">864</a></li>
<li id="calibre_link-2289" class="calibre6"><a href="#calibre_link-1327" class="calibre3">865</a></li>
<li id="calibre_link-2290" class="calibre6"><a href="#calibre_link-1328" class="calibre3">866</a></li>
<li id="calibre_link-2291" class="calibre6"><a href="#calibre_link-1329" class="calibre3">867</a></li>
<li id="calibre_link-2292" class="calibre6"><a href="#calibre_link-1330" class="calibre3">868</a></li>
<li id="calibre_link-2293" class="calibre6"><a href="#calibre_link-1331" class="calibre3">869</a></li>
<li id="calibre_link-2294" class="calibre6"><a href="#calibre_link-1332" class="calibre3">870</a></li>
<li id="calibre_link-2295" class="calibre6"><a href="#calibre_link-1333" class="calibre3">871</a></li>
<li id="calibre_link-2296" class="calibre6"><a href="#calibre_link-1334" class="calibre3">872</a></li>
<li id="calibre_link-2297" class="calibre6"><a href="#calibre_link-1335" class="calibre3">873</a></li>
<li id="calibre_link-2298" class="calibre6"><a href="#calibre_link-1336" class="calibre3">874</a></li>
<li id="calibre_link-2299" class="calibre6"><a href="#calibre_link-1337" class="calibre3">875</a></li>
<li id="calibre_link-2300" class="calibre6"><a href="#calibre_link-1338" class="calibre3">876</a></li>
<li id="calibre_link-2301" class="calibre6"><a href="#calibre_link-1339" class="calibre3">877</a></li>
<li id="calibre_link-2302" class="calibre6"><a href="#calibre_link-1340" class="calibre3">878</a></li>
<li id="calibre_link-2303" class="calibre6"><a href="#calibre_link-1341" class="calibre3">879</a></li>
<li id="calibre_link-2304" class="calibre6"><a href="#calibre_link-1342" class="calibre3">880</a></li>
<li id="calibre_link-2305" class="calibre6"><a href="#calibre_link-1343" class="calibre3">918</a></li>
<li id="calibre_link-2306" class="calibre6"><a href="#calibre_link-1344" class="calibre3">919</a></li>
<li id="calibre_link-2307" class="calibre6"><a href="#calibre_link-1345" class="calibre3">920</a></li>
<li id="calibre_link-2308" class="calibre6"><a href="#calibre_link-1346" class="calibre3">921</a></li>
<li id="calibre_link-2309" class="calibre6"><a href="#calibre_link-1347" class="calibre3">922</a></li>
</ol>
</nav>
<nav class="pagelist" {http://www.idpf.org/2007/ops}type="landmarks" id="calibre_link-2310">
<h2 class="calibre4">Guide</h2>
<ol class="calibre5">
<li id="calibre_link-2311" class="calibre6"><a {http://www.idpf.org/2007/ops}type="cover" href="xhtml/cover.xhtml" class="calibre3">Cover</a></li>
<li id="calibre_link-2312" class="calibre6"><a {http://www.idpf.org/2007/ops}type="toc" href="#calibre_link-1348" class="calibre3">Table of Contents</a></li>
<li id="calibre_link-2313" class="calibre6"><a {http://www.idpf.org/2007/ops}type="bodymatter" href="#calibre_link-0" class="calibre3">Begin Reading</a></li>
</ol>
</nav>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-237">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2314" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="1" id="calibre_link-463" class="calibre9"></span><span class="chapternumber">Chapter 1</span><br class="calibre10" /><span class="chapternumber">Programming with Visual C++</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">What the principal components of Visual C++ are</li>
<li class="calibre6">What solutions and projects are and how you create them</li>
<li class="calibre6">About console programs</li>
<li class="calibre6">How to create and edit a program</li>
<li class="calibre6">How to compile, link, and execute C++ console programs</li>
<li class="calibre6">How to create and execute basic Windows programs</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 1 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-238" class="calibre3"></a>LEARNING WITH VISUAL C++</h2>
<p class="calibre13">Windows programming isn’t difficult. Microsoft Visual C++ makes it remarkably easy, as you’ll see throughout the course of this book. There’s just one obstacle in your path: Before you get to the specifics of Windows programming, you have to be thoroughly familiar with the capabilities of the C++ programming language, particularly the object-oriented capabilities. Object-oriented techniques are central to the effectiveness of all the tools provided by Visual C++ for Windows programming, so it’s essential that you gain a good understanding of them. That’s exactly what this book provides.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="2" id="calibre_link-464" class="calibre14"></span>This chapter gives you an overview of the essential concepts involved in programming applications in C++. You’ll take a rapid tour of the integrated development environment (IDE) that comes with Visual C++. The IDE is straightforward and generally intuitive in its operation, so you’ll be able to pick up most of it as you go along. The best way to get familiar with it is to work through the process of creating, compiling, and executing a simple program. So power up your PC, start Windows, load the mighty Visual C++, and begin your journey.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-239" class="calibre3"></a>WRITING C++ APPLICATIONS</h2>
<p class="calibre13">You have tremendous flexibility in the types of applications and program components that you can develop with Visual C++. Applications that you can develop fall into two broad categories: <i class="calibre15">desktop applications</i> and <i class="calibre15">Windows Store apps</i>. Desktop applications are the applications that you know and love; they have an application window that typically has a menu bar and a toolbar and frequently a status bar at the bottom of the application window. This book focuses primarily on desktop applications.</p>
<p class="calibre13">Windows Store apps only run under Windows 8 or later versions and have a user interface that is completely different from desktop applications. The focus is on the content where the user interacts directly with the data, rather than interacting with controls such as menu items and toolbar buttons.</p>
<p class="calibre13">Once you have learned C++, this book concentrates on using the Microsoft Foundation Classes (MFC) with C++ for building desktop applications. The application programming interface (API) for Windows desktop applications is referred to as <i class="calibre15">Win32</i>. Win32 has a long history and was developed long before the object-oriented programming paradigm emerged, so it has none of the object-oriented characteristics that would be expected if it were written today. The MFC consists of a set of C++ classes that encapsulate the Win32 API for user interface creation and control and greatly eases the process of program development. You are not obliged to use the MFC, though. If you want the ultimate in performance you can write your C++ code to access the Windows API directly, but it certainly won’t be as easy.</p>
<p class="calibre13"><a id="calibre_link-1385" href="#calibre_link-392" class="calibre3">Figure 1-1</a> shows the basic options you have for developing C++ applications.</p>
<figure class="calibre16">
<img class="center" src="images/000009.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-392" href="#calibre_link-1385" class="calibre3">FIGURE 1-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><a href="#calibre_link-392" class="calibre3">Figure 1-1</a> is a simplified representation of what is involved. Desktop applications can target Windows 7, Windows 8, or Windows Vista. Windows Store apps execute only with Windows 8 and its successors and you must have Visual Studio 2013 installed under Windows 8 or later to develop them. Windows Store apps communicate with the operating system through the Windows Runtime, WinRT. I’ll introduce you to programming Windows 8 applications in Chapter 18.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-240" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="3" id="calibre_link-465" class="calibre18"></span>LEARNING DESKTOP APPLICATIONS PROGRAMMING</h2>
<p class="calibre13">There are always two basic aspects to interactive desktop applications executing under Windows: You need code to create the <i class="calibre15">graphical user interface</i> (GUI) with which the user interacts, and you need code to process these interactions to provide the functionality of the application. Visual C++ provides you with a great deal of assistance in both aspects. As you’ll see later in this chapter, you can create a working Windows program with a GUI without writing any code at all. All the basic code to create the GUI can be generated automatically by Visual C++. Of course, it’s essential to understand how this automatically generated code works because you need to extend and modify it to make the application do what you want. To do that, you need a comprehensive understanding of C++.</p>
<p class="calibre13">For this reason you’ll first learn C++ without getting involved in Windows programming considerations. After you’re comfortable with C++ you’ll learn how to develop fully fledged Windows applications. This means that while you are learning C++, you’ll be working with programs that involve only command line input and output. By sticking to this rather limited input and output capability, you’ll be able to concentrate on the specifics of how the C++ language works and avoid the inevitable complications involved in GUI building and control. Once you are comfortable with C++ you’ll find that it’s an easy and natural progression to applying C++ to the development of Windows applications.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">As I’ll explain in Chapter 18, Windows Store apps are different. You specify the GUI in XAML, and the XAML is processed to generate the C++ code for GUI elements.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">Learning C++</h3>
<p class="calibre13">Visual C++ supports the C++ language defined by the most recent ISO/IEC C++ standard that was published in 2011. The standard is defined in the document ISO/IEC 14882:2011 and commonly referred to as <i class="calibre15">C++ 11</i>. The Visual C++ compiler supports most of the language features introduced by this latest standard, and it includes some features from the draft for the next standard, C++ 14. Programs that you write in standard C++ can be ported from one system environment to another reasonably easily; although, the library functions that a program uses &mdash; particularly those related to building a graphical user interface &mdash; are a major determinant of how easy or difficult it will be. C++ is the first choice of a great many professional program developers because it is so widely supported, and because it is one of the most powerful programming languages available today.</p>
<p class="calibre13">Chapters 2 through 9 of this book teach you the C++ language and introduce some of the most commonly used C++ standard library facilities along the way. Chapter 10 explains how you can use the Standard Template Library (STL) for C++ for managing collections of data.</p>
</section>
<section class="toclist">
<h3 class="calibre21">C++ Concepts</h3>
<p class="calibre13">As with virtually all programming languages, there’s a chicken and egg problem in explaining C++. Inevitably there are occasions when I need to reference or make use of a language feature before I have discussed it in detail. This section is intended to help with this conundrum by outlining the principle C++ language elements. Of course, everything I mention here will be explained fully later in the book.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="4" id="calibre_link-466" class="calibre14"></span>Functions</h4>
<p class="calibre13">Every C++ program consists of at least one, and usually many, <i class="calibre15">functions</i>. A function is a named block of executable code that you invoke or <i class="calibre15">call</i> using its name. There must always be one function with the name <code class="calibre23">main</code>, and execution always starts with the <code class="calibre23">main()</code> function. The parentheses following the function name can specify what information is passed to a function when you call it. I’ll always put parentheses after a function name in the text to distinguish it from other things. All the executable code in a program is contained in functions. The simplest C++ program consists of just the <code class="calibre23">main()</code> function.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Data and Variables</h4>
<p class="calibre13">You store an item of data in a <i class="calibre15">variable</i>. A variable is a named memory area that can store a data item of a particular type. There are several standard <i class="calibre15">fundamental data types</i> that store integers, non-integral numerical values, and character data. You can also define your own data types, which makes writing a program that deals with real-world objects much easier. Variables of types that you define store <i class="calibre15">objects</i>. Because each variable can only store data of a given type, C++ is said to be a <i class="calibre15">type-safe</i> language.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Classes and Objects</h4>
<p class="calibre13">A <i class="calibre15">class</i> is a block of code that defines a data type. A class has a name that is the name for your data type. An item of data of a class type is referred to as an <i class="calibre15">object</i>. You use the class type name when you create variables that can store objects of your data type.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Templates</h4>
<p class="calibre13">Circumstances often arise when you need several different classes or functions in a program where the code for these only differs in the kind of data they work with. Templates save a lot of coding effort in such situations.</p>
<p class="calibre13">A <i class="calibre15">template</i> is a recipe or specification that you create that can be used by the compiler to generate code automatically in a program when requested. You can define <i class="calibre15">class templates</i> that the compiler can use to generate one or more of a family of classes. You can also define <i class="calibre15">function templates</i> that the compiler can use to generate functions. Each template has a name that you use when you want the compiler to create an instance of it.</p>
<p class="calibre13">The code for the class or function that the compiler generates from a template depends on one or more <i class="calibre15">template argument</i>s. The arguments are usually types, but not always. Typically you specify the template arguments explicitly when you use a class template. The compiler can usually deduce the arguments for a function template from the context.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Program Files</h4>
<p class="calibre13">C++ program code is stored in two kinds of files. <i class="calibre15">Source files</i> contain executable code and have the extension <code class="calibre23">.cpp</code>. <i class="calibre15">Header files</i> contain definitions for things, such as classes and templates, that are used by the executable code. Header files have the extension <code class="calibre23">.h</code>.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="5" id="calibre_link-467" class="calibre24"></span>Console Applications</h3>
<p class="calibre13">Visual C++ <i class="calibre15">console applications</i> enable you to write, compile, and test C++ programs that have none of the baggage required by Windows desktop applications. These programs are called console applications because you communicate with them through the keyboard and the screen in character mode, so they are essentially character-based, command-line programs.</p>
<p class="calibre13">In Chapters 2 through 10 you’ll only be working with console applications. Writing console applications might seem to be side-tracking you from the main objective of programming Windows applications with a GUI. However, when it comes to learning C++, it’s by far the best way to proceed in my view. There’s a <i class="calibre15">lot</i> of code in even a simple Windows program, and it’s very important not to be distracted by the complexities of Windows when learning the ins and outs of C++. In the early chapters of the book you’ll be learning C++ with a few lightweight console applications, before you get to work with the heavyweight sacks of code that are implicit in the world of Windows.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Windows Programming Concepts</h3>
<p class="calibre13">The project creation facilities in Visual C++ can generate skeleton code automatically for a variety of applications. A Windows program has a completely different structure from that of the typical console program, and it’s much more complicated. In a console program, you can get user input from the keyboard and write output back to the command line directly, and that is essentially it. A Windows application can access the input and output facilities of the computer only by way of functions supplied by the host environment; no direct access to the hardware resources is permitted. Several programs can be executing concurrently under Windows, so the operating system has to determine which application should receive a given raw input, such as a mouse click or the pressing of a key on the keyboard, and signal the program accordingly. Thus, the Windows operating system always manages all communications with the user.</p>
<p class="calibre13">The nature of the interface between a user and a Windows desktop application is such that a wide range of different inputs is usually possible at any given time. A user may select any of a number of menu options, click any of several toolbar buttons, or click the mouse somewhere in the application window. A well-designed Windows application has to be prepared to deal with any of these possible types of input at any time because there is no way of knowing in advance which type of input is going to occur. These user actions are received by the operating system in the first instance, and are all regarded by Windows as <i class="calibre15">events</i>. An event that originates with the user interface for your application will typically result in a particular piece of your program code being executed. How execution proceeds is therefore determined by the sequence of user actions. Programs that operate in this way are referred to as <i class="calibre15">event-driven programs</i>, and are different from traditional procedural programs that have a single order of execution. Input to a procedural program is controlled by the program code and can occur only when the program permits it. A Windows program consists primarily of pieces of code that respond to events caused by the action of the user, or by Windows itself. This sort of program structure is illustrated in <a id="calibre_link-1386" href="#calibre_link-393" class="calibre3">Figure 1-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000089.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-393" href="#calibre_link-1386" class="calibre3">FIGURE 1-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Each block within the Desktop Application block in <a href="#calibre_link-393" class="calibre3">Figure 1-2</a> represents a piece of code that deals with a particular kind of event. The program may appear to be somewhat fragmented because of the disjointed blocks of code, but the primary factor welding the program into a whole is the Windows operating system itself. You can think of your program as customizing Windows to provide a particular set of capabilities.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="6" id="calibre_link-468" class="calibre14"></span>Of course, modules servicing external events, such as the selection of a menu or a mouse click, will typically need access to a common set of application-specific data. This data contains information that relates to what the program is about &mdash; for example, blocks of text recording scoring records for a player in a program aimed at tracking how your baseball team is doing &mdash; as well as information about some of the events that have occurred during execution of the program. This shared data allows various parts of the program that look independent to communicate and operate in a coordinated and integrated fashion. I will go into this in much more detail later in the book.</p>
<p class="calibre13">Even an elementary Windows program involves several lines of code, and with Windows programs generated by the application wizards that come with Visual C++, “several” turns out to be “very many”. To simplify the process of understanding how C++ works, you need a context that is as uncomplicated as possible and at the same time has the tools to make it easy to create and navigate around sacks of code. Fortunately, Visual C++ comes with an environment that is designed specifically for the purpose.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-241" class="calibre3"></a>THE INTEGRATED DEVELOPMENT ENVIRONMENT</h2>
<p class="calibre13">The <i class="calibre15">integrated development environment</i> (IDE) is a self-contained environment in Visual C++ for creating, compiling, linking, testing, and debugging C++ programs of any kind. It also happens to be a great environment in which to learn the language (particularly when combined with a great book). The IDE incorporates a range of fully integrated tools that make the whole process of writing programs easy. You will see something of these in this chapter, but rather than grind through a boring litany of features and options in the abstract, I’ll introduce you to the basics to get a view of how the IDE works and then you’ll be able to pick up the rest in context as you go along.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="7" id="calibre_link-469" class="calibre14"></span>The fundamental elements you’ll be working with through the IDE are the editor, the C++ compiler, the linker, and the libraries. These are the basic tools that are essential to writing and executing a C++ program.</p>
<section class="toclist">
<h3 class="calibre21">The Editor</h3>
<p class="calibre13">The <i class="calibre15">editor</i> is an interactive environment in which you create and edit C++ source code. As well as the usual facilities such as cut and paste that you are certainly already familiar with, the editor offers a wide range of capabilities to help you get things right. For example:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Code is automatically laid out with standard indentation and spacing. There’s a default arrangement for code, but you can customize how your code is arranged in the dialog that displays when you select Tools <img src="images/000122.png" alt="image" class="calibre25" /> Options from the menu.</li>
<li class="calibre6">Fundamental words in C++ are recognized automatically and colored according to what they are. This makes your code more readable and easier to follow.</li>
<li class="calibre6"><i class="calibre15">IntelliSense</i> analyzes code as you enter it. Anything that is incorrect or any words IntelliSense doesn’t recognize are underlined with a red squiggle. It also provides prompts when it can determine the options for what you need to enter next. This saves typing because you can just select from a list.</li>
</ul>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">IntelliSense doesn’t just work with C++. It works with XAML too.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The Compiler</h3>
<p class="calibre13">You execute the <i class="calibre15">compiler</i> when you have entered the C++ code for your program. The compiler converts your source code into <i class="calibre15">object code</i>, and detects and reports errors in the compilation process. The compiler detects a wide range of errors caused by invalid or unrecognized program code, as well as structural errors, such as parts of a program that can never be executed. The object code generated by the compiler is stored in <i class="calibre15">object files</i> that have the extension <code class="calibre23">.obj.</code></p>
</section>
<section class="toclist">
<h3 class="calibre21">The Linker</h3>
<p class="calibre13">The <i class="calibre15">linker</i> combines the modules generated by the compiler from source code files, adds required code modules from the standard libraries that are supplied as part of C++, and welds everything into an executable whole, usually in the form of an <code class="calibre23">.exe</code> file. The linker can also detect and report errors &mdash; for example, if part of your program is missing, or a non-existent library component is referenced.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Libraries</h3>
<p class="calibre13">A <i class="calibre15">library</i> is a collection of prewritten routines that support and extend the C++ language by providing standard professionally produced code units for common operations that you can incorporate into your programs. The operations implemented by the libraries greatly enhance productivity by saving you the effort of writing and testing the code for such operations yourself.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="8" id="calibre_link-470" class="calibre14"></span>The Standard C++ Library</h4>
<p class="calibre13">The <i class="calibre15">Standard C++ Library</i> defines a set of facilities that are common to all ISO/IEC standard-conforming C++ compilers. It contains a vast range of commonly used routines, including numerical functions, such as calculating square roots and evaluating trigonometrical functions; character- and string-processing functions, such as the classification of characters and the comparison of character strings; and many others. It also defines data types and standard templates for generating customized data types and functions. You’ll learn about many of these as you develop your knowledge of C++.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Microsoft Libraries</h4>
<p class="calibre13">Windows desktop applications are supported by a library called the <i class="calibre15">Microsoft Foundation Classes</i> (MFC). The MFC greatly reduces the effort needed to build the GUI for an application. (You’ll see a lot more of the MFC when you finish exploring the nuances of the C++ language.) There are other Microsoft libraries for desktop applications, but you won’t be exploring them in this book.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-242" class="calibre3"></a>USING THE IDE</h2>
<p class="calibre13">All program development and execution in this book is performed from within the IDE. When you start Visual C++ you’ll see an application window similar to that shown in <a id="calibre_link-1387" href="#calibre_link-394" class="calibre3">Figure 1-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000136.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-394" href="#calibre_link-1387" class="calibre3">FIGURE 1-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The pane to the left in <a href="#calibre_link-394" class="calibre3">Figure 1-3</a> is the <i class="calibre15">Solution Explorer window</i>, the middle pane presently showing the Start page is the <i class="calibre15">Editor window</i>, and the tab visible in the pane at the bottom is the <i class="calibre15">Output window</i>. The Properties pane on the right displays properties for a variety of entities in your <span {http://www.idpf.org/2007/ops}type="pagebreak" title="9" id="calibre_link-471" class="calibre14"></span>program. The Solution Explorer pane enables you to navigate through your program files and display their contents in the Editor window, and to add new files to your program. You can dock several windows where the Solution Explorer pane is located. Three are shown in <a href="#calibre_link-394" class="calibre3">Figure 1-3</a> and you can select other windows to be displayed here from the View menu. You can rearrange the windows by dragging their labels. The Editor window is where you enter and modify source code and other components of your application. The Output window displays the output from build operations during which a project is compiled and linked. You can choose to display other windows by selecting from the View menu.</p>
<p class="calibre13">Note that a window can be undocked from its position in the Visual Studio application window. Just right-click the title bar of the window you want to undock and select Float from the pop-up menu. In general, I will show windows in their undocked state in the book. You can restore a window to its docked state by right-clicking its title bar and selecting Dock from the pop-up or by dragging it with the left mouse button down to the position that you want in the application window.</p>
<section class="toclist">
<h3 class="calibre21">Toolbar Options</h3>
<p class="calibre13">You can choose which toolbars are displayed by right-clicking in the toolbar area. The range of toolbars in the list depends on which edition of Visual Studio 2013 you have installed. A pop-up menu with a list of toolbars (<a id="calibre_link-1388" href="#calibre_link-395" class="calibre3">Figure 1-4</a>) appears, and the toolbars that are currently displayed have checkmarks alongside them.</p>
<figure class="calibre16">
<img class="center" src="images/000108.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-395" href="#calibre_link-1388" class="calibre3">FIGURE 1-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">This is where you decide which toolbars are visible at any one time. To start with, make sure the Build, Debug, Formatting, Layout, Standard, and Text Editor menu items are selected. Clicking a toolbar in the list checks it if it is deselected, and results in it being displayed; clicking a toolbar that is selected deselects it and hides the toolbar.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A toolbar won’t necessarily display all of its buttons. You can add or remove buttons for a toolbar by clicking the down arrow that appears at the right of the button set. The buttons in the Text Editor toolbar that indent and unindent a set of highlighted statements are particularly useful, as are the buttons that comment out or uncomment a selected set of statements, so make sure these are displayed.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="10" id="calibre_link-472" class="calibre14"></span>You don’t have to clutter up the application window with all the toolbars you think you might need. Some toolbars appear automatically when required, and you’ll find that the default set of toolbars is adequate most of the time. As you develop your application, it may sometimes be more convenient to have access to a different set of toolbars. You can change the set of visible toolbars at any time by right-clicking in the toolbar area and choosing from the context menu.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">As in many other Windows applications, the toolbars come complete with tooltips. If you let the mouse pointer linger over a toolbar button for a second or two, a label will display the function of that button.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Dockable Toolbars</h3>
<p class="calibre13">A <i class="calibre15">dockable toolbar</i> is one that you can move around to position it at a convenient place in the window. Any of the toolbars can be docked at any of the four sides of the application window. Right-clicking in the toolbar area and selecting Customize from the pop-up will display the Customize dialog. You can choose where a particular toolbar is docked by selecting it and clicking the Modify Selection button. You can then choose from the drop-down list that appears to dock the toolbar where you want.</p>
<p class="calibre13">You’ll recognize many of the toolbar icons from other Windows applications, but you may not appreciate exactly what these icons do in the context of Visual C++, so I’ll describe them as we use them.</p>
<p class="calibre13">Because you’ll use a new project for every program you develop, looking at what exactly a project is and understanding how the mechanism for defining a project works is a good place to start finding out about Visual C++.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Documentation</h3>
<p class="calibre13">There will be plenty of occasions when you’ll want to find out more information about Visual C++ and its features and options. Pressing Ctrl+F1 will display the online product documentation in your browser. Pressing F1 with the cursor on a C++ language element in your code or a standard library item will open a browser window showing documentation for the element. The Help menu also provides various routes into the documentation, as well as access to program samples and technical support.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Projects and Solutions</h3>
<p class="calibre13">A <i class="calibre15">project</i> is a container for all the things that make up a program of some kind &mdash; it might be a console program, a window-based program, or some other kind of program. A project usually consists of several source files containing your code, plus possibly other files containing auxiliary data. All the files for a project are stored in the <i class="calibre15">project folder</i> and detailed information about the project is stored in an XML file with the extension <code class="calibre23">.vcxproj</code>, which is also in the project folder. The project folder contains other folders that are used to store the output from compiling and linking your project.</p>
<p class="calibre13">A <i class="calibre15">solution</i> is a mechanism for bringing together one or more programs and other resources that represent a solution to a particular data-processing problem. For example, a distributed order-entry <span {http://www.idpf.org/2007/ops}type="pagebreak" title="11" id="calibre_link-473" class="calibre14"></span>system for a business operation might be composed of several different programs, each of which is a project within a single solution. Therefore a solution is a folder in which all the information relating to one or more projects is stored, and there will be one or more project folders as subfolders of the solution folder. Information about the projects in a solution is stored in a file with the extension <code class="calibre23">.sln</code>. When you create a project, a new solution is created automatically, unless you elect to add the project to an existing solution. The <code class="calibre23">.suo</code> file is not that important. You can even delete the <code class="calibre23">.suo</code> file and Visual C++ will re-create it when opening the solution.</p>
<p class="calibre13">When you create a project along with a solution, you can add projects to the same solution. You can add any kind of project to an existing solution, but you will usually add only projects that are related in some way to the existing project or projects in the solution. Generally, unless you have a good reason to do otherwise, each of your projects should have its own solution. Each example you create with this book will be a single project within its own solution.</p>
<section class="toclist">
<h4 class="calibre22">Defining a Project</h4>
<p class="calibre13">The first step in writing a Visual C++ program is to create a project for it using the File <img src="images/000122.png" alt="image" class="calibre25" /> New <img src="images/000122.png" alt="image" class="calibre25" /> Project menu option from the main menu or by pressing Ctrl+Shift+N. You can also simply click New Project on the Start page. As well as containing files that define the code and any other data that makes up your program, the project XML file in the project folder also records the options you’ve set for the project. That’s enough introductory stuff for the moment. It’s time to get your hands dirty.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Creating a Project for a Win32 Console Application</h3>
<p class="calibre20">First, select File <img src="images/000122.png" alt="image" class="calibre25" /> New <img src="images/000122.png" alt="image" class="calibre25" /> Project, or use one of the other possibilities I mentioned earlier to bring up the New Project dialog. The left pane in the dialog displays the types of projects you can create; in this case, click <code class="calibre23">Win32</code>. This selection identifies an application wizard that creates the initial contents for the project. The right pane displays a list of templates for the project type you have chosen in the left pane. The template you select is used to create the files that make up the project. In the next dialog you can customize the files that are created when you click the OK button in this dialog. For most type/template combinations a basic set of source files is created automatically. Choose Win32 Console Application in this instance.</p>
<p class="calibre20">Enter a suitable name for your project by typing into the Name: text box &mdash; for example, you could call it Ex1_01, or you can choose your own project name. Visual C++ supports long filenames, so you have a lot of flexibility. The name of the solution folder appears in the bottom text box and by default it is the same as the project name. You can change this if you prefer. The dialog also enables you to modify the location for the solution that contains your project &mdash; this appears in the Location: text box. If you simply enter a name for your project, the solution folder is automatically set to a folder with that name, with the path shown in the Location: text box. By default the solution folder is created for you if it doesn’t already exist. To specify a different path for the solution folder, just enter it in the Location: text box. Alternatively, you can use the Browse button to select a path for your solution. Clicking OK displays the Win32 Application Wizard dialog.</p>
<p class="calibre20">This dialog explains the settings currently in effect. You can click Application Settings on the left to display the Application Settings page of the wizard, shown in <a id="calibre_link-1389" href="#calibre_link-396" class="calibre3">Figure 1-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000012.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-396" href="#calibre_link-1389" class="calibre3">FIGURE 1-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="12" id="calibre_link-474" class="calibre14"></span>The Application Settings page enables you to choose options that apply to the project. You can see that you are creating a console application and not a Windows application. The Precompiled header option is a facility for compiling header files such as those from the standard library that do not change frequently. When you compile your program after making changes or additions to your code, the precompiled code that has not been changed will be reused as is. This makes compiling your program faster. You can uncheck the Security Development Lifecycle Checks checkbox option; this feature adds functionality for managing large-scale professional projects and we won’t be using these. On the right of the dialog there are options for using MFC, which I have mentioned, and ATL, which is outside the scope of this book. For this project you can leave the rest of the options as they are and click Finish. The application wizard will create the project with default files.</p>
<p class="calibre20">The project folder will have the name that you supplied as the project name and will hold the files making up the project definition. If you didn’t change it, the solution folder has the same name as the project folder and contains the project folder plus the files defining the contents of the solution. If you use Windows Explorer to inspect the contents of the solution folder, you’ll see that it contains four files:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">A file with the extension <code class="calibre23">.sln</code> that records information about the projects in the solution.</li>
<li class="calibre6">A file with the extension <code class="calibre23">.suo</code> in which user options that apply to the solution will be recorded.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="13" id="calibre_link-475" class="calibre14"></span>A file with the extension <code class="calibre23">.sdf</code> that records data about IntelliSense for the solution. IntelliSense is the facility that I mentioned earlier that provides auto-completion and prompts you for code in the Editor window as you enter it.</li>
<li class="calibre6">A file with the extension <code class="calibre23">.opensdf</code> that records information about the state of the project. This file exists only while the project is open.</li>
</ul>
<p class="calibre20">If you use Windows Explorer to look in the <code class="calibre23">Ex1_01</code> project folder, you will see that there are seven files initially, including a file with the name <code class="calibre23">ReadMe.txt</code> that contains a summary of the contents of the files that have been created. The project will automatically open with the Solution Explorer pane, as in <a id="calibre_link-1390" href="#calibre_link-397" class="calibre3">Figure 1-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000141.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-397" href="#calibre_link-1390" class="calibre3">FIGURE 1-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">The Solution Explorer tab presents a view of all the projects in the current solution and the files they contain &mdash; here, of course, there is just one project. You can display the contents of any file as an additional tab in the Editor pane by double-clicking the name in the Solution Explorer tab. In the Editor pane, you can switch instantly to any of the files that have been displayed by clicking the appropriate tab.</p>
<p class="calibre20">The Class View tab displays the classes in your project and shows the contents of each class. You don’t have any classes in this application, so the view is empty. When I discuss classes you will see that you can use the Class View tab to move quickly and easily around the code relating to your application classes.</p>
<p class="calibre20">You can display the Property Manager tab by selecting it from the View menu. It shows the properties that have been set for the Debug and Release versions of your project. I’ll explain these a little later in this chapter. You can change any of the properties for a version by right-clicking it and selecting Properties from the context menu; this displays a dialog where you can set the project properties. You can also press Alt+F7 to display the Property Pages dialog at any time. I’ll discuss this in more detail when I go into the Debug and Release versions of a program.</p>
<p class="calibre20">If it’s not already visible, you can display the Resource View tab by selecting from the View menu or by pressing Ctrl+Shift+E. Resource View shows the dialog boxes, icons, menus, toolbars, and other resources used by the project. Because this is a console program, no resources are used; when you start writing Windows applications, you’ll see a lot of things here. Through this tab you can edit or add to the resources available to the project.</p>
<p class="calibre20">As with most elements of the IDE, the Solution Explorer and other tabs provide context-sensitive pop-up menus when you right-click items displayed in the tab, and in some cases when you right-click in the empty space in the tab. If you find that the Solution Explorer pane is in the way when you’re writing code, you can hide it by clicking the Auto Hide icon. To redisplay it, click the Name tab on the left of the IDE window.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h5 class="calibre27"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="14" id="calibre_link-476" class="calibre14"></span>Modifying the Source Code</h5>
<p class="calibre13">The application wizard generates a complete Win32 console program that you can compile and execute. The program doesn’t do anything as it stands so to make it a little more interesting you need to change it. If it is not already visible in the Editor pane, double-click <code class="calibre23">Ex1_01.cpp</code> in the Solution Explorer pane. This is the main source file for the program and is shown in <a id="calibre_link-1391" href="#calibre_link-398" class="calibre3">Figure 1-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000094.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-398" href="#calibre_link-1391" class="calibre3">FIGURE 1-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">If the line numbers are not displayed, select Tools <img src="images/000122.png" alt="image" class="calibre25" /> Options from the main menu to display the Options dialog. If you extend the C/C++ option in the Text Editor subtree in the left pane and select General from the extended tree, you can check the Line numbers option in the right pane of the dialog. I’ll give you a rough guide to what this code in <a href="#calibre_link-398" class="calibre3">Figure 1-7</a> does, and you’ll see more on all of this later.</p>
<p class="calibre13">The first two lines are just comments. Anything following <code class="calibre23">//</code> in a line is ignored by the compiler. When you want to add descriptive comments in a line, precede your text with <code class="calibre23">//</code>.</p>
<p class="calibre13">Line 4 is an <code class="calibre23">#include</code> directive that adds the contents of the file <code class="calibre23">stdafx.h</code> to this file, and the contents are inserted in place of the <code class="calibre23">#include</code> directive. This is the standard way to add the contents of <code class="calibre23">.h</code> header files to a <code class="calibre23">.cpp</code> source file in a C++ program.</p>
<p class="calibre13">Line 7 is the first line of the executable code in this file and the beginning of the function called <code class="calibre23">_tmain()</code>. A function is simply a named unit of executable code in a C++ program; every C++ program consists of at least one &mdash; and usually many more &mdash; functions.</p>
<p class="calibre13">Lines 8 and 10 contain left and right braces, respectively, that enclose all the executable code in the <code class="calibre23">_tmain()</code> function. The executable code is just the single line 9, and this ends the program.</p>
<p class="calibre13">Now you can add the following two lines of code in the Editor window:</p>
<pre class="calibre28"><code class="calibre23">// Ex1_01.cpp : Defines the entry point for the console application.
//
       
#include "stdafx.h"
<b class="calibre12">#include &lt;iostream&gt;</b>
       
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="15" id="calibre_link-477" class="calibre14"></span>int _tmain(int argc, _TCHAR* argv[])
{
<b class="calibre12">std::cout &lt;&lt; "Hello world!\n";</b>
  return 0;
}</code></pre>
<p class="calibre13">The new lines you should add are shown in bold; the others are generated for you. To introduce each new line, place the cursor at the end of the text on the preceding line and press Enter to create an empty line in which you can type the new code. Make sure it is exactly as shown in the preceding example; otherwise the program may not compile.</p>
<p class="calibre13">The first new line is an <code class="calibre23">#include</code> directive that adds the contents of one of the standard library files to the <code class="calibre23">Ex1_01.cpp</code> source file. The <code class="calibre23">iostream</code> library defines facilities for basic I/O operations, and the one you are using in the second line that you added writes output to the command line. <code class="calibre23">std::cout</code> is the name of the standard output stream, and you write the string <code class="calibre23">"Hello world!\n"</code> to <code class="calibre23">std::cout</code> in the second addition statement. Whatever appears between the pair of double-quote characters is written to the command line.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Building the Solution</h5>
<p class="calibre13">To build the solution, press F7 or select the Build <img src="images/000122.png" alt="image" class="calibre25" /> Build Solution menu item. Alternatively, you can click the toolbar button corresponding to this menu item. The toolbar buttons for the Build menu may not be displayed, but you can fix this by right-clicking in the toolbar area and selecting the Build toolbar from those in the list. The program should compile successfully. If there are errors, it may be that you created them while entering the new code, so check the two new lines very carefully.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Files Created by Building a Console Application</h5>
<p class="calibre13">After the example has been built without error, take a look in the project folder by using Windows Explorer. You’ll see a new subfolder to the solution folder <code class="calibre23">Ex1_01</code> called <code class="calibre23">Debug</code>. This is the folder <code class="calibre23">Ex1_01\Debug</code>, not the folder <code class="calibre23">Ex1_01\Ex1_01\Debug</code>. This folder contains the output of the build you just performed. Notice that this folder contains three files.</p>
<p class="calibre13">The <code class="calibre23">.exe</code> file is your program in executable form. You don’t need to know much about what’s in the other files. In case you’re curious, the <code class="calibre23">.ilk</code> file is used by the linker when you build your project. It enables the linker to incrementally link object files produced from modified source code into the existing <code class="calibre23">.exe</code> file. This avoids the need to relink everything each time you change the program. The <code class="calibre23">.pdb</code> file contains debugging information that is used when you execute the program in debug mode. In this mode, you can dynamically inspect information generated during program execution.</p>
<p class="calibre13">There’s a <code class="calibre23">Debug</code> subdirectory in the <code class="calibre23">Ex1_01</code> project folder too. This contains a large number of files that were created during the build process, and you can see what kind of information they contain from the Type description in Windows Explorer.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Debug and Release Versions of Your Program</h4>
<p class="calibre13">You can set options for a project through the Project <img src="images/000122.png" alt="image" class="calibre25" /> Ex1_01 Properties menu item. These options determine how your source code is processed during the compile and link stages. The set of options <span {http://www.idpf.org/2007/ops}type="pagebreak" title="16" id="calibre_link-478" class="calibre14"></span>that produces a particular executable version of your program is called a <i class="calibre15">configuration</i>. When you create a new project workspace, Visual C++ automatically creates configurations for producing two versions of your application. The Debug version includes additional information that helps you debug the program. With the Debug version of a program, you can step through the code when things go wrong, checking on the data values in the program as you go. The Release version has no debug information included and has the code-optimization options for the compiler turned on to provide the most efficient executable module. These two configurations are sufficient for your needs throughout this book, but when you need to add other configurations for an application you can do so through the Build <img src="images/000122.png" alt="image" class="calibre25" /> Configuration Manager menu. (Note that this menu item won’t appear if you haven’t got a project loaded. This is obviously not a problem, but might be confusing if you’re just browsing through the menus to see what’s there.)</p>
<p class="calibre13">You can choose which configuration of your program to work with by selecting from the drop-down list in the toolbar. Selecting Configuration Manager from the drop-down list will display the Configuration Manager dialog. You use this dialog when your solution contains multiple projects. Here you can choose configurations for each of the projects and choose which ones you want to build.</p>
<p class="calibre13">After your application has been tested using the debug configuration and appears to be working correctly, you typically rebuild the program as a release version; this produces optimized code without the debug and trace capability, so the program runs faster and occupies less memory.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Executing the Program</h4>
<p class="calibre13">After you have successfully compiled the solution, you can execute the program by pressing Ctrl+F5. You should see the window shown in <a id="calibre_link-1392" href="#calibre_link-399" class="calibre3">Figure 1-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000056.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-399" href="#calibre_link-1392" class="calibre3">FIGURE 1-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">As you see, you get the text between the double quotes written to the command line. The <code class="calibre23">"\n"</code> that was at the end of the text string is a special sequence called an <i class="calibre15">escape sequence</i> that denotes a newline character. Escape sequences are used to represent characters in a text string that you cannot enter directly from the keyboard. The last line prompting how you continue always appears with console program output. Pressing Enter will close the window. I won’t show this last line when I show output from a program in the book.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="17" id="calibre_link-479" class="calibre24"></span>TRY IT OUT: Creating an Empty Console Project</h3>
<p class="calibre20">The previous project contained a certain amount of excess baggage that you don’t need when working with simple examples. The precompiled headers option chosen by default resulted in the <code class="calibre23">stdafx.h</code> file being created in the project. This is a mechanism for making the compilation process more efficient when there are a lot of files in a program, but it won’t be necessary for most of our examples. In these instances, you start with an empty project to which you can add your own source files. You can see how this works by creating a new project in a new solution for a Win32 console program with the name <code class="calibre23"><b class="calibre12">Ex1_02</b></code>. After you have entered the project name and clicked OK, click Application Settings on the left side of the dialog box that follows. You can then select Empty project from the additional options and uncheck SDL. When you click Finish, the project is created as before, but this time without any source files.</p>
<p class="calibre20">Next, you can add a new source file to the project. Right-click the Solution Explorer pane and then select Add <img src="images/000122.png" alt="image" class="calibre25" /> New Item from the context menu. A dialog displays: click Code in the left pane and C++ File(.cpp) in the right pane. Enter the filename as <code class="calibre23"><b class="calibre12">Ex1_02</b></code>.</p>
<p class="calibre20">When you click Add in the dialog, the new file is added to the project and is displayed in the Editor window. The file is empty, of course, so nothing will be displayed. Enter the following code in the Editor window:</p>
<pre class="calibre28"><code class="calibre23">// Ex1_02.cpp A simple console program
#include &lt;iostream&gt;                    // Basic input and output library
      
int main()
{
  std::cout &lt;&lt; "This is a simple program that outputs some text." &lt;&lt; std::endl;
  std::cout &lt;&lt; "You can output more lines of text" &lt;&lt; std::endl;
  std::cout &lt;&lt; "just by repeating the output statement like this." &lt;&lt; std::endl;
  return 0;                            // Return to the operating system
}</code></pre>
<p class="calibre20">Note the automatic indenting that occurs as you type the code. C++ uses indenting to make programs more readable, and the editor automatically indents each line of code that you enter based on what was in the previous line. You can change the indenting by selecting the Tools <img src="images/000122.png" alt="image" class="calibre25" /> Options... menu item to display the Options dialog. Selecting Text Editor <img src="images/000122.png" alt="image" class="calibre25" /> C/C++ <img src="images/000122.png" alt="image" class="calibre25" /> Tabs in the left pane of the dialog displays the indenting options in the right pane. The editor inserts tabs by default, but you can change it to insert spaces if you prefer.</p>
<p class="calibre20">You’ll see the syntax color highlighting in action as you type. Some elements of the program are shown in different colors, as the editor automatically assigns colors to language elements depending on what they are.</p>
<p class="calibre20">The preceding code is the complete program. You probably noticed a couple of differences compared to the code generated by the application wizard in the previous example. There’s no <code class="calibre23">#include</code> directive for the <code class="calibre23">stdafx.h</code> file. You don’t have this file as part of the project because you are not using the precompiled headers facility. The name of the function here is <code class="calibre23">main</code>; before it was <code class="calibre23">_tmain</code>. In fact all ISO/IEC standard C++ programs start execution in a function called <code class="calibre23">main()</code>. Microsoft uses <code class="calibre23">wmain</code> for this function when Unicode characters are used, and the name <code class="calibre23">_tmain</code> is defined to be either <code class="calibre23">main</code> or <code class="calibre23">wmain</code> (in the <code class="calibre23">tchar.h</code> header file), depending on whether or not the program is going to use Unicode characters. In the previous example the name <code class="calibre23">_tmain</code> is defined behind the scenes to be <code class="calibre23">wmain</code> because <span {http://www.idpf.org/2007/ops}type="pagebreak" title="18" id="calibre_link-480" class="calibre14"></span>the project settings were set to Unicode. I’ll use the standard name <code class="calibre23">main</code> in all the examples. The output statements are a little different. The first statement in <code class="calibre23">main()</code> is:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; "This is a simple program that outputs some text." &lt;&lt; std::endl;</code></pre>
<p class="calibre20">You have two occurrences of the <code class="calibre23">&lt;&lt;</code> operator, and each one sends whatever follows to <code class="calibre23">std::cout</code>, the standard output stream. First, the string between double quotes is sent to the stream, and then <code class="calibre23">std::endl</code>, where <code class="calibre23">std::endl</code> is defined in the standard library as a newline character. Earlier, you used the escape sequence <code class="calibre23">\n</code> for a newline character within a string between double quotes. You could have written the preceding statement as follows:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; "This is a simple program that outputs some text.\n";</code></pre>
<p class="calibre20">This is not identical to using <code class="calibre23">std::endl</code> though. Using <code class="calibre23">std::endl</code> writes a newline and then flushes the output buffer. Using just <code class="calibre23">\n</code>, the buffer is not flushed immediately.</p>
<p class="calibre20">The last statement is the <code class="calibre23">return</code> statement that ends <code class="calibre23">main()</code> and thus the program. This is not strictly necessary here and you could leave it out. If execution reaches the end of <code class="calibre23">main()</code> without encountering a return statement, it is equivalent to executing <code class="calibre23">return 0</code>.</p>
<p class="calibre20">You can build this project in the same way as the previous example. Note that any open source files in the Editor pane are saved automatically if you have not already saved them when you build the project. When you have compiled the program successfully, press Ctrl+F5 to execute it. If everything works as it should, the output will be as follows:</p>
<pre class="calibre28"><code class="calibre23">This is a simple program that outputs some text.
You can output more lines of text
just by repeating the output statement like this.</code></pre>
<p class="calibre20">Note that pressing Ctrl+F5 will build the project before executing it if it is not up to date.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Dealing with Errors</h4>
<p class="calibre13">Of course, if you didn’t type the program correctly, you get errors reported. To see how this works you could deliberately introduce an error into the program. If you already have errors of your own, you can use those to perform this exercise. Go back to the Editor pane and delete the semicolon at the end of the second-to-last line between the braces (line 8); then rebuild the source file. The Output pane at the bottom of the application window will include the following error message:</p>
<pre class="calibre28"><code class="calibre23">C2143: syntax error : missing ';' before 'return'</code></pre>
<p class="calibre13">Every error message during compilation has an error number that you can look up in the documentation. Here the problem is obvious, but in more obscure cases the documentation may help you figure out what is causing the error. To get the documentation on an error, click the line in the Output pane that contains the error number and then press F1. A new window displays containing further information about the error. You can try it with this simple error, if you like.</p>
<p class="calibre13">When you have corrected the error, you can rebuild the project. The build operation works efficiently because the project definition keeps track of the status of the files making up the project. During a normal build, Visual C++ recompiles only the files that have changed since the program was last compiled or built. This means that if your project has several source files, and you’ve edited only one of them since the project was last built, only that file is recompiled before linking to create a new <code class="calibre23">.exe</code> file. If you modify a header file, all files that include that header will be recompiled.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="19" id="calibre_link-481" class="calibre24"></span>Setting Options in Visual C++</h3>
<p class="calibre13">Two sets of options are available. You can set options that apply to the tools provided by Visual C++, which apply in every project context. You also can set options that are specific to a project that determine how the project code is to be processed when it is compiled and linked. Options that apply to every project are set through the Options dialog that’s displayed when you select Tools <img src="images/000122.png" alt="image" class="calibre25" /> Options from the main menu. You used this dialog earlier to change the code indenting used by the editor. The Options dialog box is shown in <a id="calibre_link-1393" href="#calibre_link-400" class="calibre3">Figure 1-9</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000145.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-400" href="#calibre_link-1393" class="calibre3">FIGURE 1-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Clicking the arrow symbol to the left of any of the items in the left pane displays a list of subtopics. <a href="#calibre_link-400" class="calibre3">Figure 1-9</a> shows the options for the General subtopic under Projects and Solutions. The right pane displays the options you can set for the topic you have selected in the left pane. You should concern yourself with only a few of these at this time, but you’ll find it useful to spend a little time browsing the range of options available to you. Clicking the Help button (the one with the question mark) at the top right of the dialog box displays an explanation of the current options.</p>
<p class="calibre13">You probably want to choose a path to use as a default when you create a new project, and you can do this through the first option shown in <a href="#calibre_link-400" class="calibre3">Figure 1-9</a>. Just set the path to the location where you want your projects and solutions stored.</p>
<p class="calibre13">You can set options that apply to every project by selecting the Projects and Solutions <img src="images/000122.png" alt="image" class="calibre25" /> VC++ Project Settings topic in the left pane of the Options dialog. You set options specific to the current project through the dialog that displays when you select the Project <img src="images/000122.png" alt="image" class="calibre25" /> Ex1_02 Properties menu item in the main menu, or by pressing Alt+F7. The label for this menu item is tailored to reflect the name of the current project.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="20" id="calibre_link-482" class="calibre24"></span>Creating and Executing Windows Applications</h3>
<p class="calibre13">Just to show how easy it’s going to be, you can now create a working Windows application. I’ll defer discussion of the program until I’ve covered the necessary ground for you to understand it in detail. You will see, though, that the processes are straightforward.</p>
<section class="toclist">
<h4 class="calibre22">Creating an MFC Application</h4>
<p class="calibre13">To start with, if an existing project is active &mdash; as indicated by the project name appearing in the title bar of the Visual C++ main window &mdash; you can select Close Solution from the File menu. Alternatively, you can create a new project and have the current solution closed automatically. Create directory for solution is selected by default in the New Project dialog.</p>
<p class="calibre13">To create the Windows program, select New <img src="images/000122.png" alt="image" class="calibre25" /> Project from the File menu or press Ctrl+Shift+N; then set the project type as MFC in the left pane, and select MFC Application as the project template. Enter the project name as <code class="calibre23"><b class="calibre12">Ex1_03</b></code>. When you click OK, the MFC Application Wizard dialog is displayed. The dialog has options for the features you can include in your application. These are identified by the items in the list on the left of the dialog.</p>
<p class="calibre13">Click Application Type to display these options. Click the Tabbed documents option to deselect it and select Windows Native/Default from the drop-down list to the right. The dialog should then look as shown in <a id="calibre_link-1394" href="#calibre_link-401" class="calibre3">Figure 1-10</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000015.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-401" href="#calibre_link-1394" class="calibre3">FIGURE 1-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Click Advanced Features next, and deselect all the options except for the Printing and Print Preview and Common Control Manifest options so that the dialog looks as shown in <a id="calibre_link-1395" href="#calibre_link-402" class="calibre3">Figure 1-11</a>. Note how the small image at the top left of the dialog changes as you check or uncheck options.</p>
<figure class="calibre16">
<img class="center" src="images/000098.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-402" href="#calibre_link-1395" class="calibre3">FIGURE 1-11</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="21" id="calibre_link-483" class="calibre14"></span>Finally, click Finish to create the project. The undocked Solution Explorer pane in the IDE window will look like <a id="calibre_link-1396" href="#calibre_link-403" class="calibre3">Figure 1-12</a>. The list shows the large number of source files that have been created, and several resource files. The files with the extension <code class="calibre23">.cpp</code> contain executable C++ source code, and the <code class="calibre23">.h</code> files, called header files, contain C++ code for definitions such as classes that are used by the executable code. The <code class="calibre23">.ico</code> files contain icons. The files are grouped into subfolders in the Solution Explorer pane for ease of access. These aren’t real folders though, so they won’t appear in the project folder on your disk.</p>
<figure class="calibre16">
<img class="center" src="images/000018.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-403" href="#calibre_link-1396" class="calibre3">FIGURE 1-12</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">If you look at the contents of the <code class="calibre23">Ex1_03</code> solution folder and subfolders using Windows Explorer, you’ll notice that you have generated a large number of files. Four of these are in the solution folder that includes the transient <code class="calibre23">.opensdf</code> file, there are many more in the project folder, and the rest are in the <code class="calibre23">res</code> subfolder of the project folder. The files in the <code class="calibre23">res</code> subfolder contain the resources used by the program, such as the toolbars and icons. You get all this as a result of just entering the name for the project. You can see why, with so many files and filenames being created automatically, a separate folder for each project becomes more than just a good idea.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="22" id="calibre_link-484" class="calibre14"></span>One of the files in the <code class="calibre23">Ex1_03</code> project directory is <code class="calibre23">ReadMe.txt</code>, and it provides an explanation of the files that the MFC Application Wizard has generated. You can view this file in the Editor window by double-clicking it in the Solution Explorer pane.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Building and Executing the MFC Application</h4>
<p class="calibre13">Before you can execute the program, you have to build the project &mdash; that is, compile the source code and link the program modules, exactly as you did with the console application example. To save time, press Ctrl+F5 to get the project built and then executed in a single operation.</p>
<p class="calibre13">After the project has been built, the Output window indicates that there are no errors, and the program executes. The application window for the program is shown in <a id="calibre_link-1397" href="#calibre_link-404" class="calibre3">Figure 1-13</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000059.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-404" href="#calibre_link-1397" class="calibre3">FIGURE 1-13</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">As you see, the window is complete with menus and a toolbar. Although there is no specific functionality in the program &mdash; you must add code for that to make it <i class="calibre15">your</i> program &mdash; all the menus work. You can try them out. You can even create further windows by selecting New from the File menu.</p>
<p class="calibre13">I think you’ll agree that creating a Windows program with the MFC Application Wizard hasn’t stressed too many brain cells. You’ll need to get a few more ticking away when it comes to developing the basic program you have here into a program that does something more interesting, but it won’t be that hard. Certainly, for many people, writing a serious Windows program the old-fashioned way, without the aid of Visual C++, required at least a couple of months on a brain-enhancing fish diet before making the attempt. That’s why so many programmers used to eat sushi. That’s all gone now with Visual C++. However, you never know what’s around the corner in programming technology. If you like sushi, it’s best to continue eating it &mdash; just to be on the safe side.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-243" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="23" id="calibre_link-485" class="calibre18"></span>SUMMARY</h2>
<p class="calibre13">In this chapter you have run through the basic mechanics of using Visual C++ to create applications. You created and executed console programs, and with the help of the application wizard you created an MFC-based Windows program. You should be reasonably comfortable with creating and executing projects.</p>
<p class="calibre13">Starting with the next chapter, all the examples illustrating how C++ language elements are used are executed using Win32 console applications. You will return to the application wizard for MFC-based programs as soon as you have finished learning the basics of C++.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="24" id="calibre_link-486" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">C++</b></td>
<td class="calibre32">Visual C++ supports C++ that conforms to the C++ 11 language standard that is defined in the document ISO/IEC 14882:2011. Visual C++ implements most of the language features defined by this standard and some features from the draft of the next standard, C++ 14.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Solutions</b></td>
<td class="calibre32">A solution is a container for one or more projects that form a solution to an information-processing problem of some kind.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Projects</b></td>
<td class="calibre32">A project is a container for the code and resource elements that make up a functional unit in a program.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Project View Panes</b></td>
<td class="calibre32">The Solution Explorer pane displays one or more tabs and shows the project files. The Class View pane shows classes in the project. The Resource View pane shows project resources.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Project Options</b></td>
<td class="calibre32">You can display and modify the options that apply to all C++ projects through the dialog that is displayed when you select Options from the Tools menu.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Project Properties</b></td>
<td class="calibre32">You can set values for properties for the current project through the dialog that is displayed when you select Properties from the Project menu.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Console Applications</b></td>
<td class="calibre32">A console application is a basic C++ application with no GUI. Typically, input is from the keyboard and output is to the command line.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">main()</code> function</b></td>
<td class="calibre32">The starting point for a standard C++ program is the <code class="calibre23">main()</code> function. The New Project dialog generates a console application that starts with the <code class="calibre23">_tmain()</code> function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Unicode</b></td>
<td class="calibre32">If you want to use the standard <code class="calibre23">main()</code> function in a console program, you can generate an empty Win32 project and add the source file for <code class="calibre23">main()</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows Store Apps</b></td>
<td class="calibre32">Windows Store apps target tablet computers and desktop PCs running the Windows 8 operating system.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows Runtime</b></td>
<td class="calibre32">The Windows Runtime, WinRT, provides the interface to the Windows 8 and later operating systems for Windows Store apps.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows Desktop Applications</b></td>
<td class="calibre32">Windows desktop applications have an application window and a GUI incorporating controls such as menus, toolbars, and dialogs. Desktop applications interface to the operating system through the Win32 set of functions. Desktop applications execute under Windows 7 and Windows 8 and it successors.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The Microsoft Foundation Classes</b></td>
<td class="calibre32">The MFC is a set of C++ classes that encapsulate the functions provided by Win32. MFC makes it easier to develop Windows desktop applications.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">MFC Projects</b></td>
<td class="calibre32">You create an MFC project by selecting MFC then MFC Application in the New Project dialog.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-46">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2315" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="25" id="calibre_link-487" class="calibre9"></span><span class="chapternumber">Chapter 2</span><br class="calibre10" /><span class="chapternumber">Data, Variables, and Calculations</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">C++ program structure</li>
<li class="calibre6">Namespaces</li>
<li class="calibre6">Variables in C++</li>
<li class="calibre6">Defining variables and constants</li>
<li class="calibre6">Basic input from the keyboard and output to the screen</li>
<li class="calibre6">Performing arithmetic calculations</li>
<li class="calibre6">Casting operands</li>
<li class="calibre6">Variable scope</li>
<li class="calibre6">What the auto keyword does</li>
<li class="calibre6">How to discover the type of an expression</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 2 download and files are individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-244" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="26" id="calibre_link-488" class="calibre18"></span>THE STRUCTURE OF A C++ PROGRAM</h2>
<p class="calibre13">Console applications are programs that read data from the command line and output results to the command line. All the examples that you’ll write to understand how the C++ language works will be console programs. This avoids having to dig into the complexities of creating and managing Windows applications before you have enough knowledge of how they work. You will be able to focus entirely on C++. After you have mastered that, you’ll be ready to deal with creating and managing Windows applications and the sacks of code that it involves. I’ll start by explaining how console programs are structured.</p>
<p class="calibre13">A C++ program consists of one or more functions. A function is a self-contained block of code with a unique name that you use to identify the function when you want to execute it. Chapter 1 includes an example of a Win32 console program consisting of just the <code class="calibre23">main()</code> function, where <code class="calibre23">main</code> is the name of the function. Every C++ program contains the <code class="calibre23">main()</code> function, and that is where execution always starts. Programs of any size consist of several functions &mdash; the <code class="calibre23">main()</code> function, plus a number of others.</p>
<p class="calibre13">You saw in Chapter 1 that a console program generated by the Application Wizard has a main function with the name <code class="calibre23">_tmain</code>. This is a Microsoft-specific programming construct to allow the function name to be <code class="calibre23">wmain</code> or <code class="calibre23">main</code>, depending on whether or not the program is using Unicode characters. The names <code class="calibre23">wmain</code> and <code class="calibre23">_tmain</code> are also Microsoft-specific and therefore not standard C++. The name for the main function in standard C++ is <code class="calibre23">main</code>. I’ll use the name <code class="calibre23">main</code> for all our console examples because this is the most portable option. If you intend to compile your code only with Visual C++, and you want to use the Microsoft-specific name for <code class="calibre23">main</code>, you can use the default console application the Application Wizard generates. In this case, just copy the code that is shown in the body of <code class="calibre23">main()</code> in the console program examples to <code class="calibre23">_tmain()</code>.</p>
<p class="calibre13"><a id="calibre_link-48" href="#calibre_link-47" class="calibre3">Figure 2-1</a> shows how a typical console program might be structured. Execution starts at the beginning of <code class="calibre23">main()</code>. From <code class="calibre23">main()</code> execution transfers to an <code class="calibre23">input_names()</code> function, which returns execution to the position immediately following where it was called in <code class="calibre23">main()</code>. The <code class="calibre23">sort_names()</code> function is called next from <code class="calibre23">main()</code> and when control returns to <code class="calibre23">main()</code>, the <code class="calibre23">output_names()</code> function is called. When <code class="calibre23">output_names()</code> finishes, execution returns again to <code class="calibre23">main()</code> and the program ends.</p>
<figure class="calibre16">
<img class="center" src="images/000146.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-47" href="#calibre_link-48" class="calibre3">FIGURE 2-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Of course, different programs may have radically different functional structures, but they all start execution at the beginning of <code class="calibre23">main()</code>. Defining a program as a number of functions allows you to write and test each function separately. Segmenting your programs in this way offers other advantages. A function you write to perform a general task can often be reused in other programs. The libraries that come with C++ provide a large number of standard functions that you can use to save yourself a great deal of work.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="27" id="calibre_link-489" class="calibre14"></span><b class="calibre12">NOTE</b> <i class="calibre15">You’ll see more about creating and using functions in Chapter 5.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: A Simple Program Using main()</h3>
<p class="calibre20">This example demonstrates what you need to do to use <code class="calibre23">main()</code> in a Visual C++ console program. Start by creating a new project &mdash; you can use the Ctrl+Shift+N key combination as a shortcut for this. When the dialog appears, select Win32 as the project type and Win32 Console Application as the template. You can name the project <code class="calibre23"><b class="calibre12">Ex2_01</b></code>.</p>
<p class="calibre20">When you click the OK button, you’ll see the dialog in <a id="calibre_link-50" href="#calibre_link-49" class="calibre3">Figure 2-2</a> that shows an overview of what the Application Wizard will generate.</p>
<figure class="calibre16">
<img class="center" src="images/000062.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-49" href="#calibre_link-50" class="calibre3">FIGURE 2-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="28" id="calibre_link-490" class="calibre14"></span>If you now click Application Settings on the left of this dialog, you’ll see further options for a Win32 application displayed, as shown in <a id="calibre_link-52" href="#calibre_link-51" class="calibre3">Figure 2-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000028.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-51" href="#calibre_link-52" class="calibre3">FIGURE 2-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="29" id="calibre_link-491" class="calibre14"></span>The default setting is a Console application that includes a file containing a default version of <code class="calibre23">main()</code> with the name <code class="calibre23">_tmain()</code>. You start from the most basic project structure that contains no source files, so choose Empty project  and uncheck SDL checks from the set of options and click the Finish button.</p>
<p class="calibre20">You can see what the project contains from the Solution Explorer pane on the left of the main window, as shown in <a id="calibre_link-54" href="#calibre_link-53" class="calibre3">Figure 2-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000021.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-53" href="#calibre_link-54" class="calibre3">FIGURE 2-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">You start by adding a new source file to the project. Right-click Source Files in the Solution Explorer pane and select the Add <img src="images/000122.png" alt="image" class="calibre25" /> New Item menu option. The Add New Item dialog displays, showing the options available.</p>
<p class="calibre20">Select Code in the left pane, select the C++ File (.cpp) template in the middle pane, and enter the filename as <code class="calibre23"><b class="calibre12">Ex2_01</b></code>. The file is automatically given the extension <code class="calibre23">.cpp</code>, so you don’t have to enter this. There is no problem making the name of the file the same as the name of the project. The project file will have the extension <code class="calibre23">.vcxproj</code>, so that will differentiate it from the source file.</p>
<p class="calibre20">Click the Add button to create the file. You can then type the following code in the Editor pane of the IDE window:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_01.cpp
// A Simple Example of a Program
#include &lt;iostream&gt;
       
using std::cout;
using std::endl;
       
int main()
{
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="30" id="calibre_link-492" class="calibre14"></span>   int apples, oranges;                     // Define two integer variables
   int fruit;                               // ...then another one
       
   apples = 5; oranges = 6;                 // Set initial values
   fruit = apples + oranges;                // Get the total fruit
       
   cout &lt;&lt; endl;                            // Start output on a new line
   cout &lt;&lt; "Oranges are not the only fruit... " &lt;&lt; endl
        &lt;&lt; "- and we have " &lt;&lt; fruit &lt;&lt; " fruits in all.";
   cout &lt;&lt; endl;                            // Output a new line character
       
   return 0;                                // Exit the program
}</code></pre>
<p class="calibre20">This illustrates some of the ways in which you can write statements and is not a model of good programming style. The editor checks the code as you type. Anything it thinks is not correct is underlined with a red squiggle, so look out for these. If you see one, it usually means that you have mistyped something. When you hover the mouse cursor over a red squiggle, a message displays to indicate what is wrong.</p>
<p class="calibre20">The source file is identified by its extension as a file containing C++ code so language elements of various kinds that the editor recognizes will be colored to highlight them. I say more about color highlighting later in this chapter.</p>
<p class="calibre20">If you look at the Solution Explorer pane (press Ctrl+Alt+L to display it); you’ll see the new source file name. Solution Explorer always shows all the files in a project. You can display the Class View pane by selecting from the View menu or by pressing Ctrl+Shift+C. This consists of two panes. The upper pane shows global functions and macros within the project (and classes when you get to create a project involving classes), and the lower pane is presently empty. The <code class="calibre23">main()</code> function will appear in the lower pane if you select Global Functions and Variables in the upper pane; this is shown in <a id="calibre_link-56" href="#calibre_link-55" class="calibre3">Figure 2-5</a>. I explain what this means in more detail later, but essentially, <i class="calibre15">globals</i> are functions and/or variables that are accessible from anywhere in a program.</p>
<figure class="calibre16">
<img class="center" src="images/000150.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-55" href="#calibre_link-56" class="calibre3">FIGURE 2-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">You can display the Property Manager pane by selecting from the View menu. If you expand the items in the tree that is displayed by clicking the unfilled arrow symbols, it will look like <a id="calibre_link-58" href="#calibre_link-57" class="calibre3">Figure 2-6</a>. This shows the two possible versions you can build, the Debug version for testing and the Release version when your program has been tested. The properties for each version are shown, and double-clicking any of them displays a dialog showing the Property Pages where you can change properties, if necessary.</p>
<figure class="calibre16">
<img class="center" src="images/000103.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-57" href="#calibre_link-58" class="calibre3">FIGURE 2-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">You have three ways to compile and link the program; you can select the Build Ex2_01 menu item from the Build menu, you can press the F7 function key, or you can select the appropriate toolbar button. To identify what a toolbar button does just hover the mouse cursor over it. If there is no toolbar button that shows the tooltip Build Ex2_01, then the Build toolbar is not currently displayed. You can remedy this by right-clicking an empty part of the toolbar and selecting Build from the list. It’s a very long list and you will probably want to choose to display different sets of toolbars, depending on what you are doing.</p>
<p class="calibre20">If the build operation is successful, you can execute the program by pressing Ctrl+F5 or by selecting Start Without Debugging from the Debug menu. You should get the following output in a command-line window:</p>
<pre class="calibre28"><code class="calibre23">Oranges are not the only fruit...
- and we have 11 fruits in all.
Press any key to continue ...</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="31" id="calibre_link-493" class="calibre14"></span>The first two lines were produced by the program, and the last line indicates how you can end the execution and close the command-line window. I won’t show this last line of output from other console examples but it’s always there.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">&nbsp;</h3>
<section class="toclist">
<h4 class="calibre22">Program Comments</h4>
<p class="calibre13">The first two lines in the program are <i class="calibre15">comments.</i> Comments are an important part of any program, but they’re not executable code &mdash; they are there to help the human reader. The compiler ignores all comments. On any line of code, two successive slashes (<code class="calibre23">//</code>) that are not contained within a text string (you’ll see what text strings are later) indicate that the rest of the line is a comment. You can see that several lines contain comments.</p>
<p class="calibre13">There’s another form of comment bounded by <code class="calibre23">/*</code> and <code class="calibre23">*/</code>. For example, the first line of the program could have been written:</p>
<pre class="calibre28"><code class="calibre23">/*   Ex2_01.cpp   */</code></pre>
<p class="calibre13">A comment using <code class="calibre23">//</code> covers only the portion of the line following the two successive slashes, whereas the <code class="calibre23">/*...*/</code> form defines whatever is enclosed between the <code class="calibre23">/*</code> and the <code class="calibre23">*/</code> as a comment, and this can span several lines. For example, you could write:</p>
<pre class="calibre28"><code class="calibre23">/*
   Ex2_01.cpp
   A Simple Program Example
*/</code></pre>
<p class="calibre13">All four lines are comments and are ignored by the compiler. If you want to highlight some particular comment lines, you can embellish them:</p>
<pre class="calibre28"><code class="calibre23">/*****************************
 *  Ex2_01.cpp               *
 *  A Simple Program Example *
 *****************************/</code></pre>
<p class="calibre13">As a rule, you should always comment your programs comprehensively. The comments should be sufficient for another programmer, or you at a later date, to understand the purpose of the code and how it works. I will often use more detailed comments in examples than you would in a production program.</p>
</section>
<section class="toclist">
<h4 class="calibre22">The #include Directive &mdash; Header Files</h4>
<p class="calibre13">Following the comments, you have an <code class="calibre23">#include</code> directive:</p>
<pre class="calibre28"><code class="calibre23">#include &lt;iostream&gt;</code></pre>
<p class="calibre13">This is called a <i class="calibre15">directive</i> because it directs the compiler to do something &mdash; in this case, to insert the contents of the file, <code class="calibre23">iostream</code>, that is identified between the angled brackets, <code class="calibre23">&lt;&gt;</code>, into the program source file before compilation. The <code class="calibre23">iostream</code> file is called a <i class="calibre15">header file</i> because it’s invariably inserted in another source file. <code class="calibre23">iostream</code> is part of the standard C++ library and contains the definitions necessary to allow you to use input and output statements. If you didn’t include <code class="calibre23">iostream</code> into the program, it wouldn’t compile, because you use output statements in the program that depend <span {http://www.idpf.org/2007/ops}type="pagebreak" title="32" id="calibre_link-494" class="calibre14"></span>on definitions in this file. There are many different standard header files that cover a wide range of capabilities. You’ll see more of them as you progress through the language facilities.</p>
<p class="calibre13">The name of the file to be inserted by an <code class="calibre23">#include</code> directive does not have to be written between angled brackets. It can be between double quotes, thus:</p>
<pre class="calibre28"><code class="calibre23">#include "iostream"</code></pre>
<p class="calibre13">The difference between this and the preceding version is the places where the compiler will look for the file. If you write the header filename between double quotes, the compiler first searches the directory that contains the source file in which the directive appears. If the header file is not there, the compiler searches the directories containing the standard header files.</p>
<p class="calibre13">When the filename is enclosed between angled brackets, the compiler only searches the directories containing the standard header files. Thus, when you want to include a standard header in a source file, placing the name between angled brackets ensures it will be found more quickly. When you are including other header files, typically ones that you create yourself, place the name between double quotes; otherwise, the files will not be found at all.</p>
<p class="calibre13">An <code class="calibre23">#include</code> directive is one of several <i class="calibre15">preprocessor directives</i>, and I’ll be introducing more of these as you need them. The editor highlights preprocessor directives in blue in the edit window. Preprocessor directives are commands executed by the preprocessor phase of compilation that executes before your code is compiled into object code, and they generally act on your source code in some way. They all start with the <code class="calibre23">#</code> character.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Namespaces and the Using Declaration</h4>
<p class="calibre13">As you saw in Chapter 1, the <i class="calibre15">standard library</i> is an extensive set of routines that carry out many common tasks, such as dealing with input and output and performing basic mathematical calculations. There are a large number of these routines as well as other kinds of things that have names in the standard library so it is possible that you might accidentally use a name for your own purposes that is already used in the library. A <i class="calibre15">namespace</i> is a mechanism for minimizing the risk of inadvertently using duplicate names. It does this by associating a given set of names, such as those from the standard library, with a sort of family name, which is the <i class="calibre15">namespace name</i>.</p>
<p class="calibre13">Every name that is defined in code within a namespace has the namespace name associated with it. The standard library facilities are defined within a namespace with the name <code class="calibre23">std</code>, so every item from the standard library has its own name, plus the namespace name, <code class="calibre23">std</code>, as a qualifier. The full names for <code class="calibre23">cout</code> and <code class="calibre23">endl</code> from the standard library are <code class="calibre23">std::cout</code> and <code class="calibre23">std::endl</code>; you saw these in action in Chapter 1. The two colons that separate the namespace name from the entity name form an operator called the <i class="calibre15">scope resolution operator</i>. I’ll discuss other uses for this operator later in the book. Using full names in a program can make the code look a bit cluttered, so it would be nice to have the option to use simple names, unqualified by the namespace name, <code class="calibre23">std</code>. The two lines in our program following the <code class="calibre23">#include</code> directive for <code class="calibre23">iostream</code> make this possible:</p>
<pre class="calibre28"><code class="calibre23">using std::cout;
using std::endl;</code></pre>
<p class="calibre13">These are <i class="calibre15">using declarations</i>. They tell the compiler that you intend to use the names <code class="calibre23">cout</code> and <code class="calibre23">endl</code> from the namespace <code class="calibre23">std</code> without specifying the namespace name. The compiler assumes that wherever you use <code class="calibre23">cout</code> subsequent to the first <code class="calibre23">using</code> declaration, you mean <code class="calibre23">std::cout</code>. The name <code class="calibre23">cout</code> represents the standard output stream that corresponds to the command line and the name <code class="calibre23">endl</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="33" id="calibre_link-495" class="calibre14"></span>represents the newline character and flushes the output buffer. You learn more about namespaces a little later in this chapter, including how you define your own namespaces.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">Be careful with using declarations in header files, especially when the header files are included into several other source files. In header files you should avoid placing using declarations at global scope because they will apply within any source file that includes the header file.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">The main() Function</h3>
<p class="calibre13">The <code class="calibre23">main()</code> function in the example consists of the function header defining it as <code class="calibre23">main()</code> plus everything from the first opening brace, <code class="calibre23">{</code>, to the corresponding closing brace, <code class="calibre23">}</code>. The braces enclose the executable statements in the function, which are referred to collectively as the <i class="calibre15">body</i> of the function.</p>
<p class="calibre13">As you’ll see, all functions consist of a header that defines (among other things) the function name, followed by the function body that consists of a number of program statements enclosed between braces. The body of a function may contain no statements at all, in which case, it doesn’t do anything.</p>
<p class="calibre13">A function that doesn’t do anything may seem somewhat superfluous, but when you’re writing a large program, you may map out the complete program structure in functions initially, but omit the code for many of the functions, leaving them with empty or minimal bodies. Doing this means that you can compile and execute the whole program with all its functions at any time and add detailed coding for the functions incrementally.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Program Statements</h3>
<p class="calibre13">Each program statement in the body of <code class="calibre23">main()</code> is terminated with a semicolon. It’s the semicolon that marks the end of a statement, not the end of a line. Consequently, you can spread a statement over several lines when this makes the code easier to follow, and several statements can appear in a single line. The program statement is the basic unit for defining what a program does. This is a bit like a sentence in a paragraph of text, where each sentence stands by itself in expressing an action or an idea, but relates to and combines with the other sentences in the paragraph in expressing a more general concept. A statement is a self-contained definition of an action that the computer is to carry out, but that can be combined with other statements to define a more complex action or calculation.</p>
<p class="calibre13">The action of a function is always expressed by a number of statements, each ending with a semicolon. Take a look at the statements in the example just written, just to get a feel for how it works. I will discuss each type of statement later in this chapter.</p>
<p class="calibre13">The first statement in the body of <code class="calibre23">main()</code>is:</p>
<pre class="calibre28"><code class="calibre23">int apples, oranges;           // Declare two integer variables</code></pre>
<p class="calibre13">This defines two variables, <code class="calibre23">apples</code> and <code class="calibre23">oranges</code>. A <i class="calibre15">variable</i> is a named bit of computer memory that you use to store data, and a statement that introduces the names of one or more variables is called a <i class="calibre15">variable declaration</i>. The <code class="calibre23">int</code> keyword indicates that the variables with the names <code class="calibre23">apples</code> and <code class="calibre23">oranges</code> are to store values that are whole numbers, or integers. Whenever you introduce the name of a variable into a program, you always specify what kind of data it will store, and this is called the <code class="calibre23">type</code> of the variable.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="34" id="calibre_link-496" class="calibre14"></span>The next statement defines another integer variable, <code class="calibre23">fruit</code>:</p>
<pre class="calibre28"><code class="calibre23">   int fruit;                               // ...then another one</code></pre>
<p class="calibre13">While you can define several variables in the same statement, as in the preceding statement for <code class="calibre23">apples</code> and <code class="calibre23">oranges</code>, it’s generally a good idea to define each variable in a separate statement on its own line. This enables you to comment them individually to explain how you will use them.</p>
<p class="calibre13">The next line in the example is:</p>
<pre class="calibre28"><code class="calibre23">apples = 5; oranges = 6;       // Set initial values</code></pre>
<p class="calibre13">This line contains two statements, each terminated by a semicolon. I put this here to demonstrate that you can put more than one statement in a line. Although it isn’t obligatory, it’s generally good programming practice to write only one statement on a line because it makes the code easier to understand. Good programming practice is about adopting approaches that make your code easy to follow and that minimize the likelihood of errors.</p>
<p class="calibre13">The two statements store the values <code class="calibre23">5</code> and <code class="calibre23">6</code> in the variables <code class="calibre23">apples</code> and <code class="calibre23">oranges</code>, respectively. These statements are called <i class="calibre15">assignment statements</i>, because they assign new values to variables; the = is the assignment operator.</p>
<p class="calibre13">The next statement is:</p>
<pre class="calibre28"><code class="calibre23">fruit = apples + oranges;      // Get the total fruit</code></pre>
<p class="calibre13">This is also an assignment statement, but is a little different. You have an <i class="calibre15">arithmetic expression</i> to the right of the assignment operator. This statement sums the values stored in <code class="calibre23">apples</code> and <code class="calibre23">oranges</code> and stores the result in <code class="calibre23">fruit</code>.</p>
<p class="calibre13">The next three statements are:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; endl;               // Start output on a new line
cout &lt;&lt; "Oranges are not the only fruit... " &lt;&lt; endl
     &lt;&lt; "- and we have " &lt;&lt; fruit &lt;&lt; " fruits in all.";
cout &lt;&lt; endl;               // Output a new line character</code></pre>
<p class="calibre13">These are all <i class="calibre15">output statements</i>. The first sends a newline character, denoted by the word <code class="calibre23">endl</code>, to the command line on the screen. A source of input or a destination for output in C++ is referred to as a <i class="calibre15">stream</i>. The name <code class="calibre23">cout</code> specifies the “standard” output stream, and the operator <code class="calibre23">&lt;&lt;</code> indicates that what appears to the right of the operator is to be sent to <code class="calibre23">cout</code>. The <code class="calibre23">&lt;&lt;</code> operator “points” in the direction that the data flows &mdash; from the variable, string, or expression that appears on the right of the operator to the output destination that is on the left. Thus in the first statement, the value represented by the name <code class="calibre23">endl</code> &mdash; a newline character &mdash; is sent to the stream identified by the name <code class="calibre23">cout</code> &mdash; and data transferred to <code class="calibre23">cout</code> is written to the command line. Sending <code class="calibre23">endl</code> to the stream also causes the stream buffer to be flushed so all output is sent to the command line at that point.</p>
<p class="calibre13">The meaning of the name <code class="calibre23">cout</code> and the <code class="calibre23">&lt;&lt;</code> operator are defined in the <code class="calibre23">iostream</code> header file that you added to the program code by means of the <code class="calibre23">#include</code> directive. <code class="calibre23">cout</code> is a name in the standard library so it is within the <code class="calibre23">std</code> namespace. Without the <code class="calibre23">using</code> directive, it would not be recognized unless you used its fully qualified name, <code class="calibre23">std::cout. cout</code> has been defined to represent the standard output stream so you shouldn’t use <code class="calibre23">cout</code> for other purposes. Using the same name for different things is likely to cause confusion.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="35" id="calibre_link-497" class="calibre14"></span>The second output statement of the three is spread over two lines:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "Oranges are not the only fruit... " &lt;&lt; endl
     &lt;&lt; "- and we have " &lt;&lt; fruit &lt;&lt; " fruits in all.";</code></pre>
<p class="calibre13">As I said earlier, you can spread each statement over as many lines as you wish. The end of a statement is always signalled by a semicolon, not the end of a line. Successive lines are read and combined into a single statement by the compiler until it finds the semicolon that defines the end of the statement. Of course, this means that if you forget to put a semicolon at the end of a statement, the compiler will assume the next line is part of the same statement and join them together. This usually results in something the compiler cannot understand, so you’ll get an error message.</p>
<p class="calibre13">The statement sends the text string <code class="calibre23">"Oranges are not the only fruit..."</code> to the command line, followed by another newline character (<code class="calibre23">endl</code>), then another text string, <code class="calibre23">"- and we have "</code>, followed by the value stored in the variable <code class="calibre23">fruit</code>, then, finally, another text string, <code class="calibre23">" fruits in all."</code>. There is no problem stringing together a sequence of things that you want to output in this way. The statement executes from left to right, with each item being sent to <code class="calibre23">cout</code> in turn. Note that each item to be sent to <code class="calibre23">cout</code> is preceded by its own <code class="calibre23">&lt;&lt;</code> operator.</p>
<p class="calibre13">The third and last output statement sends another newline character to the screen, and the three statements produce the output that you see. The last statement is:</p>
<pre class="calibre28"><code class="calibre23">return 0;                      // Exit the program</code></pre>
<p class="calibre13">This terminates execution of <code class="calibre23">main()</code>, which ends the program. Control returns to the operating system, and the <code class="calibre23">0</code> is a return code that tells the operating system that the application terminated successfully. You can omit the return statement from <code class="calibre23">main()</code> and it will still compile and run. I’ll discuss all these statements in more detail later.</p>
<p class="calibre13">Program statements execute in the sequence in which they are written, unless a statement specifically causes the natural sequence to be altered. In Chapter 3, you’ll look at statements that alter the sequence of execution.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Whitespace</h3>
<p class="calibre13"><i class="calibre15">Whitespace</i> is any sequence of blanks, tabs, newline characters, form feed characters, and comments. Whitespace serves to separate one part of a statement from another and enables the compiler to identify where one element in a statement, such as <code class="calibre23">int</code>, ends and the next element begins. Otherwise, whitespace is ignored and has no effect.</p>
<p class="calibre13">For example, consider the following statement:</p>
<pre class="calibre28"><code class="calibre23">int fruit;                     // ...then another one</code></pre>
<p class="calibre13">There must be at least one whitespace character between <code class="calibre23">int</code> and <code class="calibre23">fruit</code> for the compiler to be able to distinguish them, but if you add more whitespace characters, they will be ignored. The content of the line following the semicolon is all whitespace and is therefore ignored.</p>
<p class="calibre13">On the other hand, look at this statement:</p>
<pre class="calibre28"><code class="calibre23">fruit = apples + oranges;      // Get the total fruit</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="36" id="calibre_link-498" class="calibre14"></span>No whitespace characters are necessary between <code class="calibre23">fruit</code> and <code class="calibre23">=</code>, or between <code class="calibre23">=</code> and <code class="calibre23">apples</code>, although you are free to include some if you wish. This is because the <code class="calibre23">=</code> is not alphabetic or numeric, so the compiler can separate it from its surroundings. Similarly, no whitespace characters are necessary on either side of the <code class="calibre23">+</code> sign, but you can include some if you want.</p>
<p class="calibre13">Apart from its use as a separator between elements, the compiler ignores whitespace (except, of course, in a string of characters between double quotes). You can include as much whitespace as you like to make your program more readable. Remember that the end of a statement is wherever the semicolon occurs.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Statement Blocks</h3>
<p class="calibre13">You can enclose several statements between a pair of braces, in which case, they become a <i class="calibre15">block</i>, or a <i class="calibre15">compound statement</i>. The body of a function is an example of a block. Such a compound statement can be thought of as a single statement (as you’ll see when you look at the decision-making possibilities in Chapter 3). Wherever you can put a single statement, you could equally well put a block of statements between braces. As a consequence, blocks can be placed inside other blocks. In fact, blocks can be nested, one within another, to any depth.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A statement block has important effects on variables, but I will defer discussion of this until the “Understanding Storage Duration and Scope” section later in this chapter.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Automatically Generated Console Programs</h3>
<p class="calibre13">In the last example, you opted to produce the project as an empty project with no source files, and you added the source file subsequently. If you allow the Application Wizard to generate the project as you did in Chapter 1, the project will contain several files, so let’s look at their contents in a little more depth. Create a new Win32 console project with the name <code class="calibre23"><b class="calibre12">Ex2_01A</b></code>, and this time allow the Application Wizard to finish without setting any options in the Application Settings dialog. The project will have four files containing code: the <code class="calibre23">Ex2_01A.cpp</code> and <code class="calibre23">stdafx.cpp</code> source files, the <code class="calibre23">stdafx.h</code> header file, and the <code class="calibre23">targetver.h</code> file that specifies the earliest version of Windows that is capable of running your application. They represent a working program that does nothing. You can close an open project by selecting File <img src="images/000122.png" alt="image" class="calibre25" /> Close Solution on the main menu. You can create a new project with an existing project open, in which case, the old project will be closed automatically unless you elect to add it to the same solution.</p>
<p class="calibre13"><code class="calibre23">Ex2_01A.cpp</code> contains the following:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_01A.cpp : Defines the entry point for the console application.
//
        
#include "stdafx.h"
        
int _tmain(int argc, _TCHAR* argv[])
{
  return 0;
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="37" id="calibre_link-499" class="calibre14"></span>This is decidedly different from the previous example. There is an <code class="calibre23">#include</code> directive for the <code class="calibre23">stdafx.h</code> header file and the function where execution starts is called <code class="calibre23">_tmain()</code>, not <code class="calibre23">main()</code>. Chapter 5 explains the things between the parentheses in the function header.</p>
<section class="toclist">
<h4 class="calibre22">Precompiled Header Files</h4>
<p class="calibre13">The Application Wizard generated the <code class="calibre23">stdafx.h</code> header file as part of the project, and if you look at the code in there, you’ll see three further <code class="calibre23">#include</code> directives for the <code class="calibre23">targetver.h</code> header that I mentioned earlier, plus the standard library header files <code class="calibre23">stdio.h</code> and <code class="calibre23">tchar.h</code>. The old-style header <code class="calibre23">stdio.h</code> is for standard I/O and was used before the current C++ standard; this covers ground similar to the <code class="calibre23">iostream</code> header but does not define the same names. Our console examples will use <code class="calibre23">iostream</code> so you will need to include it. <code class="calibre23">tchar.h</code> is a Microsoft-specific header file defining text functions.</p>
<p class="calibre13">The idea of <code class="calibre23">stdafx.h</code> is that it will be compiled only when its contents change and not recompiled every time you compile the program. Compiling <code class="calibre23">stdafx.h</code> results in a <code class="calibre23">.pch</code> file (precompiled header file). The compiler only recompiles <code class="calibre23">stdafx.h</code> if there is no corresponding <code class="calibre23">.pch</code> file, or if the timestamp for the <code class="calibre23">.pch</code> file is earlier than the timestamp for the <code class="calibre23">stdafx.h</code> file. Some standard library header files are very large, so this feature can significantly reduce the time it takes to compile a project. If you only put an <code class="calibre23">#include</code> directive for <code class="calibre23">iostream</code> in <code class="calibre23">Ex2_01A.cpp</code>, the header is recompiled each time you compile the program. If you put it in <code class="calibre23">stdafx.h, iostream</code> will only be compiled once. Thus <code class="calibre23">stdafx.h</code> should contain <code class="calibre23">#include</code> directives for all header files that are not going to be changed very often, if at all. These will be standard header files for your project plus any of your own project header files that are rarely changed. While you are learning C++, you won’t be using either of the headers that appear in <code class="calibre23">stdafx.h</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Main Function Names</h4>
<p class="calibre13">As I explained, Visual C++ supports <code class="calibre23">wmain()</code> as an alternative to <code class="calibre23">main()</code> when you are writing a program that’s using Unicode characters &mdash; <code class="calibre23">wmain()</code> being a Microsoft-specific definition for <code class="calibre23">main()</code> that is not part of standard C++. The <code class="calibre23">tchar.h</code> header defines the name <code class="calibre23">_tmain</code> such that it will normally be replaced by <code class="calibre23">main</code>, but will be replaced by <code class="calibre23">wmain</code> if the symbol <code class="calibre23">_UNICODE</code> is defined. To identify a program as using Unicode, you could add the following statements to the beginning of the <code class="calibre23">stdafx.h</code> header file:</p>
<pre class="calibre28"><code class="calibre23">#define _UNICODE
#define  UNICODE</code></pre>
<p class="calibre13">So why do you need two statements? Defining the <code class="calibre23">_UNICODE</code> symbol causes the Windows header files to assume Unicode characters are the default. Defining <code class="calibre23">_UNICODE</code> does the same for the C runtime header files that come with the C++ standard library. You don’t need to do this with the <code class="calibre23">Ex2_01A</code> project because the <code class="calibre23">Character Set</code> project property will have been set to use the Unicode character set by default. Now that I’ve explained all that, I’ll stick to plain old <code class="calibre23">main()</code> for our C++ console examples because this option is standard C++ and therefore the most portable coding approach.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can use the default console project for the console examples in the book if you wish. In this case just put the code from the body of <code class="calibre23">main()</code> in an example as the body of <code class="calibre23">_tmain()</code>. You can put any <code class="calibre23">#include</code> directives for standard library headers in <code class="calibre23">stdafx.h</code>.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-245" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="38" id="calibre_link-500" class="calibre18"></span>DEFINING VARIABLES</h2>
<p class="calibre13">A fundamental objective in all computer programs is to manipulate data and get some answers. An essential element in this process is having a piece of memory that you can call your own, that you can refer to using a meaningful name, and where you can store an item of data. Each piece of memory specified is called a <i class="calibre15">variable</i>.</p>
<p class="calibre13">As you know, each variable will store a particular kind of data, and the type of data that can be stored is fixed when you define the variable. One variable might store whole numbers (that is, integers), in which case you can’t use it to store fractional values. The value that a variable contains at any point is determined by the statements in your program and will usually change many times as the program progresses.</p>
<section class="toclist">
<h3 class="calibre21">Naming Variables</h3>
<p class="calibre13">Names of variables, or indeed names of anything in C++, can be any sequence of letters and digits, where the underscore, <code class="calibre23">_</code>, counts as a letter in this context. No other characters are allowed. If you use some other character in a name, you will get an error message when you compile the program. Names must begin with either a letter or an underscore and are usually chosen to indicate the kind of information stored. Names are also referred to as <i class="calibre15">identifiers</i>.</p>
<p class="calibre13">Names can be up to 2,048 characters in Visual C++ so you have a more than reasonable amount of flexibility. Using long names can make your programs difficult to read, and unless you have amazing keyboard skills, they are the very devil to type in. A more serious consideration is that not all compilers support very long names. Realistically, you rarely need to use names of more than 10 or 15 characters.</p>
<p class="calibre13">Names that begin with an underscore and include uppercase letters (for example, <code class="calibre23">_Upper</code> and <code class="calibre23">_Lower</code>) are best avoided because of potential clashes with standard library names that have this form. You should also avoid using names that include a double underscore for the same reason.</p>
<p class="calibre13">Here are some examples of valid variable names:</p>
<pre class="calibre28"><code class="calibre23">price  discount  pShape  value_  COUNT
five NaCl sodiumChloride tax_rate</code></pre>
<p class="calibre13">Meaningful names involving two or more words can be constructed in various ways &mdash; capitalizing the first letter of the second and subsequent words or inserting underscores between words, for instance. There are examples in the preceding list. I’ll use various styles for names in code in the book, but it’s a good idea to stick to one style, at least within a single program.</p>
<p class="calibre13"><code class="calibre23">8_Ball, 7Up</code>, and <code class="calibre23">6_pack</code> are not legal names. Neither is <code class="calibre23">Hash!</code> nor <code class="calibre23">Mary-Ann</code>. This last example is a common mistake, although <code class="calibre23">Mary_Ann</code> with an underscore is okay. Of course, <code class="calibre23">Mary Ann</code> is not, because variable names cannot contain whitespace. The names <code class="calibre23">republican</code> and <code class="calibre23">Republican</code> are different because names are case-sensitive. A common convention is to reserve names beginning with a capital letter for classes and to use names beginning with a lowercase letter for variables. I’ll discuss classes in Chapter 8.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="39" id="calibre_link-501" class="calibre24"></span>Keywords</h3>
<p class="calibre13"><i class="calibre15">Keywords</i> are reserved words in C++ that have special significance within the language. You must not use keywords as names in your code. Keywords are highlighted with a particular color by the editor and the default is blue. If a keyword does not appear highlighted, then you have entered it incorrectly. If you don’t like the default highlighting colors used by the editor to identify various language elements, you can change them. First select Options from the Tools menu, then make whatever changes you want after selecting Environment/Fonts and Colors in the left dialog pane.</p>
<p class="calibre13">Remember that keywords, like names, are case-sensitive. For example, the program you entered earlier in the chapter contained the keywords <code class="calibre23">int</code> and <code class="calibre23">return</code>; if you write <code class="calibre23">Int</code> or <code class="calibre23">Return</code>, these are not keywords and therefore will not be recognized and won’t be highlighted in blue. You will see many more keywords as you progress through the book.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Declaring Variables</h3>
<p class="calibre13">As you know, a variable <i class="calibre15">declaration</i> is a statement that specifies the name of a variable and its type. For example:</p>
<pre class="calibre28"><code class="calibre23">int value;</code></pre>
<p class="calibre13">This declares a variable with the name <code class="calibre23">value</code> that can store integers. The type of data that can be stored in <code class="calibre23">value</code> is specified by the keyword <code class="calibre23">int</code>, so you can only use <code class="calibre23">value</code> to store data of type <code class="calibre23">int</code>.</p>
<p class="calibre13">A single declaration can specify the names of several variables:</p>
<pre class="calibre28"><code class="calibre23"> int cost, discount_percent, net_price;</code></pre>
<p class="calibre13">This is not recommended. It is generally better to declare variables in individual statements, one per line. I’ll deviate from this from time to time in this book, usually in the interests of not spreading code over too many pages.</p>
<p class="calibre13">To store an item of data you need to have a memory location associated with the variable name. This process is called variable <i class="calibre15">definition</i>. Except in a few special cases that you will meet in the book, a variable declaration is also a definition so it introduces the variable name and ties it to an appropriately sized piece of memory.</p>
<p class="calibre13">Consider the statement:</p>
<pre class="calibre28"><code class="calibre23">int value;</code></pre>
<p class="calibre13">This is a declaration and a definition. You use the variable <i class="calibre15">name,</i> <code class="calibre23">value,</code> that you have declared, to access the  <i class="calibre15">memory</i> associated with it, and that can store a single value of type <code class="calibre23">int</code>. The reason for this apparently pedantic differentiation between a declaration and a definition is that you will meet statements that are declarations but not definitions. To avoid error messages from the compiler, you must declare a variable before the variable is used for the first time. It is good practice to declare variables close to their first point of use.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="40" id="calibre_link-502" class="calibre24"></span>Initial Values for Variables</h3>
<p class="calibre13">You can assign an initial value to a variable when you declare it. A declaration that assigns an initial value to a variable is called an <i class="calibre15">initialization</i>. There are three forms of syntax available to do this, and I show you the recommended approach last. The following statements give each of the variables an initial value:</p>
<pre class="calibre28"><code class="calibre23">int value = 0;
int count = 10;
int number = 5;</code></pre>
<p class="calibre13"><code class="calibre23">value</code> will have the value <code class="calibre23">0, count</code> will have the value <code class="calibre23">10</code>, and <code class="calibre23">number</code> will have the value <code class="calibre23">5</code>.</p>
<p class="calibre13">A second way to initialize a variable uses <i class="calibre15">functional notation</i>. Instead of an equal sign and the value, you write the value in parentheses following the variable name. You could rewrite the previous statements like this:</p>
<pre class="calibre28"><code class="calibre23">int value(0);
int count(10);
int number(5);</code></pre>
<p class="calibre13">The third possibility and the recommended approach is to use an <i class="calibre15">initializer list</i>. The previous three statements can be written:</p>
<pre class="calibre28"><code class="calibre23">int value{};
int count{10};
int number{5};</code></pre>
<p class="calibre13">The initial value appears between braces, following the variable name. If the braces are empty, as in the definition for <code class="calibre23">value</code>, 0 is assumed so <code class="calibre23">value</code> will be <code class="calibre23">0</code>. This notation was introduced by the C++ 11 standard, and although the previous two methods are still valid, this is now the preferred approach. The reason is that the same notation can be used in almost every context, thus making initialization uniform. I use it throughout the rest of the book and indicate the few circumstances where it cannot be used.</p>
<p class="calibre13">If you don’t supply an initial value, a variable will usually contain garbage left in the memory it occupies by a previous program (there is an exception to this that you will meet later in this chapter). Wherever possible, you should initialize variables when you define them. If your variables start out with known values, it is easier to work out what is happening when things go wrong. And you can be sure that things <i class="calibre15">will</i> go wrong.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-246" class="calibre3"></a>FUNDAMENTAL DATA TYPES</h2>
<p class="calibre13">The sort of information that a variable can hold is determined by its <i class="calibre15">data type</i>. All data and variables in your program must be of some defined type. C++ provides a range of <i class="calibre15">fundamental data types</i>, specified by particular keywords. Fundamental data types are so-called because they store values that represent fundamental data in your computer, essentially numerical values. Characters are numeric because a character is represented by a numeric character code. You have already seen type <code class="calibre23">int</code> for integer variables.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="41" id="calibre_link-503" class="calibre14"></span>The fundamental types fall into three categories:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Types that store integers</li>
<li class="calibre6">Types that store non-integral values, called <i class="calibre15">floating-point</i> types</li>
<li class="calibre6">The <code class="calibre23">void</code> type that specifies an empty set of values or no type</li>
</ul>
<section class="toclist">
<h3 class="calibre21">Integer Variables</h3>
<p class="calibre13">Integer variables can only store whole numbers. The number of players in a football team is an integer, at least at the beginning of the game. You already know that you can declare integer variables using the keyword <code class="calibre23">int</code>. Variables of type <code class="calibre23">int</code> occupy 4 bytes in memory and can store both positive and negative integers. The upper and lower limits for values of type <code class="calibre23">int</code> correspond to the maximum and minimum signed binary numbers that can be represented by 32 bits. The upper limit is 2<sup class="calibre33">31</sup> - 1, which is 2,147,483,647, and the lower limit is -(2<sup class="calibre33">31</sup>), which is -2,147,483,648. Here’s an example of defining a variable of type <code class="calibre23">int</code>:</p>
<pre class="calibre28"><code class="calibre23">int toeCount {10};</code></pre>
<p class="calibre13">The <code class="calibre23">short</code> keyword defines an integer variable occupying 2 bytes. The keyword <code class="calibre23">short</code> is equivalent to <code class="calibre23">short int</code>, so you could define two variables of type <code class="calibre23">short</code> with the following statements:</p>
<pre class="calibre28"><code class="calibre23">short feetPerPerson {2};
short int feetPerYard {3};</code></pre>
<p class="calibre13">Both variables are of the same type because <code class="calibre23">short</code> means exactly the same as <code class="calibre23">short int</code>. I used both forms of the type name to show them in use, but it is best to stick to one representation, and <code class="calibre23">short</code> is used most often.</p>
<p class="calibre13">The integer type, <code class="calibre23">long</code>, occupies 4 bytes in Visual C++ and therefore can store the same range of values as type <code class="calibre23">int</code>. You’ll find type <code class="calibre23">long</code> occupies 8 bytes with some other C++ compilers. The type can also be written as <code class="calibre23">long int</code>. Here’s how you can declare variables of type <code class="calibre23">long</code>:</p>
<pre class="calibre28"><code class="calibre23">long bigNumber {1000000L};
long int largeValue {};</code></pre>
<p class="calibre13">These statements declare the variables <code class="calibre23">bigNumber</code> and <code class="calibre23">largeValue</code> with initial values <code class="calibre23">1000000</code> and <code class="calibre23">0</code>, respectively. The letter <code class="calibre23">L</code> appended to the literals specifies that they are of type <code class="calibre23">long</code>. You can use a small letter <code class="calibre23">l</code> but it has the disadvantage that it is easily confused with the digit <code class="calibre23">1</code>. Integer literals without an <code class="calibre23">L</code> appended are of type <code class="calibre23">int</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You must not include commas when writing numeric values in your code. In text you can write the number 12,345, but in code you must write it as 12345.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You can use variables of type <code class="calibre23">long long</code> to store integers of an even greater magnitude:</p>
<pre class="calibre28"><code class="calibre23">long long huge {100000000LL};</code></pre>
<p class="calibre13">Variables of type <code class="calibre23">long long</code> occupy 8 bytes and store values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. The suffix to identify an integer as type <code class="calibre23">long long</code> is <code class="calibre23">LL</code> or <code class="calibre23">ll</code>. The latter is best avoided because it looks like eleven.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="42" id="calibre_link-504" class="calibre24"></span>Character Data Types</h3>
<p class="calibre13">The <code class="calibre23">char</code> data type serves a dual purpose. It specifies a one-byte variable that can store integers within a given range, or it can store the code for a single <i class="calibre15">ASCII</i> character (the <i class="calibre15">American Standard Code for Information Interchange</i>). You can declare a <code class="calibre23">char</code> variable with this statement:</p>
<pre class="calibre28"><code class="calibre23">char letter {'A'};</code></pre>
<p class="calibre13">This declares the variable <code class="calibre23">letter</code> and initializes it with the constant <code class="calibre23">'A'</code>. You specify a value that is a single character between single quotes. Because <code class="calibre23">'A'</code> is represented in ASCII by the decimal value 65, you could have written the statement as:</p>
<pre class="calibre28"><code class="calibre23">char letter {65};            // Equivalent to A</code></pre>
<p class="calibre13">This produces the same result as the previous statement. The range of integers that can be stored in a variable of type <code class="calibre23">char</code> is from -128 to 127.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The C++ standard does not require that type</i> <code class="calibre23">char</code> <i class="calibre15">should represent signed 1-byte integers. It is the compiler implementer’s choice as to whether type</i> <code class="calibre23">char</code> <i class="calibre15">stores signed integers in the range -128 to +127 or unsigned integers in the range 0 to 255. You need to keep this in mind if you are porting your code to a different environment.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The type <code class="calibre23">wchar_t</code> is so-called because it is a <i class="calibre15">wide character type</i>. Variables of this type in Visual C++ store 2-byte character codes with values in the range from 0 to 65,535. Here’s an example of defining a variable of type <code class="calibre23">wchar_t</code>:</p>
<pre class="calibre28"><code class="calibre23">wchar_t letter {L'Z'};       // A variable storing a 16-bit character code</code></pre>
<p class="calibre13">This defines <code class="calibre23">letter</code> and initializes it with the 16-bit code for the letter Z. The <code class="calibre23">L</code> preceding the character constant, <code class="calibre23">'Z'</code>, tells the compiler that this is a 16-bit character code value.</p>
<p class="calibre13">You can also use hexadecimal constants to initialize integer variables, including those of type <code class="calibre23">char</code>. A hexadecimal number is written using the standard representation for hexadecimal digits: 0 to 9, and A to F (or a to f) for digits with values from 10 to 15. It’s also prefixed by <code class="calibre23">0x</code> (or <code class="calibre23">0X</code>) to distinguish it from a decimal value. Thus, to get exactly the same result again, you could rewrite the last statement as follows:</p>
<pre class="calibre28"><code class="calibre23">wchar_t letter{0x5A};        // A variable storing a 16-bit character code</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">Don’t write decimal integer values with a leading zero. The compiler will interpret such values as octal (base 8), so a value written as 065 will be equivalent to 53 in decimal notation.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Microsoft Windows provides a Character Map utility that enables you to locate characters from any of the fonts available. It will show the character code in hexadecimal and tell you the keystroke to use for entering the character.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="43" id="calibre_link-505" class="calibre24"></span>Integer Type Modifiers</h3>
<p class="calibre13">Variables of the types <code class="calibre23">char, int, short, long</code>, or <code class="calibre23">long long</code> store <code class="calibre23">signed</code> integer values so you can use these types to store either positive or negative values. This is because these types are assumed to have the default <i class="calibre15">type modifier</i> <code class="calibre23">signed</code>. So, wherever you wrote <code class="calibre23">int</code> or <code class="calibre23">long</code>, you could have written <code class="calibre23">signed int</code> or <code class="calibre23">signed long</code>, respectively.</p>
<p class="calibre13">You can also use the <code class="calibre23">signed</code> keyword by itself to specify the type of a variable, in which case, it means <code class="calibre23">signed int</code>. For example:</p>
<pre class="calibre28"><code class="calibre23">signed value {-5};           // Equivalent to signed int</code></pre>
<p class="calibre13">This usage is not common. I prefer to use <code class="calibre23">int</code> because it is more obvious what is meant.</p>
<p class="calibre13">The range of values you can store as type <code class="calibre23">char,</code> -128 to 127, is the same as the range of values you can store in a variable of type <code class="calibre23">signed char</code>. In spite of this, <code class="calibre23">char</code> and <code class="calibre23">signed char</code> are different types so you should not make the mistake of assuming they are the same. Whether type <code class="calibre23">char</code> is signed or unsigned is implementation defined in general. Visual C++ defines it as <code class="calibre23">signed char</code> but it may be different with other compilers.</p>
<p class="calibre13">If you are sure that you don’t need to store negative values (for example, if you were recording the number of miles you drive in a week), you can specify a variable as <code class="calibre23">unsigned</code>:</p>
<pre class="calibre28"><code class="calibre23">unsigned long mileage {0UL};</code></pre>
<p class="calibre13">The minimum value that can be stored in <code class="calibre23">mileage</code> is zero and the maximum is 4,294,967,295 (that’s 2<sup class="calibre33">32</sup>-1). Compare this to the range for a <code class="calibre23">signed long</code>, -2,147,483,648 to 2,147,483,647 (that’s -2<sup class="calibre33">31</sup> to 2<sup class="calibre33">31</sup>-1). The bit that is used in a <code class="calibre23">signed</code> variable as the sign is part of the numeric value in an <code class="calibre23">unsigned</code> variable. Consequently, an <code class="calibre23">unsigned</code> variable can store larger positive values, but it can’t represent a negative value. Note how a <code class="calibre23">U</code> (or <code class="calibre23">u</code>) is appended to <code class="calibre23">unsigned</code> constants. In the preceding example, I also appended <code class="calibre23">L</code> to indicate that the constant is <code class="calibre23">long</code>. You can use either upper- or lowercase for <code class="calibre23">U</code> and <code class="calibre23">L</code>, and the sequence is unimportant. However, it’s a good idea to adopt a consistent approach.</p>
<p class="calibre13">You can also use <code class="calibre23">unsigned</code> by itself as the type specification for a variable, in which case, you are specifying the type as <code class="calibre23">unsigned int</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Remember, both</i> <code class="calibre23">signed</code> <i class="calibre15">and</i> <code class="calibre23">unsigned</code> <i class="calibre15">are keywords, so you can’t use them as variable names.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The Boolean Type</h3>
<p class="calibre13"><i class="calibre15">Boolean variables</i> can store one of two values: a value called <code class="calibre23">true</code> and a value called <code class="calibre23">false</code>. Boolean variables are also referred to as <i class="calibre15">logical variables</i>. The type for a logical variable is <code class="calibre23">bool</code>, named after George Boole, who developed Boolean algebra, and it is regarded as an integer type. Variables of type <code class="calibre23">bool</code> are used to store the results of tests that can be either <code class="calibre23">true</code> or <code class="calibre23">false</code>, such as whether two values are equal.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="44" id="calibre_link-506" class="calibre14"></span>You could declare a variable of type <code class="calibre23">bool</code> with the statement:</p>
<pre class="calibre28"><code class="calibre23">bool testResult;</code></pre>
<p class="calibre13">Of course, you can also initialize <code class="calibre23">bool</code> variables when you declare them:</p>
<pre class="calibre28"><code class="calibre23">bool colorIsRed {true};</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The values</i> <code class="calibre23">TRUE</code> <i class="calibre15">and</i> <code class="calibre23">FALSE</code> <i class="calibre15">are used quite extensively with variables of numeric types, and particularly of type</i> <code class="calibre23">int</code>. <i class="calibre15">This is a hangover from the time before type</i> <code class="calibre23">bool</code> <i class="calibre15">was implemented in C++ when variables of type</i> <code class="calibre23">int</code> <i class="calibre15">were typically used to represent logical values. In this case a zero-value is treated as false and a non-zero value as true. The symbols</i> <code class="calibre23">TRUE</code> <i class="calibre15">and</i> <code class="calibre23">FALSE</code> <i class="calibre15">are still used within the MFC where they represent a non-zero integer value and 0, respectively. Note that</i> <code class="calibre23">TRUE</code> <i class="calibre15">and</i> <code class="calibre23">FALSE</code> &mdash; <i class="calibre15">written with capital letters &mdash; are not keywords; they are just symbols defined in the Win32 SDK.</i> <code class="calibre23">TRUE</code> <i class="calibre15">and</i> <code class="calibre23">FALSE</code> <i class="calibre15">are not legal</i> <code class="calibre23">bool</code> <i class="calibre15">values, so don’t confuse</i> <code class="calibre23">true</code> <i class="calibre15">with</i> <code class="calibre23">TRUE</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Floating-point Types</h3>
<p class="calibre13">Values that aren’t integral are stored as <i class="calibre15">floating-point</i> numbers. A floating-point number can be expressed as a decimal value such as 112.5, or with an exponent such as 1.125E2 where the decimal part is multiplied by the power of 10 specified after the E (for Exponent). Thus 1.125E2 is 1.125 × 10<sup class="calibre33">2</sup>, which is 112.5.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A floating-point constant must contain a decimal point, or an exponent, or both. If you write a numerical value with neither, you have an integer.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You can specify a floating-point variable using the keyword <code class="calibre23">double</code>, as in this statement:</p>
<pre class="calibre28"><code class="calibre23">double in_to_mm {25.4};</code></pre>
<p class="calibre13">A variable of type <code class="calibre23">double</code> occupies 8 bytes and stores values accurate to approximately 15 decimal digits. The range of values stored is much wider than the 15 digits’ accuracy indicates, being from 1.7 × 10<sup class="calibre33">-308</sup> to 1.7 × 10<sup class="calibre33">308</sup>, positive and negative. If you don’t need 15 digits’ precision, and you don’t need the massive range of values provided by <code class="calibre23">double</code> variables, you can use the keyword <code class="calibre23">float</code> to declare floating-point variables that occupy 4 bytes. For example:</p>
<pre class="calibre28"><code class="calibre23">float pi {3.14159f};</code></pre>
<p class="calibre13">This defines <code class="calibre23">pi</code> with the initial value 3.14159. The <code class="calibre23">f</code> at the end of the constant specifies that it is of type <code class="calibre23">float</code>. Without the <code class="calibre23">f</code>, the constant would be type <code class="calibre23">double</code>. Variables of type <code class="calibre23">float</code> have approximately 7 decimal digits of precision and can have values from 3.4 × 10<sup class="calibre33">-38</sup> to 3.4 × 10<sup class="calibre33">38</sup>, positive and negative.</p>
<p class="calibre13">The C++ standard also defines the <code class="calibre23">long double</code> floating-point type, which is implemented with the same range and precision as type <code class="calibre23">double</code> in Visual C++. With some compilers, <code class="calibre23">long double</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="45" id="calibre_link-507" class="calibre14"></span>corresponds to a 16-byte floating-point value with a much greater range and precision than type <code class="calibre23">double</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Fundamental Types in C++</h3>
<p class="calibre13">The following table summarizes all the fundamental types and the range of values that are supported for these in Visual C++:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TYPE</b></th>
<th class="calibre32"><b class="calibre12">SIZE IN BYTES</b></th>
<th class="calibre32"><b class="calibre12">RANGE OF VALUES</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">bool</code></td>
<td class="calibre32">1</td>
<td class="calibre32"><code class="calibre23">true</code> or <code class="calibre23">false</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">char</code></td>
<td class="calibre32">1</td>
<td class="calibre32">By default, the same as type <code class="calibre23">signed char</code>: -128 to 127; optionally, you can make <code class="calibre23">char</code> the same range as type <code class="calibre23">unsigned char</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">signed char</code></td>
<td class="calibre32">1</td>
<td class="calibre32">-128 to 127</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned char</code></td>
<td class="calibre32">1</td>
<td class="calibre32">0 to 255</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">wchar_t</code></td>
<td class="calibre32">2</td>
<td class="calibre32">0 to 65,535</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">short</code></td>
<td class="calibre32">2</td>
<td class="calibre32">-32,768 to 32,767</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned short</code></td>
<td class="calibre32">2</td>
<td class="calibre32">0 to 65,535</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int</code></td>
<td class="calibre32">4</td>
<td class="calibre32">-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned int</code></td>
<td class="calibre32">4</td>
<td class="calibre32">0 to 4,294,967,295</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">long</code></td>
<td class="calibre32">4</td>
<td class="calibre32">-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned long</code></td>
<td class="calibre32">4</td>
<td class="calibre32">0 to 4,294,967,295</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">long long</code></td>
<td class="calibre32">8</td>
<td class="calibre32">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned long long</code></td>
<td class="calibre32">8</td>
<td class="calibre32">0 to 18,446,744,073,709,551,615</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">float</code></td>
<td class="calibre32">4</td>
<td class="calibre32">±3.4 × 10<sup class="calibre33">±38</sup> with approximately 7-digit accuracy</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">double</code></td>
<td class="calibre32">8</td>
<td class="calibre32">±1.7 × 10<sup class="calibre33">±308</sup> with approximately 15-digit accuracy</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">long double</code></td>
<td class="calibre32">8</td>
<td class="calibre32">±1.7 × 10<sup class="calibre33">±308</sup> with approximately 15-digit accuracy</td>
</tr>
</tbody>
</table>
</section>
<section class="toclist">
<h3 class="calibre21">Literals</h3>
<p class="calibre13">I have already used a lot of explicit constants to initialize variables. Constant values of any kind are referred to as <i class="calibre15">literals</i>. A literal is a value of a specific type, and values such as <code class="calibre23">23, 3.14159, 9.5f</code>, and <code class="calibre23">true</code> are examples of literals of types <code class="calibre23">int, double, float</code>, and <code class="calibre23">bool</code>, respectively. <code class="calibre23">"Samuel Beckett"</code> is an example of a literal that is a string, but I’ll defer discussion of exactly what type this is until Chapter 4. Here’s a summary of how you write literals of the types you have met:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="46" id="calibre_link-508" class="calibre14"></span><b class="calibre12">TYPE</b></th>
<th class="calibre32"><b class="calibre12">EXAMPLES OF LITERALS</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">char, signed char</code>, or <code class="calibre23">unsigned char</code></td>
<td class="calibre32"><code class="calibre23">'A', 'Z', '8', '*'</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">wchar_t</code></td>
<td class="calibre32"><code class="calibre23">L'A', L'Z', L'8', L'*'</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int</code></td>
<td class="calibre32"><code class="calibre23">-77, 65, 12345, 0x9FE</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned int</code></td>
<td class="calibre32"><code class="calibre23">10U, 64000u</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">long</code></td>
<td class="calibre32"><code class="calibre23">-77L, 65L, 12345l</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned long</code></td>
<td class="calibre32"><code class="calibre23">5UL, 999999UL, 25ul, 35Ul</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">long long</code></td>
<td class="calibre32"><code class="calibre23">-777LL, 66LL, 1234567ll</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unsigned long long</code></td>
<td class="calibre32"><code class="calibre23">55ULL, 999999999ULL, 885ull, 445Ull</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">float</code></td>
<td class="calibre32"><code class="calibre23">3.14f, 34.506F</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">double</code></td>
<td class="calibre32"><code class="calibre23">1.414, 2.71828</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">long double</code></td>
<td class="calibre32"><code class="calibre23">1.414L, 2.71828l</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">bool</code></td>
<td class="calibre32"><code class="calibre23">true, false</code></td>
</tr>
</tbody>
</table>
<p class="calibre13">You can’t specify literals of type <code class="calibre23">short</code> or <code class="calibre23">unsigned short</code>, but the compiler will accept initial values of type <code class="calibre23">int</code> for variables of these types, provided the value is within the range of the type.</p>
<p class="calibre13">You will often need to use literals in calculations, for example, conversion values such as 12 for feet to inches or 25.4 for inches to millimeters. However, you should avoid using numeric literals explicitly where their significance is not obvious. It is not necessarily apparent to everyone that 2.54 is the number of centimeters in an inch. It is better to declare a variable with a fixed value &mdash; you might name a variable with the value 2.54 as <code class="calibre23">inchesToCentimeters</code>, for example. Then wherever you use <code class="calibre23">inchesToCentimeters</code> in your code, it will be quite obvious what it is. You will see how to fix the value of a variable a little later in this chapter.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Defining Type Aliases</h3>
<p class="calibre13">The <code class="calibre23">typedef</code> keyword enables you to define your own name for an existing type. For example, you could define the name <code class="calibre23">BigOnes</code> as equivalent to the standard <code class="calibre23">long int</code> type with this declaration:</p>
<pre class="calibre28"><code class="calibre23">typedef long int BigOnes;       // Defining BigOnes as a type name</code></pre>
<p class="calibre13">This defines <code class="calibre23">BigOnes</code> as an alias for <code class="calibre23">long int</code>, so you could declare a variable <code class="calibre23">mynum</code> as type <code class="calibre23">long int</code> with the declaration:</p>
<pre class="calibre28"><code class="calibre23">BigOnes mynum {};               // Define a long int variable</code></pre>
<p class="calibre13">There’s no difference between this and the declaration using the built-in type name. You could equally well use:</p>
<pre class="calibre28"><code class="calibre23">long int mynum {};              // Define a long int variable</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="47" id="calibre_link-509" class="calibre14"></span>When you define a type alias such as <code class="calibre23">BigOnes</code>, you can use both type specifiers within the same program for variables and the variables will have the same type.</p>
<p class="calibre13">The C++ 11 standard introduced an alternative syntax for defining a type alias that uses the <code class="calibre23">using</code> keyword. You could write the definition of the <code class="calibre23">BigOnes</code> alias as:</p>
<pre class="calibre28"><code class="calibre23">using BigOnes = long int;</code></pre>
<p class="calibre13">You write the type alias on the left of the = and the original type on the right. The effect of this statement is identical to using <code class="calibre23">typedef</code>. I use this form in subsequent examples but <code class="calibre23">typedef</code> is just as good.</p>
<p class="calibre13">A type alias is only a synonym for an existing type so it may appear to be a bit superficial, but it isn’t. You’ll see later that it fulfills a very useful role in simplifying complex declarations by defining a simple name for a more convoluted type specification. This can make your code more readable.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-247" class="calibre3"></a>BASIC INPUT/OUTPUT OPERATIONS</h2>
<p class="calibre13">Here, you will only look at enough of input and output to get you through learning about C++. It’s not that it’s difficult &mdash; quite the opposite, in fact &mdash; but for Windows programming, you won’t need it at all. C++ input/output incorporates the notion of a <i class="calibre15">data stream</i>. You can insert data into an output stream or extract data from an input stream. You have already seen that the standard output stream to the command line is referred to as <code class="calibre23">cout</code>. The complementary input stream from the keyboard is <code class="calibre23">cin</code>. Of course, both names are defined in the <code class="calibre23">std</code> namespace.</p>
<section class="toclist">
<h3 class="calibre21">Input from the Keyboard</h3>
<p class="calibre13">You obtain input from the keyboard through the standard input stream, <code class="calibre23">cin</code>, using the extraction operator for a stream, <code class="calibre23">&gt;&gt;</code>. To read integer values from the keyboard into integer variables <code class="calibre23">num1</code> and <code class="calibre23">num2</code>, you can write this statement:</p>
<pre class="calibre28"><code class="calibre23">std::cin &gt;&gt; num1 &gt;&gt; num2;</code></pre>
<p class="calibre13">The <i class="calibre15">extraction operator</i>, <code class="calibre23">&gt;&gt;</code>, “points” in the direction that data flows &mdash; in this case, from <code class="calibre23">cin</code> to each of the two variables in turn. The types of the variables storing the input determines the type of data that is expected. Any leading whitespace in the input is skipped, and the first integer value you enter is read into <code class="calibre23">num1</code>. This is because the input statement executes from left to right. Any whitespace following <code class="calibre23">num1</code> is ignored, and the second integer value you enter is stored in <code class="calibre23">num2</code>. There has to be whitespace between successive values so that they can be differentiated. The stream input operation ends when you press the Enter key, and execution then continues with the next statement. Of course, errors can arise if you key in the wrong data, but I will assume that you always get it right!</p>
<p class="calibre13">Floating-point values are read in exactly the same way as integers, and of course, you can mix the two. The stream input and operations automatically deal with variables and data of any of the fundamental types. For example:</p>
<pre class="calibre28"><code class="calibre23">int num1 {}, num2 {};
double factor {};
std::cin &gt;&gt; num1 &gt;&gt; factor &gt;&gt; num2;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="48" id="calibre_link-510" class="calibre14"></span>The last line reads an integer into <code class="calibre23">num1</code>, then a floating-point value into <code class="calibre23">factor</code>, and finally, an integer into <code class="calibre23">num2</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Output to the Command Line</h3>
<p class="calibre13">You have already seen output to the command line, but I’ll revisit it anyway. Output operates in a complementary fashion to input. The standard output stream is <code class="calibre23">std::cout</code>, and you use the insertion operator, <code class="calibre23">&lt;&lt;</code>, to transfer data to it. This operator also “points” in the direction of data movement. You have already used this operator to output a text string. I can demonstrate outputting the value of a variable with a simple program.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Output to the Command Line</h3>
<p class="calibre20">I’ll assume that you’ve got the hang of creating a new empty project by adding a new source file to the project and building it into an executable. Here’s the code that you need to put in the source file once you have created the <code class="calibre23">Ex2_02</code> project:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_02.cpp
// Exercising output
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
int main()
{
   int num1 {1234}, num2 {5678};
   cout &lt;&lt; endl;                                // Start on a new line
   cout &lt;&lt; num1 &lt;&lt; num2;                        // Output two values
   cout &lt;&lt; endl;                                // End on a new line
   return 0;                                    // Exit program
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You have <code class="calibre23">using</code> declarations for <code class="calibre23">std::cout</code> and <code class="calibre23">std::endl</code> so you can use the unqualified names in the code. The first statement in <code class="calibre23">main()</code> declares and initializes two integer variables, <code class="calibre23">num1</code> and <code class="calibre23">num2</code>. This is followed by three output statements, the first of which moves the screen cursor position to a new line. Because output statements execute from left to right, the second output statement displays the value of <code class="calibre23">num1</code> followed by the value of <code class="calibre23">num2</code>.</p>
<p class="calibre20">When you compile and execute this, you will get the output:</p>
<pre class="calibre28"><code class="calibre23">12345678</code></pre>
<p class="calibre20">The output is correct, but it’s not exactly helpful. You really need the two output values to be separated by at least one space. The default for stream output is to just output the value, which doesn’t provide for spacing successive values so they can be differentiated. As it is, you have no way to tell where the first number ends and the second number begins.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="49" id="calibre_link-511" class="calibre24"></span>Formatting the Output</h3>
<p class="calibre13">You can fix the problem quite easily by outputting a space between the two values. You can do this by replacing the following line in your original program:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; num1 &lt;&lt; num2;                        // Output two values</code></pre>
<p class="calibre13">Just substitute the statement:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; num1 &lt;&lt; ' ' &lt;&lt; num2;                 // Output two values</code></pre>
<p class="calibre13">If you had several rows of output that you wanted to align in columns, you would need some extra capability because you do not know how many digits there will be in each value. You can take care of this by using a <i class="calibre15">manipulator</i>, which modifies the way in which output to (or input from) a stream is handled.</p>
<p class="calibre13">Manipulators are defined in the header file <code class="calibre23">iomanip</code>, so you need an <code class="calibre23">#include</code> directive for it. The manipulator that you’ll use is <code class="calibre23">std::setw(n)</code>, which <b class="calibre12">set</b>s the output field <b class="calibre12">w</b>idth as <code class="calibre23">n</code> characters for the next output value, and the output will be right-justified. Thus <code class="calibre23">std::setw(6)</code> causes the next output value to be presented in a field with a width of six spaces. Let’s see it working.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Manipulators</h3>
<p class="calibre20">To get something more like the output you want, you can change the program to the following:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex2_03.cpp</b>
// Exercising output
#include &lt;iostream&gt;
<b class="calibre12">#include &lt;iomanip&gt;</b>
        
using std::cout;
using std::endl;
<b class="calibre12">using std::setw;</b>
        
int main()
{
   int num1 {1234}, num2 {5678};
   cout &lt;&lt; endl;                                // Start on a new line
   <b class="calibre12">cout &lt;&lt; setw(6) &lt;&lt; num1 &lt;&lt; setw(6) &lt;&lt; num2;  // Output two values</b>
   cout &lt;&lt; endl;                                // Start on a new line
   return 0;                                    // Exit program
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The changes from <code class="calibre23">Ex2_02.cpp</code> are the addition of the <code class="calibre23">#include</code> directive for the <code class="calibre23">iomanip</code> header, the addition of a <code class="calibre23">using</code> declaration for the <code class="calibre23">setw</code> name in the <code class="calibre23">std</code> namespace, and the insertion of the <code class="calibre23">setw()</code> manipulator in the output stream preceding each value. Now you get nice, neat output:</p>
<pre class="calibre28"><code class="calibre23">   1234  5678</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="50" id="calibre_link-512" class="calibre14"></span>Note that the <code class="calibre23">setw()</code> manipulator applies only for the next single output value after its insertion into the stream. Subsequent values will be output in the default manner. You must insert the manipulator into the stream immediately preceding each value that you want to output within a given field width.</p>
<p class="calibre20">Another useful manipulator in the <code class="calibre23">iomanip</code> header is <code class="calibre23">std::setiosflags</code>. One thing it does is to enable you to have the output left-aligned in a given field width instead of right-aligned by default. Here’s how you can do that:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; std::setiosflags(std::ios::left);</code></pre>
<p class="calibre20"><code class="calibre23">std::ios::left</code> is the flag that is set by the manipulator, which causes output to be left-aligned in a field. You can use <code class="calibre23">std::setiosflags</code> to control the appearance of numerical output in other ways by setting other flags, so it is worth exploring.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Escape Sequences</h3>
<p class="calibre13">When you specify a single character or a character string between double quotes, you specify some characters by special character sequences called <i class="calibre15">escape sequences</i>. They are called escape sequences because they allow characters to be specified that otherwise could not be represented, and they do this by escaping from the default interpretation of the characters. An obvious example of a character you can’t include in a string between double quotes or specify as a single character literal is a newline. Pressing Enter for a newline just moves the cursor to the next line &mdash; the character itself won’t be entered in the code.</p>
<p class="calibre13">An escape sequence starts with a backslash character, <code class="calibre23">\</code>, and the backslash cues the compiler to interpret the character that follows in a special way. For example, a tab character is written as <code class="calibre23">\t</code>, so the <code class="calibre23">t</code> is understood by the compiler to represent a tab, and not the letter t. Look at these two statements:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; endl &lt;&lt; "This is output.";
cout &lt;&lt; endl &lt;&lt; "\tThis is output after a tab.";</code></pre>
<p class="calibre13">They will produce these output lines:</p>
<pre class="calibre28"><code class="calibre23">This is output.
     This is output after a tab.</code></pre>
<p class="calibre13">The <code class="calibre23">\t</code> in the second statement causes the output to be indented to the first tab position. Instead of using <code class="calibre23">endl</code>, you could use the escape sequence for the newline character, <code class="calibre23">\n</code>, in each string, so you could rewrite the statements as:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "\nThis is output.";
cout &lt;&lt; "\n\tThis is output after a tab.";</code></pre>
<p class="calibre13">The output is the same, but note that <code class="calibre23">\n</code> is not quite the same as <code class="calibre23">endl. endl</code> will output a newline and flush the stream, while <code class="calibre23">\n</code> will output the newline without flushing the stream. Flushing an output stream causes all data in the stream buffer in memory to be written to the device.</p>
<p class="calibre13">Here are some escape sequences that may be particularly useful:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="51" id="calibre_link-513" class="calibre14"></span><b class="calibre12">ESCAPE SEQUENCE</b></th>
<th class="calibre32"><b class="calibre12">WHAT IT DOES</b></th>
<th class="calibre32"><b class="calibre12">ESCAPE SEQUENCE</b></th>
<th class="calibre32"><b class="calibre12">WHAT IT DOES</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">\a</code></td>
<td class="calibre32">Sounds a beep</td>
<td class="calibre32"><code class="calibre23">\b</code></td>
<td class="calibre32">Backspace</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">\n</code></td>
<td class="calibre32">Newline</td>
<td class="calibre32"><code class="calibre23">\t</code></td>
<td class="calibre32">Tab</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">\'</code></td>
<td class="calibre32">Single quote</td>
<td class="calibre32"><code class="calibre23">\"</code></td>
<td class="calibre32">Double quote</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">\\</code></td>
<td class="calibre32">Backslash</td>
<td class="calibre32"><code class="calibre23">\?</code></td>
<td class="calibre32">Question mark</td>
</tr>
</tbody>
</table>
<p class="calibre13">Obviously, if you want to be able to include a backslash or a double quote as a character in a string, you must use the appropriate escape sequences to represent them. Otherwise, the backslash would be interpreted as the start of another escape sequence, and the double quote would indicate the end of the character string. Similarly, to define a single quote character literal you must use <code class="calibre23">'\''</code>.</p>
<p class="calibre13">Of course, you can use escape sequences in the initialization of variables of type <code class="calibre23">char</code>. For example:</p>
<pre class="calibre28"><code class="calibre23">char Tab {'\t'};               // Initialize with tab character</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can put a question mark in a string or a character literal. The <code class="calibre23">\?</code> escape sequence is there to avoid conflicts with trigraphs, which are a C language construct consisting of three characters that begin with</i> <code class="calibre23">??</code>. <i class="calibre15">Trigraphs are for defining characters in environments that have a limited character set where the characters otherwise could not be specified. Trigraphs are rarely used today, but they are still part of the language standard.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Escape Sequences</h3>
<p class="calibre20">Here’s a program that uses some of the escape sequences from the table in the previous section:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_04.cpp
// Using escape sequences
#include &lt;iostream&gt;
        
using std::cout;
        
int main()
{
   char newline {'\n'};                         // Newline escape sequence
   cout &lt;&lt; newline;                             // Start on a new line
   cout &lt;&lt; "\"We\'ll make our escapes in sequence\", he said.";
   cout &lt;&lt; "\n\tThe program\'s over, it\'s time to make a beep beep.\a\a";
   cout &lt;&lt; newline;                             // Start on a new line
   return 0;                                    // Exit program
}</code></pre>
<p class="calibre20">If you compile and execute this example, it will produce the following output:</p>
<pre class="calibre28"><code class="calibre23">"We'll make our escapes in sequence", he said.
        The program's over, it's time to make a beep beep.</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="52" id="calibre_link-514" class="calibre14"></span>How It Works</h4>
<p class="calibre20">The first line in <code class="calibre23">main()</code> defines <code class="calibre23">newline</code> as type <code class="calibre23">char</code> and initializes it with the escape sequence for a newline. You can then use <code class="calibre23">newline</code> instead of <code class="calibre23">endl</code> from the standard library.</p>
<p class="calibre20">After writing <code class="calibre23">newline</code> to <code class="calibre23">cout</code>, you output a string that uses the escape sequences for a double quote (<code class="calibre23">\"</code>) and a single quote (<code class="calibre23">\'</code>). You don’t have to use the escape sequence for a single quote here because the string is delimited by double quotes, and the compiler will recognize a single quote character as just that, and not a delimiter. You must use the escape sequence for the double quote in a string though. The second string starts with a newline then a tab, so the output is indented by the tab distance. The string ends with two instances of the escape sequence for a beep, so you should hear a beep from the PC.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-248" class="calibre3"></a>CALCULATING IN C++</h2>
<p class="calibre13">This is where you start doing something with the data that you enter. You know how to carry out simple input and output; now, you’ll be coding the bit in the middle, the “processing” part of a program. Almost all of the computational aspects of C++ are intuitive, so you should slice through this like a hot knife through butter.</p>
<section class="toclist">
<h3 class="calibre21">The Assignment Statement</h3>
<p class="calibre13">You have already seen examples of the assignment statement. A typical assignment statement looks like this:</p>
<pre class="calibre28"><code class="calibre23">whole = part1 + part2 + part3;</code></pre>
<p class="calibre13">The assignment statement calculates the value of the expression that appears on the right of the assignment operator, <code class="calibre23">=</code> &mdash; in this case the sum of <code class="calibre23">part1, part2</code>, and <code class="calibre23">part3</code> &mdash; and stores the result in the variable specified on the left, the variable with the name <code class="calibre23">whole</code>. In this statement, the <code class="calibre23">whole</code> is exactly the sum of its parts, and no more.</p>
<p class="calibre13">You can also write repeated assignments, such as:</p>
<pre class="calibre28"><code class="calibre23">a = b = 2;</code></pre>
<p class="calibre13">This is equivalent to assigning the value 2 to <code class="calibre23">b</code> and then assigning the value of <code class="calibre23">b</code> to <code class="calibre23">a</code>, so both variables end up with the value 2.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Arithmetic Operations</h3>
<p class="calibre13">The basic arithmetic operators are addition, subtraction, multiplication, and division, represented by the operators <code class="calibre23">+, -, *</code>, and <code class="calibre23">/</code>, respectively. Generally, these work as you would expect, with the exception of division, which has a slight aberration when applied to integers, as you’ll see. Look at this:</p>
<pre class="calibre28"><code class="calibre23">netPay = hours * rate - deductions;</code></pre>
<p class="calibre13">Here, the product of <code class="calibre23">hours</code> and <code class="calibre23">rate</code> will be calculated and then <code class="calibre23">deductions</code> subtracted from the value produced. Multiply and divide operations are executed before addition and subtraction, as you would expect. I discuss the order of execution of operators in expressions later in this chapter. The <span {http://www.idpf.org/2007/ops}type="pagebreak" title="53" id="calibre_link-515" class="calibre14"></span>overall result of evaluating the expression <code class="calibre23">hours * rate - deductions</code> will be stored in the variable <code class="calibre23">netPay</code>.</p>
<p class="calibre13">The minus sign used in the last statement has two operands &mdash; it subtracts the value of its right operand from the value of its left operand. This is called a <i class="calibre15">binary operation</i> because two values are involved. The minus sign can also be used with one operand to change the sign of a value to which it is applied, in which case it is called a <i class="calibre15">unary minus</i>. You could write this:</p>
<pre class="calibre28"><code class="calibre23">int a {};
int b {-5};
a = -b;                        // Changes the sign of the operand so a is 5</code></pre>
<p class="calibre13">Here, <code class="calibre23">a</code> will be assigned the value +5 because the unary minus in the expression on the right changes the sign of the value of the operand <code class="calibre23">b</code>.</p>
<p class="calibre13">An assignment is not the equivalent of the equations you saw in high-school algebra. It specifies an action to be carried out rather than a statement of fact. The expression to the right of the assignment operator is evaluated and the result is stored in the location specified on the left.</p>
<p class="calibre13">Look at this statement:</p>
<pre class="calibre28"><code class="calibre23">number = number + 1;</code></pre>
<p class="calibre13">This means “add 1 to the current value stored in <code class="calibre23">number</code> and then store the result back in <code class="calibre23">number</code>.” As a normal algebraic statement, it wouldn’t make sense, but as a programming action, it obviously does.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Typically, the expression on the left of an assignment is a single variable name but it doesn’t have to be. It can be an expression of some kind but if it is an expression then the result of evaluating it must be an lvalue. An lvalue, as you will see later, is a persistent location in memory where the result of the expression to the right of the assignment operator can be stored.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Exercising Basic Arithmetic</h3>
<p class="calibre20">You can exercise basic arithmetic by calculating how many standard rolls of wallpaper are needed to paper a room. The following example does this:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_05.cpp
// Calculating how many rolls of wallpaper are required for a room
#include &lt;iostream&gt;
        
using std::cout;
using std::cin;
using std::endl;
        
int main()
{
   double height {}, width {}, length {};          // Room dimensions
   double perimeter {};                            // Room perimeter
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="54" id="calibre_link-516" class="calibre14"></span>   const double rollWidth {21.0};                  // Standard roll width
   const double rollLength {12.0*33.0};            // Standard roll length(33ft.)
        
   int strips_per_roll {};                         // Number of strips in a roll
   int strips_reqd {};                             // Number of strips needed
   int nrolls {};                                  // Total number of rolls
        
   cout &lt;&lt; endl                                    // Start a new line
        &lt;&lt; "Enter the height of the room in inches: ";
   cin &gt;&gt; height;
        
   cout  &lt;&lt; endl                                   // Start a new line
         &lt;&lt; "Now enter the length and width in inches: ";
   cin &gt;&gt; length &gt;&gt; width;
        
   strips_per_roll = rollLength / height;          // Get number of strips per roll
   perimeter = 2.0*(length + width);               // Calculate room perimeter
   strips_reqd = perimeter / rollWidth;            // Get total strips required
   nrolls = strips_reqd / strips_per_roll;         // Calculate number of rolls
        
   cout &lt;&lt; endl
        &lt;&lt; "For your room you need " &lt;&lt; nrolls &lt;&lt; " rolls of wallpaper."
        &lt;&lt; endl;
        
   return 0;
}</code></pre>
<p class="calibre20">Unless you are more adept than I am at typing, chances are there will be a few errors when you compile this for the first time. Once you have fixed the typos, it will compile and run just fine. You’ll get a couple of warning messages from the compiler. Don’t worry about them &mdash; the compiler is just making sure you understand what’s going on. I’ll explain the reason for the warnings.</p>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">One thing needs to be clear at the outset &mdash; I assume no responsibility if you run out of wallpaper as a result of using this program! As you’ll see, all errors in the estimate of the number of rolls required are due to the way C++ works and to the wastage that inevitably occurs when you hang your own wallpaper &mdash; usually 50 percent plus!</p>
<p class="calibre20">I’ll work through the statements in sequence, picking out the interesting, novel, or even exciting features. The statements down to the start of the body of <code class="calibre23">main()</code> are familiar territory by now, so I will take those for granted.</p>
<p class="calibre20">A couple of general points about the layout of the code are worth noting. First, the statements in <code class="calibre23">main()</code> are indented to make the extent of the body easier to see, and second, sets of statements are separated by a blank line to indicate that they are functional groups. Indenting statements is a fundamental technique in laying out C++ code. You will see that this is applied universally to provide visual cues to the logical blocks in a program.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="55" id="calibre_link-517" class="calibre14"></span>The const Modifier</h4>
<p class="calibre13">You have a block of declarations for the variables used in the program at the beginning of <code class="calibre23">main()</code>. These are familiar, but two contain new features:</p>
<pre class="calibre28"><code class="calibre23">const double rollWidth {21.0};                   // Standard roll width
const double rollLength {12.0*33.0};             // Standard roll length(33ft.)</code></pre>
<p class="calibre13">They both start out with a new keyword: <code class="calibre23">const</code>. This is a <i class="calibre15">type modifier</i> that indicates that the variables are not just of type <code class="calibre23">double</code>, but are also constants. Because you tell the compiler that these are constants, the compiler will check for any statements that attempt to change the values of these variables, and if it finds any, it will generate an error message. You could check this out by adding this statement anywhere after the declaration of <code class="calibre23">rollWidth</code>:</p>
<pre class="calibre28"><code class="calibre23">rollWidth = 0;</code></pre>
<p class="calibre13">Now the program no longer compiles, and you’ll see the message:</p>
<pre class="calibre28"><code class="calibre23">'error C3892: 'rollWidth' : you cannot assign to a variable that is const'.</code></pre>
<p class="calibre13">It is very useful to define constants as <code class="calibre23">const</code> variables, particularly when you use the same constant several times in a program. For one thing, it is much better than sprinkling literals throughout your program that may not have blindingly obvious meanings; the value 42 could be referring to the meaning of life, the universe, and everything, but if you use a <code class="calibre23">const</code> variable with the name <code class="calibre23">myAge</code> that has a value of 42, it becomes obvious that you are not. For another thing, if you change the initial value of a <code class="calibre23">const</code> variable, the change will take effect everywhere in a source file. If you use explicit literals, you have to change all occurrences individually.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Constant Expressions</h4>
<p class="calibre13">The <code class="calibre23">const</code> variable <code class="calibre23">rollLength</code> is initialized with an arithmetic expression (<code class="calibre23">12.0*33.0</code>). Being able to use constant expressions to initialize variables saves having to work out the value yourself. It can also be more meaningful, as in this case, because 33 feet times 12 inches is a much clearer expression of what the value represents than simply writing 396. The compiler will evaluate constant expressions accurately, whereas if you do it, depending on the complexity of the expression and your ability to number-crunch, there is a finite probability that it may be wrong.</p>
<p class="calibre13">You can use any expression that can be evaluated as a constant at compile time, including <code class="calibre23">const</code> variables that you have already defined. So, for instance, if it were useful in the program to do so, you could declare the area of a standard roll of wallpaper as:</p>
<pre class="calibre28"><code class="calibre23">const double rollArea {rollWidth*rollLength};</code></pre>
<p class="calibre13">This statement would need to be placed after the declarations for the two <code class="calibre23">const</code> variables used in the initialization of <code class="calibre23">rollArea</code>, because all the variables that appear in a constant expression must be known to the compiler at the point where the constant expression appears.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="56" id="calibre_link-518" class="calibre14"></span>Program Input</h4>
<p class="calibre13">After declaring some integer variables, the next four statements in the program handle input from the keyboard:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; endl                                     // Start a new line
     &lt;&lt; "Enter the height of the room in inches: ";
cin &gt;&gt; height;
        
cout &lt;&lt; endl                                      // Start a new line
     &lt;&lt; "Now enter the length and width in inches: ";
cin &gt;&gt; length &gt;&gt; width;</code></pre>
<p class="calibre13">You write text to <code class="calibre23">cout</code> to prompt for the input required, and then read the input from the keyboard using <code class="calibre23">cin</code>, the standard input stream. You first obtain the value for <code class="calibre23">height</code> and then read <code class="calibre23">length</code> and <code class="calibre23">width</code>, successively. In a practical program, you would need to check for errors and possibly make sure that the input values are sensible, but you don’t have enough knowledge to do that yet!</p>
</section>
<section class="toclist">
<h4 class="calibre22">Calculating the Result</h4>
<p class="calibre13">You have four statements involved in calculating the number of standard rolls of wallpaper required for the size of the room:</p>
<pre class="calibre28"><code class="calibre23">strips_per_roll = rollLength / height;    // Get number of strips in a roll
perimeter = 2.0*(length + width);         // Calculate room perimeter
strips_reqd = perimeter / rollWidth;      // Get total strips required
nrolls = strips_reqd / strips_per_roll;   // Calculate number of rolls</code></pre>
<p class="calibre13">The first statement calculates the number of strips of paper with a length corresponding to the height of the room that you can get from a standard roll, by dividing one into the other. So, if the room is 8 feet high, you divide 96 into 396, which would produce the floating-point result 4.125. There is a subtlety here. The variable where you store the result, <code class="calibre23">strips_per_roll</code>, is type <code class="calibre23">int</code>, so it can store only integers. Any floating-point value that is to be stored as an integer is rounded down to the nearest integer, 4 in this case, and this value is stored. This is actually the result you want here because, although they may fit under a window or over a door, fractions of a strip are best ignored when estimating.</p>
<p class="calibre13">The conversion of a value from one type to another is called <i class="calibre15">type conversion</i>. This particular example is an <i class="calibre15">implicit type conversion</i>, because the code doesn’t explicitly state that a conversion is needed, and the compiler has to supply it. The two warnings you got during compilation were because information could be lost as a result of the implicit conversions that were inserted to change values from one type to another.</p>
<p class="calibre13">You should beware when your code necessitates implicit conversions. Compilers do not always supply a warning that an implicit conversion is being made, and if you are assigning a value of one type to a variable of a type with a lesser range of values, there is a danger that you will lose information. If there are implicit conversions in your program that you have included accidentally, they may represent bugs that may be difficult to locate.</p>
<p class="calibre13">Where a conversion that may result in the loss of information is unavoidable, you should specify the conversion explicitly to demonstrate that it is no accident. You do this by making an <i class="calibre15">explicit type conversion</i> or <i class="calibre15">cast</i> of the value on the right of the assignment to <code class="calibre23">int</code>, so the statement would become:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="57" id="calibre_link-519" class="calibre14"></span>strips_per_roll = static_cast&lt;int&gt;(rollLength / height);   // Get number
                                                           // of strips in
                                                           // a roll</code></pre>
<p class="calibre13">The addition of <code class="calibre23">static_cast&lt;int&gt;</code> with the parentheses around the expression on the right tells the compiler that you want to convert the value of the expression between the parentheses to the type between the angled brackets, <code class="calibre23">int</code>. Although you still lose the fractional part of the value, the compiler assumes that you know what you are doing and will not issue a warning. You’ll see more about <code class="calibre23">static_cast&lt;&gt;()</code> and other type conversions later in this chapter.</p>
<p class="calibre13">Note how you calculate the perimeter of the room in the next statement. To multiply the sum of the <code class="calibre23">length</code> and the <code class="calibre23">width</code> by 2.0, you enclose the expression summing the two variables between parentheses. The parentheses ensure that the addition is performed first and the result is multiplied by 2.0 to produce the value for the perimeter. You can use parentheses to make sure that a calculation is carried out in the order you require because expressions in parentheses are always evaluated first. Where there are nested parentheses, the expressions within the parentheses are evaluated in sequence, from the innermost to the outermost.</p>
<p class="calibre13">The third statement that calculates how many strips of paper are required to cover the room uses the same effect that you saw in the first statement: the result is rounded down to the nearest integer because it is stored in the integer variable, <code class="calibre23">strips_reqd</code>. This is not what you need in practice. It would be best to round up for estimating, but you don’t have enough knowledge to do this yet. Once you have read the next chapter, you can come back and fix it!</p>
<p class="calibre13">The last arithmetic statement calculates the number of rolls needed by dividing the number of strips required (an integer) by the number of strips in a roll (also an integer). Because you are dividing one integer by another, the result has to be an integer, and any remainder is ignored. This would still be the case if the <code class="calibre23">nrolls</code> was floating-point; the integer value resulting from the expression would be converted to floating-point form before it was stored in <code class="calibre23">nrolls</code>. The result that you obtain is essentially the same as if you had produced a floating-point result and rounded down to the nearest integer. Again, this is not what you want, so if you want to use this, you will need to fix it.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Displaying the Result</h4>
<p class="calibre13">The following statement displays the result of the calculation:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; endl
     &lt;&lt; "For your room you need " &lt;&lt; nrolls &lt;&lt; " rolls of wallpaper."
     &lt;&lt; endl;</code></pre>
<p class="calibre13">This is a single output statement spread over three lines. It first outputs a newline character and then the text string <code class="calibre23">"For your room you need"</code>. This is followed by the value of the variable <code class="calibre23">nrolls</code> and, finally, the text string <code class="calibre23">" rolls of wallpaper."</code>. As you see, output statements are very easy. You could have written the statement using escape characters for the newlines:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "\nFor your room you need " &lt;&lt; nrolls &lt;&lt; " rolls of wallpaper.\n";</code></pre>
<p class="calibre13">Finally, the program ends when this statement is executed:</p>
<pre class="calibre28"><code class="calibre23">   return 0;</code></pre>
<p class="calibre13">The value zero here is a return value that will be returned to the operating system. You will learn more about return values in Chapter 5.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="58" id="calibre_link-520" class="calibre24"></span>Calculating a Remainder</h3>
<p class="calibre13">You saw that dividing one integer value by another produces an integer result that ignores any remainder, so 11 divided by 4 gives the result 2. Because the remainder after division can be of great interest, particularly when you are dividing cookies amongst children for example, C++ provides a special operator, <code class="calibre23">%</code>, for this. The following statements handle the cookie-sharing problem:</p>
<pre class="calibre28"><code class="calibre23">int residue {}, cookies {19}, children {5};
residue = cookies % children;</code></pre>
<p class="calibre13"><code class="calibre23">residue</code> will end up with the value 4, which is the number left after dividing 19 by 5. To calculate how many cookies each child receives, you just use division, as in the statement:</p>
<pre class="calibre28"><code class="calibre23">each = cookies / children;</code></pre>
</section>
<section class="toclist">
<h3 class="calibre21">Modifying a Variable</h3>
<p class="calibre13">It’s often necessary to modify the current value of a variable by incrementing it or doubling it. You could increment <code class="calibre23">count</code> using the statement:</p>
<pre class="calibre28"><code class="calibre23">count = count + 5;</code></pre>
<p class="calibre13">This adds 5 to the current value of <code class="calibre23">count</code> and stores the result back in <code class="calibre23">count</code>, so if <code class="calibre23">count</code> started out as 10, it would end up as 15.</p>
<p class="calibre13">You have an alternative, shorthand way of writing the same thing:</p>
<pre class="calibre28"><code class="calibre23">count += 5;</code></pre>
<p class="calibre13">This says, “Take the value in <code class="calibre23">count</code>, add 5 to it, and store the result back in <code class="calibre23">count</code>.” You can use other operators with this notation:</p>
<pre class="calibre28"><code class="calibre23">count *= 5;</code></pre>
<p class="calibre13">This multiplies the current value of <code class="calibre23">count</code> by 5 and stores the result back in <code class="calibre23">count</code>. In general, you can write statements of the form:</p>
<pre class="calibre28"><code class="calibre23">lhs op=  rhs;</code></pre>
<p class="calibre13"><code class="calibre23"><i class="calibre15">lhs</i></code> stands for any legal expression for the left-hand side of the statement and is usually (but not necessarily) a variable name.</p>
<p class="calibre13"><code class="calibre23"><i class="calibre15">rhs</i></code> stands for any legal expression on the right-hand side of the statement.</p>
<p class="calibre13"><code class="calibre23"><i class="calibre15">op</i></code> is any of the following operators:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">+</code></td>
<td class="calibre32"><code class="calibre23">−</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">*</code></td>
<td class="calibre32"><code class="calibre23">/</code></td>
<td class="calibre32"><code class="calibre23">%</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&lt;&lt;</code></td>
<td class="calibre32"><code class="calibre23">&gt;&gt;</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&amp;</code></td>
<td class="calibre32"><code class="calibre23">^</code></td>
<td class="calibre32"><code class="calibre23">|</code></td>
</tr>
</tbody>
</table>
<p class="calibre13">You have already met the first five of these operators, and you’ll see the others, which are the shift and logical operators, later in this chapter.</p>
<p class="calibre13">The general form of the statement is equivalent to this:</p>
<pre class="calibre28"><code class="calibre23">lhs = lhs op (rhs);</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="59" id="calibre_link-521" class="calibre14"></span>The parentheses around <code class="calibre23">rhs</code> imply that this expression is always evaluated first, and the result becomes the right operand for <code class="calibre23">op</code>.</p>
<p class="calibre13">This means that you can write statements such as:</p>
<pre class="calibre28"><code class="calibre23">a /= b + c;</code></pre>
<p class="calibre13">This will be identical in effect to this statement:</p>
<pre class="calibre28"><code class="calibre23">a = a/(b + c);</code></pre>
<p class="calibre13">The value of <code class="calibre23">a</code> is divided by the sum of <code class="calibre23">b</code> and <code class="calibre23">c</code>, and the result is stored back in <code class="calibre23">a</code>, overwriting the original value.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Increment and Decrement Operators</h3>
<p class="calibre13">I’ll now introduce some unusual arithmetic operators called the <i class="calibre15">increment</i> and <i class="calibre15">decrement operators</i>. You will find them to be quite an asset once you get further into applying C++. These are unary operators that you use to increment or decrement a value stored in a variable by 1. For example, assuming <code class="calibre23">count</code> is of type <code class="calibre23">int</code>, the following three statements all have exactly the same effect:</p>
<pre class="calibre28"><code class="calibre23">count = count + 1;      count += 1;      ++count;</code></pre>
<p class="calibre13">They each increment <code class="calibre23">count</code> by 1. The last statement uses the increment operator and is clearly the most concise.</p>
<p class="calibre13">The increment operator not only changes the value of the variable to which you apply it, but also results in a value. Thus, using the increment operator to increase the value of a variable by 1 can also appear as part of a more complex expression. The expression <code class="calibre23">++count</code> increments the value of the variable and the value that results is the value of the expression. For example, suppose <code class="calibre23">count</code> has the value 5, and you have defined <code class="calibre23">total</code> as type <code class="calibre23">int</code>. Suppose you write the following statement:</p>
<pre class="calibre28"><code class="calibre23">total = ++count + 10;</code></pre>
<p class="calibre13">This increments <code class="calibre23">count</code> to 6. The expression <code class="calibre23">++count</code> has the resultant value of <code class="calibre23">count</code>, 6, which is added to 10 so <code class="calibre23">total</code> is assigned the value 16.</p>
<p class="calibre13">So far you have written the increment operator, <code class="calibre23">++</code>, in front of the variable to which it applies. This is called the <i class="calibre15">prefix</i> form of the operator. The operator also has a <i class="calibre15">postfix</i> form, where you write the operator <i class="calibre15">after</i> the variable to which it applies and the effect is slightly different. The variable is incremented only <i class="calibre15">after</i> its value has been used in context. For example:</p>
<pre class="calibre28"><code class="calibre23">total = count++ + 10;</code></pre>
<p class="calibre13">If <code class="calibre23">count</code> has the value 5, <code class="calibre23">total</code> is assigned the value 15, because the initial value of <code class="calibre23">count</code> is used to evaluate the expression before the increment is applied. The preceding statement is equivalent to the two statements:</p>
<pre class="calibre28"><code class="calibre23">total = count + 10;
++count;</code></pre>
<p class="calibre13">The clustering of <code class="calibre23">+</code> signs in the preceding example of the postfix form is likely to lead to confusion. Generally, it isn’t a good idea to write the increment operator in the way that I have written it here. It would be clearer to write:</p>
<pre class="calibre28"><code class="calibre23">total = 6 + count++;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="60" id="calibre_link-522" class="calibre14"></span>Alternatively you could put parentheses around <code class="calibre23">count++</code>. Where you have an expression such as <code class="calibre23">a++ + b</code>, or even <code class="calibre23">a+++b</code>, it becomes less obvious what is meant or what the compiler will do. They are actually the same, but in the second case, you might really have meant <code class="calibre23">a + ++b</code>, which is different. It evaluates to one more than the other two expressions.</p>
<p class="calibre13">The rules I have discussed in relation to the increment operator also apply to the decrement operator, <code class="calibre23">--</code>. For example, if <code class="calibre23">count</code> has the initial value 5, then the statement,</p>
<pre class="calibre28"><code class="calibre23">total = --count + 10;</code></pre>
<p class="calibre13">results in <code class="calibre23">total</code> having the value 14 assigned, whereas,</p>
<pre class="calibre28"><code class="calibre23">total = 10 + count--;</code></pre>
<p class="calibre13">sets the value of <code class="calibre23">total</code> to 15. Both operators are usually applied to integers, particularly in the context of loops, as you will see in Chapter 3, but you can also use them with floating-point variables. You will see in later chapters that they can also be applied to other data types, notably variables that store addresses.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: The Comma Operator</h3>
<p class="calibre20">The comma operator allows you to specify several expressions where normally only one might occur. This is best understood by looking at an example that demonstrates how it works:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_06.cpp
// Exercising the comma operator
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
int main()
{
   long num1 {}, num2 {}, num3 {}, num4 {};
        
   num4 = (num1 = 10L, num2 = 20L, num3 = 30L);
   cout &lt;&lt; endl
        &lt;&lt; "The value of a series of expressions "
        &lt;&lt; "is the value of the rightmost: "
        &lt;&lt; num4;
   cout &lt;&lt; endl;
        
   return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">If you compile and run this program you will get this output:</p>
<pre class="calibre28"><code class="calibre23">The value of a series of expressions is the value of the rightmost: 30</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="61" id="calibre_link-523" class="calibre14"></span>This is fairly self-explanatory. The first statement in <code class="calibre23">main()</code> creates four variables, <code class="calibre23">num1</code> through <code class="calibre23">num4</code>, and initializes them to zero. The variable <code class="calibre23">num4</code> receives the value of the last of the series of three assignments, the value of an assignment operation being the value assigned to the left-hand side. The parentheses in the assignment for <code class="calibre23">num4</code> are essential. You could try executing this without them to see the effect. Without the parentheses, the first expression in the series of expressions separated by commas in the series will become:</p>
<pre class="calibre28"><code class="calibre23">num4 = num1 = 10L</code></pre>
<p class="calibre20">So, <code class="calibre23">num4</code> will have the value <code class="calibre23">10L</code>.</p>
<p class="calibre20">Of course, expressions separated by the comma operator don’t have to be assignments. You could equally well write the following:</p>
<pre class="calibre28"><code class="calibre23">long num1 {1L}, num2 {10L}, num3 {100L}, num4 {};
num4 = (++num1, ++num2, ++num3);</code></pre>
<p class="calibre20">The effect of the assignment statement will be to increment the variables <code class="calibre23">num1, num2</code>, and <code class="calibre23">num3</code> by 1, and to set <code class="calibre23">num4</code> to the value of the last expression, which will be 101L. This example is aimed at illustrating the effect of the comma operator and is not an example of how to write good code.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The Sequence of Calculation</h3>
<p class="calibre13">So far, I haven’t talked about how you arrive at the sequence of calculations involved in evaluating an expression. It corresponds to what you have learned at school when dealing with basic arithmetic operators, but there are many other operators in C++. To understand what happens with these, you need to look at the mechanism used in C++ to determine this sequence. It’s referred to as <i class="calibre15">operator precedence</i>.</p>
<section class="toclist">
<h4 class="calibre22">Operator Precedence</h4>
<p class="calibre13">Operator precedence orders the operators in a priority sequence. In any expression, operators with the highest precedence are executed first, followed by operators with the next highest precedence, and so on, down to those with the lowest precedence. The precedence of the operators  is as follows:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">PRECEDENCE</b></th>
<th class="calibre32"><b class="calibre12">OPERATORS</b></th>
<th class="calibre32"><b class="calibre12">ASSOCIATIVITY</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">1</code></td>
<td class="calibre32"><code class="calibre23">::</code></td>
<td class="calibre32">None</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">2</code></td>
<td class="calibre32"><code class="calibre23">()   []   -&gt;   .</code><br class="calibre10" />postfix <code class="calibre23">++</code> postfix <code class="calibre23">--</code><br class="calibre10" /><code class="calibre23">typeid</code><br class="calibre10" /><code class="calibre23">const_cast dynamic_cast static_cast reinterpret_cast</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="62" id="calibre_link-524" class="calibre14"></span><code class="calibre23">3</code></td>
<td class="calibre32">logical not <code class="calibre23">!</code> one’s complement <code class="calibre23">~</code><br class="calibre10" />unary <code class="calibre23">+</code>   unary <code class="calibre23">-</code><br class="calibre10" />prefix <code class="calibre23">++</code> prefix <code class="calibre23">--</code><br class="calibre10" />address-of <code class="calibre23">&amp;</code>  indirection <code class="calibre23">*</code><br class="calibre10" />type cast <code class="calibre23">(type)</code><br class="calibre10" /><code class="calibre23">sizeof   decltype</code><br class="calibre10" /><code class="calibre23">new   new[]   delete    delete[]</code></td>
<td class="calibre32">Right</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">4</code></td>
<td class="calibre32"><code class="calibre23">.*</code><br class="calibre10" /> <code class="calibre23">-&gt;*</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">5</code></td>
<td class="calibre32"><code class="calibre23">*   /   %</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">6</code></td>
<td class="calibre32"><code class="calibre23">+   -</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">7</code></td>
<td class="calibre32"><code class="calibre23">&lt;&lt; &gt;&gt;</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">8</code></td>
<td class="calibre32"><code class="calibre23">==   !=</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">9</code></td>
<td class="calibre32"><code class="calibre23">&amp;</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">10</code></td>
<td class="calibre32"><code class="calibre23">^</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">11</code></td>
<td class="calibre32"><code class="calibre23">|</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">12</code></td>
<td class="calibre32"><code class="calibre23">&amp;&amp;</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">13</code></td>
<td class="calibre32"><code class="calibre23">||</code></td>
<td class="calibre32">Left</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">14</code></td>
<td class="calibre32"><code class="calibre23">?:</code> (conditional operator)</td>
<td class="calibre32">Right</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">15</code></td>
<td class="calibre32"><code class="calibre23">=  *=  /=  %=  +=  -=  &amp;=  ^=  |=  &lt;&lt;=  &gt;&gt;=</code></td>
<td class="calibre32">Right</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">16</code></td>
<td class="calibre32"><code class="calibre23">throw</code></td>
<td class="calibre32">Right</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">17</code></td>
<td class="calibre32"><code class="calibre23">,</code></td>
<td class="calibre32">Left</td>
</tr>
</tbody>
</table>
<p class="calibre13">There are also <code class="calibre23">const_cast, static_cast, dynamic_cast, reinterpret_cast</code>, and <code class="calibre23">typeid</code>  that are not included in the table because they are never ambiguous. There are a lot of operators here that you haven’t seen yet, but you will know them all by the end of the book. I have introduced all the operators here so that you can refer to the table if you are uncertain about the precedence of one operator relative to another.</p>
<p class="calibre13">Operators with the highest precedence appear at the top of the table. All the operators in the same row have equal precedence. If there are no parentheses in an expression, operators with equal precedence are executed in a sequence determined by their <i class="calibre15">associativity</i>. If the associativity is “left,” the left-most operator in an expression executes first, progressing through the expression to the right-most. This means that an expression such as <code class="calibre23">a+b+c+d</code> is executed as though it was written <code class="calibre23">(((a+b)+c)+d)</code> because binary <code class="calibre23">+</code> is left-associative.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="63" id="calibre_link-525" class="calibre14"></span>Note that where an operator has a unary (working with one operand) and a binary (working with two operands) form, the unary form is always of higher precedence and is therefore executed first.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can always override the precedence of operators by using parentheses. Because there are so many operators, it’s sometimes hard to be sure what takes precedence over what. It’s a good idea to insert parentheses to make sure. A further plus is that parentheses often make the code much easier to read.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-249" class="calibre3"></a>TYPE CONVERSION AND CASTING</h2>
<p class="calibre13">Calculations can be carried out only between values of the same type. When you write an expression involving variables or constants of different types, for each binary operation, the compiler has to arrange to convert the type of one operand to match that of the other. This process is called <i class="calibre15">implicit type conversion</i>. For example, if you add a <code class="calibre23">double</code> value to a value of an integer type, the integer value is converted to <code class="calibre23">double</code> before the addition is carried out. Of course, the variable that contains the value to be converted is, itself, not changed. The compiler stores the converted value in a temporary location and discards it when the calculation is finished.</p>
<p class="calibre13">There are rules that govern the selection of the operand to be converted in any operation. Any expression breaks down into a series of operations between two operands. For example, the expression <code class="calibre23">2*3-4+5</code> amounts to the series <code class="calibre23">2*3</code> resulting in <code class="calibre23">6, 6-4</code> resulting in <code class="calibre23">2</code>, and finally <code class="calibre23">2+5</code> resulting in <code class="calibre23">7</code>. Thus, the rules for converting the type of operands where necessary need to be defined only in terms of decisions about pairs of operands. For any pair of operands of different types, the compiler decides which operand to convert to the other considering types to be in the following rank from high to low:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32">1. <code class="calibre23">long double</code></td>
<td class="calibre32">2. <code class="calibre23">double</code></td>
<td class="calibre32">3. <code class="calibre23">float</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32">4. <code class="calibre23">unsigned long long</code></td>
<td class="calibre32">5. <code class="calibre23">long long</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
<tr class="calibre31">
<td class="calibre32">6. <code class="calibre23">unsigned long</code></td>
<td class="calibre32">7. <code class="calibre23">long</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
<tr class="calibre31">
<td class="calibre32">8. <code class="calibre23">unsigned int</code></td>
<td class="calibre32">9. <code class="calibre23">int</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
</tbody>
</table>
<p class="calibre13">Thus, in an operation where the operands are of type <code class="calibre23">long long</code> and type <code class="calibre23">unsigned int</code>, the latter will be converted to type <code class="calibre23">long long</code>. Any operand of type <code class="calibre23">char, signed char, unsigned char, short</code>, or <code class="calibre23">unsigned short</code> is at least converted to type <code class="calibre23">int</code> before an operation.</p>
<p class="calibre13">Implicit type conversions can produce unexpected results. For example, consider these statements:</p>
<pre class="calibre28"><code class="calibre23">unsigned int a {10u};
signed int b {20};
std::cout &lt;&lt; a - b &lt;&lt; std::endl;</code></pre>
<p class="calibre13">You might expect this code to output -10, but it doesn’t. It outputs 4294967286. This is because the value of <code class="calibre23">b</code> is converted to <code class="calibre23">unsigned int</code> to match the type of <code class="calibre23">a</code>, and the subtraction results in an unsigned integer value. This implies that when you write integer operations with operands of <span {http://www.idpf.org/2007/ops}type="pagebreak" title="64" id="calibre_link-526" class="calibre14"></span>different types, you should not rely on implicit type conversion to produce the result you want unless you are quite certain it will do so.</p>
<section class="toclist">
<h3 class="calibre21">Type Conversion in Assignments</h3>
<p class="calibre13">You saw in example <code class="calibre23">Ex2_05.cpp</code> that an implicit type conversion is inserted when the expression on the right of an assignment results in a value of a different type from the variable on the left. This can cause information to be lost. For instance, if you assign an expression that results in a <code class="calibre23">float</code> or <code class="calibre23">double</code> value to a variable of type <code class="calibre23">int</code> or <code class="calibre23">long</code>, the fractional part of the <code class="calibre23">float</code> or <code class="calibre23">double</code> result will be lost and just the integer part will be stored. (You may lose even more information if the result exceeds the range for the integer type.)</p>
<p class="calibre13">For example, consider the following code:</p>
<pre class="calibre28"><code class="calibre23">int number {};
float decimal {2.5f};
number = decimal;</code></pre>
<p class="calibre13">The value of <code class="calibre23">number</code> will be 2. The <code class="calibre23">f</code> at the end of <code class="calibre23">2.5f</code> indicates to the compiler that it is single-precision floating-point. Without the <code class="calibre23">f</code>, it would have been type <code class="calibre23">double</code>. Any constant containing a decimal point is floating-point. If you don’t want it to be double-precision, you need to append the <code class="calibre23">f</code>. A capital <code class="calibre23">F</code> would do the job just as well.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Explicit Type Conversion</h3>
<p class="calibre13">With mixed expressions involving the basic types, your compiler automatically arranges type conversions where necessary, but you can force a conversion from one type to another by using an <i class="calibre15">explicit type conversion</i>, which is also referred to as a <i class="calibre15">cast</i>. To cast the value of an expression to a given type, you write the cast in the form:</p>
<pre class="calibre28"><code class="calibre23">static_cast&lt;the_type_to_convert_to&gt;(expression)</code></pre>
<p class="calibre13">The <code class="calibre23">static_cast</code> keyword reflects the fact that the cast is checked statically &mdash; that is, when your program is compiled. No checks are made to see if this cast is safe to apply when you execute the program. Later, when you get to deal with classes, you will meet <code class="calibre23">dynamic_cast</code>, where the conversion is checked dynamically &mdash; that is, when the program is executing. There are two other kinds of cast &mdash; <code class="calibre23">const_cast</code> for removing the <code class="calibre23">const</code>-ness of an expression, and <code class="calibre23">reinterpret_cast</code>, which is an unconditional cast &mdash; but I’ll say no more about these here.</p>
<p class="calibre13">The effect of the <code class="calibre23">static_cast</code> operation is to convert the value that results from evaluating <code class="calibre23">expression</code> to the type between the angled brackets. <code class="calibre23">expression</code> can be anything from a single variable to a complex expression involving lots of nested parentheses.</p>
<p class="calibre13">Here’s an example of the use of <code class="calibre23">static_cast&lt;&gt;()</code>:</p>
<pre class="calibre28"><code class="calibre23">  double value1 {10.5};
  double value2 {15.5};
  int whole_number {};
  whole_number = static_cast&lt;int&gt;(value1) + static_cast&lt;int&gt;(value2);</code></pre>
<p class="calibre13">The value assigned to <code class="calibre23">whole_number</code> is the sum of the integral parts of <code class="calibre23">value1</code> and <code class="calibre23">value2</code>, so they are each explicitly cast to type <code class="calibre23">int. whole_number</code> will therefore have the value 25. The casts do <i class="calibre15">not</i> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="65" id="calibre_link-527" class="calibre14"></span>affect the values stored in <code class="calibre23">value1</code> and <code class="calibre23">value2</code>, which will remain as 10.5 and 15.5, respectively. The values produced by the casts are stored temporarily for use in the calculation and then discarded. Although both casts cause a loss of information, the compiler assumes that you know what you are doing with an explicit cast.</p>
<p class="calibre13">You can apply an explicit cast to any numeric type, but you should be conscious of the possibility of losing information. If you cast a value of type <code class="calibre23">float</code> or <code class="calibre23">double</code> to an integer type, you will lose the fractional part of the value, so if the value started out as less than 1.0, the result will be 0. If you cast a value of type <code class="calibre23">double</code> to type <code class="calibre23">float</code>, you will lose accuracy because a <code class="calibre23">float</code> variable has only 7-digit precision, whereas <code class="calibre23">double</code> variables maintain 15. Even casting between integer types provides the potential for losing data, depending on the values involved. For example, the value of an integer of type <code class="calibre23">long long</code> can exceed the maximum that you can store in a variable of type <code class="calibre23">int</code>, so casting from a <code class="calibre23">long long</code> value to type <code class="calibre23">int</code> may lose information.</p>
<p class="calibre13">In general, you should avoid casting as far as possible. If you find that you need a lot of explicit casts in your program, you should look at the structure of the program and the ways in which you have chosen data types to see whether you can eliminate, or at least reduce, the number of casts.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Old-style Casts</h3>
<p class="calibre13">Prior to the introduction of <code class="calibre23">static_cast&lt;&gt;()</code> (and the other casts: <code class="calibre23">const_cast&lt;&gt;(), dynamic_cast&lt;&gt;()</code>, and <code class="calibre23">reinterpret_cast&lt;&gt;()</code>, which I’ll discuss later in the book) into C++, an explicit cast was written as:</p>
<pre class="calibre28"><code class="calibre23">(the_type_to_convert_to)expression</code></pre>
<p class="calibre13">The result of <code class="calibre23">expression</code> is cast to the type between parentheses. For example, the statement to calculate <code class="calibre23">strips_per_roll</code> could be written:</p>
<pre class="calibre28"><code class="calibre23">strips_per_roll = (int)(rollLength / height);     //Get number of strips in a roll</code></pre>
<p class="calibre13">There are four different kinds of casts and the old-style casting syntax covers them all. Because of this, code using the old-style casts is more error-prone &mdash; it is not always clear what you intended, and you may not get the result you expected. Although you will still see the old style of casting used extensively (it’s still part of the language and you will see it in MFC code for historical reasons), I strongly recommend that you stick to using only the new casts.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-250" class="calibre3"></a>THE auto KEYWORD</h2>
<p class="calibre13">You can use the <code class="calibre23">auto</code> keyword as the type of a variable in a definition statement and have its type deduced from the initial value you supply. Here are some examples:</p>
<pre class="calibre28"><code class="calibre23">auto n = 16;                      // Type is int
auto pi = 3.14159;                // Type is double
auto x = 3.5f;                    // Type is float
auto found = false;               // Type is bool</code></pre>
<p class="calibre13">In each of these cases, the type assigned to the variable you are defining is the same as that of the literal used as the initializer. Of course, when you use the <code class="calibre23">auto</code> keyword in this way, you must supply an initial value for the variable.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="66" id="calibre_link-528" class="calibre14"></span>Note that you should <i class="calibre15">not</i> use the initializer list form with <code class="calibre23">auto</code> because an initializer list has a type. The compiler will not deduce the type from the items in the list, but from the list itself. Suppose you write:</p>
<pre class="calibre28"><code class="calibre23">auto n {16};</code></pre>
<p class="calibre13">The type assigned to <code class="calibre23">n</code> will not be <code class="calibre23">int</code>, but will be <code class="calibre23">std::initializer_list&lt;int&gt;</code>, which is the type of this particular initializer list. You learn more about the <code class="calibre23">std::initializer_list&lt;&gt;</code> type later in the book.</p>
<p class="calibre13">You can use the functional form of initialization with <code class="calibre23">auto</code>:</p>
<pre class="calibre28"><code class="calibre23">auto n(16);</code></pre>
<p class="calibre13">The variable <code class="calibre23">n</code> will be type <code class="calibre23">int</code>. Variables defined using the <code class="calibre23">auto</code> keyword can be specified as constants:</p>
<pre class="calibre28"><code class="calibre23">const auto e = 2.71828L;          // Type is const long double</code></pre>
<p class="calibre13">Of course, you can also use functional notation:</p>
<pre class="calibre28"><code class="calibre23">const auto dozen(12);             // Type is const int</code></pre>
<p class="calibre13">The initial value can also be an expression:</p>
<pre class="calibre28"><code class="calibre23">auto factor(n*pi*pi);             // Type is double</code></pre>
<p class="calibre13">In this case, the definitions for <code class="calibre23">n</code> and <code class="calibre23">pi</code> must precede this statement.</p>
<p class="calibre13">When you use <code class="calibre23">auto</code>, you are telling the compiler to figure out the type of the variable. The <code class="calibre23">auto</code> keyword may seem at this point to be a somewhat trivial feature of C++, but you’ll see later in the book, especially in Chapter 10, that it can save a lot of effort in determining complicated variable types and make your code more elegant. I recommend that you limit the use of <code class="calibre23">auto</code> to situations where it has advantages; don’t use it for defining variables of fundamental types.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-251" class="calibre3"></a>DISCOVERING TYPES</h2>
<p class="calibre13">The <code class="calibre23">typeid</code> operator enables you to discover the type of an expression. To obtain the type of an expression, you simply write <code class="calibre23">typeid(expression)</code>. This results in an object of type <code class="calibre23">type_info</code> that encapsulates the type of the expression. Let’s look at an example.</p>
<p class="calibre13">Suppose variables <code class="calibre23">x</code> and <code class="calibre23">y</code> are of type <code class="calibre23">int</code> and type <code class="calibre23">double</code>, respectively. The expression <code class="calibre23">typeid(x*y)</code> results in a <code class="calibre23">type_info</code> object representing the type of <code class="calibre23">x*y</code>, which by now you know to be <code class="calibre23">double</code>. Because the result of the <code class="calibre23">typeid</code> operator is an object, you can’t write it to the standard output stream just as it is. However, you can output the type of the expression <code class="calibre23">x*y</code> like this:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "The type of x*y is " &lt;&lt; typeid(x*y).name() &lt;&lt; endl;</code></pre>
<p class="calibre13">This will result in the output:</p>
<pre class="calibre28"><code class="calibre23">The type of x*y is double</code></pre>
<p class="calibre13">You will understand better how this works when you have learned more about classes and functions in Chapter 7. You won’t need to use the <code class="calibre23">typeid</code> operator very often but when you do, it is invaluable.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-252" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="67" id="calibre_link-529" class="calibre18"></span>THE BITWISE OPERATORS</h2>
<p class="calibre13">Bitwise operators treat their operands as a series of bits rather than as a numerical value. They work only with integer variables or constants so only types <code class="calibre23">short, int, long, long long, signed char</code>, and <code class="calibre23">char</code> and the unsigned variants of these can be used. The bitwise operators are useful in programming hardware devices, where the status of a device is often represented as a series of individual flags (that is, each bit of a byte signifies the status of some aspect of the device). They also help in situations where you want to pack a set of on-off flags into a single variable. You will see them in action when you look at input/output in detail, where single bits are used to control options for how data is handled.</p>
<p class="calibre13">There are six bitwise operators:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&amp;</code> bitwise AND</td>
<td class="calibre32"><code class="calibre23">|</code> bitwise OR</td>
<td class="calibre32"><code class="calibre23">^</code> bitwise exclusive OR</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">~</code> bitwise NOT</td>
<td class="calibre32"><code class="calibre23">&gt;&gt;</code> shift right</td>
<td class="calibre32"><code class="calibre23">&lt;&lt;</code> shift left</td>
</tr>
</tbody>
</table>
<p class="calibre13">The following sections explain how each of these works.</p>
<section class="toclist">
<h3 class="calibre21">The Bitwise AND</h3>
<p class="calibre13">The bitwise AND, <code class="calibre23">&amp;</code>, is a binary operator that combines corresponding bits in its operands such that if both corresponding bits are 1, the result is a 1-bit, and if either or both bits are 0, the result is a 0-bit.</p>
<p class="calibre13">The effect of a particular binary operator can be shown in a <i class="calibre15">truth table</i> that shows the results for various combinations of operands. The truth table for <code class="calibre23">&amp;</code> is:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32">Bitwise AND</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32">0</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
</tr>
<tr class="calibre31">
<td class="calibre32">1</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
</tr>
</tbody>
</table>
<p class="calibre13">For each row and column combination, the result of the operation is the entry at the intersection of the row and column. You can see this in an example:</p>
<pre class="calibre28"><code class="calibre23">char letter1 {'A'}, letter2 {'Z'}, result {};
result = letter1 &amp; letter2;</code></pre>
<p class="calibre13">You need to look at the bit patterns to see what happens. The letters <code class="calibre23">'A'</code> and <code class="calibre23">'Z'</code> correspond to hexadecimal values 0x41 and 0x5A, respectively. The way in which the bitwise AND operates on these values is shown in <a id="calibre_link-60" href="#calibre_link-59" class="calibre3">Figure 2-7</a>. You can confirm this by looking at how corresponding bits combine in the truth table. After the assignment, <code class="calibre23">result</code> will be 0x40 &mdash; the code for the <code class="calibre23">'@'</code> character.</p>
<figure class="calibre16">
<img class="center" src="images/000065.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-59" href="#calibre_link-60" class="calibre3">FIGURE 2-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="68" id="calibre_link-530" class="calibre14"></span>Because <code class="calibre23">&amp;</code> produces zero if <i class="calibre15">either</i> bit is zero, you can use this operator to set specific bits in a variable to 0. You achieve this by creating what is called a <i class="calibre15">mask</i> and combining it with the original variable using <code class="calibre23">&amp;</code>. The value of the mask will have a 1 where you want to keep a bit, and 0 where you want to set a bit to zero. The result of AND-ing the mask with a variable will be 0 bits where the mask bit is 0, and the original bit value where the mask bit is 1. Suppose <code class="calibre23">letter</code> is of type <code class="calibre23">char</code> and you want to zero the high-order 4 bits but keep the low-order 4 bits. This is easily done by combining <code class="calibre23">0x0F</code> with <code class="calibre23">letter</code> like this,</p>
<pre class="calibre28"><code class="calibre23">letter = letter &amp; 0x0F;</code></pre>
<p class="calibre13">or, more concisely:</p>
<pre class="calibre28"><code class="calibre23">letter &amp;= 0x0F;</code></pre>
<p class="calibre13">If <code class="calibre23">letter</code> started out as <code class="calibre23">0x41</code>, it would end up as <code class="calibre23">0x01</code> as a result of either of these statements. This operation is shown in <a id="calibre_link-62" href="#calibre_link-61" class="calibre3">Figure 2-8</a>. 0-bits in the mask cause corresponding bits in <code class="calibre23">letter</code> to be set to 0; 1-bits in the mask cause corresponding bits in <code class="calibre23">letter</code> to be kept as they are.</p>
<figure class="calibre16">
<img class="center" src="images/000151.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-61" href="#calibre_link-62" class="calibre3">FIGURE 2-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Similarly, you can use a mask of <code class="calibre23">0xF0</code> to keep the 4 high-order bits and zero the 4 low-order bits. This statement does it:</p>
<pre class="calibre28"><code class="calibre23">letter &amp;= 0xF0;</code></pre>
<p class="calibre13">The value of <code class="calibre23">letter</code> will be changed from <code class="calibre23">0x41</code> to <code class="calibre23">0x40</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Bitwise OR</h3>
<p class="calibre13">The bitwise OR, <code class="calibre23">|</code>, sometimes called the <i class="calibre15">inclusive OR</i>, combines corresponding bits such that the result is a 1 if either bit is 1, and 0 if both bits are 0. The truth table for the bitwise OR is:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32">Bitwise OR</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32">0</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32">1</td>
<td class="calibre32">1</td>
<td class="calibre32">1</td>
</tr>
</tbody>
</table>
<p class="calibre13">You can exercise this with an example of how you could set individual flags packed into a variable of type <code class="calibre23">int</code>. Suppose <code class="calibre23">style</code> is of type <code class="calibre23">short</code> and contains 16 individual 1-bit flags. Suppose further that you want to set some of the flags to 1. You could define a mask to set the rightmost bit like this:</p>
<pre class="calibre28"><code class="calibre23">short vredraw {0x01};</code></pre>
<p class="calibre13">To set the second-to-rightmost bit, you could define <code class="calibre23">hredraw</code> as:</p>
<pre class="calibre28"><code class="calibre23">short hredraw {0x02};</code></pre>
<p class="calibre13">This statement will set the rightmost two bits in <code class="calibre23">style</code> to 1:</p>
<pre class="calibre28"><code class="calibre23">style = hredraw | vredraw;</code></pre>
<p class="calibre13">This is illustrated in <a id="calibre_link-64" href="#calibre_link-63" class="calibre3">Figure 2-9</a>. Of course, to set the third bit of <code class="calibre23">style</code> to 1, you would use <code class="calibre23">0x04</code>.</p>
<figure class="calibre16">
<img class="center" src="images/000024.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-63" href="#calibre_link-64" class="calibre3">FIGURE 2-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="69" id="calibre_link-531" class="calibre14"></span>Setting particular bits in a word to 1 is a common requirement. You can do this quite easily with a statement such as:</p>
<pre class="calibre28"><code class="calibre23">style |= hredraw | vredraw;</code></pre>
<p class="calibre13">This statement sets the two rightmost bits of <code class="calibre23">style</code> to 1 and leaves the other bits in their original state.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Bitwise Exclusive OR</h3>
<p class="calibre13">The <i class="calibre15">exclusive OR</i>, <code class="calibre23">^</code>, is so-called because it operates similarly to the inclusive OR but produces 0 when both operand bits are 1. Its truth table is:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32">Bitwise XOR</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32">0</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32">1</td>
<td class="calibre32">1</td>
<td class="calibre32">0</td>
</tr>
</tbody>
</table>
<p class="calibre13">Assuming the same variable values that I used with <code class="calibre23">&amp;</code>, consider this:</p>
<pre class="calibre28"><code class="calibre23">result = letter1 ^ letter2;</code></pre>
<p class="calibre13">This operation is XOR-ing these binary values:</p>
<pre class="calibre28"><code class="calibre23">letter1  0100 0001
letter2  0101 1010</code></pre>
<p class="calibre13">This produces:</p>
<pre class="calibre28"><code class="calibre23">result  0001 1011</code></pre>
<p class="calibre13">The variable <code class="calibre23">result</code> is set to <code class="calibre23">0x1B</code>, or 27 in decimal notation.</p>
<p class="calibre13">The <code class="calibre23">^</code> operator has a rather surprising property. Suppose that you have <code class="calibre23">char</code> variables, <code class="calibre23">first</code> and <code class="calibre23">last</code>, with values <code class="calibre23">'A'</code> and <code class="calibre23">'Z'</code>. Look at these statements:</p>
<pre class="calibre28"><code class="calibre23">first ^= last;             // Result first is 0001 1011
last ^= first;             // Result last is 0100 0001
first ^= last;             // Result first is 0101 1010</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="70" id="calibre_link-532" class="calibre14"></span>The result of executing these is that <code class="calibre23">first</code> and <code class="calibre23">last</code> exchange values without using any intermediate memory location. This works with any integer values.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Bitwise NOT</h3>
<p class="calibre13">The bitwise NOT, <code class="calibre23">~</code>, takes a single operand, for which it inverts the bits: 1 becomes 0, and 0 becomes 1. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">result = ~letter1;</code></pre>
<p class="calibre13">If <code class="calibre23">letter1</code> is 0100 0001, <code class="calibre23">result</code> will have the value 1011 1110, which is 0xBE, or 190 as a decimal value.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Bitwise Shift Operators</h3>
<p class="calibre13">These operators shift the value of an integer variable a specified number of bits left or right. The <code class="calibre23">&gt;&gt;</code> operator shifts to the right, while <code class="calibre23">&lt;&lt;</code> shifts to the left. Bits that “fall off” either end of a variable are lost. <a id="calibre_link-66" href="#calibre_link-65" class="calibre3">Figure 2-10</a> shows the effect of shifting a 2-byte variable left and right, with the initial value shown.</p>
<figure class="calibre16">
<img class="center" src="images/000162.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-65" href="#calibre_link-66" class="calibre3">FIGURE 2-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You declare and initialize <code class="calibre23">number</code> with the statement:</p>
<pre class="calibre28"><code class="calibre23">unsigned short number {16387U};</code></pre>
<p class="calibre13">As you know, you write unsigned integer literals with <code class="calibre23">U</code> or <code class="calibre23">u</code> appended. You can shift the contents of <code class="calibre23">number</code> left with the statement:</p>
<pre class="calibre28"><code class="calibre23">number &lt;&lt;= 2;              // Shift left two bit positions</code></pre>
<p class="calibre13">The left operand of the shift operator is the value to be shifted, and the right operand is the number of bit positions that the value is to be shifted. <a href="#calibre_link-65" class="calibre3">Figure 2-10</a> shows the effect. Shifting 16,387 two positions left produces 12. The rather drastic change is the result of losing the high-order 1-bit.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="71" id="calibre_link-533" class="calibre14"></span>You can also shift a value right. Let’s reset the value of <code class="calibre23">number</code> to its initial value of 16,387. Then you can write:</p>
<pre class="calibre28"><code class="calibre23">number &gt;&gt;= 2;              // Shift right two bit positions</code></pre>
<p class="calibre13">This shifts 16,387 two bits right, storing 4,096. Shifting right 2 bits is effectively dividing the value by 4 (discarding the remainder). This is also shown in the illustration.</p>
<p class="calibre13">As long as bits are not lost, shifting <i class="calibre15">n</i> bits to the left is equivalent to multiplying the value by 2, <i class="calibre15">n</i> times. In other words, it is equivalent to multiplying by 2<sup class="calibre33">n</sup>. Similarly, shifting right <i class="calibre15">n</i> bits is equivalent to dividing by 2<sup class="calibre33">n</sup>. But beware: as you saw with the left shift of <code class="calibre23">number</code>, if significant bits are lost, the result is nothing like what you would expect. However, this is no different from the multiply operation. If you multiplied <code class="calibre23">number</code> by 4, you would get the same result, so shifting left and multiply are equivalent. The problem of accuracy arises because the result of the multiplication is outside the range of a 2-byte integer.</p>
<p class="calibre13">You might imagine that confusion could arise between the operators for input and output and the shift operators. As far as the compiler is concerned, the meaning will always be clear from the context. If it isn’t, the compiler will generate an error message, but you need to be careful. For example, suppose you want to output the result of shifting <code class="calibre23">number</code> left by 2 bits:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; (number &lt;&lt; 2);</code></pre>
<p class="calibre13">The parentheses are essential here. Without them, the shift operator will be interpreted as a stream operator, so you won’t get the result that you intended; the output would be the value of <code class="calibre23">number</code> followed by the value 2.</p>
<p class="calibre13">The right-shift operation is similar to the left-shift. For example, suppose <code class="calibre23">number</code> has the value 24, and you execute the statement:</p>
<pre class="calibre28"><code class="calibre23">number &gt;&gt;= 2;</code></pre>
<p class="calibre13">This results in <code class="calibre23">number</code> having the value 6, effectively dividing the original value by 4. However, right shift operates in a special way with <code class="calibre23">signed</code> integer types that are negative, where the sign bit, which is the leftmost bit, is 1. In this case, the sign bit is propagated to the right. For example, declare and initialize a variable <code class="calibre23">number</code> of type <code class="calibre23">char</code> with the value -104 in decimal:</p>
<pre class="calibre28"><code class="calibre23">char number {-104};        // Binary representation is 1001 1000</code></pre>
<p class="calibre13">Now you can shift it right 2 bits with the operation:</p>
<pre class="calibre28"><code class="calibre23">number &gt;&gt;= 2;              // Result 1110 0110</code></pre>
<p class="calibre13">The value of the result is -26, because the sign bit is repeated. With this operation on <code class="calibre23">unsigned</code> integer types, there is no sign bit and zeros appear.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You may be wondering how the shift operators</i>, <code class="calibre23">&lt;&lt;</code> <i class="calibre15">and</i> <code class="calibre23">&gt;&gt;</code>, <i class="calibre15">can be the same as the operators used with the standard streams</i>. <code class="calibre23">cin</code> <i class="calibre15">and</i> <code class="calibre23">cout</code> <i class="calibre15">are stream objects, and because they are objects it is possible to redefine the meaning of operators in their context by a process called operator overloading. The</i> <code class="calibre23">&gt;&gt;</code> <i class="calibre15">operator has been redefined for input stream objects such as</i> <code class="calibre23">cin</code> <i class="calibre15">so you can use it in the way you have seen. The</i> <code class="calibre23">&lt;&lt;</code> <i class="calibre15">operator has also been redefined for use with output stream objects such as</i> <code class="calibre23">cout</code>. <i class="calibre15">You’ll learn about operator overloading in Chapter 8.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-253" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="72" id="calibre_link-534" class="calibre18"></span>INTRODUCING LVALUES AND RVALUES</h2>
<p class="calibre13">Every expression results in either an <i class="calibre15">lvalue</i> or an <i class="calibre15">rvalue</i> (sometimes written <i class="calibre15">l-value</i> and <i class="calibre15">r-value</i> and pronounced like that). An lvalue refers to an address in memory in which something can be stored on an ongoing basis. An rvalue, on the other hand, is the result of an expression that is stored transiently. An lvalue is so called because any expression that results in an lvalue can appear on the left of the equals sign in an assignment statement. If the result of an expression is not an lvalue, it is an rvalue.</p>
<p class="calibre13">Consider the following statements:</p>
<pre class="calibre28"><code class="calibre23">int a {}, b {1}, c {2};
a = b + c;
b = ++a;
c = a++;</code></pre>
<p class="calibre13">The first statement declares <code class="calibre23">a, b</code>, and <code class="calibre23">c</code> to be of type <code class="calibre23">int</code> and initializes them to 0, 1, and 2, respectively. In the second statement, the expression <code class="calibre23">b+c</code> is evaluated and the result is stored in <code class="calibre23">a</code>. The result of evaluating <code class="calibre23">b+c</code> is stored temporarily and the value is copied to <code class="calibre23">a</code>. Once execution of the statement is complete, the memory holding the result of <code class="calibre23">b+c</code> is discarded. Thus, the result of evaluating <code class="calibre23">b+c</code> is an rvalue.</p>
<p class="calibre13">In the third statement, the expression <code class="calibre23">++a</code> is an lvalue because its result is <code class="calibre23">a</code> after its value is incremented. The expression <code class="calibre23">a++</code> in the fourth statement is an rvalue because it stores the value of <code class="calibre23">a</code> temporarily as the result of the expression and then increments <code class="calibre23">a</code>.</p>
<p class="calibre13">An expression that consists of a single named variable is always an lvalue.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">This is by no means all there is to know about lvalues and rvalues. Most of the time, you don’t need to worry very much about whether an expression is an lvalue or an rvalue but sometimes you do. Lvalues and rvalues will pop up at various times throughout the book so keep the idea in mind.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-254" class="calibre3"></a>UNDERSTANDING STORAGE DURATION AND SCOPE</h2>
<p class="calibre13">All variables have a finite lifetime. They come into existence at the point at which you declare them and then, at some point, they disappear &mdash; at the latest, when your program terminates. How long a particular variable lasts is determined by a property called its <i class="calibre15">storage duration.</i> There are three different kinds of storage duration that a variable can have:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Automatic storage duration</li>
<li class="calibre6">Static storage duration</li>
<li class="calibre6">Dynamic storage duration</li>
</ul>
<p class="calibre13">Which of these a variable will have depends on how you create it. I will defer discussion of variables with dynamic storage duration until Chapter 4, but you will be exploring the characteristics of the other two in this chapter.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="73" id="calibre_link-535" class="calibre14"></span>Another property that variables have is <i class="calibre15">scope</i>. The scope of a variable is that part of your program over which the variable name is valid. Within a variable’s scope, you can legally refer to it, either to set its value or to use it in an expression. Outside of the scope of a variable, you cannot refer to its name &mdash; any attempt to do so will cause a compiler error. Note that a variable may still <i class="calibre15">exist</i> outside of its scope, even though you cannot refer to it. You will see examples of this a little later in this discussion.</p>
<p class="calibre13">All the variables that you have declared up to now have had <i class="calibre15">automatic storage duration</i>, and are therefore called <i class="calibre15">automatic variables</i>. Let’s take a closer look at these first.</p>
<section class="toclist">
<h3 class="calibre21">Automatic Variables</h3>
<p class="calibre13">The variables that you have declared so far have been declared within a block &mdash; that is, within the extent of a pair of braces. These are <i class="calibre15">automatic</i> variables and have <i class="calibre15">local scope</i> or <i class="calibre15">block scope</i>. An automatic variable is “in scope” from the point at which it is declared until the end of the block containing its declaration. The space that an automatic variable occupies is allocated in a memory area called the <i class="calibre15">stack</i> that is set aside specifically for this purpose. The default size for the stack is 1 MB, which is adequate for most purposes. If this is insufficient, you can increase the stack by adding a <code class="calibre23">/STACK</code> or <code class="calibre23">/F</code> compiler command-line option for the project to a value of your choosing. You can also set the stack size as a linker property.</p>
<p class="calibre13">An automatic variable is created when it is defined and space for it is allocated on the stack; it automatically ceases to exist at the end of the block containing its definition. This will be at the closing brace matching the first opening brace that precedes the declaration of the variable. Every time a block of statements containing a declaration for an automatic variable is executed, the variable is re-created, and if you specified an initial value for it, it will be reinitialized each time. When an automatic variable dies, its memory on the stack is freed for use by other automatic variables. Let’s look at an example demonstrating some of what I’ve discussed so far about scope.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Automatic Variables</h3>
<p class="calibre20">The following example shows the effect of scope on automatic variables:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_07.cpp
// Demonstrating variable scope
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
int main()
{                                    // Function scope starts here
   int count1 {10};
   int count3 {50};
   cout &lt;&lt; endl
        &lt;&lt; "Value of outer count1 = " &lt;&lt; count1
        &lt;&lt; endl;
        
   {                                // New scope starts here...
      int count1 {20};              // This hides the outer count1
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="74" id="calibre_link-536" class="calibre14"></span>      int count2 {30};
      cout &lt;&lt; "Value of inner count1 = " &lt;&lt; count1
           &lt;&lt; endl;
      count1 += 3;                  // This affects the inner count1
      count3 += count2;
   }                                // ...and ends here
        
   cout &lt;&lt; "Value of outer count1 = " &lt;&lt; count1
        &lt;&lt; endl
        &lt;&lt; "Value of outer count3 = " &lt;&lt; count3
        &lt;&lt; endl;
        
   // cout &lt;&lt; count2 &lt;&lt; endl;       // uncomment to get an error
        
   return 0;
}                                   // Function scope ends here</code></pre>
<p class="calibre20">The output from this example will be:</p>
<pre class="calibre28"><code class="calibre23">Value of outer count1 = 10
Value of inner count1 = 20
Value of outer count1 = 10
Value of outer count3 = 80</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The first two statements declare and define <code class="calibre23">count1</code> and <code class="calibre23">count3</code>, with initial values of 10 and 50, respectively. Both exist from this point to the closing brace at the end of the program. The scope of these variables also extends to the closing brace at the end of <code class="calibre23">main()</code>.</p>
<p class="calibre20">Remember that lifetime and scope are two different things. It’s important not to get these two ideas confused. The lifetime is the period from when a variable is first created to when it is destroyed and the memory it occupies is freed. Scope is the region of program code over which a variable may be accessed.</p>
<p class="calibre20">Following the variable definitions, the value of <code class="calibre23">count1</code> is written to <code class="calibre23">cout</code> to produce the first output line. There’s then a second brace, which starts a new block. Two variables, <code class="calibre23">count1</code> and <code class="calibre23">count2</code>, are defined within this block, with values 20 and 30, respectively. The <code class="calibre23">count1</code> here is <i class="calibre15">different</i> from the first <code class="calibre23">count1</code>. The first <code class="calibre23">count1</code> still exists, but its name is masked by the second <code class="calibre23">count1</code>. Any use of the name <code class="calibre23">count1</code> following the declaration within the inner block refers to the <code class="calibre23">count1</code> declared within that block.</p>
<p class="calibre20">I used a duplicate of the variable name <code class="calibre23">count1</code> here to illustrate what happens. Although this code is legal, it’s a bad approach to programming. In a real-world environment, it would be confusing, and using duplicate names makes it very easy to hide variables defined in an outer scope accidentally.</p>
<p class="calibre20">The value shown in the second output line shows that within the inner block, you are using the <code class="calibre23">count1</code> in the inner scope &mdash; that is, inside the innermost braces:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "Value of inner count1 = " &lt;&lt; count1
     &lt;&lt; endl;</code></pre>
<p class="calibre20">Had you still been using the outer <code class="calibre23">count1</code>, then this would output 10. <code class="calibre23">count1</code> is then incremented by this statement:</p>
<pre class="calibre28"><code class="calibre23">count1 += 3;               // This affects the inner count1</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="75" id="calibre_link-537" class="calibre14"></span>The increment applies to the variable in the inner scope because the outer one is still hidden. However, <code class="calibre23">count3</code> that was defined in the outer scope is incremented in the next statement without any problem:</p>
<pre class="calibre28"><code class="calibre23">count3 += count2;</code></pre>
<p class="calibre20">This shows that the variables that were declared at the beginning of the outer scope are accessible from within the inner scope. If <code class="calibre23">count3</code> had been declared <i class="calibre15">after</i> the second of the inner pair of braces, then it would still be within the outer scope but it would not exist in the inner scope.</p>
<p class="calibre20">After the brace ending the inner scope, <code class="calibre23">count2</code> and the inner <code class="calibre23">count1</code> cease to exist. <code class="calibre23">count1</code> and <code class="calibre23">count3</code> are still there in the outer scope, and the values displayed show that <code class="calibre23">count3</code> was indeed incremented in the inner scope.</p>
<p class="calibre20">If you uncomment the line,</p>
<pre class="calibre28"><code class="calibre23">// cout &lt;&lt; count2 &lt;&lt; endl;          // uncomment to get an error</code></pre>
<p class="calibre20">the program will no longer compile because this attempts to output a non-existent variable. You will get an error message something like:</p>
<pre class="calibre28"><code class="calibre23">c:\microsoft visual studio\myprojects\Ex2_07\Ex2_07.cpp(29) : error
     C2065: 'count2' : undeclared identifier</code></pre>
<p class="calibre20">This is because <code class="calibre23">count2</code> is out of scope at this point.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Positioning Variable Declarations</h3>
<p class="calibre13">You have great flexibility as to where you can place variable definitions. The most important aspect to consider is what scope the variables need to have. Beyond that, you should place a definition close to where the variable is to be first used. You should write your programs with the intention of making them as easy as possible for another programmer to understand, and declaring a variable at its first point of use is helpful in achieving that.</p>
<p class="calibre13">It is possible to place definitions for variables outside of all of the functions that make up a program. The next section looks at what effect that has.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Global Variables</h3>
<p class="calibre13">Variables declared outside of all blocks and classes (I will discuss classes later in the book) are called <i class="calibre15">globals</i> and have <i class="calibre15">global scope</i>, which is also called <i class="calibre15">global namespace scope</i> or <i class="calibre15">file scope</i>. This means that they are accessible throughout all the functions in the file following the point at which they are declared. If you declare a variable at the beginning of a source file, it will be accessible from anywhere in the file.</p>
<p class="calibre13">Globals have <i class="calibre15">static storage duration</i> by default. Static storage duration means they exist from the start of execution of a program until the program ends. If you do not specify an initial value for a global variable, it will be initialized with 0 by default. Global variables are created and initialized before the execution of <code class="calibre23">main()</code> begins, so they are always accessible by any code within the variable’s scope.</p>
<p class="calibre13"><a id="calibre_link-68" href="#calibre_link-67" class="calibre3">Figure 2-11</a> shows the contents of a source file, <code class="calibre23">Example.cpp</code>, and the arrows indicate the scopes of the variables.</p>
<figure class="calibre16">
<img class="center" src="images/000105.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-67" href="#calibre_link-68" class="calibre3">FIGURE 2-11</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="76" id="calibre_link-538" class="calibre14"></span><code class="calibre23">value1</code> appears at the beginning of the file so it is declared at global scope, as is <code class="calibre23">value4</code>, which appears after the function <code class="calibre23">main()</code>. The scope of each global variable extends from the point at which it is defined to the end of the file. Even though <code class="calibre23">value4</code> exists when execution starts, it cannot be referred to in <code class="calibre23">main()</code> because <code class="calibre23">main()</code> is not within the variable’s scope. For <code class="calibre23">main()</code> to use <code class="calibre23">value4</code>, its definition must precede <code class="calibre23">main().value1</code> and <code class="calibre23">value4</code> will be initialized with 0 by default, which is not the case for the automatic variables. The local variable, <code class="calibre23">value1</code>, in <code class="calibre23">function()</code> hides the global <code class="calibre23">value1</code>.</p>
<p class="calibre13">Global variables continue to exist for as long as a program is running, which raises the question “Why not make all variables global and avoid this messing about with local variables that disappear?” This sounds attractive but as with the Sirens of mythology, there are serious side effects that completely outweigh any advantages. Real programs are generally composed of a large number of statements, a significant number of functions, and a great many variables. Declaring all variables at global scope greatly magnifies the possibility of accidental erroneous modification of a variable, as well as making the job of naming them sensibly quite intractable. They will also occupy memory for the duration of program execution. By keeping variables local to a function or a block, you can be sure they have almost complete protection from external effects, they will only exist and occupy <span {http://www.idpf.org/2007/ops}type="pagebreak" title="77" id="calibre_link-539" class="calibre14"></span>memory from the point at which they are defined to the end of the enclosing block, and the whole development process becomes much easier to manage. That’s not to say you should never define variables at global scope. Sometimes it can be very convenient.</p>
<p class="calibre13">If you look at the Class View pane for any of the examples that you have created so far and extend the class tree for the project by clicking on the unfilled arrow, you will see an entry called Global Functions and Variables. Clicking this will display a list of everything that has global scope. This will include all the global functions, as well as any global variables.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: The Scope Resolution Operator</h3>
<p class="calibre20">As you have seen, a global variable can be hidden by a local variable with the same name. However, it’s still possible to get at the global variable by using the <i class="calibre15">scope resolution operator</i> (<code class="calibre23">::</code>), which you saw in Chapter 1 when I was discussing namespaces. I can demonstrate this with a revised version of <code class="calibre23">Ex2_07.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex2_08.cpp</b>
<b class="calibre12">// Demonstrating variable scope</b>
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
<b class="calibre12">int count1 {100};                         // Global version of count1</b>
        
int main()
{                                         // Function scope starts here
   int count1 {10};
   int count3 {50};
   cout &lt;&lt; endl
        &lt;&lt; "Value of outer count1 = " &lt;&lt; count1
        &lt;&lt; endl;
   <b class="calibre12">cout &lt;&lt; "Value of global count1 = " &lt;&lt; ::count1            // From outer block</b>
        &lt;&lt; endl;
        
  {                               // New scope starts here...
      int count1 {20};            // This hides the outer count1
      int count2 {30};
      cout &lt;&lt; "Value of inner count1 = " &lt;&lt; count1
           &lt;&lt; endl;
      <b class="calibre12">cout &lt;&lt; "Value of global count1 = " &lt;&lt; ::count1         // From inner block</b>
           <b class="calibre12">&lt;&lt; endl;</b>
        
      count1 += 3;                // This affects the inner count1
      count3 += count2;
   }                              // ...and ends here.
        
   cout &lt;&lt; "Value of outer count1 = " &lt;&lt; count1
        &lt;&lt; endl
        &lt;&lt; "Value of outer count3 = " &lt;&lt; count3
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="78" id="calibre_link-540" class="calibre14"></span>        &lt;&lt; endl;
        
   //cout &lt;&lt; count2 &lt;&lt; endl;        // uncomment to get an error
   return 0;
}                                   // Function scope ends here</code></pre>
<p class="calibre20">This produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Value of outer count1 = 10
Value of global count1 = 100
Value of inner count1 = 20
Value of global count1 = 100
Value of outer count1 = 10
Value of outer count3 = 80</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The shaded code marks the changes I have made to the previous example; I’ll just discuss the effects of those. The definition of <code class="calibre23">count1</code> prior to the definition of <code class="calibre23">main()</code> is global, so in principle, it is available anywhere through <code class="calibre23">main()</code>. This global variable is initialized with the value of 100:</p>
<pre class="calibre28"><code class="calibre23">int count1 {100};                         // Global version of count1</code></pre>
<p class="calibre20">However, you have two other variables called <code class="calibre23">count1</code> defined within <code class="calibre23">main()</code> so throughout the program the global <code class="calibre23">count1</code> is hidden by the local <code class="calibre23">count1</code> variables. The first new output statement is:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "Value of global count1 = " &lt;&lt; ::count1               // From outer block
     &lt;&lt; endl;</code></pre>
<p class="calibre20">This uses the scope resolution operator (<code class="calibre23">::</code>) to reference the global <code class="calibre23">count1</code>, <i class="calibre15">not</i> the local one. You can see that this works from the value in the output.</p>
<p class="calibre20">In the inner block, the global <code class="calibre23">count1</code> is hidden by <i class="calibre15">two</i> variables called <code class="calibre23">count1</code>: the inner <code class="calibre23">count1</code> and the outer <code class="calibre23">count1</code>. The global scope resolution operator gets over this within the inner block, as you can see from the output generated by the statement we have added there:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "Value of global count1 = " &lt;&lt; ::count1               // From inner block
     &lt;&lt; endl;</code></pre>
<p class="calibre20">This outputs the value 100, as before &mdash; the long arm of the scope resolution operator used in this fashion always reaches a global variable.</p>
<p class="calibre20">You have seen earlier that you can refer to a name in the <code class="calibre23">std</code> namespace by qualifying the name with the namespace name, such as with <code class="calibre23">std::cout</code> or <code class="calibre23">std::endl</code>. The compiler searches the namespace that has the name specified by the left operand of the scope resolution operator for the name that you specify as the right operand. In the preceding example, you are using the scope resolution operator to search the global namespace for the variable <code class="calibre23">count1</code>. By not specifying a namespace name in front of the operator, you are telling the compiler to search the global namespace for the name that follows it. You’ll see a lot more of this operator when you get to explore object-oriented programming in Chapter 9, where it is used extensively.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Static Variables</h3>
<p class="calibre13">It’s conceivable that you might want a variable that’s defined and accessible locally, but which also continues to exist after exiting the block in which it is declared. In other words, you need to declare <span {http://www.idpf.org/2007/ops}type="pagebreak" title="79" id="calibre_link-541" class="calibre14"></span>a variable with block scope, but to give it <i class="calibre15">static storage duration</i>. The <code class="calibre23">static</code> specifier enables you to do this, and the need for this will become more apparent when we come to deal with functions in Chapter 5.</p>
<p class="calibre13">A static variable continues to exist for the life of a program even though it is declared within a block and available only from within that block (or its sub-blocks). It still has block scope, but it has static storage duration. To declare a static integer variable called <code class="calibre23">count</code>, you would write:</p>
<pre class="calibre28"><code class="calibre23">static int count;</code></pre>
<p class="calibre13">If you don’t provide an initial value for a static variable, it will be initialized with 0 converted to the type applicable to the variable. Remember that this is <i class="calibre15">not</i> the case with automatic variables.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-255" class="calibre3"></a>VARIABLES WITH SPECIFIC SETS OF VALUES</h2>
<p class="calibre13">You will sometimes need variables that have a limited set of possible values that can be usefully referred to by labels &mdash; the days of the week, for example, or months of the year, or the suits in a card deck. An <i class="calibre15">enumeration</i> provides this capability. There are two kinds of enumerations: those defined using syntax introduced in the C++ 11 standard, and those defined using older syntax. I’ll describe both because the old syntax is used widely, but the new syntax has several real advantages so you should only use that.</p>
<section class="toclist">
<h3 class="calibre21">Old Enumerations</h3>
<p class="calibre13">Take one of the examples I mentioned &mdash; a variable that can assume values corresponding to days of the week. Here’s how you can define this:</p>
<pre class="calibre28"><code class="calibre23">enum Weekdays{Mon, Tues, Wed, Thurs, Fri, Sat, Sun} today;</code></pre>
<p class="calibre13">This declares an enumeration type with the name <code class="calibre23">Weekdays</code> and a variable <code class="calibre23">today</code>, which is an instance of that type. A variable of type <code class="calibre23">Weekdays</code> can assume only the constant values specified between the braces. If you try to set <code class="calibre23">today</code> to anything other than one of the set of values specified, it will cause an error. The names between the braces are called <i class="calibre15">enumerators</i>. Each enumerator will be automatically defined as a fixed integer value that will be type <code class="calibre23">int</code> by default. The first name in the list, <code class="calibre23">Mon</code>, will have the value 0, <code class="calibre23">Tues</code> will be 1, and so on.</p>
<p class="calibre13">You could assign one of the enumeration constants as the value of <code class="calibre23">today</code> like this:</p>
<pre class="calibre28"><code class="calibre23">today = Thurs;</code></pre>
<p class="calibre13">The value of <code class="calibre23">today</code> will be 3 because the enumerators are assigned values in sequence, starting with 0 by default. Each successive enumerator is one larger than the previous one. If you would prefer the implicit numbering to start at a different value, you can change it. For example:</p>
<pre class="calibre28"><code class="calibre23">enum Weekdays {Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun} today;</code></pre>
<p class="calibre13">Now the enumeration constants will be 1 through 7. Enumerators don’t even need to have unique values. You could define <code class="calibre23">Mon</code> and <code class="calibre23">Tues</code> as both having the value 1, for example, with the statement:</p>
<pre class="calibre28"><code class="calibre23">enum Weekdays {Mon = 1, Tues = 1, Wed, Thurs, Fri, Sat, Sun} thisWeek;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="80" id="calibre_link-542" class="calibre14"></span>Because the enumerators for <code class="calibre23">Weekdays</code> are of type <code class="calibre23">int, today</code> stores a value of type <code class="calibre23">int</code> and it will occupy 4 bytes, as will all variables of type <code class="calibre23">Weekdays</code>. Enumerators and variables of an enumeration type will be implicitly converted to type <code class="calibre23">int</code> when required. For example, you can assign an enumerator as a value for an integer variable:</p>
<pre class="calibre28"><code class="calibre23">int value {};
value = Wed;</code></pre>
<p class="calibre13">If you wish, you can assign specific values to all the enumerators. For example, you could define this enumeration:</p>
<pre class="calibre28"><code class="calibre23">enum Punctuation {Comma = ',', Exclamation = '!', Question = '?'} things;</code></pre>
<p class="calibre13">You have defined the possible values for <code class="calibre23">things</code> as the code values of the corresponding characters. The enumerators are 44, 33, and 63, respectively, in decimal. As you can see, the enumerator values don’t have to be in ascending order. Any enumerator for which you don’t specify a value will be assigned a value 1 greater than the preceding enumerator value.</p>
<p class="calibre13">You can write enumerator values to the standard output stream:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; today &lt;&lt; endl;</code></pre>
<p class="calibre13">The compiler inserts a conversion to type <code class="calibre23">int</code> for the value of <code class="calibre23">today</code>. In general, if you use an enumerator or a variable of an enumeration type, the compiler will insert a conversion of the value to the required numeric type for the expression. This is an undesirable feature because it allows the accidental use of a variable of an enumeration type as though it was a numeric type.</p>
<p class="calibre13">Having defined an enumeration type, you can define another variable:</p>
<pre class="calibre28"><code class="calibre23">enum Weekdays tomorrow;</code></pre>
<p class="calibre13">This defines <code class="calibre23">tomorrow</code> as type <code class="calibre23">Weekdays</code>. You can omit the <code class="calibre23">enum</code> keyword so you could write:</p>
<pre class="calibre28"><code class="calibre23">Weekdays tomorrow;</code></pre>
<p class="calibre13">You can declare and initialize a variable of an enumeration type like any other variable. For example:</p>
<pre class="calibre28"><code class="calibre23">Weekdays myBirthday {Tues};
Weekdays yourBirthday {Thurs};</code></pre>
<p class="calibre13">You don’t need to qualify an enumeration constant with the name of the enumeration, although you can if you wish:</p>
<pre class="calibre28"><code class="calibre23">Weekdays myBirthday {Weekdays::Tues};</code></pre>
<p class="calibre13">The <code class="calibre23">enum</code> type name is separated from the enumerator name by the scope resolution operator.</p>
<p class="calibre13">You can omit the enumeration type name from the definition if you don’t need to define other variables of this type. For example:</p>
<pre class="calibre28"><code class="calibre23">enum {Mon, Tues, Wed, Thurs, Fri, Sat, Sun} today, tomorrow, yesterday;</code></pre>
<p class="calibre13">You have three variables declared that can assume any of the values from <code class="calibre23">Mon</code> to <code class="calibre23">Sun</code>. Because the enumeration type is not specified, you cannot refer to it. This implies that you cannot define other variables for this enumeration type because you would not be permitted to repeat the definition. Doing so would imply that you were redefining values for <code class="calibre23">Mon</code> to <code class="calibre23">Sun</code>, and this isn’t allowed.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="81" id="calibre_link-543" class="calibre14"></span>You don’t have to accept the default type for the enumerators. You can explicitly specify the enumerator type as any integer type except <code class="calibre23">wchar_t</code>. Here’s an example that shows how you do that:</p>
<pre class="calibre28"><code class="calibre23">enum Workdays : unsigned long {Mon, Tues, Wed, Thurs, Fri} tomorrow;</code></pre>
<p class="calibre13">The enumerators for <code class="calibre23">Workdays</code> will be of type <code class="calibre23">unsigned long</code>.</p>
<p class="calibre13">The enumerator names are exported into the enclosing scope by default. This is why there is no need to qualify their names. This can create a problem. Look at these two enumerations:</p>
<pre class="calibre28"><code class="calibre23">enum Suit {Clubs, Diamonds, Hearts, Spades};
enum Jewels {Diamonds, Emeralds, Opals, Rubies, Sapphires};</code></pre>
<p class="calibre13">If you put these definitions in <code class="calibre23">main()</code> they won’t compile. Both sets of enumerator names are in the enclosing scope, that is, throughout the body of <code class="calibre23">main()</code>. The <code class="calibre23">Jewels</code> enumeration is seen to redefine <code class="calibre23">Diamonds</code>, which is not allowed.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Type-safe Enumerations</h3>
<p class="calibre13">C++ 11 introduced a new form of enumeration. These enumerations are said to be <i class="calibre15">type-safe</i> because implicit conversion of enumerator values to another type will not occur. You use the <code class="calibre23">class</code> keyword following <code class="calibre23">enum</code> to specify the new enumeration type. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">enum class Suit {Clubs, Diamonds, Hearts, Spades};</code></pre>
<p class="calibre13">The enumerator names are not exported into the enclosing scope. You must always qualify them using the type name, like this:</p>
<pre class="calibre28"><code class="calibre23">Suit suit {Suit::Diamonds};</code></pre>
<p class="calibre13">You can rewrite the two enumerations from the previous section that did not compile as type-safe enumerations:</p>
<pre class="calibre28"><code class="calibre23">enum class Suit {Clubs, Diamonds, Hearts, Spades};
enum class Jewels {Diamonds, Emeralds, Opals, Rubies, Sapphires};</code></pre>
<p class="calibre13">These statements will compile. There are no name conflicts because the enumerator names are not exported into the enclosing scope. You must always qualify the enumerator names with the type name so <code class="calibre23">Suit::Diamonds</code> is always distinct from <code class="calibre23">Jewels::Diamonds</code>.</p>
<p class="calibre13">If you want to convert an enumerator value to another type, you can use an explicit cast. For example:</p>
<pre class="calibre28"><code class="calibre23">Suit suit{Suit::Diamonds};                  // Create and initialize suit
int suitValue {static_cast&lt;int&gt;(suit)};     // Convert suit to int</code></pre>
<p class="calibre13">This will not compile without the explicit conversion of <code class="calibre23">suit</code> to type <code class="calibre23">int</code>.</p>
<p class="calibre13">The enumerator values are type <code class="calibre23">int</code> by default, but you can change this:</p>
<pre class="calibre28"><code class="calibre23">enum class Jewels : char {Diamonds, Emeralds, Opals, Rubies, Sapphires};</code></pre>
<p class="calibre13">Here, enumerator values will be of type <code class="calibre23">char</code>. The next example demonstrates aspects of both kinds of enumerations.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="82" id="calibre_link-544" class="calibre24"></span>TRY IT OUT: Using Enumerations</h3>
<p class="calibre20">This example demonstrates both types of enumerations:</p>
<pre class="calibre28"><code class="calibre23">// Ex2_09.cpp
// Demonstrating type-safe and non-type-safe enumerations
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
// You can define enumerations at global scope
//enum Jewels {Diamonds, Emeralds, Rubies};  // Uncomment this for an error
enum Suit : long {Clubs, Diamonds, Hearts, Spades};
        
int main()
{
  // Using the old enumeration type...
   Suit suit {Clubs};                        // You can use old enumerator names directly
   Suit another {Suit::Diamonds};            // or you can qualify them
 
  // Automatic conversion from enumeration type to integer
   cout &lt;&lt; "suit value: " &lt;&lt; suit &lt;&lt; endl;
   cout &lt;&lt; "Add 10 to another: " &lt;&lt; another + 10 &lt;&lt; endl;
 
   // Using type-safe enumerations...
   enum class Color : char {Red, Orange, Yellow, Green, Blue, Indigo, Violet};
   Color skyColor{Color::Blue};              // You must qualify enumerator names
   // Color grassColor{Green};               // Uncomment for an error
 
   // No auto conversion to numeric type
   cout &lt;&lt; endl
        &lt;&lt; "Sky color value: "
        &lt;&lt; static_cast&lt;long&gt;(skyColor) &lt;&lt; endl;
   
   //cout &lt;&lt; skyColor + 10L &lt;&lt; endl;         // Uncomment for an error
   cout &lt;&lt; "Incremented sky color: "
        &lt;&lt; static_cast&lt;long&gt;(skyColor) + 10L // OK with explicit cast
        &lt;&lt; endl;
   return 0;
}</code></pre>
<p class="calibre20">If you compile and run this example, you’ll get the following output:</p>
<pre class="calibre28"><code class="calibre23">suit value: 0
Add 10 to another: 11
Sky color value: 4
Incremented sky color: 14</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You can see that you can define enumerations at global scope, in which case they are accessible throughout the source file. Enumerations defined locally within a block are available from where <span {http://www.idpf.org/2007/ops}type="pagebreak" title="83" id="calibre_link-545" class="calibre14"></span>they are defined to the end of the block. You could put the definition of the enumeration type into a <code class="calibre23">.h</code> file that you create; you could then <code class="calibre23">#include</code> the header into any source file that is to use the enumeration.</p>
<p class="calibre20">Uncommenting the definition for the <code class="calibre23">Jewels</code> enumeration will result in a compiler error because of the duplication of <code class="calibre23">Diamonds</code>. If the <code class="calibre23">Suit</code> and <code class="calibre23">Jewels</code> types were defined as type-safe enums, no name collision would occur.</p>
<p class="calibre20">The <code class="calibre23">main()</code> function exercises the old-style enumerations first by showing that type qualification of enumerator names is optional. These statements show automatic conversions in operation:</p>
<pre class="calibre28"><code class="calibre23">   cout &lt;&lt; "suit value: " &lt;&lt; suit &lt;&lt; endl;
   cout &lt;&lt; "Add 10 to another: " &lt;&lt; another + 10 &lt;&lt; endl;</code></pre>
<p class="calibre20">The compiler will happily allow you to output <code class="calibre23">suit</code> as though it is an integer, even though it is of type <code class="calibre23">Suit</code>. You can also use it in an arithmetic expression.</p>
<p class="calibre20">The <code class="calibre23">Color</code> enumeration is type-safe:</p>
<pre class="calibre28"><code class="calibre23">   enum class Color : char {Red, Orange, Yellow, Green, Blue, Indigo, Violet};</code></pre>
<p class="calibre20">If you attempt to use the enumerator names without qualification, you will get an error message from the compiler. The compiler will insist that if you want to convert a <code class="calibre23">Color</code> value to another type, you must insert an explicit cast.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Always use type-safe enumerations. This will make your code less error-prone.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-256" class="calibre3"></a>NAMESPACES</h2>
<p class="calibre13">I have mentioned namespaces several times, so it’s time you got a better idea of what they are about. They are not used in the libraries supporting MFC, but the standard library uses namespaces throughout.</p>
<p class="calibre13">You know already that the names in the standard library are defined in a namespace with the name <code class="calibre23">std</code>. This means that the names have an additional qualifying name, <code class="calibre23">std</code>; for example, <code class="calibre23">cout</code> is really <code class="calibre23">std::cout</code>. You have already seen how a <code class="calibre23">using</code> declaration imports a name from the <code class="calibre23">std</code> namespace into your source file. For example:</p>
<pre class="calibre28"><code class="calibre23">using std::cout;</code></pre>
<p class="calibre13">This allows you to use <code class="calibre23">cout</code> and have it interpreted as <code class="calibre23">std::cout</code>.</p>
<p class="calibre13">Namespaces provide a way to separate names used in one part of a program from those used in another. This is invaluable with large projects involving several teams of programmers working on different parts of a program. Each team can have its own namespace name, and worries about two teams accidentally using the same name for different functions disappear.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="84" id="calibre_link-546" class="calibre14"></span>Look at this line of code:</p>
<pre class="calibre28"><code class="calibre23">using namespace std;</code></pre>
<p class="calibre13">This is a <i class="calibre15">using directive</i> and is different from a <code class="calibre23">using</code> declaration. The effect of this is to import <i class="calibre15">all</i> the names from the <code class="calibre23">std</code> namespace into the source file so you can refer to anything that is defined in this namespace without qualifying the name. Thus, you can write <code class="calibre23">cout</code> instead of <code class="calibre23">std::cout</code> and <code class="calibre23">endl</code> instead of <code class="calibre23">std::endl</code>. This sounds like a big advantage, but the downside of this blanket <code class="calibre23">using</code> directive is that it effectively negates the primary reason for using a namespace &mdash; that is, preventing accidental name clashes. There are two ways to access names from a namespace without negating its intended effect. One way is to qualify each name explicitly with the namespace name; however, this can make the code very verbose and reduce its readability. The other possibility is to introduce just the names that you use in your code with <code class="calibre23">using</code> declarations as you have seen in earlier examples, like this for example:</p>
<pre class="calibre28"><code class="calibre23">using std::cout;             // Allows cout usage without qualification
using std::endl;             // Allows endl usage without qualification</code></pre>
<p class="calibre13">Each <code class="calibre23">using</code> declaration introduces a single name from the specified namespace and allows it to be used unqualified within the program code that follows. This can be a better way of importing names from a namespace, as you only import the names you actually use. However, you may find the number of using declarations becomes excessive. Of course, you can define your own namespace that has a name that you choose. The following section shows how.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">You should not use</i> <code class="calibre23">using</code> <i class="calibre15">directives in a headers file because they will apply in all source files that include the header file. You should avoid</i> <code class="calibre23">using</code> <i class="calibre15">declarations at global scope in a header file.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">Declaring a Namespace</h3>
<p class="calibre13">You use the <code class="calibre23">namespace</code> keyword to declare a namespace &mdash; like this:</p>
<pre class="calibre28"><code class="calibre23">namespace myStuff
{
  // Code that I want to have in the namespace myStuff...
}</code></pre>
<p class="calibre13">This defines a namespace with the name <code class="calibre23">myStuff</code>. All name declarations in the code between the braces will be defined within the <code class="calibre23">myStuff</code> namespace. To access any name in this namespace from outside it requires that the name is qualified by the namespace name. Inside the <code class="calibre23">myStuff</code> namespace you just use the unqualified names.</p>
<p class="calibre13">You can’t declare a namespace inside a function. It’s intended to be used the other way around; you use a namespace to contain functions, global variables, and other named entities such as classes. You must not put the definition of <code class="calibre23">main()</code> in a namespace though. <code class="calibre23">main()</code> is where execution starts and it must always be at global scope; otherwise the compiler won’t recognize it.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="85" id="calibre_link-547" class="calibre14"></span>You could define a variable <code class="calibre23">value</code> in a namespace and use it in an example:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex2_10.cpp</b>
<b class="calibre12">// Declaring a namespace</b>
#include &lt;iostream&gt;
         
<b class="calibre12">namespace myStuff</b>
<b class="calibre12">{</b>
  int value {};
<b class="calibre12">}</b>
        
int main()
{
  std::cout &lt;&lt; "enter an integer: ";
  <b class="calibre12">std::cin  &gt;&gt; myStuff::value;</b>
  <b class="calibre12">std::cout &lt;&lt; "\nYou entered " &lt;&lt; myStuff::value</b>
          &lt;&lt; std::endl;
  return 0;
}</code></pre>
<p class="calibre13">The <code class="calibre23">myStuff</code> namespace defines a scope, and every name defined within that scope is qualified by the namespace name. To refer to a name declared within a namespace from outside, you must qualify it with the namespace name. Inside the namespace scope, any of the names within it can be referred to without qualification &mdash; they are all part of the same family. You must qualify the name <code class="calibre23">value</code> with <code class="calibre23">myStuff</code>, the name of the namespace. If not, the program will not compile. <code class="calibre23">main()</code>refers to names in two different namespaces and in general you can have as many namespaces in your program as you need. You could remove the need to qualify <code class="calibre23">value</code> by adding a <code class="calibre23">using</code> directive:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex2_11.cpp</b>
<b class="calibre12">// Using a using directive</b>
#include &lt;iostream&gt;
        
namespace myStuff
{
  int value {};
}
        
<b class="calibre12">using namespace myStuff;            // Make all the names in myStuff available</b>
        
int main()
{
  std::cout &lt;&lt; "enter an integer: ";
  <b class="calibre12">std::cin  &gt;&gt; value;</b>
  <b class="calibre12">std::cout &lt;&lt; "\nYou entered " &lt;&lt; value</b>
          &lt;&lt; std::endl;
  return 0;
}</code></pre>
<p class="calibre13">You could also have a <code class="calibre23">using</code> directive for <code class="calibre23">std</code>. Generally if you use namespaces, you should not add <code class="calibre23">using</code> directives for them throughout your code; otherwise, you might as well not bother with namespaces in the first place. I’ll add a <code class="calibre23">using</code> directive for <code class="calibre23">std</code> in some of the examples to keep the code less cluttered and easier to read. When you are starting out with a new programming language, you can do without clutter, no matter how useful it is in practice.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="86" id="calibre_link-548" class="calibre24"></span>Multiple Namespaces</h3>
<p class="calibre13">A real-world program is likely to involve multiple namespaces. You can have multiple declarations of a namespace with a given name, and the contents of all namespace blocks with the same name are within the same namespace. For example, you might have a program file with two namespaces:</p>
<pre class="calibre28"><code class="calibre23">namespace sortStuff
{
   // Everything in here is within sortStuff namespace
}
        
namespace calculateStuff
{
  // Everything in here is within calculateStuff namespace
  // To refer to names from sortStuff they must be qualified
}
        
namespace sortStuff
{
  // This is a continuation of the namespace sortStuff
  // so from here you can refer to names in the first sortStuff namespace
  // without qualifying them
}</code></pre>
<p class="calibre13">A second declaration of a namespace with a given name is a continuation of the first, so you can reference names in the first namespace block from the second without qualifying them. They are all in the same namespace. Of course, you would not organize a source file in this way deliberately, but it can arise quite naturally with header files. For example, you might have something like this:</p>
<pre class="calibre28"><code class="calibre23">#include &lt;iostream&gt;       // Contents are in namespace std
#include "myheader.h"     // Contents are in namespace myStuff
#include &lt;string&gt;         // Contents are in namespace std
        
// and so on...</code></pre>
<p class="calibre13">Here, <code class="calibre23">iostream</code> and <code class="calibre23">string</code> are standard library headers, and <code class="calibre23">myheader.h</code> represents a header file that contains our program code. You have a situation with the namespaces that is an exact parallel of the previous illustration.</p>
<p class="calibre13">This has given you a basic idea of how namespaces work. There is a lot more to namespaces than I have discussed here, but if you grasp this bit, you should be able to find out more about it when you need to without difficulty.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-257" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">This chapter covered the basics of computation. You have learned about all the fundamental types of data provided for in the language, and all the operators that manipulate these types directly.</p>
<p class="calibre13">Although I have discussed all the fundamental types, don’t be misled into thinking that’s all there is. There are more complex types based on the basic set, as you’ll see, and eventually you will be creating original types of your own.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="87" id="calibre_link-549" class="calibre24"></span>EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Write a program that asks the user to enter a number and then prints it out, using an integer as a local variable.</li>
<li class="calibre6">Write a program that reads an integer value from the keyboard into a variable of type <code class="calibre23">int</code>, and uses one of the bitwise operators (i.e., not the <code class="calibre23">%</code> operator!) to determine the positive remainder when divided by 8. For example, 29 = (3 x 8) + 5 and -14 = (-2 x 8) + 2 have positive remainder 5 and 2, respectively, when divided by 8.</li>
<li class="calibre6">Fully parenthesize the following expressions, in order to show the precedence and associativity:
<pre class="calibre28"><code class="calibre23">   1 + 2 + 3 + 4
        
   16 * 4 / 2 * 3
        
   a &gt; b? a: c &gt; d? e: f
        
   a &amp; b &amp;&amp; c &amp; d</code></pre></li>
<li class="calibre6">Create a program that will calculate the aspect ratio of your computer screen, given the width and height in pixels, using the following statements:
<pre class="calibre28"><code class="calibre23">   int width {1280};
   int height {1024};
        
   double aspect {width / height};</code></pre>
<ol class="none">
<li class="calibre6">When you output the result, what answer will you get? Is it satisfactory &mdash; and if not, how could you modify the code, without adding more variables?</li>
</ol></li>
<li class="calibre6">(Advanced) Without running it, can you work out what value the following code is going to output, and why?
<pre class="calibre28"><code class="calibre23">   unsigned s {555};
        
   int i {static_cast&lt;int&gt;((s &gt;&gt; 4) &amp; ~(~0 &lt;&lt; 3))};
   cout &lt;&lt; i;</code></pre></li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="88" id="calibre_link-550" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">main()</code> function</b></td>
<td class="calibre32">A C++ program consists of one or more functions and must include a global function called <code class="calibre23">main()</code>, which is where execution starts.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The function body</b></td>
<td class="calibre32">The executable part of a function is made up of statements contained between braces.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Statements</b></td>
<td class="calibre32">A statement is terminated by a semicolon and can be spread over several lines.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Names</b></td>
<td class="calibre32">Named objects, such as variables or functions, can have names that consist of a sequence of letters, underscores, and digits, the first of which is a letter or an underscore. Uppercase and lowercase letters are distinguished.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Reserved words</b></td>
<td class="calibre32">Reserved words in C++ are called keywords. You must not use keywords as names for things in your code.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Fundamental types</b></td>
<td class="calibre32">All constants and variables in C++ are of a given type. The fundamental types are <code class="calibre23">char, signed char, unsigned char, wchar_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long, bool, float, double</code>, and <code class="calibre23">long double</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Declarations</b></td>
<td class="calibre32">You define the name and type of a variable in a definition statement that ends with a semicolon. You can also specify initial values for variables in a definition.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">const</code> modifier</b></td>
<td class="calibre32">You can protect the value of a variable by using the <code class="calibre23">const</code> modifier. This prevents direct modification of the variable within the program. Any attempt to modify a <code class="calibre23">const</code> variable will result in a compiler error message.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Automatic variables</b></td>
<td class="calibre32">By default, a variable is automatic, which means that it exists only from the point at which it is declared to the end of the scope in which it is defined, indicated by the first closing brace after its definition.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12"><code class="calibre23">static</code> variables</b></td>
<td class="calibre32">A variable may be declared as <code class="calibre23">static</code>, in which case, it continues to exist for the life of the program. It can be accessed only within the scope in which it was defined.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Global variables</b></td>
<td class="calibre32">Variables can be declared outside of all blocks within a program, in which case, they have global namespace scope. Variables with global namespace scope are accessible throughout a program, except where a local variable exists with the same name as the global variable. Even then, they can still be reached by using the scope resolution operator.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Enumerations</b></td>
<td class="calibre32">An enumeration is a type that you define with a fixed set of values. You should use type-safe enumerations that you define using the keywords <code class="calibre23">enum class</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Namespaces</b></td>
<td class="calibre32">A namespace defines a scope where each of the names declared within it is qualified by the namespace name. Referring to names from outside a namespace requires the names to be qualified. You can access individual objects in a namespace from outside the namespace by using the namespace name to qualify the object name. Alternatively, you can supply a <code class="calibre23">using</code> declaration for each name from the namespace that you want to reference.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="89" id="calibre_link-551" class="calibre14"></span><b class="calibre12">The Stanrd Library</b></td>
<td class="calibre32">The Stanrd Library defines a vast range of functions, operators, and constants that you can use in your programs. Everything in the Stanrd Library is defined in the <code class="calibre23">std</code> namespace.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Lvalues and rvalues</b></td>
<td class="calibre32">Every expression in C++ results in either an lvalue or an rvalue. An lvalue is a persistent address and can appear on the left side of an assignment. Non-<code class="calibre23">const</code> variables are examples of lvalues. Any result that is not an lvalue is an rvalue. This implies that an rvalue cannot be used on the left side of an assignment.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="90" id="calibre_link-552" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-32">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2316" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="91" id="calibre_link-553" class="calibre9"></span><span class="chapternumber">Chapter 3</span><br class="calibre10" /><span class="chapternumber">Decisions and Loops</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How to compare data values</li>
<li class="calibre6">How to alter the sequence of program execution based on the result</li>
<li class="calibre6">How to apply logical operators and expressions</li>
<li class="calibre6">How to deal with multiple choice situations</li>
<li class="calibre6">How to write and use loops in your programs</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 3 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-258" class="calibre3"></a>COMPARING VALUES</h2>
<p class="calibre13">Unless you want to make decisions on a whim, you need a mechanism for comparing things. This involves some new operators called relational operators. Because all information in your computer is ultimately represented by numerical values (in the last chapter you saw how character information is represented by numeric codes), comparing numerical values is the essence of all decision making. You have six operators for comparing two values:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&lt;</code></td>
<td class="calibre32">less than</td>
<td class="calibre32"><code class="calibre23">&lt;=</code></td>
<td class="calibre32">less than or equal to</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&gt;</code></td>
<td class="calibre32">greater than</td>
<td class="calibre32"><code class="calibre23">&gt;=</code></td>
<td class="calibre32">greater than or equal to</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">==</code></td>
<td class="calibre32">equal to</td>
<td class="calibre32"><code class="calibre23">!=</code></td>
<td class="calibre32">not equal to</td>
</tr>
</tbody>
</table>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="92" id="calibre_link-554" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The “equal to” comparison operator has two successive</i> <code class="calibre23">=</code> <i class="calibre15">signs. This is not the same as the assignment operator, which consists only of a single</i> <code class="calibre23">=</code> <i class="calibre15">sign. It’s a common mistake to inadvertently use the assignment operator instead of the comparison operator, so watch out for this.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Each operator compares the values of two operands and returns one of the two possible values of type <code class="calibre23">bool</code>: <code class="calibre23">true</code> if the comparison is true, or <code class="calibre23">false</code> if it is not. You can see how this works by having a look at a few simple examples. The operands can be variables, literals, or expressions. Suppose you have created integer variables <code class="calibre23">i</code> and <code class="calibre23">j</code> with the values 10 and &ndash;5, respectively. The expressions,</p>
<pre class="calibre28"><code class="calibre23">   i &gt; j      i != j      j &gt; -8      i &lt;= j + 15</code></pre>
<p class="calibre13">all return the value <code class="calibre23">true</code>.</p>
<p class="calibre13">Assume that you have defined the following variables:</p>
<pre class="calibre28"><code class="calibre23">char first {'A'}, last {'Z'};</code></pre>
<p class="calibre13">Here are some examples of comparisons using these:</p>
<pre class="calibre28"><code class="calibre23">first == 65      first &lt; last     'E' &lt;= first     first != last</code></pre>
<p class="calibre13">All four expressions compare ASCII code values. The first expression returns <code class="calibre23">true</code> because <code class="calibre23">first</code> was initialized with <code class="calibre23">'A'</code>, which is the equivalent of decimal 65. The second expression checks whether the value of <code class="calibre23">first</code>, which is <code class="calibre23">'A'</code>, is less than the value <code class="calibre23">last</code>, which is <code class="calibre23">'Z'</code>. the ASCII codes for the capital letters are represented by an ascending sequence of numerical values from 65 to 90, 65 representing <code class="calibre23">'A'</code> and 90 representing <code class="calibre23">'Z'</code>, so this comparison also returns the value <code class="calibre23">true</code>. The third expression returns the value <code class="calibre23">false</code> because <code class="calibre23">'E'</code> is greater than the value of <code class="calibre23">first</code>. The last expression returns <code class="calibre23">true</code> because <code class="calibre23">'A'</code> is definitely not equal to <code class="calibre23">'Z'</code>.</p>
<p class="calibre13">Let’s consider some slightly more complicated comparisons with variables defined by the statements:</p>
<pre class="calibre28"><code class="calibre23">int i {-10}, j {20};
double x {1.5}, y {-0.25E-10};</code></pre>
<p class="calibre13">Take a look at the following expressions:</p>
<pre class="calibre28"><code class="calibre23">-1 &lt; y      j &lt; (10 - i)     2.0*x &gt;= (3 + y)</code></pre>
<p class="calibre13">Here you use expressions that result in numerical values as operands. The precedence table for operators that you saw in Chapter 2 shows that none of the parentheses are strictly necessary, but they do help to make the expressions clearer. The first comparison is true, and so returns the <code class="calibre23">bool</code> value <code class="calibre23">true</code>. The variable <code class="calibre23">y</code> has a very small negative value, -0.000000000025, and so is greater than -1. The second comparison returns the value <code class="calibre23">false</code>. The expression <code class="calibre23">10 - i</code> has the value 20, which is the same as <code class="calibre23">j</code>. The third expression returns <code class="calibre23">true</code> because the expression <code class="calibre23">3 + y</code> is slightly less than 3.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="93" id="calibre_link-555" class="calibre14"></span>You can use relational operators to compare values of any of the fundamental types or of the enumeration types, so all you need now is a way of using the results of a comparison to modify the behavior of a program.</p>
<section class="toclist">
<h3 class="calibre21">The if Statement</h3>
<p class="calibre13">The basic <code class="calibre23">if</code> statement allows your program to execute a single statement &mdash; or a block of statements enclosed within braces &mdash; if a given conditional expression evaluates to <code class="calibre23">true</code>, or to skip the statement or block of statements if the condition evaluates to <code class="calibre23">false</code>. This is illustrated in <a id="calibre_link-34" href="#calibre_link-33" class="calibre3">Figure 3-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000153.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-33" href="#calibre_link-34" class="calibre3">FIGURE 3-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">A simple example of an <code class="calibre23">if</code> statement is:</p>
<pre class="calibre28"><code class="calibre23">if('A' == letter)
   cout &lt;&lt; "The first capital, alphabetically speaking.";</code></pre>
<p class="calibre13">The condition to be tested appears in parentheses immediately following the keyword, <code class="calibre23">if</code>, and this is followed by the statement to be executed when the condition is <code class="calibre23">true</code>. Note the position of the semicolon. It goes after the statement <i class="calibre15">following</i> the <code class="calibre23">if</code> and the condition between paren-theses; there shouldn’t be a semicolon after the condition in parentheses because the two lines essentially make up a single statement. You also can see how the line following the <code class="calibre23">if</code> is indented to indicate that it is only executed when the <code class="calibre23">if</code> condition returns the value <code class="calibre23">true</code>. The indentation is not essential, but it helps you to recognize the relationship between the <code class="calibre23">if</code> condition and the statement that depends on it. The output statement in the code fragment is executed only if the variable <code class="calibre23">letter</code> has the value <code class="calibre23">'A'</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="94" id="calibre_link-556" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">When you are comparing a variable to a constant of some kind using the</i> <code class="calibre23">==</code> <i class="calibre15">operator, it is a good idea to write the constant on the left of the</i> <code class="calibre23">==</code> <i class="calibre15">operator, as in</i> <code class="calibre23">'A' == letter</code>. <i class="calibre15">That way, if you accidentally write</i> <code class="calibre23">'A' = letter</code>, <i class="calibre15">you will get an error message from the compiler. If you write</i> <code class="calibre23">letter = 'A'</code>, <i class="calibre15">this is perfectly legal, though not what you intended, and no error message will be produced.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You could extend this example to change the value of <code class="calibre23">letter</code> if it contains the value <code class="calibre23">'A'</code>:</p>
<pre class="calibre28"><code class="calibre23">if('A' == letter)
{
   cout &lt;&lt; "The first capital, alphabetically speaking.";
   letter = 'a';
}</code></pre>
<p class="calibre13">The block of statements that is controlled by the <code class="calibre23">if</code> statement is delimited by the curly braces. You execute the statements in the block only if the condition <code class="calibre23">('A' == letter)</code> evaluates to <code class="calibre23">true</code>. Without the braces, only the first statement would be the subject of the <code class="calibre23">if</code>, and the statement assigning the value <code class="calibre23">'a'</code> to <code class="calibre23">letter</code> would always be executed. Note that there is a semicolon after each of the statements in the block, but not after the closing brace at the end of the block. There can be as many statements as you like within a block. Now, as a result of <code class="calibre23">letter</code> having the value <code class="calibre23">'A'</code>, you change its value to <code class="calibre23">'a'</code> after outputting the same message as before. If the condition returns <code class="calibre23">false</code>, neither of these statements is executed.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Nested if Statements</h3>
<p class="calibre13">The statement to be executed when the condition in an <code class="calibre23">if</code> statement is true can also be an <code class="calibre23">if</code>. This arrangement is called a <i class="calibre15">nested</i> <code class="calibre23">if</code>. The condition for the inner <code class="calibre23">if</code> is only tested if the condition for the outer <code class="calibre23">if</code> is <code class="calibre23">true</code>. An <code class="calibre23">if</code> that is nested inside another can also contain a nested <code class="calibre23">if</code>. You can generally continue nesting <code class="calibre23">if</code>s one inside the other like this for as long as you still know what you are doing.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Nested ifs</h3>
<p class="calibre20">The following is a working example of the nested <code class="calibre23">if</code>:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_01.cpp
// A nested if demonstration
#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main{}
{
  char letter {};                        // Store input in here
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="95" id="calibre_link-557" class="calibre14"></span>  cout &lt;&lt; endl
       &lt;&lt; "Enter a letter: ";           // Prompt for the input
  cin &gt;&gt; letter;                        // then read a character
       
  if(letter &gt;= 'A')                     // Test for 'A' or larger
  {
     if(letter &lt;= 'Z')                  // Test for 'Z' or smaller
     {
        cout &lt;&lt; endl
             &lt;&lt; "You entered a capital letter."
             &lt;&lt; endl;
        return 0;
     }
  }
       
  if(letter &gt;= 'a')                     // Test for 'a' or larger
  {
     if(letter &lt;= 'z')                  // Test for 'z' or smaller
     {
        cout &lt;&lt; endl
             &lt;&lt; "You entered a lowercase letter."
             &lt;&lt; endl;
        return 0;
     }
  }
       
  cout &lt;&lt; endl &lt;&lt; "You did not enter a letter." &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">This program starts with the usual comment lines, then the <code class="calibre23">#include</code> statement for the header file supporting input/output, followed by the <code class="calibre23">using</code> declarations for <code class="calibre23">cin, cout</code>, and <code class="calibre23">endl</code> that are in the <code class="calibre23">std</code> namespace. The first action in the body of <code class="calibre23">main()</code> is to prompt for a letter to be entered. This is stored in the <code class="calibre23">char</code> variable with the name <code class="calibre23">letter</code>.</p>
<p class="calibre20">The <code class="calibre23">if</code> statement that follows the input checks whether the character entered is <code class="calibre23">'A'</code> or larger. The ASCII codes for lowercase letters (97 to 122) are greater than those for uppercase letters (65 to 90). Entering a lowercase letter causes the program to execute the first <code class="calibre23">if</code> block, because <code class="calibre23">(letter &gt;= 'A')</code> returns <code class="calibre23">true</code> for all lowercase letters. In this case, the nested <code class="calibre23">if</code>, which checks for an input of <code class="calibre23">'Z'</code> or less, is executed. If <code class="calibre23">letter</code> is <code class="calibre23">'Z'</code> or less, you know that you have a capital letter, so the appropriate message is displayed, and because there is nothing more to do, you execute a <code class="calibre23">return</code> statement to end the program. Both statements are between braces, so they are both executed when the nested <code class="calibre23">if</code> condition returns <code class="calibre23">true</code>.</p>
<p class="calibre20">The next <code class="calibre23">if</code> checks whether the character entered is lowercase using essentially the same mechanism as the first <code class="calibre23">if</code>, then displays a message and returns.</p>
<p class="calibre20">If the character entered is not a letter, the output statement following the last <code class="calibre23">if</code> block is executed. This displays a message to the effect that the character entered was not a letter. The <code class="calibre23">return</code> is then executed.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="96" id="calibre_link-558" class="calibre14"></span>You can see that the relationship between the nested <code class="calibre23">if</code>s and the output statement is much easier to follow because of the indentation applied to each.</p>
<p class="calibre20">A typical output from this example is:</p>
<pre class="calibre28"><code class="calibre23">Enter a letter: T
You entered a capital letter.</code></pre>
<p class="calibre20">You could easily arrange to change uppercase to lowercase by adding just one extra statement to the <code class="calibre23">if</code>, checking for uppercase:</p>
<pre class="calibre28"><code class="calibre23">   if(letter &gt;= 'A')                  // Test for 'A' or larger
     if(letter &lt;= 'Z')                // Test for 'Z' or smaller
     {
        cout &lt;&lt; endl
             &lt;&lt; "You entered a capital letter." 
             &lt;&lt; endl;
        letter += 'a' - 'A';          // Convert to lowercase
        return 0;
     }
</code></pre>
<p class="calibre20">The statement for converting from uppercase to lowercase increments the <code class="calibre23">letter</code> variable by the value <code class="calibre23">'a' - 'A'</code>. It works because the ASCII codes for <code class="calibre23">'A'</code> to <code class="calibre23">'Z'</code> and <code class="calibre23">'a'</code> to <code class="calibre23">'z'</code> are two groups of consecutive numerical codes, decimal 65 to 90 and 97 to 122, respectively, so the expression <code class="calibre23">'a' - 'A'</code> represents the value to be added to an uppercase letter to get the equivalent lowercase letter and corresponds to 97&ndash;65, which is 32. Thus, if you add 32 to the code value for <code class="calibre23">'K'</code>, which is 75, you get 107, which is the code value for <code class="calibre23">'k'</code>.</p>
<p class="calibre20">You could equally use the equivalent ASCII values for the letters here, but by using the letters you’ve ensured that this code would work on computers where the characters were not ASCII, as long as both the upper- and lowercase sets are represented by a contiguous sequence of numeric values.</p>
<p class="calibre20">There is a standard library function to convert letters to uppercase, so you don’t normally need to program this yourself. It has the name <code class="calibre23">toupper()</code> and appears in the <code class="calibre23">ctype</code> standard header file. You will see more about standard library facilities when you get to look at how functions are written.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">The Extended if Statement</h4>
<p class="calibre13">The <code class="calibre23">if</code> statement that you have been using so far executes a statement if the condition specified returns <code class="calibre23">true</code>. Program execution then continues with the next statement in sequence. You also have a version of the <code class="calibre23">if</code> that allows one statement to be executed if the condition returns <code class="calibre23">true</code>, and a different statement to be executed if the condition returns <code class="calibre23">false</code>. Execution then continues with the next statement in sequence. As you saw in Chapter 2, a block of statements can always replace a single statement, so this also applies to these <code class="calibre23">if</code>s.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="97" id="calibre_link-559" class="calibre24"></span>TRY IT OUT: Extending the if</h3>
<p class="calibre20">Here’s an extended <code class="calibre23">if</code> example:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_02.cpp
// Using the extended if
#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  long number {};                // Store input here
  cout &lt;&lt; endl
       &lt;&lt; "Enter an integer number less than 2 billion: ";
  cin &gt;&gt; number;
       
  if(number % 2L)                // Test remainder after division by 2
     cout &lt;&lt; endl                // Here if remainder 1
          &lt;&lt; "Your number is odd." &lt;&lt; endl;
  else
     cout &lt;&lt; endl                // Here if remainder 0
          &lt;&lt; "Your number is even." &lt;&lt; endl;
       
  return 0;
}</code></pre>
<p class="calibre20">Typical output from this program is:</p>
<pre class="calibre28"><code class="calibre23">Enter an integer less than 2 billion: 123456
Your number is even.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">After reading the input value into <code class="calibre23">number</code>, the value is tested by taking the remainder after division by two (using the remainder operator <code class="calibre23">%</code> that you saw in the previous chapter) and using that as the condition for the <code class="calibre23">if</code>. In this case, the condition of the <code class="calibre23">if</code> statement returns an integer, not a boolean. The <code class="calibre23">if</code> statement interprets a non-zero value returned by the condition as <code class="calibre23">true</code>, and interprets zero as <code class="calibre23">false</code>. In other words, the condition expression for the <code class="calibre23">if</code> statement</p>
<pre class="calibre28"><code class="calibre23">(number % 2L)</code></pre>
<p class="calibre20">is equivalent to</p>
<pre class="calibre28"><code class="calibre23">(number % 2L != 0)</code></pre>
<p class="calibre20">If the remainder is 1, the condition is <code class="calibre23">true</code>, and the statement immediately following the <code class="calibre23">if</code> is executed. If the remainder is 0, the condition is <code class="calibre23">false</code>, and the statement following the <code class="calibre23">else</code> keyword is executed. It’s obvious here what the <code class="calibre23">if</code> expression is doing, but with more complicated expressions it’s better to add the extra few characters needed for the comparison with zero to ensure that the code is easily understood.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="98" id="calibre_link-560" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The condition in an</i> <code class="calibre23">if</code> <i class="calibre15">statement can be an expression that results in a value of any of the fundamental data types that you saw in Chapter 2. When the conditional expression evaluates to a numerical value, the compiler inserts an automatic conversion of the value to type</i> <code class="calibre23">bool</code>. <i class="calibre15">Casting a non-zero value to type</i> <code class="calibre23">bool</code> <i class="calibre15">results in</i> <code class="calibre23">true</code>, <i class="calibre15">and casting a zero value results in</i> <code class="calibre23">false</code>.</p>
<p class="calibre20"><i class="calibre15">The remainder from the division of an integer by two can only be one or zero. After either outcome, the return statement is executed to end the program.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">else</code> <i class="calibre15">keyword is written without a semicolon, similar to the</i> <code class="calibre23">if</code> <i class="calibre15">part of the statement. Again, indentation is used as a visible indicator of the relationship between various statements. You can clearly see which statement is executed for a</i> <code class="calibre23">true</code> <i class="calibre15">or non-zero result, and which for a</i> <code class="calibre23">false</code> <i class="calibre15">or zero result. You should always indent the statements in your programs to show their logical structure.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The <code class="calibre23">if-else</code> combination provides a choice between two options. The general logic of the <code class="calibre23">if-else</code> is shown in <a id="calibre_link-36" href="#calibre_link-35" class="calibre3">Figure 3-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000025.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-35" href="#calibre_link-36" class="calibre3">FIGURE 3-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The arrows in the diagram indicate the sequence in which statements are executed, depending on whether the <code class="calibre23">if</code> condition returns <code class="calibre23">true</code> or <code class="calibre23">false</code>.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Nested if-else Statements</h3>
<p class="calibre13">As you have seen, you can nest <code class="calibre23">if</code> statements within <code class="calibre23">if</code> statements. You can also nest <code class="calibre23">if-else</code> statements within <code class="calibre23">if</code>s, <code class="calibre23">if</code>s within <code class="calibre23">if-else</code> statements, and <code class="calibre23">if-else</code> statements within <code class="calibre23">if-else</code> statements. This provides considerable room for confusion, so let’s take a look at a few examples. The following is an example of an <code class="calibre23">if-else</code> nested within an <code class="calibre23">if</code>:</p>
<pre class="calibre28"><code class="calibre23">if('y' == coffee)
  if('y' == donuts)
    cout &lt;&lt; "We have coffee and donuts.";
  else
    cout &lt;&lt; "We have coffee, but not donuts";</code></pre>
<p class="calibre13">The test for <code class="calibre23">donuts</code> is executed only if the result of the test for <code class="calibre23">coffee</code> returns <code class="calibre23">true</code>, so the messages reflect the correct situation in each case; however, it is easy to get this confused. If you write much the same thing with incorrect indentation, you can be trapped into the wrong conclusion:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="99" id="calibre_link-561" class="calibre14"></span>if('y' == coffee)
  if('y' == donuts)
    cout &lt;&lt; "We have coffee and donuts.";
else                                  // This else is indented incorrectly
  cout &lt;&lt; "We have no coffee...";    // Wrong!</code></pre>
<p class="calibre13">The mistake is easy to see here, but with more complicated <code class="calibre23">if</code> structures you need to keep in mind the rule about which <code class="calibre23">if</code> owns which <code class="calibre23">else</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">An</i> <code class="calibre23">else</code> <i class="calibre15">always belongs to the nearest preceding</i> <code class="calibre23">if</code> <i class="calibre15">that is not already spoken for by another</i> <code class="calibre23">else</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Whenever things look a bit complicated, you can apply this rule to sort things out. When you are writing your own programs you can always use braces to make the situation clearer. It isn’t essential but it’s a good idea to write the last example as follows:</p>
<pre class="calibre28"><code class="calibre23">if('y' == coffee)
{
  if('y' == donuts)
    cout &lt;&lt; "We have coffee and donuts.";
  else
    cout &lt;&lt; "We have coffee, but not donuts";
}</code></pre>
<p class="calibre13">and it should be absolutely clear. Now that you know the rules, understanding the case of an <code class="calibre23">if</code> nested within an <code class="calibre23">if-else</code> becomes easy:</p>
<pre class="calibre28"><code class="calibre23">if('y' == coffee)
{
  if('y' == donuts)
    cout &lt;&lt; "We have coffee and donuts.";
}
else
  if('y' == tea)
    cout &lt;&lt; "We have tea, but not coffee";</code></pre>
<p class="calibre13">Here, the braces are essential. If you leave them out, the <code class="calibre23">else</code> would belong to the second <code class="calibre23">if</code>, which is looking out for <code class="calibre23">donuts</code>. In this kind of situation, it is easy to forget to include the braces and create an error that may be hard to find. A program with this kind of error compiles fine and even produces the right results some of the time.</p>
<p class="calibre13">If you removed the braces in this example, you get the correct results only as long as <code class="calibre23">coffee</code> and <code class="calibre23">donuts</code> are both equal to <code class="calibre23">'y'</code> so that the <code class="calibre23">if('y' == tea)</code> check wouldn’t be executed.</p>
<p class="calibre13"><code class="calibre23">if-else</code> statements nested in <code class="calibre23">if-else</code> statements can get very messy, even with just one level of nesting:</p>
<pre class="calibre28"><code class="calibre23">if('y' == coffee)
  if('y' == donuts)
    cout &lt;&lt; "We have coffee and donuts.";
  else
    cout &lt;&lt; "We have coffee, but not donuts";
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="100" id="calibre_link-562" class="calibre14"></span>else
  if('y' == tea)
    cout &lt;&lt; "We have no coffee, but we have tea, and maybe donuts...";
  else
    cout &lt;&lt; "No tea or coffee, but maybe donuts...";</code></pre>
<p class="calibre13">The logic here doesn’t look quite so obvious, even with the correct indentation. No braces are necessary. The rule you saw earlier verifies that each <code class="calibre23">else</code> belongs to the correct <code class="calibre23">if</code>, but it would be a lot clearer if you included them:</p>
<pre class="calibre28"><code class="calibre23">if('y' == coffee)
{
  if('y' == donuts)
    cout &lt;&lt; "We have coffee and donuts.";
  else
    cout &lt;&lt; "We have coffee, but not donuts";
}
else
{
  if('y' == tea)
    cout &lt;&lt; "We have no coffee, but we have tea, and maybe donuts...";
  else
    cout &lt;&lt; "No tea or coffee, but maybe donuts...";
}</code></pre>
<p class="calibre13">There are much better ways of dealing with this kind of logic in a program. If you put enough nested <code class="calibre23">if</code>s together, you can almost guarantee a mistake somewhere. The next section will help to simplify things.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Logical Operators and Expressions</h3>
<p class="calibre13">As you have just seen, using <code class="calibre23">if</code>s where you have two or more related conditions can be a bit cumbersome. We have tried our <code class="calibre23">if</code>fy talents on looking for coffee and donuts, but in practice you may want to test much more complex conditions.</p>
<p class="calibre13"><i class="calibre15">Logical operators</i> provide a neat and simple solution. Using logical operators, you can combine a series of comparisons into a single logical expression, so you end up needing just one <code class="calibre23">if</code>, virtually regardless of the complexity of the set of conditions, as long as the decision ultimately boils down to a choice between two possibilities &mdash; true or false.</p>
<p class="calibre13">You have just three logical operators:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&amp;&amp;</code></td>
<td class="calibre32">Logical AND</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">||</code></td>
<td class="calibre32">Logical OR</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">!</code></td>
<td class="calibre32">Logical negation (NOT)</td>
</tr>
</tbody>
</table>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="101" id="calibre_link-563" class="calibre14"></span>Logical AND</h4>
<p class="calibre13">You would use the AND operator, <code class="calibre23">&amp;&amp;</code>, where you have two conditions that must both be <code class="calibre23">true</code> for a <code class="calibre23">true</code> result. You want to be rich <i class="calibre15">and</i> healthy. Thus the <code class="calibre23">&amp;&amp;</code> operator produces the result <code class="calibre23">true</code> when both operands have the value <code class="calibre23">true</code>, and <code class="calibre23">false</code> otherwise.</p>
<p class="calibre13">You could use the <code class="calibre23">&amp;&amp;</code> operator when you are testing a character to determine whether it’s an uppercase letter; the value being tested must be both greater than or equal to <code class="calibre23">'A'</code> and less than or equal to <code class="calibre23">'Z'</code>. Both conditions must return <code class="calibre23">true</code> for the value to be a capital letter.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">As before, the conditions you combine using logical operators may return numerical values. Remember that a non-zero value converts to the value</i> <code class="calibre23">true</code>; <i class="calibre15">zero converts to</i> <code class="calibre23">false</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Taking the example of a value stored in a <code class="calibre23">char</code> variable <code class="calibre23">letter</code>, you could replace the test that uses two <code class="calibre23">if</code>s with one that uses only a single <code class="calibre23">if</code> and the <code class="calibre23">&amp;&amp;</code> operator:</p>
<pre class="calibre28"><code class="calibre23">if((letter &gt;= 'A') &amp;&amp; (letter &lt;= 'Z'))
  cout &lt;&lt; "This is a capital letter.";</code></pre>
<p class="calibre13">The parentheses inside the expression that is the <code class="calibre23">if</code> condition ensure that there is no doubt that the comparison operations are executed first, which makes the statement clearer. Here, the output statement is executed only if <i class="calibre15">both</i> of the conditions that are combined by the <code class="calibre23">&amp;&amp;</code> operator are <code class="calibre23">true</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">If the left operand for the</i> <code class="calibre23">&amp;&amp;</code> <i class="calibre15">operator is</i> <code class="calibre23">false</code>, <i class="calibre15">the right operand will not be evaluated. This becomes significant if the right operand is an expression that can change something, such as an expression involving the</i> <code class="calibre23">++</code> <i class="calibre15">or</i> <code class="calibre23">--</code> <i class="calibre15">operator. For example, in the expression</i> <code class="calibre23">x&gt;=5 &amp;&amp; ++n&lt;10, n</code> <i class="calibre15">will not be incremented if</i> <code class="calibre23">x</code> <i class="calibre15">is less than</i> <code class="calibre23">5</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Logical OR</h4>
<p class="calibre13">The OR operator, <code class="calibre23">||</code>, applies when you have two conditions where you want a <code class="calibre23">true</code> result if either or both of them are <code class="calibre23">true</code>. For example, you might be considered credit worthy for a loan from the bank if your income was at least $100,000 a year, or if you had $1,000,000 in cash. This could be tested using the following <code class="calibre23">if</code>:</p>
<pre class="calibre28"><code class="calibre23">if((income &gt;= 100000.00) || (capital &gt;= 1000000.00))
  cout &lt;&lt; "How much would you like to borrow, Sir (grovel, grovel)?";</code></pre>
<p class="calibre13">The ingratiating response emerges when either or both of the conditions are <code class="calibre23">true</code>. (A better response might be, “Why do you want to borrow?” It’s strange how banks lend you money only if you don’t need it.)</p>
<p class="calibre13">You only get a <code class="calibre23">false</code> result with the <code class="calibre23">||</code> operator when both operands are <code class="calibre23">false</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="102" id="calibre_link-564" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">If the left operand for the</i> <code class="calibre23">||</code> <i class="calibre15">operator is</i> <code class="calibre23">true</code>, <i class="calibre15">the right operand will not be evaluated. For example, in the expression</i> <code class="calibre23">x&gt;=5 || ++n&lt;10</code>, <i class="calibre15">the variable</i> <code class="calibre23">n</code> <i class="calibre15">will not be incremented if</i> <code class="calibre23">x</code> <i class="calibre15">is greater than or equal to 5.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Logical NOT</h4>
<p class="calibre13">The third logical operator, <code class="calibre23">!</code>, takes one operand of type <code class="calibre23">bool</code> and inverts its value. So, if the value of a variable <code class="calibre23">test</code> is <code class="calibre23">true, !test</code> is <code class="calibre23">false</code>; and if <code class="calibre23">test</code> is <code class="calibre23">false, !test</code> is <code class="calibre23">true</code>. To take the example of a simple expression, if <code class="calibre23">x</code> has the value 10, the expression <code class="calibre23">!(x &gt; 5)</code> evaluates to <code class="calibre23">false</code>, because <code class="calibre23">x &gt; 5</code> is <code class="calibre23">true</code>.</p>
<p class="calibre13">You could also apply the <code class="calibre23">!</code> operator in an expression that was a favorite of Charles Dickens’:</p>
<pre class="calibre28"><code class="calibre23">!(income &gt; expenditure)</code></pre>
<p class="calibre13">If this expression is <code class="calibre23">true</code>, the result is misery, at least as soon as the bank starts bouncing your checks.</p>
<p class="calibre13">Finally, you can apply the <code class="calibre23">!</code> operator to other basic data types. Suppose you have a variable, <code class="calibre23">rate</code>, that is of type <code class="calibre23">float</code> and has the value 3.2. For some reason, you might want to verify that the value of <code class="calibre23">rate</code> is non-zero, in which case you could use the expression:</p>
<pre class="calibre28"><code class="calibre23">!(rate)</code></pre>
<p class="calibre13">The value 3.2 is non-zero and thus converts to the <code class="calibre23">bool</code> value <code class="calibre23">true</code>, so the result of this expression is <code class="calibre23">false</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Combining Logical Operators</h3>
<p class="calibre20">You can combine conditional expressions and logical operators to any degree that you feel comfortable with. For example, using just a single <code class="calibre23">if</code>, you could construct a test for whether a variable contained a letter. Let’s write it as a working example:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_03.cpp
// Testing for a letter using logical operators
#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  char letter {};                                   // Store input in here
        
  cout &lt;&lt; endl
       &lt;&lt; "Enter a character: ";
  cin &gt;&gt; letter;
        
  if(((letter &gt;= 'A') &amp;&amp; (letter &lt;= 'Z')) ||
      ((letter &gt;= 'a') &amp;&amp; (letter &lt;= 'z')))         // Test for alphabetic
    cout &lt;&lt; endl
         &lt;&lt; "You entered a letter." &lt;&lt; endl;
  else
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="103" id="calibre_link-565" class="calibre14"></span>    cout &lt;&lt; endl
         &lt;&lt; "You didn't enter a letter." &lt;&lt; endl;
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">This starts out in the same way as <code class="calibre23">Ex3_01.cpp</code>, by reading a character after a prompt for input. The interesting part of the program is in the <code class="calibre23">if</code> statement condition. This consists of two logical expressions combined with the <code class="calibre23">||</code> (OR) operator, so that if either is <code class="calibre23">true</code>, the condition returns <code class="calibre23">true</code> and the following message is displayed:</p>
<pre class="calibre28"><code class="calibre23">You entered a letter.</code></pre>
<p class="calibre20">If both logical expressions are <code class="calibre23">false</code>, the <code class="calibre23">else</code> statement is executed, which displays this message:</p>
<pre class="calibre28"><code class="calibre23">You didn't enter a letter.</code></pre>
<p class="calibre20">Each logical expression combines a pair of comparisons with the operator <code class="calibre23">&amp;&amp;</code> (AND), so both comparisons must return <code class="calibre23">true</code> if the expression is to be <code class="calibre23">true</code>. The first logical expression returns <code class="calibre23">true</code> if the input is an uppercase letter, and the second returns <code class="calibre23">true</code> if the input is a lowercase letter.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">The Conditional Operator</h3>
<p class="calibre13">The conditional operator is sometimes called the ternary operator because it involves three operands. It is best understood by looking at an example. Suppose you have two variables, <code class="calibre23">a</code> and <code class="calibre23">b</code>, and you want to assign the maximum of <code class="calibre23">a</code> and <code class="calibre23">b</code> to a third variable, <code class="calibre23">c</code>. You can do this with the following statement:</p>
<pre class="calibre28"><code class="calibre23">c = a &gt; b ? a : b;           // Set c to the maximum of a or b</code></pre>
<p class="calibre13">The first operand for the conditional operator must be an expression that results in a <code class="calibre23">bool</code> value, <code class="calibre23">true</code> or <code class="calibre23">false</code>, and in this case it is <code class="calibre23">a &gt; b</code>. If this expression returns <code class="calibre23">true</code>, the second operand &mdash; in this case <code class="calibre23">a</code> &mdash; is selected as the value resulting from the operation. If the first argument returns <code class="calibre23">false</code>, the third operand &mdash; in this case <code class="calibre23">b</code> &mdash; is selected as the value that results from the operation. Thus, the result of <code class="calibre23">a &gt; b ? a : b</code> is <code class="calibre23">a</code>, if <code class="calibre23">a</code> is greater than <code class="calibre23">b</code>, and <code class="calibre23">b</code> otherwise. This value is stored in <code class="calibre23">c</code> by the assignment operation. The use of the conditional operator in this assignment statement is equivalent to the <code class="calibre23">if</code> statement:</p>
<pre class="calibre28"><code class="calibre23">if(a &gt; b)
  c = a;
else
  c = b;</code></pre>
<p class="calibre13">The conditional operator can be written generally as:</p>
<pre class="calibre28"><code class="calibre23">condition ? expression1 : expression2</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="104" id="calibre_link-566" class="calibre14"></span>If <code class="calibre23">condition</code> evaluates to <code class="calibre23">true</code>, the result is the value of <code class="calibre23">expression1</code>, and if it evaluates to <code class="calibre23">false</code>, the result is the value of <code class="calibre23">expression2</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using the Conditional Operator with Output</h3>
<p class="calibre20">A common use of the conditional operator is to control output based on the result of an expression or the value of a variable. You can vary a message by selecting one text string or another, depending on the condition specified:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_04.cpp
// The conditional operator selecting output
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
int main()
{
  int nCakes {1};           // Count of number of cakes
        
  cout &lt;&lt; endl
       &lt;&lt; "We have " &lt;&lt; nCakes &lt;&lt; " cake" &lt;&lt; ((nCakes &gt; 1) ? "s." : ".")
       &lt;&lt; endl;
        
  ++nCakes;
        
  cout &lt;&lt; endl
       &lt;&lt; "We have " &lt;&lt; nCakes &lt;&lt; " cake" &lt;&lt; ((nCakes &gt; 1) ? "s." : ".")
       &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">The output from this program is:</p>
<pre class="calibre28"><code class="calibre23">We have 1 cake.
We have 2 cakes.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You first create the <code class="calibre23">nCakes</code> variable with the initial value 1; then you have an output statement that shows the number of cakes. The part that uses the conditional operator simply tests the variable to determine whether you have a singular cake or several cakes:</p>
<pre class="calibre28"><code class="calibre23"> ((nCakes &gt; 1) ? "s." : ".")</code></pre>
<p class="calibre20">This expression evaluates to <code class="calibre23">"s."</code> if <code class="calibre23">nCakes</code> is greater than 1, or <code class="calibre23">"."</code> otherwise. This enables you to use the same output statement for any number of cakes and get grammatically correct output. You make use of this in the example by incrementing the <code class="calibre23">nCakes</code> variable and repeating the output statement.</p>
<p class="calibre20">There are many other situations where you can apply this sort of mechanism; selecting between <code class="calibre23">"is"</code> and <code class="calibre23">"are"</code>, for example.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="105" id="calibre_link-567" class="calibre24"></span>The switch Statement</h3>
<p class="calibre13">The <code class="calibre23">switch</code> statement enables you to select from multiple choices based on a set of fixed values for a given expression. It operates like a physical rotary switch in that you can select one of a number of choices. Some washing machines provide a means of choosing an operation for processing your laundry in this way. There are a number of possible positions for the switch, such as cotton, wool, synthetic fiber, and so on, and you can select one of them by turning the knob to point to the option you want.</p>
<p class="calibre13">In the <code class="calibre23">switch</code> statement, the selection is determined by the value of an expression that you specify. You define the possible <code class="calibre23">switch</code> positions by one or more case values, a particular one being selected if the value of the <code class="calibre23">switch</code> expression is the same as the particular case value. There is one case value for each possible choice in the <code class="calibre23">switch</code>, and all the case values must be distinct.</p>
<p class="calibre13">The general form of the <code class="calibre23">switch</code> statement is:</p>
<pre class="calibre28"><code class="calibre23">switch(expression)
{
case c1:
  // One or more statements for c1...
  break;
case c2:
  // One or more statements for c2...
  break;
// More case statements...
default:
  // Statements for default case...
  break;
}</code></pre>
<p class="calibre13">Both <code class="calibre23">switch</code> and <code class="calibre23">case</code> are keywords. <code class="calibre23">c1, c2</code>, and so on are integer constants, or expressions that the compiler can evaluate to produce an integer constant; that is, not an expression that has to be executed at run time. The cases can be in any sequence and each case value must be unique to allow the compiler to differentiate between them. When <code class="calibre23">expression</code> evaluates to one of the case values, the statements following that case statement are executed.</p>
<p class="calibre13">If the value of the <code class="calibre23">switch</code> expression does not match any of the case values, the <code class="calibre23">switch</code> automatically selects the <code class="calibre23">default</code> case. You can omit the <code class="calibre23">default</code> case, in which case the default is to do nothing.</p>
<p class="calibre13">The <code class="calibre23">break</code> statement at the end of each case statement causes execution to transfer to the statement following the <code class="calibre23">switch</code> block after a case statement executes. If you leave it out, statements for the next case will execute. The <code class="calibre23">break</code> at the end of the <code class="calibre23">default</code> case is not necessary, but including it is a good idea to provide for the possibility that you add a <code class="calibre23">case</code> statement after the <code class="calibre23">default</code> case later. Let’s see it working.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: The switch Statement</h3>
<p class="calibre20">You can examine how the <code class="calibre23">switch</code> statement works with the following example:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_05.cpp
// Using the switch statement
#include &lt;iostream&gt;
        
using std::cin;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="106" id="calibre_link-568" class="calibre14"></span>using std::cout;
using std::endl;
        
int main()
{
  int choice {};                     // Store selection value here
        
  cout &lt;&lt; endl
       &lt;&lt; "Your electronic recipe book is at your service." &lt;&lt; endl
       &lt;&lt; "You can choose from the following delicious dishes: "
       &lt;&lt; endl
       &lt;&lt; endl &lt;&lt; "1 Boiled eggs"
       &lt;&lt; endl &lt;&lt; "2 Fried eggs"
       &lt;&lt; endl &lt;&lt; "3 Scrambled eggs"
       &lt;&lt; endl &lt;&lt; "4 Coddled eggs"
       &lt;&lt; endl &lt;&lt; endl &lt;&lt; "Enter your selection number: ";
  cin &gt;&gt; choice;
        
  switch(choice)
  {
  case 1: cout &lt;&lt; endl &lt;&lt; "Boil some eggs." &lt;&lt; endl;
          break;
  case 2: cout &lt;&lt; endl &lt;&lt; "Fry some eggs." &lt;&lt; endl;
          break;
  case 3: cout &lt;&lt; endl &lt;&lt; "Scramble some eggs." &lt;&lt; endl;
           break;
  case 4: cout &lt;&lt; endl &lt;&lt; "Coddle some eggs." &lt;&lt; endl;
          break;
  default: cout &lt;&lt; endl &lt;&lt;"You entered a wrong number, try raw eggs."
                &lt;&lt; endl;
           break;
  }
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The stream output statement displays the input options, and then a selection number is read into the variable <code class="calibre23">choice</code>. The <code class="calibre23">switch</code> statement has the condition specified as simply <code class="calibre23">choice</code>, in parentheses, immediately following the keyword <code class="calibre23">switch</code>. The possible options in the <code class="calibre23">switch</code> are enclosed between braces and are each identified by a <i class="calibre15">case label</i>. A case label is the keyword <code class="calibre23">case</code>, followed by the value of <code class="calibre23">choice</code> that corresponds to this option, and terminated by a colon.</p>
<p class="calibre20">As you can see, the statements to be executed for a particular <code class="calibre23">case</code> follow the colon at the end of the case label, and are terminated by a <code class="calibre23">break</code> statement. The <code class="calibre23">break</code> transfers execution to the statement after the <code class="calibre23">switch</code>. The <code class="calibre23">break</code> isn’t mandatory, but if you don’t include it, execution continues with the statements for the case that follows, which isn’t usually what you want. You can demonstrate this by removing the <code class="calibre23">break</code> statements from this example and seeing what happens.</p>
<p class="calibre20">You can put the statements to be executed for a particular case between braces and sometimes this is necessary. For example, if you create a variable within a case statement, you must include braces. The following statement will result in an error message:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="107" id="calibre_link-569" class="calibre14"></span>switch(choice)
{
case 1:
  int count {2};
  cout &lt;&lt; "Boil " &lt;&lt; count
       &lt;&lt; " eggs." &lt;&lt; endl;
  // Code to do something with count...
  break;
        
default:
  cout &lt;&lt; endl &lt;&lt;"You entered a wrong number, try raw eggs." &lt;&lt; endl;
  break;
}</code></pre>
<p class="calibre20">Because it is possible that <code class="calibre23">count</code> may not get initialized within the block for the <code class="calibre23">switch</code>, you get the following error message:</p>
<pre class="calibre28"><code class="calibre23">error C2360: initialization of 'count' is skipped by 'default' label
</code></pre>
<p class="calibre20">You can fix this by writing it as:</p>
<pre class="calibre28"><code class="calibre23">switch(choice)
{
case 1:
  {
    int count {2};
    cout &lt;&lt; "Boil " &lt;&lt; count
         &lt;&lt; " eggs." &lt;&lt; endl;
    // Code to do something with count...
    break;
  }
        
default:
  cout &lt;&lt; endl &lt;&lt;"You entered a wrong number, try raw eggs." &lt;&lt; endl;
  break;
}</code></pre>
<p class="calibre20">If the value of <code class="calibre23">choice</code> doesn’t correspond with any of the case values, the statements following the <code class="calibre23">default</code> label are executed. A <code class="calibre23">default</code> case isn’t essential. In its absence, if the value of the test expression doesn’t correspond to any of the cases, the <code class="calibre23">switch</code> is exited, and the program continues with the next statement after the <code class="calibre23">switch</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Sharing a Case</h3>
<p class="calibre20">Each of the case expressions in a <code class="calibre23">switch</code> statement must be constant expressions that can be evaluated at compile time and must evaluate to a unique integer value. The reason that no two case values can be the same is that the compiler would have no way of knowing which case statement should be executed for that particular value; however, different cases don’t need to have a unique action. Several cases can share the same action, as shown here:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_06.cpp
// Multiple case actions
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="108" id="calibre_link-570" class="calibre14"></span>#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  char letter {};
  cout &lt;&lt; endl
       &lt;&lt; "Enter a small letter: ";
  cin &gt;&gt; letter;
      
  switch(letter*(letter &gt;= 'a' &amp;&amp; letter &lt;= 'z'))
  {
   case 'a':  case 'e': case 'i': case 'o': case 'u':
     cout &lt;&lt; endl &lt;&lt; "You entered a vowel.";
     break;
      
   case 0:
     cout &lt;&lt; endl &lt;&lt; "That is not a small letter.";
     break;
      
   default: cout &lt;&lt; endl &lt;&lt; "You entered a consonant.";
  }
        
  cout &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">In this example, you have a more complex expression in the <code class="calibre23">switch</code>. If the character entered isn’t a lowercase letter, the expression</p>
<pre class="calibre28"><code class="calibre23"> (letter &gt;= 'a' &amp;&amp; letter &lt;= 'z')</code></pre>
<p class="calibre20">results in the value <code class="calibre23">false</code>; otherwise it evaluates to <code class="calibre23">true</code>. Because <code class="calibre23">letter</code> is multiplied by this expression, the value of the logical expression is converted to an integer &mdash; 0 if the logical expression is <code class="calibre23">false</code> and 1 if it is <code class="calibre23">true</code>. Thus, the <code class="calibre23">switch</code> expression evaluates to 0 if a lowercase letter was not entered, and to the value of <code class="calibre23">letter</code> if it was. The statements following the case label <code class="calibre23">case 0</code> are executed whenever the character code stored in <code class="calibre23">letter</code> does not represent a lowercase letter.</p>
<p class="calibre20">If a lowercase letter was entered, the <code class="calibre23">switch</code> expression evaluates to the same value as <code class="calibre23">letter</code>; so, for all values corresponding to vowels, the output statement following the sequence of case labels that have vowels as values is executed. The same statement executes for any vowel because when any of these case labels is chosen, the following statements are executed until the <code class="calibre23">break</code> statement is reached. You can see that a single action can be taken for a number of different cases by writing the case labels, one after the other, before the statements to be executed. If a lowercase letter that is a consonant is entered, the <code class="calibre23">default</code> case is executed.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="109" id="calibre_link-571" class="calibre24"></span>Unconditional Branching</h3>
<p class="calibre13">The <code class="calibre23">if</code> statement provides you with the flexibility to choose to execute one set of statements or another, depending on a specified condition, so the statement execution sequence is varied, depending on the values of the data in the program. The <code class="calibre23">goto</code> statement, in contrast, is a blunt instrument. It enables you to branch to a specified program statement unconditionally. The statement to be branched to must be identified by a statement label, which is an identifier defined according to the same rules as a variable name. This is followed by a colon and placed before the statement requiring labeling. Here is an example of a labeled statement:</p>
<pre class="calibre28"><code class="calibre23">myLabel: cout &lt;&lt; "myLabel branch has been activated" &lt;&lt; endl;</code></pre>
<p class="calibre13">This statement has the label <code class="calibre23">myLabel</code>, and an unconditional branch to this statement would be written as follows:</p>
<pre class="calibre28"><code class="calibre23">goto myLabel;</code></pre>
<p class="calibre13">Whenever possible, you should avoid using <code class="calibre23">goto</code>s in your program. They tend to encourage convoluted code that can be extremely difficult to follow.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Because the</i> <code class="calibre23">goto</code> <i class="calibre15">is theoretically unnecessary in a program &mdash; there’s always an alternative approach to using</i> <code class="calibre23">goto</code> &mdash; <i class="calibre15">a significant cadre of programmers say you should never use it. I don’t subscribe to such an extreme view. It is a legal statement, after all, and there are occasions when it can be convenient, such as when you must exit from a deeply nested set of loops (you learn about loops in the next section). I do, however, recommend that you only use it where you can see an obvious advantage over other options that are available; otherwise, you may end up with convoluted, error-prone code that is hard to understand and even harder to maintain.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-259" class="calibre3"></a>REPEATING A BLOCK OF STATEMENTS</h2>
<p class="calibre13">The capability to repeat a group of statements is fundamental to most applications. Without this, an organization would need to modify the payroll program every time an extra employee was hired, and you would need to reload your favorite game every time you wanted to play. So, let’s first understand how a loop works.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="110" id="calibre_link-572" class="calibre24"></span>What Is a Loop?</h3>
<p class="calibre13">A loop executes a sequence of statements subject to a given condition. You can write a loop with the statements that you have met so far. You just need an <code class="calibre23">if</code> and the dreaded <code class="calibre23">goto</code>. Look at the following example:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_07.cpp
// Creating a loop with an if and a goto
#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
int main()
{
  int i {1}, sum {};
  const int max {10};
        
loop:
  sum += i;             // Add current value of i to sum
  if(++i &lt;= max)
     goto loop;         // Go back to loop until i = 11
        
  cout &lt;&lt; endl
       &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl
       &lt;&lt; "i = "   &lt;&lt; i   &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre13">This example accumulates the sum of integers from 1 to 10. The first time through the sequence of statements, <code class="calibre23">i</code> has the initial value 1 and is added to <code class="calibre23">sum</code>, which starts out as zero. In the <code class="calibre23">if, i</code> is incremented to 2 and, as long as it is less than or equal to <code class="calibre23">max</code>, the unconditional branch to <code class="calibre23">loop</code> occurs, and the value of <code class="calibre23">i</code>, now 2, is added to <code class="calibre23">sum</code>. This continues with <code class="calibre23">i</code> being incremented and added to <code class="calibre23">sum</code> each time, until finally, when <code class="calibre23">i</code> is incremented to 11 in the <code class="calibre23">if</code>, the branch back is not executed. If you run this example, you get the following output:</p>
<pre class="calibre28"><code class="calibre23">sum = 55
i = 11</code></pre>
<p class="calibre13">This shows quite clearly how the loop works; however, it uses a <code class="calibre23">goto</code> and introduces a label into the program, both of which you should avoid, if possible. You can achieve the same thing, and more, with the <code class="calibre23">for</code> statement, which is specifically for writing a loop.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using the for Loop</h3>
<p class="calibre20">You can rewrite the last example using what is known as a <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex3_08.cpp</b>
<b class="calibre12">// Summing integers with a for loop</b>
#include &lt;iostream&gt;
   
 
using std::cout;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="111" id="calibre_link-573" class="calibre14"></span>using std::endl;
        
int main()
{
  int i {1}, sum {};
  const int max {10};
        
  <b class="calibre12">for(i = 1; i &lt;= max; i++)       // Loop specification</b>
     <b class="calibre12">sum += i;                    // Loop statement</b>
        
  cout &lt;&lt; endl
       &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl
       &lt;&lt; "i = "   &lt;&lt; i   &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">If you compile and run this, you get exactly the same output as the previous example, but the code is much simpler here. The conditions determining the operation of the loop appear in parentheses after the keyword <code class="calibre23">for</code>. There are three expressions that appear within the parentheses, separated by semicolons:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The first expression executes once at the outset and sets the initial conditions for the loop. In this case, it sets <code class="calibre23">i</code> to 1.</li>
<li class="calibre6">The second expression is a logical expression that determines whether the loop statement (or block of statements) should continue to be executed. If the second expression is <code class="calibre23">true</code>, the loop continues to execute; when it is <code class="calibre23">false</code>, the loop ends, and execution continues with the statement that follows the loop. In this case, the loop statement on the following line is executed as long as <code class="calibre23">i</code> is less than or equal to <code class="calibre23">max</code>.</li>
<li class="calibre6">The third expression is evaluated after the loop statement (or block of statements) executes, and in this case increments <code class="calibre23">i</code> at each iteration. After this expression has been evaluated, the second expression is evaluated once more to see whether the loop should continue.</li>
</ul>
<p class="calibre20">This loop is not exactly the same as the version in <code class="calibre23">Ex3_07.cpp</code>. You can demonstrate this if you set the value of <code class="calibre23">max</code> to 0 in both programs and run them again; then, you will find that the value of <code class="calibre23">sum</code> is 1 in <code class="calibre23">Ex3_07.cpp</code> and 0 in <code class="calibre23">Ex3_08.cpp</code>, and the value of <code class="calibre23">i</code> differs too. The reason for this is that the <code class="calibre23">if</code> version of the program always executes the loop at least once, because you don’t check the condition until the end. The <code class="calibre23">for</code> loop doesn’t do this, because the condition is checked at the beginning.</p>
<p class="calibre20">The general form of the <code class="calibre23">for</code> loop is:</p>
<pre class="calibre28"><code class="calibre23">for (initializing_expression ; test_expression ; increment_expression)
     loop_statement;</code></pre>
<p class="calibre20">Of course, <code class="calibre23">loop_statement</code> can be a single statement, or a block of statements between braces. The sequence of events in executing the <code class="calibre23">for</code> loop is shown in <a id="calibre_link-38" href="#calibre_link-37" class="calibre3">Figure 3-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000052.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-37" href="#calibre_link-38" class="calibre3">FIGURE 3-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="112" id="calibre_link-574" class="calibre14"></span>The expressions controlling the <code class="calibre23">for</code> loop are very flexible. You can even write two or more expressions, separated by the comma operator, for each control expression. This gives you a lot of scope in what you can do with a <code class="calibre23">for</code> loop.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The more mathematically minded will know that you can sum the first n integers without using a loop. The sum of the integers from 1 to n is given by the expression ½n(n+1). Using this wouldn’t teach you much about loops though.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Variations on the for Loop</h3>
<p class="calibre13">Most of the time, the expressions in a <code class="calibre23">for</code> loop are used in a fairly standard way: the first to initialize one or more loop counters, the second to test if the loop should continue, and the third to increment or decrement one or more loop counters. You are not obliged to use these expressions in this way, however, and quite a few variations are possible.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="113" id="calibre_link-575" class="calibre14"></span>The initialization expression can also include a definition for a loop variable. In the previous example, you could have written the loop to include the definition for the loop counter <code class="calibre23">i</code> in the first control expression.</p>
<pre class="calibre28"><code class="calibre23">for(int i {1}; i &lt;= max; i++)         // Loop specification
   sum += i;                          // Loop statement</code></pre>
<p class="calibre13">Naturally, the original definition for <code class="calibre23">i</code> would need to be omitted. If you make this change to the last example, you will find that it does not compile because the loop variable, <code class="calibre23">i</code>, ceases to exist after the loop, so you cannot refer to it in the output statement. A loop has a scope which extends from the <code class="calibre23">for</code> expression to the end of the body of the loop, which of course can be a block of code between braces, as well as just a single statement. The counter <code class="calibre23">i</code> is now defined within the loop scope, so you cannot refer to it in the output statement, which is outside the scope of the loop. If you need to use the value in the counter after the loop has executed, you must define the counter variable <i class="calibre15">outside the scope of the loop</i>.</p>
<p class="calibre13">You can omit the initialization expression altogether from the loop. Because <code class="calibre23">i</code> has the initial value 1, you can write the loop as:</p>
<pre class="calibre28"><code class="calibre23">for(; i &lt;= max; i++)                  // Loop specification
   sum += i;                          // Loop statement</code></pre>
<p class="calibre13">You still need the semicolon that separates the initialization expression from the test condition. In fact, both semicolons must always be present, regardless of whether any or all of the control expressions are omitted. If you omit the first semicolon, the compiler is unable to decide which expression has been omitted, or even which semicolon is missing.</p>
<p class="calibre13">The loop statement can be empty. For example, you could place the loop statement in the <code class="calibre23">for</code> loop from the previous example inside the increment expression; in this case the loop becomes:</p>
<pre class="calibre28"><code class="calibre23">for(; i &lt;= max; sum += i++);     // The whole loop</code></pre>
<p class="calibre13">You still need the semicolon after the closing parentheses, to indicate that the loop statement is now empty. If you omit this, the statement immediately following this line is interpreted as the loop statement. Sometimes you’ll see the empty loop statement written on a separate line, like the following:</p>
<pre class="calibre28"><code class="calibre23">for(; i &lt;= max; sum += i++)     // The whole loop
  ;</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Multiple Counters</h3>
<p class="calibre20">You can use the comma operator to include multiple counters in a <code class="calibre23">for</code> loop. You can see this in operation in the following program:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_09.cpp
// Using multiple counters to show powers of 2
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
        
 
using std::cout;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="114" id="calibre_link-576" class="calibre14"></span>using std::endl;
using std::setw;
        
int main()
{
  const long max {10L};
        
  for(long i {}, power {1L}; i &lt;= max; i++, power += power)
     cout &lt;&lt; endl
          &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; setw(10) &lt;&lt; power;     // Loop statement
        
  cout &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You create and initialize two variables in the initialization section of the <code class="calibre23">for</code> loop and increment each of them in the increment section. You can create as many variables as you want here, as long as they are of the same type.</p>
<p class="calibre20">You can also specify multiple conditions, separated by commas, in the second expression that represents the test part of the <code class="calibre23">for</code> loop that determines whether it should continue, but this is not generally useful because only the right-most condition affects when the loop ends.</p>
<p class="calibre20">For each increment of <code class="calibre23">i</code>, the value of the variable <code class="calibre23">power</code> is doubled by adding it to itself. This produces the powers of two that we are looking for, and so the program produces the following output:</p>
<pre class="calibre28"><code class="calibre23">         0         1
         1         2
         2         4
         3         8
         4        16
         5        32
         6        64
         7       128
         8       256
         9       512
        10      1024</code></pre>
<p class="calibre20">You use the <code class="calibre23">setw()</code> manipulator that you saw in the previous chapter to align the output nicely. You have included the <code class="calibre23">iomanip</code> header file and added a using declaration for the name in the <code class="calibre23">std</code> namespace, so you can use <code class="calibre23">setw()</code> without qualifying the name.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: The Indefinite for Loop</h3>
<p class="calibre20">If you omit the second control expression that specifies the test condition for a <code class="calibre23">for</code> loop, the value is assumed to be <code class="calibre23">true</code>, so the loop continues indefinitely unless you provide some other means of exiting from it. In fact, you can omit all the expressions in the parentheses after <code class="calibre23">for</code>. This may not seem to be useful, but the reverse is true. You will often come across situations where you want to execute a loop a number of times, but you do not know in advance how many iterations you will need. Have a look at the following:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="115" id="calibre_link-577" class="calibre14"></span>// Ex3_10.cpp
// Using an indefinite for loop to compute an average
#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  double value {};                  // Value entered stored here
  double sum {};                    // Total of values accumulated here
  int i {};                         // Count of number of values
  char indicator {'n'};             // Continue or not?
        
  for(;;)                           // Indefinite loop
{
     cout &lt;&lt; endl
          &lt;&lt; "Enter a value: ";
     cin &gt;&gt; value;                  // Read a value
     ++i;                           // Increment count
     sum += value;                  // Add current input to total
        
     cout &lt;&lt; endl
          &lt;&lt; "Do you want to enter another value (enter y or n)? ";
     cin &gt;&gt; indicator;              // Read indicator
     if (('n' == indicator) || ('N' == indicator))
        break;                      // Exit from loop
  }
        
  cout &lt;&lt; endl
       &lt;&lt; "The average of the " &lt;&lt; i
       &lt;&lt; " values you entered is " &lt;&lt; sum/i &lt;&lt; "."
       &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">This program computes the average of an arbitrary number of values. After each value is entered, you must indicate whether you want to enter another value, by entering a single character, <code class="calibre23">y</code> or <code class="calibre23">n</code>. Typical output from executing this example is:</p>
<pre class="calibre28"><code class="calibre23">Enter a value: 10
        
Do you want to enter another value (enter y or n)? y
        
Enter a value: 20
        
Do you want to enter another value (enter y or n)? y
        
Enter a value: 30
        
Do you want to enter another value (enter y or n)? n
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="116" id="calibre_link-578" class="calibre14"></span>The average of the 3 values you entered is 20.</code></pre>
<p class="calibre20">After defining and initializing the variables that you’re going to use, you start a <code class="calibre23">for</code> loop with no expressions specified, so there is no provision for ending it here. The block immediately following is the subject of the loop that is to be repeated.</p>
<p class="calibre20">The loop block performs three basic actions:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">It reads a value.</li>
<li class="calibre6">It adds the value read from <code class="calibre23">cin</code> to <code class="calibre23">sum</code>.</li>
<li class="calibre6">It checks whether you want to continue to enter values.</li>
</ul>
<p class="calibre20">The first action within the block is to prompt you for input and then read a value into the variable <code class="calibre23">value</code>. The value that you enter is added to <code class="calibre23">sum</code>, and the count of the number of values, <code class="calibre23">i</code>, is incremented. After accumulating the value in <code class="calibre23">sum</code>, you are asked if you want to enter another value, and prompted to enter <code class="calibre23">'y'</code> or <code class="calibre23">'n'</code> if you have finished. The character that you enter is stored in <code class="calibre23">indicator</code>, for testing against <code class="calibre23">'n'</code> or <code class="calibre23">'N'</code> in the <code class="calibre23">if</code> statement. If neither is found, the loop continues; otherwise, a <code class="calibre23">break</code> is executed. The effect of <code class="calibre23">break</code> in a loop is similar to its effect in the context of the <code class="calibre23">switch</code> statement. It exits the loop immediately by transferring control to the statement following the closing brace of the loop block.</p>
<p class="calibre20">Finally, you output the count of the number of values entered and their average, which is calculated by dividing <code class="calibre23">sum</code> by <code class="calibre23">i</code>. Of course, <code class="calibre23">i</code> is promoted to type <code class="calibre23">double</code> before the calculation, as you remember from the casting discussion in Chapter 2.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">Using the continue Statement</h4>
<p class="calibre13">You write the <code class="calibre23">continue</code> statement simply as:</p>
<pre class="calibre28"><code class="calibre23">continue;</code></pre>
<p class="calibre13">Executing <code class="calibre23">continue</code> within a loop starts the next loop iteration immediately, skipping over any statements remaining in the body of the loop. I can show how this works with the following code:</p>
<pre class="calibre28"><code class="calibre23">#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  int value {}, product {1};
        
  for(int i {1}; i &lt;= 10; i++)
  {
    cout &lt;&lt; "Enter an integer: ";
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="117" id="calibre_link-579" class="calibre14"></span>     cin &gt;&gt; value;
        
     if(0 == value)                    // If value is zero
        continue;                      // skip to next iteration
        
     product *= value;
  }
        
  cout &lt;&lt; "Product (ignoring zeros): " &lt;&lt; product
       &lt;&lt; endl;
        
  return 0;                           
}</code></pre>
<p class="calibre13">This loop reads 10 values with the intention of producing the product of the values entered. The <code class="calibre23">if</code> checks each value, and if it is zero, the <code class="calibre23">continue</code> statement skips to the next iteration. This is so that you don’t end up with a zero product if one of the values is zero. Obviously, if a zero value occurred on the last iteration, the loop would end. There are other ways of achieving the same result, but <code class="calibre23">continue</code> provides a very useful capability, particularly with complex loops where you may need to skip to the end of the current iteration from various points in the loop.</p>
<p class="calibre13">The effect of the <code class="calibre23">break</code> and <code class="calibre23">continue</code> statements on the logic of a <code class="calibre23">for</code> loop is illustrated in <a id="calibre_link-40" href="#calibre_link-39" class="calibre3">Figure 3-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000107.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-39" href="#calibre_link-40" class="calibre3">FIGURE 3-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="118" id="calibre_link-580" class="calibre14"></span>Obviously, in a real situation, you would use the <code class="calibre23">break</code> and <code class="calibre23">continue</code> statements with some condition-testing logic to determine when the loop should be exited, or when an iteration of the loop should be skipped. You can also use the <code class="calibre23">break</code> and <code class="calibre23">continue</code> statements with the other kinds of loop, which I’ll discuss later on in this chapter, where they work in exactly the same way.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Other Types in Loops</h3>
<p class="calibre20">So far, you have only used integers to count loop iterations. You are in no way restricted as to what type of variable you use to count iterations. Look at the following example:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_11.cpp
// Display ASCII codes for alphabetic characters
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
        
using std::cout;
using std::endl;
using std::hex;
using std::dec;
using std::setw;
        
int main()
{
  for(char capital {'A'}, small {'a'}; capital &lt;= 'Z'; capital++, small++)
  {
     cout &lt;&lt; endl
          &lt;&lt; "\t" &lt;&lt; capital                  // Output capital as a character
          &lt;&lt; hex &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(capital)   // and as hexadecimal
          &lt;&lt; dec &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(capital)   // and as decimal
          &lt;&lt; " " &lt;&lt; small                 // Output small as a character
          &lt;&lt; hex &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(small)     // and as hexadecimal
          &lt;&lt; dec &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(small);    // and as decimal
  }
        
  cout &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">Here we have <code class="calibre23">using</code> declarations for the names of some new manipulators that are used in the program to affect how the output is presented.</p>
<p class="calibre20">The loop in this example is controlled by the <code class="calibre23">char</code> variable <code class="calibre23">capital</code>, which you declare along with the variable <code class="calibre23">small</code> in the initializing expression. You increment both variables in the third control expression for the loop, so that the value of <code class="calibre23">capital</code> varies from <code class="calibre23">'A'</code> to <code class="calibre23">'Z'</code>, and the value of <code class="calibre23">small</code> correspondingly varies from <code class="calibre23">'a'</code> to <code class="calibre23">'z'</code>.</p>
<p class="calibre20">The loop contains just one output statement spread over seven lines. The first line is:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; endl</code></pre>
<p class="calibre20">This starts a new line on the screen.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="119" id="calibre_link-581" class="calibre14"></span>The next three lines are:</p>
<pre class="calibre28"><code class="calibre23">           &lt;&lt; "\t" &lt;&lt; capital                      // Output capital as a character
           &lt;&lt; hex &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(capital)   // and as hexadecimal
           &lt;&lt; dec &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(capital)   // and as decimal</code></pre>
<p class="calibre20">After outputting a tab character on each iteration, the value of <code class="calibre23">capital</code> is displayed three times: as a character, as a hexadecimal value, and as a decimal value.</p>
<p class="calibre20">Inserting the <code class="calibre23">hex</code> manipulator into the <code class="calibre23">cout</code> stream causes subsequent integer data values to be displayed as hexadecimal values, rather than the default decimal representation, so the second output of <code class="calibre23">capital</code> is as a hexadecimal representation of the character code.</p>
<p class="calibre20">You then insert the <code class="calibre23">dec</code> manipulator into the stream to cause succeeding values to be output as decimals once more. By default, a variable of type <code class="calibre23">char</code> is interpreted by the stream as a character, not a numerical value. You get the <code class="calibre23">char</code> variable <code class="calibre23">capital</code> to output as a numerical value by casting its value to type <code class="calibre23">int</code>, using the <code class="calibre23">static_cast&lt;&gt;()</code> operator that you saw in the previous chapter.</p>
<p class="calibre20">The value of <code class="calibre23">small</code> is output in a similar way by the next three lines of the output statement:</p>
<pre class="calibre28"><code class="calibre23">   &lt;&lt; " " &lt;&lt; small                               // Output small as a character
   &lt;&lt; hex &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(small)    // and as hexadecimal
   &lt;&lt; dec &lt;&lt; setw(10) &lt;&lt; static_cast&lt;int&gt;(small);   // and as decimal</code></pre>
<p class="calibre20">As a result, the program generates the following output:</p>
<pre class="calibre28"><code class="calibre23">   A        41        65    a        61        97
   B        42        66    b        62        98
   C        43        67    c        63        99
   D        44        68    d        64       100
   E        45        69    e        65       101
   F        46        70    f        66       102
   G        47        71    g        67       103
   H        48        72    h        68       104
   I        49        73    i        69       105
   J        4a        74    j        6a       106
   K        4b        75    k        6b       107
   L        4c        76    l        6c       108
   M        4d        77    m        6d       109
   N        4e        78    n        6e       110
   O        4f        79    o        6f       111
   P        50        80    p        70       112
   Q        51        81    q        71       113
   R        52        82    r        72       114
   S        53        83    s        73       115
   T        54        84    t        74       116
   U        55        85    u        75       117
   V        56        86    v        76       118
   W        57        87    w        77       119
   X        58        88    x        78       120
   Y        59        89    y        79       121
   Z        5a        90    z        7a       122</code></pre>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="120" id="calibre_link-582" class="calibre14"></span>Floating-Point Loop Counters</h4>
<p class="calibre13">You can use a floating-point value as a loop counter. Here’s an example of a <code class="calibre23">for</code> loop with this kind of counter:</p>
<pre class="calibre28"><code class="calibre23">double a {0.3}, b {2.5};
for(double x {}; x &lt;= 2.0; x += 0.25)
  cout &lt;&lt; "\n\tx = " &lt;&lt; x
       &lt;&lt; "\ta*x + b = " &lt;&lt; a*x + b;</code></pre>
<p class="calibre13">This code fragment calculates the value of <code class="calibre23">a*x + b</code> for values of <code class="calibre23">x</code> from 0.0 to 2.0, in steps of 0.25; however, you need to take care when using a floating-point counter in a loop. Many decimal values cannot be represented exactly in binary floating-point form, so discrepancies can build up with cumulative values. This means that you should not code a <code class="calibre23">for</code> loop such that ending the loop depends on a floating-point loop counter reaching a precise value. For example, the following poorly-designed loop never ends:</p>
<pre class="calibre28"><code class="calibre23">   for(double x {}; x != 1.0; x += 0.1)
     cout &lt;&lt; x &lt;&lt; endl;</code></pre>
<p class="calibre13">The intention with this loop is to output the value of <code class="calibre23">x</code> as it varies from 0.0 to 1.0; however, 0.1 has no exact representation as a binary floating-point value, so the value of <code class="calibre23">x</code> is never exactly 1. Thus, the second loop control expression is always <code class="calibre23">false</code>, and the loop continues indefinitely.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">It’s easy to see why some decimal fractional values cannot be represented exactly as binary values. In a binary fraction, the digits to the right of the binary point are equivalent to the decimal fractions 1/2, 1/4, 1/8, 1/16, and so on. Thus any binary fraction as a decimal value is the sum of one or more of these decimal fractions. Decimal fractions such as 1/3 or 1/10 that have a denominator that is odd or has an odd factor can never by represented exactly by a sum of fractions that all have an even denominator.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">The while Loop</h3>
<p class="calibre13">A second kind of loop in C++ is the <code class="calibre23">while</code> loop. Where the <code class="calibre23">for</code> loop is primarily used to repeat a statement or a block for a prescribed number of iterations, the <code class="calibre23">while</code> loop is used to execute a statement or block of statements as long as a specified condition is <code class="calibre23">true</code>. The general form is:</p>
<pre class="calibre28"><code class="calibre23">while(condition)
   loop_statement;</code></pre>
<p class="calibre13">Here <code class="calibre23">loop_statement</code> is executed repeatedly, as long as the <code class="calibre23">condition</code> <i class="calibre15">expression</i> has the value <code class="calibre23">true</code>. After the condition becomes <code class="calibre23">false</code>, the program continues with the statement following the loop. As always, a block of statements between braces could replace <code class="calibre23">loop_statement</code>.</p>
<p class="calibre13">The logic of the <code class="calibre23">while</code> loop is shown in <a id="calibre_link-42" href="#calibre_link-41" class="calibre3">Figure 3-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000157.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-41" href="#calibre_link-42" class="calibre3">FIGURE 3-5</a></b></span></p>
</figcaption>
</figure>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="121" id="calibre_link-583" class="calibre24"></span>TRY IT OUT: Using the while Loop</h3>
<p class="calibre20">You could rewrite the earlier example that computes averages (<code class="calibre23">Ex3_10.cpp</code>) to use the <code class="calibre23">while</code> loop.</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex3_12.cpp</b>
<b class="calibre12">// Using a while loop to compute an average</b>
#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  double value {};                  // Value entered stored here
  double sum {};                    // Total of values accumulated here
  int i {};                         // Count of number of values
  <b class="calibre12">char indicator {'y'};             // Continue or not?</b>
 
  <b class="calibre12">while('y' == indicator )          // Loop as long as y is entered</b>
  {
    cout &lt;&lt; endl
          &lt;&lt; "Enter a value: ";
     cin &gt;&gt; value;                  // Read a value
     ++i;                           // Increment count
     sum += value;                  // Add current input to total
        
     cout &lt;&lt; endl
          &lt;&lt; "Do you want to enter another value (enter y or n)? ";
     cin &gt;&gt; indicator;              // Read indicator
  }
        
  cout &lt;&lt; endl
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="122" id="calibre_link-584" class="calibre14"></span>       &lt;&lt; "The average of the " &lt;&lt; i
       &lt;&lt; " values you entered is " &lt;&lt; sum/i &lt;&lt; "."
       &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">For the same input, this version of the program produces the same output as before. One statement has been updated, and another has been added &mdash; they are highlighted in the code. The <code class="calibre23">for</code> loop statement has been replaced by the <code class="calibre23">while</code> statement, and the test for <code class="calibre23">indicator</code> in the <code class="calibre23">if</code> has been deleted, as this function is performed by the <code class="calibre23">while</code> condition. You have to initialize <code class="calibre23">indicator</code> with <code class="calibre23">'y'</code>, in place of the <code class="calibre23">'n'</code> which appeared previously &mdash; otherwise the <code class="calibre23">while</code> loop terminates immediately. As long as the condition in the <code class="calibre23">while</code> returns <code class="calibre23">true</code>, the loop continues.</p>
<p class="calibre20">You can use any expression resulting in <code class="calibre23">true</code> or <code class="calibre23">false</code> as a <code class="calibre23">while</code> loop condition. The example would be better if the loop condition was extended to allow <code class="calibre23">'Y'</code> to be entered to continue the loop, as well as <code class="calibre23">'y'</code>. You could modify the <code class="calibre23">while</code> as follows to do the trick:</p>
<pre class="calibre28"><code class="calibre23">while(('y' == indicator) || ('Y' == indicator))</code></pre>
<p class="calibre20">You can also create a <code class="calibre23">while</code> loop that potentially executes indefinitely, by using a condition that is always <code class="calibre23">true</code>. This can be written as follows:</p>
<pre class="calibre28"><code class="calibre23">while(true)
{
...
}</code></pre>
<p class="calibre20">You could also write the loop control expression as the integer value 1, which would be converted to the <code class="calibre23">bool</code> value <code class="calibre23">true</code>. Naturally, the same requirement applies here as in the case of the indefinite <code class="calibre23">for</code> loop: namely, you must provide some way of exiting the loop within the loop block. You’ll see other ways to use the <code class="calibre23">while</code> loop in Chapter 4.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The do-while Loop</h3>
<p class="calibre13">The <code class="calibre23">do-while</code> loop is similar to the <code class="calibre23">while</code> loop in that the loop continues as long as the specified loop condition remains <code class="calibre23">true</code>. The main difference is that the condition is checked at the end of the loop &mdash; which contrasts with the <code class="calibre23">while</code> loop and the <code class="calibre23">for</code> loop, where the condition is checked at the beginning. Consequently, the <code class="calibre23">do-while</code> loop statement is always executed at least once. The general form of the <code class="calibre23">do-while</code> loop is:</p>
<pre class="calibre28"><code class="calibre23">do
{
   loop_statements;
}while(condition);</code></pre>
<p class="calibre13">The logic of this form of loop is shown in <a id="calibre_link-44" href="#calibre_link-43" class="calibre3">Figure 3-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000116.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-43" href="#calibre_link-44" class="calibre3">FIGURE 3-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="123" id="calibre_link-585" class="calibre14"></span>You could replace the <code class="calibre23">while</code> loop in the last version of the program to calculate an average with a <code class="calibre23">do-while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">   do
   {
     cout &lt;&lt; endl
          &lt;&lt; "Enter a value: ";
     cin &gt;&gt; value;                 // Read a value
     ++i;                          // Increment count
     sum += value;                 // Add current input to total
        
     cout &lt;&lt; "Do you want to enter another value (enter y or n)?";
     cin &gt;&gt; indicator;             // Read indicator
   <b class="calibre12">} while(('y' == indicator) || ('Y' == indicator));</b></code></pre>
<p class="calibre13">There’s little difference between the two versions of the loop, except that this version doesn’t depend on the initial value set in <code class="calibre23">indicator</code> for correct operation. As long as you want to enter at least one value, which is not unreasonable for the calculation in question, this version is preferable.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Range-Based for Loop</h3>
<p class="calibre13">I am introducing this loop here so all the loops that you have available appear together. The range-based <code class="calibre23">for</code> loop enables you to iterate over each of the items in a collection of items in a very simple way. You have not met any collections to which you can apply this loop so far, but you will meet arrays in the next chapter where you can use this loop. I’ll discuss how the range-based <code class="calibre23">for</code> loop works in more detail then, and you will learn about other kinds of collections that you can apply the range-based <code class="calibre23">for</code> loop to in Chapter 10.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="124" id="calibre_link-586" class="calibre24"></span>Nested Loops</h3>
<p class="calibre13">You can nest one loop inside another. The usual application for this will become apparent in Chapter 4 &mdash; it’s typically applied to repeating actions at different levels of classification. An example might be calculating the total marks for each student in a class, and then repeating the process for each class in a school.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Nested Loops</h3>
<p class="calibre20">You can see the effects of nesting one loop inside another by calculating the values of a simple formula. A factorial of an integer is the product of all the integers from 1 to the integer in question; the factorial of 3, for example, is 1 times 2 times 3, which is 6. The following program computes the factorial of integers that you enter (until you’ve had enough):</p>
<pre class="calibre28"><code class="calibre23">// Ex3_13.cpp
// Demonstrating nested loops to compute factorials
#include &lt;iostream&gt;
        
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  char indicator {'n'};
  long value {}, factorial {};
        
  do
  {
     cout &lt;&lt; endl &lt;&lt; "Enter an integer value: ";
     cin &gt;&gt; value;
        
     factorial = 1L;
     for(long i {2L}; i &lt;= value; i++)
        factorial *= i;
        
     cout &lt;&lt; "Factorial " &lt;&lt; value &lt;&lt; " is " &lt;&lt; factorial;
     cout &lt;&lt; endl &lt;&lt; "Do you want to enter another value (y or n)? ";
     cin &gt;&gt; indicator;
  } while(('y' == indicator) || ('Y' == indicator));
        
  return 0;
}</code></pre>
<p class="calibre20">If you compile and execute this example, the typical output produced is:</p>
<pre class="calibre28"><code class="calibre23">Enter an integer value: 5
Factorial 5 is 120
Do you want to enter another value (y or n)? y
        
Enter an integer value: 10
Factorial 10 is 3628800
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="125" id="calibre_link-587" class="calibre14"></span>Do you want to enter another value (y or n)? y
        
Enter an integer value: 13
Factorial 13 is 1932053504
Do you want to enter another value (y or n)? y
        
Enter an integer value: 22
Factorial 22 is -522715136
Do you want to enter another value (y or n)? n</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">Factorial values grow very fast. In fact, 12 is the largest input value for which this example produces a correct result. The factorial of 13 is actually 6,227,020,800, not 1,932,053,504 as the program tells you. If you run it with even larger input values, leading digits are lost in the result stored in the variable <code class="calibre23">factorial</code>, and you may well get negative values for the factorial, as you do when you ask for the factorial of 22.</p>
<p class="calibre20">This situation doesn’t cause any error messages, so it is of paramount importance that you are sure that the values you’re dealing with in a program can be contained in the permitted range of the type of variable you’re using. You also need to consider the effects of incorrect input values. Errors of this kind, which occur silently, can be very hard to find.</p>
<p class="calibre20">The outer of the two nested loops is the <code class="calibre23">do-while</code> loop, which controls when the program ends. As long as you keep entering <code class="calibre23">y</code> or <code class="calibre23">Y</code> at the prompt, the program continues to calculate factorial values. The factorial for the integer entered is calculated in the inner <code class="calibre23">for</code> loop. This is executed <code class="calibre23">value-1</code> times, to multiply the variable <code class="calibre23">factorial</code> (with an initial value of 1) with successive integers from 2 to <code class="calibre23">value</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Another Nested Loop</h3>
<p class="calibre20">Nested loops can be a little confusing, so let’s try another example. This program generates a multiplication table of a given size:</p>
<pre class="calibre28"><code class="calibre23">// Ex3_14.cpp
// Using nested loops to generate a multiplication table
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
        
using std::cout;
using std::endl;
using std::setw;
        
int main()
{
  const int size {12};                 // Size of table
  int i {}, j {};                      // Loop counters
        
  cout &lt;&lt; endl                         // Output table title
       &lt;&lt; size &lt;&lt; " by " &lt;&lt; size &lt;&lt; " Multiplication Table" &lt;&lt; endl &lt;&lt; endl;
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="126" id="calibre_link-588" class="calibre14"></span>  cout &lt;&lt; endl &lt;&lt; "    |";
        
  for(i = 1; i &lt;= size; i++)          // Loop to output column headings
     cout &lt;&lt; setw(3) &lt;&lt; i &lt;&lt; " ";
        
  cout &lt;&lt; endl;                       // Newline for underlines
        
  for(i = 0; i &lt;= size; i++)
     cout &lt;&lt; "_____";                 // Underline each heading
        
  for(i = 1; i &lt;= size; i++)          // Outer loop for rows
  {
     cout &lt;&lt; endl
          &lt;&lt; setw(3) &lt;&lt; i &lt;&lt; " |";    // Output row label
     for(j = 1; j &lt;= size; j++)       // Inner loop for the rest of the row
       cout &lt;&lt; setw(3) &lt;&lt; i*j &lt;&lt; " "; // End of inner loop
  }                                   // End of outer loop
  cout &lt;&lt; endl;
        
  return 0;
}</code></pre>
<p class="calibre20">The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">12 by 12 Multiplication Table
        
        
    |  1    2    3    4    5    6    7    8    9   10   11   12
_________________________________________________________________
  1 |  1    2    3    4    5    6    7    8    9   10   11   12
  2 |  2    4    6    8   10   12   14   16   18   20   22   24
  3 |  3    6    9   12   15   18   21   24   27   30   33   36
  4 |  4    8   12   16   20   24   28   32   36   40   44   48
  5 |  5   10   15   20   25   30   35   40   45   50   55   60
  6 |  6   12   18   24   30   36   42   48   54   60   66   72
  7 |  7   14   21   28   35   42   49   56   63   70   77   84
  8 |  8   16   24   32   40   48   56   64   72   80   88   96
  9 |  9   18   27   36   45   54   63   72   81   90   99  108
 10 | 10   20   30   40   50   60   70   80   90  100  110  120
 11 | 11   22   33   44   55   66   77   88   99  110  121  132
 12 | 12   24   36   48   60   72   84   96  108  120  132  144</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The table title is produced by the first output statement. The next output statement, combined with the loop following it, generates the column headings. Each column is five characters wide, so the heading value is displayed in a field width of three, specified by the <code class="calibre23">setw(3)</code> manipulator, followed by two spaces. The output statement preceding the loop outputs four spaces and a vertical bar above the first column, which contains the row headings. A series of underline characters is then displayed beneath the column headings.</p>
<p class="calibre20">The nested loop generates the main table contents. The outer loop repeats once for each row, so <code class="calibre23">i</code> is the row number. The output statement</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="127" id="calibre_link-589" class="calibre14"></span>      cout &lt;&lt; endl
           &lt;&lt; setw(3) &lt;&lt; i &lt;&lt; " |";       // Output row label</code></pre>
<p class="calibre20">goes to a new line for the start of a row, and then outputs the row heading given by the value of <code class="calibre23">i</code> in a field width of three, followed by a space and a vertical bar.</p>
<p class="calibre20">A row of values is generated by the inner loop:</p>
<pre class="calibre28"><code class="calibre23">      for(j = 1; j &lt;= size; j++)          // Inner loop for the rest of the row
        cout &lt;&lt; setw(3) &lt;&lt; i*j &lt;&lt; " ";    // End of inner loop</code></pre>
<p class="calibre20">This loop outputs values <code class="calibre23">i*j</code>, corresponding to the product of the current row value <code class="calibre23">i</code>, and each of the column values in turn by varying <code class="calibre23">j</code> from 1 to <code class="calibre23">size</code>. So, for each iteration of the outer loop, the inner loop executes <code class="calibre23">size</code> iterations. The values are positioned in the same way as the column headings. When the outer loop ends, a new line is printed and the <code class="calibre23">return</code> is executed to end the program.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-260" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter, you learned all the essential mechanisms for making decisions in C++ programs. The ability to compare values and change the course of program execution is what differentiates a computer from a simple calculator. You need to be comfortable with all of the decision-making statements I have discussed because they are all used very frequently. You have also gone through all the facilities for repeating a group of statements. Loops are a fundamental programming technique that you will need to use in every program of consequence that you write. You will find you use the <code class="calibre23">for</code> loop most often, closely followed by the <code class="calibre23">while</code> loop.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Write a program that reads numbers from <code class="calibre23">cin</code> and then sums them, stopping when 0 has been entered. Construct three versions of this program, using the <code class="calibre23">while, do-while</code>, and <code class="calibre23">for</code> loops.</li>
<li class="calibre6">Write a program to read characters from the keyboard and count the vowels. Stop counting when a Q (or a q) is encountered. Use a combination of an indefinite loop to get the characters, and a <code class="calibre23">switch</code> statement to count them.</li>
<li class="calibre6">Write a program to print out the multiplication tables from 2 to 12, in columns.</li>
<li class="calibre6">Imagine that in a program you want to set a ‘file open mode’ variable based on two attributes: the file type, which can be text or binary, and the way in which you want to open the file to read or write it, or append data to it. Using the bitwise operators (<code class="calibre23">&amp;</code> and <code class="calibre23">|</code>) and a set of flags, devise a method to allow a single integer variable to be set to any combination of the two attributes. Write a program that sets such a variable and then decodes it, printing out its setting, for all possible combinations of the attributes.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="128" id="calibre_link-590" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Relational operators</b></td>
<td class="calibre32">The relational operators allow you to combine logical values or expressions that result in a logical value. They yield a <code class="calibre23">bool</code> value &mdash; <code class="calibre23">true</code> or <code class="calibre23">false</code> &mdash; as the result that you can use in an <code class="calibre23">if</code> statement.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Decisions based on numerical values</b></td>
<td class="calibre32">You can make decisions based on conditions that return non-<code class="calibre23">bool</code> values. Any non-zero value is cast to <code class="calibre23">true</code> when a condition is tested; zero casts to <code class="calibre23">false</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Statements for decision-making</b></td>
<td class="calibre32">The <code class="calibre23">if</code> statement provides the primary decision-making capability in C++. Further flexibility is provided by the <code class="calibre23">switch</code> statement and the conditional operator.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Loop statements</b></td>
<td class="calibre32">There are four basic methods for repeating a block of statements: the <code class="calibre23">for</code> loop, the <code class="calibre23">while</code> loop, the <code class="calibre23">do-while</code> loop, and the range-based <code class="calibre23">for</code> loop. The <code class="calibre23">for</code> loop allows the loop to repeat a given number of times. The <code class="calibre23">while</code> loop allows a loop to continue as long as a specified condition returns <code class="calibre23">true</code>. The <code class="calibre23">do-while</code> executes the loop at least once and allows continuation of the loop as long as a specified condition returns <code class="calibre23">true</code>. The range-based <code class="calibre23">for</code> loop iterates over the items in a collection.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Nested loops</b></td>
<td class="calibre32">Any kind of loop may be nested within any other kind of loop.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The continue keyword</b></td>
<td class="calibre32">The keyword <code class="calibre23">continue</code> allows you to skip the remainder of the current iteration in a loop and go straight to the next iteration.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The break keyword</b></td>
<td class="calibre32">The keyword <code class="calibre23">break</code> provides an immediate exit from a loop. It also provides an exit from a <code class="calibre23">switch</code> at the end of statements in a <code class="calibre23">case</code>.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-154">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2317" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="129" id="calibre_link-591" class="calibre9"></span><span class="chapternumber">Chapter 4</span><br class="calibre10" /><span class="chapternumber">Arrays, Strings, and Pointers</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How to use arrays</li>
<li class="calibre6">How to define and initialize arrays of different types</li>
<li class="calibre6">How to use the range-based <code class="calibre23">for</code> loop with an array</li>
<li class="calibre6">How to define and use multidimensional arrays</li>
<li class="calibre6">How to use pointers</li>
<li class="calibre6">How to define and initialize pointers of different types</li>
<li class="calibre6">The relationship between arrays and pointers</li>
<li class="calibre6">How to define references and some initial ideas on their uses</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 4 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-261" class="calibre3"></a>HANDLING MULTIPLE DATA VALUES OF THE SAME TYPE</h2>
<p class="calibre13">You already know how to define and initialize variables of various types that each holds a single item of information; I’ll refer to single items of data as <i class="calibre15">data elements</i>. The most obvious extension to the idea of a variable is to be able to reference several data elements of a particular type with a single variable name. This would enable you to handle applications of a much broader scope.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="130" id="calibre_link-592" class="calibre14"></span>Let’s consider an example. Suppose that you needed to write a payroll program. Using a separate variable for each individual’s pay, tax liability, and so on, would be an uphill task to say the least. A more convenient way to handle such a problem would be to reference an employee by some kind of generic name &mdash; <code class="calibre23">employeeName</code> to take an imaginative example &mdash; and to have other generic names for the kinds of data related to each employee, such as <code class="calibre23">pay</code> and <code class="calibre23">tax</code>. Of course, you would need some means of picking out a particular employee from the whole bunch, together with the data from the generic variables associated with them. This kind of requirement arises with any collection of like entities that you want to handle, whether they’re baseball players or battleships. Naturally, C++ provides you with a way to deal with this.</p>
<section class="toclist">
<h3 class="calibre21">Arrays</h3>
<p class="calibre13">One way to solve these problems is to use an <i class="calibre15">array</i>. An array is a number of memory locations called <i class="calibre15">array elements</i> or simply <i class="calibre15">elements</i>, each of which stores an item of data of the same given data type, and which are all referenced through the same variable name. The employee names in a payroll program could be stored in one array, the pay for each employee in another, and the tax due for each employee could be stored in a third array.</p>
<p class="calibre13">You select an element in an array using an <i class="calibre15">index</i> value. An index is an integer representing the sequence number of the element in the array. The first element has the index <code class="calibre23">0</code>, the second <code class="calibre23">1</code>, and so on. You can also envisage the index for an array element as being the offset from the first element. The first element has an offset of <code class="calibre23">0</code> and therefore an index of <code class="calibre23">0</code>, and an index value of <code class="calibre23">3</code> will refer to the fourth element of an array.</p>
<p class="calibre13">The basic structure of an array is illustrated in <a id="calibre_link-156" href="#calibre_link-155" class="calibre3">Figure 4-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000069.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-155" href="#calibre_link-156" class="calibre3">FIGURE 4-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><a href="#calibre_link-155" class="calibre3">Figure 4-1</a> shows an array with the name <code class="calibre23">height</code> that has six elements. These might be the heights of the members of a family, for instance, recorded to the nearest inch. Because there are six elements, the index values run from <code class="calibre23">0</code> through <code class="calibre23">5</code>. You refer to a particular element by writing the array name followed by the index value of the element between square brackets. The third element is <code class="calibre23">height[2]</code>, for example. If you think of the index as the offset from the first element, it’s easy to see that the index for the fourth element will be 3.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="131" id="calibre_link-593" class="calibre14"></span>The memory required to store each element is determined by its type, and all the elements of an array are stored in a contiguous block of memory.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Declaring Arrays</h3>
<p class="calibre13">You define an array in essentially the same way as you defined the variables that you have seen up to now. The only difference is that you specify the number of array elements between square brackets following the array name. For example, you could define the integer array <code class="calibre23">height</code>, shown in the previous figure, with the following statement:</p>
<pre class="calibre28"><code class="calibre23">long height[6];</code></pre>
<p class="calibre13">A <code class="calibre23">long</code> value occupies 4 bytes, so the whole array requires 24 bytes. Arrays can be of any size, subject to the constraints imposed by the amount of memory in the computer on which your program is running.</p>
<p class="calibre13">Arrays can be of any type. For example, to define arrays to store the capacity and power output of a series of engines, you could write:</p>
<pre class="calibre28"><code class="calibre23">double engine_size[10];      // Engine size in cubic inches
double horsepower[10];       // Engine power output</code></pre>
<p class="calibre13">If auto mechanics is your thing, this would enable you to store the cubic capacity and power output of up to 10 engines, referenced by index values from <code class="calibre23">0</code> to <code class="calibre23">9</code>. As you have seen with other variables, you can define several arrays of a given type in a single statement, but in practice it is almost always better to define them in separate statements.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Arrays</h3>
<p class="calibre20">Imagine that you have recorded the amount of gasoline you have bought for the car and the odometer reading each time. You can write a program to analyze this data to see how the gas consumption looks on each occasion you bought gas:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_01.cpp
// Calculating gas mileage
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
        
using std::cin;
using std::cout;
using std::endl;
using std::setw; 
        
int main()
{
   const int MAX {20};                     // Maximum number of values
   double gas[ MAX ];                      // Gas quantity in gallons
   long miles[ MAX ];                      // Odometer readings
   int count {};                           // Loop counter
   char indicator {'y'};                   // Input indicator
        
   while( ('y' == indicator || 'Y' == indicator) &amp;&amp; count &lt; MAX )
   {
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="132" id="calibre_link-594" class="calibre14"></span>      cout &lt;&lt; endl &lt;&lt; "Enter gas quantity: ";
      cin &gt;&gt; gas[count];                   // Read gas quantity
      cout &lt;&lt; "Enter odometer reading: ";
      cin &gt;&gt; miles[count];                 // Read odometer value
        
      ++count;
      cout &lt;&lt; "Do you want to enter another(y or n)? ";
      cin &gt;&gt; indicator;
   }
        
   if(count &lt;= 1)                   // count = 1 after 1 entry completed
   {                                // ... we need at least 2
      cout &lt;&lt; endl &lt;&lt; "Sorry - at least two readings are necessary.";
      return 0;
   }
        
   // Output results from 2nd entry to last entry
   for(int i {1}; i &lt; count; i++)
   {
     cout &lt;&lt; endl
          &lt;&lt; setw(2) &lt;&lt; i &lt;&lt; "."             // Output sequence number
          &lt;&lt; "Gas purchased = " &lt;&lt; gas[i] &lt;&lt; " gallons" // Output gas
          &lt;&lt; " resulted in "                 // Output miles per gallon
          &lt;&lt; (miles[i] - miles[i - 1])/gas[i] &lt;&lt; " miles per gallon.";
   }
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<p class="calibre20">The program assumes that you fill the tank each time, so the gas bought was the amount used by driving the distance recorded. Here’s an example of the output:</p>
<pre class="calibre28"><code class="calibre23">Enter gas quantity: 12.8
Enter odometer reading: 25832
Do you want to enter another(y or n)? y
        
Enter gas quantity: 14.9
Enter odometer reading: 26337
Do you want to enter another(y or n)? y
        
Enter gas quantity: 11.8
Enter odometer reading: 26598
Do you want to enter another(y or n)? n
        
 1.Gas purchased = 14.9 gallons resulted in 33.8926 miles per gallon.
 2.Gas purchased = 11.8 gallons resulted in 22.1186 miles per gallon.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">Because you need to take the difference between two odometer readings to calculate the miles covered for the gas used, you use only the odometer reading from the first pair of input values &mdash; you ignore the gas bought in the first instance as that would have been used earlier. During the second period in the output, the traffic must have been really bad &mdash; or maybe the parking brake was left on.</p>
<p class="calibre20">The dimensions of the arrays <code class="calibre23">gas</code> and <code class="calibre23">miles</code> that store the input data are determined by the value of the constant, <code class="calibre23">MAX</code>. By changing the value of <code class="calibre23">MAX</code>, you can change the program to accommodate a different <span {http://www.idpf.org/2007/ops}type="pagebreak" title="133" id="calibre_link-595" class="calibre14"></span>maximum number of input values. This technique makes a program flexible in the amount of information that it can handle. Of course, all the program code must be written taking account of the array dimensions, or of any other parameters specified by <code class="calibre23">const</code> variables. This presents little difficulty in practice, so there’s no reason not to adopt this approach. You’ll see later how to allocate memory as the program executes, so that you don’t need to fix the memory for data storage in advance.</p>
<section class="toclist">
<h5 class="calibre27">Entering the Data</h5>
<p class="calibre20">The data values are read in the <code class="calibre23">while</code> loop. Because the loop variable <code class="calibre23">count</code> can run from <code class="calibre23">0</code> to <code class="calibre23">MAX - 1</code>, the user cannot enter more values than the array can handle. You initialize <code class="calibre23">count</code> and <code class="calibre23">indicator</code> to <code class="calibre23">0</code> and <code class="calibre23">'y'</code> respectively, so the <code class="calibre23">while</code> loop is entered at least once. There’s a prompt for each input value and the value is read into the appropriate array element. The element used to store a particular value is determined by <code class="calibre23">count</code>, which is <code class="calibre23">0</code> for the first input. The array element is specified in the <code class="calibre23">cin</code> statement by using <code class="calibre23">count</code> as an index, and <code class="calibre23">count</code> is then incremented, ready for the next value.</p>
<p class="calibre20">After you enter each value, the program prompts for confirmation that another value is to be entered. The character entered is read into <code class="calibre23">indicator</code> and tested in the loop condition. The loop will terminate unless <code class="calibre23">'y'</code> or <code class="calibre23">'Y'</code> is entered and <code class="calibre23">count</code> is less than the specified maximum value, <code class="calibre23">MAX</code>.</p>
<p class="calibre20">After the input loop ends (by whatever means), <code class="calibre23">count</code> contains one more than the index of the last element entered in each array. (Remember, you increment it after you enter each value). This is checked to verify that at least two pairs of values were entered. If this wasn’t the case, the program ends with a suitable message because two odometer values are needed to calculate a mileage value.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Producing the Results</h5>
<p class="calibre20">The output is generated in the <code class="calibre23">for</code> loop. The control variable <code class="calibre23">i</code> runs from <code class="calibre23">1</code> to <code class="calibre23">count-1</code>, allowing mileage to be calculated as the difference between the current element, <code class="calibre23">miles[i]</code>, and the previous element, <code class="calibre23">miles[i - 1]</code>. An index value can be any expression evaluating to an integer that represents a legal index for the array in question, which is a value from 0 to one less than the number of elements in the array.</p>
<p class="calibre20">If the value of an index is outside the range of the array elements, you will reference a spurious location that may contain other data, garbage, or even program code. If the reference to such an element is in an expression, you will use some arbitrary value in the calculation, which certainly produces a result that you did not intend. If you are storing a result in an array element using an illegal index, you will overwrite whatever happens to be in that location. When this is part of your program code, the results are catastrophic. If you use illegal index values, there are no warnings produced, either by the compiler or at run time. The only way to guard against this is to code your program to prevent it from happening.</p>
</section>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Visual C++ has a code analysis feature that you can access via the ANALYZE menu. This will scan your code for issues and can sometimes detect and warn against problems such as accessing array elements out of bounds.</i></p>
<p class="calibre20"><i class="calibre15">The output is generated by a single statement in the last loop for all values entered after the first. A line number is generated for each line of output using the loop control variable <code class="calibre23">i</code>. Miles per gallon is calculated directly in the output statement. You can use array elements in the same way as any other variables in an expression.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="134" id="calibre_link-596" class="calibre24"></span>Initializing Arrays</h3>
<p class="calibre13">To initialize an array in its definition, you put the initializing values in an initializer list. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">int engine_size[5] { 200, 250, 300, 350, 400 };</code></pre>
<p class="calibre13">The array has the name <code class="calibre23">engine_size</code> and has five elements that each store a value of type <code class="calibre23">int</code>. The values in the initializing list correspond to successive index values, so in this case <code class="calibre23">engine_size[0]</code> has the value 200, <code class="calibre23">engine_size[1]</code> the value 250, <code class="calibre23">engine_size[2]</code> the value 300, and so on.</p>
<p class="calibre13">You must not specify more initializing values than there are elements in the array, but you can include fewer. If there <i class="calibre15">are</i> fewer, the values are assigned to successive elements, starting with the first &mdash; which is the one corresponding to index <code class="calibre23">0</code>. Array elements for which you don’t provide a value are initialized with zero. This isn’t the same as supplying no initializing list. Without an initializing list, the array elements contain junk values. You can initialize all array elements to zero with an empty initializer list. For example:</p>
<pre class="calibre28"><code class="calibre23">long data[100] {};          // Initialize all elements to zero</code></pre>
<p class="calibre13">You can also omit the dimension of an array, provided you supply initializing values. The number of array elements will be the number of initializing values. For example:</p>
<pre class="calibre28"><code class="calibre23">int value[] { 2, 3, 4 };</code></pre>
<p class="calibre13">This defines an array with three elements that have initial values <code class="calibre23">2, 3</code>, and <code class="calibre23">4</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The older syntax for initializing arrays has</i> <code class="calibre23">=</code> <i class="calibre15">preceding the initializer list, thus:</i></p>
<pre class="calibre28"><code class="calibre23">int value[] = { 2, 3, 4 };</code></pre>
<p class="calibre20"><i class="calibre15">This syntax is still valid so you will come across it from time to time.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Initializing an Array</h3>
<p class="calibre20">This example demonstrates that you’ll have junk values in arrays that you don’t initialize:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_02.cpp
// Demonstrating array initialization
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
        
using std::cout;
using std::endl;
using std::setw; 
        
int main()
{
   int value[5] { 1, 2, 3 };
   int junk [5];
        
   cout &lt;&lt; endl;
   for(int i {}; i &lt; 5; i++)
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="135" id="calibre_link-597" class="calibre14"></span>      cout &lt;&lt; setw(12) &lt;&lt; value[i];
        
   cout &lt;&lt; endl;
   for(int i {}; i &lt; 5; i++)
      cout &lt;&lt; setw(12) &lt;&lt; junk[i];
        
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<p class="calibre20">You define two arrays, <code class="calibre23">value</code> and <code class="calibre23">junk</code>. You initialize <code class="calibre23">value</code> in part, and you don’t initialize <code class="calibre23">junk</code> at all. The program generates two lines of output, which on my computer look like this:</p>
<pre class="calibre28"><code class="calibre23">           1           2           3           0         0
  -858993460  -858993460  -858993460  -858993460  -858993460</code></pre>
<p class="calibre20">The second line (corresponding to values of <code class="calibre23">junk[0]</code> to <code class="calibre23">junk[4]</code>) may be different on your PC.</p>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The first three values of the <code class="calibre23">value</code> array are the initializing values, and the last two have the default value of <code class="calibre23">0</code>. In the case of <code class="calibre23">junk</code>, all the values are meaningless in the context of your program because you didn’t provide any initial values.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In debug mode bytes in uninitialized variables will be set to 0xcc so the values will not be arbitrary. You can see in the previous output that the uninitialized variable values are all identical because this was compiled in debug mode.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Using the Range-based for Loop</h3>
<p class="calibre13">You have seen that you can use a <code class="calibre23">for</code> loop to iterate over all the elements in an array. The range-based <code class="calibre23">for</code> loop makes this even easier. The loop is easy to understand through an example:</p>
<pre class="calibre28"><code class="calibre23">double temperatures[] {65.5, 68.0, 75.0, 77.5, 76.4, 73.8,80.1};
double sum {};
int count {};
for(double t : temperatures)
{
  sum += t;
  ++count;
}
double average = sum/count;</code></pre>
<p class="calibre13">This calculates the average of the values in the <code class="calibre23">temperatures</code> array. The parentheses following <code class="calibre23">for</code> contain two things separated by a colon; the first specifies the variable that will access each of the values from the collection specified by the second. The <code class="calibre23">t</code> variable will be assigned the value of each element in the <code class="calibre23">temperatures</code> array in turn before executing the loop body. This accumulates the sum of the array elements . The loop also accumulates the total number of elements in <code class="calibre23">count</code> so the average can be calculated after the loop.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="136" id="calibre_link-598" class="calibre14"></span>You could also write the loop using the <code class="calibre23">auto</code> keyword:</p>
<pre class="calibre28"><code class="calibre23">for(auto temperature : temperatures)
{
  sum += temperature;
  ++count;
}</code></pre>
<p class="calibre13">The <code class="calibre23">auto</code> keyword tells the compiler to determine the type for the local variable that holds the current value from the array type. The compiler knows that the array elements are of type <code class="calibre23">double</code>, so <code class="calibre23">t</code> will be of type <code class="calibre23">double</code>.</p>
<p class="calibre13">You cannot modify the values of the array elements in the range-based <code class="calibre23">for</code> loop as it is written here. You can only access the element values for use elsewhere. With the loop written as it is, element values are copied to the loop variable. You could access the array elements directly specifying the loop variable as a <i class="calibre15">reference</i>. You learn about references later in this chapter.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The C++ library provides the</i> <code class="calibre23">_countof()</code> <i class="calibre15">function that returns the number of elements in an array. You just put the array name between the parentheses. The</i> <code class="calibre23">cstdlib</code> <i class="calibre15">header needs to be included to use this function. Many other standard library headers such as</i> <code class="calibre23">iostream</code> <i class="calibre15">include</i> <code class="calibre23">cstdlib</code>. <i class="calibre15">You could calculate the average temperature like this:</i></p>
<pre class="calibre28"><code class="calibre23">for(auto temperature : temperatures)
{
  sum += temperature;
}
sum /= _countof(temperatures);</code></pre>
<p class="calibre20"><code class="calibre23">_countof()</code><i class="calibre15">is a Microsoft extension and not standard C++.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Multidimensional Arrays</h3>
<p class="calibre13">Arrays with one index are referred to as <i class="calibre15">one-dimensional arrays</i>. You can define an array with more than one index, in which case it is a <i class="calibre15">multidimensional</i> array. Suppose you have a field in which you are growing bean plants in rows of 10, and the field contains 12 rows so there are 120 plants in all. You could define an array to record the weight of beans produced by each plant using the statement:</p>
<pre class="calibre28"><code class="calibre23">double beans[12][10];</code></pre>
<p class="calibre13">This defines the two-dimensional array <code class="calibre23">beans</code>, the first index being the row number, and the second index the plant number within the row. To refer to an element requires two index values. For example, you could set the value of the element reflecting the fifth plant in the third row with the statement:</p>
<pre class="calibre28"><code class="calibre23">beans[2][4] = 10.7;</code></pre>
<p class="calibre13">Remember that index values start from zero, so the row index is <code class="calibre23">2</code> and the index for the fifth plant within the row is <code class="calibre23">4</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="137" id="calibre_link-599" class="calibre14"></span>Being a successful bean farmer, you might have several identical fields planted with beans in the same pattern. Assuming that you have eight fields, you could use a three-dimensional array to record data about these, defined thus:</p>
<pre class="calibre28"><code class="calibre23">double beans[8][12][10];</code></pre>
<p class="calibre13">This records production for the 10 plants in each of the 12 rows in a field and the leftmost index references one of the 8 fields. If you ever get to bean farming on an international scale, you can use a four-dimensional array, with the extra dimension designating the country. Assuming that you’re as good a salesman as you are a farmer, growing this quantity of beans is likely to affect the ozone layer.</p>
<p class="calibre13">Arrays are stored in memory such that the rightmost index varies most rapidly. Thus, the array <code class="calibre23">data[3][4]</code> is three one-dimensional arrays of four elements each. The arrangement of this array is illustrated in <a id="calibre_link-158" href="#calibre_link-157" class="calibre3">Figure 4-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000111.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-157" href="#calibre_link-158" class="calibre3">FIGURE 4-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The elements of the array are stored in a contiguous block of memory, as indicated by the arrows in <a href="#calibre_link-157" class="calibre3">Figure 4-2</a>. The first index selects a particular row within the array, and the second index selects an element within a row.</p>
<p class="calibre13">A two-dimensional array is really a one-dimensional array of one-dimensional arrays. An array with three dimensions is actually a one-dimensional array of elements where each element is a one-dimensional array of one-dimensional arrays. This is not something you need to worry about most of the time. However, it implies that for the array in <a href="#calibre_link-157" class="calibre3">Figure 4-2</a>, the expressions <code class="calibre23">data[0], data[1]</code>, and <code class="calibre23">data[2]</code> reference one-dimensional arrays.</p>
<section class="toclist">
<h4 class="calibre22">Initializing Multidimensional Arrays</h4>
<p class="calibre13">To initialize a multidimensional array, you use an extension of the method used for a one-dimensional array. For example, you can define and initialize a two-dimensional array, <code class="calibre23">data</code>, with the statement:</p>
<pre class="calibre28"><code class="calibre23">long data[2][4] {
                   { 1,  2,  3,  5 },
                   { 7, 11, 13, 17 }
                };</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="138" id="calibre_link-600" class="calibre14"></span>The initial values for each row are within their own pair of braces. Because there are four elements in each row, there are four initial values in each group, and because there are two rows, there are two groups between braces, each group of initial values being separated from the next by a comma.</p>
<p class="calibre13">You can omit initial values in any row, in which case the remaining elements in the row are zero. For example:</p>
<pre class="calibre28"><code class="calibre23">long data[2][4] {
                   { 1,  2,  3       },
                   { 7, 11           }
                };</code></pre>
<p class="calibre13">I have spaced out the initial values to show where values have been omitted. The elements <code class="calibre23">data[0][3], data[1][2]</code>, and <code class="calibre23">data[1][3]</code> have no initializing values and are therefore zero.</p>
<p class="calibre13">To initialize the entire array with zeros you can write:</p>
<pre class="calibre28"><code class="calibre23">long data[2][4] {};</code></pre>
<p class="calibre13">If you are initializing arrays with even more dimensions, remember that you need as many nested braces for groups of initial values as there are dimensions in the array &mdash; unless you’re initializing the array with zeros.</p>
<p class="calibre13">You can let the compiler work out the first dimension in an array, but only the first, regardless of the number of dimensions.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Multidimensional Array</h3>
<p class="calibre20">You can use a multidimensional array to figure out the average bean plant production in each of a number of rows in a field:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_03.cpp
// Storing bean plant production in an array
#include &lt;iostream&gt;                       // For stream I/O
#include &lt;iomanip&gt;                        // For stream manipulators
using namespace std;                      // Any name in std namespace
        
int main()
{
  const int plant_row_count{ 6 };         // Count of plants in a row
  double beans[][plant_row_count] {       // Production for each plant
    { 12, 15 },
    { 0, 10, 13, 0, 11, 2 },
    { 8, 7, 10, 10, 13    },
    { 9, 8, 11, 13, 16    }
  };
 
  double averages[_countof(beans)] {};    // Stores average plant production
  for (int row{}; row &lt; _countof(beans); ++row)
  {
    for (int plant{}; plant &lt; plant_row_count; ++plant)
    {
      averages[row] += beans[row][plant];
    }
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="139" id="calibre_link-601" class="calibre14"></span>    averages[row] /= plant_row_count;
  }
 
  cout &lt;&lt; "Average production per row is :" 
       &lt;&lt; setiosflags(ios::fixed)                  // Fixed point output
       &lt;&lt; setprecision(2)                          // 2 decimal places
       &lt;&lt; endl;
 
  int n{};                                         // Row number
  for (double ave : averages)
    cout &lt;&lt; "Row " &lt;&lt; ++n &lt;&lt; setw(10) &lt;&lt; ave &lt;&lt; endl;
 
   return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">There’s a <code class="calibre23">using</code> directive so all names in the <code class="calibre23">std</code> namespace can be used without qualification. The first statement in <code class="calibre23">main()</code> defines <code class="calibre23">plant_row_count</code> as a <code class="calibre23">const</code> variable, and this stores the number of plants in a row. The next statement defines and initializes the two-dimensional <code class="calibre23">beans</code> array. The first dimension is deduced by the compiler from the initializer list and the second dimension is specified by <code class="calibre23">plant_row_count</code>. This would result in an error message if <code class="calibre23">plant_row_count</code> was not <code class="calibre23">const</code>. The initial values for elements in each row are between braces, and the number of pairs of inner braces determines the first row dimension. The number of elements in a row is defined explicitly, so if you inadvertently specify more initial values than there are elements in a row, you will get an error message. Where you specify fewer than <code class="calibre23">plant_row_count</code> values for a row, the remaining elements in the row will be 0.</p>
<p class="calibre20">The next statement defines and initializes an array to hold the average plant production for each row:</p>
<pre class="calibre28"><code class="calibre23">  double averages[_countof(beans)] {};   // Stores average plant production</code></pre>
<p class="calibre20">The <code class="calibre23">_countof()</code> macro determines the number of rows in <code class="calibre23">beans</code>. Specifying just the array name references the array of rows. The array name with a single index would reference a particular row, so <code class="calibre23">_countof(beans[0])</code> would return the number of elements in the first row. There are no values in the initializer list so all elements in <code class="calibre23">averages</code> will be initialized to 0.</p>
<p class="calibre20">The averages for the rows are calculated in nested loops:</p>
<pre class="calibre28"><code class="calibre23">  for (int row{}; row &lt; _countof(beans); ++row)
  {
    for (int plant{}; plant &lt; plant_row_count; ++plant)
    {
      averages[row] += beans[row][plant];
    }
    averages[row] /= plant_row_count;
  }</code></pre>
<p class="calibre20">The outer <code class="calibre23">for</code> loop iterates over the rows. The inner loop iterates over the plants in a row, adding each production value to the <code class="calibre23">averages</code> element for the row. The average is calculated by dividing the sum accumulated in <code class="calibre23">averages[row]</code> by the number of plants in a row.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="140" id="calibre_link-602" class="calibre14"></span>When the nested loops end, this statement executes:</p>
<pre class="calibre28"><code class="calibre23">  cout &lt;&lt; "Average production per row is :" 
       &lt;&lt; setiosflags(ios::fixed)                  // Fixed point output
       &lt;&lt; setprecision(2)                          // 2 decimal places
       &lt;&lt; endl;</code></pre>
<p class="calibre20">This outputs a message to precede the output of the averages and writes two manipulators to the stream. The <code class="calibre23">std::setiosflags()</code> manipulator is used to set flags that affect how output is presented. In this case <code class="calibre23">ios::fixed</code> appears between the parentheses, which ensures a floating-point value is displayed with fixed-point notation and not in scientific notation. Sending <code class="calibre23">std::setprecision()</code> to the stream causes subsequent floating-point output to include the number of decimal places specified between the parentheses.</p>
<p class="calibre20">The averages are output using a range-based <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  int n{};                                         // Row number
  for (double ave : averages)
    cout &lt;&lt; "Row " &lt;&lt; ++n &lt;&lt; setw(10) &lt;&lt; ave &lt;&lt; endl;</code></pre>
<p class="calibre20">The loop variable <code class="calibre23">ave</code> will be assigned each of the values in the <code class="calibre23">averages</code> array in turn. You could use <code class="calibre23">auto</code> instead of type <code class="calibre23">double</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-262" class="calibre3"></a>WORKING WITH C-STYLE STRINGS</h2>
<p class="calibre13">An array of <code class="calibre23">char</code> elements is called a <i class="calibre15">character array</i> and is generally used to store a C-style string. A character string is a sequence of characters with a special character appended to indicate the end of the string. This character is defined by the escape sequence <code class="calibre23">\0</code>. It’s referred to as the <i class="calibre15">null or NUL character</i> because it’s a byte with all bits zero. A string terminated by null is referred to as a <i class="calibre15">C-style string</i> because it originated in the C language.</p>
<p class="calibre13">This is not the only representation of a string. You’ll meet much safer representations in Chapter 8. You should avoid using C-style strings in new code, but they often occur in existing programs so you need to know about them.</p>
<p class="calibre13">Each character in a non-Unicode string occupies one byte, so with the terminating null, the number of bytes a string occupies is one more than the number of characters in the string. You can define a character array and initialize it with a string literal like this:</p>
<pre class="calibre28"><code class="calibre23">char movie_star[15] {"Marilyn Monroe"};     // 14 characters plus null</code></pre>
<p class="calibre13">The terminating <code class="calibre23">'\0'</code> is supplied automatically. If you include one explicitly in the string literal, you’ll end up with two. You must allow for the terminating null when you specify the array dimension.</p>
<p class="calibre13">You can omit the dimension and let the compiler work it out:</p>
<pre class="calibre28"><code class="calibre23">char president[] {"Ulysses Grant"};</code></pre>
<p class="calibre13">The compiler allocates enough elements to hold the characters in the string plus the terminating null, so this array will have 14 elements. Of course, if you use the array later to store a different string, the new string must not exceed 14 bytes including its terminating null character. In general, it is your responsibility to ensure that an array is large enough for any string you store in it.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="141" id="calibre_link-603" class="calibre14"></span>You can create strings of Unicode characters, the characters in the string being of type <code class="calibre23">wchar_t</code>:</p>
<pre class="calibre28"><code class="calibre23">wchar_t president[] {L"Ulysses Grant"};</code></pre>
<p class="calibre13">The <code class="calibre23">L</code> prefix indicates that the literal is a wide character string, so each character, including the terminating null, will occupy two bytes. Of course, indexing the string references characters, not bytes, so <code class="calibre23">president[2]</code> corresponds to the character <code class="calibre23">L'y'</code>.</p>
<p class="calibre13">The Unicode encoding for type <code class="calibre23">wchar_t</code> is UTF-16. There are other encodings such as UTF-8 and UTF-32. Whenever I refer to just Unicode in the book I mean UTF-16.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can also initialize a character array with</i> <code class="calibre23">=</code> <i class="calibre15">preceding the initializer list, but the syntax without</i> <code class="calibre23">=</code> <i class="calibre15">is preferred.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">String Input</h3>
<p class="calibre13">The <code class="calibre23">iostream</code> header contains definitions of functions for reading characters from the keyboard. The one that you’ll look at here is the <code class="calibre23">getline()</code> function that reads a sequence of characters from the keyboard and stores it in an array as a string terminated by <code class="calibre23">'\0'</code>. You typically use <code class="calibre23">getline()</code>like this:</p>
<pre class="calibre28"><code class="calibre23">const int MAX {80};               // Maximum string length including \0
char name[MAX];                   // Array to store a string
cin.getline(name, MAX, '\n');     // Read input line as a string</code></pre>
<p class="calibre13">These statements define the <code class="calibre23">char</code> array <code class="calibre23">name</code> with <code class="calibre23">MAX</code> elements and then read characters from <code class="calibre23">cin</code> using <code class="calibre23">getline()</code>. The source of the data, <code class="calibre23">cin</code>, is written as shown, with a period separating it from the function name. The period indicates that the <code class="calibre23">getline()</code> function is the one belonging to the <code class="calibre23">cin</code> object. You will learn more about this syntax when you learn about classes. Meanwhile, just take it for granted. The significance of each argument to the <code class="calibre23">getline()</code> function is shown in <a id="calibre_link-160" href="#calibre_link-159" class="calibre3">Figure 4-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000161.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-159" href="#calibre_link-160" class="calibre3">FIGURE 4-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="142" id="calibre_link-604" class="calibre14"></span>Because the last argument is <code class="calibre23">'\n'</code>(newline or end line character) and the second argument is <code class="calibre23">MAX</code>, characters are read from <code class="calibre23">cin</code> until the ‘<code class="calibre23">\n'</code> character is read, or when <code class="calibre23">MAX-1</code> characters have been read, whichever occurs first. The maximum number of characters read is <code class="calibre23">MAX-1</code> rather than <code class="calibre23">MAX</code> to allow for the <code class="calibre23">'\0'</code> character to be appended to the characters stored in the array. The <code class="calibre23">'\n'</code> character is generated when you press the <i class="calibre15">Return</i> key and is therefore usually the most convenient character to end input. You can specify something else by changing the last argument. The <code class="calibre23">'\n'</code> isn’t stored in the array <code class="calibre23">name</code>, but as I said, <code class="calibre23">'\0'</code> is stored at the end of the input string in the array.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Programming with Strings</h3>
<p class="calibre20">This program reads a string from the keyboard and counts its characters.</p>
<pre class="calibre28"><code class="calibre23">// Ex4_04.cpp
// Counting string characters
#include &lt;iostream&gt;
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
   const int MAX {80};                // Maximum array dimension
   char buffer[MAX];                  // Input buffer
   int count {};                      // Character count
        
   cout &lt;&lt; "Enter a string of less than "
        &lt;&lt; MAX &lt;&lt; " characters:\n";
   cin.getline(buffer, MAX, '\n');    // Read a string until \n
        
   while(buffer[count] != '\0')       // Increment count as long as
      count++;                        // the current character is not null
        
   cout &lt;&lt; endl
        &lt;&lt; "The string \"" &lt;&lt; buffer
        &lt;&lt; "\" has " &lt;&lt; count &lt;&lt; " characters.";
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<p class="calibre20">Typical output from this program is as follows:</p>
<pre class="calibre28"><code class="calibre23">Enter a string of less than 80 characters:
Radiation fades your genes
The string "Radiation fades your genes" has 26 characters.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">This program defines a character array <code class="calibre23">buffer</code> and reads a string into it from the keyboard after prompting for the input. Input ends when the user presses Enter, or when <code class="calibre23">MAX-1</code> characters have been read.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="143" id="calibre_link-605" class="calibre14"></span>A <code class="calibre23">while</code> loop counts the number of characters in <code class="calibre23">buffer</code>. The loop continues as long as the character in <code class="calibre23">buffer[count]</code> is not <code class="calibre23">'\0'</code>. This sort of checking on the current element while stepping through an array is a common technique. The only action in the loop is to increment <code class="calibre23">count</code> for each non-null character. There is a library function that will do what this loop does; you learn about it later in this chapter.</p>
<p class="calibre20">Finally, the string and the character count are displayed by a single output statement. Note the use of the escape sequence <code class="calibre23">'\"'</code> to output a double quote.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">String Literals</h3>
<p class="calibre13">You have seen that you can write a string literal between double quotes and you can add <code class="calibre23">L</code> as a prefix to specify a Unicode string. You can split a long string over more than one line with each segment between double quotes. For example:</p>
<p class="calibre13"><code class="calibre23">"This is a very long string that "</code></p>
<p class="calibre13"><code class="calibre23">"has been spread over two lines."</code></p>
<p class="calibre13">C++ supports the use of <i class="calibre15">regular expressions</i> through the <code class="calibre23">regex</code> header. I don’t have the space to cover these in this book, but regular expressions typically involve strings with lots of backslash characters. Having to use the escape sequence for each backslash character makes regular expressions hard to enter correctly and even harder to read. The <i class="calibre15">raw string literal</i> gets over the problem. A raw string literal can contain any character, without necessitating the use of escape sequences. Here’s an example:</p>
<p class="calibre13"><code class="calibre23">R"(The "\t" escape sequence is a tab character.)"</code></p>
<p class="calibre13">As a normal string literal, this would be:</p>
<p class="calibre13"><code class="calibre23">"The \"\\t\" escape sequence is a tab character."</code></p>
<p class="calibre13">The <code class="calibre23">R</code> indicates the start of a raw string literal and the string is delimited by <code class="calibre23">"(</code> and <code class="calibre23">)"</code>. All characters between the delimiters are “as is” &mdash; escape sequences are not recognized as such. This immediately raises the question of how you include <code class="calibre23">)"</code> as part of a raw string literal. This is not a problem. The delimiters for a raw string literal in general can be <code class="calibre23">"char_sequence(</code> at the beginning and <code class="calibre23">)char_sequence"</code> at the end. <code class="calibre23">char_sequence</code>  is a sequence of characters that must be the same at both ends and can be up to 16 characters; it must not contain parentheses, spaces, control characters, or backslashes. Here’s an example:</p>
<p class="calibre13"><code class="calibre23">R"*("a = b*(c-d)")*"</code> is equivalent to <code class="calibre23">"\"a = b*(c-d)\""</code></p>
<p class="calibre13">The raw string contains the characters between <code class="calibre23">"*(</code> and <code class="calibre23">)*"</code>. You can define a raw string of wide characters by prefixing R with L.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="144" id="calibre_link-606" class="calibre24"></span>Using the Range-based for Loop with Strings</h3>
<p class="calibre13">You can use a range-based <code class="calibre23">for</code> loop to access the characters in a string:</p>
<pre class="calibre28"><code class="calibre23">char text[] {"Exit signs are on the way out."};
int count {};
cout &lt;&lt; "The string contains the following characters:" &lt;&lt; endl;
for (auto ch : text)
{
  ++count;
  cout &lt;&lt; ch &lt;&lt;  "  ";
}  
cout &lt;&lt; endl &lt;&lt; "The string contains " 
&lt;&lt; (count-1) &lt;&lt; " characters." &lt;&lt; endl;</code></pre>
<p class="calibre13">The loop outputs each string character, including the null at the end, and accumulates a count of the total number of characters. The count includes the null that terminates the string so its value is reduced by 1 before output.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Storing Multiple Strings</h3>
<p class="calibre20">You can use a two-dimensional array to store several C-style strings. You can see how this works with an example:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_05.cpp
// Storing strings in an array
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
        
int main()
{
   char stars[6][80] { "Robert Redford",
                       "Hopalong Cassidy",
                       "Lassie",
                       "Slim Pickens",
                       "Boris Karloff",
                       "Oliver Hardy"
                     };
   int dice {};
        
   cout &lt;&lt; endl
        &lt;&lt; "Pick a lucky star!"
        &lt;&lt; "Enter a number between 1 and 6: ";
   cin &gt;&gt; dice;
        
   if(dice &gt;= 1 &amp;&amp; dice &lt;= 6)          // Check input validity
      cout &lt;&lt; endl                     // Output star name
           &lt;&lt; "Your lucky star is " &lt;&lt; stars[dice - 1];
   else
      cout &lt;&lt; endl                     // Invalid input
           &lt;&lt; "Sorry, you haven't got a lucky star.";
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="145" id="calibre_link-607" class="calibre14"></span>   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">Apart from its incredible inherent entertainment value, the main point of interest in this example is the definition of the <code class="calibre23">stars</code> array. It is a two-dimensional array of elements of type <code class="calibre23">char</code> that can hold up to six strings, each of which can be up to 80 characters, including the terminating null. The initializing strings for the array are enclosed between braces and separated by commas.</p>
<p class="calibre20">A disadvantage of using arrays in this way is the memory that is almost invariably left unused. All of the strings are fewer than 80 characters, and the surplus elements in each row of the array are wasted. You’ll see later in this chapter how you could avoid this.</p>
<p class="calibre20">You can let the compiler work out how many strings you have by omitting the first array dimension:</p>
<pre class="calibre28"><code class="calibre23">   char stars[][80] { "Robert Redford",
                      "Hopalong Cassidy",
                      "Lassie",
                      "Slim Pickens",
                      "Boris Karloff",
                      "Oliver Hardy"
                    };</code></pre>
<p class="calibre20">This causes the compiler to define the first dimension to accommodate the initializing strings. Because you have six, the result is exactly the same, but it avoids the possibility of an error.  You can’t omit both array dimensions. You can only omit the first dimension in an array.</p>
<p class="calibre20">Of course, if you do omit the first array dimension, you would need to update the rest of the code to figure out the dimension instead of hard-coding 6. The <code class="calibre23">_countof()</code> function helps. The statement affected would then look like this:</p>
<pre class="calibre28"><code class="calibre23">  cout &lt;&lt; endl
    &lt;&lt; "Pick a lucky star!"
    &lt;&lt; "Enter a number between 1 and " &lt;&lt; _countof(stars) &lt;&lt; ": ";
  cin &gt;&gt; dice;
 
  if (dice &gt;= 1 &amp;&amp; dice &lt;= _countof(stars))      // Check input validity
    cout &lt;&lt; endl                                 // Output star name
    &lt;&lt; "Your lucky star is " &lt;&lt; stars[dice - 1];
  else
    cout &lt;&lt; endl                                 // Invalid input
    &lt;&lt; "Sorry, you haven't got a lucky star.";</code></pre>
<p class="calibre20">Where you reference a string for output in <code class="calibre23">Ex4_05.cpp</code>, you only specify the first index value:</p>
<pre class="calibre28"><code class="calibre23">      cout &lt;&lt; endl                               // Output star name
           &lt;&lt; "Your lucky star is " &lt;&lt; stars[dice - 1];</code></pre>
<p class="calibre20">A single index selects a particular 80-element subarray, and the output operation displays the contents up to the terminating null. The index is <code class="calibre23">dice-1</code> because <code class="calibre23">dice</code> varies from <code class="calibre23">1</code> to <code class="calibre23">6</code> and the index values need to be from <code class="calibre23">0</code> to <code class="calibre23">5</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-263" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="146" id="calibre_link-608" class="calibre18"></span>INDIRECT DATA ACCESS</h2>
<p class="calibre13">Variables you have dealt with so far provided you with the ability to name a memory location in which you can store data of a particular type. The contents of a variable are either entered from an external source, such as the keyboard, or calculated from other values. There is another kind of variable that does not store data that you normally enter or calculate, but greatly extends the power and flexibility of your programs. This kind of variable is called a <i class="calibre15">pointer</i>.</p>
<section class="toclist">
<h3 class="calibre21">What Is a Pointer?</h3>
<p class="calibre13">Each memory location in your PC has an address. The address provides the means for the hardware to reference that location. A <i class="calibre15">pointer</i> is a variable that stores the address of another variable of a given type. A pointer has a variable name just like any other variable and also has a type that designates what kind of variables its contents refer to. Note that the type of a pointer variable includes the fact that it’s a pointer. A variable that is a pointer, that can hold an address of a location containing a value of type <code class="calibre23">int</code>, is of type ‘pointer to <code class="calibre23">int'</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Declaring Pointers</h3>
<p class="calibre13">A definition for a pointer is similar to that of an ordinary variable, except that the pointer name has an asterisk in front of it to indicate that it’s a pointer. For example, to define a pointer <code class="calibre23">pnumber</code> of type pointer to <code class="calibre23">long</code>, you could use the following statement:</p>
<pre class="calibre28"><code class="calibre23">long* pnumber;</code></pre>
<p class="calibre13">This definition has been written with the asterisk close to the type name. If you want, you can also write it as:</p>
<pre class="calibre28"><code class="calibre23">long *pnumber;</code></pre>
<p class="calibre13">The compiler won’t mind; however, the type of <code class="calibre23">pnumber</code> is ‘pointer to <code class="calibre23">long'</code>, which is often indicated by placing the asterisk close to the type name. Whichever way you choose to write a pointer type, be consistent.</p>
<p class="calibre13">You can mix definitions of ordinary variables and pointers in the same statement. For example:</p>
<pre class="calibre28"><code class="calibre23">long* pnumber, number {99};</code></pre>
<p class="calibre13">This defines <code class="calibre23">pnumber</code> of type ‘pointer to <code class="calibre23">long'</code> as before, and also defines the variable <code class="calibre23">number</code>, of type <code class="calibre23">long</code>. On balance, it’s probably better to define pointers separately from other variables; otherwise, the statement can appear misleading as to the type of variables defined, particularly if you prefer to place the <code class="calibre23">*</code> adjacent to the type name. The following statements certainly look clearer, and putting definitions on separate lines enables you to add comments for them individually, making for a program that is easier to read:</p>
<pre class="calibre28"><code class="calibre23">long number {99};    // Declaration and initialization of long variable
long* pnumber;       // Declaration of variable of type pointer to long</code></pre>
<p class="calibre13">It’s a common convention to use variable names beginning with <code class="calibre23">p</code> to denote pointers. This makes it easier to see which variables are pointers, which in turn can make a program easier to follow.</p>
<p class="calibre13">Let’s take an example to see how this works, without worrying about what it’s for. I will get to how you use pointers very shortly. Suppose you have the <code class="calibre23">long</code> variable <code class="calibre23">number</code> containing the value <code class="calibre23">99</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="147" id="calibre_link-609" class="calibre14"></span>because you defined it in the preceding code. You could use the pointer <code class="calibre23">pnumber</code> of type pointer to <code class="calibre23">long</code> to store the address of <code class="calibre23">number</code>. But how do you obtain the address of a variable?</p>
<section class="toclist">
<h4 class="calibre22">The Address-of Operator</h4>
<p class="calibre13">What you need is the <i class="calibre15">address-of operator,</i> <code class="calibre23">&amp;</code>. This is a unary operator that obtains the address of a variable. It’s also called the reference operator, for reasons I discuss later in this chapter. To set up the pointer, you could write this assignment statement:</p>
<pre class="calibre28"><code class="calibre23">pnumber = &amp;number;            // Store address of number in pnumber</code></pre>
<p class="calibre13">The result of this operation is illustrated in <a id="calibre_link-162" href="#calibre_link-161" class="calibre3">Figure 4-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000027.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-161" href="#calibre_link-162" class="calibre3">FIGURE 4-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The <code class="calibre23">&amp;</code> operator obtains the address of any variable, but you need a pointer of the appropriate type to store it. To store the address of a <code class="calibre23">double</code> variable for example, the pointer must be of type <code class="calibre23">double*</code>, which is ‘pointer to <code class="calibre23">double'</code>.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Using Pointers</h3>
<p class="calibre13">Taking the address of a variable and storing it in a pointer is all very well, but the really interesting aspect is how you can use it. Fundamental to using a pointer is accessing the data in the variable to which it points. You do this using the indirection operator, <code class="calibre23">*</code>.</p>
<section class="toclist">
<h4 class="calibre22">The Indirection Operator</h4>
<p class="calibre13">You use the <i class="calibre15">indirection operator,</i> <code class="calibre23">*</code>, to access the contents of the variable to which a pointer points. The name “indirection operator” stems from the fact that the data is accessed indirectly. It is also called the <i class="calibre15">dereference operator</i>, and the process of accessing the data in the variable pointed to by a pointer is termed <i class="calibre15">de-referencing the pointer</i>.</p>
<p class="calibre13">One aspect of this operator that can seem confusing is the fact that you now have several different uses for the same symbol, <code class="calibre23">*</code>. It is the multiply operator, it is the indirection operator, and it is used in the definition of a pointer. Each time you use <code class="calibre23">*</code>, the compiler can distinguish its meaning by the context. When you multiply two variables, <code class="calibre23">A*B</code> for instance, there’s no meaningful interpretation of this expression for anything other than a multiply operation.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="148" id="calibre_link-610" class="calibre14"></span>Why Use Pointers?</h4>
<p class="calibre13">A question that usually springs to mind at this point is, “Why use pointers at all?” After all, taking the address of a variable you already know and sticking it in a pointer so that you can dereference it seems like overhead you can do without. There are several reasons why pointers are important.</p>
<p class="calibre13">As you will see, you can use pointer notation to operate on data stored in an array. Also, when you get to define your own functions, you will see that pointers are used extensively for enabling access within a function to large blocks of data, such as arrays, that are defined outside the function. Most importantly, you will see that you can allocate space for variables dynamically &mdash; that is, during program execution. This capability allows your program to adjust its use of memory depending on the input. Because you don’t know in advance how many variables you are going to create dynamically, the way for doing this is using pointers &mdash; so make sure you get the hang of this bit.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Initializing Pointers</h3>
<p class="calibre13">Using pointers that aren’t initialized is extremely hazardous. You can easily overwrite random areas of memory through an uninitialized pointer. The resulting damage depends on how unlucky you are, so it’s more than just a good idea to initialize your pointers. It’s very easy to initialize a pointer to the address of a variable that has already been defined. Here you can see that I have initialized the pointer <code class="calibre23">pnumber</code> with the address of the variable <code class="calibre23">number</code> just by using the operator <code class="calibre23">&amp;</code> with the variable name:</p>
<pre class="calibre28"><code class="calibre23">int number {};                       // Initialized integer variable
int* pnumber {&amp;number};              // Initialized pointer</code></pre>
<p class="calibre13">When initializing a pointer with the address of another variable, remember that the variable must already have been defined prior to the pointer definition.</p>
<p class="calibre13">Of course, you may not want to initialize a pointer with the address of a specific variable when you define it. In this case, you can initialize it with the pointer equivalent of zero, <code class="calibre23">nullptr</code>, which is a pointer that doesn’t point to anything. You can define and initialize a pointer using the following statement:</p>
<pre class="calibre28"><code class="calibre23">int* pnumber {nullptr};              // Pointer not pointing to anything</code></pre>
<p class="calibre13">Because <code class="calibre23">nullptr</code> is the equivalent of zero for pointers, an empty initializer list would work just as well. Setting a pointer to <code class="calibre23">nullptr</code> ensures that it doesn’t contain an address that will be accepted as valid, and provides the pointer with a value that you can check in an <code class="calibre23">if</code> statement, such as:</p>
<pre class="calibre28"><code class="calibre23">if(pnumber == nullptr)
   cout &lt;&lt; endl &lt;&lt; "pnumber does not point to anything.";</code></pre>
<p class="calibre13">Before <code class="calibre23">nullptr</code> was added to C++, 0 or <code class="calibre23">NULL</code> (which is a macro for which the compiler will substitute 0) was used to initialize a pointer, and of course, these still work. However, it is much better to use <code class="calibre23">nullptr</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="149" id="calibre_link-611" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <code class="calibre23">nullptr</code> <i class="calibre15">was introduced into C++ to remove potential confusion between the literal 0 as an integral value and 0 as a pointer. Having a dual meaning for 0 caused problems in some circumstances.</i> <code class="calibre23">nullptr</code> <i class="calibre15">is of type</i> <code class="calibre23">std::nullptr_t</code> <i class="calibre15">and cannot be confused with a value of any other type.</i> <code class="calibre23">nullptr</code> <i class="calibre15">can be implicitly converted to any pointer type but cannot be implicitly converted to any integral type except type</i> <code class="calibre23">bool</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Because the literal <code class="calibre23">nullptr</code> can be implicitly converted to type <code class="calibre23">bool</code>, you can check the status of the pointer <code class="calibre23">pnumber</code> like this:</p>
<pre class="calibre28"><code class="calibre23">if(!pnumber)
   cout &lt;&lt; endl &lt;&lt; "pnumber does not point to anything.";</code></pre>
<p class="calibre13"><code class="calibre23">nullptr</code> converts the <code class="calibre23">bool</code> value to <code class="calibre23">false</code>, and any other pointer value converts to <code class="calibre23">true</code>. Thus, if <code class="calibre23">pnumber</code> contains <code class="calibre23">nullptr</code>, the <code class="calibre23">if</code> expression will be <code class="calibre23">true</code> and will cause the message to be written to the output stream.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Pointers</h3>
<p class="calibre20">You can try out various aspects of pointer operations with an example:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_06.cpp
// Exercising pointers
#include &lt;iostream&gt;
using std::cout;
using std::endl;
using std::hex;
using std::dec;
        
int main()
{
   long* pnumber {};             // Pointer definition &amp; initialization
   long number1 {55}, number2 {99};
        
   pnumber = &amp;number1;           // Store address in pointer
   *pnumber += 11;               // Increment number1 by 11
   cout &lt;&lt; endl
        &lt;&lt; "number1 = " &lt;&lt; number1 
        &lt;&lt; "   &amp;number1 = " &lt;&lt; hex &lt;&lt; pnumber;
        
   pnumber = &amp;number2;           // Change pointer to address of number2
   number1 = *pnumber*10;        // 10 times number2
        
   cout &lt;&lt; endl
        &lt;&lt; "number1 = " &lt;&lt; dec &lt;&lt; number1
        &lt;&lt; "   pnumber = " &lt;&lt; hex &lt;&lt; pnumber
        &lt;&lt; "   *pnumber = " &lt;&lt; dec &lt;&lt; *pnumber;
        
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="150" id="calibre_link-612" class="calibre14"></span>You should compile and execute the release version of this example. The debug version will add extra bytes that are used for debugging purposes; these will cause the variables to be separated by 12 bytes instead of 4. On my computer, this example generates the following output:</p>
<pre class="calibre28"><code class="calibre23">number1 = 66   &amp;number1 = 003CF7F0
number1 = 990   pnumber = 003CF7F4   *pnumber = 99</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">There is no input. All operations are carried out with the initial values for the variables. After storing the address of <code class="calibre23">number1</code> in the pointer <code class="calibre23">pnumber</code>, the value of <code class="calibre23">number1</code> is incremented indirectly through the pointer in this statement:</p>
<pre class="calibre28"><code class="calibre23">*pnumber += 11;                       // Increment number1 by 11</code></pre>
<p class="calibre20">The indirection operator determines that you are adding 11 to the contents of the variable pointed to by <code class="calibre23">pnumber</code>, which is <code class="calibre23">number1</code>. If you forgot the <code class="calibre23">*</code> in this statement, you would be attempting to add 11 to the address in the pointer.</p>
<p class="calibre20">The values of <code class="calibre23">number1</code>, and the address of <code class="calibre23">number1</code> that is stored in <code class="calibre23">pnumber</code>, are displayed. You use the <code class="calibre23">hex</code> manipulator to generate the address output in hexadecimal notation. You can output the values of ordinary integer variables as hexadecimal using the <code class="calibre23">hex</code> manipulator. You send it to the output stream in the same way as <code class="calibre23">endl</code>, with the effect that all following output is in hexadecimal notation. To restore decimal output, you use the <code class="calibre23">dec</code> manipulator in the next output statement, which switches output back to decimal mode.</p>
<p class="calibre20">After the first line of output, <code class="calibre23">pnumber</code> is set to the address of <code class="calibre23">number2. number1</code> is then changed to the value of 10 times <code class="calibre23">number2</code>:</p>
<pre class="calibre28"><code class="calibre23">   number1 = *pnumber*10;                // 10 times number2</code></pre>
<p class="calibre20">This is calculated by accessing the contents of <code class="calibre23">number2</code> indirectly through the pointer. The second line of output shows the results.</p>
<p class="calibre20">The address values you see in your output may well be different from those shown here because they reflect where the program is loaded in memory, which depends on the state of your operating system environment.</p>
<p class="calibre20">Note that the addresses <code class="calibre23">&amp;number1</code> and <code class="calibre23">&amp;number2</code> differ by four bytes. This shows that <code class="calibre23">number1</code> and <code class="calibre23">number2</code> occupy adjacent memory locations, because each <code class="calibre23">long</code> variable occupies four bytes. The output demonstrates that everything is working as you would expect.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">Pointers to char</h4>
<p class="calibre13">A pointer of type <code class="calibre23">const char*</code> has the interesting property that it can be initialized with a string literal. For example, you can define and initialize such a pointer with the statement:</p>
<pre class="calibre28"><code class="calibre23">const char* proverb {"A miss is as good as a mile."};</code></pre>
<p class="calibre13">This looks similar to initializing a <code class="calibre23">char</code> array, but it’s quite different. This creates a string literal (actually an array of type <code class="calibre23">const char[]</code>) with the character string appearing between the quotes and terminating with <code class="calibre23">'\0'</code>, and stores the address of the literal in the pointer <code class="calibre23">proverb</code>. The address of the literal will be the address of its first character. This is shown in <a id="calibre_link-164" href="#calibre_link-163" class="calibre3">Figure 4-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000071.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-163" href="#calibre_link-164" class="calibre3">FIGURE 4-5</a></b></span></p>
</figcaption>
</figure>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="151" id="calibre_link-613" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can store the address of a string literal in a pointer that is not</i> <code class="calibre23">const</code>. <i class="calibre15">This was removed from C++ by the C++ 11 standard but is still allowed by the Visual C++ compiler so as not to break existing code. Storing the address of a string literal in a non-</i><code class="calibre23">const</code> <i class="calibre15">pointer is dangerous; you should not do it. Setting the</i> <code class="calibre23">/Zc:strictStrings</code> <i class="calibre15">compiler option causes the compiler to enforce the standard.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Lucky Stars with Pointers</h3>
<p class="calibre20">You could rewrite the lucky stars example using pointers instead of an array:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_07.cpp
// Initializing pointers with strings
#include &lt;iostream&gt;
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
   const char* pstr1 {"Robert Redford"};
   const char* pstr2 {"Hopalong Cassidy"};
   const char* pstr3 {"Lassie"};
   const char* pstr4 {"Slim Pickens"};
   const char* pstr5 {"Boris Karloff"};
   const char* pstr6 {"Oliver Hardy"};
   const char* pstr {"Your lucky star is "};
        
   int dice {};
        
   cout &lt;&lt; endl
        &lt;&lt; "Pick a lucky star!"
        &lt;&lt; "Enter a number between 1 and 6: ";
   cin &gt;&gt; dice;
        
   cout &lt;&lt; endl;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="152" id="calibre_link-614" class="calibre14"></span>   switch(dice)
   {
      case 1: cout &lt;&lt; pstr &lt;&lt; pstr1;
              break;
      case 2: cout &lt;&lt; pstr &lt;&lt; pstr2;
              break;
      case 3: cout &lt;&lt; pstr &lt;&lt; pstr3;
              break;
      case 4: cout &lt;&lt; pstr &lt;&lt; pstr4;
              break;
      case 5: cout &lt;&lt; pstr &lt;&lt; pstr5;
              break;
      case 6: cout &lt;&lt; pstr &lt;&lt; pstr6;
              break;
        
      default: cout &lt;&lt; "Sorry, you haven't got a lucky star.";
   }
        
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The array in <code class="calibre23">Ex4_05.cpp</code> has been replaced by the six pointers, <code class="calibre23">pstr1</code> to <code class="calibre23">pstr6</code>, each initialized with the name of a star. You have also defined <code class="calibre23">pstr</code>, initialized with the phrase that you’ll use at the start of a normal output line. Because you have discrete pointers, it is easier to use a <code class="calibre23">switch</code> statement to select the appropriate output message rather than an <code class="calibre23">if</code>, as you did in the original version. Incorrect values entered are taken care of by the <code class="calibre23">default</code> option of the <code class="calibre23">switch</code>.</p>
<p class="calibre20">Outputting the string pointed to couldn’t be easier. As you can see, you simply write the pointer name. It may cross your mind at this point that in <code class="calibre23">Ex4_06.cpp</code> you wrote a pointer name in the output statement, and the address that it contained was displayed. Why is it different here? The answer is in the way the stream output operation views a pointer of type ‘pointer to <code class="calibre23">char</code>.’ It treats a pointer of this type in a special way, in that it regards it as a string (which is an array of <code class="calibre23">char</code>), and so outputs the string, rather than its address.</p>
<p class="calibre20">Using pointers has eliminated the waste of memory that occurred with the array version of this program, but the program seems a little long-winded now. There must be a better way. Indeed there is &mdash; using an array of pointers.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Arrays of Pointers</h3>
<p class="calibre20">With an array of pointers of type <code class="calibre23">char</code>, each element can point to an independent string, and the lengths of each of the strings can be different. You can define an array of pointers in the same way that you define a normal array. Let’s go straight to rewriting the previous example using a pointer array:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_08.cpp
// Initializing pointers with strings
#include &lt;iostream&gt;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="153" id="calibre_link-615" class="calibre14"></span>using std::cin;
using std::cout;
using std::endl;
        
int main()
{
   const char* pstr[] { "Robert Redford",  // Initializing a pointer array
                        "Hopalong Cassidy",
                        "Lassie",
                        "Slim Pickens",
                        "Boris Karloff",
                        "Oliver Hardy"
                      };
   const char* pstart {"Your lucky star is "};
        
   int dice {};
        
   cout &lt;&lt; endl
        &lt;&lt; "Pick a lucky star!"
        &lt;&lt; "Enter a number between 1 and "&lt;&lt; _countof(pstr) &lt;&lt; ": ";
   cin &gt;&gt; dice;
        
   cout &lt;&lt; endl;
   if(dice &gt;= 1 &amp;&amp; dice &lt;= _countof(pstr))     // Check input validity
      cout &lt;&lt; pstart &lt;&lt; pstr[dice - 1];        // Output star name
        
   else
      cout &lt;&lt; "Sorry, you haven't got a lucky star."; // Invalid input
        
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">In this case, you are nearly getting the best of all possible worlds. You have a one-dimensional array of pointers to type <code class="calibre23">char</code> defined, such that the compiler works out what the dimension should be from the number of initializing strings. The memory usage that results from this is illustrated in <a id="calibre_link-166" href="#calibre_link-165" class="calibre3">Figure 4-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000114.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-165" href="#calibre_link-166" class="calibre3">FIGURE 4-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">Compared to using a “normal” array, a pointer array generally carries less overhead in terms of space. With an array, you would need to make each row the length of the longest string, and six rows of seventeen bytes each is 102 bytes, so by using a pointer array you have saved a whole -1 bytes! What’s gone wrong? The simple truth is that for this small number of relatively short strings, the size of the extra array of pointers is significant. You would make savings if you were dealing with more strings that were longer and more variable in length.</p>
<p class="calibre20">Space saving isn’t the only advantage of using pointers. In many circumstances you save time, too. Think of what happens if you want to move <code class="calibre23">"Oliver Hardy"</code> to the first position and <code class="calibre23">"Robert Redford"</code> to the end. With the pointer array in <code class="calibre23">Ex4_08.cpp</code>, you just swap the pointers &mdash; the strings themselves stay where they are. If you had stored these simply as strings, a great deal of copying would be necessary &mdash; you’d need to copy the string <code class="calibre23">"Robert Redford"</code> to a temporary location while you copied <code class="calibre23">"Oliver Hardy"</code> in its place. Then you’d need to copy <code class="calibre23">"Robert Redford"</code> to the end position. This requires significantly more computer time.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="154" id="calibre_link-616" class="calibre14"></span>Because you use <code class="calibre23">pstr</code> as the array name, the variable holding the start of the output message needs to be different; it is called <code class="calibre23">pstart</code>. You select the string to output by means of an <code class="calibre23">if</code> statement, similar to that in the original version of the example. You either display a star selection, or a suitable message if the user enters an invalid value.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">The sizeof Operator</h3>
<p class="calibre13">The <code class="calibre23">sizeof</code> operator produces an integer value of type <code class="calibre23">size_t</code> that gives the number of bytes occupied by its operand, where <code class="calibre23">size_t</code> is a type defined by the standard library. Many standard library functions return a value of type <code class="calibre23">size_t</code>, and <code class="calibre23">size_t</code> is defined using a <code class="calibre23">typedef</code> statement to be equivalent to one of the fundamental types, usually <code class="calibre23">unsigned int</code>. The reason for using <code class="calibre23">size_t</code> rather than a fundamental type directly is that it allows flexibility in what the actual type is in different C++ implementations. The C++ standard permits the range of values accommodated by a fundamental type to vary, to make the best of a given hardware architecture, and <code class="calibre23">size_t</code> can be defined to be the equivalent of the most suitable fundamental type in the current machine environment.</p>
<p class="calibre13">Look at this statement that refers to <code class="calibre23">dice</code> in the previous example:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; sizeof dice;</code></pre>
<p class="calibre13">The value of the expression <code class="calibre23">sizeof dice</code> is 4 because <code class="calibre23">dice</code> is type <code class="calibre23">int</code> and therefore occupies 4 bytes. Thus, this statement outputs the value <code class="calibre23">4</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="155" id="calibre_link-617" class="calibre14"></span>The <code class="calibre23">sizeof</code> operator can be applied to an element in an array or to the whole array. When you apply the operator to an array name by itself, it produces the number of bytes occupied by the whole array, whereas when you apply it to a single element, it results in the number of bytes occupied by that element. In the last example, you could output the number of elements in <code class="calibre23">pstr</code> with the expression:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; (sizeof pstr)/(sizeof pstr[0]);</code></pre>
<p class="calibre13">The expression <code class="calibre23">(sizeof pstr)/(sizeof pstr[0])</code> divides the number of bytes occupied by the whole array, by the number of bytes occupied by the first element. Because each array element occupies the same amount of memory, the result is the number of elements in the array. The code fragment you saw earlier that computed the average for an array of temperatures could be written like this:</p>
<pre class="calibre28"><code class="calibre23">double temperatures[] {65.5, 68.0, 75.0, 77.5, 76.4, 73.8, 80.1};
double sum {};
for(auto t : temperatures)
  sum += t;
double average = sum/((sizeof temperatures)/(sizeof temperatures[0]));</code></pre>
<p class="calibre13">Of course, as I noted earlier, you can use <code class="calibre23">_countof()</code> to obtain the number of array elements and this is much clearer and will result in a compile-time error message if you pass a pointer to it instead of an array name.</p>
<p class="calibre13">You can apply the <code class="calibre23">sizeof</code> operator to a type name, in which case the result is the number of bytes occupied by a variable of that type. In this case, the type name should be enclosed in parentheses. For example:</p>
<pre class="calibre28"><code class="calibre23">size_t long_size {sizeof(long)};</code></pre>
<p class="calibre13">The variable <code class="calibre23">long_size</code> will be initialized with the value <code class="calibre23">4</code>. The variable <code class="calibre23">long_size</code> is of type <code class="calibre23">size_t</code> to match the type of value produced by the <code class="calibre23">sizeof</code> operator. Using a different integer type for <code class="calibre23">long_size</code> may result in a warning message from the compiler.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Constant Pointers and Pointers to Constants</h3>
<p class="calibre13">You defined <code class="calibre23">pstr</code> in <code class="calibre23">Ex4_08.cpp</code> like this:</p>
<pre class="calibre28"><code class="calibre23">   const char* pstr[]  { "Robert Redford",  // Initializing a pointer array
                         "Hopalong Cassidy",
                         "Lassie",
                         "Slim Pickens",
                         "Boris Karloff",
                         "Oliver Hardy"
                       };</code></pre>
<p class="calibre13">Each pointer in the array is initialized with the address of a string literal, <code class="calibre23">"Robert Redford", "Hopalong Cassidy"</code>, and so on. The type of a string literal is ‘array of <code class="calibre23">const char</code>,’ so you are storing the address of a <code class="calibre23">const</code> array in a <code class="calibre23">const</code> pointer. This prevents modification of the literal used as the initializer, which is quite a good idea. There is no ambiguity about the <code class="calibre23">const</code>-ness of the strings pointed to by the elements of the <code class="calibre23">pstr</code> pointer array. If you now attempt to change these strings, the compiler flags this as an error at compile time.</p>
<p class="calibre13">However, you could still legally write this:</p>
<pre class="calibre28"><code class="calibre23">pstr[0] = pstr[1];</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="156" id="calibre_link-618" class="calibre14"></span>Those lucky individuals due to be awarded Mr. Redford would get Mr. Cassidy instead since both pointers now point to the same name. Note that this isn’t changing the strings pointed to &mdash; it is changing the address stored in <code class="calibre23">pstr[0]</code>. You probably want to inhibit this kind of change as well; some people may reckon that good old Hoppy may not have the same sex appeal as Robert. You can do this with the following statement:</p>
<pre class="calibre28"><code class="calibre23">   // Array of constant pointers to constants
   const char* const pstr[] = { "Robert Redford",
                                "Hopalong Cassidy",
                                "Lassie",
                                "Slim Pickens",
                                "Boris Karloff",
                                "Oliver Hardy"
                              };</code></pre>
<p class="calibre13">Now the characters in the strings cannot be modified and neither can any of the addresses in the array.</p>
<p class="calibre13">You can distinguish three situations relating to <code class="calibre23">const</code>, pointers, and the objects to which they point:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">A pointer to a constant object</li>
<li class="calibre6">A constant pointer to an object</li>
<li class="calibre6">A constant pointer to a constant object</li>
</ul>
<p class="calibre13">In the first situation, the object pointed to cannot be modified, but you can set the pointer to point to something else:</p>
<pre class="calibre28"><code class="calibre23">int value {5};
const int* pvalue {&amp;value};
*pvalue = 6;                                // Will not compile!
pvalue = nullptr;                           // OK
</code></pre>
<p class="calibre13">In the second situation, the address stored in the pointer can’t be changed, but the object pointed to can be:</p>
<pre class="calibre28"><code class="calibre23">int value {5};
int* const pvalue {&amp;value};
*pvalue = 6;                                // OK
pvalue = nullptr;                           // Will not compile!</code></pre>
<p class="calibre13">Finally, in the third situation, both the pointer and the object pointed to have been defined as constant and, therefore, neither can be changed:</p>
<pre class="calibre28"><code class="calibre23">int value {5};
const int* const pvalue {&amp;value};
*pvalue = 6;                                // Will not compile!
pvalue = nullptr;                           // Will not compile!</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Of course, all this applies to pointers that point to any type. A pointer to type</i> <code class="calibre23">int</code> <i class="calibre15">is used here purely for illustrative purposes. In general, to interpret more complex pointer types correctly, you just read them from right to left. The type</i> <code class="calibre23">const char*</code> <i class="calibre15">is a pointer</i> (<code class="calibre23">*</code>) <i class="calibre15">to characters</i> (<code class="calibre23">char</code>) <i class="calibre15">that are</i> <code class="calibre23">const</code> <i class="calibre15">and the type</i> <code class="calibre23">char* const</code> <i class="calibre15">is a</i> <code class="calibre23">const</code> <i class="calibre15">pointer to characters.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="157" id="calibre_link-619" class="calibre24"></span>Pointers and Arrays</h3>
<p class="calibre13">Array names can behave like pointers under some circumstances. In most situations, if you use the name of a one-dimensional array by itself, it is automatically interpreted as a pointer to the first array element . Note that this is not the case when the array name is used as the operand of the <code class="calibre23">sizeof</code> operator.</p>
<p class="calibre13">If you have these definitions,</p>
<pre class="calibre28"><code class="calibre23">double* pdata {};
double data[5];</code></pre>
<p class="calibre13">you can write this assignment:</p>
<pre class="calibre28"><code class="calibre23">pdata = data;       // Initialize pointer with the array address</code></pre>
<p class="calibre13">This assigns the address of the first element of the <code class="calibre23">data</code> to the pointer <code class="calibre23">pdata</code>. Using the array name by itself refers to the address of the array. If you use the array name <code class="calibre23">data</code> with an index value, it refers to the contents of the element corresponding to that index value. So, to store the address of an element in the pointer you use the address-of operator like this:</p>
<pre class="calibre28"><code class="calibre23">pdata = &amp;data[1];</code></pre>
<p class="calibre13">Here, <code class="calibre23">pdata</code> contains the address of the second array element.</p>
<section class="toclist">
<h4 class="calibre22">Pointer Arithmetic</h4>
<p class="calibre13">You can perform arithmetic operations with pointers. You are limited to addition and subtraction, but you can also compare pointer values to produce a logical result. Arithmetic with a pointer implicitly assumes that the pointer points to an array, and that the arithmetic operation is on the address contained in the pointer. For the pointer <code class="calibre23">pdata</code>, for example, you could assign the address of the third element of the <code class="calibre23">data</code> array to it with this statement:</p>
<pre class="calibre28"><code class="calibre23">pdata = &amp;data[2];</code></pre>
<p class="calibre13">In this case, the expression <code class="calibre23">pdata+1</code> would refer to the address of <code class="calibre23">data[3]</code>, the fourth element of the <code class="calibre23">data</code> array, so you could make <code class="calibre23">pdata</code> point to this element by writing this statement:</p>
<pre class="calibre28"><code class="calibre23">pdata += 1;          // Increment pdata to the next element</code></pre>
<p class="calibre13">This increments the address in <code class="calibre23">pdata</code> by the number of bytes occupied by one element of the <code class="calibre23">data</code> array. In general, <code class="calibre23">pdata+n</code>, where <code class="calibre23">n</code> can be any expression resulting in an integer, adds <code class="calibre23">n*sizeof(double)</code> to the address in <code class="calibre23">pdata</code>, because it is of type pointer to <code class="calibre23">double</code>. This is illustrated in <a id="calibre_link-168" href="#calibre_link-167" class="calibre3">Figure 4-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000155.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-167" href="#calibre_link-168" class="calibre3">FIGURE 4-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">In other words, incrementing or decrementing a pointer works in terms of the type of the object pointed to. Increasing a pointer to <code class="calibre23">long</code> by one changes its contents to the next <code class="calibre23">long</code> address, and so increments the address by four. Similarly, incrementing a pointer to <span {http://www.idpf.org/2007/ops}type="pagebreak" title="158" id="calibre_link-620" class="calibre14"></span><code class="calibre23">short</code> by one increments the address by two. The more common notation for incrementing a pointer by one is using the increment operator. For example:</p>
<pre class="calibre28"><code class="calibre23">pdata++;            // Increment pdata to the next element</code></pre>
<p class="calibre13">This is equivalent to (and more common than) the <code class="calibre23">+=</code> operator. However, I used <code class="calibre23">+=</code> earlier to make it clear that although the increment value is specified as one, the effect is always an address increment greater than one except for the case of a pointer to type <code class="calibre23">char</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A valid address resulting from an arithmetic operation on a pointer can be a value ranging from the address of the first element of the array to the address that is one beyond the last element, although there’s nothing to prevent you from writing expressions that result in values outside this range. Accessing an address that does not refer to an element within the array results in undefined behavior; this includes one beyond the last element of course.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You can, of course, dereference a pointer on which you have performed arithmetic (there wouldn’t be much point to it otherwise). For example, if <code class="calibre23">pdata</code> is still pointing to <code class="calibre23">data[2]</code>, this statement,</p>
<pre class="calibre28"><code class="calibre23">*(pdata + 1) = *(pdata + 2);</code></pre>
<p class="calibre13">is equivalent to this:</p>
<pre class="calibre28"><code class="calibre23">data[3] = data[4];</code></pre>
<p class="calibre13">The parentheses are necessary when you want to dereference a pointer after incrementing the address it contains because the precedence of the indirection operator is higher than that of the arithmetic operators, <code class="calibre23">+</code> and <code class="calibre23">-</code>. If you write  <code class="calibre23">*pdata+1</code>, instead of <code class="calibre23">*(pdata+1)</code>, this adds one to the value stored at the address in <code class="calibre23">pdata</code>, which is equivalent to executing <code class="calibre23">data[2]+1</code>. Because this isn’t an lvalue, its use in the previous assignment statement would cause the compiler to generate an error message.</p>
<p class="calibre13">You can use an array name as though it were a pointer for addressing elements of an array. Suppose you have the array defined as:</p>
<pre class="calibre28"><code class="calibre23">long data[5];</code></pre>
<p class="calibre13">Using pointer notation, you can refer to the element <code class="calibre23">data[3]</code>, for example, as <code class="calibre23">*(data+3)</code>. This kind of notation can be applied generally so that, corresponding to the elements <code class="calibre23">data[0], data[1], data[2]</code>, you can write <code class="calibre23">*data, *(data+1), *(data+2)</code>, and so on.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Array Names as Pointers</h3>
<p class="calibre20">You can practice this aspect of array addressing with a program to calculate prime numbers (a prime number is divisible only by itself and one):</p>
<pre class="calibre28"><code class="calibre23">// Ex4_09.cpp
// Calculating primes
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="159" id="calibre_link-621" class="calibre14"></span>using std::endl;
using std::setw;
        
int main()
{
   const int MAX {100};           // Number of primes required
   long primes[MAX] { 2,3,5 };    // First three primes defined
   long trial {5};                // Candidate prime
   int count {3};                 // Count of primes found
   bool found {false};            // Indicates when a prime is found
        
   do
   {
      trial += 2;                     // Next value for checking
      found = false;                  // Set found indicator
        
      for(int i {}; i &lt; count; i++)   // Try division by existing primes
      {
         found = (trial % *(primes + i)) == 0;// True for exact division
           if(found)                          // If division is exact
              break;                          // it's not a prime
      }
        
      if (!found)                      // We got one...
         *(primes + count++) = trial;  // ...so save it in primes array
   }while(count &lt; MAX);
        
   // Output primes 5 to a line
   for(int i {}; i &lt; MAX; i++)
   {
      if(i % 5 == 0)               // New line on 1st, and every 5th line
         cout &lt;&lt; endl;
      cout &lt;&lt; setw(10) &lt;&lt; *(primes + i);
   }
   cout &lt;&lt; endl;
        
   return 0;
}</code></pre>
<p class="calibre20">If you compile and execute this example, you should get the following output:</p>
<pre class="calibre28"><code class="calibre23">         2         3         5         7        11
        13        17        19        23        29
        31        37        41        43        47
        53        59        61        67        71
        73        79        83        89        97
       101       103       107       109       113
       127       131       137       139       149
       151       157       163       167       173
       179       181       191       193       197
       199       211       223       227       229
       233       239       241       251       257
       263       269       271       277       281
       283       293       307       311       313
       317       331       337       347       349
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="160" id="calibre_link-622" class="calibre14"></span>       353       359       367       373       379
       383       389       397       401       409
       419       421       431       433       439
       443       449       457       461       463
       467       479       487       491       499
       503       509       521       523       541</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You have the usual <code class="calibre23">#include</code> statements for the <code class="calibre23">iostream</code> header for input and output, and for <code class="calibre23">iomanip</code>, because you use a stream manipulator to set the field width for output.</p>
<p class="calibre20">You use the constant <code class="calibre23">MAX</code> to define the number of primes that you want the program to produce. The <code class="calibre23">primes</code> array, which stores the results, is initialized with the first three primes to start the process off. All the work is done in two loops. The outer <code class="calibre23">do-while</code> loop picks the next value to be checked and adds the value to the <code class="calibre23">primes</code> array if it is prime, and the inner <code class="calibre23">for</code> loop that checks the value to see whether it’s prime or not.</p>
<p class="calibre20">The algorithm in the <code class="calibre23">for</code> loop is very simple and is based on the fact that if a number is not a prime, it must be divisible by one of the primes found so far &mdash; all of which are less than the number in question because all numbers are either prime or a product of primes. In fact, it is only necessary to divide by primes less than or equal to the square root of the number in question, so this example isn’t as efficient as it might be:</p>
<pre class="calibre28"><code class="calibre23">found = (trial % *(primes + i)) == 0;  // True for exact division</code></pre>
<p class="calibre20">This statement sets <code class="calibre23">found</code> to <code class="calibre23">true</code> if there’s no remainder from dividing <code class="calibre23">trial</code> by the current prime <code class="calibre23">*(primes + i)</code> (remember that this is equivalent to <code class="calibre23">primes[i]</code>), and to <code class="calibre23">false</code> otherwise. The <code class="calibre23">if</code> statement causes the <code class="calibre23">for</code> loop to be terminated if <code class="calibre23">found</code> is <code class="calibre23">true</code> because the candidate in <code class="calibre23">trial</code> can’t be a prime in that case.</p>
<p class="calibre20">After the <code class="calibre23">for</code> loop ends (for whatever reason), it’s necessary to decide whether or not the value in <code class="calibre23">trial</code> was prime. This is indicated by the value in <code class="calibre23">found</code>:</p>
<pre class="calibre28"><code class="calibre23">*(primes + count++) = trial;   // ...so save it in primes array</code></pre>
<p class="calibre20">If <code class="calibre23">trial</code> does contain a prime, this statement stores the value in <code class="calibre23">primes[count]</code> and then increments <code class="calibre23">count</code> through the postfix increment operator.</p>
<p class="calibre20">After <code class="calibre23">MAX</code> primes have been found, they are output with a field width of 10 characters, 5 to a line, as a result of this statement:</p>
<pre class="calibre28"><code class="calibre23">if(i % 5 == 0)              // New line on 1st, and every 5th line
   cout &lt;&lt; endl;</code></pre>
<p class="calibre20">This starts a new line when <code class="calibre23">i</code> has the values <code class="calibre23">0, 5, 10</code>, and so on.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Counting Characters Revisited</h3>
<p class="calibre20">To see how to handle strings in pointer notation, you could produce a version of the program you looked at earlier for counting the characters in a string:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="161" id="calibre_link-623" class="calibre14"></span>// Ex4_10.cpp
// Counting string characters using a pointer
#include &lt;iostream&gt;
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
   const int MAX {80};                 // Maximum array dimension
   char buffer[MAX];                   // Input buffer
   char* pbuffer {buffer};             // Pointer to array buffer
        
   cout &lt;&lt; endl                        // Prompt for input
        &lt;&lt; "Enter a string of less than "
        &lt;&lt; MAX &lt;&lt; " characters:"
        &lt;&lt; endl;
        
   cin.getline(pbuffer, MAX, '\n');    // Read a string until \n
        
   while(*pbuffer)                     // Continue until \0
      pbuffer++;
        
   cout &lt;&lt; endl
        &lt;&lt; "The string \"" &lt;&lt; buffer
        &lt;&lt; "\" has " &lt;&lt; pbuffer - buffer &lt;&lt; " characters.";
   cout &lt;&lt; endl;
        
   return 0;
}</code></pre>
<p class="calibre20">Here’s an example of output from this example:</p>
<pre class="calibre28"><code class="calibre23">Enter a string of less than 80 characters:
The tigers of wrath are wiser than the horses of instruction.
The string "The tigers of wrath are wiser than the horses of
instruction." has 61 characters.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The program uses the pointer <code class="calibre23">pbuffer</code> rather than the array name <code class="calibre23">buffer</code>. You don’t need the <code class="calibre23">count</code> variable because the pointer is incremented in the <code class="calibre23">while</code> loop until <code class="calibre23">'\0'</code> is found. When <code class="calibre23">'\0'</code> is found, <code class="calibre23">pbuffer</code> will contain the address of that position in the string. The count of the number of characters in the string is therefore the difference between the address in <code class="calibre23">pbuffer</code>, and the address of the beginning of the array denoted by <code class="calibre23">buffer</code>.</p>
<p class="calibre20">You could have incremented the pointer in the loop by writing the loop like this:</p>
<pre class="calibre28"><code class="calibre23">while(*pbuffer++);                   // Continue until \0</code></pre>
<p class="calibre20">Now the loop contains no statements, only the test condition. This would work adequately, except that the pointer would be incremented after <code class="calibre23">'\0'</code> was encountered, so the address would be one more than the last position in the string. You would therefore need to express the count of the number of characters in the string as <code class="calibre23">pbuffer&ndash;buffer-1</code>.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="162" id="calibre_link-624" class="calibre14"></span>Note that you can’t use the array name here in the same way that you have used the pointer. The expression <code class="calibre23">buffer++</code> is strictly illegal because you can’t modify the address value that an array name represents. Even though you can use an array name in an expression as though it is a pointer, it isn’t a pointer, because the address value that it represents is fixed.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Using Pointers with Multidimensional Arrays</h4>
<p class="calibre13">Using a pointer to store the address of a one-dimensional array is relatively straightforward, but with multidimensional arrays, things can get a little complicated. If you don’t intend to use pointers with multidimensional arrays, you can skip this section, as it’s a little obscure; however, if you have previous experience with C++, this section is worth a glance.</p>
<p class="calibre13">If you have to use a pointer with multidimensional arrays, you need to keep clear in your mind what is happening. By way of illustration, you can use an array <code class="calibre23">beans</code>, defined as follows:</p>
<pre class="calibre28"><code class="calibre23">double beans[3][4];</code></pre>
<p class="calibre13">You can define and assign a value to the pointer <code class="calibre23">pbeans</code>, as follows:</p>
<pre class="calibre28"><code class="calibre23">double* pbeans;
pbeans = &amp;beans[0][0];</code></pre>
<p class="calibre13">Here, you are setting the pointer to the address of the first element of the array, which is of type <code class="calibre23">double</code>. You could also set the pointer to the address of the first row in the array with the statement:</p>
<pre class="calibre28"><code class="calibre23">pbeans = beans[0];</code></pre>
<p class="calibre13">This is equivalent to using the name of a one-dimensional array, which is replaced by its address. You used this in the earlier discussion; however, because <code class="calibre23">beans</code> is a two-dimensional array, you cannot set an address in the pointer with the following statement:</p>
<pre class="calibre28"><code class="calibre23">pbeans = beans;           // Will cause an error!!</code></pre>
<p class="calibre13">The problem is one of type. The type of the pointer is <code class="calibre23">double*</code>, but the array is of type <code class="calibre23">double[3][4]</code>. A pointer to store the address of this array must be of type <code class="calibre23">double*[4]</code>. C++ associates the dimensions of the array with its type, and the preceding statement is only legal if the pointer has been defined with the dimension required. This can be done with a slightly more complicated notation than you have seen so far:</p>
<pre class="calibre28"><code class="calibre23">double (*pbeans)[4];</code></pre>
<p class="calibre13">The parentheses here are essential; otherwise, you would be declaring an array of pointers. Now the previous statement is legal, but this pointer can only be used to store addresses of an array with the dimensions shown. The <code class="calibre23">auto</code> keyword can help out here. You can write the statement as:</p>
<pre class="calibre28"><code class="calibre23">auto pbeans = beans;</code></pre>
<p class="calibre13">Now the compiler will deduce the correct type for you.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Pointer Notation with Multidimensional Arrays</h4>
<p class="calibre13">You can use pointer notation with an array name to reference elements of the array. You can reference each element of the array <code class="calibre23">beans</code> that you defined earlier, which had three rows of four elements, in two ways:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="163" id="calibre_link-625" class="calibre14"></span>Using the array name with two index values</li>
<li class="calibre6">Using the array name in pointer notation</li>
</ul>
<p class="calibre13">Therefore, the following two expressions are equivalent:</p>
<pre class="calibre28"><code class="calibre23">beans[i][j]
*(*(beans + i) + j)</code></pre>
<p class="calibre13">Let’s look at how these work. The first expression uses normal array indexing to refer to the element with offset <code class="calibre23">j</code> in row <code class="calibre23">i</code> of the array.</p>
<p class="calibre13">You can determine the meaning of the second expression by working from the inside outwards. <code class="calibre23">beans</code> refers to the address of the first row of the array, so <code class="calibre23">beans+i</code> refers to row <code class="calibre23">i</code>. The expression <code class="calibre23">*(beans+i)</code> is the address of the first element of row <code class="calibre23">i</code>, so <code class="calibre23">*(beans+i)+j</code> is the address of the element in row <code class="calibre23">i</code> with offset <code class="calibre23">j</code>. The whole expression therefore refers to the value of that element.</p>
<p class="calibre13">If you really want to be obscure &mdash; and it isn’t recommended that you should be &mdash; the following two statements, where you have mixed array and pointer notation, are also legal references to the same element of the array:</p>
<pre class="calibre28"><code class="calibre23">*(beans[i] + j)
(*(beans + i))[j]</code></pre>
<p class="calibre13">There is yet another aspect to using pointers that is the most important of all: the ability to allocate memory dynamically. You’ll look into that next.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-264" class="calibre3"></a>DYNAMIC MEMORY ALLOCATION</h2>
<p class="calibre13">Working with a fixed set of variables in a program can be very restrictive. You’ll often want to allocate space for variables at execution time, depending on the input data. Any program that processes a number of data items that is not known in advance can take advantage of the ability to allocate memory at run time. For example, in a program that stores information about the students in a class, the number of students is not fixed and their names will vary in length, so to deal with the data most efficiently, you’ll want to allocate space at execution time.</p>
<p class="calibre13">Obviously, because dynamically allocated variables can’t have been defined at compile time, they can’t be named in your code. When they are created, they are identified by their address, which you store in a pointer. With the power of pointers, and the dynamic memory management tools in Visual C++, writing your programs to have this kind of flexibility is quick and easy.</p>
<section class="toclist">
<h3 class="calibre21">The Free Store, Alias the Heap</h3>
<p class="calibre13">In most instances, when your program is executed, there is unused memory in your computer. This unused memory is called the <i class="calibre15">heap</i>, or the <i class="calibre15">free store</i>. You can allocate space within the free store for a new variable of a given type using a special operator that returns the address of the space allocated. This operator is <code class="calibre23">new</code>, and it’s complemented by the operator <code class="calibre23">delete</code>, which releases memory previously allocated by <code class="calibre23">new</code>.</p>
<p class="calibre13">You can allocate space in the free store for variables in one part of a program, and then release the space and return it to the free store after you have finished with it. This makes the memory available <span {http://www.idpf.org/2007/ops}type="pagebreak" title="164" id="calibre_link-626" class="calibre14"></span>for reuse by other dynamically allocated variables. This is a powerful technique; it enables you to use memory very efficiently and in many cases results in programs that can handle much larger problems, involving considerably more data than otherwise might be possible.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The new and delete Operators</h3>
<p class="calibre13">Suppose that you need space for a <code class="calibre23">double</code> variable. You can define a pointer to type <code class="calibre23">double</code> and then request that the memory be allocated at execution time. You can do this using the <code class="calibre23">new</code> operator:</p>
<pre class="calibre28"><code class="calibre23">double* pvalue {};
pvalue = new double;      // Request memory for a double variable</code></pre>
<p class="calibre13">This is a good moment to recall that <i class="calibre15">all pointers should be initialized</i>. Using memory dynamically typically involves a number of pointers floating around, so it’s important that they should not contain spurious values. You always set a pointer that doesn’t contain a legal address value to <code class="calibre23">nullptr</code>.</p>
<p class="calibre13">The <code class="calibre23">new</code> operator in the second line of code should return the address of the memory in the free store allocated to a <code class="calibre23">double</code> variable, and this address is stored in the pointer <code class="calibre23">pvalue</code>. You can then use this pointer to reference the variable using the indirection operator, as you have seen. For example:</p>
<pre class="calibre28"><code class="calibre23">*pvalue = 9999.0;</code></pre>
<p class="calibre13">Of course, the memory may not have been allocated because the free store had been used up, or because the free store is fragmented by previous usage &mdash; meaning that there aren’t sufficient contiguous bytes to accommodate the variable for which you want to obtain space. You don’t have to worry too much about this. The <code class="calibre23">new</code> operator will throw an <i class="calibre15">exception</i> if the memory cannot be allocated for any reason, which terminates your program. Exceptions are a mechanism for signaling errors in C++; you learn about these in Chapter 6.</p>
<p class="calibre13">You can initialize a variable created by <code class="calibre23">new</code>. Taking the example of the <code class="calibre23">double</code> variable that was allocated by <code class="calibre23">new</code> and the address stored in <code class="calibre23">pvalue</code>, you could have set the value to 999.0, as it was created with this statement:</p>
<pre class="calibre28"><code class="calibre23">pvalue = new double {999.0};   // Allocate a double and initialize it</code></pre>
<p class="calibre13">Of course, you could create the pointer and initialize it in a single statement, like this:</p>
<pre class="calibre28"><code class="calibre23">double* pvalue { new double{999.0} };</code></pre>
<p class="calibre13">When you no longer need a variable that has been dynamically allocated, you can free the memory that it occupies with the <code class="calibre23">delete</code> operator:</p>
<pre class="calibre28"><code class="calibre23">delete pvalue;                 // Release memory pointed to by pvalue</code></pre>
<p class="calibre13">This ensures that the memory can be used for something else. If you don’t use <code class="calibre23">delete</code>, and you store a different address in <code class="calibre23">pvalue</code>, it will be impossible to free the memory or to use the data that it contains, because access to the address is lost. In this situation, you have what is referred to as a <i class="calibre15">memory leak</i>, especially when it recurs in your program.</p>
<p class="calibre13">You should set a pointer to <code class="calibre23">nullptr</code> when you release the memory to which it points. If you don’t, you have what is called a <i class="calibre15">dangling pointer</i>, through which you might attempt to access memory that has been freed.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="165" id="calibre_link-627" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In Chapter 10 I’ll explain smart pointers, which is an alternative to the pointers I have discussed in this chapter. When you are allocating memory dynamically, especially for arrays or more complex objects, it is often better to use a smart pointer. A smart pointer takes care of deleting the memory automatically when it is no longer required so you no longer have to worry about it. I’ll defer discussion of smart pointers until Chapter 10 because there are several things you need to learn about before you can understand smart pointers.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Allocating Memory Dynamically for Arrays</h3>
<p class="calibre13">Allocating memory for an array dynamically is very straightforward. To allocate an array of type <code class="calibre23">char</code>, you could write this statement:</p>
<pre class="calibre28"><code class="calibre23">char* pstr {new char[20]};     // Allocate a string of twenty characters</code></pre>
<p class="calibre13">This allocates space for a <code class="calibre23">char</code> array of 20 characters and stores its address in <code class="calibre23">pstr</code>. To remove the array that you have just created, you use the <code class="calibre23">delete</code> operator. The statement would look like this:</p>
<pre class="calibre28"><code class="calibre23">delete [] pstr;                // Delete array pointed to by pstr</code></pre>
<p class="calibre13">Note the use of square brackets to indicate that you are deleting an array. When removing arrays from the free store, you should always include the square brackets, or the results will be unpredictable. Note that you do not specify any dimensions here, simply use <code class="calibre23">[]</code>.</p>
<p class="calibre13">Of course, <code class="calibre23">pstr</code> now contains the address of memory that may already have been allocated for some other purpose, so it certainly should not be used. When you use <code class="calibre23">delete</code> to discard memory you previously allocated, you should always reset the pointer, like this:</p>
<pre class="calibre28"><code class="calibre23">pstr = nullptr;</code></pre>
<p class="calibre13">This ensures that you cannot access the memory that has been released.</p>
<p class="calibre13">You can initialize an array allocated in the free store:</p>
<pre class="calibre28"><code class="calibre23">int *data {new int[10] {2,3,4}};</code></pre>
<p class="calibre13">This statement creates an array of 10 integer elements and initializes the first three with 2, 3, and 4. The remaining elements will be initialized to 0.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In Chapter 10 I’ll also explain containers, which you can use to store collections of items in a much more flexible way than standard arrays.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Free Store</h3>
<p class="calibre20">You can see how dynamic memory allocation works by rewriting the program that calculates an arbitrary number of primes, this time using memory in the free store to store the primes:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_11.cpp
// Calculating primes using dynamic memory allocation
#include &lt;iostream&gt;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="166" id="calibre_link-628" class="calibre14"></span>#include &lt;iomanip&gt;
using std::cin;
using std::cout;
using std::endl;
using std::setw;
        
int main()
{
   int max {};                               // Number of primes required
   cout &lt;&lt; endl
        &lt;&lt; "Enter the number of primes you would like (at least 4): ";
   cin &gt;&gt; max;                    
        
   if(max &lt; 4)                               // Test the user input, if less than 4
      max = 4;                               // ensure it is at least 4
        
   // Allocate prime array and initialize with seed primes   
   long* pprime {new long[max] {2L, 3L, 5L} }; 
 
   long trial {5L};                          // Candidate prime
   int count {3};                            // Count of primes found
   bool found {false};                       // Indicates when a prime is found
 
 
 
        
   do
   {
      trial += 2L;                           // Next value for checking
      found = false;                         // Set found indicator
        
      for(int i {}; i &lt; count; i++)          // Division by existing primes
      {
         found =(trial % *(pprime + i)) == 0;// True for exact division
         if(found)                           // If division is exact
            break;                           // it's not a prime
      }
        
      if (!found)                            // We got one...
         *(pprime + count++) = trial;        // ...so save it in primes array
   } while(count &lt; max);
        
   // Output primes 5 to a line
   for(int i {}; i &lt; max; i++)
   {
      if(i % 5 == 0)                         // New line on 1st, and every 5th line
         cout &lt;&lt; endl;
      cout &lt;&lt; setw(10) &lt;&lt; *(pprime + i);
   }
        
   delete [] pprime;                         // Free up memory...
   pprime = nullptr;                         // ...and reset the pointer
   cout &lt;&lt; endl;
   return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="167" id="calibre_link-629" class="calibre14"></span>Here’s an example of the output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter the number of primes you would like (at least 4): 20
         2         3         5         7        11
        13        17        19        23        29
        31        37        41        43        47
        53        59        61        67        71</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">After receiving the number of primes required in the <code class="calibre23">int</code> variable <code class="calibre23">max</code>, you make sure that <code class="calibre23">max</code> can be no less than 4. This is because the program requires space to be allocated for at least the three seed primes, plus one new one. You specify the size of the array by putting the variable <code class="calibre23">max</code> between the square brackets following the array type specification:</p>
<pre class="calibre28"><code class="calibre23">   long* pprime {new long[max] {2L, 3L, 5L} };</code></pre>
<p class="calibre20">The program would terminate at this point if the memory could not be allocated for <code class="calibre23">pprime</code>. The statement also initializes the first three elements of the array to the first three prime values. The remaining elements will be 0.</p>
<p class="calibre20">The calculation of the primes is exactly as before; the only change is that the name of the pointer, <code class="calibre23">pprime</code>, replaces the array name, <code class="calibre23">primes</code>, that you used in the previous version. Equally, the output process is the same. Acquiring space dynamically is really not a problem. After it has been allocated, it in no way affects how the computation is written.</p>
<p class="calibre20">After you finish with the array, you remove it from the free store using <code class="calibre23">delete</code>, remembering to include the square brackets to indicate that it is an array:</p>
<pre class="calibre28"><code class="calibre23">   delete [] pprime;             // Free up memory</code></pre>
<p class="calibre20">Although it’s not essential here, you also reset the pointer:</p>
<pre class="calibre28"><code class="calibre23">   pprime = nullptr;            // and reset the pointer</code></pre>
<p class="calibre20">All memory allocated in the free store is released when your program ends, but it is good to get into the habit of resetting pointers to <code class="calibre23">nullptr</code> when they no longer point to valid memory areas.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Dynamic Allocation of Multidimensional Arrays</h3>
<p class="calibre13">Allocating memory in the free store for a multidimensional array involves using the <code class="calibre23">new</code> operator in a slightly more complicated form than is used for a one-dimensional array. Suppose that you define the pointer <code class="calibre23">pbeans</code> like this:</p>
<pre class="calibre28"><code class="calibre23">double (*pbeans)[4] {};</code></pre>
<p class="calibre13">To obtain the space for the array <code class="calibre23">beans[3][4]</code> that you used earlier in this chapter, you could write this:</p>
<pre class="calibre28"><code class="calibre23">pbeans = new double [3][4];              // Allocate memory for a 3x4 array</code></pre>
<p class="calibre13">You just specify both array dimensions between square brackets after the type name for the elements. Of course, you could do it all in one go:</p>
<pre class="calibre28"><code class="calibre23">double (*pbeans)[4] {new double [3][4]};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="168" id="calibre_link-630" class="calibre14"></span>Allocating space for a three-dimensional array simply requires that you specify the extra dimension, as in this example:</p>
<pre class="calibre28"><code class="calibre23">auto pBigArray (new double [5][10][10]); // Allocate memory for a 5x10x10 array</code></pre>
<p class="calibre13">This uses <code class="calibre23">auto</code> to have the pointer type determined automatically. Don’t forget &mdash; you can’t use an initializer list with <code class="calibre23">auto</code>. You could write it as:</p>
<pre class="calibre28"><code class="calibre23">auto pBigArray = new double [5][10][10]; // Allocate memory for a 5x10x10 array</code></pre>
<p class="calibre13">However many dimensions there are in the array that has been created, to destroy it and release the memory back to the free store, you write the following:</p>
<pre class="calibre28"><code class="calibre23">delete [] pBigArray;                     // Release memory for array
pBigArray = nullptr;</code></pre>
<p class="calibre13">You always use just one pair of square brackets following the <code class="calibre23">delete</code> operator, regardless of the dimensionality of the array.</p>
<p class="calibre13">You have already seen that you can use a variable as the specification of the dimension of a one-dimensional array to be allocated by <code class="calibre23">new</code>. This extends to two or more dimensions, but with the restriction that only the leftmost dimension may be specified by a variable. All the other dimensions must be constants or constant expressions. So, you could write this,</p>
<pre class="calibre28"><code class="calibre23">pBigArray = new double[max][10][10];</code></pre>
<p class="calibre13">where <code class="calibre23">max</code> is a variable; however, specifying a variable for any dimension other than the leftmost causes an error message to be generated by the compiler.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-265" class="calibre3"></a>USING REFERENCES</h2>
<p class="calibre13">A <i class="calibre15">reference</i> appears to be similar to a pointer in many respects, which is why I’m introducing it here, but it really isn’t. The importance of references becomes apparent only when you get to explore their use with functions, particularly in the context of object-oriented programming. Don’t be misled by their simplicity and what might seem to be a trivial concept here. As you’ll see later, references provide some extraordinarily powerful facilities, and in some contexts enable you to achieve results that would be impossible without them.</p>
<section class="toclist">
<h3 class="calibre21">What Is a Reference?</h3>
<p class="calibre13">Essentially, a reference is a name that can be used as an alias for something else. There are two kinds of references: <i class="calibre15">lvalue references</i> and <i class="calibre15">rvalue references</i>.</p>
<p class="calibre13">An lvalue reference is an alias for another variable; it is called an <i class="calibre15">lvalue</i> reference because it refers to a persistent storage location that can appear on the left of an assignment operation. Because an lvalue reference is an alias, the variable for which it is an alias has to exist when the reference is defined. Unlike a pointer, a reference cannot be altered to represent something else.</p>
<p class="calibre13">An <i class="calibre15">rvalue</i> reference can be used as an alias for a variable, just like an lvalue reference, but it differs from an lvalue reference in that it can also reference an rvalue, which is a temporary value that is essentially transient.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="169" id="calibre_link-631" class="calibre24"></span>Declaring and Initializing Lvalue References</h3>
<p class="calibre13">Suppose that you have defined a variable as:</p>
<pre class="calibre28"><code class="calibre23">long number {};</code></pre>
<p class="calibre13">You can define an lvalue reference for this variable using this statement:</p>
<pre class="calibre28"><code class="calibre23">long&amp; rnumber {number};        // Declare a reference to variable number</code></pre>
<p class="calibre13">The ampersand following the type name <code class="calibre23">long</code> and preceding the variable name <code class="calibre23">rnumber</code>, indicates that an lvalue reference is being defined, and that the variable name it represents, <code class="calibre23">number</code>, is specified as the initializing value between the parentheses; therefore <code class="calibre23">rnumber</code> is of type ‘reference to <code class="calibre23">long'</code>. You can use the reference in place of the original variable name. For example:</p>
<pre class="calibre28"><code class="calibre23">rnumber += 10L;</code></pre>
<p class="calibre13">This will increment <code class="calibre23">number</code> by 10.</p>
<p class="calibre13">Note that you cannot write:</p>
<pre class="calibre28"><code class="calibre23">int&amp; rfive {5};                // Will not compile!</code></pre>
<p class="calibre13">The literal 5 is constant and cannot be changed. To protect the integrity of constant values, you must use a <code class="calibre23">const</code> reference:</p>
<pre class="calibre28"><code class="calibre23">const int&amp; rfive {5};          // OK</code></pre>
<p class="calibre13">Now you can access the literal 5 through the <code class="calibre23">rfive</code> reference. Because you define <code class="calibre23">rfive</code> as <code class="calibre23">const</code>, it cannot be used to change the value it references.</p>
<p class="calibre13">Let’s contrast the lvalue reference <code class="calibre23">rnumber</code> in the previous code with the pointer <code class="calibre23">pnumber</code>, defined in this statement:</p>
<pre class="calibre28"><code class="calibre23">long* pnumber {&amp;number};       // Initialize a pointer with an address</code></pre>
<p class="calibre13">This defines the pointer <code class="calibre23">pnumber</code>, and initializes it with the address of <code class="calibre23">number</code>. This allows <code class="calibre23">number</code> to be incremented with a statement such as:</p>
<pre class="calibre28"><code class="calibre23">*pnumber += 10L;               // Increment number through a pointer</code></pre>
<p class="calibre13">There is a significant distinction between using a pointer and using a reference. You must dereference the pointer to access the variable to which it points in the expression. With a reference, there is no need for dereferencing. In some ways, a reference is like a pointer that has already been dereferenced, although it can’t be changed to reference something else. An lvalue reference is the complete equivalent of the variable for which it is a reference.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using References in a Range-based for Loop</h3>
<p class="calibre13">Earlier in this chapter you saw a code snippet using a range-based <code class="calibre23">for</code> loop to iterate over an array of temperatures:</p>
<pre class="calibre28"><code class="calibre23">for(auto t : temperatures)
{
  sum += t;
  ++count;
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="170" id="calibre_link-632" class="calibre14"></span>The <code class="calibre23">t</code> variable does not reference an array element, only its value, so you cannot use it to modify the element. However, you can by using a reference:</p>
<pre class="calibre28"><code class="calibre23">const double FtoC {5.0/9.0};           // Convert Fahrenheit to Centigrade
for(auto&amp; t : temperatures)
  t = (t - 32)*FtoC;
for(auto&amp; t : temperatures)
  cout &lt;&lt; "  " &lt;&lt; t;
cout &lt;&lt; endl;</code></pre>
<p class="calibre13">The variable <code class="calibre23">t</code> will now be of type <code class="calibre23">double&amp;</code> and will reference each array element directly. This loop changes the values in the array from Fahrenheit to Centigrade.</p>
<p class="calibre13">Using a reference in a range-based <code class="calibre23">for</code> loop is particularly valuable when you are working with collections of objects. Copying objects can be expensive on time, so avoiding copying by using a reference type makes your code more efficient. You will learn about collections of objects in Chapter 10 when the range-based <code class="calibre23">for</code> loop comes into its own.</p>
<p class="calibre13">If you want to use references with the range-based <code class="calibre23">for</code> loop for performance reasons, but you don’t want to be able to modify the values, you can use <code class="calibre23">const auto&amp;</code>, as in:</p>
<pre class="calibre28"><code class="calibre23">for (const auto&amp; t : temperatures)
  cout &lt;&lt; "  " &lt;&lt; t;</code></pre>
</section>
<section class="toclist">
<h3 class="calibre21">Creating Rvalue References</h3>
<p class="calibre13">I am explaining rvalue references here because the concept is related to that of lvalue references, but I cannot go into the significance of rvalue references at this point. Rvalue references are particularly important in the context of functions, which you’ll learn about in Chapter 5. You’ll also learn more about rvalue references in subsequent chapters.</p>
<p class="calibre13">As you know, every expression is either an rvalue or an lvalue. A variable is an lvalue because it represents a location in memory. An rvalue is different. It represents the result of evaluating an expression. Thus, an lvalue reference is a reference to a variable that has a name, and allows the contents of the memory that the variable represents to be accessed through the lvalue reference. An rvalue reference is a reference to memory containing the result of evaluating an expression.</p>
<p class="calibre13">You specify an rvalue reference type using two ampersands following the type name. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">int x {5};
int&amp;&amp; rExpr {2*x + 3};                   // rvalue reference
cout &lt;&lt; rExpr &lt;&lt; endl;
int&amp; rx {x};                              // lvalue reference
cout &lt;&lt; rx &lt;&lt; endl;</code></pre>
<p class="calibre13">Here, the rvalue reference is initialized to reference the result of evaluating the expression <code class="calibre23">2*x+3</code>, which is a temporary value &mdash; an rvalue. The output will be 13. You cannot do this with an lvalue reference. Is this useful? In this case, no, indeed it is not recommended at all; but in a different context, it is very useful.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="171" id="calibre_link-633" class="calibre14"></span><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">The preceding code fragment will compile and execute, but it is definitely NOT the way to use an rvalue reference. This is just to illustrate what an rvalue reference is.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-266" class="calibre3"></a>LIBRARY FUNCTIONS FOR STRINGS</h2>
<p class="calibre13">The <code class="calibre23">cstring</code> standard header defines functions that operate on null-terminated strings. These are functions that are specified in the C++ standard and are defined in the <code class="calibre23">std</code> namespace. There are alternatives to some of these that are not standard and therefore not in the <code class="calibre23">std</code> namespace, but which provide a more secure implementation of the function than the original versions. In general, the secure functions have names ending with <code class="calibre23">_s</code> and I’ll use the more secure versions in examples. Let’s explore some of the most useful functions provided by the <code class="calibre23">cstring</code> header.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">string</code> <i class="calibre15">standard header defines the</i> <code class="calibre23">string</code> <i class="calibre15">and</i> <code class="calibre23">wstring</code> <i class="calibre15">classes that represent character strings. The</i> <code class="calibre23">string</code> <i class="calibre15">class represents strings of characters of type</i> <code class="calibre23">char</code> <i class="calibre15">and the</i> <code class="calibre23">wstring</code> <i class="calibre15">class represents strings of characters of type</i> <code class="calibre23">wchar_t</code>. <i class="calibre15">Both are defined in the</i> <code class="calibre23">string</code> <i class="calibre15">header as template classes that are instances of the</i> <code class="calibre23">basic_string&lt;T&gt;</code> <i class="calibre15">class template. I won’t be discussing templates and the</i> <code class="calibre23">string</code> <i class="calibre15">and</i> <code class="calibre23">wstring</code> <i class="calibre15">classes until Chapter 8, but I am mentioning them here because they are much better and safer to use.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">Finding the Length of a Null-terminated String</h3>
<p class="calibre13">The <code class="calibre23">strlen()</code> function returns the length of the argument string of type <code class="calibre23">char*</code> as a value of type <code class="calibre23">size_t</code>. The <code class="calibre23">wcslen()</code> function does the same thing for strings of type <code class="calibre23">wchar_t*</code>.</p>
<p class="calibre13">Here’s how you use the <code class="calibre23">strlen()</code> function:</p>
<pre class="calibre28"><code class="calibre23">const char* str {"A miss is as good as a mile."};
std::cout &lt;&lt; "The string contains " &lt;&lt;  std::strlen(str) &lt;&lt; " characters.";</code></pre>
<p class="calibre13">The output produced when this fragment executes is:</p>
<pre class="calibre28"><code class="calibre23">The string contains 28 characters.</code></pre>
<p class="calibre13">As you can see from the output, the length that is returned does not include the terminating null. It is important to keep this in mind, especially when you are using the length of one string to create another.</p>
<p class="calibre13">Both <code class="calibre23">strlen()</code> and <code class="calibre23">wcslen()</code> find the length by looking for the null at the end. If there isn’t one, the functions will happily continue beyond the end of the string, checking throughout memory in the hope of finding a null. For this reason, these functions represent a security risk when you are working with data from an untrusted external source. It is generally better to use the <code class="calibre23">strnlen()</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="172" id="calibre_link-634" class="calibre14"></span>and <code class="calibre23">wcsnlen()</code> functions, both of which require a second argument that specifies the length of the buffer in which the string specified by the first argument is stored. For example:</p>
<pre class="calibre28"><code class="calibre23">char str[30] {"A miss is as good as a mile."};
std::cout &lt;&lt; "The string contains " &lt;&lt;  strnlen(str, _countof(str)) 
          &lt;&lt; " characters.";</code></pre>
<p class="calibre13">The second argument to <code class="calibre23">strnlen()</code> is provided by the <code class="calibre23">_countof()</code> macro.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In this example I switched to using</i> <code class="calibre23">char str[30]</code> <i class="calibre15">while in the previous example it was</i> <code class="calibre23">const char*</code>. <i class="calibre15">This is because</i> <code class="calibre23">_countof()</code> <i class="calibre15">doesn’t work with type</i> <code class="calibre23">const char*</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Joining Null-terminated Strings</h3>
<p class="calibre13">The <code class="calibre23">strcat()</code> function  that concatenates two null-terminated strings is deprecated because it is unsafe. The <code class="calibre23">strcat_s()</code> function is the safe alternative. The string specified by the second argument to <code class="calibre23">strcat_s()</code> is appended to the string specified by the first argument. Here’s an example of how you might use it:</p>
<pre class="calibre28"><code class="calibre23">const size_t count {30};
char str1[count] {"Many hands"};
const char* str2 {" make light work."};
        
errno_t error {strcat_s(str1, str2)};
        
if(error == 0)
    std::cout &lt;&lt; "Strings joined successfully.\n"
              &lt;&lt; str1 &lt;&lt; std::endl;
        
else if(error == EINVAL)
  std::cout &lt;&lt;"Error! Source or destination string address is a null pointer." 
            &lt;&lt; std::endl;
        
else if(error == ERANGE)
  std::cout &lt;&lt; "Error! Destination string too small." &lt;&lt; std::endl;</code></pre>
<p class="calibre13">For convenience, I defined the array size as the constant <code class="calibre23">count</code>. The first argument to <code class="calibre23">strcat_s()</code> is the destination string to which the source string specified by the second argument is to be appended. The function returns an integer value of type <code class="calibre23">errno_t</code> to indicate how things went. The return value will be zero if the operation is successful, <code class="calibre23">EINVAL</code> if the source or destination is <code class="calibre23">nullptr</code>, or <code class="calibre23">ERANGE</code> if the destination length is too small. In the event of an error, the destination will be left unchanged. The error code values <code class="calibre23">EINVAL</code> and <code class="calibre23">ERANGE</code> are defined in the <code class="calibre23">cerrno</code> header, which is included indirectly in the <code class="calibre23">iostream</code> header. Of course, you are not obliged to test for the error codes that the function might return but it is good practice.</p>
<p class="calibre13">As <a id="calibre_link-170" href="#calibre_link-169" class="calibre3">Figure 4-8</a> shows, the first character of the string specified by the second argument overwrites the terminating null of the first argument, and all the remaining characters of the second string are copied across, including the terminating null. Thus, the output from the fragment will be:</p>
<figure class="calibre16">
<img class="center" src="images/000029.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-169" href="#calibre_link-170" class="calibre3">FIGURE 4-8</a></b></span></p>
</figcaption>
</figure>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="173" id="calibre_link-635" class="calibre14"></span>Strings joined successfully.
Many hands make light work.</code></pre>
<p class="calibre13">The <code class="calibre23">wcscat_s()</code> function is the safe alternative to <code class="calibre23">wcscat()</code> that concatenates wide-character strings, and works in the same way as the <code class="calibre23">strcat_s()</code> function.</p>
<p class="calibre13">With the <code class="calibre23">strncat_s()</code> function you can append part of one null-terminated string to another. The first two arguments are the destination and source strings respectively, and the third argument is a count of the number of characters from the source string that are to be appended. With the strings as defined in <a href="#calibre_link-169" class="calibre3">Figure 4-8</a>, here’s an example of using <code class="calibre23">strncat_s()</code>:</p>
<pre class="calibre28"><code class="calibre23">  errno_t error{ strncat_s(str1, str2, 11) };</code></pre>
<p class="calibre13">After executing this statement, <code class="calibre23">str1</code> contains the string <code class="calibre23">"Many hands make light"</code>. The operation appends 11 characters from <code class="calibre23">str2</code> to <code class="calibre23">str1</code>, overwriting the terminating <code class="calibre23">'\0'</code> in <code class="calibre23">str1</code>, and then appends a final <code class="calibre23">'\0'</code> character. The <code class="calibre23">wcsncat_s()</code> provides the same capability as <code class="calibre23">strncat_s()</code> but for wide-character strings.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Copying Null-terminated Strings</h3>
<p class="calibre13">The standard library function <code class="calibre23">strcpy()</code> copies a string from a source location to a destination. The <code class="calibre23">strcpy_s()</code> function is a more secure version of <code class="calibre23">strcpy().</code> The first argument is a pointer to the destination, and the second is a pointer to the source string; the first argument is of type <code class="calibre23">char*</code> and the second is type <code class="calibre23">const char*. strcpy_s()</code>verifies that the source and destination are not <code class="calibre23">nullptr</code> and that the destination has sufficient space to accommodate the source string. If either argument is <code class="calibre23">nullptr</code> or the destination is too small, the program will crash and offer you the option to close the program or start debugging it, thus preventing an uncontrolled copy operation. <code class="calibre23">wcscpy_s()</code> provides analogous wide-character versions of this copy function.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Comparing Null-terminated Strings</h3>
<p class="calibre13">The <code class="calibre23">strcmp()</code> function compares two null-terminated strings that you specify by arguments of type <code class="calibre23">const char*</code>. The function returns a value of type <code class="calibre23">int</code> that is less than zero, zero, or greater <span {http://www.idpf.org/2007/ops}type="pagebreak" title="174" id="calibre_link-636" class="calibre14"></span>than zero, depending on whether the string pointed to by the first argument is less than, equal to, or greater than the string pointed to by the second argument. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">const char* str1 {"Jill"};
const char* str2 {"Jacko"};
int result {std::strcmp(str1, str2)};
if(result &lt; 0)
  std::cout &lt;&lt; str1 &lt;&lt; " is less than " &lt;&lt; str2 &lt;&lt; '.' &lt;&lt; std::endl;
else if(0 == result)
  std::cout &lt;&lt; str1 &lt;&lt; " is equal to " &lt;&lt; str2 &lt;&lt; '.' &lt;&lt; std::endl;
else
  std::cout &lt;&lt; str1 &lt;&lt; " is greater than " &lt;&lt; str2 &lt;&lt; '.' &lt;&lt; std::endl;</code></pre>
<p class="calibre13">This fragment compares the strings <code class="calibre23">str1</code> and <code class="calibre23">str2</code>, and uses the value returned by <code class="calibre23">strcmp()</code> to execute one of three possible output statements.</p>
<p class="calibre13">Comparing strings works by comparing the character codes of successive pairs of corresponding characters. The first pair of characters that are different determines whether the first string is less than or greater than the second string. Two strings are equal if they contain the same number of characters, and the corresponding characters are identical. Of course, the output is:</p>
<pre class="calibre28"><code class="calibre23">Jill is greater than Jacko.</code></pre>
<p class="calibre13">The <code class="calibre23">wcscmp()</code> function is the wide-character string equivalent of <code class="calibre23">strcmp()</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Searching Null-terminated Strings</h3>
<p class="calibre13">The <code class="calibre23">strspn()</code> function searches a string for the first character that is not in a given set and returns the index of the character found. The first argument is a pointer to the string to be searched, and the second is a pointer to a string containing the set of characters. You could search for the first character that is not a vowel like this:</p>
<pre class="calibre28"><code class="calibre23">char str[] {"I agree with everything."};
const char* vowels {"aeiouAEIOU "};
size_t index {std::strspn(str, vowels)};
std::cout &lt;&lt; "The first character that is not a vowel is '" &lt;&lt; str[index]
          &lt;&lt; "' at position " &lt;&lt; index &lt;&lt; std::endl;</code></pre>
<p class="calibre13">This searches <code class="calibre23">str</code> for the first character that is not contained in <code class="calibre23">vowels</code>. Note that I included a space in the <code class="calibre23">vowels</code> set, so a space will be ignored so far as the search is concerned. The output from this fragment is:</p>
<pre class="calibre28"><code class="calibre23">The first character that is not a vowel is 'g' at position 3</code></pre>
<p class="calibre13">Another way of looking at the return value from <code class="calibre23">strspn()</code>is that it represents the length of the substring, starting from the first character in the first argument string that consists entirely of characters in the second argument string. In the example it is the first three characters <code class="calibre23">"I a"</code>. The <code class="calibre23">wcsspn()</code> function is the wide-character string equivalent of <code class="calibre23">strspn()</code>.</p>
<p class="calibre13">The <code class="calibre23">strstr()</code> function returns a pointer to the position in the first argument of a substring specified by the second argument. Here’s a fragment that shows this in action:</p>
<pre class="calibre28"><code class="calibre23">char str[] {"I agree with everything."};
const char* substring {"ever"}; 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="175" id="calibre_link-637" class="calibre14"></span>char* psubstr {std::strstr(str, substring)};
        
if(!psubstr)
  std::cout &lt;&lt; "\"" &lt;&lt; substring &lt;&lt; "\" not found in \"" &lt;&lt; str &lt;&lt; "\"" &lt;&lt; 
std::endl;
else
  std::cout &lt;&lt; "The first occurrence of \"" &lt;&lt; substring
            &lt;&lt; "\" in \"" &lt;&lt; str &lt;&lt; "\" is at position "
            &lt;&lt; psubstr-str &lt;&lt; std::endl;</code></pre>
<p class="calibre13">The third statement calls <code class="calibre23">strstr()</code>to search <code class="calibre23">str</code> for the first occurrence of <code class="calibre23">substring</code>. The function returns a pointer to the position of the substring if it is found, or <code class="calibre23">nullptr</code> when it is not found. The <code class="calibre23">if</code> statement outputs a message, depending on whether or not <code class="calibre23">substring</code> was found in <code class="calibre23">str</code>. The expression <code class="calibre23">psubstr-str</code> gives the index position of the first character in the substring. The output produced by this fragment is:</p>
<pre class="calibre28"><code class="calibre23">The first occurrence of "ever" in "I agree with everything." is at position 13</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Searching Null-terminated Strings</h3>
<p class="calibre20">This example searches a given string to determine the number of occurrences of a given substring:</p>
<pre class="calibre28"><code class="calibre23">// Ex4_12.cpp
// Searching a string
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using std::cout;
using std::endl;
 
int main()
{
  char str[] { "Smith, where Jones had had \"had had\" had had \"had\"."
    "\n\"Had had\" had had the examiners' approval." };
  const char* word { "had" };
  cout &lt;&lt; "The string to be searched is: " &lt;&lt; endl &lt;&lt; str &lt;&lt; endl;
 
  int count {};                              // Number of occurrences of word in str
  char* pstr { str };                        // Pointer to search start position
  char* found {};                            // Pointer to occurrence of word in str
  const size_t wordLength { std::strlen(word) };
  while (true)
  {
    found = std::strstr(pstr, word);
    if (!found)
      break;
    ++count;
    pstr = found + wordLength;                
// Set next search start as 1 past the word found
  }
  cout &lt;&lt; "\"" &lt;&lt; word &lt;&lt; "\" was found "
       &lt;&lt; count &lt;&lt; " times in the string." &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="176" id="calibre_link-638" class="calibre14"></span>The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">The string to be searched is: Smith, where Jones had had "had had" had had "had".
"Had had" had had the examiners' approval.
"had" was found 10 times in the string.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">All the action takes place in the indefinite <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  while(true)
  {
    found = std::strstr(pstr, word);
    if (!found)
      break;
    ++count;
    pstr = found + wordLength;                
// Set next search start as 1 past the word found
  }</code></pre>
<p class="calibre20">You first search the string for <code class="calibre23">word</code> starting at position <code class="calibre23">pstr</code>, which initially is the beginning of the string. You store the address <code class="calibre23">strstr()</code> returns in <code class="calibre23">found</code>, which will be <code class="calibre23">nullptr</code> if <code class="calibre23">word</code> was not found so the <code class="calibre23">if</code> statement ends the loop in that case.</p>
<p class="calibre20">If <code class="calibre23">found</code> is not <code class="calibre23">nullptr</code>, you increment the number of occurrences of <code class="calibre23">word</code>, and update <code class="calibre23">pstr</code> so that it points to one character past the <code class="calibre23">word</code> instance that was found. This will be the starting point for the search on the next loop iteration. From the output, you can see that <code class="calibre23">word</code> was found ten times in <code class="calibre23">str</code>. Of course, <code class="calibre23">"Had"</code> doesn’t count because it starts with an uppercase letter.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-267" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">You are now familiar with all of the basic types of values in C++, how to create and use arrays of those types, and how to create and use pointers. You have also been introduced to the idea of a reference. However, we have not exhausted all of these topics. I’ll come back to arrays, pointers, and references later in the book.</p>
<p class="calibre13">The pointer mechanism is sometimes a bit confusing because it can operate at different levels within the same program. Sometimes it is operating as an address, and at other times it can be operating with the value stored at an address. It’s very important that you feel at ease with the way pointers are used, so if you find that they are in any way unclear, try them out with a few examples of your own until you feel confident about applying them.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Write a program that allows an unlimited number of values to be entered and stored in an array allocated in the free store. The program should then output the values, five to a line, followed by the average of the values entered. The initial array size should be five elements. The program should create a new array with five additional elements, when necessary, and copy values from the old array to the new.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="177" id="calibre_link-639" class="calibre14"></span>Repeat the previous exercise but use pointer notation throughout instead of arrays.</li>
<li class="calibre6">Declare a character array, and initialize it to a suitable string. Use a loop to change every other character to uppercase.
<ol class="none">
<li class="calibre6"><i class="calibre15">Hint:</i> In the ASCII character set, values for uppercase characters are 32 less than their lowercase counterparts.</li>
</ol></li>
<li class="calibre6">Define an array of elements of type <code class="calibre23">double</code> that contains twelve arbitrary values that represent monthly average temperatures in Fahrenheit. Use a range-based <code class="calibre23">for</code> loop to convert the values to Centigrade and find and output the maximum, minimum, and average Centigrade temperatures.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="178" id="calibre_link-640" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Arrays</b></td>
<td class="calibre32">An array allows you to manage a number of variables of the same type using a single name. Each dimension of an array is defined between square brackets, following the array name in the definition of the array.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Array dimensions</b></td>
<td class="calibre32">Each dimension of an array is indexed starting from zero. Thus, the fifth element of a one-dimensional array has the index value 4.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Initializing arrays</b></td>
<td class="calibre32">Arrays can be initialized by placing the initializing values between curly braces in the definition &mdash; in other words, in an initializer list.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Range <code class="calibre23">for</code> loop</b></td>
<td class="calibre32">You can use the range-based <code class="calibre23">for</code> loop to iterate over each of the elements in an array.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Pointers</b></td>
<td class="calibre32">A pointer is a variable that contains the address of another variable. A pointer is defined as a ‘pointer to type’ and may only be assigned addresses of variables of the given type.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Pointers to <code class="calibre23">const</code> and <code class="calibre23">const</code> pointers</b></td>
<td class="calibre32">A pointer can point to a constant object. Such a pointer can be reassigned to another object. A pointer may also be defined as <code class="calibre23">const</code>, in which case it can’t be reassigned.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">References</b></td>
<td class="calibre32">A reference is an alias for something else. An lvalue reference can be used in place of the variable it references. An rvalue reference can refer to a value stored in a temporary location. A reference must be initialized when it is defined. A reference can’t be reassigned to another variable.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">sizeof</code> operator</b></td>
<td class="calibre32">The <code class="calibre23">sizeof</code> operator returns the number of bytes occupied by the object specified as its argument. Its argument may be a variable, or a type name between parentheses.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">new</code> operator</b></td>
<td class="calibre32">The <code class="calibre23">new</code> operator allocates memory in the free store. When memory has been assigned, it returns a pointer to the beginning of the memory area. If memory cannot be allocated for any reason, an exception is thrown that by default causes the program to terminate.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">delete</code> operator</b></td>
<td class="calibre32">You use the <code class="calibre23">delete</code> operator to release memory that you previously allocated using the <code class="calibre23">new</code> operator.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-2">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2318" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="179" id="calibre_link-641" class="calibre9"></span><span class="chapternumber">Chapter 5</span><br class="calibre10" /><span class="chapternumber">Introducing Structure into Your Programs</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How to declare and write your own C++ functions</li>
<li class="calibre6">How function arguments are defined and used</li>
<li class="calibre6">How to pass arrays to and from a function</li>
<li class="calibre6">What pass-by-value means</li>
<li class="calibre6">How to pass pointers to functions</li>
<li class="calibre6">How to use references as function arguments, and what pass-by-reference means</li>
<li class="calibre6">How the <code class="calibre23">const</code> modifier affects function arguments</li>
<li class="calibre6">How to return values from a function</li>
<li class="calibre6">How to use recursion</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 5 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-268" class="calibre3"></a>UNDERSTANDING FUNCTIONS</h2>
<p class="calibre13">Up to now, you haven’t really been able to structure your program code in a modular fashion, because you only know how to construct a program as a single function, <code class="calibre23">main()</code>; but you <i class="calibre15">have</i> been using library functions of various kinds as well as functions belonging to objects. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="180" id="calibre_link-642" class="calibre14"></span>Whenever you write a C++ program, you should have a modular structure in mind from the outset, and as you’ll see, a good understanding of how to implement functions is essential to object-oriented programming.</p>
<p class="calibre13">There’s quite a lot to structuring your C++ programs, so to avoid indigestion, you won’t try to swallow the whole thing in one gulp. After you have chewed over and gotten the full flavor of these morsels, you move on to the next chapter, where you get further into the meat of the topic.</p>
<p class="calibre13">First, I’ll explain the broad principles of how a function works. A function is a self-contained block of code with a specific purpose. A function has a name that both identifies it and is used to call it for execution in a program. The name of a function is global if it is not defined within a namespace, otherwise the name is qualified by the namespace name. The name of a function is not necessarily unique, as you’ll see in the next chapter; however, functions that perform different actions should generally have different names.</p>
<p class="calibre13">The name of a function is governed by the same rules as those for a variable. A function name is, therefore, a sequence of letters and digits, the first of which is a letter, where an underscore (<code class="calibre23">_</code>) counts as a letter. The name of a function should generally reflect what it does, so, for example, you might call a function that counts beans <code class="calibre23">count_beans()</code>.</p>
<p class="calibre13">You pass information to a function by means of <i class="calibre15">arguments</i> specified when you invoke it. These arguments must correspond with <i class="calibre15">parameters</i> that appear in the definition of the function. The arguments that you specify replace the parameters used in the definition of the function when the function executes. The code in the function then executes as though it were written using your argument values. <a id="calibre_link-4" href="#calibre_link-3" class="calibre3">Figure 5-1</a> illustrates the relationship between arguments in the function call and the parameters you specify in the definition of the function.</p>
<figure class="calibre16">
<img class="center" src="images/000126.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-3" href="#calibre_link-4" class="calibre3">FIGURE 5-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="181" id="calibre_link-643" class="calibre14"></span>In <a href="#calibre_link-3" class="calibre3">Figure 5-1</a>, the <code class="calibre23">add_ints()</code> function returns the sum of the two arguments passed to it. In general, a function returns either a single value to the point in the program where it was called, or nothing at all, depending on how you define the function. You might think that returning a single value from a function is a constraint, but the single value returned can be a pointer that could contain the address of an array, for example. You will learn more about how data is returned from a function a little later in this chapter.</p>
<section class="toclist">
<h3 class="calibre21">Why Do You Need Functions?</h3>
<p class="calibre13">One major advantage that a function offers is that it can be executed as many times as necessary from different points in a program. Without the ability to package a block of code into a function, programs would end up being much larger, because you would typically need to replicate the same code at various points in them. You also use functions to break up a program into easily manageable chunks for development and testing; a program of significant size and complexity that consists of several small blocks of code is much easier to understand and test than if it were written as one large chunk.</p>
<p class="calibre13">Imagine a really big program &mdash; let’s say a million lines of code. A program of this size would be virtually impossible to write and debug without functions. Functions enable you to segment the program so that you can write the code piecemeal. You can test each piece independently before bringing it together with the other pieces. This approach also allows the development work to be divided among members of a programming team, with each team member taking responsibility for a tightly specified piece of the program that has a well-defined, functional interface to the rest of the code.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Structure of a Function</h3>
<p class="calibre13">As you have seen when writing the function <code class="calibre23">main()</code>, a function consists of a <i class="calibre15">function header</i> that identifies the function, followed by the <i class="calibre15">body</i> of the function between braces that makes up the executable code for the function. Let’s look at an example. You could write a function to raise a value to a given power; that is, to compute the result of multiplying the value <code class="calibre23">x</code> by itself <code class="calibre23">n</code> times, which is x<sup class="calibre33">n</sup>:</p>
<pre class="calibre28"><code class="calibre23">// Function to calculate x to the power n, with n greater than or
// equal to 0
double power(double x, int n)          // Function header
{                                      // Function body starts here...
  double result {1.0};                 // Result stored here
  for(int i {1}; i &lt;= n; i++)
    result *= x;
        
  return result;
}                                      // ...and ends here</code></pre>
<section class="toclist">
<h4 class="calibre22">The Function Header</h4>
<p class="calibre13">Let’s first examine the function header in this example. The following is the first line of the function:</p>
<pre class="calibre28"><code class="calibre23">double power(double x, int n)          // Function header</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="182" id="calibre_link-644" class="calibre14"></span>It consists of three parts:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The type of the <i class="calibre15">return value</i> (<code class="calibre23">double</code>, in this case)</li>
<li class="calibre6">The name of the function (<code class="calibre23">power</code>, in this case)</li>
<li class="calibre6">The parameters of the function enclosed between parentheses (<code class="calibre23">x</code> and <code class="calibre23">n</code>, in this case, of types <code class="calibre23">double</code> and <code class="calibre23">int</code>, respectively)</li>
</ul>
<p class="calibre13">The return value is returned to the calling function when the function is executed, so when the function is called, it results in a value of type <code class="calibre23">double</code> in the expression in which it appears.</p>
<p class="calibre13">Our function has two parameters: <code class="calibre23">x</code>, the value to be raised to a given power, which is of type <code class="calibre23">double</code>, and the value of the power, <code class="calibre23">n</code>, which is of type <code class="calibre23">int</code>. The computation that the function performs is written using these parameter variables together with another variable, <code class="calibre23">result</code>, declared in the body of the function. The parameter names and any variables defined in the body of the function are local to the function.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">No semicolon is required at the end of the function header or after the closing brace for the function body.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h5 class="calibre27">The General Form of a Function Header</h5>
<p class="calibre13">The general form of a function header can be written as follows:</p>
<pre class="calibre28"><code class="calibre23">return_type function_name(parameter_list)</code></pre>
<p class="calibre13">The <code class="calibre23"><i class="calibre15">return_type</i></code> can be any legal type. If the function does not return a value, the return type is specified by the keyword <code class="calibre23">void</code>. The keyword <code class="calibre23">void</code> is also used to indicate the absence of parameters, so a function that has no parameters and doesn’t return a value would have the following function header.</p>
<pre class="calibre28"><code class="calibre23">void my_function(void)</code></pre>
<p class="calibre13">An empty parameter list also indicates that a function takes no arguments, so you could omit the keyword <code class="calibre23">void</code> between the parentheses like:</p>
<pre class="calibre28"><code class="calibre23">void my_function()</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A function with a return type specified as void should not be used in an expression in the calling program. Because it doesn’t return a value, it can’t sensibly be part of an expression, so using it in this way causes the compiler to generate an error message.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="183" id="calibre_link-645" class="calibre14"></span>The Function Body</h4>
<p class="calibre13">The desired computation in a function is performed by the statements in the function body that follow the function header. The first of these in our <code class="calibre23">power()</code> example declares a variable <code class="calibre23">result</code> that is initialized with the value 1.0. The variable <code class="calibre23">result</code> is local to the function, as are all automatic variables that you declare within the function body. This means that the variable <code class="calibre23">result</code> ceases to exist after the function has completed execution. What might immediately strike you is that if <code class="calibre23">result</code> ceases to exist on completing execution of the function, how is it returned? The answer is that a copy of the value to be returned is made automatically, and this copy is made available to the return point in the program.</p>
<p class="calibre13">The calculation in <code class="calibre23">power()</code> is performed in the <code class="calibre23">for</code> loop. A loop control variable <code class="calibre23">i</code> is declared in the <code class="calibre23">for</code> loop, which assumes successive values from <code class="calibre23">1</code> to <code class="calibre23">n</code>. The variable <code class="calibre23">result</code> is multiplied by <code class="calibre23">x</code> once for each loop iteration, so this occurs <code class="calibre23">n</code> times to generate the required value. If <code class="calibre23">n</code> is <code class="calibre23">0</code>, the statement in the loop won’t be executed at all because the loop continuation condition immediately fails, and so <code class="calibre23">result</code> is left as 1.0.</p>
<p class="calibre13">As I’ve said, the parameters and all the variables declared within the body of a function are local to the function. There is nothing to prevent you from using the same names for variables in other functions for quite different purposes. Indeed, it’s just as well this is so because it would be extremely difficult to ensure variables’ names were always unique within a program containing a large number of functions, particularly if the functions were not all written by the same person.</p>
<p class="calibre13">The scope of variables declared within a function is determined in the same way that I have already discussed. A variable is created at the point at which it is defined and ceases to exist at the end of the block containing it. There is one type of variable that is an exception to this &mdash; variables declared as <code class="calibre23">static</code>. I’ll discuss static variables a little later in this chapter.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Take care not to mask global variables with local variables of the same name. You first met this situation back in Chapter 2, where you saw how you could use the scope resolution operator</i> <code class="calibre23">::</code> <i class="calibre15">to access global variables.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">The return Statement</h4>
<p class="calibre13">The <code class="calibre23">return</code> statement returns the value of <code class="calibre23">result</code> to the point where the function was called. The general form of the <code class="calibre23">return</code> statement is</p>
<pre class="calibre28"><code class="calibre23">return <i class="calibre15">expression;</i></code></pre>
<p class="calibre13">where <code class="calibre23"><i class="calibre15">expression</i></code> must evaluate to a value of the type specified in the function header for the return value. The expression can be any expression you want, as long as you end up with a value of the required type. It can include function calls &mdash; even a call of the same function in which it appears, as you’ll see later in this chapter.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="184" id="calibre_link-646" class="calibre14"></span>If the type of return value has been specified as <code class="calibre23">void</code>, there must be no expression appearing in the <code class="calibre23">return</code> statement. It must be written simply as:</p>
<pre class="calibre28"><code class="calibre23">return;</code></pre>
<p class="calibre13">You can also omit the <code class="calibre23">return</code> statement when it is the last statement in the function body and there is no return value.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Alternative Function Syntax</h3>
<p class="calibre13">There is an alternative syntax for writing the function header. Here’s an example of the <code class="calibre23">power()</code> function that you saw earlier defined using it:</p>
<pre class="calibre28"><code class="calibre23">auto power(double x, int n)-&gt; double   // Function header
{                                      // Function body starts here...
  double result {1.0};                 // Result stored here
  for(int i {1}; i &lt;= n; i++)
    result *= x;
        
  return result;
}                                      // ...and ends here</code></pre>
<p class="calibre13">This will work in exactly the same way as the previous version of the function. The return type of the function appears following the <code class="calibre23">-&gt;</code> in the header. This is referred to as a <code class="calibre23">trailing return type</code>. The <code class="calibre23">auto</code> keyword at the beginning indicates to the compiler that the return type is determined later.</p>
<p class="calibre13">So why was it necessary to introduce the alternative syntax? Isn’t the old syntax good enough? The answer is no. In the next chapter you’ll learn about <i class="calibre15">function templates</i>, where situations can arise when you need to allow for the return type from a function to vary depending on the result of executing the body of the function. You can’t specify that with the old syntax. The alternative function syntax does allow you to do that, as you’ll see in Chapter 6.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using a Function</h3>
<p class="calibre13">At the point at which you use a function in a program, the compiler must know something about it to compile the function call. It needs enough information to be able to identify the function, and to verify that you are using it correctly. If the definition of the function that you intend to use does not appear earlier in the same source file, you must declare the function using a statement called a <i class="calibre15">function prototype</i>.</p>
<section class="toclist">
<h4 class="calibre22">Function Prototypes</h4>
<p class="calibre13">The prototype of a function provides the basic information that the compiler needs to check that you are using the function correctly. It specifies the parameters to be passed to the function, the function name, and the type of the return value &mdash; basically, it contains the same information as appears in the function header, with the addition of a semicolon. Clearly, the number of parameters and their types must be the same in the function prototype as they are in the function header in the definition of the function.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="185" id="calibre_link-647" class="calibre14"></span>A prototype or a definition for each function that you call from within another function must appear before the statements doing the calling. Prototypes are usually placed at the beginning of the program source file. The header files that you’ve been including for standard library functions contain the prototypes of the functions provided by the library, amongst other things.</p>
<p class="calibre13">For the <code class="calibre23">power()</code> function example, you could write the prototype as:</p>
<pre class="calibre28"><code class="calibre23">double power(double value, int index);</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Don’t forget that a semicolon is required at the end of a function prototype. Without it, you get error messages from the compiler.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Note that I have specified names for the parameters in the function prototype that are different from those I used in the function header when I defined the function. This is just to indicate that it’s possible. Most often, the same names are used in the prototype and in the function header in the definition of the function, but this doesn’t <i class="calibre15">have</i> to be so. You can use longer, more expressive parameter names in the function prototype to aid understanding of the significance of the parameters, and then use shorter parameter names in the function definition where the longer names would make the code in the body of the function less readable.</p>
<p class="calibre13">If you like, you can even omit the names altogether in the prototype, and just write:</p>
<pre class="calibre28"><code class="calibre23">double power(double, int);</code></pre>
<p class="calibre13">This provides enough information for the compiler to do its job; however, it’s better practice to use some meaningful name in a prototype because it aids readability and, in some cases, makes all the difference between clear code and confusing code. If you have a function with two parameters of the same type (suppose our index was also of type <code class="calibre23">double</code> in the function <code class="calibre23">power()</code>, for example), the use of suitable names indicates clearly which parameter appears first and which second. Without parameter names it would be impossible to tell.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Function</h3>
<p class="calibre20">You can see how all this goes together in an example that exercises the <code class="calibre23">power()</code> function:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_01.cpp
// Declaring, defining, and using a function
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
double power(double x, int n);    // Function prototype
        
int main()
{
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="186" id="calibre_link-648" class="calibre14"></span>  int index {3};                  // Raise to this power
  double x {1};                   // Different x from that in function power
  double y {};
        
  y = power(5.0, 3);              // Passing constants as arguments
  cout &lt;&lt; endl &lt;&lt; "5.0 cubed = " &lt;&lt; y;
        
  cout &lt;&lt; endl &lt;&lt; "3.0 cubed = "
       &lt;&lt; power(3.0, index);      // Outputting return value
        
  x = power(x, power(2.0, 2.0));  // Using a function as an argument
  cout &lt;&lt; endl                    // with auto conversion of 2nd parameter
       &lt;&lt; "x = " &lt;&lt; x;
        
  cout &lt;&lt; endl;
  return 0;
}
        
// Function to compute positive integral powers of a double value
// First argument is value, second argument is power index
double power(double x, int n)
{                                 // Function body starts here...
  double result {1.0};            // Result stored here
  for(int i {1}; i &lt;= n; i++)
    result *= x;
  return result;
}                                 // ...and ends here</code></pre>
<p class="calibre20">This program shows some of the ways in which you can use the function <code class="calibre23">power()</code>, specifying the arguments to the function in a variety of ways. If you run this example, you get the following output:</p>
<pre class="calibre28"><code class="calibre23">5.0 cubed = 125
3.0 cubed = 27
x = 81</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">After the usual <code class="calibre23">#include</code> statement for input/output and the <code class="calibre23">using</code> declarations, you have the prototype for the function <code class="calibre23">power()</code>. If you were to delete this and try recompiling the program, the compiler wouldn’t be able to process the calls to the function in <code class="calibre23">main()</code> and would instead generate a whole series of error messages:</p>
<pre class="calibre28"><code class="calibre23"> error C3861: <i class="calibre15">'</i>power<i class="calibre15">'</i>: identifier not found</code></pre>
<p class="calibre20">In a change from previous examples, I’ve used the keyword <code class="calibre23">void</code> in the function <code class="calibre23">main()</code> where the parameter list would usually appear to indicate that no parameters are to be supplied. Previously, I left the parentheses enclosing the parameter list empty, which is also interpreted in C++ as indicating that there are no parameters. Using <code class="calibre23">void</code> in this way is a remnant from the practice in C but you won’t see it very often in C++. As you saw, the keyword <code class="calibre23">void</code> is used as the return type for a function to indicate that no value is returned. If you specify the return type of a function as <code class="calibre23">void</code>, you must not place a value in any <code class="calibre23">return</code> statement within the function; otherwise, you get an error message from the compiler.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="187" id="calibre_link-649" class="calibre14"></span>You gathered from some of the previous examples that using a function is very simple. To use the function <code class="calibre23">power()</code> to calculate 5.0<sup class="calibre33">3</sup> and store the result in a variable <code class="calibre23">y</code> in our example, you have the following statement:</p>
<pre class="calibre28"><code class="calibre23">   y = power(5.0, 3);</code></pre>
<p class="calibre20">The values 5.0 and 3 here are the arguments to the function. They happen to be constants, but you can use any expression as an argument, as long as a value of the correct type is ultimately produced. The arguments to the <code class="calibre23">power()</code> function substitute for the parameters <code class="calibre23">x</code> and <code class="calibre23">n</code>, which were used in the definition of the function. The computation is performed using these values, and then, a copy of the result, 125, is returned to the calling function, <code class="calibre23">main()</code>, which is then stored in <code class="calibre23">y</code>. You can think of the function as having this value in the statement or expression in which it appears. You then output the value of <code class="calibre23">y</code>:</p>
<pre class="calibre28"><code class="calibre23">   cout &lt;&lt; endl &lt;&lt; "5.0 cubed = " &lt;&lt; y;</code></pre>
<p class="calibre20">The next call of the function is used within the output statement:</p>
<pre class="calibre28"><code class="calibre23">   cout &lt;&lt; endl &lt;&lt; "3.0 cubed = "
        &lt;&lt; power(3.0, index);        // Outputting return value</code></pre>
<p class="calibre20">Here, the value returned by the function is transferred directly to the output stream. Because you haven’t stored the returned value anywhere, it is otherwise unavailable to you. The first argument in the call of the function here is a constant; the second argument is a variable.</p>
<p class="calibre20">The function <code class="calibre23">power()</code> is used next in this statement:</p>
<pre class="calibre28"><code class="calibre23">   x = power(x, power(2.0, 2.0));    // Using a function as an argument</code></pre>
<p class="calibre20">Here, the <code class="calibre23">power()</code> function is called twice. The first call to the function is the rightmost in the expression, and the result supplies the value for the second argument to the leftmost call. Although the arguments in the sub-expression <code class="calibre23">power(2.0, 2.0)</code> are both specified as the <code class="calibre23">double</code> literal 2.0, the function is actually called with the first argument as 2.0 and the second argument as the integer literal, 2. The compiler converts the <code class="calibre23">double</code> value specified for the second argument to type <code class="calibre23">int</code>, because it knows from the function prototype (shown again here) that the type of the second parameter has been specified as <code class="calibre23">int</code>.</p>
<pre class="calibre28"><code class="calibre23">double power(double x, int n);       // Function prototype</code></pre>
<p class="calibre20">The <code class="calibre23">double</code> result 4.0 is returned by the first call to the <code class="calibre23">power()</code> function, and after conversion to type <code class="calibre23">int</code>, the value 4 is passed as the second argument in the next call of the function, with <code class="calibre23">x</code> as the first argument. Because <code class="calibre23">x</code> has the value 3.0, the value of 3.0<sup class="calibre33">4</sup> is computed and the result, 81.0, stored in <code class="calibre23">x</code>. This sequence of events is illustrated in <a id="calibre_link-6" href="#calibre_link-5" class="calibre3">Figure 5-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000077.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-5" href="#calibre_link-6" class="calibre3">FIGURE 5-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">This statement involves two implicit conversions from type <code class="calibre23">double</code> to type <code class="calibre23">int</code> that were inserted by the compiler. There’s a possible loss of data when converting from type <code class="calibre23">double</code> to type <code class="calibre23">int</code>, so the compiler issues warning messages when this occurs, even though the compiler itself has inserted the conversations. Generally, relying on automatic conversions where there is potential for data loss is a dangerous programming practice, and it is not at all obvious from the code that this conversion <span {http://www.idpf.org/2007/ops}type="pagebreak" title="188" id="calibre_link-650" class="calibre14"></span>is intended. It is far better to be explicit in your code by using the <code class="calibre23">static_cast</code> operator when necessary. The statement in the example is much better written as:</p>
<pre class="calibre28"><code class="calibre23">x = power(x, static_cast&lt;int&gt;(power(2.0, 2)));</code></pre>
<p class="calibre20">Coding the statement like this avoids both the compiler warning messages that the original version caused. Using a static cast does not remove the possibility of losing data in the conversion of data from one type to another. Because you specified it, though, it is clear that this is what you intended, recognizing that data loss might occur.</p>
<p class="calibre20">You could write the loop in the <code class="calibre23">power()</code> function like this:</p>
<pre class="calibre28"><code class="calibre23">   for(auto i = 1; i &lt;= n; i++)
      result *= x;</code></pre>
<p class="calibre20">The compiler will deduce the appropriate type for <code class="calibre23">i</code> from the initial value. I prefer to explicitly specify the type as <code class="calibre23">int</code> in this instance because I think it makes the code more readily understood.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-269" class="calibre3"></a>PASSING ARGUMENTS TO A FUNCTION</h2>
<p class="calibre13">It’s very important to understand how arguments are passed to a function, because it affects how you write functions and how they ultimately operate. There are also a number of pitfalls to be avoided, so we’ll look at the mechanism for this quite closely.</p>
<p class="calibre13">The arguments you specify when a function is called should usually correspond in type and sequence to the parameters that appear in the definition of the function. As you saw in the last example, if the type of an argument you specify in a function call doesn’t correspond with the type of the parameter in the function definition, the compiler arranges for the argument to be converted to the required type, obeying the same rules as those for converting operands that I discussed in Chapter 2. If the conversion is not possible, you get an error message from the compiler. However, even if the conversion is possible and the code compiles, it could result in the loss of data (for example, a conversion from type <code class="calibre23">long</code> to type <code class="calibre23">short</code>) and should therefore be avoided.</p>
<p class="calibre13">There are two mechanisms used to pass arguments to functions. The first mechanism applies when you specify the parameters in the function definition as ordinary variables (<i class="calibre15">not</i> references). This is called the <i class="calibre15">pass-by-value</i> method of transferring data to a function, so let’s look into that first.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="189" id="calibre_link-651" class="calibre24"></span>The Pass-by-Value Mechanism</h3>
<p class="calibre13">With this mechanism, the variables, constants, or expression values that you specify as arguments are not passed to a function at all. Instead, copies of the argument values are created, and these copies are used as the values to be transferred to the function. <a id="calibre_link-8" href="#calibre_link-7" class="calibre3">Figure 5-3</a> shows this using the example of our <code class="calibre23">power()</code> function.</p>
<figure class="calibre16">
<img class="center" src="images/000123.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-7" href="#calibre_link-8" class="calibre3">FIGURE 5-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">In <a href="#calibre_link-7" class="calibre3">Figure 5-3</a>, the value returned by <code class="calibre23">power()</code> is used to initialize <code class="calibre23">result</code>. Each time you call the <code class="calibre23">power()</code> function, the compiler arranges for copies of the arguments to be stored in temporary location plural in memory. During execution of the function, all references to the function parameters are mapped to these temporary copies of the arguments.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="190" id="calibre_link-652" class="calibre24"></span>TRY IT OUT: Passing-by-Value</h3>
<p class="calibre20">One consequence of the pass-by-value mechanism is that a function can’t directly modify the arguments passed to it. You can demonstrate this by deliberately trying to do so in an example:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_02.cpp
// A futile attempt to modify caller arguments
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
int incr10(int num);           // Function prototype
        
int main()
{
  int num {3};
        
  cout &lt;&lt; endl &lt;&lt; "incr10(num) = " &lt;&lt; incr10(num) &lt;&lt; endl
       &lt;&lt; "num = " &lt;&lt; num &lt;&lt; endl;
  return 0;
}
        
// Function to increment a variable by 10
int incr10(int num)            // Using the same name might help...
{
  num += 10;                  // Increment the caller argument &ndash; hopefully
  return num;                 // Return the incremented value
}</code></pre>
<p class="calibre20">Of course, this program is doomed to failure. If you run it, you get this output:</p>
<pre class="calibre28"><code class="calibre23">incr10(num) = 13
num = 3</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The output confirms that the original value of <code class="calibre23">num</code> remains untouched. The copy of <code class="calibre23">num</code> that was generated and passed as the argument to the <code class="calibre23">incr10()</code> function was incremented and was eventually discarded on exiting from the function.</p>
<p class="calibre20">Clearly, the pass-by-value mechanism provides you with a high degree of protection from having your caller arguments mauled by a rogue function, but it is conceivable that you might actually want to modify caller arguments. Of course, there is a way to do this. Didn’t you just know that pointers would turn out to be incredibly useful?</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Pointers as Arguments to a Function</h3>
<p class="calibre13">When you use a pointer as an argument, the pass-by-value mechanism still operates as before; however, a pointer is an address of another variable, and if you take a copy of this address, the copy still points to the same variable. This is how specifying a pointer as a parameter enables your function to get at a caller argument.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="191" id="calibre_link-653" class="calibre24"></span>TRY IT OUT: Pass-by-Pointer</h3>
<p class="calibre20">You can change the last example to use a pointer to demonstrate the effect:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex5_03.cpp</b>
<b class="calibre12">// A successful attempt to modify caller arguments</b>
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
<b class="calibre12">int incr10(int* num);                // Function prototype</b>
        
int main()
{
  int num {3};
 
  <b class="calibre12">int* pnum {&amp;num};                  // Pointer to num</b>

  <b class="calibre12">cout &lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">Address passed =</b> " <b class="calibre12">&lt;&lt; pnum;</b>

  <b class="calibre12">int result {incr10(pnum)};</b>
  <b class="calibre12">cout &lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">incr10(pnum) =</b> " <b class="calibre12">&lt;&lt; result;</b>

  cout &lt;&lt; endl &lt;&lt; "num = " &lt;&lt; num &lt;&lt; endl;
  return 0;
}
 
// Function to increment a variable by 10
<b class="calibre12">int incr10(int* num)                 // Function with pointer argument</b>
<b class="calibre12">{</b>
  <b class="calibre12">cout &lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">Address received =</b> " <b class="calibre12">&lt;&lt; num;</b>

  <b class="calibre12">*num += 10;                        // Increment the caller argument</b>
                                     <b class="calibre12">//  - confidently</b>
  <b class="calibre12">return *num;                       // Return the incremented value</b>
<b class="calibre12">}</b></code></pre>
<p class="calibre20">The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">Address passed = 0012FF6C
Address received = 0012FF6C
incr10(pnum) = 13
num = 13</code></pre>
<p class="calibre20">The address values produced by your computer may be different from those shown here, but the two values should be identical.</p>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">In this example, the principal alterations from the previous version relate to passing a pointer, <code class="calibre23">pnum</code>, in place of the original variable, <code class="calibre23">num</code>. The prototype for the function now has the parameter type specified as a pointer to <code class="calibre23">int</code>, and the <code class="calibre23">main()</code> function has the pointer <code class="calibre23">pnum</code> declared and initialized with the address of <code class="calibre23">num</code>. The function <code class="calibre23">main()</code>, and the function <code class="calibre23">incr10()</code>, output the address sent and <span {http://www.idpf.org/2007/ops}type="pagebreak" title="192" id="calibre_link-654" class="calibre14"></span>the address received, respectively, to verify that the same address is indeed being used in both places. Because the <code class="calibre23">incr10()</code> function is writing to <code class="calibre23">cout</code>, you now call it before the output statement and store the return value in <code class="calibre23">result</code>:</p>
<pre class="calibre28"><code class="calibre23">   int result {incr10(pnum)};
   cout &lt;&lt; endl &lt;&lt; "incr10(pnum) = " &lt;&lt; result;</code></pre>
<p class="calibre20">This ensures proper sequencing of the output. The output shows that this time, the variable <code class="calibre23">num</code> has been incremented and has a value that’s now identical to that returned by the function.</p>
<p class="calibre20">In the rewritten version of <code class="calibre23">incr10()</code>, both the statement incrementing the value passed to the function and the <code class="calibre23">return</code> statement now de-reference the pointer to use the value stored.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Passing Arrays to a Function</h3>
<p class="calibre13">You can pass an array to a function, but in this case, the array is not copied, even though a pass-by-value method of passing arguments still applies. The array name is converted to a pointer, and a copy of the pointer to the beginning of the array is passed by value to the function. This is quite advantageous because copying large arrays is very time-consuming. As you may have worked out, elements of the array may be changed within a function, and thus, an array is the only type that cannot be passed by value.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Passing Arrays</h3>
<p class="calibre20">You can illustrate the ins and outs of this by writing a function to compute the average of a number of values passed to a function in an array:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_04.cpp
// Passing an array to a function
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
double average(double array[], int count);      //Function prototype
        
int main()
{
  double values[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 };
        
  cout &lt;&lt; endl &lt;&lt; "Average = "
       &lt;&lt; average(values, _countof(values)) &lt;&lt; endl;
  return 0;
}
        
// Function to compute an average
double average(double array[], int count)
{
  double sum {};                    // Accumulate total in here
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="193" id="calibre_link-655" class="calibre14"></span>  for(int i {}; i &lt; count; i++)
     sum += array[i];                 // Sum array elements
        
  return sum/count;                   // Return average
}</code></pre>
<p class="calibre20">The program produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Average = 5.5</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The <code class="calibre23">average()</code> function is designed to work with an array of any length. As you can see from the prototype, it accepts two arguments: the array and a count of the number of elements. The function is called in <code class="calibre23">main()</code> in this statement:</p>
<pre class="calibre28"><code class="calibre23">   cout &lt;&lt; endl &lt;&lt; "Average = "
        &lt;&lt; average(values, _countof(values)) &lt;&lt; endl;</code></pre>
<p class="calibre20">The function is called with the first argument as the array name, <code class="calibre23">values</code>, and the second argument as an expression that evaluates to the number of elements in the array.</p>
<p class="calibre20">The number of elements  is produced by the _countof() macro. Note that you cannot apply this macro to an array parameter in a function because only the address of the array is known.</p>
<p class="calibre20">Within the body of the function, the computation is expressed in the way you would expect. There’s no significant difference between this and the way you would write the computation if you implemented it directly in <code class="calibre23">main()</code>.</p>
<p class="calibre20">The output confirms that everything works as we anticipated.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Pointer Notation When Passing Arrays</h3>
<p class="calibre20">You haven’t exhausted all the possibilities here. As you determined at the outset, the array name is passed as a pointer &mdash; to be precise, as a copy of a pointer &mdash; so within the function, you are not obliged to work with the data as an array at all. You could modify the function in the example to work with pointer notation throughout, in spite of the fact that you are using an array.</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex5_05.cpp</b>
<b class="calibre12">// Handling an array in a function as a pointer</b>
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
<b class="calibre12">double average(double* array, int count);      //Function prototype</b>
        
int main()
{
  double values[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 };
        
  cout &lt;&lt; endl &lt;&lt; "Average = "
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="194" id="calibre_link-656" class="calibre14"></span>        &lt;&lt; average(values, _countof(values)) &lt;&lt; endl;
  return 0;
}
        
<b class="calibre12">// Function to compute an average</b>
<b class="calibre12">double average(double* array, int count)</b>
{
  double sum {};                       // Accumulate total in here
  for(int i {}; i &lt; count; i++)
     <b class="calibre12">sum += *array++;                  // Sum array elements</b>
        
  return sum/count;                    // Return average
}</code></pre>
<p class="calibre20">The output is exactly the same as in the previous example.</p>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">As you can see, the program needed very few changes to make it work with the array as a pointer. The prototype and the function header have been changed, although neither change is absolutely necessary. If you change both back to the original version, with the first parameter specified as a <code class="calibre23">double</code> array, and leave the function body written in terms of a pointer, it works just as well. The most interesting aspect of this version is the body of the <code class="calibre23">for</code> loop statement:</p>
<pre class="calibre28"><code class="calibre23">      sum += *array++;                 // Sum array elements</code></pre>
<p class="calibre20">Here, you apparently break the rule about not being able to modify an address specified as an array name because you are incrementing the address stored in <code class="calibre23">array</code>. In fact, you aren’t breaking the rule at all. Remember that the pass-by-value mechanism makes a copy of the original array address and passes that to the function, so you are just modifying the copy here &mdash; the original array address is quite unaffected. As a result, whenever you pass a one-dimensional array to a function, you are free to treat the value passed as a pointer in every sense, and change the address in any way that you want.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">An array records no information about its size, so you cannot use the range-based</i> <code class="calibre23">for</code> <i class="calibre15">loop with an array passed as an argument to a function.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">Passing Multidimensional Arrays to a Function</h4>
<p class="calibre13">Passing a multidimensional array to a function is quite straightforward. The following statement declares a two-dimensional array, <code class="calibre23">beans</code>:</p>
<pre class="calibre28"><code class="calibre23">double beans[2][4];</code></pre>
<p class="calibre13">You could then write the prototype of a hypothetical function, <code class="calibre23">yield()</code>, like this:</p>
<pre class="calibre28"><code class="calibre23">double yield(double beans[2][4]);</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="195" id="calibre_link-657" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You may be wondering how the compiler knows that this is defining an array of the dimensions shown as a parameter, and not a single array element. The answer is simple &mdash; you can’t write a single array element as a parameter in a function definition or prototype, although you can pass one as an argument when you call a function. For a parameter accepting a single element of an array as an argument, the parameter would have just a variable name and its type. The array context doesn’t apply.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">When you are defining a multidimensional array as a parameter, you can also omit the first dimension value. Of course, the function needs some way of knowing the extent of the first dimension. For example, you could write this:</p>
<pre class="calibre28"><code class="calibre23">double yield(double beans[][4], int index);</code></pre>
<p class="calibre13">Here, the second parameter provides the necessary information about the first dimension. The function can operate with a two-dimensional array, with the value for the first dimension specified by the second argument and with the second dimension fixed at 4.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Passing Multidimensional Arrays</h3>
<p class="calibre20">You define such a function in the following example:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_06.cpp
// Passing a two-dimensional array to a function
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
double yield(double array[][4], int n);
        
int main()
{
  double beans[3][4]   {    { 1.0,  2.0,  3.0,  4.0 },
                            { 5.0,  6.0,  7.0,  8.0 },
                            { 9.0, 10.0, 11.0, 12.0 }   };
        
  cout &lt;&lt; endl &lt;&lt; "Yield = " &lt;&lt; yield(beans, _countof(beans))
       &lt;&lt; endl;
  return 0;
}
        
// Function to compute total yield
double yield(double beans[][4], int count)
{
  double sum {};
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="196" id="calibre_link-658" class="calibre14"></span>  for(int i {}; i &lt; count; i++)      // Loop through number of rows
     for(int j {}; j &lt; 4; j++)       // Loop through elements in a row
        sum += beans[i][j];
  return sum;
}</code></pre>
<p class="calibre20">The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">Yield = 78</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">I have used different names for the parameters in the function header from those in the prototype, just to remind you that this is possible &mdash; but in this case, it doesn’t really improve the program at all. The first parameter is defined as an array of an arbitrary number of rows, each row having four elements. You call the function using the array <code class="calibre23">beans</code> with three rows. The second argument is specified by dividing the total size of the array in bytes by the size of the first row. This evaluates to the number of rows in the array.</p>
<p class="calibre20">The computation in the function is a nested <code class="calibre23">for</code> loop with the inner loop summing elements of a single row and the outer loop repeating this for each row.</p>
<p class="calibre20">Using a pointer in a function rather than a multidimensional array as an argument doesn’t really apply particularly well in this example. When the array is passed, it passes an address value that points to an array of four elements (a row). This doesn’t lend itself to an easy pointer operation within the function. You would need to modify the statement in the nested <code class="calibre23">for</code> loop to the following:</p>
<pre class="calibre28"><code class="calibre23">sum += *(*(beans + i) + j);</code></pre>
<p class="calibre20">So the computation is probably clearer in array notation.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">References as Arguments to a Function</h3>
<p class="calibre13">We now come to the second of the two mechanisms for passing arguments to a function. Specifying a parameter to a function as a reference changes the method of passing data for that parameter. The method used is not pass-by-value, where an argument is copied before being transferred to the function, but <i class="calibre15">pass-by-reference</i>, where the parameter acts as an alias for the argument passed. This eliminates any copying of the argument supplied and allows the function to access the caller argument directly. It also means that the de-referencing, which is required when passing and using a pointer to a value, is also unnecessary.</p>
<p class="calibre13">Using reference parameters to a function has particular significance when you are working with objects of a class type. Objects can be large and complex, in which case, the copying process can be very time-consuming. Using reference parameters in these situations can make your code execute considerably faster.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="197" id="calibre_link-659" class="calibre24"></span>TRY IT OUT: Pass-by-Reference</h3>
<p class="calibre20">Let’s go back to a revised version of a very simple example, <code class="calibre23">Ex5_03.cpp</code>, to see how it would work using reference parameters:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex5_07.cpp</b>
<b class="calibre12">// Using an lvalue reference to modify caller arguments</b>
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
<b class="calibre12">int incr10(int&amp; num);               // Function prototype</b>

int main()
{
  int num {3};
  <b class="calibre12">int value {6};</b>

  <b class="calibre12">int result {incr10(num)};</b>
  cout &lt;&lt; endl  &lt;&lt; "incr10(num) = " &lt;&lt; result
       &lt;&lt; endl &lt;&lt; "num = " &lt;&lt; num;
 
  <b class="calibre12">result = incr10(value);</b>
  <b class="calibre12">cout &lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">incr10(value) =</b> " <b class="calibre12">&lt;&lt; result</b>
       <b class="calibre12">&lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">value =</b> " <b class="calibre12">&lt;&lt; value &lt;&lt; endl;</b>
  return 0;
}
 
// Function to increment a variable by 10
<b class="calibre12">int incr10(int&amp; num)                // Function with reference argument</b>
<b class="calibre12">{</b>
  <b class="calibre12">cout &lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">Value received =</b> " <b class="calibre12">&lt;&lt; num;</b>
  <b class="calibre12">num += 10;                        // Increment the caller argument</b>
                                    <b class="calibre12">//  - confidently</b>
  <b class="calibre12">return num;                       // Return the incremented value</b>
<b class="calibre12">}</b></code></pre>
<p class="calibre20">This program produces the output:</p>
<pre class="calibre28"><code class="calibre23">Value received = 3
incr10(num) = 13
num = 13
Value received = 6
incr10(value) = 16
value = 16</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You should find the way this works quite remarkable. This is essentially the same as <code class="calibre23">Ex5_03.cpp</code>, except that the function uses an lvalue reference as a parameter. The prototype has been changed to reflect this. When the function is called, the argument is specified just as though it were a pass-by-value operation, so it’s used in the same way as the earlier version. The argument value isn’t passed to <span {http://www.idpf.org/2007/ops}type="pagebreak" title="198" id="calibre_link-660" class="calibre14"></span>the function. The function parameter is <i class="calibre15">initialized</i> with the address of the argument, so whenever the parameter <code class="calibre23">num</code> is used in the function, it accesses the caller argument directly.</p>
<p class="calibre20">Just to reassure you that there’s nothing fishy about the use of the identifier <code class="calibre23">num</code> in <code class="calibre23">main()</code> as well as in the function, the function is called a second time with the variable <code class="calibre23">value</code> as the argument. At first sight, this may give you the impression that it contradicts what I said was a basic property of a reference &mdash; that after being declared and initialized, it couldn’t be reassigned to another variable. The reason it isn’t contradictory is that a reference as a function parameter is created and initialized each time the function is called, and is destroyed when the function ends, so you get a completely new reference created each time you use the function.</p>
<p class="calibre20">Within the function, the value received from the calling program is displayed onscreen. Although the statement is essentially the same as the one used to output the address stored in a pointer, because <code class="calibre23">num</code> is now a reference you obtain the data value rather than the address.</p>
<p class="calibre20">This clearly demonstrates the difference between a reference and a pointer. A reference is an alias for another variable, and therefore can be used as an alternative way of referring to it. It is equivalent to using the original variable name. The output shows that the <code class="calibre23">incr10()</code> function is directly modifying the variable passed as a caller argument.</p>
<p class="calibre20">You will find that if you try to use a numeric value, such as 20, as an argument to <code class="calibre23">incr10()</code>, the compiler outputs an error message. This is because the compiler recognizes that a reference parameter can be modified within a function, and the last thing you want is to have your constants changing value now and again. This would introduce a kind of excitement into your programs that you could probably do without. You also cannot use an expression for an argument corresponding to an lvalue reference parameter unless the expression is an lvalue. Essentially, the argument for an lvalue reference parameter must result in a persistent memory location in which something can be stored.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">I’m sure that you remember that there is another type of reference called an rvalue reference that I mentioned in Chapter 4. A parameter of an rvalue reference type allows an expression that is an rvalue to be passed to a function. You’ll learn more about this later in this chapter.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The security you get by using an lvalue reference parameter is all very well, but if the function didn’t modify the value, you wouldn’t want the compiler to create all these error messages every time you passed a reference argument that was a constant. Surely, there ought to be some way to accommodate this? As Ollie would have said, “There most certainly is, Stanley!”</p>
</section>
<section class="toclist">
<h3 class="calibre21">Use of the const Modifier</h3>
<p class="calibre13">You can apply the <code class="calibre23">const</code> modifier to a function parameter to tell the compiler that you don’t intend to modify it in any way. This causes the compiler to check that your code indeed does not modify the argument, and there are no error messages when you use a constant argument.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="199" id="calibre_link-661" class="calibre24"></span>TRY IT OUT: Passing a const</h3>
<p class="calibre20">You can modify the previous program to show how the <code class="calibre23">const</code> modifier changes the situation:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex5_08.cpp</b>
<b class="calibre12">// Using a reference to modify caller arguments</b>

#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
<b class="calibre12">int incr10(const int&amp; num);              // Function prototype</b>

int main()
{
  <b class="calibre12">const int num {3};       // Declared const to test for temporary creation</b>
  int value {6};
 
  int result {incr10(num)}
  cout &lt;&lt; endl &lt;&lt; "incr10(num) = " &lt;&lt; result
       &lt;&lt; endl &lt;&lt; "num = " &lt;&lt; num;
 
  result = incr10(value);
  cout &lt;&lt; endl &lt;&lt; "incr10(value) = " &lt;&lt; result;
  cout &lt;&lt; endl &lt;&lt; "value = " &lt;&lt; value;
 
  cout &lt;&lt; endl;
  return 0;
}
 
// Function to increment a variable by 10
<b class="calibre12">int incr10(const int&amp; num)       // Function with const reference argument</b>
<b class="calibre12">{</b>
  <b class="calibre12">cout &lt;&lt; endl &lt;&lt;</b> "<b class="calibre12">Value received =</b> " <b class="calibre12">&lt;&lt; num;</b>
<b class="calibre12">//   num += 10;                  // this statement would now be illegal</b>
  <b class="calibre12">return num+10;                 // Return the incremented value</b>
}</code></pre>
<p class="calibre20">The output when you execute this is:</p>
<pre class="calibre28"><code class="calibre23">Value received = 3
incr10(num) = 13
num = 3
Value received = 6
incr10(value) = 16
value = 6</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You declare the variable <code class="calibre23">num</code> in <code class="calibre23">main()</code> as <code class="calibre23">const</code> to show that when the parameter to the function <code class="calibre23">incr10()</code> is declared as <code class="calibre23">const</code>, you no longer get a compiler message when passing a <code class="calibre23">const</code> object.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="200" id="calibre_link-662" class="calibre14"></span>It has also been necessary to comment out the statement that increments <code class="calibre23">num</code> in the function <code class="calibre23">incr10()</code>. If you uncomment this line, you’ll find the program no longer compiles, because the compiler won’t allow <code class="calibre23">num</code> to appear on the left of an assignment. When you specified <code class="calibre23">num</code> as <code class="calibre23">const</code> in the function header and prototype, you promised not to modify it, so the compiler checks that you kept your word. Everything works as before, except that the variables in <code class="calibre23">main()</code> are no longer changed by the function.</p>
<p class="calibre20">By using lvalue reference parameters, you now have the best of both worlds. On one hand, you can write a function that can access caller arguments directly and avoid the copying that is implicit in the pass-by-value mechanism. On the other hand, where you don’t intend to modify an argument, you can get all the protection against accidental modification you need by using a <code class="calibre23">const</code> modifier with an lvalue reference type.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Rvalue Reference Parameters</h3>
<p class="calibre13">I’ll now illustrate briefly how parameters that are rvalue reference types differ from parameters that are lvalue reference types. Keep in mind that this won’t be how rvalue references are intended to be used. You’ll learn about that later in the book. Let’s look at an example that is similar to <code class="calibre23">Ex5_07.cpp</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using rvalue Reference Parameters</h3>
<p class="calibre20">Here’s the code for this example:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_09.cpp
// Using an rvalue reference parameter
 
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
int incr10(int&amp;&amp; num);              // Function prototype
 
int main()
{
  int num {3};      
  int value {6};
  int result {};
/* 
  result = incr10(num);                              // Increment num
  cout &lt;&lt; endl &lt;&lt; "incr10(num) = " &lt;&lt; result
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="201" id="calibre_link-663" class="calibre14"></span>       &lt;&lt; endl &lt;&lt; "num = " &lt;&lt; num;
 
  result = incr10(value);                            // Increment value
  cout &lt;&lt; endl &lt;&lt; "incr10(value) = " &lt;&lt; result
       &lt;&lt; endl &lt;&lt; "value = " &lt;&lt; value;
*/ 
  result = incr10(value+num);                        // Increment an expression
  cout &lt;&lt; endl &lt;&lt; "incr10(value+num) = " &lt;&lt; result
       &lt;&lt; endl &lt;&lt; "value = " &lt;&lt; value;
 
  result = incr10(5);                                // Increment a literal
  cout &lt;&lt; endl &lt;&lt; "incr10(5) = " &lt;&lt; result
       &lt;&lt; endl &lt;&lt; "5 = " &lt;&lt; 5;
 
  cout &lt;&lt; endl;
  return 0;
}
 
// Function to increment a variable by 10
int incr10(int&amp;&amp; num)       // Function with rvalue reference argument
{
  cout &lt;&lt; endl &lt;&lt; "Value received = " &lt;&lt; num;
  num += 10;                  
  return num;               // Return the incremented value
}</code></pre>
<p class="calibre20">Compiling and executing this produces the output:</p>
<pre class="calibre28"><code class="calibre23">Value received = 9
incr10(value+num) = 19
value = 6
Value received = 5
incr10(5) = 15
5 = 5</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The <code class="calibre23">incr10()</code> function now has an rvalue reference parameter type. In <code class="calibre23">main()</code>, you call the function with the expression <code class="calibre23">value+num</code> as the argument. The output shows that the function returns the value of the expression incremented by 10. Of course, you saw earlier that if you try to pass an expression as the argument for an lvalue reference parameter, the compiler will not allow it.</p>
<p class="calibre20">Next, you pass the literal, 5, as the argument, and again, the value returned shows the incrementing works. The output also shows that the literal 5 has not been changed, but why not? The argument in this case is an expression consisting of just the literal 5. The expression has the value 5 when it is evaluated, and this is stored in a temporary location that is referenced by the function parameter.</p>
<p class="calibre20">If you uncomment the statements at the beginning of <code class="calibre23">main()</code>, the code will not compile. A function that has an rvalue reference parameter can only be called with an argument that is an rvalue. Because <code class="calibre23">num</code> and <code class="calibre23">value</code> are lvalues, the compiler flags the statements that pass these as arguments to <code class="calibre23">incr10()</code> as errors.</p>
<p class="calibre20">While this example shows that you can pass an expression as the argument corresponding to an rvalue reference, and that within the function, the temporary location holding the value of the expression can be accessed and changed, this serves no purpose in this context. You will see when we get to look into defining classes that in some circumstances, rvalue reference parameters offer significant advantages.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="202" id="calibre_link-664" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">An important point to keep in mind is that even though an rvalue reference parameter may refer to an rvalue &mdash; the result of an expression that is temporary &mdash; the rvalue reference parameter itself is not an rvalue, it is an lvalue. There are circumstances where you will want to convert the rvalue reference parameter from an lvalue to an rvalue. You will see in Chapter 8 how this can arise and how you can use the</i> <code class="calibre23">std::move()</code> <i class="calibre15">library function to convert an lvalue to an rvalue.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Arguments to main()</h3>
<p class="calibre13">You can define <code class="calibre23">main()</code> with no parameters or you can specify a parameter list that allows the <code class="calibre23">main()</code> function to obtain values from the command line from the execute command for the program. Values passed from the command line as arguments to <code class="calibre23">main()</code> are always interpreted as strings. If you want to get data into <code class="calibre23">main()</code> from the command line, you must define it like this:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">int main(int argc, char* argv[])</b>
{
  // Code for main()...
}</code></pre>
<p class="calibre13">The first parameter is the count of the number of strings found on the command line, including the program name, and the second parameter is an array that contains pointers to these strings plus an additional element that is null. Thus, <code class="calibre23">argc</code> is always at least 1, because you at least must enter the name of the program. The number of arguments received depends on what you enter on the command line to execute the program. For example, suppose that you execute the <code class="calibre23">DoThat</code> program with the command:</p>
<pre class="calibre28"><code class="calibre23">DoThat.exe</code></pre>
<p class="calibre13">There is just the name of the <code class="calibre23">.exe</code> file for the program, so <code class="calibre23">argc</code> is 1 and the <code class="calibre23">argv</code> array contains two elements &mdash; <code class="calibre23">argv[0]</code> pointing to the string <code class="calibre23">"DoThat.exe"</code>, and <code class="calibre23">argv[1]</code> that contains <code class="calibre23">nullptr</code>.</p>
<p class="calibre13">Suppose you enter this on the command line:</p>
<pre class="calibre28"><code class="calibre23">DoThat or else "my friend" 999.9</code></pre>
<p class="calibre13">Now <code class="calibre23">argc</code> is 5 and <code class="calibre23">argv</code> contains six elements, the last element being <code class="calibre23">nullptr</code> and the first five pointing to the strings:</p>
<pre class="calibre28"><code class="calibre23">"DoThat<i class="calibre15">" "</i>or<i class="calibre15">" "</i>else<i class="calibre15">" "</i>my friend<i class="calibre15">" "</i>999.9"</code></pre>
<p class="calibre13">You can see from this that if you want to have a string that includes spaces received as a single string, you must enclose it between double quotes. You can also see that numerical values are read as strings, so if you want conversion to the numerical value, that is up to you.</p>
<p class="calibre13">Let’s see it working.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="203" id="calibre_link-665" class="calibre24"></span>TRY IT OUT: Receiving Command-Line Arguments</h3>
<p class="calibre20">This program just lists the arguments it receives from the command line:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_10.cpp
// Reading command line arguments
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
int main(int argc, char* argv[])
{
  cout &lt;&lt; endl &lt;&lt; "argc = " &lt;&lt; argc &lt;&lt; endl;
  cout &lt;&lt; "Command line arguments received are:" &lt;&lt; endl;
  for(int i {}; i &lt;argc; i++)
    cout &lt;&lt; "argument " &lt;&lt; (i+1) &lt;&lt; ": " &lt;&lt; argv[i] &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">You have two choices as to how you enter the command-line arguments. After you build the example, you can open a command window at the folder containing the <code class="calibre23">.exe</code> file, and then enter the program name followed by the command-line arguments. Alternatively, you can specify the command-line arguments in the IDE before you execute the program. Just open the project properties window by selecting Project <img src="images/000122.png" alt="image" class="calibre25" /> Properties from the main menu and then extend the Configuration Properties tree in the left pane by clicking the arrow. Click the Debugging folder and enter the items to be passed to the application as values for the Command Arguments property.</p>
<p class="calibre20">I enter the following in the command window with the current directory containing the <code class="calibre23">.exe</code> file for the program:</p>
<pre class="calibre28"><code class="calibre23">Ex5_10 trying multiple "argument values" 4.5 0.0</code></pre>
<p class="calibre20">Here is the output resulting from my input:</p>
<pre class="calibre28"><code class="calibre23">argc = 6
Command line arguments received are:
argument 1: Ex5_10
argument 2: trying
argument 3: multiple
argument 4: argument values
argument 5: 4.5
argument 6: 0.0</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The program first outputs the value of <code class="calibre23">argc</code> and then the values of each argument from the <code class="calibre23">argv</code> array in the <code class="calibre23">for</code> loop. You can see from the output that the first argument value is the program name. <code class="calibre23">"argument values"</code> is treated as a single argument because of the enclosing double quotes.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="204" id="calibre_link-666" class="calibre14"></span>You could make use of the fact that the last element in <code class="calibre23">argv</code> is <code class="calibre23">nullptr</code> and code the output of the command-line argument values like this:</p>
<pre class="calibre28"><code class="calibre23">  int i{-1};
  while(argv[++i]
    cout &lt;&lt; "argument " &lt;&lt; (i+1) &lt;&lt; ": " &lt;&lt; argv[i] &lt;&lt; endl;
</code></pre>
<p class="calibre20">The <code class="calibre23">while</code> loop ends when <code class="calibre23">argv[argc]</code> is reached because that element contains <code class="calibre23">nullptr</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Accepting a Variable Number of Function Arguments</h3>
<p class="calibre13">You can define a function so that it allows any number of arguments to be passed to it. You indicate that a variable number of arguments can be supplied by placing an ellipsis (which is three periods, <code class="calibre23">...</code>) at the end of the parameter list in the function definition. For example:</p>
<pre class="calibre28"><code class="calibre23">int sumValues(int first,...)
{
  //Code for the function
}</code></pre>
<p class="calibre13">There must be at least one ordinary parameter, but you can have more. The ellipsis must always be placed at the end of the parameter list.</p>
<p class="calibre13">Obviously, there is no information about the type or number of arguments in the variable list, so your code must figure out what is passed to the function when it is called. The C++ library defines <code class="calibre23">va_start, va_arg</code>, and <code class="calibre23">va_end</code> macros in the <code class="calibre23">cstdarg</code> header to help you do this. It’s easiest to show how these are used with an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Receiving a Variable Number of Arguments</h3>
<p class="calibre20">This program uses a function that just sums the values of a variable number of arguments passed to it:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_11.cpp
// Handling a variable number of arguments
#include &lt;iostream&gt;
#include &lt;cstdarg&gt;
using std::cout;
using std::endl;
        
int sum(int count, ...)
{
  if(count &lt;= 0) 
    return 0;
        
  va_list arg_ptr;                     // Declare argument list pointer
  va_start(arg_ptr, count);            // Set arg_ptr to 1st optional argument
        
  int sum {};
  for(int i {}; i&lt;count; i++)
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="205" id="calibre_link-667" class="calibre14"></span>    sum += va_arg(arg_ptr, int);       // Add int value from arg_ptr and increment
        
  va_end(arg_ptr);                     // Reset the pointer to null
  return sum;
}
        
int main(int argc, char* argv[])
{
  cout &lt;&lt; sum(6, 2, 4, 6, 8, 10, 12) &lt;&lt; endl;
  cout &lt;&lt; sum(9, 11, 22, 33, 44, 55, 66, 77, 66, 99) &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">42
473</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The <code class="calibre23">main()</code> function calls the <code class="calibre23">sum()</code> function in the two output statements, in the first instance with seven arguments and in the second with ten arguments. The first argument in each case specifies the number of arguments that follow. It’s important not to forget this, because if you omit the count argument, the result will be rubbish.</p>
<p class="calibre20">The <code class="calibre23">sum()</code> function has a single normal parameter of type <code class="calibre23">int</code> that represents the count of the number of arguments that follow. The ellipsis in the parameter list indicates that an arbitrary number of arguments can be passed. Basically, you have two ways of determining how many arguments there are when the function is called &mdash; you can require that the number of arguments is specified by a fixed parameter, as in the case of <code class="calibre23">sum()</code>, or you can require that the last argument has a special marker value that you can check for and recognize.</p>
<p class="calibre20">To start processing the variable argument list, you declare a pointer of type <code class="calibre23">va_list</code>:</p>
<pre class="calibre28"><code class="calibre23">  va_list arg_ptr;                     // Declare argument list pointer</code></pre>
<p class="calibre20">The <code class="calibre23">va_list</code> type is defined in the <code class="calibre23">cstdarg</code> header file, and the pointer is used to point to each argument in turn.</p>
<p class="calibre20">The <code class="calibre23">va_start</code> macro is used to initialize <code class="calibre23">arg_ptr</code> so that it points to the first argument in the list:</p>
<pre class="calibre28"><code class="calibre23">  va_start(arg_ptr, count);            // Set arg_ptr to 1st optional argument</code></pre>
<p class="calibre20">The second argument to the macro is the name of the fixed parameter that precedes the ellipsis in the parameter list, and this is used by the macro to determine where the first variable argument is.</p>
<p class="calibre20">You retrieve the values of the arguments in the list in the <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  int sum {};
  for(int i {} ; i&lt;count; i++)
    sum += va_arg(arg_ptr, int);      // Add int value from arg_ptr and increment</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="206" id="calibre_link-668" class="calibre14"></span>The <code class="calibre23">va_arg</code> macro returns the value of the argument at the location specified by <code class="calibre23">arg_ptr</code> and increments <code class="calibre23">arg_ptr</code> to point to the next argument value. The second argument to the <code class="calibre23">va_arg</code> macro is the argument type, and this determines the value that you get as well as how <code class="calibre23">arg_ptr</code> increments, so if this is not correct, you get chaos; the program probably executes, but the values you retrieve are rubbish, and <code class="calibre23">arg_ptr</code> is incremented incorrectly to access more rubbish.</p>
<p class="calibre20">When you are finished retrieving argument values, you reset <code class="calibre23">arg_ptr</code> with the statement:</p>
<pre class="calibre28"><code class="calibre23">  va_end(arg_ptr);                     // Reset the pointer to null</code></pre>
<p class="calibre20">The <code class="calibre23">va_end</code> macro resets the pointer of type <code class="calibre23">va_list</code> that you pass as the argument to it to null. It’s a good idea to always do this because after processing the arguments, <code class="calibre23">arg_ptr</code> points to a location that does not contain valid data.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-270" class="calibre3"></a>RETURNING VALUES FROM A FUNCTION</h2>
<p class="calibre13">All the example functions that you have created have returned a single value. Is it possible to return anything other than a single value? Well, not directly, but as I said earlier, the single value returned need not be a numeric value; it could also be an address, which provides the key to returning any amount of data. You simply use a pointer. Unfortunately, this also is where the pitfalls start, so you need to keep your wits about you for the adventure ahead.</p>
<section class="toclist">
<h3 class="calibre21">Returning a Pointer</h3>
<p class="calibre13">Returning a pointer value is easy. A pointer value is just an address, so if you want to return the address of some variable <code class="calibre23">value</code>, you can just write the following:</p>
<pre class="calibre28"><code class="calibre23">return &amp;value;                     // Returning an address</code></pre>
<p class="calibre13">As long as the function header and function prototype indicate the return type appropriately, you have no problem &mdash; or at least, no apparent problem. Assuming that the variable <code class="calibre23">value</code> is of type <code class="calibre23">double</code>, the prototype of a function called <code class="calibre23">treble</code>, which might contain the preceding <code class="calibre23">return</code> statement, could be as follows:</p>
<pre class="calibre28"><code class="calibre23">double* treble(double data);</code></pre>
<p class="calibre13">I have defined the parameter list arbitrarily here.</p>
<p class="calibre13">So let’s look at a function that returns a pointer. It’s only fair that I warn you in advance &mdash; this function doesn’t work, but it is educational. Let’s assume that you need a function that returns a pointer to a memory location containing three times its argument value. Our first attempt to implement such a function might look like this:</p>
<pre class="calibre28"><code class="calibre23">// Function to treble a value - mark 1
double* treble(double data)
{
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="207" id="calibre_link-669" class="calibre14"></span>  double result {};
  result = 3.0*data;
  return &amp;result;
}</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Returning a Bad Pointer</h3>
<p class="calibre20">You could create a little test program to see what happens (remember that the <code class="calibre23">treble</code> function won’t work as expected):</p>
<pre class="calibre28"><code class="calibre23">// Ex5_12.cpp
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
double* treble (double);                 // Function prototype
        
int main()
{
  double num {5.0};                      // Test value
  double* ptr {};                        // Pointer to returned value
        
  ptr = treble(num);
        
   out &lt;&lt; endl &lt;&lt; "Three times num = " &lt;&lt; 3.0*num;
        
  cout &lt;&lt; endl &lt;&lt; "Result = " &lt;&lt; *ptr;   // Display 3*num
        
  cout &lt;&lt; endl;
  return 0;
}
        
// Function to treble a value - mark 1
double* treble(double data)
{
  double result {};
  result = 3.0*data;
  return &amp;result;
}</code></pre>
<p class="calibre20">There’s a hint that everything is not as it should be, because compiling this program results in a warning from the compiler:</p>
<pre class="calibre28"><code class="calibre23">warning C4172: returning address of local variable or temporary</code></pre>
<p class="calibre20">The output that I got from executing the program was:</p>
<pre class="calibre28"><code class="calibre23">Three times num = 15
Result = 4.10416e-230</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="208" id="calibre_link-670" class="calibre14"></span>How It Works (or Why It Doesn’t)</h4>
<p class="calibre20">The function <code class="calibre23">main()</code> calls <code class="calibre23">treble()</code> and stores the address returned in the pointer <code class="calibre23">ptr</code>, which should point to a value that is three times the argument, <code class="calibre23">num</code>. It then displays the result of computing three times <code class="calibre23">num</code>, followed by the value at the address returned from the function.</p>
<p class="calibre20">Clearly, the second line of output doesn’t reflect the correct value of 15, but where’s the error? Well, it’s not exactly a secret because the compiler gives fair warning of the problem. The error arises because the variable <code class="calibre23">result</code> in the function <code class="calibre23">treble()</code> is created when the function begins execution, and is destroyed on exiting from the function &mdash; so the memory that the pointer is pointing to no longer contains the original variable value. The memory previously allocated to <code class="calibre23">result</code> becomes available for other purposes, and here, it has evidently been used for something else.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">A Cast-Iron Rule for Returning Addresses</h4>
<p class="calibre13">There is an absolutely cast-iron rule for returning addresses:</p>
<blockquote class="extract">
<p class="calibre13"><i class="calibre15">Never, ever, return the address of a local automatic variable from a function.</i></p>
</blockquote>
<p class="calibre13">You obviously can’t use a function that doesn’t work, so what can you do to rectify that? You could use a reference parameter and modify the original variable, but that’s not what you set out to do. You are trying to return a pointer to some useful data so that, ultimately, you can return more than a single item of data. One answer lies in dynamic memory allocation (you saw this in action in the previous chapter). With the operator <code class="calibre23">new</code>, you can create a new variable in the free store that continues to exist until it is eventually destroyed by <code class="calibre23">delete</code> &mdash; or until the program ends. With this approach, the function looks like this:</p>
<pre class="calibre28"><code class="calibre23">// Function to treble a value - mark 2
double* treble(double data)
{
  double* result {new double{}};
  *result = 3.0*data;
  return result;
}</code></pre>
<p class="calibre13">Rather than declaring <code class="calibre23">result</code> to be type <code class="calibre23">double</code>, you now declare it to be of type <code class="calibre23">double*</code> and store in it the address returned by the operator <code class="calibre23">new</code>. Because the result is a pointer, the rest of the function is changed to reflect this, and the address contained in the result is finally returned to the calling program. You could exercise this version by replacing the function in the last working example with this version.</p>
<p class="calibre13">You need to remember that with dynamic memory allocation from within a function such as this, more memory is allocated each time the function is called. The onus is on the calling program to delete the memory when it’s no longer required. It’s easy to forget to do this in practice, with the result that the free store is gradually eaten up until, at some point, it is exhausted and the program fails. As mentioned before, this sort of problem is referred to as a <i class="calibre15">memory leak</i>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="209" id="calibre_link-671" class="calibre14"></span>Here you can see how the function would be used. The only necessary change to the original code is to use <code class="calibre23">delete</code> to free the memory as soon as you have finished with the pointer returned by the <code class="calibre23">treble()</code> function.</p>
<pre class="calibre28"><code class="calibre23">#include &lt;iostream&gt;
        
using std::cout;
using std::endl;
        
double* treble(double);                  // Function prototype
        
int main()
{
  double num {5.0};                      // Test value
  double* ptr {};                        // Pointer to returned value
        
  ptr = treble(num);
        
  cout &lt;&lt; endl &lt;&lt; "Three times num = " &lt;&lt; 3.0*num;
        
  cout &lt;&lt; endl &lt;&lt; "Result = " &lt;&lt; *ptr;   // Display 3*num
  <b class="calibre12">delete ptr;                            // Don</b><i class="calibre15">'</i><b class="calibre12">t forget to free the memory</b>
  ptr = nullptr;
  cout &lt;&lt; endl;
  return 0;
}
        
// Function to treble a value - mark 2
double* treble(double data)
{
  double* result {new double{}}
  *result = 3.0*data;
  return result;
}</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In Chapter 10 you’ll learn about smart pointers that eliminate the need to use</i> <code class="calibre23">delete</code> <i class="calibre15">to free memory you have allocated with</i> <code class="calibre23">new</code>. <i class="calibre15">By using smart pointers you can remove the risk of memory leaks too.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Returning a Reference</h3>
<p class="calibre13">You can also return an lvalue reference from a function. This is just as fraught with potential errors as returning a pointer, so you need to take care with this, too. Because an lvalue reference has no existence in its own right (it’s always an alias for something else), you must be sure that the object that it refers to still exists after the function completes execution. It’s very easy to forget this when you use references in a function because they appear to be just like ordinary variables.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="210" id="calibre_link-672" class="calibre14"></span>References as return types are of primary significance in the context of object-oriented programming. As you will see later in the book, they enable you to do things that would be impossible without them. (This particularly applies to “operator overloading,” which I’ll come to in Chapter 8.) Returning an lvalue reference from a function means that you can use the result of the function on the left side of an assignment statement.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Returning a Reference</h3>
<p class="calibre20">Let’s look at an example that illustrates the use of reference return types, and also demonstrates how a function can be used on the left of an assignment operation when it returns an lvalue. This example assumes that you have an array containing a mixed set of values. Whenever you want to insert a new value into the array, you want to replace the element with the lowest value.</p>
<pre class="calibre28"><code class="calibre23">// Ex5_13.cpp
// Returning a reference
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::setw;
        
double&amp; lowest(double values[], int length); // Function prototype
        
int main()
{
 
  double data[] { 3.0, 10.0, 1.5, 15.0, 2.7, 23.0,
                  4.5, 12.0, 6.8, 13.5, 2.1, 14.0 };
  int len {_countof(data)}                   // Number of elements       
  for(auto value : data)
     cout &lt;&lt; setw(6) &lt;&lt; value;
        
  lowest(data, len) = 6.9;                   // Change lowest to 6.9
  lowest(data, len) = 7.9;                   // Change lowest to 7.9
        
  cout &lt;&lt; endl;
  for (auto value : data)
     cout &lt;&lt; setw(6) &lt;&lt; value;
        
  cout &lt;&lt; endl;
  return 0;
}
        
// Function returning a reference
double&amp; lowest(double a[], int len)
{
  int j {};                                  // Index of lowest element
  for(int i {1}; i &lt; len; i++)
     if(a[j] &gt; a[i])                         // Test for a lower value...
        j = i;                               // ...if so update j
  return a[j];                               // Return reference to lowest element
}
</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="211" id="calibre_link-673" class="calibre14"></span>The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">     3    10   1.5    15   2.7    23   4.5    12   6.8  13.5   2.1    14
     3    10   6.9    15   2.7    23   4.5    12   6.8  13.5   7.9    14</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">Let’s first look at how the function is implemented. The prototype for the function <code class="calibre23">lowest()</code> uses <code class="calibre23">double&amp;</code> as the specification of the return type, which is therefore of type “reference to <code class="calibre23">double.</code>” You write a reference type return value in exactly the same way as you have seen for variable declarations, by appending <code class="calibre23">&amp;</code> to the data type. The function has two parameters &mdash; a one-dimensional array of type <code class="calibre23">double</code> and a parameter of type <code class="calibre23">int</code> that specifies the length of the array.</p>
<p class="calibre20">The body of the function has a straightforward <code class="calibre23">for</code> loop to determine which element of the array passed contains the lowest value. The index, <code class="calibre23">j</code>, of the array element with the lowest value is arbitrarily set to 0 at the outset, and then modified within the loop if the current element, <code class="calibre23">a[i]</code>, is less than <code class="calibre23">a[j]</code>. Thus, on exit from the loop, <code class="calibre23">j</code> contains the index value corresponding to the array element with the lowest value. The <code class="calibre23">return</code> statement is:</p>
<pre class="calibre28"><code class="calibre23">   return a[j];                    // Return reference to lowest element</code></pre>
<p class="calibre20">In spite of the fact that this looks identical to the statement that would return a value, because the return type was declared as a reference, this returns a reference to the array element <code class="calibre23">a[j]</code> rather than the value that the element contains. The address of <code class="calibre23">a[j]</code> is used to initialize the reference to be returned. This reference is created by the compiler because the return type was declared as a reference.</p>
<p class="calibre20">Don’t confuse returning <code class="calibre23">&amp;a[j]</code> with returning a reference. If you write <code class="calibre23">&amp;a[j]</code> as the return value, you are specifying the address of <code class="calibre23">a[j]</code>, which is a <i class="calibre15">pointer</i>. If you do this after having specified the return type as a <i class="calibre15">reference</i>, you get an error message from the compiler. Specifically, you get this:</p>
<pre class="calibre28"><code class="calibre23"> error C2440: <i class="calibre15">'</i>return<i class="calibre15">'</i> : cannot convert from <i class="calibre15">'</i>double * <i class="calibre15">'</i> to <i class="calibre15">'</i>double &amp;<i class="calibre15">'</i></code></pre>
<p class="calibre20">The function <code class="calibre23">main()</code>, which exercises the <code class="calibre23">lowest()</code> function, is very simple. An array of type <code class="calibre23">double</code> is declared and initialized with 12 arbitrary values, and an <code class="calibre23">int</code> variable <code class="calibre23">len</code> is initialized to the length of the array using the <code class="calibre23">_countof()</code> macro. The initial values in the array are output for comparison purposes.</p>
<p class="calibre20">Again, the program uses the stream manipulator <code class="calibre23">setw()</code> to space the values uniformly, requiring the <code class="calibre23">#include</code> directive for <code class="calibre23">iomanip</code>.</p>
<p class="calibre20">The function <code class="calibre23">main()</code> then calls the function <code class="calibre23">lowest()</code> on the left of an assignment to change the lowest value in the array. This is done twice to show that it does actually work and is not an accident. The contents of the array are then output to the display again, with the same field width as before, so corresponding values line up.</p>
<p class="calibre20">As you can see from the output with the first call to <code class="calibre23">lowest()</code>, the third element of the array, <code class="calibre23">data[2]</code>, contained the lowest value, so the function returned a reference to it and its value was changed to 6.9. Similarly, on the second call, <code class="calibre23">data[10]</code> was changed to 7.9. This demonstrates quite clearly that returning a reference allows the use of the function on the left of an assignment. The effect is as if the variable specified in the <code class="calibre23">return</code> statement appeared on the left of the assignment.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="212" id="calibre_link-674" class="calibre14"></span>Of course, if you want to, you can also use it on the right of an assignment, or in any other suitable expression. If you had two arrays, <code class="calibre23">X</code> and <code class="calibre23">Y</code>, with the number of array elements specified by <code class="calibre23">lenx</code> and <code class="calibre23">leny</code>, respectively, you could set the lowest element in the array <code class="calibre23">x</code> to twice the lowest element in the array <code class="calibre23">y</code> with this statement:</p>
<pre class="calibre28"><code class="calibre23">lowest(x, lenx) = 2.0*lowest(y, leny);</code></pre>
<p class="calibre20">This statement would call <code class="calibre23">lowest()</code> twice &mdash; once with arguments <code class="calibre23">y</code> and <code class="calibre23">leny</code> in the expression on the right of the assignment, and once with arguments <code class="calibre23">x</code> and <code class="calibre23">lenx</code> to obtain the address where the result of the right-hand expression is to be stored.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">A Cast-Iron Rule: Returning References</h4>
<p class="calibre13">A similar rule to the one concerning the return of a pointer from a function also applies to returning references:</p>
<blockquote class="extract">
<p class="calibre13"><i class="calibre15">Never, ever, return a reference to a local variable from a function.</i></p>
</blockquote>
<p class="calibre13">I’ll leave the topic of returning a reference from a function for now, but I haven’t finished with it yet. I will come back to it again in the context of user-defined types and object-oriented programming, when you will unearth a few more magical things that you can do with references.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Static Variables in a Function</h3>
<p class="calibre13">There are some things you can’t do with automatic variables within a function. You can’t count how many times a function is called, for example, because you can’t accumulate a value from one call to the next. There’s more than one way to get around this. For instance, you could use a reference parameter to update a count in the calling program, but this wouldn’t help if the function was called from lots of different places within a program. You could use a global variable that you incremented from within the function, but globals are risky things to use. Because globals can be accessed from anywhere in a program, it is very easy to change them accidentally.</p>
<p class="calibre13">Global variables are also risky in applications that have multiple threads of execution that access them, and you must take special care to manage how globals are accessed from different threads. The basic problem that has to be addressed when more than one thread can access a global variable is that one thread can change the value of a global variable while another thread is working with it. The best solution in such circumstances is to avoid the use of global variables altogether.</p>
<p class="calibre13">To create a variable whose value persists from one call of a function to the next, you can declare a variable within a function as <code class="calibre23">static</code>. You use exactly the same form of declaration for a <code class="calibre23">static</code> variable that you saw in Chapter 2. For example, to declare a variable <code class="calibre23">count</code> as <code class="calibre23">static</code>, you could use this statement:</p>
<pre class="calibre28"><code class="calibre23">static int count {};</code></pre>
<p class="calibre13">This also initializes the variable to zero.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="213" id="calibre_link-675" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Initialization of a static variable within a function only occurs the first time that the function is called. On the first call of a function, the static variable is created and initialized. It then continues to exist for the duration of program execution, and whatever value it contains when the function is exited is available when the function is next called.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Static Variables in Functions</h3>
<p class="calibre20">You can demonstrate how a static variable behaves in a function with the following simple example:</p>
<pre class="calibre28"><code class="calibre23">// Ex5_14.cpp
// Using a static variable within a function
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
void record();      // Function prototype, no arguments or return value
        
int main()
{
  record();
        
  for(int i {}; i &lt;= 3; i++)
     record();
        
  cout &lt;&lt; endl;
  return 0;
}
        
// A function that records how often it is called
void record()
{
  static int count {};
  cout &lt;&lt; endl &lt;&lt; "This is the " &lt;&lt; ++count;
  if((count &gt; 3) &amp;&amp; (count &lt; 21))         // All this....
     cout &lt;&lt;"th";
  else
     switch(count%10)                     // is just to get...
     {
     case 1: cout &lt;&lt; "st";
             break;
     case 2: cout &lt;&lt; "nd";
             break;
     case 3: cout &lt;&lt; "rd";
             break;
     default: cout &lt;&lt; "th";               // the right ending for...
     }                                    // 1st, 2nd, 3rd, 4th, etc.
   cout &lt;&lt; " time I have been called";
   return;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="214" id="calibre_link-676" class="calibre14"></span>Our function here serves only to record the fact that it was called. If you build and execute it, you get this output:</p>
<pre class="calibre28"><code class="calibre23">This is the 1st time I have been called
This is the 2nd time I have been called
This is the 3rd time I have been called
This is the 4th time I have been called
This is the 5th time I have been called</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">You initialize the static variable <code class="calibre23">count</code> with 0 and increment it in the first output statement in the function. Because the increment operator is prefixed, the incremented value is displayed by the output statement. It will be 1 on the first call, 2 on the second, and so on. Because <code class="calibre23">count</code> is static, it continues to exist and retain its value from one call of the function to the next.</p>
<p class="calibre20">The remainder of the function is concerned with working out when <code class="calibre23">"st", "nd", "rd"</code>, or <code class="calibre23">"th"</code> should be appended to the value of <code class="calibre23">count</code> that is displayed. It’s surprisingly irregular.</p>
<p class="calibre20">Note the <code class="calibre23">return</code> statement. Because the return type of the function is <code class="calibre23">void</code>, to include a value would cause a compiler error. You don’t actually need to put a <code class="calibre23">return</code> statement in this particular case, because running off the closing brace for the body of the function is equivalent to executing a <code class="calibre23">return</code> statement without a value. The program would compile and run without error even if you didn’t include the <code class="calibre23">return</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-271" class="calibre3"></a>RECURSIVE FUNCTION CALLS</h2>
<p class="calibre13">When a function contains a call to itself, it’s referred to as a <i class="calibre15">recursive function</i>. A recursive function call can also be indirect, where a function <code class="calibre23">fun1</code> calls a function <code class="calibre23">fun2</code>, which, in turn, calls <code class="calibre23">fun1</code>.</p>
<p class="calibre13">Recursion may seem to be a recipe for an indefinite loop, and if you aren’t careful, it certainly can be. An indefinite loop will lock up your machine and require <i class="calibre15">Ctrl+Alt+Del</i> to end the program, which is always a nuisance. A prerequisite for avoiding an indefinite loop is that the function contains some means of stopping the process.</p>
<p class="calibre13">Unless you have come across the technique before, the sort of things to which recursion may be applied may not be obvious. In physics and mathematics, there are many things that can be thought of as involving recursion. A simple example is the factorial of an integer, which, for a given integer N, is the product 1 × 2 × 3 . . . × N. This is very often the example given to show recursion in operation. Recursion can also be applied to the analysis of programs during the compilation process; however, you will look at something even simpler.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: A Recursive Function</h3>
<p class="calibre20">At the start of this chapter (see <code class="calibre23">Ex5_01.cpp</code>), you produced a function to compute the integral power of a value; that is, to compute x<sup class="calibre33">n</sup>. This is equivalent to <i class="calibre15">x</i> multiplied by itself <i class="calibre15">n</i> times. You can implement this as a recursive function as an elementary illustration of recursion in action. You can also improve the implementation of the function to deal with negative index values, where x<sup class="calibre33">-n</sup> is equivalent to 1/x<sup class="calibre33">n</sup>.</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="215" id="calibre_link-677" class="calibre14"></span>// Ex5_15.cpp (based on Ex5_01.cpp)
// A recursive version of x to the power n
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
double power(double x, int n);    // Function prototype
        
int main()
{
  double x {2.0};                 // Different x from that in function power
  double result {};
        
  // Calculate x raised to powers -3 to +3 inclusive
  for(int index {-3}; index &lt;= 3; index++)
    cout &lt;&lt; x &lt;&lt; " to the power " &lt;&lt; index &lt;&lt; " is " &lt;&lt; power(x, index)&lt;&lt; endl;
        
  return 0;
}
        
// Recursive function to compute integral powers of a double value
// First argument is value, second argument is power index
double power(double x, int n)
{
  if(n &lt; 0)
  {
     x = 1.0/x;
     n = -n;
  }
  if(n &gt; 0)
     return x*power(x, n-1);
  else
     return 1.0;
}</code></pre>
<p class="calibre20">The output from this program is:</p>
<pre class="calibre28"><code class="calibre23">2 to the power -3 is 0.125
2 to the power -2 is 0.25
2 to the power -1 is 0.5
2 to the power 0 is 1
2 to the power 1 is 2
2 to the power 2 is 4
2 to the power 3 is 8</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The function now supports positive and negative powers of <code class="calibre23">x</code>, so the first action is to check whether the value for the power that <code class="calibre23">x</code> is to be raised to, <code class="calibre23">n</code>, is negative:</p>
<pre class="calibre28"><code class="calibre23">   if(n &lt; 0)
   {
     x = 1.0/x;
     n = -n;
   }</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="216" id="calibre_link-678" class="calibre14"></span>Supporting negative powers is easy; the code just uses the fact that x<sup class="calibre33">-n</sup> can be evaluated as (1/x)<sup class="calibre33">n</sup>. Thus, if n is negative, you set <code class="calibre23">x</code> to be <code class="calibre23">1.0/x</code> and change the sign of <code class="calibre23">n</code> so it’s positive.</p>
<p class="calibre20">The next <code class="calibre23">if</code> statement decides whether or not the <code class="calibre23">power()</code> function should call itself once more:</p>
<pre class="calibre28"><code class="calibre23">   if(n &gt; 0)
     return x*power(x, n-1);
   else
     return 1.0;</code></pre>
<p class="calibre20">The <code class="calibre23">if</code> statement provides for the value 1.0 being returned if <code class="calibre23">n</code> is zero, and in all other cases, it returns the result of the expression, <code class="calibre23">x*power(x, n-1)</code>. This causes a further call to the function <code class="calibre23">power()</code> with the index value reduced by 1. Thus, the <code class="calibre23">else</code> clause in the <code class="calibre23">if</code> statement provides the essential mechanism necessary to avoid an indefinite sequence of recursive function calls.</p>
<p class="calibre20">Clearly, if the value of <code class="calibre23">n</code> is other than zero within the function <code class="calibre23">power()</code>, a further call to <code class="calibre23">power()</code>occurs. In fact, for any given value of <code class="calibre23">n</code> other than 0, the function calls itself <code class="calibre23">n</code> times, ignoring the sign of <code class="calibre23">n</code>. <a id="calibre_link-10" href="#calibre_link-9" class="calibre3">Figure 5-4</a> shows the mechanism when the index argument is 3.</p>
<figure class="calibre16">
<img class="center" src="images/000074.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-9" href="#calibre_link-10" class="calibre3">FIGURE 5-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">As you see, the <code class="calibre23">power()</code> function is called a total of four times to generate x<sup class="calibre33">3</sup>, three of the calls being recursive where the function is calling itself.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="217" id="calibre_link-679" class="calibre24"></span>Using Recursion</h3>
<p class="calibre13">Unless you have a problem that particularly lends itself to using recursive functions, or if you have no obvious alternative, it’s generally better to use a different approach, such as a loop, because it will be much more efficient than using recusion. Think about what happens with our last example to evaluate a simple product, <code class="calibre23">x</code> multiplied by itself <code class="calibre23">n</code> times. On each call, the compiler generates copies of the two arguments to the function, and also has to keep track of the location to return to when each <code class="calibre23">return</code> is executed. It’s also necessary to arrange to save the contents of various registers in your computer so that they can be used within <code class="calibre23">power()</code>, and, of course, these need to be restored to their original state at each return from the function. With a quite modest depth of recursive call, the overhead will be considerably greater than if you use a loop.</p>
<p class="calibre13">This is not to say you should never use recursion. Where the problem suggests the use of recursive function calls as a solution, it can be an immensely powerful technique, greatly simplifying the code. You’ll see an example where this is the case in the next chapter.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-272" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter, you learned about the basics of program structure. You should have a good grasp of how functions are defined, how data can be passed to a function, and how results are returned to a calling program. Functions are fundamental to programming in C++, so everything you do from here on will involve using multiple functions in a program.</p>
<p class="calibre13">The use of references as arguments is a very important concept, so make sure you are confident about using them. You’ll see a lot more about references as arguments to functions when you look into object-oriented programming.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">The factorial of 4 (written as 4!) is 4 × 3 × 2 × 1 = 24, and 3! is 3 × 2 × 1 = 6, so it follows that 4! is 4 × 3!, or more generally:
<pre class="calibre28"><code class="calibre23">fact(n) = n*fact(n - 1)</code></pre>
<ol class="none">
<li class="calibre6">The limiting case is when n is 1, in which case, 1! = 1. Because of this, 0! is defined to be 1. Write a recursive function that calculates factorials, and test it.</li>
</ol></li>
<li class="calibre6">Write a function that swaps two integers, using pointers as arguments. Write a program that uses this function and test that it works correctly.</li>
<li class="calibre6">The trigonometry functions (<code class="calibre23">sin(), cos()</code>, and <code class="calibre23">tan()</code>) in the standard <code class="calibre23">cmath</code> library take arguments in radians. Write three equivalent functions, called <code class="calibre23">sind(), cosd()</code>, and <code class="calibre23">tand()</code>, which take arguments in degrees. All arguments and return values should be type <code class="calibre23">double</code>.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="218" id="calibre_link-680" class="calibre14"></span>Write a program that reads a number (an integer) and a name (less than 15 characters) from the keyboard. Design the program so that the data entry is done in one function, and the output in another. Store the data in the <code class="calibre23">main()</code> function. The program should end when zero is entered for the number. Think about how you are going to pass the data between functions &mdash; by value, by pointer, or by reference?</li>
<li class="calibre6">(Advanced) Write a function that, when passed a string consisting of words separated by single spaces, returns the first word; calling it again with an argument of <code class="calibre23">nullptr</code> returns the second word, and so on, until the string has been processed completely, when <code class="calibre23">nullptr</code> is returned. This is a simplified version of the way the C run-time library routine <code class="calibre23">strtok()</code> works. So, when passed the string <code class="calibre23">"one two three"</code>, the function returns <code class="calibre23">"one"</code> after the first call, then <code class="calibre23">"two"</code> after the second, and finally <code class="calibre23">"three"</code>. Passing it a new string results in the current string being discarded before the function starts on the new string.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="219" id="calibre_link-681" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Functions</b></td>
<td class="calibre32">Functions should be compact units of code with a well-defined purpose. A typical program will consist of a large number of small functions, rather than a small number of large functions.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Function prototypes</b></td>
<td class="calibre32">Always provide a function prototype for each function defined in your program, positioned before you call that function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Reference parameters</b></td>
<td class="calibre32">Passing values to a function using a reference can avoid the copying implicit in the pass-by-value transfer of arguments. Parameters that are not modified in a function should be specified as <code class="calibre23">const</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Returning references or pointers</b></td>
<td class="calibre32">When returning a reference or a pointer from a function, ensure that the object being returned has the correct scope. Never return a pointer or a reference to an object that is local to a function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12"><code class="calibre23">static</code> variables in a function</b></td>
<td class="calibre32">A static variable that is defined within the body of a function retains its value from one function call to the next.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="220" id="calibre_link-682" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-171">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2319" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="221" id="calibre_link-683" class="calibre9"></span><span class="chapternumber">Chapter 6</span><br class="calibre10" /><span class="chapternumber">More about Program Structure</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">What a pointer to a function is</li>
<li class="calibre6">How to define and use pointers to functions</li>
<li class="calibre6">How to define and use arrays of pointers to functions</li>
<li class="calibre6">What an exception is and how to write exception handlers that deal with them</li>
<li class="calibre6">How to write multiple functions with a single name to handle different kinds of data automatically</li>
<li class="calibre6">What function templates are and how to define and use them</li>
<li class="calibre6">How to write a substantial program using several functions</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 6 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-273" class="calibre3"></a>POINTERS TO FUNCTIONS</h2>
<p class="calibre13">A pointer stores an address value that up to now has been the address of another variable. This has provided considerable flexibility in allowing you to use different variables at different times through a single pointer. A pointer can also store the address of a function. This enables you to call a function through a pointer, which will be the function at the address that was last assigned to the pointer.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="222" id="calibre_link-684" class="calibre14"></span>Obviously, a pointer to a function must contain the address of the function that you want to call. To work properly, the pointer must also maintain information about the parameter list for the function it points to, as well as the return type. Therefore, the type for a pointer to a function must incorporate the parameter types and the return type of the functions to which it can point. Clearly, this is going to restrict what you can store in a particular pointer to a function.</p>
<p class="calibre13">If you have declared a pointer to functions that accept one argument of type <code class="calibre23">int</code> and return a value of type <code class="calibre23">double</code>, you can only store the address of a function that has exactly this form. If you want to store the address of a function that accepts two arguments of type <code class="calibre23">int</code> and returns type <code class="calibre23">char</code>, you must define another pointer with a type that includes these characteristics.</p>
<section class="toclist">
<h3 class="calibre21">Declaring Pointers to Functions</h3>
<p class="calibre13">You can declare a pointer <code class="calibre23">pfun</code> that you can use to point to functions that take two arguments, of type <code class="calibre23">char*</code> and <code class="calibre23">int</code>, and return a value of type <code class="calibre23">double</code> like this:</p>
<pre class="calibre28"><code class="calibre23">double (*pfun)(char*, int);            // Pointer to function declaration</code></pre>
<p class="calibre13">At first, you may find that the parentheses make this look a little weird. This declares a pointer with the name <code class="calibre23">pfun</code> that can point to functions that accept two arguments, one of type pointer to <code class="calibre23">char</code> and another of type <code class="calibre23">int</code>, and return a value of type <code class="calibre23">double</code>. The parentheses around the pointer name, <code class="calibre23">pfun</code>, and the asterisk are essential; without them, the statement would be a function declaration rather than a pointer declaration. In this case, it would look like this:</p>
<pre class="calibre28"><code class="calibre23">double *pfun(char*, int);                  </code></pre>
<p class="calibre13">This is a prototype for a function <code class="calibre23">pfun()</code> that has two parameters, and returns a pointer to a <code class="calibre23">double</code> value. The general form of a declaration of a pointer to a function looks like this:</p>
<pre class="calibre28"><code class="calibre23"><i class="calibre15">return_type (*pointer_name)(list_of_parameter_types);</i></code></pre>
<p class="calibre13">The declaration of a pointer to a function consists of three components:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The return type of the functions that can be pointed to</li>
<li class="calibre6">The pointer name preceded by an asterisk to indicate it is a pointer</li>
<li class="calibre6">The parameter types of the functions that can be pointed to</li>
</ul>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The pointer can only point to functions with the same <code class="calibre23">return_type</code> and <code class="calibre23">list_of_parameter_types</code> specified in the declaration. If you attempt to assign a function to a pointer that does not conform to the types in the pointer declaration, the compiler generates an error message.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="223" id="calibre_link-685" class="calibre14"></span>You can initialize a pointer to a function with the name of a function within the declaration of the pointer. The following is an example of this:</p>
<pre class="calibre28"><code class="calibre23">long sum(long num1, long num2);      // Function prototype
long (*pfun)(long, long) {sum};      // Pointer to function points to sum()</code></pre>
<p class="calibre13">In general, you can set the <code class="calibre23">pfun</code> pointer that you declared here to point to any function that accepts two arguments of type <code class="calibre23">long</code> and returns a value of type <code class="calibre23">long</code>. In the first instance, you initialized it with the address of the <code class="calibre23">sum()</code> function that has the prototype given by the first statement.</p>
<p class="calibre13">When you initialize a pointer to a function in the declaration, you can use the <code class="calibre23">auto</code> keyword for the type. You can write the previous declaration as:</p>
<pre class="calibre28"><code class="calibre23">auto pfun = sum;</code></pre>
<p class="calibre13">As long as the prototype or definition for <code class="calibre23">sum()</code> precedes this statement in the source file, the compiler can work out the pointer type.</p>
<p class="calibre13">Of course, you can also initialize a pointer to a function by using an assignment statement. Assuming the pointer <code class="calibre23">pfun</code> has been declared as in the preceding code, you could set the value of the pointer to a different function with these statements:</p>
<pre class="calibre28"><code class="calibre23">long product(long, long);            // Function prototype
...
pfun = product;                      // Set pointer to function product()</code></pre>
<p class="calibre13">As with pointers to variables, you must ensure that a pointer to a function is initialized before you use it. Without initialization, catastrophic failure of your program is guaranteed.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Pointers to Functions</h3>
<p class="calibre20">To get a proper feeling for these newfangled pointers and how they perform in action, try one out in a program:</p>
<pre class="calibre28"><code class="calibre23">// Ex6_01.cpp
// Exercising pointers to functions
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
long sum(long a, long b);              // Function prototype
long product(long a, long b);          // Function prototype
        
int main()
{
  long (*pdo_it)(long, long);          // Pointer to function declaration
        
  pdo_it = product;
  cout &lt;&lt; endl
       &lt;&lt; "3*5 = " &lt;&lt; pdo_it(3, 5);    // Call product thru a pointer
        
  pdo_it = sum;                        // Reassign pointer to sum()
  cout &lt;&lt; endl
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="224" id="calibre_link-686" class="calibre14"></span>       &lt;&lt; "3*(4 + 5) + 6 = "
       &lt;&lt; pdo_it(product(3, pdo_it(4, 5)), 6);   // Call thru a pointer,
                                                 // twice
  cout &lt;&lt; endl;
  return 0;
}
        
// Function to multiply two values
long product(long a, long b)
{
  return a*b;
}
        
// Function to add two values
long sum(long a, long b)
{
  return a + b;
}</code></pre>
<p class="calibre20">This example produces the output:</p>
<pre class="calibre28"><code class="calibre23">3*5 = 15
3*(4 + 5) + 6 = 33</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">This is hardly a useful program, but it does show very simply how a pointer to a function is declared, assigned a value, and subsequently used to call a function.</p>
<p class="calibre20">After the usual preamble, you declare a pointer to a function, <code class="calibre23">pdo_it</code>, which can point to either of the other two functions that you have defined, <code class="calibre23">sum()</code> or <code class="calibre23">product()</code>. The pointer is given the address of the function <code class="calibre23">product()</code> in this assignment statement:</p>
<pre class="calibre28"><code class="calibre23">pdo_it = product;</code></pre>
<p class="calibre20">You just supply the name of the function as the initial value for the pointer, and no parentheses or other adornments are required. The function name is automatically converted to an address, which is stored in the pointer. You could replace the first two statements in <code class="calibre23">main()</code> with this statement:</p>
<pre class="calibre28"><code class="calibre23">auto pdo_it = product;</code></pre>
<p class="calibre20">This declares and initializes <code class="calibre23">pdo_it</code> with the address of the <code class="calibre23">product()</code> function.</p>
<p class="calibre20">The function <code class="calibre23">product()</code> is called indirectly through the pointer <code class="calibre23">pdo_it</code> in the output statement.</p>
<pre class="calibre28"><code class="calibre23">   cout &lt;&lt; endl
        &lt;&lt; "3*5 = " &lt;&lt; pdo_it(3, 5);        // Call product thru a pointer</code></pre>
<p class="calibre20">You use the name of the pointer just as if it was a function name, followed by the arguments between parentheses exactly as they would appear if you were using the original function name directly.</p>
<p class="calibre20">Just to show that you can, you change the pointer to point to <code class="calibre23">sum()</code>:</p>
<pre class="calibre28"><code class="calibre23">   pdo_it = sum;                            // Reassign pointer to sum()</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="225" id="calibre_link-687" class="calibre14"></span>You then use it again in a ludicrously convoluted expression to do some simple arithmetic:</p>
<pre class="calibre28"><code class="calibre23">   cout &lt;&lt; endl
        &lt;&lt; "3*(4 + 5) + 6 = "
        &lt;&lt; pdo_it(product(3, pdo_it(4, 5)), 6);  // Call thru a pointer,
                                                 // twice</code></pre>
<p class="calibre20">This shows that you can use a pointer to a function in exactly the same way as the function that it points to. The sequence of actions in the expression is shown in <a id="calibre_link-173" href="#calibre_link-172" class="calibre3">Figure 6-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000001.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-172" href="#calibre_link-173" class="calibre3">FIGURE 6-1</a></b></span></p>
</figcaption>
</figure>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">A Pointer to a Function as an Argument</h3>
<p class="calibre13">Because “pointer to a function” is a perfectly reasonable type, a function can also have a parameter that is of a pointer to a function type. The function can then call the function pointed to by the argument. The pointer can point to different functions in different circumstances, which allows the particular function that is to be called from inside a function to be determined in the calling <span {http://www.idpf.org/2007/ops}type="pagebreak" title="226" id="calibre_link-688" class="calibre14"></span>program. You can pass a function name explicitly as the argument for a parameter that is of a pointer to function type.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Passing a Function Pointer</h3>
<p class="calibre20">Suppose you need a function that processes an array of values by producing the sum of the squares of each of the elements on some occasions, and the sum of the cubes on other occasions. One way of achieving this is by using a pointer to a function as a parameter.</p>
<pre class="calibre28"><code class="calibre23">// Ex6_02.cpp
// A pointer to a function as an argument
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
// Function prototypes
double squared(double);
double cubed(double);
double sumarray(const double data[], size_t len, double (*pfun)(double));
        
int main()
{
  double data[] { 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5 };
  size_t len {_countof(data)};
        
  cout &lt;&lt; endl &lt;&lt; "Sum of squares = " &lt;&lt; sumarray(data, len, squared);
  cout &lt;&lt; endl &lt;&lt; "Sum of cubes = " &lt;&lt; sumarray(data, len, cubed);
  cout &lt;&lt; endl;
  return 0;
}
        
// Function for a square of a value
double squared(double x)
{
  return x*x;
}
        
// Function for a cube of a value
double cubed(double x)
{
  return x*x*x;
}
        
// Function to sum functions of array elements
double sumarray(const double data[], size_t len, double (*pfun)(double))
{
  double total {};                   // Accumulate total in here
        
  for(size_t i {}; i &lt; len; i++)
    total += pfun(data[i]);
        
  return total;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="227" id="calibre_link-689" class="calibre14"></span>If you compile and run this code, you should see the following output:</p>
<pre class="calibre28"><code class="calibre23">Sum of squares = 169.75
Sum of cubes = 1015.88
</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The first statement of interest is the prototype for the function <code class="calibre23">sumarray()</code>. Its third parameter is a pointer to a function that has a parameter of type <code class="calibre23">double</code>, and returns a value of type <code class="calibre23">double</code>.</p>
<pre class="calibre28"><code class="calibre23">double sumarray(double array[], int len, double (*pfun)(double));</code></pre>
<p class="calibre20">The function <code class="calibre23">sumarray()</code> processes each element of the array passed as its first argument with whatever function is pointed to by its third argument. The function then returns the sum of the processed array elements. The third argument must be a function that returns a <code class="calibre23">double</code> value and accepts an argument of type <code class="calibre23">double</code>.</p>
<p class="calibre20">You call <code class="calibre23">sumarray()</code> twice in <code class="calibre23">main()</code>, the first time with the function name <code class="calibre23">squared</code> as the third argument, and the second using <code class="calibre23">cubed</code>. In each case, the address corresponding to the function name that you use as the argument is substituted for the function pointer in the body of <code class="calibre23">sumarray()</code>, so the appropriate function is called within the <code class="calibre23">for</code> loop.</p>
<p class="calibre20">There are obviously easier ways of achieving what this example does, but using a pointer to a function provides you with a lot of generality. You could pass any function to <code class="calibre23">sumarray()</code> that you care to define as long as it takes one <code class="calibre23">double</code> argument and returns a value of type <code class="calibre23">double</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Arrays of Pointers to Functions</h3>
<p class="calibre13">In the same way as with regular pointers, you can declare an array of pointers to functions. You can also initialize them in the declaration. Here is an example:</p>
<pre class="calibre28"><code class="calibre23">double sum(const double, const double);          // Function prototype
double product(const double, const double);      // Function prototype
double difference(const double, const double);   // Function prototype
double (*pfun[])( const double, const double)
                 { sum, product, difference };   // Array of function pointers</code></pre>
<p class="calibre13">Each array element is initialized by the corresponding function address in the initializing list. The array length is determined by the number of values in the list. You cannot use <code class="calibre23">auto</code> to deduce an array type, so you must put the specific type here.</p>
<p class="calibre13">To call <code class="calibre23">product()</code> using the second element of the pointer array, you would write:</p>
<pre class="calibre28"><code class="calibre23">pfun[1](2.5, 3.5);</code></pre>
<p class="calibre13">The square brackets that select the function pointer array element appear immediately after the array name and before the arguments to the function being called. Of course, you can place a function call through an element of a function pointer array in any appropriate expression that the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="228" id="calibre_link-690" class="calibre14"></span>original function might legitimately appear in, and the index value selecting the pointer can be any expression producing a valid index.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-274" class="calibre3"></a>INITIALIZING FUNCTION PARAMETERS</h2>
<p class="calibre13">With all the functions you have used up to now, you have had to take care to provide an argument corresponding to each parameter in a function call. It can be quite handy to be able to omit one or more arguments in a function call and have some default values supplied automatically for the arguments that you leave out. You can arrange this by providing initial values for the parameters to a function in its prototype.</p>
<p class="calibre13">Suppose that you write a function to display a message, where the message is passed as the argument. Here is the definition of such a function:</p>
<pre class="calibre28"><code class="calibre23">void showit(const char message[])
{
  cout &lt;&lt; endl
       &lt;&lt; message;
  return;
}</code></pre>
<p class="calibre13">You can specify a default value for the parameter to this function by specifying the initializing string in the function prototype, as follows:</p>
<pre class="calibre28"><code class="calibre23">void showit(const char message[] = "Something is wrong.");</code></pre>
<p class="calibre13">The default value for the <code class="calibre23">message</code> parameter is the string literal shown. If you omit the argument when you call the function, the default value is used.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Omitting Function Arguments</h3>
<p class="calibre20">Leaving out the function argument when you call the function executes it with the default value. If you supply the argument, it replaces the default value. You can use the <code class="calibre23">showit()</code> function to output a variety of messages.</p>
<pre class="calibre28"><code class="calibre23">// Ex6_03.cpp
// Omitting function arguments
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
void showit(const char message[] = "Something is wrong.");
        
int main()
{
  const char mymess[] {"The end of the world is nigh."};
        
  showit();                                 // Display the basic message
  showit("Something is terribly wrong!");   // Display an alternative
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="229" id="calibre_link-691" class="calibre14"></span>  showit();                                 // Display the default again
  showit(mymess);                           // Display a predefined message
        
  cout &lt;&lt; endl;
  return 0;
}
        
void showit(const char message[])
{
  cout &lt;&lt; endl
       &lt;&lt; message;
  return;
}</code></pre>
<p class="calibre20">If you execute this example, it produces the following apocalyptic output:</p>
<pre class="calibre28"><code class="calibre23">Something is wrong.
Something is terribly wrong!
Something is wrong.
The end of the world is nigh.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">As you see, you get the default message specified in the function prototype whenever the argument is left out; otherwise, the function behaves normally.</p>
<p class="calibre20">If you have a function with several arguments, you can provide initial values for as many of them as you like. If you want to omit more than one argument to take advantage of a default value, all arguments to the right of the leftmost argument that you omit must also be left out. For example, suppose you have this function:</p>
<pre class="calibre28"><code class="calibre23">int do_it(long arg1 = 10, long arg2 = 20, long arg3 = 30, long arg4 = 40);</code></pre>
<p class="calibre20">If you want to omit one argument in a call to it, you can omit only the last one, <code class="calibre23">arg4</code>. If you want to omit <code class="calibre23">arg3</code>, you must also omit <code class="calibre23">arg4</code>. If you omit <code class="calibre23">arg2, arg3</code> and <code class="calibre23">arg4</code> must also be omitted, and if you want to use the default value for <code class="calibre23">arg1</code>, you have to omit all of the arguments.</p>
<p class="calibre20">You can conclude from this that you need to put the parameters that have default values in the function prototype together in sequence at the end of the parameter list, with the parameter most likely to be omitted appearing last.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-275" class="calibre3"></a>EXCEPTIONS</h2>
<p class="calibre13">If you’ve had a go at the exercises that appear at the end of the previous chapters, you’ve more than likely come across compiler errors and warnings, as well as errors that occur while the program is running. <i class="calibre15">Exceptions</i> are a way of flagging errors or unexpected conditions that occur in your programs, and you already know that the <code class="calibre23">new</code> operator throws an exception if the memory you request cannot be allocated.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="230" id="calibre_link-692" class="calibre14"></span>So far, you have typically handled error conditions by using an <code class="calibre23">if</code> statement to test some expression, and then executing some specific code to deal with the error. C++ provides another, more general mechanism for handling errors that allows you to separate the code that deals with these conditions from the code that executes when such conditions do not arise. It is important to realize that exceptions are not intended to be used as an alternative to the normal data checking and validating that you might do in a program. The code that is generated when you use exceptions carries quite a bit of overhead with it, so exceptions are really intended to be applied in the context of exceptional, near-catastrophic conditions that might arise, but are not expected to occur in the normal course of events. An error reading a disk might be something that you use exceptions for. An invalid data item being entered is not a good candidate for using exceptions.</p>
<p class="calibre13">The exception mechanism uses three new keywords:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">try</code>&mdash;Identifies a code block in which an exception can occur. A <code class="calibre23">try</code> block must be immediately followed by at least one <code class="calibre23">catch</code> block.</li>
<li class="calibre6"><code class="calibre23">throw</code>&mdash;Causes an exception condition to be originated and throws an exception of a particular type.</li>
<li class="calibre6"><code class="calibre23">catch</code>&mdash;Identifies a block of code that handles the exception. A <code class="calibre23">catch</code> block is executed when an exception is thrown in the preceding <code class="calibre23">try</code> block that is of the type that is specified between parentheses following the <code class="calibre23">catch</code> keyword. A <code class="calibre23">try</code> block may be followed by several <code class="calibre23">catch</code> blocks, each catching a different type of exception.</li>
</ul>
<p class="calibre13">In the following Try It Out, you can see how they work in practice.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Throwing and Catching Exceptions</h3>
<p class="calibre20">You can easily see how exception handling operates by working through an example. Let’s use a very simple context for this. Suppose that you are required to write a program that calculates the time it takes in minutes to make a part on a machine. The number of parts made in each hour is recorded, but you must keep in mind that the machine breaks down regularly and may not make any parts.</p>
<p class="calibre20">You could code this using exception handling as follows:</p>
<pre class="calibre28"><code class="calibre23">// Ex6_04.cpp  Using exception handling
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
int main()
{
  int counts[] {34, 54, 0, 27, 0, 10, 0};
  double time {60};                     // One hour in minutes
  int hour {};                          // Current hour
        
  for(auto count : counts)
  {
    try
    {
      cout &lt;&lt; endl &lt;&lt; "Hour " &lt;&lt; ++hour;
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="231" id="calibre_link-693" class="calibre14"></span>      if(0 == count)
        throw "Zero count - calculation not possible.";
        
      cout &lt;&lt; " minutes per item: " &lt;&lt; time/count;
    }
    catch(const char aMessage[])
    {
      cout &lt;&lt; endl &lt;&lt; aMessage &lt;&lt; endl;
    }
  }
  return 0;
}</code></pre>
<p class="calibre20">If you run this example, the output is:</p>
<pre class="calibre28"><code class="calibre23">Hour 1 minutes per item: 1.76471
Hour 2 minutes per item: 1.11111
Hour 3
Zero count - calculation not possible.
        
Hour 4 minutes per item: 2.22222
Hour 5
Zero count - calculation not possible.
        
Hour 6 minutes per item: 6
Hour 7
Zero count - calculation not possible.</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The code in the <code class="calibre23">try</code> block is executed in the normal sequence. The <code class="calibre23">try</code> block serves to define where an exception can be raised. You can see from the output that when an exception is thrown, the sequence of execution continues with the <code class="calibre23">catch</code> block. The <code class="calibre23">catch</code> block will execute when an exception of type <code class="calibre23">const char[]</code> is thrown. After the code in the <code class="calibre23">catch</code> block has been executed, execution continues with the next loop iteration. Of course, when no exception is thrown, the <code class="calibre23">catch</code> block is not executed.</p>
<p class="calibre20">The division is carried out in the output statement that follows the <code class="calibre23">if</code> statement checking the divisor. When a <code class="calibre23">throw</code> statement is executed, control passes immediately to the first statement in the <code class="calibre23">catch</code> block, so the statement that performs the division is bypassed when an exception is thrown. After the statement in the <code class="calibre23">catch</code> block executes, the loop continues with the next iteration, if there is one.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">Throwing Exceptions</h3>
<p class="calibre13">You can throw an exception anywhere within a <code class="calibre23">try</code> block using a <code class="calibre23">throw</code> statement, and the <code class="calibre23">throw</code> statement operand determines the type of the exception. The exception thrown in the example is a string literal and, therefore, of type <code class="calibre23">const char[]</code>. The operand following the <code class="calibre23">throw</code> keyword can be any expression, and the type of the result of the expression determines the type of exception thrown. There must be a <code class="calibre23">catch</code> block to catch an exception of the type that may be thrown.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="232" id="calibre_link-694" class="calibre14"></span>Exceptions can also be thrown in functions that are called from within a <code class="calibre23">try</code> block and can be caught by a <code class="calibre23">catch</code> block following the <code class="calibre23">try</code> block if they are not caught within the function. You could add a function to the previous example to demonstrate this, with the definition:</p>
<pre class="calibre28"><code class="calibre23">void testThrow()
{
  throw " Zero count - calculation not possible.";
}</code></pre>
<p class="calibre13">You place a call to this function in the previous example in place of the <code class="calibre23">throw</code> statement:</p>
<pre class="calibre28"><code class="calibre23">  if(0 == count)
    testThrow();             // Call a function that throws an exception</code></pre>
<p class="calibre13">The exception is thrown by the <code class="calibre23">testThrow()</code> function and caught by the <code class="calibre23">catch</code> block whenever the array element is zero, so the output is the same as before. Don’t forget the function prototype if you add the definition of <code class="calibre23">testThrow()</code> to the end of the source code.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Catching Exceptions</h3>
<p class="calibre13">The <code class="calibre23">catch</code> block following the <code class="calibre23">try</code> block in our example catches any exception of type <code class="calibre23">const char[]</code>. This is determined by the parameter specification that appears in parentheses following the keyword <code class="calibre23">catch</code>. You must supply at least one <code class="calibre23">catch</code> block for a <code class="calibre23">try</code> block, and the <code class="calibre23">catch</code> blocks must immediately follow the <code class="calibre23">try</code> block. A <code class="calibre23">catch</code> block catches all exceptions (of the specified type) that occur anywhere in the code in the immediately preceding <code class="calibre23">try</code> block, including those thrown and not caught in any functions called directly or indirectly within the <code class="calibre23">try</code> block.</p>
<p class="calibre13">If you want to specify that a <code class="calibre23">catch</code> block is to handle any exception thrown in a <code class="calibre23">try</code> block, you put an ellipsis (<code class="calibre23">...</code>) between the parentheses enclosing the exception declaration:</p>
<pre class="calibre28"><code class="calibre23">catch (...)
{
  // code to handle any exception
}</code></pre>
<p class="calibre13">This <code class="calibre23">catch</code> block catches exceptions of any type. It must appear last if you have other <code class="calibre23">catch</code> blocks defined for the <code class="calibre23">try</code> block.</p>
<p class="calibre13">Here’s how a <code class="calibre23">try</code> block followed by two <code class="calibre23">catch</code> blocks looks:</p>
<pre class="calibre28"><code class="calibre23">try 
{
  ...
} 
catch (const type1&amp; ex) 
{
  ...
} 
catch (type2 ex) 
{
  ...
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="233" id="calibre_link-695" class="calibre14"></span>When an exception is thrown in a try block with more than one catch block, the catch blocks are checked in sequence until a match for the exception type is found. The code in the first catch block that matches will be executed.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Nested try Blocks</h3>
<p class="calibre20">You can nest <code class="calibre23">try</code> blocks one within another. With this situation, if an exception is thrown from within an inner <code class="calibre23">try</code> block that is not followed by a <code class="calibre23">catch</code> block corresponding to the type of exception thrown, the catch handlers for the outer <code class="calibre23">try</code> block are searched. You can demonstrate this with the following example:</p>
<pre class="calibre28"><code class="calibre23">// Ex6_05.cpp
// Nested try blocks
#include &lt;iostream&gt;
using std::cin;
using std::cout;
using std::endl;
        
int main()
{
  int height {};
  const int minHeight {9};                       // Minimum height in inches
  const int maxHeight {100};                     // Maximum height in inches
  const double inchesToMeters {0.0254};
  char ch {'y'};
        
  try                                            // Outer try block
  {
    while('y' == ch || 'Y' == ch)
    {
      cout &lt;&lt; "Enter a height in inches: ";
      cin &gt;&gt; height;                             // Read the height to be
                                                 // converted
        
      try                                        // Defines try block in which
      {                                          // exceptions may be thrown
        if(height &gt; maxHeight)
           throw "Height exceeds maximum";       // Exception thrown
        if(height &lt; minHeight)
           throw height;                         // Exception thrown
        
         cout &lt;&lt; static_cast&lt;double&gt;(height)*inchesToMeters
              &lt;&lt; " meters" &lt;&lt; endl;
      }
      catch(const char aMessage[])               // start of catch block which
      {                                          // catches exceptions of type
        cout &lt;&lt; aMessage &lt;&lt; endl;                // const char[]
      }
      cout &lt;&lt; "Do you want to continue(y or n)?";
      cin &gt;&gt; ch;
    }
  }
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="234" id="calibre_link-696" class="calibre14"></span>  catch(int badHeight)
  {
    cout &lt;&lt; badHeight &lt;&lt; " inches is below minimum" &lt;&lt; endl;
  }
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">There is a <code class="calibre23">try</code> block enclosing the <code class="calibre23">while</code> loop and an inner <code class="calibre23">try</code> block in which two different types of exception may be thrown. The exception of type <code class="calibre23">const char[]</code> is caught by the <code class="calibre23">catch</code> block for the inner <code class="calibre23">try</code> block, but the exception of type <code class="calibre23">int</code> has no catch handler associated with the inner <code class="calibre23">try</code> block; therefore, the <code class="calibre23">catch</code> handler in the outer try block is executed. In this case, the program ends immediately because the statement following the <code class="calibre23">catch</code> block is a <code class="calibre23">return</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Rethrowing Exceptions</h3>
<p class="calibre13">It may be that when you catch an exception, you want to pass it on the calling program for some additional action, rather that handling it entirely in the <code class="calibre23">catch</code> block. In this case you can rethrow the exception for onward processing. For example:</p>
<pre class="calibre28"><code class="calibre23">try 
{
  ...
} 
catch (const type1&amp; ex) 
{
  ...
} 
catch (type2 ex) 
{
  // Process the exception...
  throw;                // Rethrow the exception for processing by the caller
}</code></pre>
<p class="calibre13">Using <code class="calibre23">throw</code> without an operand causes the exception that is being handled to be rethrown. You can only use <code class="calibre23">throw</code> without an operand within a <code class="calibre23">catch</code> block. Rethrowing an exception allows the exception to be caught by an enclosing <code class="calibre23">try/catch</code> block or by a caller of this function. The calling function must place its call to the function in a <code class="calibre23">try</code> block to catch the rethrown exception.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Exception Handling in the MFC</h3>
<p class="calibre13">This is a good point to raise the question of MFC and exceptions because they are used to some extent. If you browse the documentation that came with Visual C++, you may come across <code class="calibre23">TRY, THROW</code>, and <code class="calibre23">CATCH</code> in the index. These are macros defined within the MFC that were created before exception handling was implemented in the C++ language. They mimic the operation of <code class="calibre23">try, throw</code>, and <code class="calibre23">catch</code> in C++, but the language facilities for exception handling really render these obsolete, so you should not use them. They are, however, still there for two reasons. There are large numbers of <span {http://www.idpf.org/2007/ops}type="pagebreak" title="235" id="calibre_link-697" class="calibre14"></span>programs still around that use these macros, and it is important to ensure that, as far as possible, old code still compiles. Also, most of the MFC that throws exceptions was implemented in terms of these macros. In any event, any new programs should use the <code class="calibre23">try, throw</code>, and <code class="calibre23">catch</code> keywords because they work with the MFC.</p>
<p class="calibre13">There is one slight anomaly you need to keep in mind when you use MFC functions that throw exceptions. The MFC functions that throw exceptions generally throw exceptions of class types &mdash; you will find out about class types before you get to use the MFC. Even though the exception that an MFC function throws is of a given class type &mdash; <code class="calibre23">CDBException</code>, say &mdash; you need to catch the exception as a pointer, not as the type of the exception. So, with the exception thrown being of type <code class="calibre23">CDBException</code>, the type that appears as the <code class="calibre23">catch</code> block parameter is <code class="calibre23">CBDException*</code>. If you are not rethrowing the exception, you must also delete the exception object in the catch block by calling its <code class="calibre23">Delete()</code> function. For example:</p>
<pre class="calibre28"><code class="calibre23">try
{
    // Execute some code that might throw an MFC exception... 
}
catch (CException* ex) 
{
    // Handle the exception here...
    ex-&gt;Delete();                           // Delete the exception object
}</code></pre>
<p class="calibre13">You should not use <code class="calibre23">delete</code> to delete the exception object because the object may not be allocated on the heap. <code class="calibre23">CException</code> is the base class for all MFC exceptions so the catch block here will catch MFC exceptions of any type.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-276" class="calibre3"></a>HANDLING MEMORY ALLOCATION ERRORS</h2>
<p class="calibre13">When you used the <code class="calibre23">new</code> operator to allocate memory (as you saw in Chapters 4 and 5), you ignored the possibility that the memory might not be allocated. If the memory isn’t allocated, an exception is thrown that results in the termination of the program. Ignoring this exception is quite acceptable in most situations because having no memory left is usually a terminal condition for a program that you can usually do nothing about. However, there can be circumstances where you might be able to do something about it if you had the chance, or you might want to report the problem in your own way. In this situation, you can catch the exception that the <code class="calibre23">new</code> operator throws. Let’s contrive an example to show this happening.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Catching an Exception Thrown by the new Operator</h3>
<p class="calibre20">The exception that the <code class="calibre23">new</code> operator throws when memory cannot be allocated is of type <code class="calibre23">std::bad_alloc. bad_alloc</code> is a class type defined in the <code class="calibre23">new</code> standard header file, so you’ll need an <code class="calibre23">#include</code> directive for that. Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">// Ex6_06.cpp
// Catching an exception thrown by new
#include&lt;new&gt;                    // For bad_alloc type
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="236" id="calibre_link-698" class="calibre14"></span>#include&lt;iostream&gt;
using std::bad_alloc;
using std::cout;
using std::endl;
        
int main()
{
  char* pdata {};
  size_t count {~static_cast&lt;size_t&gt;(0)/2};
  try
  {
    pdata = new char[count];
    cout &lt;&lt; "Memory allocated." &lt;&lt; endl;
  }
  catch(bad_alloc&amp; ex)
  {
    cout &lt;&lt; "Memory allocation failed." &lt;&lt; endl
         &lt;&lt; "The information from the exception object is: "
         &lt;&lt; ex.what() &lt;&lt; endl;
  }
  delete[] pdata;
  return 0;
}</code></pre>
<p class="calibre20">On my machine, this example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Memory allocation failed.
The information from the exception object is: bad allocation</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The example allocates memory dynamically for an array of type <code class="calibre23">char[]</code> where the length is specified by the <code class="calibre23">count</code> variable that you define as:</p>
<pre class="calibre28"><code class="calibre23">  size_t count {~static_cast&lt;size_t&gt;(0)/2};</code></pre>
<p class="calibre20">The size of an array is an integer of type <code class="calibre23">size_t</code>, so you declare <code class="calibre23">count</code> to be of this type. The value for <code class="calibre23">count</code> is generated by a somewhat complicated expression. The value 0 is type <code class="calibre23">int</code>, so the value produced by the expression <code class="calibre23">static_cast&lt;size_t&gt;(0)</code> is a zero of type <code class="calibre23">size_t</code>. Applying the <code class="calibre23">~</code> operator to this flips all the bits so you then have a <code class="calibre23">size_t</code> value with all the bits as 1, which corresponds to the maximum value you can represent as <code class="calibre23">size_t</code>, because <code class="calibre23">size_t</code> is an unsigned type. This value exceeds the maximum amount of memory that the <code class="calibre23">new</code> operator can allocate in one go, so you divide by 2 to bring it within the bounds of what is possible. This is still a very large value, so, unless your machine is exceptionally well endowed with memory, the allocation request will fail.</p>
<p class="calibre20">The allocation of the memory takes place in the <code class="calibre23">try</code> block. If the allocation succeeds, you’ll see a message to that effect, but if, as you expect, it fails, an exception of type <code class="calibre23">bad_alloc</code> will be thrown by the <code class="calibre23">new</code> operator. This causes the code in the <code class="calibre23">catch</code> block to be executed. Calling the <code class="calibre23">what()</code> function for the <code class="calibre23">bad_alloc</code> object reference <code class="calibre23">ex</code> returns a string describing the problem that caused the exception, and you see the result of this call in the output. All standard exception classes implement the <code class="calibre23">what()</code> function to provide a string describing why the exception was thrown.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="237" id="calibre_link-699" class="calibre14"></span>To handle out-of-memory situations with some positive effect, clearly, you must have some means of returning memory to the free store. In most practical cases, this involves some serious work on the program to manage memory, so it is not often undertaken.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-277" class="calibre3"></a>FUNCTION OVERLOADING</h2>
<p class="calibre13">Suppose you have written a function that determines the maximum value in an array of values of type <code class="calibre23">double</code>:</p>
<pre class="calibre28"><code class="calibre23">// Function to generate the maximum value in an array of type double
double maxdouble(const double data[], const size_t len)
{
   double maximum {data(0)};
        
   for(size_t i {1}; i &lt; len; i++)
      if(maximum &lt; data[i])
         maximum = data[i];
        
   return maximum;
}
</code></pre>
<p class="calibre13">You now want to create a function that produces the maximum value from an array of type <code class="calibre23">long</code>, so you write another function similar to the first, with this prototype:</p>
<pre class="calibre28"><code class="calibre23">long maxlong(const long data[], const size_t len);</code></pre>
<p class="calibre13">You have chosen the function name to reflect the particular task in hand, which is OK for two functions, but you may also need the same function for several other types of argument. It seems a pity that you have to keep inventing names. Ideally, you would use the same function name <code class="calibre23">max()</code> regardless of the argument type, and have the appropriate version executed. It probably won’t be any surprise to you that you can, indeed, do this, and the C++ mechanism that makes it possible is called <i class="calibre15">function overloading</i>.</p>
<section class="toclist">
<h3 class="calibre21">What Is Function Overloading?</h3>
<p class="calibre13">Function overloading allows you to use several functions with the same name as long as they each have different parameter lists. When one of the functions is called, the compiler chooses the correct version for the job based on the list of arguments. Obviously, the compiler must always be able to decide unequivocally which function should be selected in any particular instance of a function call, so the parameter list for each function in a set of overloaded functions must be unique. Following on from the <code class="calibre23">max()</code> function example, you could create overloaded functions with the following prototypes:</p>
<pre class="calibre28"><code class="calibre23">int max(const int data[], const size_t len);               // Prototypes for
long max(const long data[], const size_t len);             // a set of overloaded
double max(const double data[], const size_t len);         // functions</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="238" id="calibre_link-700" class="calibre14"></span>These functions share a common name, but have different parameter lists. Overloaded functions that have the same number of parameters must have at least one parameter with a unique type. An overloaded function can have a different number of parameters from the others in the set.</p>
<p class="calibre13">Note that a different return type does not distinguish a function adequately. You can’t add the following function to the previous set:</p>
<pre class="calibre28"><code class="calibre23">double max(const long data[], const size_t len);           // Not valid overloading</code></pre>
<p class="calibre13">The reason is that this function would be indistinguishable from the function that has this prototype:</p>
<pre class="calibre28"><code class="calibre23">long max(const long data[], const size_t len);</code></pre>
<p class="calibre13">If you define functions like this, it causes the compiler to complain with the following error:</p>
<pre class="calibre28"><code class="calibre23">error C2556: 'double max(const long [],const size_t)' :
    overloaded function differs only by return type from 'long max(const long [],const size_t)'</code></pre>
<p class="calibre13">This may seem slightly unreasonable, until you remember that you can write statements such as these:</p>
<pre class="calibre28"><code class="calibre23">long numbers[] {1, 2, 3, 3, 6, 7, 11, 50, 40};
const size_t len {_countof(numbers)}
max(numbers, len);</code></pre>
<p class="calibre13">The call for the <code class="calibre23">max()</code> function doesn't make much sense here because you discard the result, but this does not make it illegal. If the return type were permitted as a distinguishing feature, the compiler would be unable to decide whether to choose the version with a <code class="calibre23">long</code> or a <code class="calibre23">double</code> return type. For this reason, the return type is not considered to be a differentiating feature of overloaded functions.</p>
<p class="calibre13">Every function &mdash; not just overloaded functions &mdash; is said to have a <i class="calibre15">signature</i>, where the signature of a function is determined by its name and its parameter list. All functions in a program must have unique signatures, otherwise the program does not compile.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Overloaded Functions</h3>
<p class="calibre20">You can exercise the overloading capability with the function <code class="calibre23">max()</code> that you have already defined. Try an example that includes the three versions for <code class="calibre23">int, long</code>, and <code class="calibre23">double</code> arrays.</p>
<pre class="calibre28"><code class="calibre23">// Ex6_07.cpp
// Using overloaded functions
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
int max(const int data[],const size_t  len);               // Prototypes for
long max(const long data[],const size_t  len);             // a set of overloaded
double max(const double data[],const size_t  len);         // functions
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="239" id="calibre_link-701" class="calibre14"></span>int main()
{
  int small[] {1, 24, 34, 22};
  long medium[] {23, 245, 123, 1, 234, 2345};
  double large[] {23.0, 1.4, 2.456, 345.5, 12.0, 21.0};
      
  const size_t lensmall {_countof(small)};
  const size_t lenmedium {_countof(medium)};
  const size_t lenlarge {_countof(large)};
      
  cout &lt;&lt; endl &lt;&lt; max(small, lensmall);
  cout &lt;&lt; endl &lt;&lt; max(medium, lenmedium);
  cout &lt;&lt; endl &lt;&lt; max(large, lenlarge);
      
  cout &lt;&lt; endl;
  return 0;
}
        
// Maximum of ints
int max(const int x[],const size_t len)
{
  int maximum {x[0]};
  for(size_t i {1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}
        
// Maximum of longs
long max(const long x[],const size_t  len)
{
  long maximum {x[0]};
  for(size_t i {1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}
      
// Maximum of doubles
double max(const double x[],const size_t len)
{
  double maximum {x[0]};
  for(size_t i {1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}
</code></pre>
<p class="calibre20">The example works as you would expect and produces this output:</p>
<pre class="calibre28"><code class="calibre23">34
2345
345.5</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="240" id="calibre_link-702" class="calibre14"></span>How It Works</h4>
<p class="calibre20">You have three prototypes for the three overloaded versions of the function <code class="calibre23">max()</code>. In each of the three output statements, the appropriate version of the function <code class="calibre23">max()</code> is selected by the compiler based on the argument list types. This works because each of the versions of <code class="calibre23">max()</code> has a unique signature, because each parameter list is different from that of the others.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Reference Types and Overload Selection</h3>
<p class="calibre13">When you use reference types for parameters in overloaded functions, you must take care to ensure the compiler can select an appropriate overload. Suppose you define functions with the following prototypes:</p>
<pre class="calibre28"><code class="calibre23">void f(int n);
void f(int&amp; rn);</code></pre>
<p class="calibre13">These functions are differentiated by the type of the parameter, but code using these will not compile. When you call <code class="calibre23">f()</code> with an argument of type <code class="calibre23">int</code>, the compiler has no means of determining which function should be selected because either function is equally applicable. In general, you cannot overload on a given type, <code class="calibre23">type</code>, and an lvalue reference to that type, <code class="calibre23">type&amp;</code>.</p>
<p class="calibre13">However, the compiler can distinguish the overloaded functions with the following prototypes:</p>
<pre class="calibre28"><code class="calibre23">void f(int&amp; arg);        // Lvalue reference parameter
void f(int&amp;&amp; arg);       // Rvalue reference parameter</code></pre>
<p class="calibre13">Even though for some argument types, either function could apply, the compiler adopts a preferred choice. The <code class="calibre23">f(int&amp;)</code> function will always be selected when the argument is an lvalue. The <code class="calibre23">f(int&amp;&amp;)</code> version will be selected only when the argument is an rvalue. For example:</p>
<pre class="calibre28"><code class="calibre23">int num{5};
f(num);                  // Calls f(int&amp;)
f(2*num);                // Calls f(int&amp;&amp;)
f(25);                   // Calls f(int&amp;&amp;)
f(num++);                // Calls f(int&amp;&amp;)
f(++num);                // Calls f(int&amp;)</code></pre>
<p class="calibre13">Only the first and last statements call the overload with the lvalue reference parameter, because the other statements call the function with arguments that are rvalues.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The rvalue reference type parameter is intended primarily for addressing specific problems that you’ll learn about when you look into defining classes.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="241" id="calibre_link-703" class="calibre24"></span>When to Overload Functions</h3>
<p class="calibre13">Function overloading provides you with the means of ensuring that a function name describes the function being performed and is not confused by extraneous information such as the type of data being processed. This is akin to what happens with basic operations in C++. To add two numbers, you use the same operator, regardless of the types of the operands. Our overloaded function <code class="calibre23">max()</code> has the same name, regardless of the type of data being processed. This helps to make the code more readable and makes these functions easier to use.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The intent of function overloading is clear: to enable the same operation to be performed with different operands using a single function name. So, whenever you have a series of functions that do essentially the same thing, but with different types of arguments, you should overload them and use a common function name, or write a function template, which is coming up next.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-278" class="calibre3"></a>FUNCTION TEMPLATES</h2>
<p class="calibre13">The last example was somewhat tedious in that you had to repeat essentially the same code for each function, but with different variable and parameter types. However, there is a way of avoiding this. You have the possibility of creating a recipe that will enable the compiler to automatically generate functions with various parameter types. The code defining the recipe for generating a particular group of functions is called a <i class="calibre15">function template</i>.</p>
<p class="calibre13">A function template has one or more <i class="calibre15">type parameters</i>, and you generate a particular function by supplying a concrete type argument for each of the template’s parameters. Thus, the functions generated by a function template all have the same basic code, but customized by the type arguments that you supply. You can see how this works in practice by defining a function template for the function <code class="calibre23">max()</code> in the previous example.</p>
<section class="toclist">
<h3 class="calibre21">Using a Function Template</h3>
<p class="calibre13">You can define a template for the function <code class="calibre23">max()</code> as follows:</p>
<pre class="calibre28"><code class="calibre23">template&lt;class T&gt; T max(const T x[], const size_t len)
{
  T maximum {x[0]};
  for(size_t i{1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}</code></pre>
<p class="calibre13">The <code class="calibre23">template</code> keyword identifies this as a template definition. The angled brackets following the <code class="calibre23">template</code> keyword enclose the type parameters that are used to create a particular instance of the function separated by commas; in this instance, you have just one type parameter, <code class="calibre23">T</code>. The <span {http://www.idpf.org/2007/ops}type="pagebreak" title="242" id="calibre_link-704" class="calibre14"></span><code class="calibre23">class</code> keyword before the <code class="calibre23">T</code> indicates that the <code class="calibre23">T</code> is the type parameter for this template, <code class="calibre23">class</code> being the generic term for type. Later in the book, you will see that defining a class is essentially defining your own data type. Consequently, you have fundamental types in C++, such as type <code class="calibre23">int</code> and type <code class="calibre23">char</code>, and you also have the types that you define yourself. You can use the keyword <code class="calibre23">typename</code> instead of <code class="calibre23">class</code> to identify the parameters in a function template, in which case, the template definition would look like this:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt; T max(const T x[], const size_t len)
{
  T maximum {x[0]};
  for(size_t i {1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}</code></pre>
<p class="calibre13">Some programmers prefer to use the <code class="calibre23">typename</code> keyword as the <code class="calibre23">class</code> keyword tends to connote a user-defined type, whereas <code class="calibre23">typename</code> is more neutral and, therefore, is more readily understood to imply fundamental types as well as user-defined types. In practice, you’ll see both used widely.</p>
<p class="calibre13">Wherever <code class="calibre23">T</code> appears in the definition of a function template, it is replaced by the specific type argument, such as <code class="calibre23">long</code>, that you supply when you create an instance of the template. If you try this out manually by plugging in <code class="calibre23">long</code> in place of <code class="calibre23">T</code> in the template, you’ll see that this generates a perfectly satisfactory function for calculating the maximum value from an array of type <code class="calibre23">long</code>:</p>
<pre class="calibre28"><code class="calibre23">long max(const long x[], const size_t len)
{
  long maximum {x[0]};
  for(size_t i {1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}</code></pre>
<p class="calibre13">The creation of a particular function instance is referred to as <i class="calibre15">instantiation</i>. Each time you use <code class="calibre23">max()</code> in your program, the compiler checks to see if a function corresponding to the type of arguments that you have used in the function call already exists. If the function required does not exist, the compiler creates one by substituting the argument type that you have used in your function call in place of the parameter <code class="calibre23">T</code> throughout the template definition.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The compiler will only process a template definition if you use it in your code. This means that errors in the template will not be identified if you don’t use it.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You could exercise the template for the <code class="calibre23">max()</code> function with the same <code class="calibre23">main()</code> function that you used in the previous example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="243" id="calibre_link-705" class="calibre24"></span>TRY IT OUT: Using a Function Template</h3>
<p class="calibre20">Here’s a version of the previous example modified to use a template for the <code class="calibre23">max()</code> function:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex6_08.cpp</b>
<b class="calibre12">// Using function templates</b>
        
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
<b class="calibre12">// Template for function to compute the maximum element of an array</b>
<b class="calibre12">template&lt;typename T&gt; T max(const T x[], const size_t len)</b>
<b class="calibre12">{</b>
  <b class="calibre12">T maximum {x[0]};</b>
  <b class="calibre12">for(size_t i {1}; i &lt; len; i++)</b>
    <b class="calibre12">if(maximum &lt; x[i])</b>
      <b class="calibre12">maximum = x[i];</b>
  <b class="calibre12">return maximum;</b>
<b class="calibre12">}</b>
        
int main()
{
  int small[] { 1, 24, 34, 22};
  long medium[] { 23, 245, 123, 1, 234, 2345};
  double large[] { 23.0, 1.4, 2.456, 345.5, 12.0, 21.0};
     
  size_t lensmall {_countof(small)};
  size_t lenmedium {_countof(medium)};
  size_t lenlarge {_countof(large)};
        
 
  cout &lt;&lt; endl &lt;&lt; max(small, lensmall);
  cout &lt;&lt; endl &lt;&lt; max(medium, lenmedium);
  cout &lt;&lt; endl &lt;&lt; max(large, lenlarge);
        
  cout &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">This program produces exactly the same output as the previous example.</p>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">For each of the statements outputting the maximum value in an array, a new version of <code class="calibre23">max()</code> is instantiated using the template. Of course, if you add another statement calling the function <code class="calibre23">max()</code> with one of the types used previously, no new version of the template code is generated.</p>
<p class="calibre20">Using a template doesn’t reduce the size of your compiled program in any way. The compiler generates a version of the source code for each unique function that you require. In fact, using templates can <i class="calibre15">increase</i> the size of your program, because functions may be created even though an existing version might satisfactorily be used by casting because the argument. You can force the creation of particular instance of a template by explicitly including a declaration for it. For example, if you wanted to ensure <span {http://www.idpf.org/2007/ops}type="pagebreak" title="244" id="calibre_link-706" class="calibre14"></span>that an instance of the template for the function <code class="calibre23">max()</code> was created corresponding to type <code class="calibre23">float</code>, you could place the following declaration after the definition of the template:</p>
<pre class="calibre28"><code class="calibre23">float max (const float[], const size_t);</code></pre>
<p class="calibre20">This forces the creation of this version of the function template. It does not have much value in the case of our program example, but it can be useful when you know that several versions of a template function might be generated, but you want to force the generation of a subset that you plan to use, with arguments cast to the appropriate type where necessary.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-279" class="calibre3"></a>USING THE DECLTYPE OPERATOR</h2>
<p class="calibre13">You use the <code class="calibre23">decltype</code> operator to obtain the type of an expression, so <code class="calibre23">decltype(exp)</code> is the type of the value that results from evaluating the expression <code class="calibre23">exp</code>. For example, you could write the following statements:</p>
<pre class="calibre28"><code class="calibre23">double x {100.0};
int n {5};
decltype(x*n) result(x*n);</code></pre>
<p class="calibre13">The last statement specifies the type of <code class="calibre23">result</code> to be the type of the expression <code class="calibre23">x*n</code>, which is type <code class="calibre23">double</code>. While this shows the mechanics of what the <code class="calibre23">decltype</code> operator does, the primary use for the <code class="calibre23">decltype</code> operator is in defining function templates. Occasionally, the return type of a template function with multiple type parameters may depend on the types used to instantiate the template. Suppose you want to write a template function to multiply corresponding elements of two arrays, possibly of different types, and return the sum of these products. Because the types of the two arrays may be different, the type of the result will depend on the actual types of the array arguments, so you cannot specify a particular return type. The function template might notionally look like this:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename  T1, typename  T2&gt;
return_type f(T1 v1[], T2 v2[], const size_t count)
{
  decltype(v1[0]*v2[0]) sum {};
  for(size_t i {}; i&lt;count; i++) sum += v1[i]*v2[i];
  return sum;
}</code></pre>
<p class="calibre13"><code class="calibre23">return_type</code> needs to be the type of the result of multiplying corresponding elements of the array arguments. The <code class="calibre23">decltype</code> operator can help, but unfortunately the following will not compile:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename  T1, typename  T2&gt;
decltype(v1[0]*v2[0]) f(T1 v1[], T2 v2[], const size_t count)   // Will not compile!
{
  decltype(v1[0]*v2[0]) sum {};
  for(size_t i {}; i&lt;count; i++) sum += v1[i]*v2[i];
  return sum;
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="245" id="calibre_link-707" class="calibre14"></span>This specifies what you want, but the compiler cannot compile this because <code class="calibre23">v1</code> and <code class="calibre23">v2</code> are not defined at the point where the return type specification is processed.</p>
<p class="calibre13">It requires a different syntax to take care of it:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T1, typename T2&gt;
auto f(T1 v1[], T2 v2[], const size_t count) -&gt; decltype(v1[0]*v2[0])
{
  decltype(v1[0]*v2[0]) sum {};
  for(size_t i {}; i&lt;count; i++) sum += v1[i]*v2[i];
  return sum;
}</code></pre>
<p class="calibre13">As you saw in Chapter 5, this is referred to as a <i class="calibre15">trailing return type</i>. You specify the return type using the <code class="calibre23">auto</code> keyword. The actual return type can be determined by the compiler when an instance of the template is created because, at that point, the parameters <code class="calibre23">v1</code> and <code class="calibre23">v2</code> have been parsed. The <code class="calibre23">decltype</code> expression following the <code class="calibre23">-&gt;</code> determines the return type for any instance of the template. Let’s see if it works.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using the decltype Operator</h3>
<p class="calibre20">Here’s a simple example to exercise the template you have just seen:</p>
<pre class="calibre28"><code class="calibre23">// Ex6_09.cpp Using the decltype operator
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
template&lt;typename T1, typename T2&gt;
auto product(T1 v1[], T2 v2[], const size_t count) -&gt; decltype(v1[0]*v2[0])
{
  decltype(v1[0]*v2[0]) sum {};
  for(size_t i {}; i&lt;count; i++) sum += v1[i]*v2[i];
  return sum;
}
        
int main()
{
  double x[] {100.5, 99.5, 88.7, 77.8};
  short y[] {3, 4, 5, 6};
  long z[] {11L, 12L, 13L, 14L};
  size_t n {_countof(x)};
  cout &lt;&lt; "Result type is " &lt;&lt; typeid(product(x, y, n)).name() &lt;&lt; endl;
  cout &lt;&lt; "Result is " &lt;&lt; product(x, y, n) &lt;&lt; endl;
  auto result = product(z, y, n);
  cout &lt;&lt; "Result type is " &lt;&lt; typeid(result).name() &lt;&lt; endl;
  cout &lt;&lt; "Result is " &lt;&lt; result &lt;&lt; endl;
 
  return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="246" id="calibre_link-708" class="calibre14"></span>This produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Result type is double
Result is 1609.8
Result type is long
Result is 230</code></pre>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre20">The return types for functions generated from the <code class="calibre23">product()</code> function template are determined by the expression <code class="calibre23">decltype(v1[0]*v2[0])</code>. The first instantiations of the template in <code class="calibre23">main()</code> are due to the statements:</p>
<pre class="calibre28"><code class="calibre23">  cout &lt;&lt; "Result type is "&lt;&lt; typeid(product(x, y, n)).name() &lt;&lt; endl;
  cout &lt;&lt; "Result is " &lt;&lt; product(x, y, n) &lt;&lt; endl;</code></pre>
<p class="calibre20">You can see from the output that the type of the value returned by the <code class="calibre23">product()</code> function instance is type <code class="calibre23">double</code> when the first two arguments are arrays of type <code class="calibre23">double</code> and type <code class="calibre23">short</code>, respectively, which is as it should be. Executing the next three statements shows that the type for the value returned is type <code class="calibre23">long</code> when the arguments are arrays of type <code class="calibre23">short</code> and <code class="calibre23">long</code>. You obtain the type of <code class="calibre23">result</code> where the <code class="calibre23">auto</code> keyword determines the type of the variable to be that of the value returned by <code class="calibre23">product()</code>. Clearly, the <code class="calibre23">decltype</code> operator is working exactly as advertized.</p>
<p class="calibre20">The type of <code class="calibre23">result</code> will be the same as the type of value returned by <code class="calibre23">product()</code>, which is determined by the <code class="calibre23">auto</code> keyword.</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt; auto max(const T x[], const size_t len) -&gt; T
{
  T maximum {x[0]};
  for (size_t i {1}; i &lt; len; i++)
    if(maximum &lt; x[i])
      maximum = x[i];
  return maximum;
}</code></pre>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-280" class="calibre3"></a>AN EXAMPLE USING FUNCTIONS</h2>
<p class="calibre13">You have covered a lot of ground in C++ up to now and a lot on functions in this chapter alone. After wading through a varied menu of language capabilities, it’s not always easy to see how they relate to one another. Now would be a good point to see how some of this goes together to produce something with more meat than a simple demonstration program.</p>
<p class="calibre13">Let’s work through a more realistic example to see how a problem can be broken down into functions. The process involves defining the problem to be solved, analyzing the problem to see how it can be implemented in C++, and, finally, writing the code. The approach here is aimed at <span {http://www.idpf.org/2007/ops}type="pagebreak" title="247" id="calibre_link-709" class="calibre14"></span>illustrating how various functions go together to make up the final result, rather than providing a tutorial on how to develop a program.</p>
<section class="toclist">
<h3 class="calibre21">Implementing a Calculator</h3>
<p class="calibre13">Suppose you need a program that acts as a calculator; not one of these fancy devices with lots of buttons and gizmos designed for those who are easily pleased, but one for people who know where they are going, arithmetically speaking. You can really go for it and enter a calculation from the keyboard as a single arithmetic expression, and have the answer displayed immediately. An example of the sort of thing that you might enter is:</p>
<pre class="calibre28"><code class="calibre23">2*3.14159*12.6*12.6 / 2 + 25.2*25.2</code></pre>
<p class="calibre13">To avoid unnecessary complications for the moment, you won’t allow parentheses in the expression and the whole computation must be entered in a single line; however, to allow the user to make the input look attractive, you <i class="calibre15">will</i> allow spaces to be placed anywhere. The expression may contain the operators multiply, divide, add, and subtract represented by <code class="calibre23">*, /, +</code>, and &ndash;, respectively, and it will be evaluated with normal arithmetic rules, so that multiplication and division take precedence over addition and subtraction.</p>
<p class="calibre13">The program should allow as many successive calculations to be performed as required, and should terminate if an empty line is entered. It should also have helpful and friendly error messages.</p>
<section class="toclist">
<h4 class="calibre22">Analyzing the Problem</h4>
<p class="calibre13">A good place to start is with the input. The program reads in an arithmetic expression of any length on a single line, which can be any construction within the terms given. Because nothing is fixed about the elements making up the expression, you have to read it as a string of characters and then work out within the program how it’s made up. You can decide arbitrarily that you will handle a string of up to 80 characters, so you could store it in an array declared within these statements:</p>
<pre class="calibre28"><code class="calibre23">const size_t MAX {80};        // Maximum expression length including '\0'
char buffer[MAX];             // Input area for expression to be evaluated</code></pre>
<p class="calibre13">To change the maximum length of the string processed by the program, you will only need to alter the initial value of <code class="calibre23">MAX</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In Chapter 8 you’ll learn about the</i> <code class="calibre23">string</code> <i class="calibre15">class that enables you to handle strings of any length without having to decide the length in advance.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You’ll need to analyze the basic structure of the information that appears in the input string, so let’s break it down step by step.</p>
<p class="calibre13">You will want to make sure that the input is as uncluttered as possible when you are processing it, so before you start analyzing the input string, you will get rid of any spaces in it. You can call the function that will do this <code class="calibre23">eatspaces()</code>. This function can work by stepping through the input <span {http://www.idpf.org/2007/ops}type="pagebreak" title="248" id="calibre_link-710" class="calibre14"></span>buffer &mdash; which is the array <code class="calibre23">buffer[]</code> &mdash; and shuffling characters up to overwrite any spaces. This process uses two indexes to the buffer array, <code class="calibre23">i</code> and <code class="calibre23">j</code>, which start out at the beginning of the buffer; in general, you’ll store element <code class="calibre23">j</code> at position <code class="calibre23">i</code>. As you progress through the array elements, each time you find a space, you increment <code class="calibre23">j</code> but not <code class="calibre23">i</code>, so the space at position <code class="calibre23">i</code> gets overwritten by the next character you find at index position <code class="calibre23">j</code> that is not a space. <a id="calibre_link-175" href="#calibre_link-174" class="calibre3">Figure 6-2</a> illustrates the logic of this.</p>
<figure class="calibre16">
<img class="center" src="images/000106.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-174" href="#calibre_link-175" class="calibre3">FIGURE 6-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">This process is one of copying the contents of the <code class="calibre23">buffer</code> array to itself, excluding any spaces. <a href="#calibre_link-174" class="calibre3">Figure 6-2</a> shows the <code class="calibre23">buffer</code> array before and after the copying process, and the arrows indicate which characters are copied and the position to which each character is copied.</p>
<p class="calibre13">When you have removed spaces from the input, you are ready to evaluate the expression. You define the <code class="calibre23">expr()</code> function that returns the value that results from evaluating the whole expression in the input buffer. To decide what goes on inside the <code class="calibre23">expr()</code> function, you need to look into the structure of the input in more detail. The add and subtract operators have the lowest precedence and so are evaluated last. You can think of the input string as comprising one or more <i class="calibre15">terms</i> connected by operators, which can be either the operator <code class="calibre23">+</code> or the operator <code class="calibre23">-</code>. You can refer to either operator as an <code class="calibre23">addop</code>. With this terminology, you can represent the general form of the input expression like this:</p>
<pre class="calibre28"><code class="calibre23">expression: term addop term ... addop term</code></pre>
<p class="calibre13">The expression contains at least one <code class="calibre23">term</code> and can have an arbitrary number of following <code class="calibre23">addop term</code> combinations. In fact, assuming that you have removed all the blanks, there are only three legal possibilities for the character that follows each <code class="calibre23">term</code>:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The next character is <code class="calibre23">'\0'</code>, so you are at the end of the string.</li>
<li class="calibre6">The next character is <code class="calibre23">'-'</code>, in which case you should subtract the next <code class="calibre23">term</code> from the value accrued for the expression up to this point.</li>
<li class="calibre6">The next character is <code class="calibre23">'+'</code>, in which case you should add the value of the next <code class="calibre23">term</code> to the value of the expression accumulated so far.</li>
</ul>
<p class="calibre13">If anything else follows a <code class="calibre23">term</code>, the string is not what you expect, so you’ll throw an exception. <a id="calibre_link-177" href="#calibre_link-176" class="calibre3">Figure 6-3</a> illustrates the structure of a sample expression.</p>
<figure class="calibre16">
<img class="center" src="images/000110.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-176" href="#calibre_link-177" class="calibre3">FIGURE 6-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="249" id="calibre_link-711" class="calibre14"></span>Next, you need a more detailed and precise definition of a <code class="calibre23">term</code>. A <code class="calibre23">term</code> is simply a series of numbers connected by either the operator <code class="calibre23">*</code> or the operator <code class="calibre23">/</code>. Therefore, a <code class="calibre23">term</code> (in general) looks like this:</p>
<pre class="calibre28"><code class="calibre23">term: number multop number ... multop number</code></pre>
<p class="calibre13"><code class="calibre23">multop</code> represents either a multiply or a divide operator. You could define a <code class="calibre23">term()</code> function to return the value of a term. This needs to scan the string to a number first and then to look for a <code class="calibre23">multop</code> followed by another number. If a character is found that isn’t a <code class="calibre23">multop</code>, the <code class="calibre23">term()</code> function assumes that it is an <code class="calibre23">addop</code> and returns the value that has been found up to that point.</p>
<p class="calibre13">The last thing you need to figure out before writing the program is how you recognize a number. To minimize the complexity of the code, you’ll only recognize unsigned numbers; therefore, a number consists of a series of digits that optionally may be followed by a decimal point and some more digits. To determine the value of a number, you step through the buffer looking for digits. If you find anything that isn’t a digit, you check whether it’s a decimal point. If it’s not a decimal point, it has nothing to do with a number, so you return what you have got. If you find a decimal point, you look for more digits. As soon as you find anything that’s not a digit, you have the complete number and you return that. Imaginatively, you’ll call the function to recognize a number and return its value <code class="calibre23">number()</code>. <a id="calibre_link-179" href="#calibre_link-178" class="calibre3">Figure 6-4</a> shows an example of how an expression breaks down into terms and numbers.</p>
<figure class="calibre16">
<img class="center" src="images/000104.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-178" href="#calibre_link-179" class="calibre3">FIGURE 6-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="250" id="calibre_link-712" class="calibre14"></span>You now have enough understanding of the problem to write some code. You can work through the functions you need and then write a <code class="calibre23">main()</code> function to tie them all together. The first and, perhaps, easiest function to write is <code class="calibre23">eatspaces()</code>, which will eliminate spaces from the input string.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Eliminating Blanks from a String</h3>
<p class="calibre13">You can write the prototype for the <code class="calibre23">eatspaces()</code> function as follows:</p>
<pre class="calibre28"><code class="calibre23">void eatspaces(char* str);         // Function to eliminate blanks</code></pre>
<p class="calibre13">The function doesn’t need to return any value because spaces can be eliminated from the string <i class="calibre15">in situ</i>, modifying the original string directly through the pointer that is passed as the argument. The process for eliminating spaces is very simple. You copy the string to itself, overwriting any spaces, as you saw earlier in this chapter.</p>
<p class="calibre13">You can define the function to do this as follows:</p>
<pre class="calibre28"><code class="calibre23">// Function to eliminate spaces from a string
void eatspaces(char* str)
{
  size_t i {};                                   // 'Copy to' index to string
  size_t j {};                                   // 'Copy from' index to string
        
  while((*(str + i) = *(str + j++)) != '\0')     // Loop while character is not \0
    if(*(str + i) != ' ')                        // Increment i as long as
      i++;                                       // character is not a space
  return;
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How the Function Functions</h4>
<p class="calibre13">All the action is in the <code class="calibre23">while</code> loop. The loop condition copies the string by moving the character at position <code class="calibre23">j</code> to the character at position <code class="calibre23">i</code>, and then increments <code class="calibre23">j</code> to the next character. If the character copied was <code class="calibre23">'\0'</code>, you have reached the end of the string and you’re done.</p>
<p class="calibre13">The only action in the loop statement is to increment <code class="calibre23">i</code> to the next character if the last character copied was not a blank. If it <i class="calibre15">is</i> a blank, <code class="calibre23">i</code> is not to be incremented and the blank can therefore be overwritten by the character copied on the next iteration.</p>
<p class="calibre13">That wasn’t hard, was it? Next, you can try writing the function that returns the result of evaluating the expression.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Evaluating an Expression</h3>
<p class="calibre13">The <code class="calibre23">expr()</code> function returns the value of the expression specified in a string that is supplied as an argument, so you can write its prototype as:</p>
<pre class="calibre28"><code class="calibre23">double expr(char* str);              // Function evaluating an expression</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="251" id="calibre_link-713" class="calibre14"></span>The function declared here accepts a string as an argument and returns the result as type <code class="calibre23">double</code>. Based on the structure for an expression that you worked out earlier, you can draw a logic diagram for the process of evaluating an expression, as shown in <a id="calibre_link-181" href="#calibre_link-180" class="calibre3">Figure 6-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000038.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-180" href="#calibre_link-181" class="calibre3">FIGURE 6-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="252" id="calibre_link-714" class="calibre14"></span>Using this basic definition of the logic, you can now write the function:</p>
<pre class="calibre28"><code class="calibre23">// Function to evaluate an arithmetic expression
double expr(const char* str)
{
  double value {};                    // Store result here
  int index {};                       // Keeps track of current character position
        
  value = term(str, index);           // Get first term
        
  for(;;)                             // Indefinite loop, all exits inside
  {
    switch(*(str + index++))          // Choose action based on current character
    {
      case '\0':                      // We're at the end of the string
         return value;                // so return what we have got
        
      case '+':                       // + found so add in the
         value += term(str, index);   // next term
         break;
        
      case '-':                       // - found so subtract
         value -= term(str, index);   // the next term
         break;
        
      default:                        // If we reach here the string is junk
         char message[38] {"Expression evaluation error. Found: "}
         strncat_s(message, str + index - 1, 1);  // Append the character
         throw message;
         break;
 
    }
  }
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How the Function Functions</h4>
<p class="calibre13">Considering this function is analyzing any arithmetic expression that you care to throw at it (as long as it uses our operator subset), it’s not a lot of code. You define a variable <code class="calibre23">index</code> of type <code class="calibre23">int</code>, which keeps track of the current position in the string where you are working, and you initialize it to 0, which corresponds to the index position of the first character in the string. You also define a variable <code class="calibre23">value</code> of type <code class="calibre23">double</code> in which you’ll accumulate the value of the expression that is passed to the function in the <code class="calibre23">char</code> array <code class="calibre23">str</code>.</p>
<p class="calibre13">Because an expression must have at least one term, the first action in the function is to get the value of the first term by calling the function <code class="calibre23">term()</code>, which you have yet to write. This actually places three requirements on the function <code class="calibre23">term()</code>:</p>
<ol class="calibre5">
<li class="calibre6">It should accept a <code class="calibre23">char*</code> and an <code class="calibre23">int</code> parameter, the second parameter being an index to the first character of the term in the string supplied through the first parameter.</li>
<li class="calibre6">It should update the index value passed so that it references the string character following the last character of the term found.</li>
<li class="calibre6">It should return the value of the term as type <code class="calibre23">double</code>.</li>
</ol>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="253" id="calibre_link-715" class="calibre14"></span>The rest of the program is an indefinite <code class="calibre23">for</code> loop. Within the loop, the action is determined by a <code class="calibre23">switch</code> statement, which is controlled by the current character in the string. If it is a <code class="calibre23">'+'</code>, you call the <code class="calibre23">term()</code> function to get the value of the next term in the expression and add it to the variable <code class="calibre23">value</code>. If it is a <code class="calibre23">'-'</code>, you subtract the value returned by <code class="calibre23">term()</code> from <code class="calibre23">value</code>. If it is a <code class="calibre23">'\0'</code>, you are at the end of the string, so you return the current contents of <code class="calibre23">value</code> to the calling function. If it is any other character, it shouldn’t be there, so throw an exception. The exception is a string that has the offending character appended.</p>
<p class="calibre13">As long as either a <code class="calibre23">'+'</code> or a <code class="calibre23">'-'</code> is found, the loop continues. Each call to <code class="calibre23">term()</code> moves the value of <code class="calibre23">index</code> to the character following the term that was evaluated, and this should be either another <code class="calibre23">'+'</code> or <code class="calibre23">'-'</code>, or the end-of-string character <code class="calibre23">'\0'</code>. Thus, the function either terminates normally when <code class="calibre23">'\0'</code> is reached, or abnormally by throwing an exception.</p>
<p class="calibre13">You could also analyze an arithmetic expression using a recursive function. If you think about the definition of an expression slightly differently, you could specify it as being either a term, or a term followed by an expression. The definition here is recursive (i.e., the definition involves the item being defined), and this approach is very common in defining programming language structures. This definition provides just as much flexibility as the first, but using it as the base concept, you could arrive at a recursive version of <code class="calibre23">expr()</code> instead of using a loop as you did in the implementation of <code class="calibre23">expr()</code>. You might want to try this alternative approach as an exercise after you have completed the first version.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Getting the Value of a Term</h3>
<p class="calibre13">The <code class="calibre23">term()</code> function returns a value for a term as type <code class="calibre23">double</code> and receives two arguments: the string being analyzed and an index to the current position in the string. There are other ways of doing this, but this arrangement is quite straightforward. The prototype of the function <code class="calibre23">term()</code> is:</p>
<pre class="calibre28"><code class="calibre23">double term(const char* str, size_t&amp; index);        // Function analyzing a term</code></pre>
<p class="calibre13">The second parameter is a reference. This is because you want the function to be able to modify the value of the <code class="calibre23">index</code> variable in the calling program to position it at the character following the last character of the term found in the input string. You could return <code class="calibre23">index</code> as a value, but then you would need to return the value of the term in some other way, so this arrangement seems quite natural.</p>
<p class="calibre13">The logic for analyzing a term is going to be similar to that for an expression. A term is a number, potentially followed by one or more combinations of a multiply or a divide operator and another number. You can write the definition of the <code class="calibre23">term()</code> function as:</p>
<pre class="calibre28"><code class="calibre23">// Function to get the value of a term
double term(const char* str, size_t&amp; index)
{
  double value {};                     // Somewhere to accumulate
                                       // the result
        
  value = number(str, index);          // Get the first number in the term
        
  // Loop as long as we have a good operator
  while(true)
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="254" id="calibre_link-716" class="calibre14"></span>  {
        
    if(*(str + index) == '*')          // If it's multiply,
      value *= number(str, ++index);   // multiply by next number
        
    else if(*(str + index) == '/')     // If it's divide,
      value /= number(str, ++index);   // divide by next number
    else
      break;
  }
  return value;                        // We've finished, so return what
                                       // we've got
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How the Function Functions</h4>
<p class="calibre13">You first declare a local <code class="calibre23">double</code> variable, <code class="calibre23">value</code>, in which you’ll accumulate the value of the current term. Because a term must contain at least one number, the first action is to obtain the value of the first number by calling the <code class="calibre23">number()</code> function and storing the result in <code class="calibre23">value</code>. The code implicitly assumes that <code class="calibre23">number()</code> accepts the string and an index to a position in the string as arguments, and returns the value of the number found. Because the <code class="calibre23">number()</code> function must also update the index to the string to the position after a number is found, you’ll specify the second parameter for the function as a reference.</p>
<p class="calibre13">The rest of the <code class="calibre23">term()</code> function is a <code class="calibre23">while</code> loop that continues as long as the next character is <code class="calibre23">'*'</code> or <code class="calibre23">'/'</code>. Within the loop, if the character found at the current position is <code class="calibre23">'*'</code>, you increment <code class="calibre23">index</code> to position it at the beginning of the next number, call the function <code class="calibre23">number()</code> to get the value of the next number, and then multiply the contents of <code class="calibre23">value</code> by the value returned. In a similar manner, if the current character is <code class="calibre23">'/'</code>, you increment <code class="calibre23">index</code> and divide the contents of <code class="calibre23">value</code> by the value returned from <code class="calibre23">number()</code>. Because <code class="calibre23">number()</code> automatically alters the value of <code class="calibre23">index</code> to the character following the number found, <code class="calibre23">index</code> is already set to select the next available character in the string on the next iteration. The loop terminates when a character other than a multiply or divide operator is found, whereupon the current value of the term accumulated in the variable <code class="calibre23">value</code> is returned to the calling function.</p>
<p class="calibre13">The last analytical function that you require is <code class="calibre23">number()</code>, which determines the numerical value of any number appearing in the string.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Analyzing a Number</h3>
<p class="calibre13">Based on the way you have used <code class="calibre23">number()</code> within the <code class="calibre23">term()</code> function, you need to declare it with this prototype:</p>
<pre class="calibre28"><code class="calibre23">double number(const char* str, size_t&amp; index);   // Function to recognize a number</code></pre>
<p class="calibre13">The specification of the second parameter as a reference allows the function to update the argument in the calling program directly, which is what you require.</p>
<p class="calibre13">You can make use of a function provided by the standard library here. The <code class="calibre23">cctype</code> header file provides definitions for a range of functions for testing single characters. These functions return <span {http://www.idpf.org/2007/ops}type="pagebreak" title="255" id="calibre_link-717" class="calibre14"></span>values of type <code class="calibre23">int</code> where nonzero values correspond to <code class="calibre23">true</code> and zero corresponds to <code class="calibre23">false</code>. Four of these functions are shown in the following table:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTIONS</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int isalpha(int c)</code></td>
<td class="calibre32">Returns nonzero if the argument is alphabetic; otherwise, returns 0</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int isupper(int c)</code></td>
<td class="calibre32">Returns nonzero if the argument is an uppercase letter; otherwise, returns 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int islower(int c)</code></td>
<td class="calibre32">Returns nonzero if the argument is a lowercase letter; otherwise, returns 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int isdigit(int c)</code></td>
<td class="calibre32">Returns nonzero if the argument is a digit; otherwise, returns 0.</td>
</tr>
</tbody>
</table>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A number of other functions are provided by the</i> <code class="calibre23">cctype</code> <i class="calibre15">header but I won’t grind through all the details. If you’re interested, you can look them up in the Visual C++ Help. A search on “is routines” should find them.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You only need the last of the functions shown in the table in the program. Remember that <code class="calibre23">isdigit()</code> is testing a character, such as the character <code class="calibre23">'9'</code> (ASCII character 57 in decimal notation) for instance, not a numeric 9, because the input is a string. You can define the function <code class="calibre23">number()</code> as:</p>
<pre class="calibre28"><code class="calibre23">// Function to recognize a number in a string
double number(const char* str, size_t&amp; index)
{
  double value {};                     // Store the resulting value
        
  <b class="calibre12">// There must be at least one digit...</b>
  <b class="calibre12">if(!isdigit(*(str + index)))</b>
  <b class="calibre12">{ // There</b>'<b class="calibre12">s no digits so input is junk...</b>
    <b class="calibre12">char message[31] {"Invalid character in number: "}</b>
    <b class="calibre12">strncat_s(message, str+index, 1);  // Append the character</b>
    <b class="calibre12">throw message;</b>

  <b class="calibre12">}</b>
        
  while(isdigit(*(str + index)))       // Loop accumulating leading digits
    value = 10*value + (*(str + index++) - '0');
        
                                       // Not a digit when we get to here
  if(*(str + index) != '.')            // so check for decimal point
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="256" id="calibre_link-718" class="calibre14"></span>    return value;                      // and if not, return value
        
  double factor {1.0};                 // Factor for decimal places
  while(isdigit(*(str + (++index))))   // Loop as long as we have digits
  {
    factor *= 0.1;                     // Decrease factor by factor of 10
    value = value + (*(str + index) - '0')*factor;   // Add decimal place
  }
        
  return value;                        // On loop exit we are done
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How the Function Functions</h4>
<p class="calibre13">You declare the local variable <code class="calibre23">value</code> as type <code class="calibre23">double</code> that holds the value of the number that is found. You initialize it with 0.0 because you add in the digit values as you go along. There must always be at least one digit present for the number to be valid, so the first step is to verify that this is the case. If there is no initial digit, the input is badly formed, so you throw an exception that identifies the problem and the erroneous character.</p>
<p class="calibre13">A number in the string is a series of digits as ASCII characters so the function steps through the string accumulating the value of the number digit by digit. This occurs in two phases &mdash; the first phase accumulates digits before the decimal point; then, if you find a decimal point, the second phase accumulates the digits after it.</p>
<p class="calibre13">The first step is in the <code class="calibre23">while</code> loop that continues as long as the current character selected by the variable <code class="calibre23">index</code> is a digit. The value of the digit is extracted and added to the variable <code class="calibre23">value</code> in the loop statement:</p>
<pre class="calibre28"><code class="calibre23">value = 10*value + (*(str + index++) - '0');</code></pre>
<p class="calibre13">The way this is constructed bears a closer examination. A digit character has an ASCII value between 48, corresponding to the digit 0, and 57, corresponding to the digit 9. Thus, if you subtract the ASCII code for <code class="calibre23">'</code>0<code class="calibre23">'</code> from the code for a digit, you convert it to its equivalent numeric digit value from 0 to 9. You have parentheses around the subexpression:</p>
<pre class="calibre28"><code class="calibre23">*(str + index++) - '0'</code></pre>
<p class="calibre13">These are not essential, but they do make what’s going on a little clearer. The contents of <code class="calibre23">value</code> are multiplied by 10 to shift the value one decimal place to the left before adding in the digit value, because you’ll find digits from left to right &mdash; that is, the most significant digit first. This process is illustrated in <a id="calibre_link-183" href="#calibre_link-182" class="calibre3">Figure 6-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000130.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-182" href="#calibre_link-183" class="calibre3">FIGURE 6-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">As soon as you come across something other than a digit, it is either a decimal point or something else. If it’s not a decimal point, you’ve finished, so you return the current contents of <code class="calibre23">value</code> to the calling function. If it is a decimal point, you accumulate the digits corresponding to the fractional part of the number in the second loop. In this loop, you use the <code class="calibre23">factor</code> variable, which has the initial value 1.0, to set the decimal place for the current digit, and, consequently, <code class="calibre23">factor</code> is multiplied by 0.1 for each digit found. Thus, the first digit after the decimal point is multiplied by 0.1, the second by 0.01, the third by 0.001, and so on. This process is illustrated in <a id="calibre_link-185" href="#calibre_link-184" class="calibre3">Figure 6-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000000.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-184" href="#calibre_link-185" class="calibre3">FIGURE 6-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="257" id="calibre_link-719" class="calibre14"></span>As soon as you find a non-digit character, you are done, so after the second loop you return <code class="calibre23">value</code>. You almost have the whole thing now. You just need a <code class="calibre23">main()</code> function to read the input and drive the process.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="258" id="calibre_link-720" class="calibre24"></span>Putting the Program Together</h3>
<p class="calibre13">You can collect the <code class="calibre23">#include</code> statements together and assemble the function prototypes at the beginning of the program for all the functions used in this program:</p>
<pre class="calibre28"><code class="calibre23">// Ex6_10.cpp
// A program to implement a calculator
        
#include &lt;iostream&gt;                            // For stream input/output
#include &lt;cstdlib&gt;                             // For the exit() function
#include &lt;cctype&gt;                              // For the isdigit() function
using std::cin;
using std::cout;
using std::cerr;
using std::endl;
        
void eatspaces(char* str);                     // Function to eliminate blanks
double expr(char* str);                        // Function evaluating an expression
double term(const char* str, size_t&amp; index);   // Function analyzing a term
double number(const char* str, size_t&amp; index);  // Function to recognize a number
        
const size_t MAX {80};                         // Maximum expression length,
                                               // including '\0'</code></pre>
<p class="calibre13">You have also defined a global variable <code class="calibre23">MAX</code>, which is the maximum number of characters in the expression processed by the program (including the terminating <code class="calibre23">'\0'</code> character).</p>
<p class="calibre13">Now, you can add the definition of the <code class="calibre23">main()</code> function, and your program is complete. The <code class="calibre23">main()</code> function should read a string and exit if it is empty; otherwise, call <code class="calibre23">expr()</code> to evaluate the input and display the result. This process should repeat indefinitely. That doesn’t sound too difficult, so let’s give it a try.</p>
<pre class="calibre28"><code class="calibre23">int main()
{
  char buffer[MAX] {};    // Input area for expression to be evaluated
        
  cout &lt;&lt; endl
       &lt;&lt; "Welcome to your friendly calculator."
       &lt;&lt; endl
       &lt;&lt; "Enter an expression, or an empty line to quit."
       &lt;&lt; endl;
        
  for(;;)
 
  {
    cin.getline(buffer, sizeof buffer);        // Read an input line
    eatspaces(buffer);                         // Remove blanks from input
        
    if(!buffer[0])                             // Empty line ends calculator
      return 0;
        
    try
    {
      cout &lt;&lt; "\t= " &lt;&lt; expr(buffer)           // Output value of expression
           &lt;&lt; endl &lt;&lt; endl;
    }
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="259" id="calibre_link-721" class="calibre14"></span>    catch( const char* pEx)
    {
      cerr &lt;&lt; pEx &lt;&lt; endl;
      cerr &lt;&lt; "Ending program." &lt;&lt; endl;
      return 1;
    }
  }
}</code></pre>
<section class="toclist">
<h4 class="calibre22">How the Function Functions</h4>
<p class="calibre13">In <code class="calibre23">main()</code>, you set up the <code class="calibre23">char</code> array, <code class="calibre23">buffer</code>, to accept an expression up to 80 characters long (including the string termination character). The expression is read within the indefinite <code class="calibre23">for</code> loop using the <code class="calibre23">getline()</code> function. After obtaining the input, spaces are removed from the string by calling <code class="calibre23">eatspaces()</code>.</p>
<p class="calibre13">All the other things that <code class="calibre23">main()</code> provides for are also within the loop. It checks for an empty string, which consists of just the null character, <code class="calibre23">'\0'</code>, in which case the program ends. It also outputs the value returned by <code class="calibre23">expr()</code> function. The statement that does this is in a <code class="calibre23">try</code> block, because both <code class="calibre23">expr()</code> and the <code class="calibre23">number()</code> function that it calls indirectly can throw an exception when things go wrong. The exception thrown by both functions is of the same type. The <code class="calibre23">catch</code> block will catch exceptions of type <code class="calibre23">const char*</code> so it will catch an exception thrown by either function. When an exception is thrown, the <code class="calibre23">catch</code> block outputs the string that is the exception and ends the program.</p>
<p class="calibre13">After you add all the function definitions to the code and compile and run it, you should get output similar to the following:</p>
<pre class="calibre28"><code class="calibre23">2 * 35
        = 70
2/3 + 3/4 + 4/5 + 5/6 + 6/7
        = 3.90714
1 + 2.5 + 2.5*2.5 + 2.5*2.5*2.5
        = 25.375</code></pre>
<p class="calibre13">You can enter as many calculations as you like, and when you are fed up with it, just press Enter to end the program. If you want to see the error handling in action, just enter an invalid expression.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Extending the Program</h3>
<p class="calibre13">Now that you have got a working calculator, you can start to think about extending it. Wouldn’t it be nice to be able to handle parentheses in an expression? It can’t be that difficult, can it? Let’s give it a try.</p>
<p class="calibre13">Think about the relationship between something in parentheses that might appear in an expression and the kind of expression analysis that you have made so far. Look at an example of the kind of expression you want to handle:</p>
<pre class="calibre28"><code class="calibre23">2*(3 + 4) / 6 - (5 + 6) / (7 + 8)
</code></pre>
<p class="calibre13">Notice that an expression between parentheses always forms part of a <code class="calibre23">term</code> in our original parlance. Whatever sort of computation you come up with, this is always true. In fact, if you could substitute <span {http://www.idpf.org/2007/ops}type="pagebreak" title="260" id="calibre_link-722" class="calibre14"></span>the value of the expressions within parentheses back into the original string, you would have something that you can already deal with. This indicates a possible approach to handling parentheses. You might be able to treat an expression in parentheses as just another number, and modify the <code class="calibre23">number()</code> function to sort out the value of whatever appears between the parentheses.</p>
<p class="calibre13">That sounds like a good idea, but “sorting out” the expression in parentheses requires a bit of thought: the clue to success is in the terminology used here. An expression that appears within parentheses is a perfectly good example of a full-blown expression, and you already have the <code class="calibre23">expr()</code> function that will return the value of an expression. If you can get the <code class="calibre23">number()</code> function to work out what lies between the parentheses and extract those from the string, you could pass the substring to the <code class="calibre23">expr()</code> function, and recursion would really simplify the problem. What’s more, you don’t need to worry about nested parentheses. Any set of parentheses contains what you have defined as an expression, so nested parentheses are taken care of automatically. Recursion wins again.</p>
<p class="calibre13">Let’s take a stab at rewriting <code class="calibre23">number()</code> to recognize an expression between parentheses:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Function to recognize an expression in parentheses</b>
<b class="calibre12">// or a number in a string</b>
double number(const char* str, size_t&amp; index)
{
  double value {};                     // Store the resulting value
        
  <b class="calibre12">if(*(str + index) ==</b> '<b class="calibre12">(</b>'<b class="calibre12">)            // Start of parentheses</b>
  <b class="calibre12">{</b>
    <b class="calibre12">char* psubstr {};                  // Pointer for substring</b>
    <b class="calibre12">psubstr = extract(str, ++index);   // Extract substring in brackets</b>
    <b class="calibre12">value = expr(psubstr);             // Get the value of the substring</b>
    <b class="calibre12">delete[]psubstr;                   // Clean up the free store</b>
    <b class="calibre12">return value;                      // Return substring value</b>
  <b class="calibre12">}</b>
        
  // There must be at least one digit...
  if(!isdigit(*(str + index)))
  { // There's no digits so input is junk...
    char message[31] {"Invalid character in number: "}
    strncat_s(message, str+index, 1);  // Append the character
    throw message;
 
  }
        
  while(isdigit(*(str + index)))       // Loop accumulating leading digits
    value = 10*value + (*(str + index++) - '0');
                                       // Not a digit when we get to here
  if(*(str + index)!= '.')             // so check for decimal point
    return value;                      // and if not, return value
      
  double factor{1.0};                  // Factor for decimal places
  while(isdigit(*(str + (++index))))   // Loop as long as we have digits
  {
    factor *= 0.1;                     // Decrease factor by factor of 10
    value = value + (*(str + index) - '0')*factor;  // Add decimal place
  }
  return value;                        // On loop exit we are done
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="261" id="calibre_link-723" class="calibre14"></span>This is not yet complete, because you still need the <code class="calibre23">extract()</code> function, but you’ll fix that in a moment.</p>
<section class="toclist">
<h4 class="calibre22">How the Function Functions</h4>
<p class="calibre13">Very little has been changed to support parentheses. I suppose it is a bit of a cheat, because you use the <code class="calibre23">extract()</code> function that you haven’t written yet, but for one extra function, you get as many levels of nested parentheses as you want. This really is icing on the cake, and it’s all down to the magic of recursion!</p>
<p class="calibre13">The first thing that <code class="calibre23">number()</code> does now is to test for a left parenthesis. If it finds one, it calls another function, <code class="calibre23">extract()</code> to extract the substring between the parentheses from the original string. The address of this new substring is stored in the pointer <code class="calibre23">psubstr</code>, so you then apply the <code class="calibre23">expr()</code> function to the substring by passing this pointer as an argument. The result is stored in <code class="calibre23">value</code>, and after releasing the memory allocated on the free store in the <code class="calibre23">extract()</code> function (as you will eventually implement it), you return the value obtained for the substring as though it were a regular number. Of course, if there is no left parenthesis to start with, the function <code class="calibre23">number()</code> continues exactly as before.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Extracting a Substring</h3>
<p class="calibre13">You now need to write the <code class="calibre23">extract()</code> function. It’s not difficult, but it’s also not trivial. The main complication comes from the fact that the expression within parentheses may also contain other sets of parentheses, so you can’t just go looking for the first right parenthesis after you find a left parenthesis. You must watch out for more left parentheses as well, and for every one that you find, ignore the corresponding right parenthesis. You can do this by maintaining a count of left parentheses as you go along, adding one to the count for each left parenthesis you find. If the left parenthesis count is not zero, you subtract one for each right parenthesis. Of course, if the left parenthesis count is zero and you find a right parenthesis, you’re at the end of the substring. The mechanism for extracting a parenthesized substring is illustrated in <a id="calibre_link-187" href="#calibre_link-186" class="calibre3">Figure 6-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000165.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-186" href="#calibre_link-187" class="calibre3">FIGURE 6-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="262" id="calibre_link-724" class="calibre14"></span>Because the string you extract here contains subexpressions between parentheses, eventually <code class="calibre23">extract()</code> is called again to deal with those.</p>
<p class="calibre13">The <code class="calibre23">extract()</code> function also needs to allocate memory for the substring and return a pointer to it. Of course, the index to the current position in the original string must end up selecting the character following the substring, so the parameter for that should be specified as a reference. Thus the prototype of <code class="calibre23">extract()</code> is:</p>
<pre class="calibre28"><code class="calibre23">char* extract(const char* str, size_t&amp; index); //Function to extract a substring</code></pre>
<p class="calibre13">You can now have a shot at the definition of the function:</p>
<pre class="calibre28"><code class="calibre23">// Function to extract a substring between parentheses
// (requires cstring header file)
char* extract(const char* str, size_t&amp; index)
{
  char* pstr {};                       // Pointer to new string for return
  size_t numL {};                      // Count of left parentheses found
  size_t bufindex {index};             // Save starting value for index
 
  do
  {
    switch(*(str + index))
    {
      case ')':
        if(0 == numL)
        {
          ++index;
          pstr = new char[index - bufindex];
          if(!pstr)
          {
            throw "Memory allocation failed.";
          }
          // Copy substring to new memory
          strncpy_s(pstr, index-bufindex, str+bufindex, index-bufindex-1); 
 
          return pstr;                 // Return substring in new memory
        }
        else
          numL--;                      // Reduce count of '(' to be matched
          break;
 
      case '(':
        numL++;                        // Increase count of '(' to be 
                                       // matched
        break;
      }
  } while(*(str + index++) != '\0');   // Loop - don't overrun end of string
 
  throw "Ran off the end of the expression, must be bad input.";
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="263" id="calibre_link-725" class="calibre14"></span>How the Function Functions</h4>
<p class="calibre13">You declare a pointer to a string, <code class="calibre23">pstr</code>, that will eventually point to the substring that you will return. You declare a counter <code class="calibre23">numL</code> to keep track of left parentheses in the substring. The initial value of <code class="calibre23">index</code> (when the function begins execution) is stored in the variable <code class="calibre23">bufindex</code>. You use this in combination with incremented values of <code class="calibre23">index</code> to determine the range of characters to be extracted from <code class="calibre23">str</code> and returned.</p>
<p class="calibre13">The executable part of the function is basically one big <code class="calibre23">do-while</code> loop that walks through <code class="calibre23">str</code> looking for parentheses. You check for left or right parentheses during each cycle. If a left parenthesis is found, <code class="calibre23">numL</code> is incremented, and if a right parenthesis is found and <code class="calibre23">numL</code> is non-zero, it is decremented. When you find a right parenthesis and <code class="calibre23">numL</code> is zero, you have found the end of the substring. Sufficient memory is obtained on the heap to hold the substring and the address is stored in <code class="calibre23">pstr</code>. The substring that you want from <code class="calibre23">str</code> is then copied to the memory that you obtained through the operator <code class="calibre23">new</code> by using the <code class="calibre23">strncpy_s()</code> function that is declared in the <code class="calibre23">cstring</code> header. This function copies the string specified by the third argument, <code class="calibre23">str+bufindex</code>, to the address specified by the first argument, <code class="calibre23">pstr. str+bufindex</code> is a pointer to the character in <code class="calibre23">str</code> where the substring starts. The second argument is the length of the destination string, <code class="calibre23">pstr</code> and the fourth argument is the number of characters to be copied from the source string.</p>
<p class="calibre13">If you fall through the bottom of the loop, it means that you hit the <code class="calibre23">'\0'</code> at the end of the expression in <code class="calibre23">str</code> without finding the complementary right parenthesis, so you throw an exception that will be caught in <code class="calibre23">main()</code>.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Running the Modified Program</h3>
<p class="calibre13">After replacing the <code class="calibre23">number()</code> function in the old version of the program, adding the <code class="calibre23">#include</code> directive for <code class="calibre23">cstring</code>, and incorporating the prototype and the definition for the new <code class="calibre23">extract()</code> function you have just written, you’re ready to roll with an all-singing, all-dancing calculator. If you have assembled all that without error, you can get output like this:</p>
<pre class="calibre28"><code class="calibre23">Welcome to your friendly calculator.
Enter an expression, or an empty line to quit.
1/(1+1/(1+1/(1+1)))
        = 0.6
(1/2-1/3)*(1/3-1/4)*(1/4-1/5)
        = 0.000694444
3.5*(1.25-3/(1.333-2.1*1.6))-1
        = 8.55507
2,4-3.4
Expression evaluation error. Found:, Ending program.</code></pre>
<p class="calibre13">The friendly and informative error message in the last output line is due to the use of the comma instead of the decimal point in the expression above it, in what should be 2.4. As you can see, you get nested parentheses to any depth with a relatively simple extension of the program, all due to the amazing power of recursion.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-281" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="264" id="calibre_link-726" class="calibre18"></span>SUMMARY</h2>
<p class="calibre13">You now have a reasonably comprehensive knowledge of writing and using functions, and you have used overloading to implement a set of functions providing the same operation with different types of parameters. You have also seen how you can define function templates that you can use to generate different versions of essentially the same function. You’ll see more about overloading functions in the following chapters.</p>
<p class="calibre13">You also got some experience of using several functions in a program by working through the calculator example. But remember that all the uses of functions up to now have been in the context of a traditional procedural approach to programming. When you come to look at object-oriented programming, you will still use functions extensively, but with a very different approach to program structure and to the design of the solution to a problem.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Consider the following function:
<pre class="calibre28"><code class="calibre23">  int ascVal(size_t i, const char* p)
  {
     // Return the ASCII value of the char 
     if (!p || i &gt; strlen(p))
        return -1;
     else
        return p[i];
  }</code></pre>
<ol class="none">
<li class="calibre6">Write a program that will call this function through a pointer and verify that it works. You’ll need an <code class="calibre23">#include</code> directive for the <code class="calibre23">cstring</code> header in your program to use the <code class="calibre23">strlen()</code> function.</li>
</ol></li>
<li class="calibre6">Write a family of overloaded functions called <code class="calibre23">equal()</code>, which take two arguments of the same type, returning 1 if the arguments are equal, and 0 otherwise. Provide versions having <code class="calibre23">char, int, double</code>, and <code class="calibre23">char*</code> arguments. (Use the <code class="calibre23">strcmp()</code> function from the runtime library to test for equality of strings. If you don’t know how to use <code class="calibre23">strcmp()</code>, search for it in the online help. You’ll need an <code class="calibre23">#include</code> directive for the <code class="calibre23">cstring</code> header file in your program.) Write test code to verify that the correct versions are called.</li>
<li class="calibre6">At present, when the calculator hits an invalid input character, it prints an error message, but doesn’t show you where the error was in the line. Write an error routine that prints out the input string, putting a caret (<code class="calibre23">^</code>) below the offending character, like this:
<pre class="calibre28"><code class="calibre23">  12 + 4,2*3
        ^</code></pre></li>
<li class="calibre6">Add an exponentiation operator, <code class="calibre23">^</code>, to the calculator, fitting it in alongside <code class="calibre23">*</code> and <code class="calibre23">/</code>. What are the limitations of implementing it in this way, and how can you overcome them?</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="265" id="calibre_link-727" class="calibre14"></span>(Advanced) Extend the calculator so it can handle trig and other math functions, allowing you to input expressions such as:
<pre class="calibre28"><code class="calibre23"> 2 * sin(0.6)</code></pre>
<ol class="none">
<li class="calibre6">The math library functions all work in radians; provide versions of the trigonometric functions so that the user can use degrees, for example:</li>
</ol>
<pre class="calibre28"><code class="calibre23"> 2 * sind(30)</code></pre></li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="266" id="calibre_link-728" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Pointers to functions</b></td>
<td class="calibre32">A pointer to a function stores the address of a function, plus information about the number and types of parameters and return type for a function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Exceptions</b></td>
<td class="calibre32">An exception is a way of signaling an error in a program so that the error handling code can be separated from the code for normal operations.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Throwing exceptions</b></td>
<td class="calibre32">You throw an exception with a statement that uses the keyword <code class="calibre23">throw</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12"><code class="calibre23">try</code> blocks</b></td>
<td class="calibre32">Code that may throw exceptions should be placed in a <code class="calibre23">try</code> block, and the code to handle a particular type of exception is placed in a <code class="calibre23">catch</code> block immediately following the <code class="calibre23">try</code> block. There can be several <code class="calibre23">catch</code> blocks following a <code class="calibre23">try</code> block, each catching a different type of exception.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Overloaded functions</b></td>
<td class="calibre32">Overloaded functions are functions with the same name, but with different parameter lists.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Calling an overloaded function</b></td>
<td class="calibre32">When you call an overloaded function, the function to be called is selected by the compiler based on the number and types of the arguments that you specify.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Function templates</b></td>
<td class="calibre32">A function template is a recipe for generating overloaded functions automatically.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Function template parameters</b></td>
<td class="calibre32">A function template has one or more parameters that are type variables. An instance of the function template &mdash; that is, a function definition &mdash; is created by the compiler for each function call that corresponds to a unique set of type arguments for the template.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Function template instances</b></td>
<td class="calibre32">You can force the compiler to create a particular instance from a function template by specifying the function you want in a prototype declaration.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">decltype</code> operator</b></td>
<td class="calibre32">You use the <code class="calibre23">decltype</code> operator to determine the type of the result of an expression.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Trailing return types</b></td>
<td class="calibre32">When a function template has a return type that depends on the arguments types, you can specify the return type using the <code class="calibre23">auto</code> keyword and define the return type using the <code class="calibre23">decltype</code> operator following <code class="calibre23">-&gt;</code> after the function header.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-282">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2320" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="267" id="calibre_link-729" class="calibre9"></span><span class="chapternumber">Chapter 7</span><br class="calibre10" /><span class="chapternumber">Defining Your Own Data Types</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How structures are used</li>
<li class="calibre6">How classes are used</li>
<li class="calibre6">The basic components of a class and how you define class types</li>
<li class="calibre6">How to create and use objects of a class</li>
<li class="calibre6">How to control access to members of a class</li>
<li class="calibre6">How to create constructors</li>
<li class="calibre6">The default constructor</li>
<li class="calibre6">References in the context of classes</li>
<li class="calibre6">How to implement the copy constructor</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 7 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-283" class="calibre3"></a>THE STRUCT IN C++</h2>
<p class="calibre13">This chapter is about creating your own data types to suit your particular problem. It’s also about creating objects, the building blocks of object-oriented programming. An object can seem a bit mysterious at first, but as you’ll see in this chapter, an object can be just an instance of one of your own data types.</p>
<p class="calibre13">A structure is a user-defined type that you define using the <code class="calibre23">struct</code> keyword so it is often referred to as a <i class="calibre15">struct</i>. The <code class="calibre23">struct</code> originated back in C and C++ incorporates and expands on the C <code class="calibre23">struct</code>. A <code class="calibre23">struct</code> in C++ is functionally replaceable by a class insofar as anything you <span {http://www.idpf.org/2007/ops}type="pagebreak" title="268" id="calibre_link-730" class="calibre14"></span>can do with a <code class="calibre23">struct</code>, you can also achieve by using a class. However, because Windows was written in C before C++ became widely used, the <code class="calibre23">struct</code> appears pervasively in Windows programming. It is also used today, so you really need to know something about structs. You’ll first look at structs before exploring the more extensive capabilities offered by classes.</p>
<section class="toclist">
<h3 class="calibre21">What Is a struct?</h3>
<p class="calibre13">Almost all the variables that you have seen up to now have been able to store a single type of entity &mdash; a number of some kind, a character, or an array of elements of the same type. The real world is a bit more complicated than that, and just about any physical object you can think of needs several items of data to describe it even minimally. Think about the information that might be needed to describe something as simple as a book. You might consider title, author, publisher, date of publication, number of pages, price, topic or classification, and ISBN number, just for starters, and you can probably come up with a few more without too much difficulty. You could specify separate variables to contain each of the parameters that you need to describe a book, but ideally, you would have a single data type, <code class="calibre23">Book</code>, say, which embodied all of the things that you need to describe a book. I’m sure you won’t be surprised to hear that this is exactly what a <code class="calibre23">struct</code> can do for you.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Defining a struct</h3>
<p class="calibre13">Let’s stick with the notion of a book, and suppose that you just want to include the title, author, publisher, and year of publication within your definition of a book. You could define a structure to accommodate this as follows:</p>
<pre class="calibre28"><code class="calibre23">struct Book
{
  char title[80];
  char author[80];
  char publisher[80];
  int year;
};</code></pre>
<p class="calibre13">This doesn’t define any variables, but it does define a new type, and the name of the type is <code class="calibre23">Book</code>. The <code class="calibre23">struct</code> keyword defines <code class="calibre23">Book</code> as a structure, and the elements making up an object of this type are defined within the braces. Note that each line defining an element in the <code class="calibre23">struct</code> is terminated by a semicolon, and that a semicolon also appears after the closing brace. The elements of a <code class="calibre23">struct</code> can be of any type, except the same type as the <code class="calibre23">struct</code> being defined. You couldn’t have an element of type <code class="calibre23">Book</code> included in the structure definition for <code class="calibre23">Book</code>, for example. You may think this is a limitation, but note that you could include a pointer of type <code class="calibre23">Book*</code>, as you’ll see a little later on.</p>
<p class="calibre13">The elements <code class="calibre23">title, author, publisher</code>, and <code class="calibre23">year</code> enclosed between the braces in the preceding definition are referred to as <i class="calibre15">members</i> or <i class="calibre15">fields</i> of the <code class="calibre23">Book</code> structure. A <code class="calibre23">Book</code> object is called an <i class="calibre15">instance</i> of the type. Every object of type <code class="calibre23">Book</code> contains its own set of the members <code class="calibre23">title, author, publisher</code>, and <code class="calibre23">year</code>. You can now create variables of type <code class="calibre23">Book</code> in exactly the same way as you create variables of any other type:</p>
<pre class="calibre28"><code class="calibre23">Book novel;                            // Declare variable novel of type Book</code></pre>
<p class="calibre13">This defines a variable with the name <code class="calibre23">novel</code> that you can now use to store information about a book. All you need now is to understand how you get data into the members that make up a variable of type <code class="calibre23">Book</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="269" id="calibre_link-731" class="calibre24"></span>Initializing a struct</h3>
<p class="calibre13">The first way to get data into members of a <code class="calibre23">struct</code> object is to define initial values for them in the definition of the object. Suppose you wanted to initialize <code class="calibre23">novel</code> to contain the data for one of your favorite books, <i class="calibre15">Paneless Programming</i>, published in 1981 by the Gutter Press. This is a story of a guy performing heroic code development while living in an igloo, and, as you probably know, inspired the famous Hollywood box office success, <i class="calibre15">Gone with the Window</i>. It was written by I.C. Fingers, who is also the author of that seminal three-volume work, <i class="calibre15">The Connoisseur’s Guide to the Paper Clip</i>. With this wealth of information, you can write the definition for <code class="calibre23">novel</code> as:</p>
<pre class="calibre28"><code class="calibre23">Book novel
{
 "Paneless Programming",              // Initial value for title
 "I.C. Fingers",                      // Initial value for author
 "Gutter Press",                      // Initial value for publisher
  1981                                // Initial value for year
};</code></pre>
<p class="calibre13">The initializing values appear in an initializer list in much the same way as for elements of an array. As with arrays, the sequence of initial values needs to be the same as the sequence of the members of the <code class="calibre23">struct</code> in its definition. Each member of the <code class="calibre23">novel</code> structure has the corresponding initial value assigned to it, as indicated in the comments.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Accessing the Members of a struct</h3>
<p class="calibre13">To access individual members of a <code class="calibre23">struct</code>, you use the <i class="calibre15">member selection operator</i>, which is a period; this is sometimes referred to as the <i class="calibre15">member access operator</i>. To refer to a member, you write the <code class="calibre23">struct</code> variable name, followed by a period, followed by the name of the member. To change the <code class="calibre23">year</code> member of the <code class="calibre23">novel</code> structure, you could write:</p>
<pre class="calibre28"><code class="calibre23">novel.year = 1988;</code></pre>
<p class="calibre13">This sets the value of the <code class="calibre23">year</code> member to 1988. You can use a member of a struct in exactly the same way as any other variable. To increment the member <code class="calibre23">year</code> by two, for example, you can write:</p>
<pre class="calibre28"><code class="calibre23">novel.year += 2;</code></pre>
<p class="calibre13">This increments the value of the <code class="calibre23">year</code> member of <code class="calibre23">novel</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using structs</h3>
<p class="calibre20">This example shows how referencing the members of a <code class="calibre23">struct</code> works. Suppose you want to write a program to deal with some of the things you might find in a yard, such as those illustrated in the professionally landscaped yard in <a id="calibre_link-1373" href="#calibre_link-23" class="calibre3">Figure 7-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000075.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-23" href="#calibre_link-1373" class="calibre3">FIGURE 7-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">I have arbitrarily assigned the coordinates 0,0 to the top-left corner of the yard. The bottom-right corner has the coordinates 100,120. Thus, the first coordinate value is a measure of the horizontal position relative to the top-left corner, with values increasing from left to right, and the second coordinate is a measure of the vertical position from the same reference point, with values increasing from top to bottom. <a href="#calibre_link-23" class="calibre3">Figure 7-1</a> also shows the position of the pool and those of the two huts relative to the top-left corner of the yard. Because the yard, huts, and pool are all rectangular, you could define a <code class="calibre23">struct</code> type to represent any of these:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="270" id="calibre_link-732" class="calibre14"></span>struct Rectangle
{
  int left;                            // Top-left point
  int top;                             // coordinate pair
        
  int right;                           // Bottom-right point
  int bottom;                          // coordinate pair
};</code></pre>
<p class="calibre20">The first two members of the <code class="calibre23">Rectangle</code> structure type correspond to the coordinates of the top-left point of a rectangle, and the next two to the coordinates of the bottom-right point. You can use this in an elementary example representing rectangular objects in the yard:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_01.cpp
// Exercising structures in the yard
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
// Definition of a struct to represent rectangles
struct Rectangle
{
  int left;                            // Top-left point
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="271" id="calibre_link-733" class="calibre14"></span>int top;                             // coordinate pair
        
  int right;                           // Bottom-right point
  int bottom;                          // coordinate pair
};
        
// Prototype of function to calculate the area of a rectangle
long area(const Rectangle&amp; aRect);
        
// Prototype of a function to move a rectangle
void moveRect(Rectangle&amp; aRect, const int x, const int y);
        
int main()
{
  Rectangle yard { 0, 0, 100, 120 };
  Rectangle pool { 30, 40, 70, 80 };
  Rectangle hut1, hut2;
 
        
  hut1.left = 70;
  hut1.top = 10;
  hut1.right = hut1.left + 25;
  hut1.bottom = 30;
        
  hut2 = hut1;                         // Define hut2 the same as hut1
  moveRect(hut2, 10, 90);              // Now move it to the right position
        
  cout &lt;&lt; "Coordinates of hut2 are "
       &lt;&lt; hut2.left &lt;&lt; "," &lt;&lt; hut2.top &lt;&lt; " and "
       &lt;&lt; hut2.right &lt;&lt; "," &lt;&lt; hut2.bottom &lt;&lt; endl;
        
  cout &lt;&lt; "The area of the yard is " &lt;&lt; area(yard) &lt;&lt; endl;
        
  cout &lt;&lt; "The area of the pool is " &lt;&lt; area(pool) &lt;&lt; endl;
        
  return 0;
}
        
// Function to calculate the area of a rectangle
long area(const Rectangle&amp; aRect)
{
  return (aRect.right - aRect.left)*(aRect.bottom - aRect.top);
}
        
// Function to Move a Rectangle
void moveRect(Rectangle&amp; aRect, const int x, const int y)
{
  const int length {aRect.right - aRect.left}; // Get length of rectangle
  const int width {aRect.bottom - aRect.top};  // Get width of rectangle
        
  aRect.left = x;                              // Set top-left point
  aRect.top = y;                               // to new position
  aRect.right = x + length;                    // Get bottom-right point as
  aRect.bottom = y + width;                    // increment from new position
  return;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="272" id="calibre_link-734" class="calibre14"></span>The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">Coordinates of hut2 are 10,90 and 35,110
The area of the yard is 12000
The area of the pool is 1600</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Note that the <code class="calibre23">struct</code> definition appears at global scope in this example. You’ll be able to see it in the Class View tab for the project. Putting the definition of the <code class="calibre23">struct</code> at global scope allows you to define a variable of type <code class="calibre23">Rectangle</code> anywhere in the <code class="calibre23">.cpp</code> file. In a larger program, such definitions would be stored in an <code class="calibre23">.h</code> file that would be added to each <code class="calibre23">.cpp</code> file where necessary, using an <code class="calibre23">#include</code> directive.</p>
<p class="calibre20">You have defined two functions to process <code class="calibre23">Rectangle</code> objects. The <code class="calibre23">area()</code> function calculates the area of the <code class="calibre23">Rectangle</code> object that you pass as a reference argument as the product of the length and the width, where the length is the difference between the horizontal positions of the defining points, and the width is the difference between the vertical positions of the defining points. The parameter is <code class="calibre23">const</code> because the function does not change the argument that is passed to it. By passing a reference, the code runs a little faster because the argument is not copied. The <code class="calibre23">MoveRect()</code> function modifies the defining points of a <code class="calibre23">Rectangle</code> object to position it at the coordinates <code class="calibre23">x, y,</code> which are passed as arguments.</p>
<p class="calibre20">The position of a <code class="calibre23">Rectangle</code> object is assumed to be the position of the <code class="calibre23">left, top</code> point. Because the <code class="calibre23">Rectangle</code> object is passed as a reference, the function can modify the members of the <code class="calibre23">Rectangle</code> object directly. After calculating the length and width of the <code class="calibre23">Rectangle</code> object passed, the <code class="calibre23">left</code> and <code class="calibre23">top</code> members are set to <code class="calibre23">x</code> and <code class="calibre23">y</code>, respectively, and the new <code class="calibre23">right</code> and <code class="calibre23">bottom</code> members are calculated by incrementing <code class="calibre23">x</code> and <code class="calibre23">y</code> by the length and width of the original <code class="calibre23">Rectangle</code> object.</p>
<p class="calibre20">In the <code class="calibre23">main()</code> function, you initialize the <code class="calibre23">yard</code> and <code class="calibre23">pool</code> variables with their coordinate positions, as shown in <a href="#calibre_link-23" class="calibre3">Figure 7-1</a>. The <code class="calibre23">hut1</code> variable represents the hut at the top-right in the illustration, and its members are set to the appropriate values using assignment statements. The <code class="calibre23">hut2</code> variable, corresponding to the hut at the bottom-left of the yard, is first set to be the same as <code class="calibre23">hut1</code> in the assignment statement:</p>
<pre class="calibre28"><code class="calibre23">hut2 = hut1;                           // Define Hut2 the same as Hut1</code></pre>
<p class="calibre20">This copies the values of the members of <code class="calibre23">hut1</code> to the corresponding members of <code class="calibre23">hut2</code>. You can only assign a <code class="calibre23">struct</code> of a given type to another of the same type. You can’t increment a <code class="calibre23">struct</code> directly or use a <code class="calibre23">struct</code> in an arithmetic expression.</p>
<p class="calibre20">To alter the position of <code class="calibre23">hut2</code> to its place at the bottom-left of the yard, you call the <code class="calibre23">moveRect()</code> function with the coordinates of the required position as arguments. This roundabout way of getting the coordinates of <code class="calibre23">hut2</code> is totally unnecessary, and serves only to show how you can use a <code class="calibre23">struct</code> as an argument to a function.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">IntelliSense Assistance with Structures</h3>
<p class="calibre13">The editor in Visual C++ is quite intelligent &mdash; it knows the types of variables, for instance. This is because of the IntelliSense feature. If you hover the mouse cursor over a variable name in the editor window, it pops up a little box showing its type. It also can help a lot with structures (and classes, as you will see) because not only does it know the types of ordinary variables, it also knows the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="273" id="calibre_link-735" class="calibre14"></span>members that belong to a variable of a particular structure type. As you type the member selection operator following a structure variable name, the editor pops up a window showing the list of members. If you click one of the members, it shows the member definition including the comment that appeared in the original definition of the structure, so you know what it is. This is shown in <a id="calibre_link-1374" href="#calibre_link-405" class="calibre3">Figure 7-2</a>, using a fragment of the previous example.</p>
<figure class="calibre16">
<img class="center" src="images/000117.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-405" href="#calibre_link-1374" class="calibre3">FIGURE 7-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">There’s a real incentive to add comments, and to keep them short and to the point. If you double-click on a member in the list or press the Enter key when the item is highlighted, it is automatically inserted after the member selection operator, thus eliminating one source of typos in your code. Great, isn’t it?</p>
<p class="calibre13">You can turn any or all of the IntelliSense features off. To turn the IntelliSense features on or off, first select Options from the Tools menu. Expand the Text Editor tree in the left pane of the dialog that displays by clicking the [unfilled] symbol, then click the unfilled symbol alongside C/C++. Click the Advanced option and you will see the IntelliSense options displayed in the right pane. Setting an option to false turns it off.</p>
<p class="calibre13">The editor also shows the parameter list for a function when you are typing the code to call it &mdash; it pops up as soon as you enter the left parenthesis for the argument list. This is particularly helpful with library functions, as it’s tough to remember the parameter list for all of them. Of course, the <code class="calibre23">#include</code> directive for the header file must already be there in the source code for this to work. Without it, the editor has no idea what the library function is. Also, if you omit the <code class="calibre23">std</code> namespace prefix when you have also failed to include a <code class="calibre23">using</code> statement for a library function, the editor won’t recognize the function. You will see more things that the editor can help with as you learn more about classes. After that interesting little diversion, let’s get back to structures.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="274" id="calibre_link-736" class="calibre24"></span>The RECT Structure</h3>
<p class="calibre13">Rectangles are used a great deal in Windows programs. For this reason, there is a <code class="calibre23">RECT</code> structure predefined in the <code class="calibre23">windef.h</code> header file that is included in <code class="calibre23">windows.h</code>. Its definition is essentially the same as the structure that you defined in the last example:</p>
<pre class="calibre28"><code class="calibre23">struct RECT
{
  LONG left;                            // Top-left point
  LONG top;                             // coordinate pair
        
  LONG right;                           // Bottom-right point
  LONG bottom;                          // coordinate pair
};</code></pre>
<p class="calibre13">Type <code class="calibre23">LONG</code> is a Windows type that is equivalent to the fundamental type <code class="calibre23">long</code>. This <code class="calibre23">struct</code> is usually used to define rectangular areas on your display for a variety of purposes. Because <code class="calibre23">RECT</code> is used so extensively, <code class="calibre23">windows.h</code> also contains prototypes for a number of functions to manipulate and modify rectangles. For example, it defines the <code class="calibre23">InflateRect()</code> function that increases the size of a rectangle, and the <code class="calibre23">EqualRect()</code> function that compares two rectangles.</p>
<p class="calibre13">The MFC defines a <code class="calibre23">CRect</code> class that is the equivalent of a <code class="calibre23">RECT</code> structure. After you understand classes, you will be using this rather than the <code class="calibre23">RECT</code> structure. The <code class="calibre23">CRect</code> class provides an extensive range of functions for manipulating rectangles, and you’ll use many of these when you are writing Windows programs using the MFC.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using Pointers with a struct</h3>
<p class="calibre13">You can create a pointer to an object of a structure type. Many of the functions defined in <code class="calibre23">windows.h</code> that work with <code class="calibre23">RECT</code> objects require pointers to a <code class="calibre23">RECT</code> object as arguments, because this avoids the copying of the structure when a function is called. To define a pointer to a <code class="calibre23">RECT</code> object, the definition is what you might expect:</p>
<pre class="calibre28"><code class="calibre23">RECT* pRect {};                  // Define a pointer to a RECT</code></pre>
<p class="calibre13">Assuming that you have defined a <code class="calibre23">RECT</code> object, <code class="calibre23">aRect</code>, you can set the pointer to the address of this variable in the normal way:</p>
<pre class="calibre28"><code class="calibre23">pRect = &amp;aRect;                        // Set pointer to the address of aRect</code></pre>
<p class="calibre13">As you saw when I introduced the idea of a <code class="calibre23">struct</code>, a <code class="calibre23">struct</code> can’t contain a member of the same type as the <code class="calibre23">struct</code> being defined, but it can contain a pointer to a <code class="calibre23">struct</code>, including a pointer to a <code class="calibre23">struct</code> of the same type. For example, you could define a structure like this:</p>
<pre class="calibre28"><code class="calibre23">struct ListElement
{
  RECT aRect;                          // RECT member of structure
  ListElement* pNext;                  // Pointer to a list element
};</code></pre>
<p class="calibre13">The first member of the <code class="calibre23">ListElement</code> structure is of type <code class="calibre23">RECT</code>, and the second member is a pointer to a structure of type <code class="calibre23">ListElement</code> &mdash; the same type as that being defined. This allows objects of type <code class="calibre23">ListElement</code> to be daisy-chained together, where each <code class="calibre23">ListElement</code> can contain the address <span {http://www.idpf.org/2007/ops}type="pagebreak" title="275" id="calibre_link-737" class="calibre14"></span>of the next <code class="calibre23">ListElement</code> object in a chain, the last in the chain having the pointer as <code class="calibre23">nullptr</code>. This is illustrated in <a id="calibre_link-1375" href="#calibre_link-406" class="calibre3">Figure 7-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000168.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-406" href="#calibre_link-1375" class="calibre3">FIGURE 7-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Each box in the diagram represents an object of type <code class="calibre23">ListElement</code>, and the <code class="calibre23">pNext</code> member of each object stores the address of the next object in the chain, except for the last object, where <code class="calibre23">pNext</code> is <code class="calibre23">nullptr</code>. This kind of arrangement is referred to as a <i class="calibre15">linked list</i>. It has the advantage that as long as you know the address of the first element in the list, you can find all the others. This is particularly useful when many objects are created dynamically, because you can use a linked list to keep track of them. Every time you create a new object, you can add it to the end of the list by storing its address in the <code class="calibre23">pNext</code> member of the last object in the chain.</p>
<section class="toclist">
<h4 class="calibre22">Accessing Structure Members through a Pointer</h4>
<p class="calibre13">Consider the following statements:</p>
<pre class="calibre28"><code class="calibre23">RECT aRect {0, 0, 100, 100};
RECT* pRect {&amp;aRect};</code></pre>
<p class="calibre13">The first defines the <code class="calibre23">aRect</code> object to be of type <code class="calibre23">RECT</code> with the first pair of members initialized to (0, 0) and the second pair to (100, 100). The second statement defines <code class="calibre23">pRect</code> as a pointer to type <code class="calibre23">RECT</code> and initializes it with the address of <code class="calibre23">aRect</code>. You can now access the members of <code class="calibre23">aRect</code> through the pointer with a statement such as this:</p>
<pre class="calibre28"><code class="calibre23">(*pRect).top += 10;                  // Increment the Top member by 10</code></pre>
<p class="calibre13">The parentheses around the dereferenced pointer here are essential because the member access operator takes precedence over the dereferencing operator. Without the parentheses, you would be attempting to treat the pointer as a <code class="calibre23">struct</code> and trying to access the member, so the statement would not compile. After executing this statement, the <code class="calibre23">top</code> member will have the value 10 and, of course, the remaining members will be unchanged.</p>
<p class="calibre13">The syntax that you used to access the member of a <code class="calibre23">struct</code> through a pointer looks rather clumsy. Because this kind of operation crops up very frequently, C++ includes a special operator that expresses the same thing in a much more readable and intuitive form, so let’s look at that next.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="276" id="calibre_link-738" class="calibre14"></span>The Indirect Member Selection Operator</h4>
<p class="calibre13">The <i class="calibre15">indirect member selection operator</i>, <code class="calibre23">-&gt;</code>, is specifically for accessing members of a <code class="calibre23">struct</code> or a class through a pointer; this operator is also referred to as the <i class="calibre15">indirect member access operator</i>. The operator looks like a little arrow (<code class="calibre23">-&gt;</code>) and is formed from a minus sign (<code class="calibre23">-</code>) followed by the symbol for greater than (<code class="calibre23">&gt;</code>). You could use it to rewrite the statement to access the <code class="calibre23">top</code> member of <code class="calibre23">aRect</code> through the pointer <code class="calibre23">pRect</code>, as follows:</p>
<pre class="calibre28"><code class="calibre23">pRect-&gt;top += 10;                      // Increment the top member by 10</code></pre>
<p class="calibre13">This is much more expressive of what is going on, isn’t it? You’ll see a lot more of the indirect member selection operator throughout the rest of the book.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-284" class="calibre3"></a>TYPES, OBJECTS, CLASSES, AND INSTANCES</h2>
<p class="calibre13">Before I get into the language, syntax, and programming techniques for classes, I’ll first explain how your existing knowledge relates to the concept of classes. So far, you’ve learned that you can create variables that can be any of a range of fundamental data types: <code class="calibre23">int, long, double</code>, and so on. You have also seen how you can use the <code class="calibre23">struct</code> keyword to define a structure type that you can use as the type for a variable representing a composite of several other variables.</p>
<p class="calibre13">The variables of the fundamental types don’t allow you to model real-world objects (or even imaginary objects) adequately. It’s hard to model a box in terms of an <code class="calibre23">int</code>, for example; however, you can use the members of a <code class="calibre23">struct</code> to define a set of attributes for such an object. You could define variables <code class="calibre23">length, width</code>, and <code class="calibre23">height</code> to represent the dimensions of the box and bind them together as members of a <code class="calibre23">Box</code> structure, as follows:</p>
<pre class="calibre28"><code class="calibre23">struct Box
{
  double length;
  double width;
  double height;
};</code></pre>
<p class="calibre13">With this definition of a new data type called <code class="calibre23">Box</code>, you can define variables of this type just as you did with variables of the basic types. You can then create, manipulate, and destroy as many <code class="calibre23">Box</code> objects as you need to in your program. This means that you can model objects using <code class="calibre23">struct</code>s and write your programs around them.</p>
<p class="calibre13">So &mdash; that’s object-oriented programming all wrapped up, then? Well, not quite. Object-oriented programming (OOP) is based on three basic concepts relating to object types (<i class="calibre15">encapsulation, polymorphism</i>, and <i class="calibre15">inheritance</i>), and what you have seen so far doesn’t quite fit the bill. Don’t worry about what these terms mean for the moment &mdash; you’ll explore that in the rest of this chapter and throughout the book.</p>
<p class="calibre13">The notion of a <code class="calibre23">struct</code> in C++ goes far beyond the original concept of a <code class="calibre23">struct</code> in C &mdash; it incorporates the object-oriented notion of a <i class="calibre15">class</i>. This idea of classes, from which you can create your own data types and use them just like the native types, is fundamental to C++, and the <code class="calibre23">class</code> keyword was introduced into the language to describe this concept. The keywords <code class="calibre23">struct</code> and <code class="calibre23">class</code> are almost identical in effect. They differ in the access control to the members, which you’ll learn more <span {http://www.idpf.org/2007/ops}type="pagebreak" title="277" id="calibre_link-739" class="calibre14"></span>about later in this chapter. The <code class="calibre23">struct</code> keyword is maintained in C++ for backwards compatibility with C, but everything that you can do with a <code class="calibre23">struct</code>, and more, you can achieve with a <code class="calibre23">class</code>.</p>
<p class="calibre13">Take a look at how you might define a class representing boxes:</p>
<pre class="calibre28"><code class="calibre23">class CBox
{
public:
  double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre13">When you define <code class="calibre23">CBox</code> as a class, you are essentially defining a new data type, similar to when you defined the <code class="calibre23">Box</code> structure. The only differences here are the use of the keyword <code class="calibre23">class</code> instead of <code class="calibre23">struct</code>, and the use of the <code class="calibre23">public</code> keyword followed by a colon that precedes the definition of the members of the class. The variables that you define as part of the class are called <i class="calibre15">data members</i> of the class, because they are variables that store data.</p>
<p class="calibre13">The <code class="calibre23">public</code> keyword is a clue as to the difference between a structure and a class. It just specifies that the members of the class that follow the keyword are generally accessible, in the same way as the members of a structure are. By default, the members of a class are not generally accessible and are said to be <i class="calibre15">private</i>, and to make members accessible, you must precede their definitions with the <code class="calibre23">public</code> keyword. The members of a <code class="calibre23">struct</code>, on the other hand, are public by default. The reason that class members are private by default is because, in general, an object of a class should be a self-contained entity such that the data that make the object what it is should be <i class="calibre15">encapsulated</i> and only changed under controlled circumstances. Public data members should be very much the exception. As you’ll see a little later in the chapter, though, it’s also possible to place other restrictions on the accessibility of members of a class.</p>
<p class="calibre13">I have also called the class <code class="calibre23">CBox</code> instead of <code class="calibre23">Box</code>. I could have called the class <code class="calibre23">Box</code>, but the MFC adopts the convention of using the prefix <code class="calibre23">C</code> for all class names, so you might as well get used to it. The MFC also prefixes data members of classes with <code class="calibre23">m_</code> to distinguish them from other variables, so I’ll use this convention, too. Remember, though, that in other contexts where you might use C++ without the MFC, this will not be the case; in some instances, the convention for naming classes and their members may be different, and in others, there may be no particular convention for naming entities.</p>
<p class="calibre13">You can define a variable, <code class="calibre23">bigBox</code>, which represents an instance of the <code class="calibre23">CBox</code> class type like this:</p>
<pre class="calibre28"><code class="calibre23">CBox bigBox;</code></pre>
<p class="calibre13">This is exactly the same as declaring a variable for a <code class="calibre23">struct</code>, or, indeed, for any other variable type. After you have defined the <code class="calibre23">CBox</code> class, definitions for variables of this type are quite standard.</p>
<section class="toclist">
<h3 class="calibre21">First Class</h3>
<p class="calibre13">The notion of class was invented by an Englishman to keep the general population happy. It derives from the theory that people who know their place and function in society are much more secure and comfortable in life than those who do not. The famous Dane, Bjarne Stroustrup, who invented C++, undoubtedly acquired a deep knowledge of class concepts while at Cambridge University in England and appropriated the idea very successfully for use in his new language.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="278" id="calibre_link-740" class="calibre14"></span>Class in C++ is similar to the English concept, in that each class usually has a very precise role and a permitted set of actions. However, it differs from the English idea because class in C++ has largely socialist overtones, concentrating on the importance of working classes. Indeed, in some ways it is the reverse of the English ideal because working classes in C++ often live on the backs of classes that do nothing at all.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Operations on Classes</h3>
<p class="calibre13">You can define new data types as classes to represent whatever kinds of objects you like. Classes (and structures) aren’t limited to just holding data; you can also define member functions or even operations that act on objects of your classes using the standard C++ operators. You can define the <code class="calibre23">CBox</code> class, for example, so that the following statements work and have the meanings you want them to have:</p>
<pre class="calibre28"><code class="calibre23">CBox box1;
CBox box2;
        
if(box1 &gt; box2)          // Fill the larger box
  box1.fill();
else
  box2.fill();</code></pre>
<p class="calibre13">You could also implement operations as part of the <code class="calibre23">CBox</code> class for adding, subtracting or even multiplying boxes &mdash; in fact, almost any operation to which you could ascribe a sensible meaning in the context of boxes.</p>
<p class="calibre13">I’m talking about incredibly powerful medicine here, and it constitutes a major change in the approach that you take to programming. Instead of breaking down a problem in terms of what are essentially computer-related data types (integers, floating-point numbers, and so on) and then writing a program, you can program in terms of problem-related data types, in other words, classes. These classes might be named <code class="calibre23">CEmployee</code>, or <code class="calibre23">CCowboy</code>, or <code class="calibre23">CCheese</code>, or <code class="calibre23">CChutney</code>, each defined specifically for the kind of problem that you want to solve, complete with the functions and operators that are necessary to manipulate instances of your new types.</p>
<p class="calibre13">Object-oriented program design starts with deciding what application-specific data types you need to solve the problem in hand, defining those as classes and writing the program in terms of operations on the specific types that the problem is concerned with, be they <code class="calibre23">CCoffins</code> or <code class="calibre23">CCowpokes</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Terminology</h3>
<p class="calibre13">I’ll first summarize some of the terminology that I will be using when discussing classes:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">A <i class="calibre15">class</i> is a user-defined data type.</li>
<li class="calibre6"><i class="calibre15">Object-oriented programming</i> (OOP) is the programming style based on the idea of defining your own data types as classes, where the data types are specific to the domain of the problem you intend to solve.</li>
<li class="calibre6">Declaring an object of a class type is sometimes referred to as <i class="calibre15">instantiation</i> because you are creating an <i class="calibre15">instance</i> of a class.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="279" id="calibre_link-741" class="calibre14"></span>Instances of a class type are referred to as <i class="calibre15">objects</i>.</li>
<li class="calibre6">The idea of an object containing the data implicit to its definition, together with the functions that operate on that data, is referred to as <i class="calibre15">encapsulation</i>.</li>
</ul>
<p class="calibre13">When I get into the details of object-oriented programming, it may seem a little complicated in places, but getting back to the basics usually helps to make things clearer, so always keep in mind what objects are really about. They are about writing programs in terms of the objects that are specific to the domain of your problem. All the facilities around classes are there to make this as comprehensive and flexible as possible. Let’s get down to the business of understanding classes.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-285" class="calibre3"></a>UNDERSTANDING CLASSES</h2>
<p class="calibre13">A class is a specification of a data type that you define. It can contain data elements that can either be variables of the fundamental types or of other user-defined types. The data elements may be single data items, arrays, pointers, arrays of pointers of almost any kind, or objects of other class types, so you have a lot of flexibility. A class typically contains functions that operate on objects of the class type by accessing the data elements that they include. So, a class combines both the definition of the elementary data that makes up an object and the means of manipulating the data that belongs to objects of the class type.</p>
<p class="calibre13">The data and functions within a class are called <i class="calibre15">members</i> of the class. Oddly enough, the members of a class that are data items are called <i class="calibre15">data members</i> and the members that are functions are called <i class="calibre15">function members</i> or <i class="calibre15">member functions</i>. The member functions are also sometimes referred to as <i class="calibre15">methods</i>; I will not use this term in general in this book, but it will turn up in Chapter 18.</p>
<p class="calibre13">When you define a class, you define a blueprint for objects of that type. This doesn’t actually define any objects, but it does define what the class name means, that is, what an object of the class type will consist of and what operations can be performed on it. It’s much the same as if you wrote a description of the basic type <code class="calibre23">double</code>. This wouldn’t be an actual variable of type <code class="calibre23">double</code>, but a definition of how it’s made up and what you can do with it. To create a variable of a fundamental type, you use a definition statement. It’s exactly the same with a class type.</p>
<section class="toclist">
<h3 class="calibre21">Defining a Class</h3>
<p class="calibre13">Take a look again at the class example you saw earlier &mdash; a class of boxes. The <code class="calibre23">CBox</code> type was defined as:</p>
<pre class="calibre28"><code class="calibre23">class CBox
{
public:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
};</code></pre>
<p class="calibre13">The class type name follows the <code class="calibre23">class</code> keyword, and the three data members are defined between the curly braces. The data members are defined for the class using the definition statements that you already know and love, and the whole class definition is terminated with a semicolon. The names of <span {http://www.idpf.org/2007/ops}type="pagebreak" title="280" id="calibre_link-742" class="calibre14"></span>all the members of a class are local to the class. You can, therefore, use the same names elsewhere in a program, including other class definitions.</p>
<section class="toclist">
<h4 class="calibre22">Access Control in a Class</h4>
<p class="calibre13">The <code class="calibre23">public</code> keyword determines the <i class="calibre15">access attributes</i> of the members of the class that follow it. Specifying members as <code class="calibre23">public</code> means that they can be accessed anywhere within the scope of the class object to which they belong. You can also specify the members of a class as <code class="calibre23">private</code> or <code class="calibre23">protected</code>, in which case the members cannot be accessed from outside the class. I’ll explain these attributes in more detail later. If you omit the access specification, the members have the default access attribute, <code class="calibre23">private</code>. (This is the only difference between a class and a struct &mdash; the default access specifier for a struct is <code class="calibre23">public</code>.)</p>
<p class="calibre13">All you have defined so far is the <code class="calibre23">CBox</code> class, which is a type. You haven’t created any objects. When I talk about accessing a class member, say <code class="calibre23">m_Height</code>, I’m talking about accessing the data member of a particular object, and that object needs to be defined somewhere.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Declaring Objects of a Class</h3>
<p class="calibre13">You define objects of a class with exactly the same sort of definition that you use to define variables of fundamental types, so you could define objects of the <code class="calibre23">CBox</code> class type with these statements:</p>
<pre class="calibre28"><code class="calibre23">CBox box1;                             // Declare box1 of type CBox
CBox box2;                             // Declare box2 of type CBox</code></pre>
<p class="calibre13">Both of these objects will, of course, have their own independent data members. This is illustrated in <a id="calibre_link-1376" href="#calibre_link-407" class="calibre3">Figure 7-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000035.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-407" href="#calibre_link-1376" class="calibre3">FIGURE 7-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The object name, <code class="calibre23">box1</code>, embodies the whole object, including its three data members. They are not initialized to anything &mdash; the data members of each object will contain junk values, so let’s look at how you access them for the purpose of setting them to some specific values.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Accessing the Data Members of a Class</h3>
<p class="calibre13">You can refer to the data members of a class object using the <i class="calibre15">direct member selection operator</i> that you used to access members of a struct. To set the value of the <code class="calibre23">m_Height</code> member of the object <code class="calibre23">box2</code> to 18.0, you can write this statement:</p>
<pre class="calibre28"><code class="calibre23">box2.m_Height = 18.0;                  // Setting the value of a data member</code></pre>
<p class="calibre13">You can access the data member in this way in a function that is outside the class because the <code class="calibre23">m_Height</code> member has <code class="calibre23">public</code> access. If it wasn’t defined as <code class="calibre23">public</code>, this statement would not compile. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="281" id="calibre_link-743" class="calibre14"></span>You’ll see more about this shortly. Obviously, you could assign values to the other public data members of <code class="calibre23">box2</code>.</p>
<p class="calibre13">You can also copy the values of members of one object to another. For example:</p>
<pre class="calibre28"><code class="calibre23">CBox box1;
CBox box2;
box1.m_Length = box1.m_Width = box1.m_Height = 2;
box2 = box1;                           // Member-wise copying from box1 to box2</code></pre>
<p class="calibre13">After creating two <code class="calibre23">CBox</code> objects, you set all the members of <code class="calibre23">box1</code> to 2.0. The last statement copies the values of the <code class="calibre23">box1</code> members to <code class="calibre23">box2</code>, so all the members of <code class="calibre23">box2</code> will be 2.0. Member-wise copying from one object to another works regardless of the access specification of the data members.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Your First Use of Classes</h3>
<p class="calibre20">This example shows that you can use your class in the same way as the structure:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_02.cpp
// Creating and using boxes
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
class CBox                             // Class definition at global scope
{
public:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
};
        
int main()
{
  CBox box1;                           // Declare box1 of type CBox
  CBox box2;                           // Declare box2 of type CBox
        
  double boxVolume {};                 // Stores the volume of a box
        
  box1.m_Height = 18.0;                // Define the values
  box1.m_Length = 78.0;                // of the members of
  box1.m_Width = 24.0;                 // the object box1
        
  box2.m_Height = box1.m_Height - 10;  // Define box2
  box2.m_Length = box1.m_Length/2.0;   // members in
  box2.m_Width = 0.25*box1.m_Length;   // terms of box1
        
  // Calculate volume of box1
  boxVolume = box1.m_Height*box1.m_Length*box1.m_Width;
        
  cout &lt;&lt; "Volume of box1 = " &lt;&lt; boxVolume &lt;&lt; endl;
        
  cout &lt;&lt; "box2 has sides which total "
       <span {http://www.idpf.org/2007/ops}type="pagebreak" title="282" id="calibre_link-744" class="calibre14"></span>&lt;&lt; box2.m_Height+ box2.m_Length+ box2.m_Width
       &lt;&lt; " inches." &lt;&lt; endl;
        
  // Display the size of a box in memory
  cout &lt;&lt; "A CBox object occupies "   
       &lt;&lt; sizeof box1 &lt;&lt; " bytes." &lt;&lt; endl;
        
  return 0;
}</code></pre>
<p class="calibre20">As you enter the code for <code class="calibre23">main()</code>, the editor prompts you with a list of member names whenever you enter a member selection operator following the name of a class object. You can then select the member you want from the list by double-clicking it. You can also use the arrow keys on the keyboard to move through the list and press Enter when you reach the one you want. Hovering the mouse cursor over any variable in your code will result in the type being displayed.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Everything here works, as you would expect from your experience with structures. The class definition is outside of <code class="calibre23">main()</code> and therefore has global scope. This enables you to define <code class="calibre23">CBox</code> objects anywhere in the source file and the class shows up in the Class View tab.</p>
<p class="calibre20">You define two objects of type <code class="calibre23">CBox</code> within <code class="calibre23">main()</code>: <code class="calibre23">box1</code> and <code class="calibre23">box2</code>. Of course, as with variables of the fundamental types, <code class="calibre23">box1</code> and <code class="calibre23">box2</code> are local to <code class="calibre23">main()</code>. Objects of a class type obey the same rules with respect to scope as variables of the fundamental types.</p>
<p class="calibre20">The first three assignment statements set the values of the data members of <code class="calibre23">box1</code>. You define the values of the data members of <code class="calibre23">box2</code> in terms of the data members of <code class="calibre23">box1</code> in the next three assignment statements.</p>
<p class="calibre20">You then have a statement that calculates the volume of <code class="calibre23">box1</code> as the product of its three data members, and you output this value. Next, you output the sum of the data members of <code class="calibre23">box2</code> by writing the expression for the sum directly in the output statement. The final action in the program is to output the number of bytes occupied by <code class="calibre23">box1</code>, which is produced by the <code class="calibre23">sizeof</code> operator.</p>
<p class="calibre20">If you run this program, you should get this output:</p>
<pre class="calibre28"><code class="calibre23">Volume of box1 = 33696
box2 has sides which total 66.5 inches.
A CBox object occupies 24 bytes.</code></pre>
<p class="calibre20">The last line shows that <code class="calibre23">box1</code> occupies 24 bytes, which is because it has three data members of 8 bytes each. The statement that produced the last line of output could equally well have been written like this:</p>
<pre class="calibre28"><code class="calibre23">  cout &lt;&lt; "A CBox object occupies " &lt;&lt; sizeof(CBox) &lt;&lt; " bytes." &lt;&lt; endl;</code></pre>
<p class="calibre20">I have used the type name between parentheses as the operand for the <code class="calibre23">sizeof</code> operator, rather than a specific object name. You’ll remember from Chapter 4 that this is standard syntax for the <code class="calibre23">sizeof</code> operator.</p>
<p class="calibre20">This example has demonstrated the mechanism for accessing the <code class="calibre23">public</code> data members of a class. It also shows that they can be used in exactly the same way as ordinary variables.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="283" id="calibre_link-745" class="calibre24"></span>Memberwise Initialization of an Object</h3>
<p class="calibre13">Because the data members of a <code class="calibre23">CBox</code> object are <code class="calibre23">public</code>, you can specify their values in an initializer list when you create the object. For example:</p>
<pre class="calibre28"><code class="calibre23">CBox box1 {2.5, 3.5, 4.5};</code></pre>
<p class="calibre13">The members of <code class="calibre23">box1</code> will be assigned values from the list in sequence so <code class="calibre23">m_Length</code> will be 2.5, <code class="calibre23">m_Width</code> will be 3.5, and <code class="calibre23">m_Height</code> will be 4.5. If you supply fewer initial values in the list than there are data members, the remainder will be set to zero. For example:</p>
<pre class="calibre28"><code class="calibre23">CBox box2 {2.5, 3.5};</code></pre>
<p class="calibre13"><code class="calibre23">m_Height</code> for <code class="calibre23">box2</code> here will be zero.</p>
<p class="calibre13">You can also supply an empty list to initialize all the members to zero:</p>
<pre class="calibre28"><code class="calibre23">CBox box3 {};             // All data members 0</code></pre>
<p class="calibre13">You <i class="calibre15">cannot</i> do this if the data members are <code class="calibre23">private</code>. You also cannot use an initializing list in this way if the class includes a <i class="calibre15">constructor</i> definition. I’ll explain what a constructor is a little later in this chapter.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Initializing Class Members</h3>
<p class="calibre13">You can specify initial values for data members in the definition of a class type. The members of the <code class="calibre23">CBox</code> class store dimensions of a box, which should not be negative, so it would be sensible to make the initial values 1.0. Here’s how you do this:</p>
<pre class="calibre28"><code class="calibre23">class CBox
{
public:
  double m_Length {1.0};               // Length of a box in inches
  double m_Width {1.0};                // Width of a box in inches
  double m_Height {1.0};               // Height of a box in inches
};</code></pre>
<p class="calibre13">The syntax for initializing class members is the same as for ordinary variables. You use an initializer list. The initial values will apply for the members of any <code class="calibre23">CBox</code> object you create unless the member values are set by some other means.</p>
<p class="calibre13">You don’t have to initialize every data member. The ones you don’t provide initial values for will contain junk values. If you provide an initial value for one or more members, you cannot specify initial values when you create an object as I described in the previous section. If you try to do so the compiler will flag it as an error. To restore this capability you must include a <i class="calibre15">constructor</i> in the class. As I said, I’ll explain class constructors a little later in this chapter.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Member Functions of a Class</h3>
<p class="calibre13">A member function of a class is a function that has its definition or prototype within the class definition. It operates on any object of the class of which it is a member, and can access all the members of an object, regardless of the access specification. The names of the class members that you use in the body of a member function automatically refer to the members of the specific object used to call the function, and the function can only be called for a particular object of the class type. If you try to <span {http://www.idpf.org/2007/ops}type="pagebreak" title="284" id="calibre_link-746" class="calibre14"></span>call a member function without specifying an object name, your program will not compile. Let’s try it out.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Adding a Member Function to CBox</h3>
<p class="calibre20">This example extends the <code class="calibre23">CBox</code> class to include a member function that calculates the volume of a <code class="calibre23">CBox</code> object. This will demonstrate how you access the members of the class from within a member function.</p>
<pre class="calibre28"><code class="calibre23">// Ex7_03.cpp
// Calculating the volume of a box with a member function
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
class CBox                               // Class definition at global scope
{
public:
  double m_Length{ 1.0 };                // Length of a box in inches
  double m_Width{ 1.0 };                 // Width of a box in inches
  double m_Height{ 1.0 };                // Height of a box in inches
 
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length*m_Width*m_Height;
  }
};
 
int main()
{
  CBox box1;                             // Declare box1 of type CBox
  CBox box2;                             // Declare box2 of type CBox
  CBox box3;                             // Declare box3 of type CBox
 
  double boxVolume{ box1.volume() };     // Stores the volume of a box
 
  cout &lt;&lt; "Default box1 volume : " &lt;&lt; boxVolume &lt;&lt; endl;
 
  box1.m_Height = 18.0;                  // Define the values
  box1.m_Length = 78.0;                  // of the members of
  box1.m_Width = 24.0;                   // the object box1
 
  boxVolume = box1.volume();             // Calculate new volume of box1
  cout &lt;&lt; "Volume of box1 is now: " &lt;&lt; boxVolume &lt;&lt; endl;
 
  box2.m_Height = box1.m_Height - 10;    // Define box2
  box2.m_Length = box1.m_Length / 2.0;   // members in
  box2.m_Width = 0.25*box1.m_Length;     // terms of box1
  cout &lt;&lt; "Volume of box2 = " &lt;&lt; box2.volume() &lt;&lt; endl;
 
  box3 = box2;
  cout &lt;&lt; "Volume of box3 = " &lt;&lt; box3.volume() &lt;&lt; endl;
 
  cout &lt;&lt; "A CBox object occupies "
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="285" id="calibre_link-747" class="calibre14"></span>&lt;&lt; sizeof box1 &lt;&lt; " bytes." &lt;&lt; endl;
 
  return 0;
}</code></pre>
<p class="calibre20">If you execute this example, it produces this output:</p>
<pre class="calibre28"><code class="calibre23">Default box1 volume : 1
Volume of box1 is now: 33696
Volume of box2 = 6084
Volume of box3 = 6084
A CBox object occupies 24 bytes.</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The new code in the <code class="calibre23">CBox</code> class definition is the definition of the <code class="calibre23">volume()</code> member function. It has the same access attribute as the data members, <code class="calibre23">public</code>. Every class member that you define following an access attribute will have that attribute, until another access attribute specification appears within the class definition. The <code class="calibre23">volume()</code> function returns the volume of a <code class="calibre23">CBox</code> object as a value of type <code class="calibre23">double</code>. The expression in the <code class="calibre23">return</code> statement is just the product of the three data members.</p>
<p class="calibre20">There’s no need to qualify the names of class members when you access them in member functions. The unqualified member names automatically refer to the members of the object for which the member function is called. You call a member function for a particular object by writing the name of the object, followed by a period, followed by the function name. The function automatically accesses the data members of the object for which it was called, so the first use of <code class="calibre23">volume()</code> calculates the volume of <code class="calibre23">box1</code> and the value returned is used to initialize <code class="calibre23">boxVolume</code>. The output shows that the data members of <code class="calibre23">box1</code> had the initial values you specified in the class definition when the <code class="calibre23">volume()</code> member was executed.</p>
<p class="calibre20">The member function is used a second time to produce the volume of <code class="calibre23">box1</code> after new values have been set for the members of the object. Of course, the output reflects the volume of a box with the new dimensions. After computing values for the members of <code class="calibre23">box2</code>, you call the <code class="calibre23">volume()</code> member directly in the output statement so the return value is written to the stream. Using a member function of an object is no different from using an ordinary function.</p>
<p class="calibre20">The members of <code class="calibre23">box3</code> are assigned the same values as <code class="calibre23">box2</code> by an assignment statement. The output confirms that <code class="calibre23">box3</code> has the same volume as <code class="calibre23">box2</code>.</p>
<p class="calibre20">Note that a <code class="calibre23">CBox</code> object still occupies the same number of bytes. Adding a function member to a class doesn’t affect the size of the objects. Obviously, a member function has to be stored somewhere, but there’s only one copy regardless of how many class objects you create. The memory occupied by member functions isn’t counted when the <code class="calibre23">sizeof</code> operator produces the number of bytes that an object occupies.</p>
<p class="calibre20">You could try commenting out the <code class="calibre23">public</code> keyword. The code will no longer compile because all the members of the <code class="calibre23">CBox</code> class will be private by default.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Adding a</i> <code class="calibre23">virtual</code> <i class="calibre15">function to a class, which you will learn about in Chapter 9, will increase the size of a class object.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="286" id="calibre_link-748" class="calibre24"></span>Defining a Member Function Outside a Class</h3>
<p class="calibre13">You can define a member function outside the class definition. In this case you just put the prototype inside the class. If you rewrite the <code class="calibre23">CBox</code> class definition with the function definition outside, the class definition looks like this:</p>
<pre class="calibre28"><code class="calibre23">class CBox                             // Class definition at global scope
{
public:
  double m_Length {1.0};               // Length of a box in inches
  double m_Width {1.0};                // Width of a box in inches
  double m_Height {1.0};               // Height of a box in inches
  double volume();                     // Member function prototype
};</code></pre>
<p class="calibre13">Because the definition of the <code class="calibre23">Volume()</code> member will be outside the class, there has to be a way of telling the compiler that the function belongs to the <code class="calibre23">CBox</code> class. This is done by prefixing the function name with the name of the class and separating the two with the scope resolution operator. The function definition would look like this:</p>
<pre class="calibre28"><code class="calibre23">// Function to calculate the volume of a box
double CBox::volume()
{
  return m_Length*m_Width*m_Height;
}</code></pre>
<p class="calibre13">The function produces the same output as the last example; however, the program isn’t exactly the same. In the second case, all calls to the function are treated in the way that you’re already familiar with. However, when you define a function within the class definition, as in <code class="calibre23">Ex7_03.cpp</code>, the compiler implicitly treats the function as an <i class="calibre15">inline function</i>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Inline Functions</h3>
<p class="calibre13">The compiler tries to expand the code in the body of an inline function in place of a call to the function. This avoids much of the overhead of calling the function and speeds up your code. This is illustrated in <a id="calibre_link-1377" href="#calibre_link-408" class="calibre3">Figure 7-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000112.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-408" href="#calibre_link-1377" class="calibre3">FIGURE 7-5</a></b></span></p>
</figcaption>
</figure>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="287" id="calibre_link-749" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Of course, the compiler ensures that expanding a function inline doesn’t cause any problems with variable name conflicts or scope.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Specifying a function as inline does not guarantee the function will be inline. The compiler may not be able to insert the code for a function inline (such as with recursive functions or functions for which you have obtained an address), but generally, it will work. It’s best used for very short, simple functions, such as our <code class="calibre23">volume()</code> function in the <code class="calibre23">CBox</code> class, because such functions will execute faster inline and inserting the body code in place of each call does not significantly increase the size of the executable module. When the compiler is not able to make a function inline, your code will still compile and run.</p>
<p class="calibre13">When you define a member function outside of a class, you can tell the compiler that you would like the function to be considered as inline by placing the keyword <code class="calibre23">inline</code> at the beginning of the function header:</p>
<pre class="calibre28"><code class="calibre23">// Function to calculate the volume of a box
<b class="calibre12">inline double CBox::Volume()</b>
{
  return m_Length*m_Width*m_Height;
}</code></pre>
<p class="calibre13">With this function definition, the program is exactly the same as the original. Thus you can put the member function definitions outside of a class and still retain the execution performance benefits of inlining. You can apply the <code class="calibre23">inline</code> keyword to ordinary functions that have nothing to do with classes and get the same effect. Remember, however, that it’s best used for short, simple functions.</p>
<p class="calibre13">Having said all that, it is not essential to use the <code class="calibre23">inline</code> keyword for functions to be inline. The compiler is sometimes smart enough to decide for itself whether inlining makes sense, even if the method is not marked as “inline”.</p>
<p class="calibre13">Next I’ll explain a little more about what happens when you define an object of a class.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-286" class="calibre3"></a>CLASS CONSTRUCTORS</h2>
<p class="calibre13">In the previous program, you defined the <code class="calibre23">CBox</code> objects, <code class="calibre23">box1</code> and <code class="calibre23">box2</code>, and then set values for members of each object explicitly. A major constraint on this approach arises when the data members of a class don’t have the attribute <code class="calibre23">public</code> &mdash; you won’t be able to access them from outside the class at all. There has to be a better way and of course there is &mdash; it’s known as the class <i class="calibre15">constructor</i>.</p>
<section class="toclist">
<h3 class="calibre21">What Is a Constructor?</h3>
<p class="calibre13">A class constructor is a special function in a class that is responsible for creating new objects. A constructor can customize objects as they are created to ensure that data members have the values you want. Because a constructor is a member function, it can set the values for members regardless of their access attributes. A class can have several constructors, enabling you to create objects in various ways. A constructor can and often does include code to check the validity of the arguments passed to it to ensure that data members have legal values for the object type. A trivial example would be to ensure that the dimensions stored in a <code class="calibre23">CBox</code> object was not negative.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="288" id="calibre_link-750" class="calibre14"></span>You have no leeway in naming constructors &mdash; they always have the same name as the class in which they are defined, even when there are two or more. <code class="calibre23">CBox()</code> for example, is a constructor for our <code class="calibre23">CBox</code> class. A constructor has no return type. It’s wrong to specify a return type for a constructor; you must not even write it as <code class="calibre23">void</code>. The primary purpose of a constructor is to assign values to data members of the class, and no return type is necessary or permitted. If you specify a return type for a constructor, the compiler will report it as an error.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Adding a Constructor to the CBox class</h3>
<p class="calibre20">Let’s extend our <code class="calibre23">CBox</code> class to incorporate a constructor:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_04.cpp
// Using a constructor
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
class CBox                           // Class definition at global scope
{
public:
  double m_Length {1.0};             // Length of a box in inches
  double m_Width {1.0};              // Width of a box in inches
  double m_Height {1.0};             // Height of a box in inches
 
  // Constructor definition
  CBox(double lv, double wv, double hv)
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    m_Length = lv;                   // Set values of
    m_Width = wv;                    // data members
    m_Height = hv;
  }
 
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length* m_Width* m_Height;
  }
   
};
 
int main()
{
  CBox box1 {78.0,24.0,18.0};          // Declare and initialize box1
  CBox cigarBox {8.0,5.0,1.0};         // Declare and initialize cigarBox
 
  cout &lt;&lt; "Volume of box1 = " &lt;&lt; box1.volume() &lt;&lt; endl; 
  cout &lt;&lt; "Volume of cigarBox = " &lt;&lt; cigarBox.volume() &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="289" id="calibre_link-751" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">CBox()</code> constructor has three parameters of type <code class="calibre23">double</code>, corresponding to the <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code> members of an object. The first statement in the constructor outputs a message so that you can tell when it’s been called. You wouldn’t do this in production programs, but it’s very helpful in showing when a constructor is called, so it’s often used when testing a program. I’ll use it regularly for the purposes of illustration. The code in the body of the constructor is very simple. It just assigns the arguments that you pass to the constructor when you call it to the corresponding data members. If necessary, you could also include checks that valid, non-negative arguments are supplied and in a real context you probably would do this, but our primary interest here is in seeing how the mechanism works.</p>
<p class="calibre20">Within <code class="calibre23">main()</code>, you define the <code class="calibre23">box1</code> object with values for the data members <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code>, in sequence:</p>
<pre class="calibre28"><code class="calibre23">CBox box1 {78.0,24.0,18.0};          // Declare and initialize box1</code></pre>
<p class="calibre20">The constructor arguments are in an initializer list following the object name. You can also use functional notation to call the constructor:</p>
<pre class="calibre28"><code class="calibre23">CBox box1(78.0,24.0,18.0);           // Declare and initialize box1</code></pre>
<p class="calibre20">This is older syntax so you will still see it used, but it’s better to use an initializer list because almost everything can be initialized in this way.</p>
<p class="calibre20">Note that calling a constructor is quite different from the statements earlier where you supplied an initializer list containing values for public data members. There you could have fewer values in the list and members would be initialized with zero. Here the initializer list contains the arguments for the constructor. There are three parameters so three values must appear in the list.</p>
<p class="calibre20">You create a second <code class="calibre23">CBox</code> object, called <code class="calibre23">cigarBox</code>, by calling the constructor.</p>
<p class="calibre20">The volume of <code class="calibre23">box1</code> is calculated by calling its <code class="calibre23">volume()</code> member as in the previous example, and is then output. You also output the value of the volume of <code class="calibre23">cigarBox</code>. The output from the example is:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Volume of box1 = 33696
Volume of cigarBox = 40</code></pre>
<p class="calibre20">The first two lines are from the calls of the <code class="calibre23">CBox</code> constructor, once for each object created. The constructor that you have supplied is automatically called when a <code class="calibre23">CBox</code> object is defined, so the <code class="calibre23">CBox</code> objects have members with the values appearing in the initializer lists for the constructor calls. The values are passed to the constructor as arguments in the sequence that they are written in the list. As you can see, the volume of <code class="calibre23">box1</code> is the same as before and <code class="calibre23">cigarBox</code> has a volume looking suspiciously like the product of its dimensions, which is quite a relief.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The Default Constructor</h3>
<p class="calibre13">Try modifying <code class="calibre23">Ex7_04.cpp</code> by adding this definition for <code class="calibre23">box2</code>:</p>
<pre class="calibre28"><code class="calibre23">CBox box2;                             // Define box2 of type CBox</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="290" id="calibre_link-752" class="calibre14"></span>When you rebuild this version of the program, you get the error message:</p>
<pre class="calibre28"><code class="calibre23">error C2512: 'CBox': no appropriate default constructor available</code></pre>
<p class="calibre13">This means that the compiler is looking for a <i class="calibre15">default constructor</i> to create <code class="calibre23">box2</code> (also referred to as the <i class="calibre15">noarg</i> constructor because it doesn’t require arguments when it is called). The error message is because you haven’t supplied an initializer list containing the arguments for the constructor defined in the class. The default constructor looks like this:</p>
<pre class="calibre28"><code class="calibre23">CBox()                       // Default constructor
{}                           // Totally devoid of statements</code></pre>
<p class="calibre13">A default constructor can be either a constructor that has no parameters as here, or a constructor with all its parameters having default values specified. This statement worked perfectly well in <code class="calibre23">Ex7_02.cpp</code>, so why doesn’t it work now?</p>
<p class="calibre13">The answer is that the previous example used a default constructor that was supplied by the compiler, and the compiler provided this constructor because you didn’t supply any. In this example you <i class="calibre15">did</i> supply a constructor so the compiler assumes that you are taking care of everything needed to create <code class="calibre23">CBox</code> objects and it didn’t supply the default. If you want to use definitions for <code class="calibre23">CBox</code> objects with no initializer list, you have to define the default constructor in the class. You don’t have to write it as the previous fragment in the class. You can instruct the compiler to include the default constructor when it will otherwise be suppressed because you have defined other constructors for the class. Here’s how you would do that for the <code class="calibre23">CBox</code> class:</p>
<pre class="calibre28"><code class="calibre23">class CBox                                  // Class definition at global scope
{
public:
  double m_Length{ 1.0 };                   // Length of a box in inches
  double m_Width{ 1.0 };                    // Width of a box in inches
  double m_Height{ 1.0 };                   // Height of a box in inches
 
  // Constructor definition
  CBox(double lv, double wv, double hv)
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    m_Length = lv;                          // Set values of
    m_Width = wv;                           // data members
    m_Height = hv;
  }
 
  <b class="calibre12">CBox() = default;                         // Default constructor</b>
 
  // Function to calculate the volume of a box
  double volume() {  return m_Length* m_Width* m_Height;  }
};</code></pre>
<p class="calibre13">The <code class="calibre23">default</code> keyword after the <code class="calibre23">=</code> specifies that the <code class="calibre23">CBox</code> no-arg constructor should be included in the class. Specifying it this way shows clearly that the default constructor is included in the class. You can see such a constructor in action.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="291" id="calibre_link-753" class="calibre24"></span>TRY IT OUT: Supplying a Default Constructor</h3>
<p class="calibre20">Let’s add a default constructor to the last example, along with the definition for <code class="calibre23">box2</code>, plus the original assignments for the data members of <code class="calibre23">box2</code>. You can enlarge the default constructor just enough to show that it is called. Here is the next version of the program:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_05.cpp
// Supplying and using a default constructor
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
class CBox                                  // Class definition at global scope
{
public:
  double m_Length{ 1.0 };                   // Length of a box in inches
  double m_Width{ 1.0 };                    // Width of a box in inches
  double m_Height{ 1.0 };                   // Height of a box in inches
 
  // Constructor definition
  CBox(double lv, double wv, double hv)
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    m_Length = lv;                          // Set values of
    m_Width = wv;                           // data members
    m_Height = hv;
  }
 
  // Default constructor definition
  CBox()
  {
    cout &lt;&lt; "Default constructor called." &lt;&lt; endl;
  }
 
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length* m_Width* m_Height;
  }
};
 
int main()
{
  CBox box1{ 78.0, 24.0, 18.0 };            // Define and initialize box1
  CBox box2;                                // Define box2 - no initial values
  CBox cigarBox{ 8.0, 5.0, 1.0 };           // Define and initialize cigarBox
 
  cout &lt;&lt; "Volume of box1 = " &lt;&lt; box1.volume() &lt;&lt; endl;; 
  cout &lt;&lt; "Volume of cigarBox = " &lt;&lt; cigarBox.volume() &lt;&lt; endl;; 
 
  box2.m_Height = box1.m_Height - 10;       // Define box2
  box2.m_Length = box1.m_Length / 2.0;      // members in
  box2.m_Width = 0.25*box1.m_Length;        // terms of box1
  cout &lt;&lt; "Volume of box2 = " &lt;&lt; box2.volume() &lt;&lt; endl;
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="292" id="calibre_link-754" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Now that you have included your own version of the default constructor, there are no error messages from the compiler and everything works. The program produces this output:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Default constructor called.
Constructor called.
Volume of box1 = 33696
Volume of cigarBox = 40
Volume of box2 = 6084
</code></pre>
<p class="calibre20">The default constructor just displays a message. Evidently, it was called when you defined the object <code class="calibre23">box2</code>. You also get the correct value for the volumes of all three <code class="calibre23">CBox</code> objects, so the rest of the program is working as it should.</p>
<p class="calibre20">I included the full definition of the default constructor in the class so you can see when it is called. If you want to see it working using the default keyword, replace the definition with:</p>
<pre class="calibre28"><code class="calibre23">  CBox() = default;</code></pre>
<p class="calibre20">You now know that you can overload constructors just as you overloaded functions in Chapter 6. You have just executed an example with two constructors that differ only in their parameter list. One has three parameters of type <code class="calibre23">double</code> and the other has no parameters at all.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Default Parameter Values</h3>
<p class="calibre13">You have seen how you can specify default values for the parameters to a function in the function prototype. You use the same syntax for class member functions, including constructors. If you put the definition of the member function inside the class, you can put the default values for the parameters in the function header. If you include only the prototype of a function in the class definition, the default parameter values should go in the prototype, not in the function definition.</p>
<p class="calibre13">You could use this technique as an alternative to specifying initial values for the data members of the <code class="calibre23">CBox</code> class. You could alter the class in the last example to this:</p>
<pre class="calibre28"><code class="calibre23">class CBox                             // Class definition at global scope
{
public:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
        
  <b class="calibre12">// Constructor definition</b>
  <b class="calibre12">CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0)</b>
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    m_Length = lv;                     // Set values of
    m_Width = wv;                      // data members
    m_Height = hv;
  }
        
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="293" id="calibre_link-755" class="calibre14"></span>// Default constructor definition
  CBox()
  {
    cout &lt;&lt; "Default constructor called." &lt;&lt; endl;
  }
        
  // Function to calculate the volume of a box
  double Volume()
  {
    return m_Length*m_Width*m_Height;
  }
};</code></pre>
<p class="calibre13">If you make this change to the last example, what happens? You get another error message from the compiler, of course. Amongst a lot of other stuff, you get these useful comments from the compiler:</p>
<pre class="calibre28"><code class="calibre23">warning C4520: 'CBox': multiple default constructors specified
error C2668: 'CBox::CBox': ambiguous call to overloaded function</code></pre>
<p class="calibre13">This is because the compiler can’t work out which of the two constructors to call &mdash; the one for which you have set default parameter values or the constructor that doesn’t accept any parameters. The definition of <code class="calibre23">box2</code> requires a constructor without parameters and either constructor can now be called with no arguments. The obvious solution to this is to get rid of the constructor that has no parameters. This is actually beneficial. Without this constructor, any <code class="calibre23">CBox</code> object defined without being explicitly initialized will automatically have its members initialized to 1. Personally, I prefer to set up such default values as in-class member initializations, but let’s see how it works with default constructor argument values anyway.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Supplying Default Values for Constructor Arguments</h3>
<p class="calibre20">You can demonstrate this with the following simplified example:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_06.cpp
// Supplying default values for constructor arguments
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
class CBox                             // Class definition at global scope
{
public:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
        
  // Constructor definition
  CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0)
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    m_Length = lv;                     // Set values of
    m_Width = wv;                      // data members
    m_Height = hv;
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="294" id="calibre_link-756" class="calibre14"></span>}
        
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length*m_Width*m_Height;
  }
};
        
int main()
{
  CBox box2;                           // Declare box2 - no initial values        
  cout &lt;&lt; "Volume of box2 = " &lt;&lt; box2.volume() &lt;&lt; endl;
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You only define a single uninitialized <code class="calibre23">CBox</code> variable &mdash; <code class="calibre23">box2</code> &mdash; because that’s all you need for demonstration purposes. This version of the program produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Volume of box2 = 1</code></pre>
<p class="calibre20">This shows that the constructor with default parameter values is doing its job of setting the values of objects that have no initializing values specified.</p>
<p class="calibre20">You should not assume from this that this is the only, or even the recommended, way of implementing the default constructor. There will be many occasions where you won’t want to assign default values in this way, in which case, you’ll need to write a separate default constructor. There will even be times when you don’t want to have a default constructor operating at all, even though you have defined another constructor.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Using a Constructor Initialization List</h3>
<p class="calibre13">You can initialize data members using a <i class="calibre15">constructor initialization list</i> within the header in a constructor definition. This is different from using an initializer list when you call a constructor; the initializer list just contains the arguments to be passed to the constructor. I can demonstrate this with an alternative <code class="calibre23">CBox</code> constructor:</p>
<pre class="calibre28"><code class="calibre23">    // Constructor definition using an initialization list
    CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                                    m_Length {lv}, m_Width {wv}, m_Height {hv}
    {
      cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    }</code></pre>
<p class="calibre13">This definition is written assuming that it is within the class definition. The constructor initializing list is separated from the parameter list by a colon, and the initializers for class members are separated by commas. Values of the data members are not set in assignment statements in the body <span {http://www.idpf.org/2007/ops}type="pagebreak" title="295" id="calibre_link-757" class="calibre14"></span>of the constructor. They each have an initial value defined in an initializer list that is part of the function header. The members are effectively created in the constructor initializer list. The member <code class="calibre23">m_Length</code> is initialized by the value of the argument passed for the parameter, <code class="calibre23">lv</code>, for example. Functional notation also works, but it’s better to use the uniform initialization syntax. Initializing members in the constructor header is more efficient than using assignments as in the previous version. The member initialization list always executes before the body of the function so you can use the values of any members initialized in the list in the body of the constructor. If you substitute this constructor in <code class="calibre23">Ex7_06.cpp</code>, you will see that it works just as well.</p>
<p class="calibre13">With class members that are <code class="calibre23">const</code> or reference types, you have no choice as to how they are initialized. The <i class="calibre15">only</i> way is to use a member initializer list in a constructor. Assignment within the body of a constructor will not work. Note also that the members are not initialized in the order they are written in the constructor initializer list, but in the order in which they are defined in the class definition.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Making a Constructor Explicit</h3>
<p class="calibre13">This discussion assumes that the <code class="calibre23">CBox</code> constructor with three parameters has no default parameter values specified. This is because the three-parameter constructor could function as a constructor with a single argument and as a constructor with two arguments because the parameters with no arguments specified would assume the default values.</p>
<p class="calibre13">If you define a constructor with a single parameter, the compiler will use this constructor for implicit conversions, which may not be what you want. For example, suppose you define a constructor for the <code class="calibre23">CBox</code> class like this:</p>
<pre class="calibre28"><code class="calibre23">CBox(double side): m_Length {side}, m_Width {side}, m_Height {side} {}</code></pre>
<p class="calibre13">This constructor is handy when you want to define <code class="calibre23">CBox</code> objects that are cubes, where all three dimensions are the same. Because this constructor has a single parameter, the compiler will use it for implicit conversions from type <code class="calibre23">double</code> to type <code class="calibre23">CBox</code> when necessary. For example, consider the following:</p>
<pre class="calibre28"><code class="calibre23">CBox box;
box = 99.0;</code></pre>
<p class="calibre13">The first statement calls the default constructor to create <code class="calibre23">box</code>, so a default constructor must be defined in the class. The second statement will call the constructor <code class="calibre23">CBox(double)</code> with the argument as 99.0, so you are getting an implicit conversion from a value of type <code class="calibre23">double</code> to type <code class="calibre23">CBox</code>. This may be what you want, but there will be many classes with single argument constructors where you don’t want this to happen. In these situations, you can use the <code class="calibre23">explicit</code> keyword in the definition of the constructor to prevent it:</p>
<pre class="calibre28"><code class="calibre23">explicit CBox(double side): m_Length {side}, m_Width {side}, m_Height {side} {}</code></pre>
<p class="calibre13">With the constructor defined as <code class="calibre23">explicit</code>, it will only be called when it is explicitly invoked; it will not be used for implicit conversions. With the constructor defined as <code class="calibre23">explicit</code>, the statement assigning 99.0 to <code class="calibre23">box</code> will not compile. In general, unless you want your single-parameter constructors to be used for implicit-type conversions, it is best to define them all as <code class="calibre23">explicit</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="296" id="calibre_link-758" class="calibre14"></span>With the explicit <code class="calibre23">CBox</code> constructor in the previous fragment, this will not compile:</p>
<pre class="calibre28"><code class="calibre23">CBox box = 4.0;</code></pre>
<p class="calibre13">The statement requires an implicit conversion from the value, 4.0, of type <code class="calibre23">double,</code> to type <code class="calibre23">CBox</code> and the compiler will not allow it. This will compile though:</p>
<pre class="calibre28"><code class="calibre23">CBox box {4.0};</code></pre>
<p class="calibre13">This is not a conversion. This is an explicit call for the constructor with a single parameter.</p>
<p class="calibre13">There’s a more obscure way you can get accidental implicit conversions. In the previous version of the <code class="calibre23">CBox</code> class, the constructor has default values for all three parameters. This is how it looks using an initialization list in the header:</p>
<pre class="calibre28"><code class="calibre23">CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                                m_Length {lv}, m_Width {wv}, m_Height {hv}
{
  cout &lt;&lt; "Constructor called." &lt;&lt; endl;
}</code></pre>
<p class="calibre13">Because there are default values for the second and third parameters, the following statements will compile:</p>
<pre class="calibre28"><code class="calibre23">CBox box;
box = 99.0;</code></pre>
<p class="calibre13">This time, you get an implicit call to the constructor with the first argument as 99.0, and the other two arguments will have default values. This is unlikely to be what you want. To prevent this, make the constructor explicit:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):</b>
                                <b class="calibre12">m_Length(lv), m_Width(wv), m_Height(hv)</b>
{
  cout &lt;&lt; "Constructor called." &lt;&lt; endl;
}</code></pre>
</section>
<section class="toclist">
<h3 class="calibre21">Delegating Constructors</h3>
<p class="calibre13">When a class has two or more constructors defined, one constructor can call another to help with creating an object, but only in the constructor initializer list in the constructor header, in which case there can be no other initializations within the list. Let’s look at an example to see how this works. Suppose you have defined the <code class="calibre23">CBox</code> class constructor as:</p>
<pre class="calibre28"><code class="calibre23">explicit CBoxCbox(double lv, double wv, double hv):
                                m_Length{lv}, m_Width{wv}, m_Height{hv}     {}</code></pre>
<p class="calibre13">You can now define a constructor with a single parameter like this:</p>
<pre class="calibre28"><code class="calibre23">explicit CBox(double side): CBox {side, side, side}
{}</code></pre>
<p class="calibre13">This calls the previous constructor in the member initializing list. This technique can save repeating code in several constructors, where some of the members are always initialized in the same way, for example, but others are initialized uniquely, depending on which constructor is used.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="297" id="calibre_link-759" class="calibre14"></span>The only way one constructor can call another in a given class is through the member initializing list. You cannot call a <code class="calibre23">CBox</code> constructor to assist with creating an object in the body of a <code class="calibre23">CBox</code> constructor. Calling a constructor in the body of a constructor, or any function for that matter, is creating an independent object.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-287" class="calibre3"></a>PRIVATE MEMBERS OF A CLASS</h2>
<p class="calibre13">Having a constructor that sets the values of the data members of a class object but still allows any part of a program to mess with what are essentially the guts of the object, is almost a contradiction in terms. To draw an analogy, after you have arranged for a brilliant surgeon with skills honed over years of training to do things to your insides with a sharp knife, letting the local plumber or bricklayer have a go is a bit risky, to say the least. You need protection for your class data members.</p>
<p class="calibre13">You can get the security you need by using the <code class="calibre23">private</code> keyword when you define the class members. Data and function members of a class that are <code class="calibre23">private</code> can, in general, be accessed only by member functions of a class. There’s one exception, but we’ll worry about that later. A normal function has no direct means of accessing the <code class="calibre23">private</code> members of a class. This is shown in <a id="calibre_link-1378" href="#calibre_link-409" class="calibre3">Figure 7-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000121.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-409" href="#calibre_link-1378" class="calibre3">FIGURE 7-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Having the possibility of specifying some class members as <code class="calibre23">private</code> enables you to separate the <i class="calibre15">interface</i> to the class from its internal implementation. The interface to a class consists of the <code class="calibre23">public</code> data members and the <code class="calibre23">public</code> member functions. Where necessary, public member functions can <span {http://www.idpf.org/2007/ops}type="pagebreak" title="298" id="calibre_link-760" class="calibre14"></span>provide indirect access to any member of a class, including the <code class="calibre23">private</code> members. By keeping the internals of a class <code class="calibre23">private</code>, you can later modify them to improve performance for example, without requiring changes to code that uses the class through its public interface. To keep the data and function members of a class safe from unnecessary meddling, it’s good practice to define those that don’t need to be exposed as <code class="calibre23">private</code>. Only make <code class="calibre23">public</code> what is essential to the use of your class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Private Data Members</h3>
<p class="calibre20">You can rewrite the <code class="calibre23">CBox</code> class to make its data members <code class="calibre23">private</code>.</p>
<pre class="calibre28"><code class="calibre23">// Ex7_07.cpp
// A class with private members
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
class CBox                             // Class definition at global scope
{
public:
  // Constructor definition using an initialization list
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                             m_Length {lv}, m_Width {wv}, m_Height {hv}
 {
   cout &lt;&lt; "Constructor called." &lt;&lt; endl;
 }
        
 // Function to calculate the volume of a box
 double volume()
 {
   return m_Length*m_Width*m_Height;
 }
        
private:
  double m_Length;                   // Length of a box in inches
  double m_Width;                    // Width of a box in inches
  double m_Height;                   // Height of a box in inches
};
        
int main()
{
  CBox match {2.2, 1.1, 0.5};        // Declare match box
  CBox box2;                         // Declare box2 - no initial values
        
  cout &lt;&lt; "Volume of match = " &lt;&lt; match.volume() &lt;&lt; endl;
        
// Uncomment the following line to get an error
// box2.m_Length = 4.0;
        
  cout &lt;&lt; "Volume of box2 = " &lt;&lt; box2.volume() &lt;&lt; endl;
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="299" id="calibre_link-761" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">CBox</code> constructor is <code class="calibre23">explicit</code> to prevent implicit conversions. The <code class="calibre23">CBox</code> class definition now has two sections. The first is the <code class="calibre23">public</code> section containing the constructor and the member function, <code class="calibre23">volume()</code>. The second section is specified as <code class="calibre23">private</code> and contains the data members. The data members can only be accessed by the member functions of the class. You don’t have to modify any of the member functions &mdash; they can access all the data members of the class anyway. If you uncomment the statement in <code class="calibre23">main()</code> that assigns a value to the <code class="calibre23">m_Length</code> member of the <code class="calibre23">box2</code> object, you’ll get a compiler error message confirming that the data member is inaccessible. If you haven’t already done so, take a look at the members of the <code class="calibre23">CBox</code> class in Class View; the icon alongside a member indicates its accessibility; a small padlock in the icon shows when a member is <code class="calibre23">private</code>.</p>
<p class="calibre20">A point to remember is that using a constructor or a member function is the only way to get a value into a <code class="calibre23">private</code> data member of an object. You have to make sure that all the ways in which you might want to set or modify <code class="calibre23">private</code> data members of a class are provided for through member functions.</p>
<p class="calibre20">You can put functions in the <code class="calibre23">private</code> section of a class. In this case, they can only be called by other member functions. If you put the <code class="calibre23">volume()</code> function in the <code class="calibre23">private</code> section, you will get compiler errors for the statements that attempt to use it in <code class="calibre23">main()</code>. If you put the constructor in the <code class="calibre23">private</code> section, you won’t be able to create any objects of the class type.</p>
<p class="calibre20">The example generates this output:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Volume of match = 1.21
Volume of box2 = 1</code></pre>
<p class="calibre20">The output demonstrates that the class is still working satisfactorily, with its data members defined as <code class="calibre23">private</code>. The major difference is that they are now completely protected from unauthorized access and modification.</p>
<p class="calibre20">If you don’t specify otherwise, the default access attribute for class members is <code class="calibre23">private</code>. You could put all your <code class="calibre23">private</code> members at the beginning of the class definition and let them default to <code class="calibre23">private</code>. It’s better, however, to explicitly state the access attribute in every case, so there is no doubt about what you intend.</p>
<p class="calibre20">Of course, you don’t have to make all data members <code class="calibre23">private</code>. If the application for your class requires it, you can have some data members defined as <code class="calibre23">private</code> and some as <code class="calibre23">public</code>. It depends on what you’re trying to do. If there’s no reason to make members <code class="calibre23">public</code>, it’s better to make them <code class="calibre23">private</code> because it makes the class more secure. Ordinary functions can’t access the <code class="calibre23">private</code> members of your class.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">Accessing private Class Members</h3>
<p class="calibre13">On reflection, declaring the data members of a class as <code class="calibre23">private</code> is rather extreme. It’s all very well protecting them from unauthorized modification, but that’s no reason to keep their values a secret. What you need is a Freedom of Information Act for <code class="calibre23">private</code> members.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="300" id="calibre_link-762" class="calibre14"></span>You don’t have to start writing to your state senator to get it &mdash; it’s already available. You can write a member function to return the value of a data member. Look at this member function for the <code class="calibre23">CBox</code> class:</p>
<pre class="calibre28"><code class="calibre23">inline double CBox::getLength()
{
  return m_Length;
}</code></pre>
<p class="calibre13">Just to show how it looks, I have written this as a member function definition that is external to the class. I’ve specified it as <code class="calibre23">inline</code> because we’ll benefit from the speed increase without increasing the size of the code much. As I said earlier, this is not strictly necessary with Visual C++. With the definition of the function in the <code class="calibre23">public</code> section of the class, you can use it like this:</p>
<pre class="calibre28"><code class="calibre23">double len {box2.getLength()};         // Obtain data member length</code></pre>
<p class="calibre13">You can write a similar function for each data member that you want to make available to the outside world, and their values can be accessed without prejudicing the security of the class. Of course, if the function definitions are within the class, they will be <code class="calibre23">inline</code> by default.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The friend Functions of a Class</h3>
<p class="calibre13">There will be circumstances when you want certain selected functions that are not members of a class to be able to access all the members of a class &mdash; a sort of elite group with special privileges. Such functions are called <i class="calibre15">friend functions</i> of a class and are defined using the keyword <code class="calibre23">friend</code>. You can either include the prototype of a <code class="calibre23">friend</code> function in the class definition, or you can include the whole function definition. Functions that are friends of a class and are defined within the class definition are also <code class="calibre23">inline</code> by default.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Friend functions are not members of the class, so the access attributes do not apply to them. They are just ordinary global functions with special privileges.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Imagine that you want to implement a friend function in the <code class="calibre23">CBox</code> class to compute the surface area of a <code class="calibre23">CBox</code> object.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a friend function to Calculate the Surface Area</h3>
<p class="calibre20">You can see how a <code class="calibre23">friend</code> function works in the following example:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_08.cpp
// Creating a friend function of a class
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::setw;
 
class CBox                             // Class definition at global scope
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="301" id="calibre_link-763" class="calibre14"></span>{
public:
  // Constructor definition
  Box(double lv, double wv, double hv) :
    m_Length{ lv }, m_Width{ wv }, m_Height{ hv }
          { cout &lt;&lt; "3-arg Constructor called." &lt;&lt; endl; }
 
  explicit CBox(double side) : CBox{ side, side, side } 
          { cout &lt;&lt; "1-arg Constructor called." &lt;&lt; endl; }
 
  CBox() = default;
 
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length*m_Width*m_Height;
  }
 
private:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
 
  // Friend function
  friend double boxSurface(const CBox&amp; aBox);
};
 
// friend function to calculate the surface area of a Box object
double boxSurface(const CBox&amp; aBox)
{
  return 2.0*(aBox.m_Length*aBox.m_Width +
    aBox.m_Length*aBox.m_Height +
    aBox.m_Height*aBox.m_Width);
}
 
int main()
{
  CBox match{ 2.2, 1.1, 0.5 };          // match box using 3-arg constructor
  CBox cube{ 5.0 };                     // Define cube using 1-arg constructor
  CBox box;                             // Define box using default constructor 
 
  cout &lt;&lt; "Volume of match =" &lt;&lt; setw(10) &lt;&lt; match.volume()
       &lt;&lt; "   Surface area = " &lt;&lt; boxSurface(match) &lt;&lt; endl;
 
 
  cout &lt;&lt; setw(16) &lt;&lt; "Volume of cube  =" &lt;&lt; setw(10) &lt;&lt; cube.volume()
    &lt;&lt; "   Surface area = " &lt;&lt; boxSurface(cube) &lt;&lt; endl;
 
  cout &lt;&lt; "Volume of box   =" &lt;&lt; setw(10) &lt;&lt; box.volume()
    &lt;&lt; "   Surface area = " &lt;&lt; boxSurface(box) &lt;&lt; endl;
 
  return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="302" id="calibre_link-764" class="calibre14"></span>This example also calls a constructor in the member initializer list and specifies that the default constructor should be included using the <code class="calibre23">default</code> keyword. The output is something like:</p>
<pre class="calibre28"><code class="calibre23">3-arg Constructor called.
3-arg Constructor called.
1-arg Constructor called.
Volume of match =      1.21   Surface area = 8.14
Volume of cube  =       125   Surface area = 150
Volume of box   =-7.92985e+185   Surface area = 5.14037e+124</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You define the <code class="calibre23">boxSurface()</code> function as a friend of the <code class="calibre23">CBox</code> class by writing the function prototype in the class definition with the keyword <code class="calibre23">friend</code> at the front. The <code class="calibre23">boxSurface()</code> function is global, so it makes no difference where you put the <code class="calibre23">friend</code> definition within the class definition. It’s a good idea to be consistent where you position this sort of definition, though. I chose to position it after all the <code class="calibre23">public</code> and <code class="calibre23">private</code> members of the class. Remember, a friend function isn’t a class member, so access attributes don’t apply.</p>
<p class="calibre20">The <code class="calibre23">friend</code> function definition follows that of the class. You specify access to the data members of the object within the definition of <code class="calibre23">boxSurface()</code>, using the <code class="calibre23">CBox</code> object specified by the parameter. Because a friend function isn’t a class member, the data members can’t be referenced just by their names. They each have to be qualified by an object name in exactly the same way as an ordinary function accesses public members. A friend function is the same as an ordinary function, except that it can access all the members of the class for which it is a friend, without restriction.</p>
<p class="calibre20">The output should be exactly what you would expect. The first line of output is from the constructor that creates the <code class="calibre23">match</code> object. The second line of output is from the call of the three-arg constructor in the constructor initializer list of the one-arg constructor. The third line of output is from the body of the one-arg constructor so this demonstrates that the member initializer list executes before the body of a constructor.</p>
<p class="calibre20">The friend function is computing the surface area of <code class="calibre23">CBox</code> objects from the values of the <code class="calibre23">private</code> data members. In the case of the <code class="calibre23">box</code> object created by the default constructor, the dimensions are junk values so the volume and surface area are also junk.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">Placing friend Function Definitions Inside the Class</h4>
<p class="calibre13">You could combine the definition of the function with its definition as a friend of the <code class="calibre23">CBox</code> class within the class definition, and the code would run as before. The function definition in the class would be:</p>
<pre class="calibre28"><code class="calibre23">friend double boxSurface(const CBox&amp; aBox)
{
  return 2.0*(aBox.m_Length*aBox.m_Width +
              aBox.m_Length*aBox.m_Height +
              aBox.m_Height*aBox.m_Width);
}</code></pre>
<p class="calibre13">However, this has a disadvantage. Although the function still has global scope, this might not be obvious to readers of the code, because the function is buried in the class definition.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="303" id="calibre_link-765" class="calibre24"></span>The Default Copy Constructor</h3>
<p class="calibre13">Suppose you define and initialize a <code class="calibre23">CBox</code> object like this:</p>
<pre class="calibre28"><code class="calibre23">CBox box1 {78.0, 24.0, 18.0};</code></pre>
<p class="calibre13">You now want to create another <code class="calibre23">CBox</code> object, identical to <code class="calibre23">box1</code>. In other words you would like to initialize a new <code class="calibre23">CBox</code> object with <code class="calibre23">box1</code>. Let’s try it.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Copying Information Between Instances</h3>
<p class="calibre20">The following example shows this in action:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_09.cpp
// Initializing an object with an object of the same class
#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
class CBox                             // Class definition at global scope
{
public:
  // Constructor definition
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0) :
             m_Length {lv}, m_Width {wv}, m_Height {hv}  
             {  cout &lt;&lt; "Constructor called." &lt;&lt; endl; }
        
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length*m_Width*m_Height;
  }
        
private:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
};
        
int main()
{
   CBox box1 {78.0, 24.0, 18.0};
   CBox box2 {box1};                   // Initialize box2 with box1
        
   cout &lt;&lt; "box1 volume = " &lt;&lt; box1.volume() &lt;&lt; endl
        &lt;&lt; "box2 volume = " &lt;&lt; box2.volume() &lt;&lt; endl;
        
   return 0;
}</code></pre>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
box1 volume = 33696
box2 volume = 33696</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="304" id="calibre_link-766" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The program is working exactly as you would want, with both boxes having the same volume. However, as you can see from the output, our constructor was called only once &mdash; to create <code class="calibre23">box1</code>. So how was <code class="calibre23">box2</code> created?</p>
<p class="calibre20">The mechanism is similar to when you had no constructor defined. The compiler supplied a default constructor to allow an object to be created. In this instance, the compiler generates a default version of what is referred to as a <i class="calibre15">copy constructor</i>.</p>
<p class="calibre20">A copy constructor does exactly what we’re doing here &mdash; it creates a new object that is a copy of an existing object of the same type. The default version of the copy constructor creates a new object by copying the existing object, member by member.</p>
<p class="calibre20">This is fine for simple classes such as <code class="calibre23">CBox</code>, but for many classes &mdash; classes that have pointers as members, for example &mdash; the default copy constructor won’t work as you would want. Indeed, with such classes the member-by-member copying that is done by the default copy constructor can create serious errors in your program. In these cases, you must create your own copy constructor, which will replace the default version. This requires a special approach that you’ll look into more fully toward the end of this chapter and again in the next chapter.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-288" class="calibre3"></a>THE POINTER THIS</h2>
<p class="calibre13">You wrote the <code class="calibre23">volume()</code> member of the <code class="calibre23">CBox</code> class in terms of the class member names in the definition of the class. Of course, every <code class="calibre23">CBox</code> object that you create contains their own independent set of these members, so there has to be a mechanism for the function to refer to the members of the particular object for which it is called.</p>
<p class="calibre13">When any member function executes, it always contains a hidden pointer with the name <code class="calibre23">this</code>, which contains the address of the object used to call the function. Therefore when the <code class="calibre23">m_Length</code> member name appears in the body of the <code class="calibre23">volume()</code> function, it’s actually <code class="calibre23">this-&gt;m_Length</code>, which is the fully specified reference to the member of the object that is used to call the function. The compiler takes care of adding <code class="calibre23">this</code> to the member names in the function.</p>
<p class="calibre13">You can use <code class="calibre23">this</code> explicitly within a member function if you need to &mdash; when you want to return a pointer to the current object, for example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Explicit Use of this</h3>
<p class="calibre20">You can add a <code class="calibre23">public</code> function to the <code class="calibre23">CBox</code> class that compares the volumes of two <code class="calibre23">CBox</code> objects:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_10.cpp
// Using the pointer this
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="305" id="calibre_link-767" class="calibre14"></span>class CBox                             // Class definition at global scope
{
public:
  // Constructor definition
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0) :
             m_Length {lv}, m_Width {wv}, m_Height {hv}  
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
  }
 
  // Function to calculate the volume of a box
  double volume()
  {
    return m_Length*m_Width*m_Height;
  }
 
  // Function to compare two boxes which returns true
  // if the first is greater than the second, and false otherwise
  bool compare(CBox&amp; xBox)
  {
    return this-&gt;volume() &gt; xBox.volume();
  }
 
private:
  double m_Length;                   // Length of a box in inches
  double m_Width;                    // Width of a box in inches
  double m_Height;                   // Height of a box in inches
};
 
int main()
{
  CBox match {2.2, 1.1, 0.5};           // Define match box
  CBox cigar {8.0, 5.0, 1.0};           // Define cigar box
 
  if(cigar.compare(match))
    cout &lt;&lt; "match is smaller than cigar" &lt;&lt; endl;
  else
    cout &lt;&lt; "match is equal to or larger than cigar" &lt;&lt; endl;
 
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">compare()</code> member returns <code class="calibre23">true</code> if the <code class="calibre23">CBox</code> object for which the member function is called has a greater volume than the <code class="calibre23">CBox</code> object passed as the argument, and <code class="calibre23">false</code> if it doesn’t. The parameter to <code class="calibre23">compare()</code>is a reference type to avoid unnecessary copying of the argument. In the <code class="calibre23">return</code> statement, the prefixed object is referred to through the pointer <code class="calibre23">this</code>, using the indirect member access operator, <code class="calibre23">-&gt;</code>.</p>
<p class="calibre20">Remember that you use the direct member access operator when accessing members through objects and the indirect member access operator when accessing members through pointers to objects. <code class="calibre23">this</code> is a pointer, so you use the <code class="calibre23">-&gt;</code> operator.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="306" id="calibre_link-768" class="calibre14"></span>The <code class="calibre23">-&gt;</code> operator works the same for pointers to class objects as it did when you were dealing with a <code class="calibre23">struct</code>. Using <code class="calibre23">this</code> here demonstrates that it exists and <i class="calibre15">does</i> work, but it’s quite unnecessary to use it explicitly in this case. You could change the <code class="calibre23">return</code> statement in <code class="calibre23">compare()</code>to:</p>
<pre class="calibre28"><code class="calibre23">return volume() &gt; xBox.volume();</code></pre>
<p class="calibre20">You’ll find that the program works just as well. Any references to unadorned member names are automatically the members of the object pointed to by <code class="calibre23">this</code>.</p>
<p class="calibre20">You use the <code class="calibre23">compare()</code> function in <code class="calibre23">main()</code> to check the relationship between the volumes of the objects <code class="calibre23">match</code> and <code class="calibre23">cigar</code>. The output is:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
match is smaller than cigar</code></pre>
<p class="calibre20">This confirms that the <code class="calibre23">cigar</code> object is larger than the <code class="calibre23">match</code> object.</p>
<p class="calibre20">It wasn’t essential to define the <code class="calibre23">compare()</code> function as a class member. You could just as well have written it as an ordinary function with the objects as arguments. Note that this isn’t true of the <code class="calibre23">volume()</code> function because it needs to access the <code class="calibre23">private</code> data members of the class. Of course, if you implemented <code class="calibre23">compare()</code> as an ordinary function, it wouldn’t have access to the pointer <code class="calibre23">this</code>, but it would still be very simple:</p>
<pre class="calibre28"><code class="calibre23">// Comparing two CBox objects - ordinary function version
bool compare(CBox&amp; box1, CBox&amp; box2)
{
 return box1.volume() &gt; box2.volume();
}</code></pre>
<p class="calibre20">This has two <code class="calibre23">CBox</code> objects as arguments and returns <code class="calibre23">true</code> if the volume of the first is greater than the second. You could use this function to perform the same function as in the last example with this statement:</p>
<pre class="calibre28"><code class="calibre23">  if(compare(cigar, match))
     cout &lt;&lt; "match is smaller than cigar" &lt;&lt; endl;
  else
     cout &lt;&lt; "match is equal to or larger than cigar" &lt;&lt; endl;</code></pre>
<p class="calibre20">If anything this looks slightly better and easier to read than the original; however, there’s a much better way to do this, which you’ll learn about in the next chapter.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-289" class="calibre3"></a>CONST OBJECTS</h2>
<p class="calibre13">The <code class="calibre23">volume()</code> function in the <code class="calibre23">CBox</code> class doesn’t alter the object for which it is called; neither does a function such as <code class="calibre23">getHeight()</code> that returns the value of the <code class="calibre23">m_Height</code> member. Likewise, the <code class="calibre23">compare()</code> function in the previous example didn’t change the class objects. This may seem at first sight to be a mildly interesting but largely irrelevant observation, but it isn’t &mdash; it’s quite important. Let’s think about it.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="307" id="calibre_link-769" class="calibre14"></span>You will undoubtedly want to create class objects that are fixed from time to time, just like values such as <code class="calibre23">pi</code> or <code class="calibre23">inchesPerFoot</code> that you might define as <code class="calibre23">const</code>. Suppose you wanted to define a <code class="calibre23">CBox</code> object as <code class="calibre23">const</code> &mdash; because it was a very important standard-sized box, for instance. You might define it with the following statement:</p>
<pre class="calibre28"><code class="calibre23">const CBox standard {3.0, 5.0, 8.0};</code></pre>
<p class="calibre13">Now that you have defined your standard box having dimensions 3 × 5 × 8, you don’t want it changed. In particular, you don’t want to allow the values of its data members to be altered. How can you be sure they won’t be?</p>
<p class="calibre13">Well, you already are. If you define an object as <code class="calibre23">const</code>, the compiler will not allow a member function to be called for it that might alter it. You can demonstrate this quite easily by modifying the definition for the object, <code class="calibre23">cigar</code>, in the previous example to:</p>
<pre class="calibre28"><code class="calibre23">const CBox cigar {8.0, 5.0, 1.0};           // Declare cigar box</code></pre>
<p class="calibre13">If you try to compile the program with this change, you will see the error message:</p>
<pre class="calibre28"><code class="calibre23">error C2662: 'CBox::compare' : cannot convert 'this' pointer
 
from 'const CBox' to 'CBox &amp;' Conversion loses qualifiers</code></pre>
<p class="calibre13">This is caused by the <code class="calibre23">if</code> statement that calls the <code class="calibre23">compare()</code> member of <code class="calibre23">cigar</code>. An object that you define as <code class="calibre23">const</code> will always have a <code class="calibre23">this</code> pointer that is <code class="calibre23">const</code>, so the compiler will not allow any member function to be called that does not assume the <code class="calibre23">this</code> pointer is <code class="calibre23">const</code>. You need to find out how to make the <code class="calibre23">this</code> pointer <code class="calibre23">const</code> in a member function.</p>
<section class="toclist">
<h3 class="calibre21">const Member Functions of a Class</h3>
<p class="calibre13">To make <code class="calibre23">this</code> in a member function <code class="calibre23">const</code>, you must define the function as <code class="calibre23">const</code> in the class definition. Here’s how you do that with the <code class="calibre23">compare()</code> and <code class="calibre23">volume()</code> members of <code class="calibre23">CBox</code>:</p>
<pre class="calibre28"><code class="calibre23">class CBox                             // Class definition at global scope
{
public:
  // Constructor definition
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0) :
             m_Length {lv}, m_Width {wv}, m_Height {hv}  
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
  }
        
  // Function to calculate the volume of a box
  <b class="calibre12">double volume() const</b>
  {
    return m_Length*m_Width*m_Height;
  }
        
  // Function to compare two boxes which returns true (1)
  // if the first is greater than the second, and false (0) otherwise
  <b class="calibre12">bool compare(const CBox&amp; xBox) const</b>
  {
    return this-&gt;volume() &gt; xBox.volume();
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="308" id="calibre_link-770" class="calibre14"></span>}
        
private:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
};</code></pre>
<p class="calibre13">You can find this code in the download as <code class="calibre23">Ex7_10A.cpp</code>. To specify that a member function is <code class="calibre23">const</code>, you append the <code class="calibre23">const</code> keyword to the function header. Note that you can only do this with functions that are class members. It does not apply to ordinary global functions. Declaring a function as <code class="calibre23">const</code> is only meaningful for a function that is a member of a class. The effect is to make the <code class="calibre23">this</code> pointer in the function <code class="calibre23">const</code>. This implies that a data member cannot appear on the left of an assignment within the function definition; it will be flagged as an error by the compiler. A <code class="calibre23">const</code> member function cannot call a non-<code class="calibre23">const</code> member function of the same class because this could potentially modify the object. This means that because <code class="calibre23">compare()</code>calls <code class="calibre23">volume()</code>, the <code class="calibre23">volume()</code> member must be defined as <code class="calibre23">const</code> too. With the <code class="calibre23">volume()</code> function defined as <code class="calibre23">const</code>, you can make the parameter to the <code class="calibre23">compare()</code> function <code class="calibre23">const</code>. When <code class="calibre23">volume()</code> was a non-<code class="calibre23">const</code> member of the class, making the <code class="calibre23">compare()</code> function parameter <code class="calibre23">const</code> would result in a C2662 error message from the compiler. When you define an object as <code class="calibre23">const</code>, the member functions that you call for it must be defined as <code class="calibre23">const</code>; otherwise, the program will not compile. The <code class="calibre23">compare()</code> function now works with <code class="calibre23">const</code> and non-<code class="calibre23">const</code> objects.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Member Function Definitions Outside the Class</h3>
<p class="calibre13">When the definition of a <code class="calibre23">const</code> member function appears outside the class, the header for the definition must have the <code class="calibre23">const</code> keyword added, just as the definition within the class does. You should always define member functions that do not alter the class object for which they are called as <code class="calibre23">const</code>. With this in mind, the <code class="calibre23">CBox</code> class could be defined as:</p>
<pre class="calibre28"><code class="calibre23">class CBox                                 // Class definition at global scope
{
public:
  // Constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0);
        
  double volume() const;                   // Calculate the volume of a box
  bool compare(const CBox&amp; xBox) const;    // Compare two boxes
        
private:
  double m_Length;                         // Length of a box in inches
  double m_Width;                          // Width of a box in inches
  double m_Height;                         // Height of a box in inches
};</code></pre>
<p class="calibre13">This assumes that all function members, including the constructor, are defined outside the class. Both the <code class="calibre23">volume()</code> and <code class="calibre23">compare()</code> members have been defined as <code class="calibre23">const</code>. The <code class="calibre23">volume()</code> function is now defined as:</p>
<pre class="calibre28"><code class="calibre23">double CBox::volume() const
{
  return m_Length*m_Width*m_Height;
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="309" id="calibre_link-771" class="calibre14"></span>The <code class="calibre23">compare()</code> function definition is:</p>
<pre class="calibre28"><code class="calibre23">bool CBox::compare(const CBox&amp; xBox) const
{
  return this-&gt;volume() &gt; xBox.volume();
}</code></pre>
<p class="calibre13">As you can see, the <code class="calibre23">const</code> modifier appears in both definitions. If you leave it out, the code will not compile. A function with a <code class="calibre23">const</code> modifier is a different function from one without, even though the name and parameters are exactly the same. Indeed, you can have both <code class="calibre23">const</code> and non-<code class="calibre23">const</code> versions of a function in a class, and sometimes this can be very useful.</p>
<p class="calibre13">With the class defined as shown, the constructor also needs to be defined separately, like this:</p>
<pre class="calibre28"><code class="calibre23">CBox::CBox(double lv, double wv, double hv):
                  m_Length {lv}, m_Width {wv}, m_Height {hv}
{
  cout &lt;&lt; "Constructor called." &lt;&lt; endl;
}</code></pre>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-290" class="calibre3"></a>ARRAYS OF OBJECTS</h2>
<p class="calibre13">You create an array of objects in exactly the same way as you created an array of elements of a fundamental type. Each element of an array of objects that you don’t initialize will cause the default constructor to be called.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Arrays of Class Objects</h3>
<p class="calibre20">The definition of <code class="calibre23">CBox</code> in this example includes a specific default constructor:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_11.cpp
// Using an array of class objects
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
class CBox                             // Class definition at global scope
{
public:
  // Constructor definition
  explicit CBox(double lv, double wv = 1.0, double hv = 1.0) :
            m_Length{ lv }, m_Width{ wv }, m_Height{ hv }
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
  }
 
  CBox()                             // Default constructor
  {
    cout &lt;&lt; "Default constructor called." &lt;&lt; endl;
    m_Length = m_Width = m_Height = 1.0;
  }
 
    // Function to calculate the volume of a box
    double volume() const
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="310" id="calibre_link-772" class="calibre14"></span>{
      return m_Length*m_Width*m_Height;
    }
  private:
    double m_Length;                   // Length of a box in inches
    double m_Width;                    // Width of a box in inches
    double m_Height;                   // Height of a box in inches
};
int main()
{
  CBox boxes[5];                       // Array of CBox objects defined
  CBox cigar(8.0, 5.0, 1.0);           // Define cigar box
  cout &lt;&lt; "Volume of boxes[3] = " &lt;&lt; boxes[3].volume()&lt;&lt; endl
       &lt;&lt; "Volume of cigar = " &lt;&lt; cigar.volume() &lt;&lt; endl;
 
  return 0;
}</code></pre>
<p class="calibre20">The program produces this output:</p>
<pre class="calibre28"><code class="calibre23">Default constructor called.
Default constructor called.
Default constructor called.
Default constructor called.
Default constructor called.
Constructor called.
Volume of boxes[3] = 1
Volume of cigar = 40</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You have modified the constructor that accepts arguments so that only two default values are supplied, and you have added a default constructor that initializes the data members to 1 after displaying a message that it was called. You are now able to see <i class="calibre15">which</i> constructor was called <i class="calibre15">when</i>. The constructors now have quite distinct parameter lists, so there’s no possibility of the compiler confusing them.</p>
<p class="calibre20">You can see from the output that the default constructor was called five times, once for each element of the <code class="calibre23">boxes</code> array. The other constructor was called to create the <code class="calibre23">cigar</code> object. It’s clear from the output that the default constructor initialization is working satisfactorily, as the volume of the array element <code class="calibre23">boxes[3]</code> is 1.</p>
<p class="calibre20">Of course, you can initialize an array of objects when you define it. For example:</p>
<pre class="calibre28"><code class="calibre23">CBox boxes[5] {CBox {1,2,3},CBox {1,3,2}};</code></pre>
<p class="calibre20">The initial values are defined in an initializer list. The first two elements will be initialized by calling the constructor with three arguments. The remaining three elements will use the default constructor.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-291" class="calibre3"></a>STATIC MEMBERS OF A CLASS</h2>
<p class="calibre13">Both data members and function members of a class can be defined as <code class="calibre23">static</code>. Because the context is a class, there’s a little more to it than the effect of the <code class="calibre23">static</code> keyword outside a class. We’ll look at <code class="calibre23">static</code> data members first.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="311" id="calibre_link-773" class="calibre24"></span>Static Data Members</h3>
<p class="calibre13">When you define a data member of a class to be <code class="calibre23">static</code>, only one instance of the <code class="calibre23">static</code> member is created and this is shared between all objects of the class. Each object gets its own copy of each of the ordinary data members, but only one instance of each <code class="calibre23">static</code> data member exists, regardless of how many class objects have been defined. <a id="calibre_link-1379" href="#calibre_link-410" class="calibre3">Figure 7-7</a> illustrates this.</p>
<figure class="calibre16">
<img class="center" src="images/000034.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-410" href="#calibre_link-1379" class="calibre3">FIGURE 7-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">One use for a <code class="calibre23">static</code> data member is to count how many objects have been created. You could add a <code class="calibre23">static</code> data member to the <code class="calibre23">public</code> section of the <code class="calibre23">CBox</code> class by adding the following statement to the class definition:</p>
<pre class="calibre28"><code class="calibre23">    static int objectCount;                // Count of objects in existence</code></pre>
<p class="calibre13">You now have a problem. How do you initialize the <code class="calibre23">static</code> data member?</p>
<p class="calibre13">You can’t initialize a <code class="calibre23">static</code> data member in the class definition unless it is <code class="calibre23">const</code>, and then only when it is a numeric or enumeration type. You don’t want to initialize <code class="calibre23">objectCount</code> in a constructor, because you want to increment it every time a constructor is called to accumulate the count of the number of objects created. You can’t initialize it in another member function because a member <span {http://www.idpf.org/2007/ops}type="pagebreak" title="312" id="calibre_link-774" class="calibre14"></span>function is associated with an object, and you want it initialized before any objects are created. You can initialize a <code class="calibre23">static</code> data member outside of the class definition though, like this:</p>
<pre class="calibre28"><code class="calibre23">int CBox::objectCount {};         // Initialize static member of CBox class</code></pre>
<p class="calibre13">Notice that the <code class="calibre23">static</code> keyword is not used in the initialization statement; however, you must qualify the member name by using the class name and the scope resolution operator so that the compiler understands that you are referring to a <code class="calibre23">static</code> member of the class. Otherwise, you would simply create a global variable that had nothing to do with the class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Counting Instances of a Class Type</h3>
<p class="calibre20">Let’s add the <code class="calibre23">static</code> data member and the object-counting capability to the previous example.</p>
<pre class="calibre28"><code class="calibre23">// Ex7_12.cpp
// Using a static member to count objects
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
class CBox                             // Class definition at global scope
{
public:
  <b class="calibre12">static int objectCount;</b>              // Count of objects in existence
 
  // Constructor definition
  explicit CBox(double lv, double wv = 1.0, double hv = 1.0) :
              m_Length{ lv }, m_Width{ wv }, m_Height{ hv }
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    <b class="calibre12">objectCount++;</b>
  }
 
  CBox()                               // Default constructor
  {
    cout &lt;&lt; "Default constructor called." &lt;&lt; endl;
    m_Length = m_Width = m_Height = 1.0;
    <b class="calibre12">objectCount++;</b>
  }
 
  // Function to calculate the volume of a box
  double volume() const
  {
    return m_Length*m_Width*m_Height;
  }
 
private:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
};
 
<b class="calibre12">int CBox::objectCount {};</b>              // Initialize static member of CBox class
 
int main()
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="313" id="calibre_link-775" class="calibre14"></span>{
  CBox boxes[5];                       // Array of CBox objects defined
  CBox cigar{ 8.0, 5.0, 1.0 };         // Declare cigar box
 
  <b class="calibre12">cout &lt;&lt;</b> "Number of objects (accessed through class) = "
    <b class="calibre12">&lt;&lt;</b> CBox<b class="calibre12">::objectCount &lt;&lt; endl;</b>
 
  <b class="calibre12">cout &lt;&lt;</b> "Number of objects (accessed through object) = "
    <b class="calibre12">&lt;&lt; boxes[2].objectCount &lt;&lt; endl;</b>
 
  return 0;
}</code></pre>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Default constructor called.
Default constructor called.
Default constructor called.
Default constructor called.
Default constructor called.
Constructor called.
Number of objects (through class) = 6
Number of objects (through object) = 6</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">This code shows that it doesn’t matter how you refer to the <code class="calibre23">static</code> member <code class="calibre23">objectCount</code>, whether through the class itself or any of the objects of that class. The value is the same and it is equal to the number of objects that have been created. The six objects are the five elements of the <code class="calibre23">boxes</code> array, plus the <code class="calibre23">cigar</code> object. It’s interesting to note that <code class="calibre23">static</code> members of a class exist even though there may be no instances of the class defined. This is evidently the case, because you initialized the <code class="calibre23">static</code> member <code class="calibre23">objectCount</code> before any class objects were defined.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Static data members are automatically created when your program begins, and they will be initialized with 0 or its equivalent unless you initialize them with some other value. Thus, you need only to initialize</i> <code class="calibre23">static</code> <i class="calibre15">data members of a class if you want them to start out with a value other than 0. However, you still need to define them. For example:</i></p>
<pre class="calibre28"><code class="calibre23">int CBox::objectCount;</code></pre>
<p class="calibre20"><i class="calibre15">This defines</i> <code class="calibre23">objectCount</code> <i class="calibre15">but does not initialize it explicitly so the value will be 0 by default.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Static Function Members of a Class</h3>
<p class="calibre13">By declaring a function member as <code class="calibre23">static</code>, you make it independent of any objects of the class type. Consequently it does not have the pointer <code class="calibre23">this</code>. A <code class="calibre23">static</code> member function has the advantage that it exists, and can be called, even if no class objects exist. In this case, only <code class="calibre23">static</code> data members can <span {http://www.idpf.org/2007/ops}type="pagebreak" title="314" id="calibre_link-776" class="calibre14"></span>be accessed because they are the only ones that exist. Thus, you can call a <code class="calibre23">static</code> function member of a class to examine <code class="calibre23">static</code> data members, even when you do not know for certain that any objects of the class exist. You could therefore use a <code class="calibre23">static</code> member function to determine whether any objects of the class have been created or how many have been created.</p>
<p class="calibre13">Here’s an example of a prototype for a static function:</p>
<pre class="calibre28"><code class="calibre23">static void aFunction(int n);</code></pre>
<p class="calibre13">A static function can be called in relation to a particular object by a statement such as the following:</p>
<pre class="calibre28"><code class="calibre23">aBox.aFunction(10);</code></pre>
<p class="calibre13">The function has no access to the non-<code class="calibre23">static</code> members of <code class="calibre23">aBox</code>. The same function could also be called without reference to an object. In this case, the statement would be:</p>
<pre class="calibre28"><code class="calibre23">CBox::aFunction(10);</code></pre>
<p class="calibre13">The class name qualifies the function. Using the class name and the scope resolution operator tells the compiler to which class <code class="calibre23">aFunction()</code> belongs.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-292" class="calibre3"></a>POINTERS AND REFERENCES TO OBJECTS</h2>
<p class="calibre13">Using pointers and references to class objects, is very important in object-oriented programming, particularly in the specification of function parameters. Class objects can involve considerable amounts of data, so using the pass-by-value mechanism for them can be very time-consuming and inefficient because each object that is passed to a function in this way will be copied. Using reference parameters avoids this overhead and reference parameters are essential to some operations with classes. As you’ll see, it’s not possible to write a copy constructor without using a reference parameter.</p>
<section class="toclist">
<h3 class="calibre21">Pointers to Objects</h3>
<p class="calibre13">You define a pointer to an object in the same way that you define other pointers. For example, a pointer to objects of type <code class="calibre23">CBox</code> is defined in this statement:</p>
<pre class="calibre28"><code class="calibre23">CBox* pBox {};               // Declare a pointer to CBox - initialized to nullptr</code></pre>
<p class="calibre13">You can use this to store the address of a <code class="calibre23">CBox</code> object in an assignment in the usual way, using the address operator:</p>
<pre class="calibre28"><code class="calibre23">pBox = &amp;cigar;               // Store address of CBox object cigar in pBox</code></pre>
<p class="calibre13">As you saw when you used the <code class="calibre23">this</code> pointer in the <code class="calibre23">compare()</code> member function, you can call a function using a pointer to an object. You can call the <code class="calibre23">volume()</code> function for the pointer <code class="calibre23">pBox</code> like this:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; pBox-&gt;volume();      // Display volume of object pointed to by pBox</code></pre>
<p class="calibre13">This uses the indirect member selection operator. This is the typical notation used for this kind of operation, <i class="calibre15">so from now on, I’ll use it universally</i>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="315" id="calibre_link-777" class="calibre24"></span>TRY IT OUT: Pointers to Classes</h3>
<p class="calibre20">Let’s try exercising the indirect member access operator a little more. We will use the example <code class="calibre23">Ex7_10.cpp</code> as a base, but change it a little:</p>
<pre class="calibre28"><code class="calibre23">// Ex7_13.cpp
// Exercising the indirect member access operator
#include &lt;iostream&gt;
using std::cout;
using std::endl;
 
class CBox                             // Class definition at global scope
{
  public:
    // Constructor definition
    explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0) :
              m_Length{ lv }, m_Width{ wv }, m_Height{ hv }
    {
      cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    }
 
    // Function to calculate the volume of a box
    double volume() const 
    {
      return m_Length*m_Width*m_Height;
    }
 
    // Function to compare two boxes which returns true
    // if the first is greater than the second, and false otherwise
    bool compare(const CBox* pBox) const 
    {
      if(!pBox)
        return false;
      return this-&gt;volume() &gt; pBox-&gt;volume();
    }
  private:
    double m_Length;                   // Length of a box in inches
    double m_Width;                    // Width of a box in inches
    double m_Height;                   // Height of a box in inches
};
int main()
{
  CBox boxes[5];                       // Array of CBox objects defined
  CBox match {2.2, 1.1, 0.5};          // Declare match box
  CBox cigar {8.0, 5.0, 1.0};          // Declare cigar Box
  CBox* pB1 {&amp;cigar};                  // Initialize pointer to cigar object address
  CBox* pB2 {};                        // Pointer to CBox initialized to nullptr
  cout &lt;&lt; "Address of cigar is " &lt;&lt; pB1 &lt;&lt; endl     // Display address
       &lt;&lt; "Volume of cigar is " &lt;&lt; pB1-&gt;volume()    // Volume of object pointed to
       &lt;&lt; endl;                    
  pB2 = &amp;match;
 
  if(pB2-&gt;compare(pB1))                     // Compare via pointers
    cout &lt;&lt; "match is greater than cigar" &lt;&lt; endl;
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="316" id="calibre_link-778" class="calibre14"></span>else
    cout &lt;&lt; "match is less than or equal to cigar" &lt;&lt; endl;
 
  pB1 = boxes;                              // Set to address of array
  boxes[2] = match;                         // Set 3rd element to match
 
  // Now access through pointer
  cout &lt;&lt; "Volume of boxes[2] is " &lt;&lt; (pB1 + 2)-&gt;volume() &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">When you run the example, the output looks something like this:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Constructor called.
Constructor called.
Constructor called.
Constructor called.
Constructor called.
Address of cigar is 00B3FA5C
Volume of cigar is 40
match is less than or equal to cigar
Volume of boxes[2] is 1.21</code></pre>
<p class="calibre20">The address for <code class="calibre23">cigar</code> is likely to be different on your PC.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The only change to the class isn’t of great substance. I modified the <code class="calibre23">compare()</code> function to accept a pointer to a <code class="calibre23">CBox</code> object as an argument. You have an <code class="calibre23">if</code> statement in the function that guards against the possibility for the argument to be <code class="calibre23">nullptr. compare()</code> is defined as <code class="calibre23">const</code> because it doesn’t alter the object. The <code class="calibre23">main()</code> function merely exercises pointers to <code class="calibre23">CBox</code> type objects in various, rather arbitrary, ways.</p>
<p class="calibre20">Within <code class="calibre23">main()</code>, you define two pointers to <code class="calibre23">CBox</code> objects after declaring an array, <code class="calibre23">boxes</code>, and the <code class="calibre23">CBox</code> objects <code class="calibre23">cigar</code> and <code class="calibre23">match</code>. The first, <code class="calibre23">pB1</code>, is initialized with the address of the <code class="calibre23">cigar</code> object, and the second, <code class="calibre23">pB2</code>, is initialized to <code class="calibre23">nullptr</code>. All of this uses the pointer in exactly the same way you would use a pointer to a basic type. The fact that you are using a pointer to a class type makes no difference.</p>
<p class="calibre20">You use <code class="calibre23">pB1</code> with the indirect member access operator to generate the volume of the object pointed to, and the result is displayed. You then assign the address of <code class="calibre23">match</code> to <code class="calibre23">pB2</code> and use both pointers in calling the compare function. Because the parameter for <code class="calibre23">compare()</code> is a pointer to a <code class="calibre23">CBox</code> object, the function uses the indirect member selection operator to call the <code class="calibre23">volume()</code> function for the argument.</p>
<p class="calibre20">To demonstrate that you can use address arithmetic on the pointer <code class="calibre23">pB1</code> when using it to select a member function, you set <code class="calibre23">pB1</code> to the address of the first element of the <code class="calibre23">CBox</code> array, <code class="calibre23">boxes</code>. In this case, you select the third element of the array and calculate its volume. This is the same as the volume of <code class="calibre23">match</code>.</p>
<p class="calibre20">You can see from the output that there were seven constructor calls, five for the <code class="calibre23">boxes</code> array, plus one each for the objects <code class="calibre23">cigar</code> and <code class="calibre23">match</code>. Overall, there’s virtually no difference between using a pointer to a class object and using a pointer to a primitive type, such as <code class="calibre23">double</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="317" id="calibre_link-779" class="calibre24"></span>References to Class Objects</h3>
<p class="calibre13">References really come into their own when they are used with classes. As with pointers, there is no difference between the way you define and use references to class objects and the way in which you have already defined and used references to variables of primitive types. To define a reference to the object <code class="calibre23">cigar</code>, for instance, you would write this:</p>
<pre class="calibre28"><code class="calibre23">CBox&amp; rcigar {cigar};                  // Define reference to object cigar</code></pre>
<p class="calibre13">To use a reference to calculate the volume of the object <code class="calibre23">cigar</code>, you would just use the reference name where the object name would otherwise appear:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; rcigar.volume();               // Output volume of cigar thru a reference</code></pre>
<p class="calibre13">As you may remember, a reference acts as an alias for the object it refers to, so the usage is exactly the same as using the original object name.</p>
<section class="toclist">
<h4 class="calibre22">Implementing a Copy Constructor</h4>
<p class="calibre13">References are of major importance in the context of parameters and return values in functions, particularly class member functions. Let’s return to the copy constructor as a first toe in the water. For the moment, I’ll sidestep the question of <i class="calibre15">when</i> you need to write your own copy constructor and concentrate on the problem of <i class="calibre15">how</i> you write it. I’ll use the <code class="calibre23">CBox</code> class to make the discussion more concrete.</p>
<p class="calibre13">The copy constructor is a constructor that creates a new object from an existing object of the same type. It therefore needs to accept an object of the class as an argument. You might consider writing the prototype like this:</p>
<pre class="calibre28"><code class="calibre23">CBox(CBox initB);</code></pre>
<p class="calibre13">Now, think about what happens when this constructor is called. Suppose you write this definition:</p>
<pre class="calibre28"><code class="calibre23">CBox myBox {cigar};</code></pre>
<p class="calibre13">This generates a call of the copy constructor. This seems to be no problem, until you realize that the argument is passed by value. So, before <code class="calibre23">cigar</code> can be passed to the constructor, the compiler needs to arrange to make a copy of it. Naturally, it calls the copy constructor to make a copy of the argument to the copy constructor. Unfortunately, since it is passed by value, this call also needs a copy of its argument to be made, so the copy constructor is called again, and so on and so on. You end up with an infinite number of calls to the copy constructor.</p>
<p class="calibre13">The solution, as I’m sure you’ll have guessed, is to use a <code class="calibre23">const</code> reference parameter. You can write the prototype of the copy constructor like this:</p>
<pre class="calibre28"><code class="calibre23">CBox(const CBox&amp; initB);</code></pre>
<p class="calibre13">Now, the argument to the copy constructor doesn’t need to be copied. The argument is used to initialize the reference parameter so no copying takes place. As you remember from the discussion on references, if a parameter to a function is a reference, no copying of the argument occurs when the function is called. The function accesses the argument in the caller function directly. The <code class="calibre23">const</code> qualifier ensures that the argument can’t be modified by the function.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="318" id="calibre_link-780" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">This is another important use of the</i> <code class="calibre23">const</code> <i class="calibre15">qualifier. You should always define a reference parameter of a function as</i> <code class="calibre23">const</code> <i class="calibre15">unless the function will modify it.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You could implement the copy constructor as follows:</p>
<pre class="calibre28"><code class="calibre23">CBox::CBox(const CBox&amp; initB) : 
     m_Length {initB.m_Length}, m_Width {initB.m_Width}, m_Height {initB.m_Height}
{}</code></pre>
<p class="calibre13">This definition assumes that it appears outside of the class definition. The constructor name is qualified with the class name using the scope resolution operator. Each data member of the object being created is initialized with the corresponding member of the object passed as the argument in the member initialization list.</p>
<p class="calibre13">The <code class="calibre23">CBox</code> class is not an example of when you need to write a copy constructor. As you have seen, the default copy constructor works perfectly well with <code class="calibre23">CBox</code> objects. I will get to <i class="calibre15">why</i> and <i class="calibre15">when</i> you need to write your own copy constructor in the next chapter.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-293" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">You now understand the basic ideas of classes. You’re going to see more and more about using classes throughout the rest of the book.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Define a struct <code class="calibre23">Sample</code> that contains two integer data items. Write a program that defines two objects of type <code class="calibre23">Sample</code>, called <code class="calibre23">a</code> and <code class="calibre23">b</code>. Set values for the data items that belong to <code class="calibre23">a</code> and then check that you can copy the values into <code class="calibre23">b</code> by simple assignment.</li>
<li class="calibre6">Add a <code class="calibre23">char*</code> member to the <code class="calibre23">Sample</code> struct in the previous exercise called <code class="calibre23">sPtr</code>. When you fill in the data for <code class="calibre23">a</code>, dynamically create a string buffer initialized with <code class="calibre23">"Hello World!"</code> and make <code class="calibre23">a.sPtr</code> point to it. Copy <code class="calibre23">a</code> into <code class="calibre23">b</code>. What happens when you change the contents of the character buffer pointed to by <code class="calibre23">a.sPtr</code> and then output the contents of the string pointed to by <code class="calibre23">b.sPtr</code>? Explain what is happening. How would you get around this?</li>
<li class="calibre6">Create a function that accepts a pointer to an object of type <code class="calibre23">Sample</code> as an argument and that outputs the values of the members of the object that is passed to it. Test this function by extending the program that you created for the previous exercise.</li>
<li class="calibre6">Define a class <code class="calibre23">CRecord</code> with two <code class="calibre23">private</code> data members that store a name up to 14 characters long and an integer item number. Define a <code class="calibre23">getRecord()</code> function member of the <code class="calibre23">CRecord</code> class that will set values for the data members by reading input from the keyboard, and a <code class="calibre23">putRecord()</code> function member that outputs the values of the data members. Implement <span {http://www.idpf.org/2007/ops}type="pagebreak" title="319" id="calibre_link-781" class="calibre14"></span>the <code class="calibre23">getRecord()</code> function so that a calling program can detect when a zero item-number is entered. Test your <code class="calibre23">CRecord</code> class with a <code class="calibre23">main()</code> function that reads and outputs <code class="calibre23">CRecord</code> objects until a zero item-number is entered.</li>
<li class="calibre6">Define a class to represent a push-down stack of integers. A stack is a list of items that permits adding (“pushing”) or removing (“popping”) items only from one end and works on a last-in, first-out principle. For example, if the stack contained [10 4 16 20], <code class="calibre23">pop()</code> would return 10, and the stack would then contain [4 16 20]; a subsequent <code class="calibre23">push(13)</code> would leave the stack as [13 4 16 20]. You can’t get at an item that is not at the top without first popping the ones above it. Your class should implement <code class="calibre23">push()</code> and <code class="calibre23">pop()</code> functions, plus a <code class="calibre23">print()</code> function so that you can check the stack contents. Store the list internally as an array, for now. Write a test program to verify the correct operation of your class.</li>
<li class="calibre6">What happens with your solution to the previous exercise if you try to pop more items than you’ve pushed, or save more items than you have space for? Can you think of a robust way to trap this? Sometimes, you might want to look at the number at the top of the stack without removing it; implement a <code class="calibre23">peek()</code> function to do this.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="320" id="calibre_link-782" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Classes</b></td>
<td class="calibre32">A class provides a means of defining your own data types. They can reflect whatever types of objects your particular problem requires.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Class members</b></td>
<td class="calibre32">A class can contain data members and function members. The function members of a class always have free access to the data members of the same class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Class constructors</b></td>
<td class="calibre32">Objects of a class are created and initialized using member functions called constructors. A constructor is called automatically when you define an object. Constructors may be overloaded to provide different ways of initializing an object.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The default constructor</b></td>
<td class="calibre32">The compiler will supply a default constructor in a class that has no constructors defined. The default constructor has no parameters and does nothing. Defining any constructor in a class inhibits the insertion of the default constructor so if you need it, you must specify it.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Explicit constructors</b></td>
<td class="calibre32">Constructors specified using the <code class="calibre23">explicit</code> keyword can only be called explicitly, and therefore cannot be used for implicit conversions from another type. This is only relevant for one-arg constructors and constructors with multiple default arguments.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Member initializer list</b></td>
<td class="calibre32">Class members can be initialized in a member initializer list in the constructor header. Initializing members in this way is more efficient than using assignments in the body of the constructor.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Delegating constructors</b></td>
<td class="calibre32">A constructor can call another constructor in the same class, but only in its constructor initializer list. The constructor call must be the only thing in the initializer list.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Class member access</b></td>
<td class="calibre32">Members of a class can be specified as <code class="calibre23">public</code>, in which case, they are freely accessible by any function in a program. Members may be specified as <code class="calibre23">private</code>, in which case, they may only be accessed by member functions or friend functions of the class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Static class members</b></td>
<td class="calibre32">Members of a class can be defined as <code class="calibre23">static</code>. Only one instance of each <code class="calibre23">static</code> data member of a class exists, which is shared amongst all instances of the class, no matter how many objects of the class are created.<br class="calibre10" />Static function members have no <code class="calibre23">this</code> pointer.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The pointer <code class="calibre23">this</code></b></td>
<td class="calibre32">Every non-static function of a class contains the pointer <code class="calibre23">this</code>, which points to the object for which the function was called.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="321" id="calibre_link-783" class="calibre14"></span><b class="calibre12"><code class="calibre23">const</code> member functions</b></td>
<td class="calibre32">A member function that is defined as <code class="calibre23">const</code> has a <code class="calibre23">const this</code> pointer, and therefore cannot modify data members of the object for which it is called.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Calling <code class="calibre23">const</code> member functions</b></td>
<td class="calibre32">A member function that is defined as <code class="calibre23">const</code> cannot call another member function that is not <code class="calibre23">const</code>. You cannot call a non-<code class="calibre23">const</code> member function for a <code class="calibre23">const</code> object.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Passing objects to a function by reference</b></td>
<td class="calibre32">Using references to class objects as arguments to function calls can avoid substantial overhead in passing complex objects to a function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The copy constructor</b></td>
<td class="calibre32">A copy constructor duplicates an existing object of the same class type. A copy constructor always has its parameter specified as a <code class="calibre23">const</code> reference.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="322" id="calibre_link-784" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-294">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2321" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="323" id="calibre_link-785" class="calibre9"></span><span class="chapternumber">Chapter 8</span><br class="calibre10" /><span class="chapternumber">More on Classes</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">What a destructor is and when and why you need to define it</li>
<li class="calibre6">How to implement a destructor</li>
<li class="calibre6">How to create class data members in the free store and how to delete them</li>
<li class="calibre6">When you must write a copy constructor for a class</li>
<li class="calibre6">How to make class objects work with operators such as + or *</li>
<li class="calibre6">How to use rvalue reference parameters to avoid unnecessary copying of class objects</li>
<li class="calibre6">What class templates are and how you define and use them</li>
<li class="calibre6">What template specializations are and how they are defined</li>
<li class="calibre6">What perfect forwarding is and how you can achieve it</li>
<li class="calibre6">How to use the standard <code class="calibre23">string</code> class for string operations</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 8 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-295" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="324" id="calibre_link-786" class="calibre18"></span>CLASS DESTRUCTORS</h2>
<p class="calibre13">Although this section heading relates to destructors, it’s also about dynamic memory allocation. When you allocate memory in the free store for class members, you are usually obliged to make use of a destructor, in addition to a constructor, of course. As you’ll see, dynamically allocating memory for class members will also require you to write a copy constructor.</p>
<section class="toclist">
<h3 class="calibre21">What Is a Destructor?</h3>
<p class="calibre13">A <i class="calibre15">destructor</i> is a function that destroys objects when they are no longer required or when they go out of scope. The class destructor is called automatically when an object goes out of scope. Destroying an object involves freeing the memory occupied by the data members of the object (except for static members, which continue to exist even when there are no class objects in existence). The class destructor is a member function with a name that is a tilde (<code class="calibre23">~</code>) followed by the class name. A destructor doesn’t return a value and doesn’t have parameters. For example, the prototype for the <code class="calibre23">CBox</code> class destructor is:</p>
<pre class="calibre28"><code class="calibre23">~CBox();                 // Class destructor prototype</code></pre>
<p class="calibre13">Because a destructor has a specific name and no parameters, there can only ever be one destructor in a class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">It’s an error to specify a return value or parameters for a destructor.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The Default Destructor</h3>
<p class="calibre13">All the objects that you have been using up to now have been destroyed automatically by the <i class="calibre15">default destructor</i> for the class. The default destructor is always generated automatically by the compiler if you do not define your own destructor. The default destructor doesn’t delete objects or object members that have been allocated in the free store. If space for class members has been allocated dynamically in a constructor, then you should define a destructor that will release the memory that has been allocated, just as you would with ordinary variables. You need some practice in writing destructors, so let’s try it out.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In Chapter 10 you’ll learn about smart pointers that automatically release heap memory when it is no longer required. This can eliminate the need for a destructor in many instances.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: A Simple Destructor</h3>
<p class="calibre20">To get an appreciation of when the destructor for a class is called, you can include a destructor in the <code class="calibre23">CBox</code> class. Here’s the example:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_01.cpp
// Class with an explicit destructor
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="325" id="calibre_link-787" class="calibre14"></span>#include &lt;iostream&gt;
using std::cout;
using std::endl;
        
class CBox                     // Class definition at global scope
{
public:
  // Destructor definition
  ~CBox()
  {
    cout &lt;&lt; "Destructor called." &lt;&lt; endl;
  }
        
  // Constructor definition
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                                  m_Length {lv}, m_Width {wv}, m_Height {hv}
  {
    cout &lt;&lt; "Constructor called." &lt;&lt; endl;
  }
        
  // Function to calculate the volume of a box
  double volume() const
  {
    return m_Length*m_Width*m_Height;
  }
        
  // Function to compare two boxes which returns true
  // if the first is greater than the second, and false otherwise
  bool compare(const CBox* pBox) const
  {
    if(!pBox)
      return false;
    return this-&gt;volume() &gt; pBox-&gt;volume();
  }
        
  private:
    double m_Length;            // Length of a box in inches
    double m_Width;             // Width of a box in inches
    double m_Height;            // Height of a box in inches
};
        
// Function to demonstrate the CBox class destructor in action
int main()
{
  CBox boxes[5];                // Array of CBox objects defined
  CBox cigar {8.0, 5.0, 1.0};   // Declare cigar box
  CBox match {2.2, 1.1, 0.5};   // Declare match box
  CBox* pB1 {&amp;cigar};           // Initialize pointer to cigar object address
  CBox* pB2 {};                 // Pointer to CBox initialized to nullptr
        
  cout &lt;&lt; "Volume of cigar is " &lt;&lt; pB1-&gt;volume() &lt;&lt; endl;     
        
  pB2 = boxes;                  // Set to address of array
  boxes[2] = match;             // Set 3rd element to match
 
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="326" id="calibre_link-788" class="calibre14"></span>cout &lt;&lt; "Volume of boxes[2] is " &lt;&lt; (pB2 + 2)-&gt;volume() &lt;&lt; endl; 
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">CBox</code> class destructor just displays a message showing that it was called. The output is:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Constructor called.
Constructor called.
Constructor called.
Constructor called.
Constructor called.
Volume of cigar is 40
Volume of boxes[2] is 1.21
Destructor called.
Destructor called.
Destructor called.
Destructor called.
Destructor called.
Destructor called.
Destructor called.</code></pre>
<p class="calibre20">There’s one destructor call for each of the objects that exist when <code class="calibre23">main()</code> ends. For each constructor call, there’s a matching destructor call. You don’t need to call the destructor explicitly here. The compiler arranges for the destructor to be called when an object needs to be destroyed. In our example, the destructor calls occur after <code class="calibre23">main()</code> has finished executing, so it’s possible for an error in a destructor to cause a program to crash after <code class="calibre23">main()</code> has terminated.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Destructors and Dynamic Memory Allocation</h3>
<p class="calibre13">You will often want to allocate memory for class data members dynamically. You can use the <code class="calibre23">new</code> operator in a constructor to allocate memory for an object member. In such a case, you are responsible for releasing the memory when the object is no longer required by providing a suitable destructor (or possibly use a smart pointer, which you will learn about in Chapter 10). Let’s first define a simple class where we can do this.</p>
<p class="calibre13">Suppose you define a class where each object is a message of some description &mdash; for example, a text string. The class should be as memory-efficient as possible, so, rather than defining a data member as a <code class="calibre23">char</code> array big enough to hold the maximum length string that you might require, you’ll allocate memory for the message when an object is created. Here’s the class definition:</p>
<pre class="calibre28"><code class="calibre23">//Listing 08_02_1
class CMessage
{
  private:
    char* m_pMessage;                   // Pointer to object text string
        
  public:
        
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="327" id="calibre_link-789" class="calibre14"></span>// Function to display a message
    void showIt() const
    {
      cout &lt;&lt; m_pMessage &lt;&lt; endl;
    }
        
    // Constructor definition
    CMessage(const char* text = "Default message")
    {
      size_t length {strlen(text) + 1};
      m_pMessage = new char[length + 1];        // Allocate space for text
      strcpy_s(m_pMessage, length + 1, text);   // Copy text to new memory
    }
        
    ~CMessage();                                // Destructor prototype
};</code></pre>
<p class="calibre13">The class has only one data member, <code class="calibre23">m_pMessage</code>, which is a pointer to a string. This is in the <code class="calibre23">private</code> section of the class, so it can’t be accessed from outside the class.</p>
<p class="calibre13">In the <code class="calibre23">public</code> section, you have the <code class="calibre23">showIt()</code> function that outputs the string for a <code class="calibre23">CMessage</code> object. You also have a constructor definition and the prototype for the destructor, <code class="calibre23">~CMessage()</code>, which I’ll come to in a moment.</p>
<p class="calibre13">The constructor requires a string as an argument, but if none is passed, it uses the default string that is specified for the parameter. The constructor obtains the length of the argument string using the library function <code class="calibre23">strlen()</code> that is declared in the <code class="calibre23">cstring</code> header and allocates sufficient space for it in the free store. Of course, if the memory allocation fails, an exception will be thrown that will terminate the program. If you want to manage such a failure to provide a more graceful end to the program, you would catch the exception within the constructor code. Chapter 6 explained how you can handle out-of-memory conditions.</p>
<p class="calibre13">You use the <code class="calibre23">strcpy_s()</code> library function that is also declared in the <code class="calibre23">cstring</code> header file to copy the argument string to the memory allocated for it. <code class="calibre23">strcpy_s()</code>copies the string specified by the third argument to the address contained in the first argument. The second argument is the length of the destination location.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">cstring</code> <i class="calibre15">header declares functions that are from the C runtime library, which is not defined within a namespace, so you can use the function names without qualifying them with a namespace name. Because they are also part of the C++ standard library, the names are also defined within the</i> <code class="calibre23">std</code> <i class="calibre15">namespace, so if you want to qualify them with</i> <code class="calibre23">std</code>, <i class="calibre15">you can</i>. <code class="calibre23">strcpy_s()</code> <i class="calibre15">is Microsoft-specific and not a standard library function so you must not qualify the name with</i> <code class="calibre23">std</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You need a destructor that will free the memory allocated for a message. If you don’t provide a destructor, there’s no way to delete the memory allocated for an object. If you use this class as it stands to create many <code class="calibre23">CMessage</code> objects, the free store will be gradually eaten away until the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="328" id="calibre_link-790" class="calibre14"></span>program fails. It’s easy for this to occur in circumstances where it may not be obvious. For example, if you create a temporary <code class="calibre23">CMessage</code> object in a function that is called many times in a program, you might assume that the objects are being destroyed at the return from the function. You’d be right about that, but the free store memory will not be released. Thus, for each call of the function, more of the free store would be occupied by memory for discarded <code class="calibre23">CMessage</code> objects.</p>
<p class="calibre13">The code for the <code class="calibre23">CMessage</code> class destructor is:</p>
<pre class="calibre28"><code class="calibre23">// Listing 08_02_2
// Destructor to free memory allocated by new
CMessage::~CMessage()
{
  cout &lt;&lt; "Destructor called." &lt;&lt; endl;    // Just to track what happens
  delete[] m_pMessage;                     // Free memory assigned to pointer
}</code></pre>
<p class="calibre13">Because you’re defining the destructor outside the class, you must qualify the destructor name with the class name, <code class="calibre23">CMessage</code>. The destructor displays a message so that you can see when it is called, and then uses the <code class="calibre23">delete</code> operator to free the memory pointed to by <code class="calibre23">m_pMessage</code>. Note that you must include the square brackets with <code class="calibre23">delete</code> because you’re deleting an array (of type <code class="calibre23">char[]</code>).</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using the CMessage Class</h3>
<p class="calibre20">You can exercise the <code class="calibre23">CMessage</code> class with a little example:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_02.cpp
// Using a destructor to free memory
#include &lt;iostream&gt;          // For stream I/O
#include &lt;cstring&gt;           // For strlen() and strcpy()
using std::cout;
using std::endl;
        
// Put the CMessage class definition here (Listing 08_02_1)
        
// Put the destructor definition here (Listing 08_02_2)
        
int main()
{
  // Declare object
  CMessage motto {"A miss is as good as a mile."};
        
  // Dynamic object
  CMessage* pM {new CMessage {"A cat can look at a queen."}};
        
  motto.showIt();            // Display 1st message
  pM-&gt;showIt();              // Display 2nd message
        
  delete pM;                 // Manually delete object created with new
  return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="329" id="calibre_link-791" class="calibre14"></span>Replace the comments in the code with the <code class="calibre23">CMessage</code> class and destructor definitions from the previous section; it won’t compile without this (the source code in the download contains all the code for the example).</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">At the beginning of <code class="calibre23">main()</code>, you define an initialized <code class="calibre23">CMessage</code> object, <code class="calibre23">motto</code>, in the usual manner. In the second declaration, you define a pointer to a <code class="calibre23">CMessage</code> object, <code class="calibre23">pM</code>, and allocate memory for the <code class="calibre23">CMessage</code> object that is pointed to by using the operator <code class="calibre23">new</code>. The call to <code class="calibre23">new</code> invokes the <code class="calibre23">CMessage</code> class constructor, which has the effect of calling <code class="calibre23">new</code> again to allocate space for the message text pointed to by the data member <code class="calibre23">m_pMessage</code>. If you build and execute this example, it will produce the following output:</p>
<pre class="calibre28"><code class="calibre23">A miss is as good as a mile.
A cat can look at a queen.
Destructor called.
Destructor called.</code></pre>
<p class="calibre20">You have two destructor calls recorded in the output, one for each of the two <code class="calibre23">CMessage</code> objects. I said earlier that the compiler doesn’t take responsibility for objects created in the free store. The compiler arranged to call your destructor for the object <code class="calibre23">motto</code> because this is a normal, automatic object, even though the memory for the data member was allocated in the free store by the constructor. The object pointed to by <code class="calibre23">pM</code> is different. You allocated memory for the object in the free store, so you have to use <code class="calibre23">delete</code> to remove it. Try commenting out the statement that appears just before the <code class="calibre23">return</code> statement in <code class="calibre23">main()</code>:</p>
<pre class="calibre28"><code class="calibre23">  // delete pM;               // Manually delete object created with new</code></pre>
<p class="calibre20">If you run the code now, it will produce this output:</p>
<pre class="calibre28"><code class="calibre23">A miss is as good as a mile.
A cat can look at a queen.
Destructor called.</code></pre>
<p class="calibre20">Now you get just one call of your destructor. This is surprising in a way. Clearly, <code class="calibre23">delete</code> is only dealing with the memory allocated by the call to <code class="calibre23">new</code> in the function <code class="calibre23">main()</code>. It only freed the memory pointed to by <code class="calibre23">pM</code>. Because your pointer <code class="calibre23">pM</code> points to a <code class="calibre23">CMessage</code> object (for which a destructor has been defined), <code class="calibre23">delete</code> also calls your destructor to allow you to release the memory for the members of the object. So when you use <code class="calibre23">delete</code> for an object created dynamically, it will always call the destructor for the object before releasing the memory that the object occupies. This ensures that any memory allocated dynamically for class members will also be freed.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-296" class="calibre3"></a>IMPLEMENTING A COPY CONSTRUCTOR</h2>
<p class="calibre13">When you allocate space for class members dynamically, there are demons lurking in the free store. For the <code class="calibre23">CMessage</code> class, the default copy constructor is woefully inadequate. Suppose you write these statements:</p>
<pre class="calibre28"><code class="calibre23">CMessage motto1 {"Radiation fades your genes."};
CMessage motto2 {motto1};     // Calls the default copy constructor</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="330" id="calibre_link-792" class="calibre14"></span>The default copy constructor will copy the address that is stored in the pointer member of the class from <code class="calibre23">motto1</code> to <code class="calibre23">motto2</code> because the copying process implemented by the default copy constructor just copies the values of the data members of the original object to the new object. Consequently, there will be only one text string shared between the two objects, as <a id="calibre_link-1363" href="#calibre_link-411" class="calibre3">Figure 8-1</a> illustrates.</p>
<figure class="calibre16">
<img class="center" src="images/000072.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-411" href="#calibre_link-1363" class="calibre3">FIGURE 8-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">If the string is changed for either object, it will be changed for the other object too, because both objects share the same string. If <code class="calibre23">motto1</code> is destroyed, the pointer in <code class="calibre23">motto2</code> will contain the address of memory that has been released, which may now be used for something else, so chaos will surely ensue. Of course, the same problem arises if <code class="calibre23">motto2</code> is deleted; <code class="calibre23">motto1</code> would contain a member pointing to a non-existent string.</p>
<p class="calibre13">The solution is to supply a copy constructor to replace the default version. You could implement this in the <code class="calibre23">public</code> section of the class as:</p>
<pre class="calibre28"><code class="calibre23">CMessage(const CMessage&amp; aMess)
{
  size_t len {strlen(aMess.m_pMessage)+1};
  m_pMessage = new char[len];
  strcpy_s(m_pMessage, len, aMess.m_pMessage);
}</code></pre>
<p class="calibre13">Remember from the previous chapter that the parameter must be specified as a <code class="calibre23">const</code> reference to avoid an infinite spiral of calls to a copy constructor. This copy constructor first allocates enough memory to hold the string from the <code class="calibre23">aMess</code> object, stores the address in the <code class="calibre23">m_pMessage</code> member of the new object, and then copies the string from the initializing object. Now the new object will be identical to the original, but quite independent of it.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="331" id="calibre_link-793" class="calibre14"></span>Just because you don’t explicitly initialize one <code class="calibre23">CMessage</code> class object with another, don’t think that you’re safe and need not bother with the copy constructor. Another monster lurks in the free store that can emerge to bite you when you least expect it. Consider the following statements:</p>
<pre class="calibre28"><code class="calibre23">CMessage thought {"Eye awl weighs yews my spell checker."};
displayMessage(thought);     // Call a function to output a message</code></pre>
<p class="calibre13">Where the function <code class="calibre23">displayMessage()</code> is defined as:</p>
<pre class="calibre28"><code class="calibre23">void displayMessage(CMessage localMsg)
{
  cout &lt;&lt; "The message is: " &lt;&lt; endl; 
  localMsg.showIt();
  return;
}</code></pre>
<p class="calibre13">Looks simple enough, doesn’t it? What could be wrong with that? A catastrophic error, that’s what! What <code class="calibre23">displayMessage()</code> does is irrelevant. The problem lies with the parameter. The parameter is type <code class="calibre23">CMessage</code>, so the argument in a call is passed by value. With the default copy constructor, the sequence of events is as follows:</p>
<ol class="calibre5">
<li class="calibre6">The object <code class="calibre23">thought</code> is created with the space for the message <code class="calibre23">"Eye awl weighs yews my spell checker"</code> allocated in the free store.</li>
<li class="calibre6">The function <code class="calibre23">displayMessage()</code> is called and, because the argument is passed by value, a copy, <code class="calibre23">localMsg</code>, is made using the default copy constructor. Now, the pointer in the copy points to the same string in the free store as the original object.</li>
<li class="calibre6">At the end of the function, the local object goes out of scope, so the destructor for the <code class="calibre23">CMessage</code> class is called. This deletes the local object (the copy) and releases the memory pointed to by <code class="calibre23">m_pMessage</code>.</li>
<li class="calibre6">On return from <code class="calibre23">displayMessage()</code>, the pointer in the original object, <code class="calibre23">thought</code>, still points to the memory that has just been deleted. Next time you use the original object, your program will behave in weird and mysterious ways.</li>
</ol>
<p class="calibre13"><i class="calibre15">Any</i> call to a function that passes by value an object of a class that has a member defined dynamically will cause problems. So, out of this, you have an absolutely 100-percent, 24-carat golden rule:</p>
<p class="calibre13"><i class="calibre15">If you allocate space for a member of a class dynamically, always implement a copy constructor. You should also implement a destructor unless you are using smart pointers that you’ll learn about in Chapter 10.</i></p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-297" class="calibre3"></a>OPERATOR OVERLOADING</h2>
<p class="calibre13"><i class="calibre15">Operator overloading</i> is a very important capability. It enables you to make standard C++ operators, such as <code class="calibre23">+, -, *</code>, and so on, work with objects of your own data types. You can write a function that redefines an operator so that it performs a particular action when it’s used with objects of a class type. For example, you could redefine the <code class="calibre23">&lt;</code> operator to compare <code class="calibre23">CBox</code> objects and return <code class="calibre23">true</code> if the first <code class="calibre23">CBox</code> argument had a smaller volume than the second.</p>
<p class="calibre13">Operator overloading doesn’t allow you to invent new operators. Nor can you change operator precedence, so your overloaded version of an operator will have the same priority in the sequence of <span {http://www.idpf.org/2007/ops}type="pagebreak" title="332" id="calibre_link-794" class="calibre14"></span>evaluating an expression as the original operator. The operator precedence table  is in Chapter 2 and in the MSDN Library.</p>
<p class="calibre13">Although you can’t overload all the operators, the restrictions aren’t particularly oppressive. These are the operators that you can’t overload:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">OPERATOR</b></th>
<th class="calibre32"><b class="calibre12">DEFINITION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">::</code></td>
<td class="calibre32">The scope resolution operator</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">?:</code></td>
<td class="calibre32">The conditional operator</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">.</code></td>
<td class="calibre32">The direct member selection operator</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">sizeof</code></td>
<td class="calibre32">The size-of operator</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">.*</code></td>
<td class="calibre32">The dereference pointer to class member operator</td>
</tr>
</tbody>
</table>
<p class="calibre13">Anything else is fair game, which gives you quite a bit of scope. Obviously, it’s a good idea to ensure that your versions of the operators are reasonably consistent with their original usage, or at least reasonably intuitive in their operation. It wouldn’t be a very sensible approach to produce an overloaded <code class="calibre23">+</code> operator for a class that performed the equivalent of a multiplication on class objects. The best way to understand how operator overloading works is to work through an example, so let’s implement what I just referred to, the less-than operator, <code class="calibre23">&lt;</code>, for the <code class="calibre23">CBox</code> class.</p>
<section class="toclist">
<h3 class="calibre21">Implementing an Overloaded Operator</h3>
<p class="calibre13">A function defining an overloaded operator for a class must have a specific form. Assuming that it is a member of the <code class="calibre23">CBox</code> class, the declaration for the function to overload the <code class="calibre23">&lt;</code> operator within the class definition will be as follows:</p>
<pre class="calibre28"><code class="calibre23">class CBox
{
  public:
    bool operator&lt;(const CBox&amp; aBox) const;  // Overloaded 'less than'
        
  // Rest of the class definition...
};</code></pre>
<p class="calibre13"><code class="calibre23">operator</code> is a keyword. Combined with an operator symbol or name, in this case, <code class="calibre23">&lt;</code>, it specifies an operator function name. The function name in this case is <code class="calibre23">operator&lt;</code>. You can write an operator function with or without a space between the <code class="calibre23">operator</code> keyword and the operator itself, as long as there’s no ambiguity. The ambiguity arises with operators with names rather than symbols such as <code class="calibre23">new</code> or <code class="calibre23">delete</code>. If you were to write <code class="calibre23">operatornew</code> and <code class="calibre23">operatordelete</code> without a space, they are legal names for ordinary functions, so for operator functions with these operators, you must leave a space between the keyword <code class="calibre23">operator</code> and the operator name. The strangest-looking name for an overloaded operator function is <code class="calibre23">operator()()</code>. This looks like a typing error, but it is, in fact, a function that overloads the function call operator, <code class="calibre23">()</code>. You declare <code class="calibre23">operator&lt;()</code> as <code class="calibre23">const</code> because it doesn’t modify the data members of the class.</p>
<p class="calibre13">The right operand of the <code class="calibre23">operator&lt;()</code> function is specified by the argument. The left operand is defined implicitly by the pointer <code class="calibre23">this</code>. Suppose you have the following <code class="calibre23">if</code> statement:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="333" id="calibre_link-795" class="calibre14"></span>if(box1 &lt; box2)
   cout &lt;&lt; "box1 is less than box2" &lt;&lt; endl;</code></pre>
<p class="calibre13">The expression between the parentheses will call our operator function, so the statement is equivalent to:</p>
<pre class="calibre28"><code class="calibre23">if(box1.operator&lt;(box2))
   cout &lt;&lt; "box1 is less than box2" &lt;&lt; endl;</code></pre>
<p class="calibre13">The correspondence between the <code class="calibre23">CBox</code> objects in the expression and the operator function parameters is illustrated in <a id="calibre_link-1364" href="#calibre_link-412" class="calibre3">Figure 8-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000170.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-412" href="#calibre_link-1364" class="calibre3">FIGURE 8-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Let’s look at how the code for the <code class="calibre23">operator&lt;()</code> function works:</p>
<pre class="calibre28"><code class="calibre23">// Operator function for 'less than' which
// compares volumes of CBox objects.
bool CBox::operator&lt;(const CBox&amp; aBox) const
{
  return this-&gt;volume() &lt; aBox.volume();
}</code></pre>
<p class="calibre13">Using a reference parameter avoids copying of the argument when the function is called. Because the function does not alter the object for which it is called, you can declare the parameter as <code class="calibre23">const</code>. If you don’t do this, you won’t be able to use the operator with a <code class="calibre23">const CBox</code> object as the right operand. You also declare the function to be <code class="calibre23">const</code> because it doesn’t modify the <code class="calibre23">CBox</code> object for which it is called.</p>
<p class="calibre13">The <code class="calibre23">return</code> expression uses the <code class="calibre23">volume()</code> member to calculate the volume of the object pointed to by <code class="calibre23">this</code>, and compares the result with the volume of <code class="calibre23">aBox</code> using the basic operator <code class="calibre23">&lt;</code>.</p>
<p class="calibre13">Comparing <code class="calibre23">CBox</code> objects for equality is just as easy to implement:</p>
<pre class="calibre28"><code class="calibre23">bool CBox::operator==(const CBox&amp; aBox) const
{
  return this-&gt;volume() == aBox.volume();
}</code></pre>
<p class="calibre13">This implementation assumes two objects are equal if the volumes are the same. You might want to define equality differently though. A more stringent and perhaps more realistic implementation for equality might be that the objects had identical dimensions, but I’ll leave that for you to explore.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="334" id="calibre_link-796" class="calibre24"></span>TRY IT OUT: Operator Overloading</h3>
<p class="calibre20">You can exercise the operator functions for <code class="calibre23">CBox</code> objects with an example:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex8_03.cpp</b>
<b class="calibre12">// Exercising the overloaded 'less than' and equality operators</b>
#include &lt;iostream&gt;                      // For stream I/O
using std::cout;
using std::endl;
        
class CBox                               // Class definition at global scope
{
  public:
    // Constructor definition
    explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                               m_Length(lv), m_Width(wv), m_Height(hv)
    {
      cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    }
        
    // Function to calculate the volume of a box
    double volume() const
    {
      return m_Length*m_Width*m_Height;
    }
        
    <b class="calibre12">bool operator&lt;(const CBox&amp; aBox) const;  // Overloaded 'less than'</b>
        
    <b class="calibre12">// Overloaded equality operator</b>
    <b class="calibre12">bool operator==(const CBox&amp; aBox) const</b>
    <b class="calibre12">{</b>
      <b class="calibre12">return this-&gt;volume() == aBox.volume();</b>
    <b class="calibre12">}</b>
        
    // Destructor definition
    ~CBox()
    {
      cout &lt;&lt; "Destructor called." &lt;&lt; endl;
    }
  private:
    double m_Length;                         // Length of a box in inches
    double m_Width;                          // Width of a box in inches
    double m_Height;                         // Height of a box in inches
};
        
<b class="calibre12">// Operator function for 'less than' that</b>
<b class="calibre12">// compares volumes of CBox objects.</b>
<b class="calibre12">inline bool CBox::operator&lt;(const CBox&amp; aBox) const</b>
<b class="calibre12">{</b>
  <b class="calibre12">return this-&gt;volume() &lt; aBox.volume();</b>
<b class="calibre12">}</b>

<b class="calibre12">int main()</b>
<b class="calibre12">{</b>
  <b class="calibre12">const CBox smallBox {4.0, 2.0, 1.0};</b>
  <b class="calibre12">const CBox mediumBox {10.0, 4.0, 2.0};</b>
  <b class="calibre12">CBox bigBox {30.0, 20.0, 40.0};</b>
  <b class="calibre12"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="335" id="calibre_link-797" class="calibre14"></span>CBox thatBox {4.0, 2.0, 10.0};</b>

  <b class="calibre12">if(mediumBox &lt; smallBox)</b>
    <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">mediumBox is smaller than smallBox" &lt;&lt; endl;</b>

  <b class="calibre12">if(mediumBox &lt; bigBox)</b>
    <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">mediumBox is smaller than bigBox" &lt;&lt; endl;</b>
  <b class="calibre12">else</b>
    <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">mediumBox is not smaller than bigBox" &lt;&lt; endl;</b>

  <b class="calibre12">if(thatBox == mediumBox)</b>
    <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">thatBox is equal to mediumBox" &lt;&lt; endl;</b>
  <b class="calibre12">else</b>  
    <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">thatBox is not equal to mediumBox" &lt;&lt; endl;</b>  

  <b class="calibre12">return 0;</b>
<b class="calibre12">}</b></code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The prototype of the <code class="calibre23">operator&lt;()</code> function is in the <code class="calibre23">public</code> section of the class. The only reason the definition is outside the class here is to demonstrate the possibility. You could just as well have put the definition inside the class, like the <code class="calibre23">operator==()</code> function. Then you wouldn’t need to qualify the function name with <code class="calibre23">CBox</code>.</p>
<p class="calibre20">The <code class="calibre23">main()</code> function has two <code class="calibre23">if</code> statements using the <code class="calibre23">&lt;</code> operator with <code class="calibre23">CBox</code> objects. These automatically call the overloaded operator function. If you want to confirm this, add an output statement to the operator function. There is also a statement using the <code class="calibre23">==</code> operator. The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Constructor called.
Constructor called.
mediumBox is smaller than bigBox
thatBox is equal to mediumBox
Destructor called.
Destructor called.
Destructor called.
Destructor called.</code></pre>
<p class="calibre20">The output demonstrates that the <code class="calibre23">if</code> statements work fine with our operator functions, and the operator overload works with <code class="calibre23">const</code> and non-<code class="calibre23">const</code> objects. Being able to express the solution to <code class="calibre23">CBox</code> problems directly in terms of <code class="calibre23">CBox</code> objects is beginning to be a realistic proposition.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Implementing Full Support for Comparison Operators</h3>
<p class="calibre13">With the current version of <code class="calibre23">operator&lt;()</code>, there are a lot of things that you can’t do. Specifying a problem solution in terms of <code class="calibre23">CBox</code> objects might well involve statements such as this:</p>
<pre class="calibre28"><code class="calibre23">if(aBox &lt; 20.0)
  // Do something...</code></pre>
<p class="calibre13">Our class won’t deal with that. If you use an expression comparing a <code class="calibre23">CBox</code> object with a numerical value, it won’t compile. To support this capability, you would need to write another version of the <code class="calibre23">operator&lt;()</code> function.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="336" id="calibre_link-798" class="calibre14"></span>You can easily support the type of expression that you’ve just seen. The definition of the member function within the class would be:</p>
<pre class="calibre28"><code class="calibre23">// Function to compare a CBox object with a constant
bool CBox::operator&lt;(const double value) const
{
  return this-&gt;volume() &lt; value;
}</code></pre>
<p class="calibre13">The right operand for the <code class="calibre23">&lt;</code> operator corresponds to the function parameter. The <code class="calibre23">CBox</code> object that is the left operand will be passed as the implicit pointer <code class="calibre23">this</code>. This couldn’t be much simpler, could it? But you still have a problem using the <code class="calibre23">&lt;</code> operator with <code class="calibre23">CBox</code> objects. You may well want to write this:</p>
<pre class="calibre28"><code class="calibre23">if(20.0 &lt; aBox)
   // do something...</code></pre>
<p class="calibre13">You might argue that this could be done by implementing the <code class="calibre23">operator&gt;()</code> operator function that accepted a right argument of type <code class="calibre23">double</code>, and rewriting the preceding statement to use it, which is true. Indeed, implementing the <code class="calibre23">&gt;</code> operator is likely to be a requirement for comparing <code class="calibre23">CBox</code> objects, anyway, but an implementation of an operator for a type shouldn’t artificially restrict the ways in which you can use it in an expression. The use of the operator should be as natural as possible. The problem is how to do it.</p>
<p class="calibre13">A member operator function always provides the left argument as the pointer <code class="calibre23">this</code>. Because the left argument is of type <code class="calibre23">double</code> in this case, you can’t implement it as a member function. That leaves you with two choices: an ordinary function or a <code class="calibre23">friend</code> function. You don’t need to access the <code class="calibre23">private</code> members of the class so it doesn’t need to be a <code class="calibre23">friend</code> function. You can implement the overloaded <code class="calibre23">&lt;</code> operator with a left operand of type <code class="calibre23">double</code> as an ordinary function, like this:</p>
<pre class="calibre28"><code class="calibre23">// Function comparing a constant with a CBox object
inline bool operator&lt;(const double value, const CBox&amp; aBox)
{
   return value &lt; aBox.volume();
}</code></pre>
<p class="calibre13">As you have seen, an ordinary function (and a <code class="calibre23">friend</code> function, too, for that matter) accesses the <code class="calibre23">public</code> members of an object by using the direct member selection operator and the object name. The <code class="calibre23">volume()</code> member is <code class="calibre23">public</code>, so there’s no problem using it here.</p>
<p class="calibre13">If the class didn’t have the <code class="calibre23">public</code> function <code class="calibre23">volume()</code>, you could either declare the operator function a <code class="calibre23">friend</code> function that could access the <code class="calibre23">private</code> data members directly, or you could provide a set of member functions to return the values of the <code class="calibre23">private</code> data members and use those to implement the comparison.</p>
<p class="calibre13">You still have quite a way to go yet. You still need the <code class="calibre23">&gt;, &gt;=, &lt;=</code>, and <code class="calibre23">!=</code> operators. You could plow on and implement all of these yourself. However, the standard library can save you the trouble. The <code class="calibre23">utility</code> header defines a set of templates for operator functions as follows:</p>
<pre class="calibre28"><code class="calibre23">template &lt;class T&gt; bool operator!=(const T&amp; x, const T&amp; y); // Requires ==
template &lt;class T&gt; bool operator&gt;(const T&amp; x, const T&amp; y);       // Requires &lt;
template &lt;class T&gt; bool operator&lt;=(const T&amp; x, const T&amp; y);      // Requires &lt;
template &lt;class T&gt; bool operator&gt;=(const T&amp; x, const T&amp; y);      // Requires &lt;</code></pre>
<p class="calibre13">These templates create comparison operator functions for any class. The comments indicate that you must implement <code class="calibre23">operator&lt;()</code> and <code class="calibre23">operator==()</code> for all these templates to be usable with a class. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="337" id="calibre_link-799" class="calibre14"></span>The templates are defined in the <code class="calibre23">std::rel_ops</code> namespace, so you can make the template function names available without qualification in your source file with the following <code class="calibre23">using</code> directive:</p>
<pre class="calibre28"><code class="calibre23">using namespace std::rel_ops;</code></pre>
<p class="calibre13">With that in place, you will get the four additional operator functions in a class for free. Let’s try it.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Complete Overloading of the Comparison Operators</h3>
<p class="calibre20">We can put all this together in an example to show how it works:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_04.cpp
// Implementing the comparison operators
#include &lt;iostream&gt;                    // For stream I/O
#include &lt;utility&gt;                     // For operator overload templates
using std::cout;
using std::endl;
using namespace std::rel_ops;
        
class CBox                             // Class definition at global scope
{
  public:
    // Constructor definition
    explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                            m_Length {lv}, m_Width {wv}, m_Height {hv} 
    {
      cout &lt;&lt; "Constructor called." &lt;&lt; endl;
    }
        
    // Function to calculate the volume of a box
    double volume() const
    {
      return m_Length*m_Width*m_Height;
    }
        
    // Operator function for 'less than' that
    // compares volumes of CBox objects.
    bool operator&lt;(const CBox&amp; aBox) const
    {
      return this-&gt;volume() &lt; aBox.volume();
    }
    // 'Less than' operator function to compare a CBox object volume with a constant
    bool operator&lt;(const double value) const
    {
      return this-&gt;volume() &lt; value;
    }
    // 'Greater than' function to compare a CBox object volume with a constant
    bool operator&gt;(const double value) const
    {
      return this-&gt;volume() &gt; value;
    }
        
    // Overloaded equality operator
    bool operator==(const CBox&amp; aBox) const
    {
      return this-&gt;volume() == aBox.volume();
    }
        
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="338" id="calibre_link-800" class="calibre14"></span>// Destructor definition
    ~CBox()
    { cout &lt;&lt; "Destructor called." &lt;&lt; endl; }
        
  private:
    double m_Length;                   // Length of a box in inches
    double m_Width;                    // Width of a box in inches
    double m_Height;                   // Height of a box in inches
};
        
// Function comparing a constant with a CBox object
inline bool operator&lt;(const double value, const CBox&amp; aBox) 
{
  return value &lt; aBox.volume();
}
        
int main()
{
  CBox smallBox {4.0, 2.0, 1.0};
  CBox mediumBox {10.0, 4.0, 2.0};
  CBox otherBox {2.0, 1.0, 4.0};
  if(mediumBox != smallBox)
    cout &lt;&lt; "mediumBox is not equal to smallBox" &lt;&lt; endl;
       
  if(mediumBox &gt; smallBox)
    cout &lt;&lt; "mediumBox is bigger than smallBox" &lt;&lt; endl;
  else
    cout &lt;&lt; "mediumBox is not bigger than smallBox" &lt;&lt; endl;
 
  if(otherBox &gt;= smallBox)
    cout &lt;&lt; "otherBox is greater than or equal to smallBox" &lt;&lt; endl;
  else
    cout &lt;&lt; "otherBox is smaller than smallBox" &lt;&lt; endl;
 
  if(otherBox &gt;= mediumBox)
    cout &lt;&lt; "otherBox is greater than or equal to mediumBox" &lt;&lt; endl;
  else
    cout &lt;&lt; "otherBox is smaller than mediumBox" &lt;&lt; endl;
    
  if(mediumBox &gt; 50.0)
    cout &lt;&lt; "mediumBox capacity is more than 50" &lt;&lt; endl;
  else
    cout &lt;&lt; "mediumBox capacity is not more than 50" &lt;&lt; endl;
 
  if(10.0 &lt; smallBox)
    cout &lt;&lt; "smallBox capacity is more than 10"&lt;&lt; endl;
  else
    cout &lt;&lt; "smallBox capacity is not more than 10"&lt;&lt; endl;
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Note the position of the definition for the ordinary function version of <code class="calibre23">operator&lt;()</code>. It must follow the class definition, because it refers to a <code class="calibre23">CBox</code> object. If you place it before the class definition, the example will not compile because the <code class="calibre23">CBox</code> type has not been defined at that point.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="339" id="calibre_link-801" class="calibre14"></span>There is a way you could place the function prototype at the beginning of the source file. You can use an <i class="calibre15">incomplete class declaration</i>, also called a <i class="calibre15">forward declaration</i> of the class type. This would precede the function definition and the code would look like this:</p>
<pre class="calibre28"><code class="calibre23">class CBox;                                      // Incomplete class declaration
inline bool operator&lt;(const double value, const CBox&amp; aBox); // Prototype</code></pre>
<p class="calibre20">The forward declaration identifies <code class="calibre23">CBox</code> to the compiler as a class and is sufficient to allow the compiler to process the function prototype properly. It tells the compiler that <code class="calibre23">CBox</code> is a user-defined type to be specified later.</p>
<p class="calibre20">This mechanism is essential in circumstances where you have two classes, each of which has a pointer to an object of the other class type as a member. They will each require the other to be declared first. It is only possible to resolve such an impasse through the use of an incomplete class declaration.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can have forward declarations for</i> <code class="calibre23">enum</code> <i class="calibre15">types as well as class types. For example:</i></p>
<pre class="calibre28"><code class="calibre23">enum class Suit;</code></pre>
<p class="calibre20"><i class="calibre15">This forward declaration allows you to use the <code class="calibre23">Suit enum</code> type to declare variables after this statement even though the <code class="calibre23">enum</code> type is not yet defined. However, you cannot refer to enumerators until you supply the complete definition for the type.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The output from the example is:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Constructor called.
mediumBox is not equal to smallBox
mediumBox is bigger than smallBox
otherBox is greater than or equal to smallBox
otherBox is smaller than mediumBox
mediumBox capacity is more than 50
smallBox capacity is not more than 10
Destructor called.
Destructor called.
Destructor called.</code></pre>
<p class="calibre13">Following the constructor messages due to the declarations of the <code class="calibre23">CBox</code> objects, you have the output lines from the <code class="calibre23">if</code> statements, each of which works as you would expect. The first of these calls the <code class="calibre23">operator!=()</code> function that is generated by the compiler from the template provided by the <code class="calibre23">utility</code> header. The template requires a definition for the <code class="calibre23">==</code> operator function in the class.</p>
<p class="calibre13">The output demonstrates that all of the template-generated operator functions are working. As it happens, you could have made both the operator functions that you defined as class member ordinary functions, because they only need access to the <code class="calibre23">volume()</code> function, which is <code class="calibre23">public</code>.</p>
<p class="calibre13">You can implement comparison operators for any class type in much the same way as you have implemented them here. They would only differ in the details that depend on the nature of the objects.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="340" id="calibre_link-802" class="calibre24"></span>Overloading the Assignment Operator</h3>
<p class="calibre13">If you don’t provide an overloaded assignment operator function for your class, the compiler will provide a default. The default version implements member-by-member copying, similar to that of the default copy constructor. Don’t confuse the default copy constructor with the default assignment operator. The copy constructor is called when you define an object that’s initialized with another object of the same type. It will also be called when you pass an object to a function by value. The assignment operator is called when both sides of an assignment are objects of the same type.</p>
<p class="calibre13">The default assignment operator works with no problem for the <code class="calibre23">CBox</code> class but for any class that has space for members allocated dynamically, you must implement the assignment operator. There will be considerable potential for chaos if you omit the assignment operator in these circumstances.</p>
<p class="calibre13">Let’s return to the <code class="calibre23">CMessage</code> class we used in the context of copy constructors. You’ll remember it had a <code class="calibre23">m_pMessage</code> member that was a pointer to a string. Consider the effect that the default assignment operator could have with <code class="calibre23">CMessage</code> objects. Suppose you had two instances of the class, <code class="calibre23">motto1</code> and <code class="calibre23">motto2</code>. You could set the members of <code class="calibre23">motto2</code> equal to the members of <code class="calibre23">motto1</code> using the default assignment operator, like this:</p>
<pre class="calibre28"><code class="calibre23">motto2 = motto1;</code></pre>
<p class="calibre13">The effect of using the default assignment operator for this class is essentially the same as using the default copy constructor: disaster will result! Both objects will end up with a pointer to the same string; if the string is changed for one object, it’s changed for both. There is also the problem that when one object is destroyed, its destructor will free the memory used for the string, so the other object will be left with a pointer to memory that may now be used for something else. What you need the assignment operator to do is to copy the text from the source object to a memory area owned by the destination object.</p>
<section class="toclist">
<h4 class="calibre22">Fixing the Problem</h4>
<p class="calibre13">You can fix this with your own assignment operator function, which I will assume is defined within the class definition. Here’s a first stab at it, which I’ll warn you now is not sufficient for proper operation:</p>
<pre class="calibre28"><code class="calibre23">// Overloaded assignment operator for CMessage objects
CMessage&amp; operator=(const CMessage&amp; aMess)
{
  // Release memory for 1st operand
  delete[] m_pMessage;
  size_t length { strlen(aMess.m_pMessage) + 1};
  m_pMessage = new char[length];          
  // Copy 2nd operand string to 1st
  strcpy_s(this-&gt;m_pMessage, length, aMess.m_pMessage);
        
  return *this;                       // Return a reference to 1st operand
}</code></pre>
<p class="calibre13">An assignment might seem very simple, but there are a couple of subtleties. First of all, note that you return a <i class="calibre15">reference</i> from the assignment operator function. It may not be immediately apparent why this is so &mdash; after all, the function does complete the assignment operation entirely, and the object <span {http://www.idpf.org/2007/ops}type="pagebreak" title="341" id="calibre_link-803" class="calibre14"></span>on the right of the assignment will be copied to that on the left. Superficially, this would suggest that you don’t need to return anything, but you need to consider in a little more depth how the operator might be used.</p>
<p class="calibre13">The result of an assignment operation can appear on the right-hand side of another assignment. Consider this statement:</p>
<pre class="calibre28"><code class="calibre23">motto1 = motto2 = motto3;</code></pre>
<p class="calibre13">The assignment operator is right-associative so the assignment of <code class="calibre23">motto3</code> to <code class="calibre23">motto2</code> will be carried out first. The statement will translate into the following:</p>
<pre class="calibre28"><code class="calibre23">motto1 = (motto2.operator=(motto3));</code></pre>
<p class="calibre13">The result of the operator function call is on the right of <code class="calibre23">=</code>, so the statement will finally become:</p>
<pre class="calibre28"><code class="calibre23">motto1.operator=(motto2.operator=(motto3));</code></pre>
<p class="calibre13">If this is to work, you certainly have to return something from the <code class="calibre23">operator=()</code> function. The function call between the parentheses must return an object that can be used as the argument to the other <code class="calibre23">operator=()</code> function call. In this case, a return type of either <code class="calibre23">CMessage</code> or <code class="calibre23">CMessage&amp;</code> would do it, so a reference is not mandatory for this situation, but you must at least return a <code class="calibre23">CMessage</code> object.</p>
<p class="calibre13">However, consider the following example:</p>
<pre class="calibre28"><code class="calibre23"> (motto1 = motto2) = motto3;</code></pre>
<p class="calibre13">This is perfectly legitimate code &mdash; the parentheses serve to make sure the leftmost assignment is carried out first. This translates into the following statement:</p>
<pre class="calibre28"><code class="calibre23"> (motto1.operator=(motto2)) = motto3;</code></pre>
<p class="calibre13">When you express the remaining assignment operation as the explicit overloaded function call, this ultimately becomes:</p>
<pre class="calibre28"><code class="calibre23"> (motto1.operator=(motto2)).operator=(motto3);</code></pre>
<p class="calibre13">Now, you have a situation where the object returned from the <code class="calibre23">operator=()</code> function is used to call the <code class="calibre23">operator=()</code> function. If the return type is just <code class="calibre23">CMessage</code>, this will not be legal because a temporary copy of the original object is returned which will be an rvalue, and the compiler will not allow a member function call using an rvalue. The only way to ensure this will compile and work correctly is to return a reference, which is an lvalue. The only possible return type if you want to allow fully flexible use of the assignment operator with your class objects is <code class="calibre23">CMessage&amp;</code>.</p>
<p class="calibre13">Note that C++ does not enforce any restrictions on the accepted parameter or return types for the assignment operator, but it makes sense to declare the operator in the way I have just described if you want your assignment operator functions to support normal assignment usage.</p>
<p class="calibre13">Another subtlety is that each object already has memory for a string allocated, so the first thing that the operator function has to do is to delete the memory allocated to the first object and reallocate sufficient memory to accommodate the string from the second object. When this is done, the string from the second object can be copied to the new memory now owned by the first.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="342" id="calibre_link-804" class="calibre14"></span>There’s still a defect in this operator function. What if you were to write the following statement?</p>
<pre class="calibre28"><code class="calibre23">motto1 = motto1;</code></pre>
<p class="calibre13">Obviously, you wouldn’t do anything as stupid as this directly, but it could easily be hidden behind a pointer, as in the following statement:</p>
<pre class="calibre28"><code class="calibre23">motto1 = *pMessage;</code></pre>
<p class="calibre13">If the pointer <code class="calibre23">pMessage</code> points to <code class="calibre23">motto1</code>, you essentially have the preceding assignment statement. In this case, the operator function as it stands will delete the memory for <code class="calibre23">motto1</code>, allocate some more memory based on the length of the string that has already been deleted, and try to copy the old memory, which, by then, could well have been corrupted. You can fix this by checking for identical left and right operands at the beginning of the function, so the definition of the <code class="calibre23">operator=()</code> function would become:</p>
<pre class="calibre28"><code class="calibre23">// Overloaded assignment operator for CMessage objects
CMessage&amp; operator=(const CMessage&amp; aMess)
{
  <b class="calibre12">if(this != &amp;aMess)                   // Check addresses are not equal</b>
  <b class="calibre12">{</b>        
    // Release memory for 1st operand
    delete[] m_pMessage;
    size_t length { strlen(aMess.m_pMessage) + 1};
    m_pMessage = new char[length]; 
        
    // Copy 2nd operand string to 1st
    strcpy_s(this-&gt;m_pMessage, length, aMess.m_pMessage);
  <b class="calibre12">}</b>
  
  return *this;                        // Return a reference to 1st operand
}</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Overloading the Assignment Operator</h3>
<p class="calibre20">You can put the full <code class="calibre23">operator=()</code> function implementation in a working example. You’ll add a <code class="calibre23">reset()</code> function to the <code class="calibre23">CMessage</code> class that just resets the message to a string of asterisks.</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex8_05.cpp</b>
<b class="calibre12">// Overloaded assignment operator working well</b>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using std::cout;
using std::endl;
        
class CMessage
{
  private:
    char* m_pMessage;                          // Pointer to object text string
        
  public:
    // Function to display a message
    void showIt() const
    {
      <span {http://www.idpf.org/2007/ops}type="pagebreak" title="343" id="calibre_link-805" class="calibre14"></span>cout &lt;&lt; m_pMessage &lt;&lt; endl;
    }
        
    <b class="calibre12">//Function to reset a message to *</b>
    <b class="calibre12">void reset()</b>
    <b class="calibre12">{</b>
      <b class="calibre12">char* temp {m_pMessage};</b>
      <b class="calibre12">while(*temp)</b>
        <b class="calibre12">*(temp++) = '*';</b>
    <b class="calibre12">}</b>
    <b class="calibre12">// Overloaded assignment operator for CMessage objects</b>
    <b class="calibre12">CMessage&amp; operator=(const CMessage&amp; aMess)</b>
    <b class="calibre12">{</b>
      <b class="calibre12">if(this != &amp;aMess)                       // Check addresses are not equal</b>
      <b class="calibre12">{</b>        
        <b class="calibre12">// Release memory for 1st operand</b>
        <b class="calibre12">delete[] m_pMessage;</b>
        <b class="calibre12">size_t length {strlen(aMess.m_pMessage) + 1};</b>
        <b class="calibre12">m_pMessage = new char[length];</b>
        
        <b class="calibre12">// Copy 2nd operand string to 1st</b>
        <b class="calibre12">strcpy_s(this-&gt;m_pMessage, length, aMess.m_pMessage);</b>
      <b class="calibre12">}</b>
      <b class="calibre12">return *this;                            // Return a reference to 1st operand</b>
    <b class="calibre12">}</b>
        
    // Constructor definition
    CMessage(const char* text = "Default message")
    {
      size_t length {strlen(text) + 1};
      m_pMessage = new char[length];           // Allocate space for text
      strcpy_s(m_pMessage, length, text);      // Copy text to new memory
    }
        
    // Copy constructor definition
    CMessage(const CMessage&amp; aMess)
    {
      size_t length {strlen(aMess.m_pMessage)+1}; 
      m_pMessage = new char[length];
      strcpy_s(m_pMessage, length, aMess.m_pMessage);
    }
        
    // Destructor to free memory allocated by new
    ~CMessage()
    {
      cout &lt;&lt; "Destructor called." &lt;&lt; endl;    // Just to track what happens
      delete[] m_pMessage;                     // Free memory assigned to pointer
    }
};
        
<b class="calibre12">int main()</b>
<b class="calibre12">{</b>
  <b class="calibre12">CMessage motto1 {"The devil takes care of his own."};</b>
  <b class="calibre12">CMessage motto2;</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">motto2 contains:" &lt;&lt; endl;</b>
  <b class="calibre12"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="344" id="calibre_link-806" class="calibre14"></span>motto2.showIt();</b>
  <b class="calibre12">motto2 = motto1;                             // Use new assignment operator</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">motto2 contains:" &lt;&lt; endl;</b>
  <b class="calibre12">motto2.showIt();</b>

  <b class="calibre12">motto1.reset();                              // Setting motto1 to * doesn't</b>
                                               <b class="calibre12">// affect motto2</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">motto1 now contains:" &lt;&lt; endl;</b>
  <b class="calibre12">motto1.showIt();</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">motto2 still contains:" &lt;&lt; endl;</b> 
  <b class="calibre12">motto2.showIt();</b>

  <b class="calibre12">return 0;</b>
<b class="calibre12">}</b></code></pre>
<p class="calibre20">You can see from the output that everything works exactly as required, with no linking between the messages of the two objects:</p>
<pre class="calibre28"><code class="calibre23">motto2 contains:
Default message
motto2 contains:
The devil takes care of his own
motto1 now contains:
*******************************
motto2 still contains:
The devil takes care of his own
Destructor called.
Destructor called.</code></pre>
<p class="calibre20">So you have another golden rule out of all of this:</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<p class="calibre20"><i class="calibre15">Always implement an assignment operator function if you allocate space dynamically for a data member of a class.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre20">Having implemented the assignment operator, what happens with operations such as <code class="calibre23">+=</code>? Well, they don’t work unless you implement them. For each form of op<code class="calibre23">=</code> that you want to use with your class objects, you need to write another operator function.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Overloading the Addition Operator</h3>
<p class="calibre13">Let’s look at overloading the addition operator for our <code class="calibre23">CBox</code> class. This is interesting because it involves creating and returning a new object. The new object will be the sum (whatever that means) of the <code class="calibre23">CBox</code> objects that are its operands.</p>
<p class="calibre13">So what do we want the sum of two boxes to mean? Well, there are quite a few legitimate possibilities, but we’ll keep it simple here. Let’s define the sum of two <code class="calibre23">CBox</code> objects as a <code class="calibre23">CBox</code> object that is large enough to contain the other two boxes stacked on top of each other. Ideally, you want to join the boxes by combining their shortest dimensions. You can do this by ensuring that the box height is always the smallest dimension. If you make the box length greater than or equal to the width, you can ensure the result of adding two boxes is not larger than it needs to be. A new object that results from addition will have an <code class="calibre23">m_Length</code> member that is the larger of the <code class="calibre23">m_Length</code> members of the operands and an <code class="calibre23">m_Width</code> member derived in a similar way. The <code class="calibre23">m_Height</code> member will be the sum of the <code class="calibre23">m_Height</code> members of the operands, so that the resultant <code class="calibre23">CBox</code> object can contain the other <span {http://www.idpf.org/2007/ops}type="pagebreak" title="345" id="calibre_link-807" class="calibre14"></span>two <code class="calibre23">CBox</code> objects. This isn’t necessarily optimal because one or other of the boxes could be rotated about its height axis for a more efficient combination, but it will be sufficient for our purposes. By altering the constructor, we’ll also arrange that the length, width, and height of a <code class="calibre23">CBox</code> object are in descending magnitude.</p>
<p class="calibre13">Our version of the addition operation for boxes is easier to explain graphically, so it’s illustrated in <a id="calibre_link-1365" href="#calibre_link-413" class="calibre3">Figure 8-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000040.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-413" href="#calibre_link-1365" class="calibre3">FIGURE 8-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Because it needs to access the private members of a <code class="calibre23">CBox</code> object, the <code class="calibre23">operator+()</code> function will be a member of the class. The declaration of the function within the class definition will be:</p>
<pre class="calibre28"><code class="calibre23">CBox operator+(const CBox&amp; aBox) const; // Function adding two CBox objects</code></pre>
<p class="calibre13">You define the parameter as a reference to avoid copying of the right argument when the function is called, and you make it a <code class="calibre23">const</code> reference because the function doesn’t modify the argument. The parameter must be <code class="calibre23">const</code> to allow a <code class="calibre23">const</code> object to be passed to the function, and the function must be declared as <code class="calibre23">const</code> to allow a <code class="calibre23">const</code> left operand.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="346" id="calibre_link-808" class="calibre14"></span>The <code class="calibre23">algorithm</code> header defines function templates for <code class="calibre23">max()</code> and <code class="calibre23">min()</code> that return the maximum and minimum of two values respectively. You can use the first of these to define the <code class="calibre23">operator+()</code> function like this:</p>
<pre class="calibre28"><code class="calibre23">// Function to add two CBox objects
CBox CBox::operator+(const CBox&amp; aBox) const
{
  // New object has larger length and width, and sum of heights
  return CBox(std::max(m_Length, aBox.m_Length),
              std::max(m_Width, aBox.m_Width) ,
              m_Height + aBox.m_Height);
}</code></pre>
<p class="calibre13">You construct a local <code class="calibre23">CBox</code> object from the current object (<code class="calibre23">*this</code>) and the object that is passed as the argument. The return process will make a temporary copy of the local <code class="calibre23">CBox</code> object you create, and the temporary copy is passed back to the calling function, not the local object. The local object is destroyed on return from the function.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Exercising Our Addition Operator</h3>
<p class="calibre20">You’ll be able to see how the overloaded addition operator in the <code class="calibre23">CBox</code> class works in this example:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex8_06.cpp</b>
<b class="calibre12">// Adding CBox objects</b>
#include &lt;iostream&gt;                    // For stream I/O
#include &lt;algorithm&gt;                   // For min(), max() and swap()
#include &lt;utility&gt;                     // For operator templates
using std::cout;
using std::endl;
using namespace std::rel_ops;
        
class CBox                             // Class definition at global scope
{
  public:
  <b class="calibre12">// Constructor definition</b>
  <b class="calibre12">explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):</b> 
     <b class="calibre12">m_Length {std::max(lv, wv)}, m_Width{std::min(lv, wv)}, m_Height{hv}</b>
  <b class="calibre12">{</b>
    <b class="calibre12">// height is &lt;= width</b> 
    <b class="calibre12">// We need to ensure the height is &lt;= width is &lt;= length</b>
    <b class="calibre12">if (m_Height &gt; m_Length)</b>
    <b class="calibre12">{ // height greater than length, so swap them</b>
      <b class="calibre12">std::swap(m_Height, m_Length);</b>
      <b class="calibre12">std::swap(m_Width, m_Height);</b>
    <b class="calibre12">} else if (m_Height &gt; m_Width)</b>
    <b class="calibre12">{ // height less than or equal to length but greater than width so swap</b>
      <b class="calibre12">std::swap(m_Height, m_Width);</b>
    <b class="calibre12">}</b>
  <b class="calibre12">}</b>
        
  // Function to calculate the volume of a box
  double volume() const
  {
    return m_Length*m_Width*m_Height;
  }
        
  // Operator function for 'less than' that
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="347" id="calibre_link-809" class="calibre14"></span>// compares volumes of CBox objects.
  bool operator&lt;(const CBox&amp; aBox) const
  {
    return this-&gt;volume() &lt; aBox.volume();
  }
 
  // 'Less than' operator function to compare a CBox object volume with a constant
  bool operator&lt;(const double value) const
  {
    return this-&gt;volume() &lt; value;
  }
 
  // 'Greater than' function to compare a CBox object volume with a constant
  bool operator&gt;(const double value) const
  {
    return this-&gt;volume() &gt; value;
  }
        
  // Overloaded equality operator
  bool operator==(const CBox&amp; aBox) const
  {
    return this-&gt;volume() == aBox.volume();
  }
 
  <b class="calibre12">// Function to add two CBox objects</b>
  <b class="calibre12">CBox operator+(const CBox&amp; aBox) const</b>
  <b class="calibre12">{</b>
    <b class="calibre12">// New object has larger length &amp; width, and sum of heights</b>
    <b class="calibre12">return CBox(std::max(m_Length, aBox.m_Length),</b>
                <b class="calibre12">std::max(m_Width , aBox.m_Width) ,</b>
                <b class="calibre12">m_Height + aBox.m_Height);</b>
  <b class="calibre12">}</b>

  <b class="calibre12">// Function to show the dimensions of a box</b>
  <b class="calibre12">void showBox() const</b>
  <b class="calibre12">{</b>
    <b class="calibre12">cout &lt;&lt; m_Length &lt;&lt;</b> " " <b class="calibre12">&lt;&lt; m_Width  &lt;&lt;</b> " " <b class="calibre12">&lt;&lt; m_Height &lt;&lt; endl;</b>
  <b class="calibre12">}</b>
        
private:
  double m_Length;                     // Length of a box in inches
  double m_Width;                      // Width of a box in inches
  double m_Height;                     // Height of a box in inches
};
        
// Function comparing a constant with a CBox object
inline bool operator&gt;(const double value, const CBox&amp; aBox) 
{
  return value &gt; aBox.volume();
}
        
int main()
{
  CBox smallBox {4.0, 2.0, 1.0};
  CBox mediumBox {10.0, 4.0, 2.0};
  <b class="calibre12">CBox aBox;</b>
  <b class="calibre12">CBox bBox;</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">smallBox dimensions are</b> "<b class="calibre12">;</b>
  <b class="calibre12"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="348" id="calibre_link-810" class="calibre14"></span>smallBox.showBox();</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">mediumBox dimensions are</b> "<b class="calibre12">;</b>
  <b class="calibre12">mediumBox.showBox();</b>
  <b class="calibre12">aBox = smallBox + mediumBox;</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">aBox dimensions are</b> "<b class="calibre12">;</b>
  <b class="calibre12">aBox.showBox();</b>
  <b class="calibre12">bBox = aBox + smallBox + mediumBox;</b>
  <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">bBox dimensions are</b> "<b class="calibre12">;</b>
  <b class="calibre12">bBox.showBox();</b>
  <b class="calibre12">return 0;</b>
<b class="calibre12">}</b>       </code></pre>
<p class="calibre20">You’ll be using the <code class="calibre23">CBox</code> class definition again a few pages down the road in this chapter, so note that you’ll want to return to this point in the book.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">I changed the <code class="calibre23">CBox</code> class a little in this example. I deleted the destructor because the default is okay for this class, and I modified the constructor to ensure that the <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code> members are in descending order of magnitude. This uses the <code class="calibre23">max(), min()</code>, and <code class="calibre23">swap()</code> template functions that are defined in the <code class="calibre23">algorithm</code> header. The <code class="calibre23">swap()</code> template function interchanges the values of its arguments.</p>
<p class="calibre20">I’ve also added the <code class="calibre23">showBox()</code> function to output the dimensions of an object. We can use this to verify that our overloaded addition operation is working.</p>
<p class="calibre20">The output from this program is:</p>
<pre class="calibre28"><code class="calibre23">smallBox dimensions are 4 2 1
mediumBox dimensions are 10 4 2
aBox dimensions are 10 4 3
bBox dimensions are 10 6 4</code></pre>
<p class="calibre20">This seems to be consistent with the notion of adding <code class="calibre23">CBox</code> objects that we defined, and, as you can see, the operator works with multiple add operations in an expression. For the computation of <code class="calibre23">bBox</code>, the addition operator function is called twice. The result shows the combination is not optimum.</p>
<p class="calibre20">You could have implemented the addition operation as a <code class="calibre23">friend</code> function. Its prototype would then be:</p>
<pre class="calibre28"><code class="calibre23">friend CBox operator+(const CBox&amp; aBox, const CBox&amp; bBox);</code></pre>
<p class="calibre20">The process for producing the result would be much the same, except that you would use the direct member selection operator to obtain the members for both the arguments to the function.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">algorithm</code> <i class="calibre15">header defines many more template functions that are very useful when you are working with containers, which are covered in Chapter 10.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Overloading the Increment and Decrement Operators</h3>
<p class="calibre13">I’ll briefly introduce the mechanism for overloading the increment and decrement operators in a class because they have some special characteristics that make them different from other unary operators. You need a way to deal with the fact that these operators come in a prefix and postfix <span {http://www.idpf.org/2007/ops}type="pagebreak" title="349" id="calibre_link-811" class="calibre14"></span>form, and the effects differ between the two forms. The operator function is different for the prefix and postfix forms of the increment and decrement operators. Here’s how they would be defined in a class with the name <code class="calibre23">Length</code>, for example:</p>
<pre class="calibre28"><code class="calibre23">class Length
{
  private:
    double m_Length;                    // Length value for the class
        
  public:
    Length&amp; operator++();               // Prefix increment operator
    const Length operator++(int);       // Postfix increment operator
        
    Length&amp; operator--();               // Prefix decrement operator
    const Length operator--(int);       // Postfix decrement operator
        
  // rest of the class...
        
};</code></pre>
<p class="calibre13">This simple class assumes a length is stored just as a value of type <code class="calibre23">double</code>. You would probably make a length class more sophisticated than this but it will serve to illustrate how you overload these operators.</p>
<p class="calibre13">The prefix and postfix forms of the operator functions are differentiated by the parameter list; the prefix form has no parameters whereas there is a parameter of type <code class="calibre23">int</code> for the postfix form. The parameter in the postfix operator function is only there to distinguish it from the prefix form and is not used in the function implementation.</p>
<p class="calibre13">The prefix <code class="calibre23">++</code> and <code class="calibre23">--</code> operators increment or decrement the operand before its value is used in an expression, so you return a reference to the current object <i class="calibre15">after</i> it has been incremented or decremented. Here’s how an implementation of the prefix <code class="calibre23">operator++()</code> function would look for the <code class="calibre23">Length</code> class:</p>
<pre class="calibre28"><code class="calibre23">inline Length&amp; Length::operator++()
{
  ++(this-&gt;m_Length);
  return *this;
}</code></pre>
<p class="calibre13">With the postfix forms, the operand is incremented after its value has been used in an expression. You achieve this by creating a copy of the current object before it has been incremented and you return the copy after you have modified the current object. Here’s how you might implement the postfix <code class="calibre23">++</code> operator for the <code class="calibre23">Length</code> class:</p>
<pre class="calibre28"><code class="calibre23">inline const Length Length::operator++(int)
{
  Length length {*this};               // Copy the current object
  ++*this;                             // Increment the current object
  return length;                       // Return the copy
}</code></pre>
<p class="calibre13">After copying the object, you increment it using the prefix <code class="calibre23">++</code> operator for the class. You return the un-incremented copy of the original object so it is this value that will be used in the expression <span {http://www.idpf.org/2007/ops}type="pagebreak" title="350" id="calibre_link-812" class="calibre14"></span>in which the operator appears. Specifying the return value as <code class="calibre23">const</code> prevents expressions such as <code class="calibre23">data++++</code> from compiling.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Overloading the Function Call Operator</h3>
<p class="calibre13">The function call operator is <code class="calibre23">()</code>, so the function to overload this for a class is <code class="calibre23">operator()()</code>. An object of a class that overloads the function call operator is referred to as a <i class="calibre15">function object</i> or <i class="calibre15">functor</i> because you can use an object name as though it is a function. Let’s look at an example. Here’s a class that overloads the function call operator:</p>
<pre class="calibre28"><code class="calibre23">class Area
{
  public:
  int operator()(int length, int width) { return length*width; }
};</code></pre>
<p class="calibre13">The function call operator in this class calculates an area as the product of its integer arguments. To use this operator function, you just need to create an object of type <code class="calibre23">Area</code>, for example:</p>
<pre class="calibre28"><code class="calibre23">Area area;                                       // Create function object
int pitchLength {100}, pitchWidth {50};
int pitchArea {area(pitchLength, pitchWidth)};   // Execute function call overload</code></pre>
<p class="calibre13">The first statement creates an <code class="calibre23">area</code> object. This object is used in the third statement to call its function call operator overload. This returns the area of a football pitch, in this case.</p>
<p class="calibre13">Of course, you can pass a function object to another function, just as you would any other object. Look at this function:</p>
<pre class="calibre28"><code class="calibre23">void printArea(int length, int width, Area&amp; area)
{
  std::cout &lt;&lt; "Area is " &lt;&lt; area(length, width) &lt;&lt; std::endl;
}</code></pre>
<p class="calibre13">Here is a statement that uses this function:</p>
<pre class="calibre28"><code class="calibre23">printArea(20, 35, Area());</code></pre>
<p class="calibre13">This statement calls the <code class="calibre23">printArea()</code> function with the first two arguments specifying the length and width of a rectangle. The third argument calls the default <code class="calibre23">Area</code> class constructor to create an object that is used in the function to calculate an area. Thus, you can use a function object to pass a function as an argument to another function that is simpler and easier to work with than using a pointer to a function.</p>
<p class="calibre13">Classes that define function objects typically do not need data members and do not have a constructor defined, so there is minimal overhead in creating and using function objects. Function object classes are usually defined as templates because this makes them very flexible.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">In Chapter 10 you’ll learn about the</i> <code class="calibre23">std::function&lt;T&gt;</code> <i class="calibre15">template that provides more flexibility in passing functions around.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-298" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="351" id="calibre_link-813" class="calibre18"></span>THE OBJECT COPYING PROBLEM</h2>
<p class="calibre13">Copying is implicit in passing arguments by value to a function. This is not a problem when the argument is of a fundamental type, but for arguments that are objects of a class type, it can be. The overhead for copying an object can be considerable, especially when the object is large or owns memory that was allocated dynamically. The copy constructor copies an object so the efficiency of this function is critical to execution performance. As you saw with the <code class="calibre23">CMessage</code> class, the assignment operator also involves copying an object. However, there are circumstances where such copy operations are not really necessary, and if you can find a way to avoid them in such situations, execution time can be reduced. Rvalue reference parameters are the key to making this possible.</p>
<section class="toclist">
<h3 class="calibre21">Avoiding Unnecessary Copy Operations</h3>
<p class="calibre13">A modified version of the <code class="calibre23">CMessage</code> class from <code class="calibre23">Ex8_05.cpp</code> will provide a basis for seeing how this works. Here’s a version of the class that implements the addition operator:</p>
<pre class="calibre28"><code class="calibre23">class CMessage
{
  private:
    char* m_pMessage;                    // Pointer to object text string
        
  public:
    // Function to display a message
    void showIt() const
    {
      cout &lt;&lt; m_pMessage &lt;&lt; endl;
    }
        
    <b class="calibre12">// Overloaded addition operator</b>
    <b class="calibre12">CMessage operator+(const CMessage&amp; aMess) const</b>
    <b class="calibre12">{</b>
      <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">Add operator function called." &lt;&lt; endl;</b>
      <b class="calibre12">size_t len {strlen(m_pMessage) + strlen(aMess.m_pMessage) + 1};</b>
      <b class="calibre12">CMessage message;</b>
      <b class="calibre12">message.m_pMessage = new char[len];</b>
      <b class="calibre12">strcpy_s(message.m_pMessage, len, m_pMessage);</b>
      <b class="calibre12">strcat_s(message.m_pMessage, len, aMess.m_pMessage);</b>
      <b class="calibre12">return message;</b>
    <b class="calibre12">}</b>
        
    // Overloaded assignment operator for CMessage objects
    CMessage&amp; operator=(const CMessage&amp; aMess)
    {
      <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">Assignment operator function called." &lt;&lt; endl;</b>
      if(this != &amp;aMess)                   // Check addresses are not equal
      {        
        // Release memory for 1st operand
        delete[] m_pMessage;
        size_t length {strlen(aMess.m_pMessage) + 1};
        m_pMessage = new char[length];
        
        // Copy 2nd operand string to 1st
        <span {http://www.idpf.org/2007/ops}type="pagebreak" title="352" id="calibre_link-814" class="calibre14"></span>strcpy_s(this-&gt;m_pMessage, length, aMess.m_pMessage);
        
      }
      return *this;                           // Return a reference to 1st operand
    }
        
    // Constructor definition
    CMessage(const char* text = "Default message")
    {
      <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">Constructor called." &lt;&lt; endl;</b>
      size_t length {strlen(text) + 1};
      m_pMessage = new char[length];          // Allocate space for text
      strcpy_s(m_pMessage, length, text);     // Copy text to new memory
    }
        
    // Copy constructor definition
    CMessage(const CMessage&amp; aMess)
    {
      <b class="calibre12">cout &lt;&lt;</b> "<b class="calibre12">Copy constructor called." &lt;&lt; endl;</b>
      size_t length {strlen(aMess.m_pMessage) + 1};
      m_pMessage = new char[length];
      strcpy_s(m_pMessage, length, aMess.m_pMessage);
    }
        
    // Destructor to free memory allocated by new
    ~CMessage()
    {
      cout &lt;&lt; "Destructor called." &lt;&lt; endl;   // Just to track what happens
      delete[] m_pMessage;                    // Free memory assigned to pointer
    }
};</code></pre>
<p class="calibre13">The changes from the version in <code class="calibre23">Ex8_05.cpp</code> are highlighted. There is now output from the constructor and the assignment operator functions to trace when they are called. There is also a copy constructor and the <code class="calibre23">operator+()</code> function for adding <code class="calibre23">CMessage</code> objects. You could add versions for concatenating a <code class="calibre23">CMessage</code> object with a string literal, but it’s not needed here. Let’s see how often copying occurs with some simple operations on <code class="calibre23">CMessage</code> objects.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Tracing Object Copy Operations</h3>
<p class="calibre20">Here’s the code to exercise the <code class="calibre23">CMessage</code> class:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_07.cpp
// How many copy operations?
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using std::cout;
using std::endl;
        
// Insert CMessage class definition here...
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="353" id="calibre_link-815" class="calibre14"></span>int main()
{
  CMessage motto1 {"The devil takes care of his own. "};
  CMessage motto2 {"If you sup with the devil use a long spoon.\n"};
  CMessage motto3;
  cout &lt;&lt; " Executing: motto3 = motto1 + motto2 " &lt;&lt; endl; 
  motto3 = motto1 + motto2;
  cout &lt;&lt; " Done!! " &lt;&lt; endl &lt;&lt; endl;
        
  cout &lt;&lt; " Executing: motto3 = motto3 + motto1 + motto2 " &lt;&lt; endl;
  motto3 = motto3 + motto1 + motto2;
  cout &lt;&lt; " Done!! " &lt;&lt; endl &lt;&lt; endl;
        
  cout &lt;&lt; "motto3 contains:" &lt;&lt; endl;
  motto3.showIt();
 
  return 0;
}</code></pre>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Constructor called.
 Executing: motto3 = motto1 + motto2
Add operator function called.
Constructor called.
Copy constructor called.
Destructor called.
Assignment operator function called.
Destructor called.
 Done!!
 
 Executing: motto3 = motto3 + motto1 + motto2
Add operator function called.
Constructor called.
Copy constructor called.
Destructor called.
Add operator function called.
Constructor called.
Copy constructor called.
Destructor called.
Assignment operator function called.
Destructor called.
Destructor called.
 Done!!
 
motto3 contains:
The devil takes care of his own. If you sup with the devil use a long spoon.
The devil takes care of his own. If you sup with the devil use a long spoon.
 
Destructor called.
Destructor called.
Destructor called.</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="354" id="calibre_link-816" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The first statement of interest is:</p>
<pre class="calibre28"><code class="calibre23">  motto3 = motto1 + motto2;              // Use new addition operator</code></pre>
<p class="calibre20">This calls <code class="calibre23">operator+()</code> to add <code class="calibre23">motto1</code> and <code class="calibre23">motto2</code>, and the function calls the constructor to create the temporary object to be returned. The returned object is copied by the copy constructor and destroyed, as you can see from the destructor call. The returned copy is copied into <code class="calibre23">motto3</code> by the <code class="calibre23">operator=()</code> function. Finally, the temporary object &mdash; the copy &mdash; that was the right operand for the assignment is destroyed by calling the destructor. There are two operations that copy temporary objects, which are rvalues, as a result of this statement.</p>
<p class="calibre20">The second statement of interest is:</p>
<pre class="calibre28"><code class="calibre23">  motto3 = motto3 + motto1 + motto2;</code></pre>
<p class="calibre20">The <code class="calibre23">operator+()</code> function is called to concatenate <code class="calibre23">motto3</code> and <code class="calibre23">motto1</code>, and the function calls the constructor to create the result that is to be returned. The object to be returned is copied using the copy constructor, and after the original object that was created is destroyed by the destructor, the copy is concatenated with <code class="calibre23">motto2</code> by calling <code class="calibre23">operator+()</code> once more and the sequence of calls is repeated. Finally, the <code class="calibre23">operator=()</code> function is called to store the result. Thus, for this simple statement, we have three copy operations from temporary objects, two from copy constructor calls, and one from the assignment operator.</p>
<p class="calibre20">All of these copy operations could be expensive in elapsed time if <code class="calibre23">CMessage</code> objects were large or complex. If the copy operations could be avoided, you could improve execution efficiency. Let’s look at how you can do this.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Applying Rvalue Reference Parameters</h3>
<p class="calibre13">When the source <code class="calibre23">CMessage</code> object is a temporary object that is going to be destroyed immediately after a copy operation, the alternative to copying it is to steal the memory that belongs to the temporary object (the memory pointed to by its <code class="calibre23">m_pMessage</code> member) and transfer it to the destination object. If you can do this, you avoid the need to allocate memory for the destination object, you don’t need to copy the data, and there will be no need to release the memory owned by the source object. The source object is going to be destroyed immediately after the operation, so there is no risk in doing this &mdash; just faster execution. The key to performing this trick is to detect when the source object in a copy operation is an rvalue. This is exactly what an rvalue reference parameter enables you to do.</p>
<p class="calibre13">You can create an additional overload for the <code class="calibre23">operator=()</code> function like this:</p>
<pre class="calibre28"><code class="calibre23">    CMessage&amp; operator=(CMessage&amp;&amp; aMess)
    {
      cout &lt;&lt; "Move assignment operator function called." &lt;&lt; endl;
      delete[] m_pMessage;              // Release memory for left operand
      m_pMessage = aMess.m_pMessage;    // Steal string from rhs object
      aMess.m_pMessage = nullptr;       // Null rhs pointer
      return *this;                     // Return a reference to 1st operand
    }</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="355" id="calibre_link-817" class="calibre14"></span>This function is called when the right operand of an assignment is an rvalue &mdash; a temporary object. When the right operand is an lvalue, the original function that has an lvalue reference parameter will be called. The rvalue reference version of the function deletes the string pointed to by the <code class="calibre23">m_pMessage</code> member of the destination object, and copies the address stored in the <code class="calibre23">m_pMessage</code> member of the source object. The <code class="calibre23">m_pMessage</code> member of the source object is then set to <code class="calibre23">nullptr</code>. It is essential that you do this; otherwise, the message would be deleted by the destructor call for the source object. Note that you must not specify the parameter as <code class="calibre23">const</code> in this case, because you are modifying it.</p>
<p class="calibre13">You can apply exactly the same logic to copy constructor operations by adding an overloaded copy constructor with an rvalue reference parameter:</p>
<pre class="calibre28"><code class="calibre23">    CMessage(CMessage&amp;&amp; aMess)
    {
      cout &lt;&lt; "Move constructor called." &lt;&lt; endl;
      m_pMessage = aMess.m_pMessage;
      aMess.m_pMessage = nullptr;
    }</code></pre>
<p class="calibre13">Instead of copying the message belonging to the source object to the object being constructed, you simply transfer the address of the message string from the source object to the new object so the copy is just a move operation. As before, you set <code class="calibre23">m_pMessage</code> for the source object to <code class="calibre23">nullptr</code> to prevent the message string from being deleted by the destructor. A copy constructor with an rvalue reference parameter is called a move constructor.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Efficient Object Copy Operations</h3>
<p class="calibre20">You can create a new console application, <code class="calibre23">Ex8_08</code>, and copy the code from <code class="calibre23">Ex8_07</code>. You can then add the overloaded <code class="calibre23">operator=()</code> and copy constructor functions that I just discussed to the <code class="calibre23">CMessage</code> class definition. This example will produce the following output:</p>
<pre class="calibre28"><code class="calibre23">Constructor called.
Constructor called.
Constructor called.
 Executing: motto3 = motto1 + motto2
Add operator function called.
Constructor called.
Move constructor called.
Destructor called.
Move assignment operator function called.
Destructor called.
 Done!!
 
 Executing: motto3 = motto3 + motto1 + motto2
Add operator function called.
Constructor called.
Move constructor called.
Destructor called.
Add operator function called.
Constructor called.
Move constructor called.
Destructor called.
Move assignment operator function called.
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="356" id="calibre_link-818" class="calibre14"></span>Destructor called.
Destructor called.
 Done!!
 
motto3 contains:
The devil takes care of his own. If you sup with the devil use a long spoon.
The devil takes care of his own. If you sup with the devil use a long spoon.
 
Destructor called.
Destructor called.
Destructor called.</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You can see that all of the copying operations in the previous example now execute as move operations. The assignment operator function calls now use the version with the rvalue reference parameter, as do the move constructor calls . The output shows that <code class="calibre23">motto3</code> ends up with the same string as before, so everything is working as it should.</p>
<p class="calibre20">For classes that define complex or large objects, implmenting a move assignment operator and move constructor in addition to the assignment operator and copy constructor can improve performance significantly.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">If you define the</i> <code class="calibre23">operator=()</code> <i class="calibre15">member function and the copy constructor in a class with the parameters as non</i>-<code class="calibre23">const</code> <i class="calibre15">rvalue references, make sure you also define the standard versions with</i> <code class="calibre23">const</code> <i class="calibre15">lvalue reference parameters. If you don’t, the compiler will supply default versions of these that perform member-by-member copying. This will certainly not be what you want.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Named Objects Are Lvalues</h3>
<p class="calibre13">When the move assignment operator in the <code class="calibre23">CMessage</code> class is called, you know for certain that the argument &mdash; the right operand &mdash; is an rvalue and is therefore a temporary object from which you can steal memory. However, the parameter, <code class="calibre23">aMess</code>, within the body of this operator function is an lvalue. This is because any expression that is a named variable is an lvalue. This can result in inefficiencies creeping back in, as I can demonstrate using a modified version of the <code class="calibre23">CMessage</code> class:</p>
<pre class="calibre28"><code class="calibre23">class CMessage
{
private:
  CText m_Text;                    // Object text string
        
public:
  // Function to display a message
  void showIt() const
  {
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="357" id="calibre_link-819" class="calibre14"></span>m_Text.showIt();
  }
        
  // Overloaded addition operator
  CMessage operator+(const CMessage&amp; aMess) const
  {
    cout &lt;&lt; "CMessage add operator function called." &lt;&lt; endl;
    CMessage message;
    message.m_Text = m_Text + aMess.m_Text;
    return message;
  }
        
  // Copy assignment operator for CMessage objects
  CMessage&amp; operator=(const CMessage&amp; aMess)
  {
    cout &lt;&lt; "CMessage copy assignment operator function called." &lt;&lt; endl;
    if(this != &amp;aMess)               // Check addresses not equal
    {
      m_Text = aMess.m_Text;
    }
    return *this;                    // Return a reference to 1st operand
  }
        
  // Move assignment operator for CMessage objects
  CMessage&amp; operator=(CMessage&amp;&amp; aMess)
  {
    cout &lt;&lt; "CMessage move assignment operator function called." &lt;&lt; endl;
    m_Text = aMess.m_Text;
    return *this;                    // Return a reference to 1st operand
  }
        
  // Constructor definition
  CMessage(const char* str = "Default message")
  {
    cout &lt;&lt; "CMessage constructor called." &lt;&lt; endl;
    m_Text = CText(str);
  }
        
  // Copy constructor definition
  CMessage(const CMessage&amp; aMess)
  {
    cout &lt;&lt; "CMessage copy constructor called." &lt;&lt; endl;
    m_Text = aMess.m_Text;
  }
        
  // Move constructor definition
  CMessage(CMessage&amp;&amp; aMess)
  {
    cout &lt;&lt; "CMessage move constructor called." &lt;&lt; endl;
    m_Text = aMess.m_Text;
  }
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="358" id="calibre_link-820" class="calibre14"></span>The text for the message is now stored as an object of type <code class="calibre23">CText</code>, and the member functions of the class have been changed accordingly. Note that the class is kitted out with rvalue reference versions of the copy constructor and the assignment operator, so it should move rather than create new objects when it is feasible to do so. Here’s the definition of the <code class="calibre23">CText</code> class:</p>
<pre class="calibre28"><code class="calibre23">class CText
{
private:
  char* pText;
        
public:
  // Function to display text
  void showIt() const
  {
    cout &lt;&lt; pText &lt;&lt; endl;
  }
      
  // Constructor
  CText(const char* pStr="No text")
  {
    cout &lt;&lt; "CText constructor called." &lt;&lt; endl;
    size_t len {strlen(pStr)+1};
    pText = new char[len];                         // Allocate space for text
    strcpy_s(pText, len, pStr);                    // Copy text to new memory
  }
        
  // Copy constructor definition
  CText(const CText&amp; txt)
  {
    cout &lt;&lt; "CText copy constructor called." &lt;&lt; endl;
    size_t len {strlen(txt.pText)+1};
    pText = new char[len];
    strcpy_s(pText, len, txt.pText);
  }
        
  // Move constructor definition
  CText(CText&amp;&amp; txt)
  {
    cout &lt;&lt; "CText move constructor called." &lt;&lt; endl;
    pText = txt.pText;
    txt.pText = nullptr;
  }
        
  // Destructor to free memory allocated by new
  ~CText()
  {
    cout &lt;&lt; "CText destructor called." &lt;&lt; endl;    // Just to track what happens
    delete[] pText;                                // Free memory
  }
        
  // Assignment operator for CText objects
  CText&amp; operator=(const CText&amp; txt)
  {
    cout &lt;&lt; "CText assignment operator function called." &lt;&lt; endl;
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="359" id="calibre_link-821" class="calibre14"></span>if(this != &amp;txt)                        // Check addresses not equal
    {
      delete[] pText;                       // Release memory for 1st operand
      size_t length {strlen(txt.pText) + 1};
      pText = new char[length];
      
      // Copy 2nd operand string to 1st
      strcpy_s(this-&gt;pText, length, txt.pText);
    }
    return *this;                           // Return a reference to 1st operand
  }
        
  // Move assignment operator for CText objects
  CText&amp; operator=(CText&amp;&amp; txt)
  {
    cout &lt;&lt; "CText move assignment operator function called." &lt;&lt; endl;
    delete[] pText;                         // Release memory for 1st operand
    pText = txt.pText;
    txt.pText = nullptr;
    return *this;                           // Return a reference to 1st operand
  }
      
  // Overloaded addition operator
  CText operator+(const CText&amp; txt) const
  {
    cout &lt;&lt; "CText add operator function called." &lt;&lt; endl;
    size_t length {strlen(pText) + strlen(txt.pText) + 1};
    CText aText;
    aText.pText = new char[length];
    strcpy_s(aText.pText, length, pText);
    strcat_s(aText.pText, length, txt.pText);
    return aText;
  }
};</code></pre>
<p class="calibre13">It looks like a lot of code, but this is because the class has overloaded versions of the copy constructor and the assignment operator, and it has the <code class="calibre23">operator+()</code> function defined as well as a move constructor and move assignment operator. The <code class="calibre23">CMessage</code> class makes use of these in the implementation of its member functions. There are also output statements to trace when each function is called. Let’s exercise these classes with an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Creeping Inefficiencies</h3>
<p class="calibre20">Here’s a simple <code class="calibre23">main()</code> function that uses the <code class="calibre23">CMessage</code> copy constructor and assignment operator:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_09.cpp Creeping inefficiencies
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using std::cout;
using std::endl;
        
// Insert CText class definition here...
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="360" id="calibre_link-822" class="calibre14"></span>// Insert CMessage class definition here...
        
int main()
{
  CMessage motto1 {"The devil takes care of his own. "};
  CMessage motto2 {"If you sup with the devil use a long spoon.\n"};
        
  cout &lt;&lt; endl &lt;&lt; " Executing: CMessage motto3{motto1+motto2}; " &lt;&lt; endl;
  CMessage motto3 {motto1+motto2};
  cout &lt;&lt; " Done!! " &lt;&lt; endl &lt;&lt; endl &lt;&lt; "motto3 contains:" &lt;&lt; endl;
   motto3.showIt();
  CMessage motto4;
  cout &lt;&lt; " Executing: motto4 = motto3 + motto2; " &lt;&lt; endl;
  motto4 = motto3 + motto2;
  cout &lt;&lt; " Done!! " &lt;&lt; endl &lt;&lt; endl &lt;&lt; "motto4 contains:" &lt;&lt; endl;
  motto4.showIt();
 
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">It’s a lot of output from relatively few statements in <code class="calibre23">main()</code>. I’ll just discuss the interesting bits. Let’s first consider the output arising from executing the statement:</p>
<pre class="calibre28"><code class="calibre23">  CMessage motto3 {motto1+motto2};</code></pre>
<p class="calibre20">The output looks like this:</p>
<pre class="calibre28"><code class="calibre23">CMessage add operator function called.
CText constructor called.
CMessage constructor called.
CText constructor called.
CText move assignment operator function called.
CText destructor called.
CText add operator function called.
CText constructor called.
CText move constructor called.
CText destructor called.
CText move assignment operator function called.
CText destructor called.
CText constructor called.
CMessage move constructor called.
CText assignment operator function called.
CText destructor called.</code></pre>
<p class="calibre20">To see what is happening, you need to relate the output to the code in the functions that are called. First, <code class="calibre23">operator+()</code> for the <code class="calibre23">CMessage</code> class is called to concatenate <code class="calibre23">motto1</code> and <code class="calibre23">motto2</code>. In the body of this function, the <code class="calibre23">CMessage</code> constructor is called to create the message object, and within this process, the <code class="calibre23">CText</code> constructor is called. Everything is going swimmingly until we get to the second to last line of output, following the line indicating the <code class="calibre23">CMessage</code> move constructor is called. When this constructor executes, the argument must have been a temporary &mdash; an rvalue &mdash; so the assignment statement in the body of the function that stores the value of the <code class="calibre23">text</code> member should be a move assignment operation for <code class="calibre23">CText</code> objects, not a copy assignment. The problem arises because within the <code class="calibre23">CMessage</code> move <span {http://www.idpf.org/2007/ops}type="pagebreak" title="361" id="calibre_link-823" class="calibre14"></span>constructor, the <code class="calibre23">aMess</code> parameter is an lvalue because it has a name, in spite of the fact that we know for certain that the argument passed to the function was an rvalue. This means that <code class="calibre23">aMess.m_Text</code> is also an lvalue. If it weren’t, the <code class="calibre23">CMessage</code> copy constructor would be called.</p>
<p class="calibre20">The same problem arises with this statement:</p>
<pre class="calibre28"><code class="calibre23">  motto4 = motto3 + motto2;</code></pre>
<p class="calibre20">If you look at the output from this, you’ll see that exactly the same problem arises when the move assignment operator for <code class="calibre23">CMessage</code> objects is called. The <code class="calibre23">m_Text</code> member of the argument is copied when really it could be moved.</p>
<p class="calibre20">To fix these inefficiencies you need a way to force <code class="calibre23">aMess.m_Text</code> to be an <code class="calibre23">rvalue</code> in the move assignment and move constructor functions in the <code class="calibre23">CMessage</code> class. The <code class="calibre23">utility</code> library header thoughtfully provides you with the <code class="calibre23">std::move()</code> function that will do precisely what you want. This function returns whatever argument you pass to it as an rvalue. You can change the <code class="calibre23">CMessage</code> move constructor like this:</p>
<pre class="calibre28"><code class="calibre23">   CMessage(CMessage&amp;&amp; aMess)
   {
     cout &lt;&lt; "CMessage move constructor called." &lt;&lt; endl;
     <b class="calibre12">m_Text = std::move(aMess.m_Text);</b>
   }</code></pre>
<p class="calibre20">Now, the right-hand side of the assignment that sets up the <code class="calibre23">m_Text</code> member of the new object is an rvalue so the move assignment operator function in the <code class="calibre23">CText</code> class will be called, not the copy assignment operator function.</p>
<p class="calibre20">You can modify the move assignment operator function in a similar way:</p>
<pre class="calibre28"><code class="calibre23">   CMessage&amp; operator=(CMessage&amp;&amp; aMess)
   {
    cout &lt;&lt; "CMessage move assignment operator function called." &lt;&lt; endl;
     <b class="calibre12">m_Text = std::move(aMess.m_Text);</b>
     return *this;                    // Return a reference to 1st operand
   }</code></pre>
<p class="calibre20">The <code class="calibre23">std::move()</code> function is declared in the <code class="calibre23">utility</code> header, so you should add an <code class="calibre23">#include</code> directive for this to the example. This version is <code class="calibre23">Ex8_09A.cpp</code> in the download. If you compile the program and execute it once more, the output will show that you now get the <code class="calibre23">CText</code> move assignment operator function called from the two functions you have modified. Implementing a move constructor and a move assignment operator in a class is referred to as <i class="calibre15">move semantics</i>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-299" class="calibre3"></a>DEFAULT CLASS MEMBERS</h2>
<p class="calibre13">It is useful to keep in mind everything that the compiler may supply by default for a class. Suppose you define a class like this:</p>
<pre class="calibre28"><code class="calibre23">class MyClass
{
public:
  int data {};
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="362" id="calibre_link-824" class="calibre14"></span>With just a single data member, you might imagine you can do very little with this class, but the compiler contributes some members. If you don’t specify them, the compiler will supply definitions for:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">A default constructor:
<pre class="calibre28"><code class="calibre23">MyClass(){}</code></pre></li>
<li class="calibre6">A copy constructor that does member-by-member copying:
<pre class="calibre28"><code class="calibre23">MyClass(const MyClass&amp; obj) {/* Copy members */}</code></pre></li>
<li class="calibre6">A destructor defined as:
<pre class="calibre28"><code class="calibre23">~MyClass(){}</code></pre></li>
<li class="calibre6">A default assignment operator that does member-by-member copying:
<pre class="calibre28"><code class="calibre23">MyClass&amp; operator=(const MyClass&amp; obj) {/* Copy members */}</code></pre></li>
</ul>
<p class="calibre13">If you define any constructor, the default constructor will not be supplied. If you don’t want the default copy constructor and assignment operator to be in effect, you must define them. You can mark them with <code class="calibre23">= delete</code> if you don’t want them to be included in the class. You can specify the inclusion of the members that are supplied by default using the <code class="calibre23">default</code> keyword, so you could define <code class="calibre23">MyClass</code> like this:</p>
<pre class="calibre28"><code class="calibre23">class MyClass
{
public:
  int data {};
 
  MyClass() = default;                                // No-arg constructor
  MyClass(const MyClass&amp; obj) = default;              // Copy constructor
  MyClass&amp; operator=(const MyClass&amp; obj) = default;   // Assignment operator
  ~MyClass() = default;                               // Destructor
};</code></pre>
<p class="calibre13">Specifying these members like this demonstrates that their inclusion is what you intend.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">Visual C++ does not currently implement the automatic provision of a default move constructor and move assignment operator in a class. You cannot use the</i> <code class="calibre23">default</code> <i class="calibre15">keyword to get these created for a class, so you must define them when you need them. This is not consistent with the latest language standard, which says that these members should be generated by default.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-300" class="calibre3"></a>CLASS TEMPLATES</h2>
<p class="calibre13">You saw in Chapter 6 that you could define a function template that automatically generates functions from the type of arguments accepted, or from the type of values returned. There is a similar mechanism for classes. A <i class="calibre15">class template</i> is not a class, but a sort of “recipe” for a class that the compiler uses to generate a class definition. As <a id="calibre_link-1366" href="#calibre_link-414" class="calibre3">Figure 8-4</a> shows, it’s like a function template &mdash; you specify a class by supplying a type for the parameter (<code class="calibre23">T</code>, in this case) that appears between the angled brackets in the template. This generates a particular class that is referred to as an <i class="calibre15">instance</i> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="363" id="calibre_link-825" class="calibre14"></span>or a <i class="calibre15">specialization</i> of the template. Creating a class from a template is described as <i class="calibre15">instantiating</i> the template. Like function templates, class templates can have several parameters.</p>
<figure class="calibre16">
<img class="center" src="images/000127.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-414" href="#calibre_link-1366" class="calibre3">FIGURE 8-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">A class definition is generated when you instantiate a class template with a type argument for each template parameter, so you can generate any number of different classes from a single template. The principle use of class templates is in defining library classes, particularly container classes that organize and store collections of objects.</p>
<p class="calibre13">You would not normally define templates for a single application so you won’t need to define your own class templates very often. However, the standard library uses class templates extensively and it’s important to understand how templates are defined and how they work because there are potential pitfalls with their use. You’ll learn about the templates that define container classes in Chapter 10. A good way to understand how a class template is defined and works in practice is by looking at an example.</p>
<section class="toclist">
<h3 class="calibre21">Defining a Class Template</h3>
<p class="calibre13">I’ll choose a simple example, and I won’t complicate things by worrying too much about errors that might arise if it’s misused. Suppose you want to define classes that can store several data values of some type, and provide a <code class="calibre23">max()</code> function to return the maximum of the values stored. You could define a template to generate a <code class="calibre23">CSamples</code> class to store samples of any type:</p>
<pre class="calibre28"><code class="calibre23">template &lt;class T&gt;
class CSamples
{
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="364" id="calibre_link-826" class="calibre14"></span>public:
    // Constructor definition to accept an array of samples
    CSamples(const T values[], int count)
    {
      m_Next = count &lt; maxSamples ? count : maxSamples; // Don't exceed the array
      for(int i {}; i &lt; m_Next; i++)                    // Store count samples
        m_Values[i] = values[i];
    }
        
    // Constructor to accept a single sample
    CSamples(const T&amp; value)
    {
      m_Values[0] = value;                    // Store the sample
      m_Next = 1;                             // Next is free
    }
        
    CSamples() = default;                     // Default constructor 
        
    // Function to add a sample
    bool add(const T&amp; value)
    {
      bool OK {m_Next &lt; maxSamples};          // Indicates there is a free place
      if(OK)
        m_Values[m_Next++] = value;           // OK true, so store the value
      return OK;
    }
        
    // Function to obtain maximum sample
    T max() const
    {
      // Set first sample as maximum
      T theMax {m_Values[0]};
        
      for(int i {1}; i &lt; m_Next; i++)         // Check all the samples
        if(m_Values[i] &gt; theMax)
          theMax = m_Values[i];               // Store any larger sample
      return theMax;
    }
        
  private:
    static const size_t maxSamples {100};     // Maximum number of samples
    T m_Values[maxSamples];                   // Array to store samples
    int m_Next {};                            // Index of next free location
};</code></pre>
<p class="calibre13">The <code class="calibre23">template</code> keyword indicates that you are defining a template. This is followed by the type parameter, <code class="calibre23">T</code>, between angled brackets, preceding the <code class="calibre23">class</code> keyword and the class name. This is essentially the same as the syntax you use for a function template. You can use <code class="calibre23">typename</code> instead of <code class="calibre23">class</code> to specify the parameters.</p>
<p class="calibre13">The compiler creates a definition for a <code class="calibre23">CSamples&lt;T&gt;</code> class for a specific <code class="calibre23">T</code> when you define an object of this type. Wherever <code class="calibre23">T</code> appears in the template definition, it will be replaced by the type that you specify in your object declaration; this creates a class definition corresponding to this type argument. You can specify any type (a fundamental data type or a class type) for <code class="calibre23">T</code>, but it has to make <span {http://www.idpf.org/2007/ops}type="pagebreak" title="365" id="calibre_link-827" class="calibre14"></span>sense in the context of the template of course. A class type that you use to instantiate a template must have all the operators defined that the member functions of the template use with such objects. If your class hasn’t implemented <code class="calibre23">operator&gt;()</code>, for example, it will not work with the <code class="calibre23">CSamples&lt;T&gt;</code> class template.</p>
<p class="calibre13">In our class template the samples are stored in an array of type <code class="calibre23">T[]</code>. The array will be an array of elements of whatever type you specify for <code class="calibre23">T</code> when you define a <code class="calibre23">CSamples&lt;T&gt;</code> object. You use the type <code class="calibre23">T</code> in two of the constructors as well as in the <code class="calibre23">add()</code> and <code class="calibre23">max()</code> functions. Each occurrence of <code class="calibre23">T</code> will be replaced by your type when you instantiate the template.</p>
<p class="calibre13">The constructors support the creation of an empty object, an object with a single value, and an object initialized with an array of values. The <code class="calibre23">add()</code> function allows values to be added one at a time. You could overload this function to add an array of values. The template includes some elementary provision to prevent the capacity of the <code class="calibre23">m_Values</code> array being exceeded in the <code class="calibre23">add()</code> function and in the constructor that accepts an array of values.</p>
<p class="calibre13">In theory, you can create instances of a class template that will handle any data type: type <code class="calibre23">int</code>, type <code class="calibre23">double</code>, type <code class="calibre23">CBox</code>, or any other class type. In practice, an instance of a class template won’t necessarily compile and work as you expect. It depends on what the template definition does and usually a template will only work for a particular range of types. Clearly, you’ll usually be in the position of defining a template that works for some types but not others, but there’s no easy way you can restrict what type is applied to a template.</p>
<section class="toclist">
<h4 class="calibre22">Template Member Functions</h4>
<p class="calibre13">You can place the definition of a member function for class template outside of the template. If you do, the definition must appear in the header file that contains the definition of the template, not in a separate <code class="calibre23">.cpp</code> file. The syntax for defining a member function outside a template isn’t particularly obvious, so let’s look at how you do it. First, you declare the function as a member of the class template in the normal way. For instance:</p>
<pre class="calibre28"><code class="calibre23">template &lt;typename T&gt;
class CSamples
{
  // Rest of the template definition...
  <b class="calibre12">T max() const;             // Function to obtain maximum sample</b>
  // Rest of the template definition...
}</code></pre>
<p class="calibre13">This declares <code class="calibre23">max()</code>as a member of the template, but doesn’t define it. You need a separate function template for <code class="calibre23">max()</code> and this must go in the header file. You use the template class name plus the parameters in angled brackets to identify the class template to which the function template belongs:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt;
T CSamples&lt;T&gt;::max() const
{
  // Set first sample as maximum
  T theMax {m_Values[0]};
        
  for(int i {1}; i &lt; m_Next; i++)         // Check all the samples
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="366" id="calibre_link-828" class="calibre14"></span>if(theMax &lt; m_Values[i])
      theMax = m_Values[i];               // Store any larger sample
  return theMax;
}</code></pre>
<p class="calibre13">A function template for a member of a class template must have the same type parameters as the class template definition. There’s just one in this case &mdash; <code class="calibre23">T</code> &mdash; but in general there can be several. If the class template had two or more parameters, then so would templates that define member functions.</p>
<p class="calibre13">Note how you qualify the function name with the template name followed by the parameter <code class="calibre23">T</code> between angled brackets. The combination of the template name and the parameters identify the class to which an instance of the function template belongs. The type will be <code class="calibre23">CSamples&lt;T&gt;</code>, with <code class="calibre23">T</code> replaced by the type argument you used to declare an object. Each class that’s produced from the template will have its own definition for <code class="calibre23">max()</code>. This means that if you create ten different classes from the template, there will be ten copies of the <code class="calibre23">max()</code> function in memory.</p>
<p class="calibre13">You can define a constructor or a destructor outside of a class template in a similar way. You could write the definition of the constructor that accepts an array of samples as:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt;
CSamples&lt;T&gt;::CSamples(const T values[], int count)
{
  m_Next = count &lt; maxSamples ? count : maxSamples; // Don't exceed the array
        
  for(int i {}; i &lt; m_Next; i++)
    m_Values[i] = values[i];                      // Store count number of samples
}</code></pre>
<p class="calibre13">You specify the class to which the constructor belongs in the template in the same way as for an ordinary member function. The constructor name doesn’t require the type parameter specification &mdash; it is just <code class="calibre23">CSamples</code>, but it must be qualified by the class template type name <code class="calibre23">CSamples&lt;T&gt;</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Member functions that you define outside a class template definition must be in the header file that defines the class template. If they are not, the template won’t compile.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Creating Objects from a Class Template</h3>
<p class="calibre13">When you use a function defined by a template, the compiler can deduce the template type arguments from the types of the function arguments. The type parameters for a function template are implicitly defined by the specific use of a function. Class templates are different. To create an object based on a class template, you must specify the type parameters following the class name in the declaration.</p>
<p class="calibre13">For example, to define a <code class="calibre23">CSamples&lt;T&gt;</code> object to handle samples of type <code class="calibre23">double</code>, you could write the declaration as:</p>
<pre class="calibre28"><code class="calibre23">CSamples&lt;double&gt; myData {10.0};</code></pre>
<p class="calibre13">This defines an object of type <code class="calibre23">CSamples&lt;double&gt;</code> that can store samples of type <code class="calibre23">double</code>. The object is created with one sample stored.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="367" id="calibre_link-829" class="calibre24"></span>TRY IT OUT: Using a Class Template</h3>
<p class="calibre20">You could create an object from a slightly extended version of the <code class="calibre23">CSamples&lt;&gt;</code> template to store <code class="calibre23">CBox</code> objects. This will work because the <code class="calibre23">CBox</code> class implements the <code class="calibre23">operator&gt;()</code> function to overload the greater-than operator. You could exercise the class template with the <code class="calibre23">main()</code> function in the following code:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_10.cpp
// Using a class template
#include &lt;iostream&gt;
#include &lt;utility&gt;                          // For operator overload templates
#include &lt;algorithm&gt;                        // For max(), swap() used in CBox
using std::cout;
using std::endl;
using namespace std::rel_ops;
        
<b class="calibre12">// Put the CBox class definition from Ex8_06.cpp here...</b>
 
// CSamples class template definition
template &lt;typename T&gt; class CSamples
{
  public:
    // Constructors
    CSamples(const T values[], int count);
    CSamples(const T&amp; value);
    CSamples(T&amp;&amp; value);
    CSamples() = default;
        
    bool add(const T&amp; value);               // Insert a value
    bool add(T&amp;&amp; value);                    // Insert a value with move semantics
    T max() const;                          // Calculate maximum
        
  private:
    static const size_t maxSamples {100};   // Maximum number of samples
    T m_Values[maxSamples];                 // Array to store samples
    int m_Next {};                          // Index of free location in m_Values
};        
       
// Constructor template definition to accept an array of samples
template&lt;typename T&gt; CSamples&lt;T&gt;::CSamples(const T values[], int count)
{
  m_Next = count &lt; maxSamples ? count : maxSamples;       // Don't exceed the array
  for(int i {}; i &lt; m_Next; i++)            // Store count of samples
    m_Values[i] = values[i];                
}
        
// Constructor to accept a single sample
template&lt;typename T&gt; CSamples&lt;T&gt;::CSamples(const T&amp; value)
{
  m_Values[0] = value;                      // Store the sample
  m_Next = 1;                               // Next is free
}
        
// Constructor to accept a temporary sample
template&lt;typename T&gt; CSamples&lt;T&gt;::CSamples(T&amp;&amp; value)
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="368" id="calibre_link-830" class="calibre14"></span>{
  cout &lt;&lt; "Move constructor." &lt;&lt; endl;
  m_Values[0] = std::move(value);           // Store the sample
  m_Next = 1;                               // Next is free
}
        
// Function to add a sample
template&lt;typename T&gt; bool CSamples&lt;T&gt;::add(const T&amp; value)
{
  cout &lt;&lt; "Add." &lt;&lt; endl;
  bool OK {m_Next &lt; maxSamples};            // Indicates there is a free place
  if(OK)
    m_Values[m_Next++] = value;             // OK true, so store the value
  return OK;
}
        
template&lt;typename T&gt; bool CSamples&lt;T&gt;::add(T&amp;&amp; value)
{
  cout &lt;&lt; "Add move." &lt;&lt; endl;
  bool OK {m_Next &lt; maxSamples};            // Indicates there is a free place
  if(OK)
    m_Values[m_Next++] = std::move(value);  // OK true, so store the value
  return OK;
}
 
// Function to obtain maximum sample
template&lt;typename T&gt; T CSamples&lt;T&gt;::max() const
{
  T theMax {m_Values[0]};                   // Set first sample as maximum
  for(int i {1}; i &lt; m_Next; i++)           // Check all the samples
    if(theMax &lt; m_Values[i])
      theMax = m_Values[i];                 // Store any larger sample
  return theMax;
}
        
int main()
{
  CBox boxes[]  {                           // Create an array of boxes
                  CBox { 8.0, 5.0, 2.0 },   // Initialize the boxes...
                  CBox { 5.0, 4.0, 6.0 },
                  CBox { 4.0, 3.0, 3.0 }
                };
 
  // Create the CSamples object to hold CBox objects
  CSamples&lt;CBox&gt; myBoxes {boxes, _countof(boxes)};
 
  CBox maxBox {myBoxes.max()};              // Get the biggest box
  cout &lt;&lt; "The biggest box has a volume of "// and output its volume
       &lt;&lt; maxBox.volume() &lt;&lt; endl;
  CSamples&lt;CBox&gt; moreBoxes {CBox { 8.0, 5.0, 2.0 }};
  moreBoxes.aAdd(CBox { 5.0, 4.0, 6.0 });
  moreBoxes.aAdd(CBox { 4.0, 3.0, 3.0 });
  cout &lt;&lt; "The biggest box has a volume of "
       <span {http://www.idpf.org/2007/ops}type="pagebreak" title="369" id="calibre_link-831" class="calibre14"></span>&lt;&lt; moreBoxes.max().volume() &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">Replace the comment with the <code class="calibre23">CBox</code> class and function definitions from <code class="calibre23">Ex8_06.cpp</code>. Except for the default constructor, all member functions of the template are defined by separate function templates, just to show you a complete example of how it’s done. The <code class="calibre23">CSamples&lt;T&gt;</code> template includes a constructor and an <code class="calibre23">add()</code> function that have move semantics.</p>
<p class="calibre20">You create an array of three <code class="calibre23">CBox</code> objects in <code class="calibre23">main()</code> and use this array to initialize a <code class="calibre23">CSamples&lt;CBox&gt;</code> object. The declaration of the object is basically the same as it would be for an ordinary class, but with the addition of the template type parameter in angled brackets following the template name.</p>
<p class="calibre20">Next, you create the <code class="calibre23">moreBoxes</code> object but in a different way. This time the constructor and <code class="calibre23">add()</code> function with move semantics are called because the arguments are rvalues.</p>
<p class="calibre20">The program will generate the following output:</p>
<pre class="calibre28"><code class="calibre23">The biggest box has a volume of 120
Move constructor.
Add move.
Add move.
The biggest box has a volume of 120</code></pre>
<p class="calibre20">When you create an instance of a class template, it does not follow that instances of the templates for function members will also be created. The compiler will only create instances of templates for member functions that you call in your program. In fact, as with templates for ordinary functions, your function templates can contain coding errors and, as long as you don’t call the member function that belongs to the template, the compiler won’t complain. You can test this out with the example. Try introducing an error into the template for the non-move <code class="calibre23">add()</code> member &mdash; maybe just delete a semicolon. The program will still compile and run because it doesn’t call that version of the <code class="calibre23">add()</code> function.</p>
<p class="calibre20">You could try modifying the example to see what happens when you instantiate classes using various other types.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You might be surprised at what happens if you add some output statements to the constructors. The constructors for</i> <code class="calibre23">CBox</code> <i class="calibre15">are called 103 times for the operations with</i> <code class="calibre23">myBoxes</code> <i class="calibre15">alone! Look at what happens in</i> <code class="calibre23">main()</code>. <i class="calibre15">First, you create an array of three</i> <code class="calibre23">CBox</code> <i class="calibre15">objects, so that’s three calls. You then create a</i> <code class="calibre23">CSamples</code> <i class="calibre15">object to hold them, but a</i> <code class="calibre23">CSamples</code> <i class="calibre15">object contains an array of 100</i> <code class="calibre23">CBox</code> <i class="calibre15">elements so you call the default constructor 100 times, once for each element. Of course, the</i> <code class="calibre23">maxBox</code> <i class="calibre15">object is created by the default copy constructor.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="370" id="calibre_link-832" class="calibre24"></span>Class Templates with Multiple Parameters</h3>
<p class="calibre13">Using multiple type parameters in a class template is a straightforward extension of using a single parameter. You can use each type parameter wherever you want in the template definition. For example, here’s a template with two parameters:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T1, typename T2&gt;
class CExampleClass
{
  // Class data members
        
  private:
    T1 m_Value1;
    T2 m_Value2;
        
  // Rest of the template definition...
};</code></pre>
<p class="calibre13">The types of the class data members will be determined by the types you supply for the parameters when you instantiate an instance of the template. You can explicitly instantiate a template without defining any objects. For example, you can write the following statement after the definition of the <code class="calibre23">CSamples&lt;T&gt;</code> template:</p>
<pre class="calibre28"><code class="calibre23">template class CSamples&lt;Foo&gt;;</code></pre>
<p class="calibre13">This explicitly instantiates <code class="calibre23">CSamples</code> for type <code class="calibre23">Foo</code>, but it doesn’t instantiate any objects yet. The <code class="calibre23">Foo</code> class has to be available for this to compile. If <code class="calibre23">Foo</code> doesn’t implement all the member functions required by the template, then the compiler will produce an error message with the explicit instantiation, just as it would when you define an object of the type.</p>
<p class="calibre13">The parameters in a class template aren’t limited to types. You can specify parameters that require constants or constant expressions to be substituted in the class definition. In our <code class="calibre23">CSamples&lt;T&gt;</code> template, we arbitrarily defined the <code class="calibre23">m_Values</code> array with 100 elements. You could let the user of the template choose the size of the array when an object is instantiated by defining the template as:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">template &lt;typename T, size_t Size&gt; class CSamples</b>
{
  private:
    <b class="calibre12">T m_Values[Size];                 // Array to store samples</b>
    int m_Next {};                    // Index of free location in m_Values
        
  public:
    // Constructor definition to accept an array of samples
    CSamples(const T values[], int count)
    {
      <b class="calibre12">m_Next = count &lt; Size ? count : Size; // Don't exceed the array</b>
        
      for(int i {}; i &lt; m_Next; i++)
        m_Values[i] = values[i];            // Store count number of samples
    }
        
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="371" id="calibre_link-833" class="calibre14"></span>// Constructor to accept a single sample
    CSamples(const T&amp; value)
    {
      m_Values[0] = value;                  // Store the sample
      m_Next = 1;                           // Next is free
    }
        
    CSamples() = default;
 
    // Function to add a sample
    int add(const T&amp; value)
    {
      <b class="calibre12">int OK {m_Next &lt; Size};               // Indicates there is a free place</b>
      if(OK)
        m_Values[m_Next++] = value;         // OK true, so store the value
      return OK;
    }
        
    // Function to obtain maximum sample
    T max() const
    {
      // Set first sample as maximum
      T theMax {m_Values[0]};
        
      for(int i {1}; i &lt; m_Next; i++)       // Check all the samples
        if(m_Values[i] &gt; theMax)
          theMax = m_Values[i];             // Store any larger sample
      return theMax;
    }
};</code></pre>
<p class="calibre13">The value supplied for <code class="calibre23">Size</code> when you create an instance of the template will replace all occurrences of the parameter in the template definition. Now you can define the <code class="calibre23">CSamples</code> object from the previous example as:</p>
<pre class="calibre28"><code class="calibre23">CSamples&lt;CBox, 3&gt; myBoxes {boxes, _countof(boxes)};</code></pre>
<p class="calibre13">Because you can supply <i class="calibre15">any</i> constant expression for the <code class="calibre23">Size</code> parameter, you could also have written this as:</p>
<pre class="calibre28"><code class="calibre23">CSamples&lt;CBox, _countof(boxes)&gt; myBoxes {boxes, _countof(boxes)};</code></pre>
<p class="calibre13">The example is a poor template, though &mdash; the original version was more flexible. A consequence of making <code class="calibre23">Size</code> a template parameter is that instances of the template that store the same type of objects but have different values for the <code class="calibre23">Size</code> parameter are different class types and cannot be mixed. For instance, an object of type <code class="calibre23">CSamples&lt;double,10&gt;</code> cannot be used in an expression with an object of type <code class="calibre23">CSamples&lt;double,20&gt;</code>.</p>
<p class="calibre13">You need to be careful with expressions that involve comparison operators when instantiating templates. Look at these statements:</p>
<pre class="calibre28"><code class="calibre23">CBox myBoxes[] = {CBox {1,2,3}, CBox {2,3,4},CBox {4,5,6}, CBox {5,7,8}};
CSamples&lt;CBox, _countof(myBoxes) &gt; 3 ? 3 : 2 &gt; mySamples {myBoxes,4};// Wrong!</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="372" id="calibre_link-834" class="calibre14"></span>This will not compile correctly because the <code class="calibre23">&gt;</code> following <code class="calibre23">_countof(myBoxes)</code> in the expression will be interpreted as the right angled bracket at the end of the argument list. You must write this statement as:</p>
<pre class="calibre28"><code class="calibre23">CSamples&lt;CBox, (_countof(myBoxes) &gt; 3 ? 3 : 2) &gt; mySamples {myBoxes,4};</code></pre>
<p class="calibre13">The parentheses ensure that the expression for the second template argument is evaluated first and doesn’t get mixed up with the angled brackets.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Templates for Function Objects</h3>
<p class="calibre13">A class that defines function objects is typically defined by a template, for the obvious reason that it allows you to define function objects that will work with a variety of argument types. Here’s a template for the <code class="calibre23">Area</code> class that you saw earlier:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt; class Area
{
public:
  T operator()(const T length, const T width){ return length*width;  }
};</code></pre>
<p class="calibre13">This template defines function objects to calculate areas with dimensions of any numeric type. You can define the <code class="calibre23">printArea()</code> function that you saw earlier as a function template:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt; void printArea(const T length, const T width, Area&lt;T&gt; area)
{  cout &lt;&lt; "Area is " &lt;&lt;  area(length, width); }</code></pre>
<p class="calibre13">Now, you can call the <code class="calibre23">printArea()</code> function like this:</p>
<pre class="calibre28"><code class="calibre23">printArea(1.5, 2.5, Area&lt;double&gt;());
printArea(100, 50, Area&lt;int&gt;());</code></pre>
<p class="calibre13">You could avoid having to specify the third argument to instances of the <code class="calibre23">printArea()</code> function template by defining the template like this:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt; 
void printArea(const T length, const T width, Area&lt;T&gt; area = Area&lt;T&gt;())
{  cout &lt;&lt; "Area is " &lt;&lt;  area(length, width); }</code></pre>
<p class="calibre13">Now you can use <code class="calibre23">printArea()</code> like this:</p>
<pre class="calibre28"><code class="calibre23">printArea(1.5, 2.5);            // 3rd argument deduced as Area&lt;double&gt;()
printArea(100, 50);             // 3rd argument deduced as Area&lt;int&gt;()</code></pre>
<p class="calibre13">The compiler will deduce the correct type argument for the default specification for the third parameter as the type of the first two arguments, which must both be of the same type, of course.</p>
<p class="calibre13">There is a disadvantage to using templates like this. Each specialization of the template will have its own function definition. For example, if you use the <code class="calibre23">Area</code> template with type arguments, <code class="calibre23">int, long</code>, and <code class="calibre23">long long</code>, you will have generated three definitions for the function call operator overload, each occupying memory. You probably could manage with just one for type <code class="calibre23">long long</code>. It is easy to cause unnecessary code bloat with templates, so keep this in mind.</p>
<p class="calibre13">Function objects are applied extensively with the Standard Template Library that you will learn about in Chapter 10, so you will see practical examples of their use in that context.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-301" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="373" id="calibre_link-835" class="calibre18"></span>PERFECT FORWARDING</h2>
<p class="calibre13">Perfect forwarding is an important concept because it can significantly improve performance with large objects that take substantial time to copy or create. Perfect forwarding is only relevant in the context of a class or function template. At first sight it sounds a little complicated but once you grasp the idea, it is quite simple. So what is perfect forwarding?</p>
<p class="calibre13">Suppose you have a function, <code class="calibre23">fun1()</code>, that is parameterized by a class type, <code class="calibre23">T</code>. This could be a function template or be within a class template. Suppose also that <code class="calibre23">fun1()</code> is defined with an rvalue reference parameter of type <code class="calibre23">T&amp;&amp;</code>. You know from Chapter 6 that <code class="calibre23">fun1()</code> can be called with an argument that is an lvalue, an lvalue reference, or an rvalue. An lvalue or an lvalue reference argument results in the <code class="calibre23">fun1()</code> template instance having an lvalue reference parameter. Otherwise, it has an rvalue reference parameter.</p>
<p class="calibre13">Suppose further that <code class="calibre23">fun1()</code> calls another function, <code class="calibre23">fun2()</code>, that comes in two versions, one that has an lvalue reference parameter and the other with an rvalue reference parameter. <code class="calibre23">fun1()</code> passes the argument it receives as the argument to <code class="calibre23">fun2()</code>. Ideally, when the argument received by <code class="calibre23">fun1()</code> is an rvalue, you want it to call the version of <code class="calibre23">fun2()</code> that has an rvalue reference parameter so there is no moving or copying of the argument. When <code class="calibre23">fun1()</code> is called with an lvalue or an lvalue reference argument, you want it to call the version of <code class="calibre23">fun2()</code> that has an lvalue reference parameter. You want <i class="calibre15">perfect forwarding</i> of the argument to <code class="calibre23">fun1(),</code> in other words, so the code always maximizes efficiency.</p>
<p class="calibre13">To achieve this you need a way to convert the reference parameter in <code class="calibre23">fun1()</code> from an lvalue to an rvalue when the argument is an rvalue so you can pass it to <code class="calibre23">fun2()</code> as an rvalue. Then there will be no copying or moving of the argument. When the argument to <code class="calibre23">fun1()</code> is an lvalue or an lvalue reference, you want it left as it is in the call to <code class="calibre23">fun2()</code>. This is precisely what the <code class="calibre23">std::forward()</code> function template does. The template is defined in the <code class="calibre23">utility</code> header. If you pass an rvalue reference argument to <code class="calibre23">std::forward()</code>, it returns it as an rvalue. If you pass an lvalue reference to it, it returns it as an lvalue reference. Let’s see it working.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Perfect Forwarding</h3>
<p class="calibre20">This example uses the <code class="calibre23">string</code> class that I’ll discuss in detail at the end of this chapter. In addition to showing perfect forwarding in action, the example demonstrates defining a template function as a member of a non-template class, and using a template with two type parameters. The example defines a <code class="calibre23">Person</code> class like this:</p>
<pre class="calibre28"><code class="calibre23">class Person
{
public:
  // Constructor template
  template&lt;typename T1, typename T2&gt;
  Person(T1&amp;&amp; first, T2&amp;&amp; second) :
    firstname {std::forward&lt;T1&gt;(first)}, secondname {std::forward&lt;T2&gt;(second)} {}
//    firstname {first}, secondname {second} {}
 
  // Access the name
  string getName() const
  {
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="374" id="calibre_link-836" class="calibre14"></span>return firstname.getName() + " " + secondname.getName();
  }
 
private:
  Name firstname;
  Name secondname;
};</code></pre>
<p class="calibre20">This is an ordinary class with the constructor defined by a template with two type parameters, <code class="calibre23">T1</code> and <code class="calibre23">T2</code>. This allows the constructor arguments to be of different types &mdash; type <code class="calibre23">string</code> and type <code class="calibre23">char*</code>, for example. The data members that store the first and second name of a person are of type <code class="calibre23">Name</code>; I’ll define the <code class="calibre23">Name</code> class in a moment. The <code class="calibre23">Person</code> constructor initializes the data members with the arguments after passing them to <code class="calibre23">std::forward()</code>. This ensures that an rvalue reference argument will remain as an rvalue reference when it is used to initialize a <code class="calibre23">Person</code> class data member. I’ll come back to the commented-out line later. The <code class="calibre23">getName()</code> member returns a string representation of a <code class="calibre23">Person</code> object.</p>
<p class="calibre20">Here’s the <code class="calibre23">Name</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">class Name
{
public:
  Name(const string&amp; aName) : name {aName}
  {  cout &lt;&lt; "Lvalue Name constructor." &lt;&lt; endl;  }
 
  Name(string&amp;&amp; aName) : name {std::move(aName)}
  {  cout &lt;&lt; "Rvalue Name constructor." &lt;&lt; endl;  }
 
  const string&amp; getName() const { return name; }
 
private:
  string name;
};</code></pre>
<p class="calibre20">This class encapsulates a single name as a <code class="calibre23">string</code> object. You can create a <code class="calibre23">string</code> object from a null-terminated string, or from another <code class="calibre23">string</code> object. The class has two constructors, one with an lvalue reference argument and the other with an rvalue reference argument. The latter will only be called when the argument is an rvalue reference. The reason for moving the rvalue reference argument is that the <code class="calibre23">string</code> class supports move semantics.</p>
<p class="calibre20">The program to use these classes is:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_11.cpp
// Perfect forwarding
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;string&gt;
using std::string;
using std::cout;
using std::endl;
 
// Put the Name class definition here...
 
// Put the Person class definition here...
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="375" id="calibre_link-837" class="calibre14"></span>int main()
{
  cout &lt;&lt; "Creating Person{string{\"Ivor\"} , string{\"Horton\"}} - rvalue arguments:"
       &lt;&lt; endl;
  Person me{string{"Ivor"} , string{"Horton"}};
  cout &lt;&lt; "Person is " &lt;&lt; me.getName() &lt;&lt; endl &lt;&lt; endl;
  string first{"Fred"};
  string second{"Fernackerpan"};
  cout &lt;&lt; "Creating Person{first , second} - lvalue arguments:" &lt;&lt; endl;
  Person other{first,second};
  cout &lt;&lt; "Person is " &lt;&lt; other.getName() &lt;&lt; endl &lt;&lt; endl;
  cout &lt;&lt; "Creating Person{first , string{\"Bloggs\"}} - lvalue, rvalue arguments:" 
       &lt;&lt; endl;
  Person brother{first , string{"Bloggs"}};
  cout &lt;&lt; "Person is " &lt;&lt; brother.getName() &lt;&lt; endl &lt;&lt; endl;
  cout &lt;&lt; "Creating Person{\"Richard\" , \"Horton\"} - rvalue const char* arguments:"
       &lt;&lt; endl; 
  Person another{"Richard", "Horton"};
  cout &lt;&lt; "Person is " &lt;&lt; another.getName() &lt;&lt; endl &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">Creating Person{string{"Ivor"} , string{"Horton"}} - rvalue arguments:
Rvalue Name constructor.
Rvalue Name constructor.
Person is Ivor Horton
Creating Person{first , second} - lvalue arguments:
Lvalue Name constructor.
Lvalue Name constructor.
Person is Fred Fernackerpan
Creating Person{first , string{"Bloggs"}} - lvalue, rvalue arguments:
Lvalue Name constructor.
Rvalue Name constructor.
Person is Fred Bloggs
Creating Person{"Richard" , "Horton"} - rvalue const char* arguments:
Rvalue Name constructor.
Rvalue Name constructor.
Person is Richard Horton</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You can see from the output that the <code class="calibre23">Name</code> constructor with an lvalue reference parameter is called when the corresponding argument to the <code class="calibre23">Person</code> constructor is an lvalue reference, and the <code class="calibre23">Name</code> constructor that has an rvalue reference parameter is called when the <code class="calibre23">Person</code> constructor argument is an rvalue. Clearly the <code class="calibre23">std::forward()</code> function is working as advertised.</p>
<p class="calibre20">Now uncomment the commented-out line in the <code class="calibre23">Person</code> class and comment out the line above it. Now the constructor arguments are not being forwarded, and the output is:</p>
<pre class="calibre28"><code class="calibre23">Creating Person{string{"Ivor"} , string{"Horton"}} - rvalue arguments:
Lvalue Name constructor.
Lvalue Name constructor.
Person is Ivor Horton
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="376" id="calibre_link-838" class="calibre14"></span>Creating Person{first , second} - lvalue arguments:
Lvalue Name constructor.
Lvalue Name constructor.
Person is Fred Fernackerpan
Creating Person{first , string{"Bloggs"}} - lvalue, rvalue arguments:
Lvalue Name constructor.
Lvalue Name constructor.
Person is Fred Bloggs
Creating Person{"Richard" , "Horton"} - rvalue const char* arguments:
Rvalue Name constructor.
Rvalue Name constructor.
Person is Richard Horton</code></pre>
<p class="calibre20">Everything looks consistent with forwarding not being applied, except for the last <code class="calibre23">Person</code> object. How come the <code class="calibre23">Name</code> constructors with an rvalue reference parameter were called without forwarding? The answer is that a literal is always an rvalue. If presenting a literal argument as an lvalue was permitted, you would be able to modify it, which is somewhat contrary to the notion of what a literal is.</p>
<p class="calibre20">There is a significant aspect to the use of a template for the constructor in the <code class="calibre23">Person</code> class. It allows you to create a <code class="calibre23">Person</code> object from two arguments where each argument can be a temporary <code class="calibre23">string</code> object, an lvalue <code class="calibre23">string</code> object, a temporary null-terminated string, or an lvalue null-terminated string. To provide for this without using a template you would need to write sixteen <code class="calibre23">Person</code> class constructors. With the template, the source code is much shorter and will result in a smaller executable module if you use less than the sixteen possible combinations of constructor arguments.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-302" class="calibre3"></a>DEFAULT ARGUMENTS FOR TEMPLATE PARAMETERS</h2>
<p class="calibre13">You can specify default arguments for parameters in function templates and class templates. You are likely to use them for class templates most. Parameter values for function templates can usually be deduced by the compiler, and therefore the parameters do not need default values to be specified. A default function template parameter value can be useful when you need flexibility in the return type because the return type cannot necessarily be deduced. Let’s look at that first.</p>
<section class="toclist">
<h3 class="calibre21">Default Function Template Arguments</h3>
<p class="calibre13">Look at this function template:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T, typename R=double&gt;
R sigma(T values[], size_t count)
{
  double mean {};
  for (size_t i {}; i &lt; count; i++)
    mean += values[i];
  mean /= count;
 
  double deviation {};
  for (size_t i {}; i &lt; count; i++)
    deviation += std::pow(values[i] - mean, 2);
 
  return static_cast&lt;R&gt;(std::sqrt(deviation/count));
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="377" id="calibre_link-839" class="calibre14"></span>This computes the <i class="calibre15">standard deviation</i> (denoted by the Greek letter sigma, <code class="calibre23">σ</code>) for an array of samples. It doesn’t matter if you are not familiar with this, but if you are not and you’d like to get an idea, the standard deviation is a measure of how much the values in a set vary from the average. A low value <code class="calibre23">σ</code> means that the values are typically close to the average. A high <code class="calibre23">σ</code> value indicates they are widely dispersed. The type for the return value is specified by the second template parameter, <code class="calibre23">R</code>, which defaults to type <code class="calibre23">double</code>. You might use the template like this:</p>
<pre class="calibre28"><code class="calibre23">  int heights[] {67, 72, 69, 74, 75, 66, 67, 78};                // In inches
  std::cout &lt;&lt; sigma(heights, _countof(heights)) &lt;&lt; std::endl;   // Outputs 4.12311</code></pre>
<p class="calibre13">No template parameter arguments are supplied, so the return value is the default type, <code class="calibre23">double</code>. You could also use the template like this:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; sigma&lt;int, int&gt;(heights, _countof(heights))       // Outputs 4
            &lt;&lt; std::endl;</code></pre>
<p class="calibre13">Both parameters values are supplied. The first parameter would be deduced to be <code class="calibre23">int</code> in any event, but you cannot omit it when you want to specify an argument for the second parameter.</p>
<p class="calibre13">Here’s another example of using it:</p>
<pre class="calibre28"><code class="calibre23">int heights[] {52, 72, 53, 74, 75, 46, 67, 79};                  // In inches
std::cout &lt;&lt; sigma&lt;int, float&gt;(heights, _countof(heights)) &lt;&lt; std::endl;</code></pre>
<p class="calibre13">This outputs 11.7447 because these values are more widely dispersed. The function returns the result as type <code class="calibre23">float</code>.</p>
<p class="calibre13">It’s conceivable that you might want the return type to be the same as the array element type by default, but still offer the possibility of choosing a return type. Defining the template like this does it:</p>
<pre class="calibre28"><code class="calibre23">template&lt;class T, class R=T&gt;
R sigma(T values[], size_t count)
{
  // Code as before...
 
  return static_cast&lt;R&gt;(std::sqrt(deviation/count));
}</code></pre>
<p class="calibre13">The default for <code class="calibre23">R</code> is now <code class="calibre23">T</code>, so if you don’t specify it, the default return type will be the element type.</p>
<p class="calibre13">Template parameters that have default values must come after parameters without defaults in a template definition. When you supply an argument for a parameter, all the preceding parameters in the list must have arguments specified.</p>
<p class="calibre13">Of course, a template is not really the best way to go for the <code class="calibre23">sigma()</code> function. Every unique combination of template arguments will cause the compiler to generate another function overload that occupies memory so a program may end up to be a lot larger than it needs to be.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">sqrt()</code> <i class="calibre15">and</i> <code class="calibre23">pow()</code> <i class="calibre15">functions that are used in the</i> <code class="calibre23">sigma()</code> <i class="calibre15">template calculate square roots and powers respectively. They are declared along with many other functions in the</i> <code class="calibre23">cmath</code> <i class="calibre15">header</i>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="378" id="calibre_link-840" class="calibre24"></span>Default Class Template Arguments</h3>
<p class="calibre13">Any or all of the parameters for a class template can have default arguments. The same rules apply for defining default parameter values &mdash; all the parameters with defaults specified must be together at the end of the parameter list. If you supply a value for any parameter when you create an instance of a template then you must specify values for any preceding parameters in the list. Here’s how you could specify defaults for the <code class="calibre23">CSamples</code> template you saw earlier:</p>
<pre class="calibre28"><code class="calibre23">template &lt;class T=double, size_t Size=100&gt; class CSamples
{
  public:
    // Constructors
    CSamples(const T values[], int count);
    CSamples(const T&amp; value);
    CSamples(T&amp;&amp; value);
    CSamples() = default;
        
    bool add(const T&amp; value);               // Insert a value
    bool add(T&amp;&amp; value);                    // Insert a value with move semantics
    T max() const;                          // Calculate maximum
        
  private:
    T m_Values[Size];                       // Array to store samples
    int m_Next {};                          // Index of free location in m_Values
}; </code></pre>
<p class="calibre13">Here’s an example of how you can use this template:</p>
<pre class="calibre28"><code class="calibre23">  double values[] { 2.5, 3.6, 4.7, -15.0, 6.8, 7.2, -8.1 };
  CSamples&lt;&gt; data{ values, _countof(values) };</code></pre>
<p class="calibre13">Neither template parameter has a value specified for it here so the defaults of <code class="calibre23">double</code> and <code class="calibre23">100</code> apply. Note that the angled brackets are essential, even though there are no parameter values. If you want to specify the <code class="calibre23">Size</code> parameter value, you must also specify a value for the first parameter &mdash; like this:</p>
<pre class="calibre28"><code class="calibre23">  CSamples&lt;double, _countof(values)&gt; data{ values, _countof(values) };</code></pre>
<p class="calibre13">If you omit the first parameter value here, the statement won’t compile. Let’s see it in action.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Default Parameter Values in a Class Template</h3>
<p class="calibre20">This example demonstrates the <code class="calibre23">CSamples&lt;&gt;</code> template with default parameter values. It uses the <code class="calibre23">CBox</code> class from <code class="calibre23">Ex8_10</code>:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_12.cpp
// Default values for class template parameters
#include &lt;iostream&gt;
#include &lt;utility&gt;                          // For operator overload templates
#include &lt;algorithm&gt;                        // For max(), swap() used in CBox
using std::cout;
using std::endl;
using namespace std::rel_ops;
 
// Insert code for CBox class and its member from Ex8_10 here...
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="379" id="calibre_link-841" class="calibre14"></span>// CSamples class template definition
template &lt;typename T=double, size_t Size=100&gt; class CSamples
{
public:
  // Constructors
  CSamples(const T values[], int count);
  CSamples(const T&amp; value);
  CSamples(T&amp;&amp; value);
  CSamples() = default;
 
  bool add(const T&amp; value);               // Insert a value
  bool add(T&amp;&amp; value);                    // Insert a value with move semantics
  T max() const;                          // Calculate maximum
 
private:
  T m_Values[Size];                       // Array to store samples
  int m_Next {};                          // Index of free location in m_Values
};
 
// Constructor template definition to accept an array of samples
template&lt;typename T, size_t Size&gt; 
CSamples&lt;T, Size&gt;::CSamples(const T values[], int count)
{
  m_Next = count &lt; Size ? count : Size;     // Don't exceed the array
  for (int i {}; i &lt; m_Next; i++)           // Store count of samples
    m_Values[i] = values[i];
}
 
// Constructor to accept a single sample
template&lt;typename T, size_t Size&gt; 
CSamples&lt;T, Size&gt;::CSamples(const T&amp; value)
{
  m_Values[0] = value;                      // Store the sample
  m_Next = 1;                               // Next is free
}
 
// Constructor to accept a temporary sample
template&lt;typename T, size_t Size&gt; 
CSamples&lt;T, Size&gt;::CSamples(T&amp;&amp; value)
{
  cout &lt;&lt; "Move constructor." &lt;&lt; endl;
  m_Values[0] = std::move(value);           // Store the sample
  m_Next = 1;                               // Next is free
}
 
// Function to add a sample
template&lt;typename T, size_t Size&gt; 
bool CSamples&lt;T, Size&gt;::add(const T&amp; value)
{
  cout &lt;&lt; "Add." &lt;&lt; endl;
  bool OK {m_Next &lt; Size};                  // Indicates there is a free place
  if (OK)
    m_Values[m_Next++] = value;             // OK true, so store the value
  return OK;
}
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="380" id="calibre_link-842" class="calibre14"></span>template&lt;typename T, size_t Size&gt; 
bool CSamples&lt;T, Size&gt;::add(T&amp;&amp; value)
{
  cout &lt;&lt; "Add move." &lt;&lt; endl;
  bool OK {m_Next &lt; Size};                  // Indicates there is a free place
  if (OK)
    m_Values[m_Next++] = std::move(value);  // OK true, so store the value
  return OK;
}
 
// Function to obtain maximum sample
template&lt;typename T, size_t Size&gt; 
T CSamples&lt;T, Size&gt;::max() const
{
  T theMax {m_Values[0]};                   // Set first sample as maximum
  for (int i {1}; i &lt; m_Next; i++)          // Check all the samples
  if (theMax &lt; m_Values[i])
    theMax = m_Values[i];                   // Store any larger sample
  return theMax;
}
 
int main()
{
  CBox boxes[]  {                           // Create an array of boxes
      CBox { 8.0, 5.0, 2.0 },               // Initialize the boxes...
      CBox { 5.0, 4.0, 6.0 },
      CBox { 4.0, 3.0, 3.0 }
  };
 
  // Create the CSamples object to hold CBox objects
  CSamples&lt;CBox&gt; myBoxes { boxes, _countof(boxes) };
 
  CBox maxBox { myBoxes.max() };             // Get the biggest box
  cout &lt;&lt; "The biggest box has a volume of "// and output its volume
    &lt;&lt; maxBox.volume() &lt;&lt; endl;
 
  double values[] { 2.5, 3.6, 4.7, -15.0, 6.8, 7.2, -8.1 };
  CSamples&lt;&gt; data{ values, _countof(values) };
  cout &lt;&lt; "Maximum double value = " &lt;&lt; data.max() &lt;&lt; endl;
 
  // Uncomment next line for an error
  // CSamples &lt;, _countof(values)&gt; baddata{ values, _countof(values) }; 
 
  int counts[] { 21, 32, 444, 15, 6, 7, 8 };
  CSamples&lt;int, _countof(counts)&gt; dataset{ counts, _countof(counts) };
  cout &lt;&lt; "Maximum int value = " &lt;&lt; dataset.max() &lt;&lt; endl;
 
  return 0;
}</code></pre>
<p class="calibre20">This will produce the following output:</p>
<pre class="calibre28"><code class="calibre23">The biggest box has a volume of 120
Maximum double value = 7.2
Maximum int value = 444</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="381" id="calibre_link-843" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">I defined the function members of the template outside its definition to show how it’s done with multiple parameters with defaults specified. Note how each member function definition that appears outside the template definition has both class template parameters included, but without the default values.</p>
<p class="calibre20">The <code class="calibre23">main()</code> function first instantiates the template for an array of <code class="calibre23">CBox</code> objects, where the first template parameter has a value specified. The second parameter, <code class="calibre23">Size</code>, will have the default value, 100.</p>
<p class="calibre20">The <code class="calibre23">CSamples&lt;&gt;</code> template is used next with an array of <code class="calibre23">double</code> values. Neither template parameter is specified so the default values apply. You must supply the angled brackets when no parameter values are specified, unlike function templates. If you wanted to specify a value for the <code class="calibre23">Size</code> parameter, you must also specify a value for <code class="calibre23">T</code>. Uncomment the next line to show the compiler error message that you get if you don’t.</p>
<p class="calibre20">The last use of <code class="calibre23">CSamples&lt;&gt;</code> is with an array of <code class="calibre23">int</code> values. Both template parameters have values specified. You could omit the <code class="calibre23">Size</code> value to use the default of 100, which would look like this:</p>
<pre class="calibre28"><code class="calibre23">  CSamples&lt;int&gt; dataset{ counts, _countof(counts) };  // Default 2nd parameter value</code></pre>
<p class="calibre20">Default template argument values are used frequently in the container class templates that you’ll learn about in Chapter 10.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-303" class="calibre3"></a>ALIASES FOR CLASS TEMPLATES</h2>
<p class="calibre13">You can define an alias for a class template with values for some or all of its parameters specified. This can make your code easier to read. You use the <code class="calibre23">using</code> keyword for this. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">  using BoxSamples = CSamples&lt;CBox&gt;;</code></pre>
<p class="calibre13">With this alias defined in <code class="calibre23">main()</code> in <code class="calibre23">Ex8_12,</code> you could define <code class="calibre23">myBoxes</code> like this:</p>
<pre class="calibre28"><code class="calibre23">  BoxSamples myBoxes { boxes, _countof(boxes) };</code></pre>
<p class="calibre13"><code class="calibre23">BoxSamples</code> can now be used whenever you want to specify the <code class="calibre23">CSamples&lt;CBox&gt;</code> type. This is especially useful if you have several uses of the template in this way because the code will look a lot less cluttered. When all the template parameters have default values, you could use an alias to get rid of the empty angled brackets when defining variables of the type:</p>
<pre class="calibre28"><code class="calibre23">using Samples = CSamples&lt;&gt;;                   // Default parameter values
Samples data { values, _countof(values) };</code></pre>
<p class="calibre13">Thus <code class="calibre23">data</code> is a variable with a type specified by an instance of the <code class="calibre23">CSamples</code> template with <code class="calibre23">double</code> as the first parameter value and 100 as the value for the <code class="calibre23">Size</code> parameter so it is of type <code class="calibre23">CSamples&lt;double,100&gt;</code>.</p>
<p class="calibre13">Type aliases can be a great help in simplifying your code when you are working with the container class templates from the Standard Template Library that’s in Chapter 10.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-304" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="382" id="calibre_link-844" class="calibre18"></span>TEMPLATE SPECIALIZATION</h2>
<p class="calibre13">Some parameter values for a function or class template may not work. Using the <code class="calibre23">CBox</code> type as an argument for the <code class="calibre23">sigma()</code> function template won’t work, for example. Also, pointer types usually won’t work for a template unless there is special provisioning for them. You can deal with such situations by defining a <i class="calibre15">template specialization</i>, which is an additional definition of a template for a specific set of parameter values. I’ll illustrate how you define a template specialization with a very simple example. Suppose you have defined the following function template that computes an average:</p>
<pre class="calibre28"><code class="calibre23">template&lt;typename T&gt;
T average (T values[], size_t count)
{
  T mean {};
  for (size_t i {}; i &lt; count; i++)
    mean += values[i];
 
  return mean/count;
}</code></pre>
<p class="calibre13">I used <code class="calibre23">typename</code> instead of <code class="calibre23">class</code> to specify the parameter here to remind you that you can. Suppose you now want to use this with an array of <code class="calibre23">CBox</code> objects and you have defined an “average” <code class="calibre23">CBox</code> object to be one that has dimensions that are the average dimensions of a set of <code class="calibre23">CBox</code> objects. Given that the <code class="calibre23">CBox</code> class has members, <code class="calibre23">getWidth(), getHeight()</code>, and <code class="calibre23">getLength()</code> that return the dimensions of a box, you can define a specialization of the template for boxes like this:</p>
<pre class="calibre28"><code class="calibre23">template&lt;&gt;
CBox average(CBox boxes[], size_t count)
{
  double height {}, width {}, length {};
  for(size_t i {}; i&lt;count; ++i)
  {
    height += boxes[i].getHeight();
    width += boxes[i].getWidth();
    length += boxes[i].getLength();
  }
  return CBox {length/count, width/count, height/count};
}</code></pre>
<p class="calibre13">The first line with the empty angled brackets indicates to the compiler that this is a specialization of an existing template. The template argument will be deduced by the compiler from the type of the first argument. You could make the specialization argument explicit by defining it like this:</p>
<pre class="calibre28"><code class="calibre23">template&lt;&gt;
CBox average&lt;CBox&gt;(CBox boxes[], size_t count)
{
  // Code as above...
}</code></pre>
<p class="calibre13">This form will be necessary when the template argument or arguments cannot be deduced by the compiler.</p>
<p class="calibre13">You could use the template specialization like this:</p>
<pre class="calibre28"><code class="calibre23">  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="383" id="calibre_link-845" class="calibre14"></span>CBox boxes[] {CBox {8.0, 5.0, 2.0},CBox {5.0, 4.0, 6.0},CBox {4.0, 3.0, 3.0}};
  average(boxes, _countof(boxes)).showBox();</code></pre>
<p class="calibre13">With the <code class="calibre23">boxes</code> array as the first argument to <code class="calibre23">average()</code>, the compiler will generate the specialized version of the template and call it here. The <code class="calibre23">CBox</code> object that is returned is used to call the <code class="calibre23">showBox()</code> member to output the dimensions.</p>
<p class="calibre13">Of course, you could define a function overload instead of a template specialization. So what difference would that make? If you use this function in a program, there is no difference between defining an overload and defining a specialization of the template. If you don’t use it, there is a difference. A template will not be instantiated if you don’t use it, whereas a function overload will always be compiled and included in the executable module. However, remember that templates are primarily intended for creating library facilities that will be reused in many applications, and not in one-off applications.</p>
<p class="calibre13">A specialization for a class template is defined in a similar manner. For example, you might specialize the <code class="calibre23">CSamples</code> class template with a single parameter to work with <code class="calibre23">CBox</code> objects like this:</p>
<pre class="calibre28"><code class="calibre23">template &lt;&gt;
class CSamples&lt;CBox&gt;
{
  public:
    // Constructor definition to accept an array of sample boxes
    CSamples(const CBox boxes[], int count)
    {
      m_Next = count &lt; maxSamples ? count : maxSamples;   // Don't exceed the array
      for(int i {}; i &lt; m_Next; i++)                      // Store count samples
        m_Boxes[i] = boxes[i];
    }
        
    // Constructor to accept a single sample
    CSamples(const CBox&amp; box)
    {
      m_Boxes[0] = box;                       // Store the sample
      m_Next = 1;                             // Next is free
    }
        
    CSamples() = default;                     // Default constructor 
        
    // Function to add a box
    bool add(const CBox&amp; box))
    {
      bool OK {m_Next &lt; maxSamples};          // Indicates there is a free place
      if(OK)
        m_Boxes[m_Next++] = box;              // OK true, so store the box
      return OK;
    }
        
    // Function to obtain maximum box
    CBox max() const
    {
      // Set first box as maximum
      CBox maxBox {m_Boxes[0]};
        
      for(int i {1}; i &lt; m_Next; i++)         // Check all the boxes
        <span {http://www.idpf.org/2007/ops}type="pagebreak" title="384" id="calibre_link-846" class="calibre14"></span>if(m_Boxes[i].volume() &gt; maxBox.volume())
          maxBox = m_Boxes[i];                // Store any larger box
      return maxBox;
    }
        
  private:
    static const size_t maxSamples {100};     // Maximum number of samples
    CBox m_Boxes[maxSamples];                 // Array to store boxes
    int m_Next {};                            // Index of next free location
};</code></pre>
<p class="calibre13">The <code class="calibre23">template</code> keyword followed by the empty angled brackets indicates to the compiler that you are defining a template specialization. The specialized type appears between angled brackets following the template name, <code class="calibre23">CSamples</code>. When an instance of the <code class="calibre23">CSamples</code> template needs to be created with <code class="calibre23">CBox</code> as the parameter value, the compiler will use this specialization to create the class.</p>
<p class="calibre13">The preceding specialization is called a <i class="calibre15">complete specialization</i> because it only applies to a specific parameter value. A specialization of a template with multiple parameters with all parameters specified is also a complete specialization. You can define a template specialization that applies to a range of argument types, for any pointer type for example. This is called a <i class="calibre15">partial specialization</i>. The syntax is slightly different in this case. You could define a specialization of the <code class="calibre23">CSamples</code> template for pointers as something like this:</p>
<pre class="calibre28"><code class="calibre23">template &lt;typename T&gt;
class CSamples&lt;T*&gt;
{
  public:
    // Constructor definition to accept an array of pointers to samples 
    CSamples(T* pSamples[], int count)
    {
      m_Next = count &lt; maxSamples) ? count : maxSamples;  // Don't exceed the array
      for(int i {}; i &lt; m_Next; i++)                      // Store count samples
        m_pSamples[i] = pSamples[i];
    }
        
      
    // Function to obtain address of maximum sample
    T* max() const
    {
      // Set first sample as maximum
      T* pMax {m_pSamples[0]};
        
      for(int i {1}; i &lt; m_Next; i++)         // Check all the samples
        if(*m_pSamples[i] &gt; *pMax)
          pMax = m_pSamples[i];               // Store any larger sample
      return pMax;
    }
   
    // Plus other members adjusted for pointers...
        
  private:
    static const size_t maxSamples {100};     // Maximum number of samples
    T* m_pSamples[maxSamples];                // Array to store pointers
    int m_Next {};                            // Index of next free location
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="385" id="calibre_link-847" class="calibre14"></span>The first line specifies that the template parameter is <code class="calibre23">T</code> and the type <code class="calibre23">T*</code> between angle brackets following the template type name; <code class="calibre23">CSamples</code>, is the form for which this template specialization applies, i.e., any pointer type. Thus this specialization will be used if <code class="calibre23">T</code> is <code class="calibre23">double*</code> or <code class="calibre23">CBox*</code>. Here’s a fragment that will use this specialization:</p>
<pre class="calibre28"><code class="calibre23">    CBox boxes[] { CBox {8.0, 5.0, 2.0},
                   CBox {5.0, 4.0, 6.0},
                   CBox {4.0, 3.0, 3.0}
                 };
    CBox* pBoxes[] {boxes, boxes + 1, boxes + 2};
    CSamples&lt;CBox*&gt; pBoxSamples { pBoxes, _countof(pBoxes) };
    pBoxSamples.max()-&gt;showBox();</code></pre>
<p class="calibre13">The first statement creates an array of <code class="calibre23">CBox</code> objects, and the second statement creates an array of pointers to these objects. <code class="calibre23">pBoxSamples</code> is an object of type <code class="calibre23">CSamples&lt;CBox*&gt;</code> that is constructed using the array of pointers. The last line will output the dimensions of the largest <code class="calibre23">CBox</code> object pointed to.</p>
<p class="calibre13">When a template has more than one parameter, you can define a partial specialization that allows one or more of the parameters to remain variable. Here’s how a partial specialization of the <code class="calibre23">CSamples&lt;T, Size&gt;</code> template would look:</p>
<pre class="calibre28"><code class="calibre23">template&lt;size_t Size&gt;
class CSamples&lt;CBox, Size&gt;
{
  // Code for a CBox version...
};</code></pre>
<p class="calibre13">The type following the template keyword is still a variable and the types between the angled brackets following <code class="calibre23">CSamples</code> indicates that the first type parameter value for this specialization is fixed as <code class="calibre23">CBox</code> and the second is parameter <code class="calibre23">Size</code> and thus still variable.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-305" class="calibre3"></a>USING CLASSES</h2>
<p class="calibre13">I’ve touched on most of the basic aspects of defining a class, so maybe it’s time to look at how you might use a class to solve a problem. The problem has to be simple in order to keep this book down to a reasonable number of pages, so I’ll consider problems in which we can use an extended version of the <code class="calibre23">CBox</code> class.</p>
<section class="toclist">
<h3 class="calibre21">The Idea of a Class Interface</h3>
<p class="calibre13">The implementation of an extended <code class="calibre23">CBox</code> class should incorporate the notion of a <i class="calibre15">class interface</i>. You are going to provide a tool kit for anyone who wants to work with <code class="calibre23">CBox</code> objects, so you need to assemble a set of functions that represents the interface to the world of boxes. The interface will represent the only way to deal with <code class="calibre23">CBox</code> objects so it should provide everything one is likely to want do with a <code class="calibre23">CBox</code> object, and be implemented as far as possible in a way that protects against misuse or accidental errors.</p>
<p class="calibre13">The first question that you need to consider in designing a class is the nature of the problem you intend to solve, and, from that, determine the kind of functionality you need in the class interface.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="386" id="calibre_link-848" class="calibre24"></span>Defining the Problem</h3>
<p class="calibre13">The principal function of a box is to contain objects of one kind or another, so, in a word, the problem is <i class="calibre15">packaging</i>. We’ll attempt to provide a class that eases packaging problems in general and then see how it might be used. We will assume that we’ll always be packing <code class="calibre23">CBox</code> objects into other <code class="calibre23">CBox</code> objects; if you want to pack candy in a box, you can represent the pieces of candy as idealized <code class="calibre23">CBox</code> objects. The basic operations that you might want to provide in the <code class="calibre23">CBox</code> class include:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Calculate the volume of a <code class="calibre23">CBox</code>. This is a fundamental characteristic of a <code class="calibre23">CBox</code> object, and you have an implementation of this already.</li>
<li class="calibre6">Compare the volumes of two <code class="calibre23">CBox</code> objects. You probably should support a complete set of comparison operators for <code class="calibre23">CBox</code> objects.</li>
<li class="calibre6">Compare the volume of a <code class="calibre23">CBox</code> object with a value, and vice versa.</li>
<li class="calibre6">Add two <code class="calibre23">CBox</code> objects to produce a new object that will contain both original objects. The result will be at least the sum of the volumes but may be larger.</li>
<li class="calibre6">Multiply a <code class="calibre23">CBox</code> object by an integer and vice versa to produce a new <code class="calibre23">CBox</code> object that will contain the specified number of original objects. This is effectively designing a carton.</li>
<li class="calibre6">Determine how many of a given <code class="calibre23">CBox</code> object can be packed in another <code class="calibre23">CBox</code> object. This is effectively division, so you could implement this by overloading the <code class="calibre23">/</code> operator.</li>
<li class="calibre6">Determine the volume of space remaining in a <code class="calibre23">CBox</code> object after packing it with the maximum number of <code class="calibre23">CBox</code> objects of a given size.</li>
</ul>
<p class="calibre13">I had better stop right there! There are undoubtedly other functions that would be useful but, in the interest of saving trees, we’ll consider the set to be complete, apart from ancillaries such as accessing box dimensions.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Implementing the CBox Class</h3>
<p class="calibre13">You need to consider the degree of error protection that you want to build into the <code class="calibre23">CBox</code> class. The basic class that you defined to illustrate various aspects of classes is a starting point, but you should also consider some points a little more deeply. The constructor is weak in that it doesn’t ensure that the dimensions are valid, so, perhaps the first thing is to ensure that you always have valid objects. You could redefine the basic class as follows to do this:</p>
<pre class="calibre28"><code class="calibre23">class CBox
{
public:
  CBox(const CBox&amp; obj) = default;               // Copy constructor
  CBox&amp; operator=(const CBox&amp; obj) = default;    // Assignment operator
  ~CBox() = default;                             // Destructor
 
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0): 
     m_Length {std::max(lv, wv)}, m_Width {std::min(lv, wv)}, m_Height {hv}
  {
    // height is &lt;= width 
    // We need to ensure the height is &lt;= width is &lt;= length
  <b class="calibre12">if (m_Height &gt; m_Length)</b>
  <b class="calibre12"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="387" id="calibre_link-849" class="calibre14"></span>{ // height greater than length, so swap them</b>
    <b class="calibre12">std::swap(m_Height, m_Length);</b>
    <b class="calibre12">std::swap(m_Width, m_Height);</b>
  <b class="calibre12">} else if (m_Height &gt; m_Width)</b>
  <b class="calibre12">{ // height less than or equal to length but greater than width so swap</b>
    <b class="calibre12">std::swap(m_Height, m_Width);</b>
  <b class="calibre12">}</b>
  }
        
  double volume() const                          // Calculate the volume of a box
  {  return m_Length*m_Width*m_Height;  }
 
  double getLength() const { return m_Length; }  // Return the length of a box
  double getWidth() const { return m_Width; }    // Return the width of a box
  double getHeight() const { return m_Height; }  // Return the height of a box
        
private:
  double m_Length;                               // Length of a box in inches
  double m_Width;                                // Width of a box in inches
  double m_Height;                               // Height of a box in inches
};</code></pre>
<p class="calibre13">The constructor is now secure because any dimension that the user of the class tries to set to a value less than zero will cause an exception to be thrown.</p>
<p class="calibre13">The default copy constructor and assignment operator are satisfactory for the class, because you have no dynamic memory allocation for data members. The default destructor also works perfectly well. Next, you can consider what is required to support comparing <code class="calibre23">CBox</code> objects.</p>
<section class="toclist">
<h4 class="calibre22">Comparing CBox Objects</h4>
<p class="calibre13">You should support the operators <code class="calibre23">&gt;, &gt;=, ==, !=, &lt;</code>, and <code class="calibre23">&lt;=</code> so that they all work with both operands as <code class="calibre23">CBox</code> objects, as well as between a <code class="calibre23">CBox</code> object and a value of type <code class="calibre23">double</code>. This totals eighteen operator functions. You can get four of the ones with both operands as <code class="calibre23">CBox</code> objects for free, courtesy of the templates in the <code class="calibre23">utility</code> header, once you have defined the <code class="calibre23">&lt;</code> and <code class="calibre23">==</code> operator functions. You saw how to do that in <code class="calibre23">Ex8_06</code>:</p>
<pre class="calibre28"><code class="calibre23">bool operator&lt;(const CBox&amp; aBox) const            // Less-than operator
{  return this-&gt;volume() &lt; aBox.volume();  }
 
bool operator==(const CBox&amp; aBox) const           // Compare for equality
{  return this-&gt;volume() == aBox.volume();  }</code></pre>
<p class="calibre13">All the operator functions comparing a <code class="calibre23">CBox</code> left operand with a constant can be inside the class:</p>
<pre class="calibre28"><code class="calibre23">bool operator&gt;(const double  value) const         // CBox &gt; value
{  return volume() &gt; value;  }
 
bool operator&lt;(const double value) const          // CBox &lt; value
{  return volume() &lt; value;  }
 
bool operator&gt;=(const double value) const         // CBox &gt;= value
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="388" id="calibre_link-850" class="calibre14"></span>{  return volume() &gt;= value;  }
 
bool operator&lt;=(const double value) const         // CBox &lt;= value
{  return volume() &lt;= value;  }
 
bool operator==(const double value) const         // CBox ==  value
{  return volume() == value;  }
 
bool operator!=(const double value) const         // CBox != value
{  return volume() != value;  }</code></pre>
<p class="calibre13">These will be <code class="calibre23">inline</code> by default.</p>
<p class="calibre13">You must define comparisons with a left operand of type <code class="calibre23">double</code> as ordinary functions outside the class:</p>
<pre class="calibre28"><code class="calibre23">inline bool operator&gt;(const double value, const CBox&amp; aBox)  // value &gt; CBox
{  return value &gt; aBox.volume();  }
 
inline bool operator&lt;(const double value, const CBox&amp; aBox)  // value &lt; CBox
{  return value &lt; aBox.volume();  }
 
inline bool operator&gt;=(const double value, const CBox&amp; aBox) // value &gt;= CBox
{  return value &gt;= aBox.volume();  }
 
inline bool operator&lt;=(const double value, const CBox&amp; aBox) // value &lt;= CBox
{  return value &lt;= aBox.volume();  }
 
inline bool operator==(const double value, const CBox&amp; aBox) // value == CBox
{  return value == aBox.volume();  }
 
inline bool operator!=(const double value, const CBox&amp; aBox) // value != CBox
{  return value != aBox.volume();  }</code></pre>
<p class="calibre13">You now have a complete set of comparison operators. These will work with expressions as long as the expressions result in objects of the required type.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Combining CBox Objects</h4>
<p class="calibre13">Now, you can implement overloads for the operators <code class="calibre23">+, *, /</code>, and <code class="calibre23">%</code> in the <code class="calibre23">CBox</code> class. I will take them in order. The add operation that you already have from <code class="calibre23">Ex8_06.cpp</code> has this prototype:</p>
<pre class="calibre28"><code class="calibre23">CBox operator+(const CBox&amp; aBox) const;    // Function adding two CBox objects</code></pre>
<p class="calibre13">Although the original implementation isn’t ideal, let’s use it anyway to avoid overcomplicating the class. A better version might examine whether the operands had any faces with the same dimensions and, if so, join along those faces, but coding that could get a bit messy. Of course, in a real application a better add operation could be developed later and substituted for this version; any programs written using the original would still run without change. The separation of the interface to a class from its implementation is crucial to good C++ programming.</p>
<p class="calibre13">I conveniently forgot about the subtraction operator. This is a judicious oversight to avoid the complications inherent in implementing this when the result is a <code class="calibre23">CBox</code> object. If you’re really enthusiastic about it and think it’s a sensible idea, you can give it a try &mdash; but you need to decide what to do when the result has a negative volume. If you allow the concept, you need to resolve which box dimension or dimensions are to be negative, and how such a box is to be handled in subsequent operations. A simpler concept might be that subtracting <code class="calibre23">CBox</code> objects resulted in a volume.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="389" id="calibre_link-851" class="calibre14"></span>The multiply operation is easy. It represents the process of creating a box to contain <code class="calibre23">n</code> boxes, where <code class="calibre23">n</code> is the multiplier. A simple solution would be to take the width and length of the object to be packed and multiply the height by <code class="calibre23">n</code> to get the dimensions for the new <code class="calibre23">CBox</code> object. You can make it a little cleverer by checking whether or not the multiplier is even and in this case stack the boxes side by side by doubling the width and multiplying the height by half of <code class="calibre23">n</code>. This mechanism is illustrated in <a id="calibre_link-1367" href="#calibre_link-415" class="calibre3">Figure 8-5</a> with examples of the <code class="calibre23">CBox</code> objects resulting from multiplying <code class="calibre23">aBox</code> by 3 and 6.</p>
<figure class="calibre16">
<img class="center" src="images/000049.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-415" href="#calibre_link-1367" class="calibre3">FIGURE 8-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Of course, you don’t need to check which is the larger of the length and width for the new object because the constructor sorts it out. You can write the <code class="calibre23">operator*()</code> function as a member function with the left operand as a <code class="calibre23">CBox</code> object like this:</p>
<pre class="calibre28"><code class="calibre23">// CBox multiply operator this*n
CBox operator*(int n) const
{
  if(n % 2)
    return CBox {m_Length, m_Width, n*m_Height};           // n odd
  else
    return CBox {m_Length, 2.0*m_Width, (n/2)*m_Height};   // n even
}</code></pre>
<p class="calibre13">You use the <code class="calibre23">%</code> operator to determine whether <code class="calibre23">n</code> is even or odd. If <code class="calibre23">n</code> is odd, the value of <code class="calibre23">n%2</code> is <code class="calibre23">1</code> and the <code class="calibre23">if</code> condition is <code class="calibre23">true</code>. If it’s even, <code class="calibre23">n%2</code> is <code class="calibre23">0</code> and the condition is <code class="calibre23">false</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="390" id="calibre_link-852" class="calibre14"></span>You can use the function you have just written in the implementation of the version with the left operand as an integer. You can write this as a non-member function:</p>
<pre class="calibre28"><code class="calibre23">// CBox multiply operator n*aBox
CBox operator*(int n, const CBox&amp; aBox)
{
  return aBox*n;
}</code></pre>
<p class="calibre13">This reverses the order of the operands so as to use the previous version of the function directly. That completes the arithmetic operators for <code class="calibre23">CBox</code> objects that we defined. You can now look at the analytical operator functions, <code class="calibre23">operator/()</code> and <code class="calibre23">operator%()</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Analyzing CBox Objects</h4>
<p class="calibre13">The division operation will determine how many objects identical to the right operand can be contained in the <code class="calibre23">CBox</code> object specified by the left operand. To keep it simple I’ll assume that all the objects are packed the right way up &mdash; that is, with their height dimension vertical. I’ll also assume that they are all packed the same way round so that their lengths are aligned. Without these assumptions, it gets complicated.</p>
<p class="calibre13">The problem amounts to determining how many of the right-operand objects can be placed in a single layer inside the left-operand <code class="calibre23">CBox</code>, and then deciding how many layers you can get in it. You can code this as a member function like this:</p>
<pre class="calibre28"><code class="calibre23">int operator/(const CBox&amp; aBox) const
{
  // Number of boxes in horizontal plane this way
  int tc1 {static_cast&lt;int&gt;((m_Length / aBox.m_Length))*
               static_cast&lt;int&gt;((m_Width / aBox.m_Width))};
  // Number of boxes in horizontal plane that way
  int tc2 {static_cast&lt;int&gt;((m_Length / aBox.m_Width))*
               static_cast&lt;int&gt;((m_Width / aBox.m_Length))};
  //Return best fit
  return static_cast&lt;int&gt;((m_Height/aBox.m_Height)*(tc1 &gt; tc2 ? tc1 : tc2));
}</code></pre>
<p class="calibre13">You first determine how many of the right-operand objects can fit in a layer with their lengths aligned with the length dimension of the left-operand. This is stored in <code class="calibre23">tc1</code>. You then calculate how many fit in a layer with the lengths of the right-operand objects lying in the width direction of the left-operand <code class="calibre23">CBox</code>. Finally, you multiply the larger of <code class="calibre23">tc1</code> and <code class="calibre23">tc2</code> by the number of layers you can pack in, and return that value. This process is illustrated in <a id="calibre_link-1368" href="#calibre_link-416" class="calibre3">Figure 8-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000128.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-416" href="#calibre_link-1368" class="calibre3">FIGURE 8-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Consider two possibilities: fitting <code class="calibre23">bBox</code> into <code class="calibre23">aBox</code> with its length aligned with that of <code class="calibre23">aBox</code>, and then with the length of <code class="calibre23">bBox</code> aligned with the width of <code class="calibre23">aBox</code>. You can see from <a href="#calibre_link-416" class="calibre3">Figure 8-6</a> that the best packing results from rotating <code class="calibre23">bBox</code> so that its width divides into the length of <code class="calibre23">aBox</code>.</p>
<p class="calibre13">The <code class="calibre23">operator%()</code> function for obtaining the free volume in a packed box is easier, because you can use the operator you have just written to implement it. It can be an ordinary global function because you don’t need access to the <code class="calibre23">private</code> members of the class.</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="391" id="calibre_link-853" class="calibre14"></span>// Operator to return the free volume in a packed box
inline double operator%(const CBox&amp; aBox, const CBox&amp; bBox)
{
  return aBox.volume() - ((aBox/bBox)*bBox.volume());
}</code></pre>
<p class="calibre13">This computation falls out very easily using existing <code class="calibre23">CBox</code> class functions. The result is the volume of the big box, <code class="calibre23">aBox</code>, minus the total volume of the <code class="calibre23">bBox</code> boxes that can be stored in it. The number of <code class="calibre23">bBox</code> objects packed into <code class="calibre23">aBox</code> is given by the expression <code class="calibre23">aBox/bBox</code>, which uses the division operator function. You multiply this by the volume of a single <code class="calibre23">bBox</code> object to get the volume to be subtracted from the volume of the large box, <code class="calibre23">aBox</code>.</p>
<p class="calibre13">That completes the class interface. Clearly, there are many more functions that might be required for a production problem solver but, as an interesting working model demonstrating how you can produce a class for solving a particular kind of problem, it will suffice. Now you can try it out on a real problem.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="392" id="calibre_link-854" class="calibre24"></span>TRY IT OUT: A Multifile Project Using the CBox Class</h3>
<p class="calibre20">Before you can actually start writing the code to <i class="calibre15">use</i> the <code class="calibre23">CBox</code> class and its overloaded operators, you need to assemble the definition for the class into a coherent whole. You’re going to take a new approach in that you’re going to create multiple files for the project. You’re also going to start using the Visual C++ facilities for creating and maintaining classes. This will mean that you do rather less of the work, but it will also mean that the code will be slightly different in places.</p>
<p class="calibre20">Start by creating a new Win32 project for a console application called Ex8_13 and check the Empty project application option and uncheck the Security Development Lifecycle option.</p>
<p class="calibre20">The Class View tab shows the classes in a project but of course there are none here yet. Although there are no classes defined &mdash; or anything else, for that matter &mdash; Visual C++ has made provisions for including some. You can create a skeleton for the <code class="calibre23">CBox</code> class, and the files that relate to it. Right-click <code class="calibre23">Ex8_13</code> in Class View and select Add <img src="images/000122.png" alt="image" class="calibre25" /> Class from the pop-up menu. Select C++ from the class categories in the left pane of the dialog, select the C++ Class template in the right pane, and press Enter. (Ignore the Name and Location entry fields; they are disabled and not used.) You will then be able to enter the name of the class, <code class="calibre23">CBox</code>, as shown in <a id="calibre_link-1369" href="#calibre_link-417" class="calibre3">Figure 8-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000083.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-417" href="#calibre_link-1369" class="calibre3">FIGURE 8-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="393" id="calibre_link-855" class="calibre14"></span>The <code class="calibre23">Box.cpp</code> file will contain the <i class="calibre15">class implementation</i>, which consists of the definitions for function members that are not in the class definition. This is the executable code for the class. You can change the name of this file if you want, but <code class="calibre23">Box.cpp</code> looks like a good name. The class definition will be stored in a file called <code class="calibre23">Box.h</code>. This is the standard way of structuring a program. Code that consists of class definitions is stored in files with the extension <code class="calibre23">.h</code>, and code that defines functions is stored in files with the extension <code class="calibre23">.cpp</code>. Usually, each class definition goes in its own <code class="calibre23">.h</code> file, and each class implementation goes in its own <code class="calibre23">.cpp</code> file.</p>
<p class="calibre20">When you click the Finish button, two things happen:</p>
<ol class="calibre5">
<li class="calibre6">A <code class="calibre23">Box.h</code> file is created that contains a skeleton definition for the <code class="calibre23">CBox</code> class. This includes a no-arg constructor and a destructor.</li>
<li class="calibre6">A <code class="calibre23">Box.cpp</code> file is created that contains a skeleton implementation for the functions in the class with definitions for the constructor and the destructor &mdash; both bodies are empty of course.</li>
</ol>
<p class="calibre20">The editor pane now displays the code for the class definition that is in <code class="calibre23">Box.h</code>. The second tab in the editor pane displays the contents of <code class="calibre23">Box.cpp</code>. Let’s start developing the <code class="calibre23">CBox</code> class from what Visual C++ has provided automatically.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">Defining the CBox Class</i></h4>
<p class="calibre20">If you click the <img src="images/000122.png" alt="image" class="calibre25" />  to the left of <code class="calibre23">Ex8_13</code> in the <code class="calibre23">Class View</code>, the tree will be expanded and you will see that <code class="calibre23">CBox</code> is now defined for the project. All the classes in a project are displayed in this tree. You can view the source code for a class definition by double-clicking the class name in the tree.</p>
<p class="calibre20">The <code class="calibre23">CBox</code> class definition that was generated starts with a preprocessor directive:</p>
<pre class="calibre28"><code class="calibre23">#pragma once</code></pre>
<p class="calibre20">This prevents the file contents from being included in the source code more than once. Typically, a header file containing a given class definition may be included into several files in a project, including other header files, because each file that references the name of the class will need access to its definition. Thus the contents of a header file could potentially appear more than once in a source file. Having more than one definition of a class in a build is not allowed and will be flagged as an error. Putting the <code class="calibre23">#pragma once</code> directive at the start of every header file will ensure this cannot happen.</p>
<p class="calibre20"><code class="calibre23">#pragma once</code> may not be supported in other environments. If you are developing code that may need to be compiled in other environments, you can use the following directives in a header file to achieve the same effect:</p>
<pre class="calibre28"><code class="calibre23">// Box.h header file
<b class="calibre12">#ifndef BOX_H</b>
<b class="calibre12">#define BOX_H</b>
// Code that must not be included more than once
// such as the CBox class definition
<b class="calibre12">#endif</b></code></pre>
<p class="calibre20">The important lines are bolded and correspond to directives that are supported by any C++ compiler. The lines following the <code class="calibre23">#ifndef</code> directive down to the <code class="calibre23">#endif</code> directive will be included in a build as long as the symbol <code class="calibre23">BOX_H</code> is not defined. The line following <code class="calibre23">#ifndef</code> defines the symbol <code class="calibre23">BOX_H</code>, thus ensuring that the code in this header file will not be included a second time. Thus, this has the same effect as the <code class="calibre23">#pragma once</code> directive. Clearly, the <code class="calibre23">#pragma once</code> directive is simpler and less <span {http://www.idpf.org/2007/ops}type="pagebreak" title="394" id="calibre_link-856" class="calibre14"></span>cluttered, so it’s better to use that when you only expect to be using your code in Visual C++. You will sometimes see the <code class="calibre23">#ifndef</code>/<code class="calibre23">#endif</code> combination written as:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">#if !defined BOX_H</b>
<b class="calibre12">#define BOX_H</b>
// Code that must not be included more than once
// such as the CBox class definition
<b class="calibre12">#endif</b></code></pre>
<p class="calibre20">The <code class="calibre23">Box.cpp</code> file that Class Wizard generated contains the following code:</p>
<pre class="calibre28"><code class="calibre23">#include "Box.h"
        
CBox::CBox()
{
}
        
CBox::~CBox() 
{
}</code></pre>
<p class="calibre20">The first line is an <code class="calibre23">#include</code> directive that inserts the contents of <code class="calibre23">Box.h</code>&mdash; the class definition &mdash; into this file, <code class="calibre23">Box.cpp</code>. This is necessary because the code in <code class="calibre23">Box.cpp</code> refers to the <code class="calibre23">CBox</code> class, and the class definition needs to be available to assign meaning to the name <code class="calibre23">CBox</code>.</p>
<section class="toclist">
<h5 class="calibre27">Adding Data Members</h5>
<p class="calibre20">First, you can add the <code class="calibre23">private</code> data members <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code> as type <code class="calibre23">double</code>. Right-click <code class="calibre23">CBox</code> in Class View and select Add <img src="images/000122.png" alt="image" class="calibre25" />  Add Variable from the pop-up menu. You can then specify the name, type, and access for the first data member that you want to add to the class in the Add Member Variable Wizard dialog. The way you specify a new data member in this dialog is quite self-explanatory. The upper and lower limits for variables only applies when you are defining an MFC variable attached to a control. You can add a comment in the lower input field, if you wish. Clicking the Finish button adds the variable to the class definition along with any comment you supplied. You can repeat the process for the other two class data members, <code class="calibre23">m_Width</code> and <code class="calibre23">m_Height</code>. The class definition in <code class="calibre23">Box.h</code> will then look like this:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
        
class CBox
{
public:
  CBox(); 
  ~CBox(); 
<b class="calibre12">private:</b>
  <b class="calibre12">double m_Length;</b>
  <b class="calibre12">double m_Width;</b>
  <b class="calibre12">double m_Height;</b>
};</code></pre>
<p class="calibre20">Of course, you could enter the declarations for these members manually. You always have the choice of whether or not you use the automation provided by the IDE. You can also delete anything manually that was generated automatically, but remember that both the <code class="calibre23">.h</code> and <code class="calibre23">.cpp</code> files will need to be changed sometimes. It’s a good idea to save all the files whenever you make manual changes.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="395" id="calibre_link-857" class="calibre14"></span>If you look in <code class="calibre23">Box.cpp</code> you’ll see that the Wizard has also added an initialization list to the constructor definition for the data members you have added, with each variable initialized to 0 using the old syntax for the initial values. You could change this to the new syntax if you prefer. You’ll modify the constructor to do what you want next.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Defining the Constructor</h5>
<p class="calibre20">You need to change the declaration of the no-arg constructor in the class definition so that it has arguments with default values, so modify it to:</p>
<pre class="calibre28"><code class="calibre23"> explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0);</code></pre>
<p class="calibre20">Now, you’re ready to implement it. Open the <code class="calibre23">Box.cpp</code> file, if it isn’t open already, and modify the constructor definition to:</p>
<pre class="calibre28"><code class="calibre23">CBox::CBox(double lv, double wv, double hv) :
    m_Length {std::max(lv, wv)}, m_Width {std::min(lv, wv)}, m_Height {hv}
{
  if (lv &lt; 0.0 || wv &lt; 0.0 || hv &lt; 0.0)
    throw "Negative dimension specified for CBox object.";
  // Ensure the height is &lt;= width is &lt;= length
  if (m_Height &gt; m_Length)
  { // height greater than length, so swap them
    std::swap(m_Height, m_Length);
  }
  else if (m_Height &gt; m_Width)
  { // height less than or equal to length but greater than width so swap
    std::swap(m_Height, m_Width);
  }
}</code></pre>
<p class="calibre20">You’ll need an <code class="calibre23">#include</code> directive for the <code class="calibre23">algorithm</code> header in <code class="calibre23">Box.cpp</code>. Remember that the default values for the parameters to a member function only appear in the member declaration in the class definition, not in the definition of the function. If you put them in the function definition, the code will not compile. You’ve seen this code already, so I won’t discuss it again. It would be a good idea to save the file at this point by clicking the Save toolbar button. Get into the habit of saving the file you’re editing before you switch to something else. If you need to edit the constructor again, you can get to it easily by double-clicking its entry in the lower pane on the Class View tab.</p>
<p class="calibre20">Clicking a class name in Class View will cause the members of the class to be displayed in the lower pane. You can get to a member function’s definition in a <code class="calibre23">.cpp</code> file or to its declaration in an <code class="calibre23">.h</code> file directly by right-clicking its name in the Class View pane and selecting the appropriate item from the context menu that appears.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Adding Member Functions</h5>
<p class="calibre20">You need to add the member functions you saw earlier to the <code class="calibre23">CBox</code> class. You defined several member functions within the class definition, so that these functions were automatically inline. First, add the <code class="calibre23">#include</code> directive for the <code class="calibre23">utility</code> header to <code class="calibre23">Box.h</code> and then add the following <code class="calibre23">using</code> declarations:</p>
<pre class="calibre28"><code class="calibre23">Using std::rel_ops::operator&lt;=;
using std::rel_ops::operator&gt;;
using std::rel_ops::operator&gt;=;
using std::rel_ops::operator!=;</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="396" id="calibre_link-858" class="calibre14"></span>This makes the names of the templates for the comparison operators in the <code class="calibre23">std::rel_ops</code> namespace available. You should never add a “using namespace” to a header file so the only alternative to the declarations above would be to define the comparison operator functions yourself.</p>
<p class="calibre20">To add the <code class="calibre23">operator&lt;()</code> function as inline, right-click <code class="calibre23">CBox</code> on the Class View tab and select Add <img src="images/000122.png" alt="image" class="calibre25" />  Add Function from the context menu. You then can enter the data defining the function in the dialog that is displayed, as <a id="calibre_link-1370" href="#calibre_link-418" class="calibre3">Figure 8-8</a> shows.</p>
<figure class="calibre16">
<img class="center" src="images/000002.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-418" href="#calibre_link-1370" class="calibre3">FIGURE 8-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">The drop-down lists for the Return Type and Parameter Type contain a limited range of types. If the type you want is not in the list, you just type it in. You must click the Add button to add the parameter. It will then appear in the parameter list to the right in the dialog. If you don’t select the Inline option, the function definition will be in <code class="calibre23">Box.cpp</code>. Clicking Finish with Inline selected will create the skeleton for the function definition within the class definition. You must still edit the declaration in the <code class="calibre23">CBox</code> class definition to make the function <code class="calibre23">const</code> and to add the implementation to the function body. It should then look like this:</p>
<pre class="calibre28"><code class="calibre23">// Less-than operator for CBox objects
bool operator&lt;(const CBox&amp; aBox) const
{
  return volume() &lt; aBox.volume();
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="397" id="calibre_link-859" class="calibre14"></span>You can add and implement the <code class="calibre23">operator==()</code> and <code class="calibre23">volume()</code> members that you saw earlier to the class definition in the same way:</p>
<pre class="calibre28"><code class="calibre23">// Operator function for == comparing CBox objects
bool operator==(const CBox&amp; aBox) const 
{
  return volume() == aBox.volume();
}
 
// Calculate the box volume
double volume() const
{
 return m_Length*m_Width*m_Height;
}</code></pre>
<p class="calibre20">The templates in the <code class="calibre23">utility</code> header take care of the operator functions for <code class="calibre23">!=, &gt;, &lt;=</code>, and <code class="calibre23">&gt;=</code>. I’ll return to those that compare <code class="calibre23">CBox</code> objects with numerical values in a moment.</p>
<p class="calibre20">You can now add the <code class="calibre23">getHeight(), getWidth()</code>, and <code class="calibre23">getLength()</code> functions that you saw earlier as inline class members. I’ll leave it to you whether you use the Add <img src="images/000122.png" alt="image" class="calibre25" />  Add Function menu option or enter them directly.</p>
<p class="calibre20">Enter the operator functions for add, multiply, and divide operations using the Add Member Function Wizard because the practice will be useful. Right-click <code class="calibre23">CBox</code> in the Class View tab and select the Add <img src="images/000122.png" alt="image" class="calibre25" />  Add Function menu item from the context menu, as before. You can then enter the details of the <code class="calibre23">operator+()</code> function in the dialog that appears, as <a id="calibre_link-1371" href="#calibre_link-419" class="calibre3">Figure 8-9</a> shows.</p>
<figure class="calibre16">
<img class="center" src="images/000016.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-419" href="#calibre_link-1371" class="calibre3">FIGURE 8-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="398" id="calibre_link-860" class="calibre14"></span><a href="#calibre_link-419" class="calibre3">Figure 8-9</a> shows the dialog after the Add button has been clicked to add the parameter to the list. Inline is not selected in this instance. When you click Finish, the declaration for the function will be added to the class definition in the <code class="calibre23">Box.h</code> file and a skeleton definition for the function will be added to the <code class="calibre23">Box.cpp</code> file. The function needs to be declared as <code class="calibre23">const</code>, so you must add this keyword to the declaration of the <code class="calibre23">operator+()</code> function in the class definition, and to the function definition in <code class="calibre23">Box.cpp</code>. You must also add the code in the body of the function, like this:</p>
<pre class="calibre28"><code class="calibre23">CBox CBox::operator+(const CBox&amp; aBox) const
{
  // New object has larger length and width and sum of the heights
  return CBox {std::max(m_Length, aBox.m_Length),
               std::max(m_Width, aBox.m_Width),
               m_Height + aBox.m_Height};
}</code></pre>
<p class="calibre20">When you have repeated this process for the <code class="calibre23">operator*()</code> and <code class="calibre23">operator/()</code> functions that you saw earlier, the class definition in <code class="calibre23">Box.h</code> will look something like this:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
#include &lt;utility&gt;                     // For operator overload templates
using namespace std::rel_ops;
 
class CBox
{
public:
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0);
  ~CBox();
private:
  double m_Length;
  double m_Width;
  double m_Height;
public:
 
  // Less-than operator for CBox objects
  bool operator&lt;(const CBox&amp; aBox) const
  {
    return volume() &lt; aBox.volume();
  }
 
  // Operator function for == comparing CBox objects
  bool operator==(const CBox&amp; aBox) const
  {
    return volume() == aBox.volume();
  }
 
  // Calculate the box volume
  double volume()@@@remove MG OK IH@@@) const
  {
    return m_Length*m_Width*m_Height;
  }
 
  double getLength() const { return m_Length; }
  double getWidth() const { return m_Width; }
  double getHeight() const { return m_Height; }
  
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="399" id="calibre_link-861" class="calibre14"></span>CBox operator+(const CBox&amp; aBox) const;     // Addition operator for CBox objects
  CBox operator*(int n) const;                // Multiply operator for CBox objects
  int operator/(const CBox&amp; aBox) const;      // Division operator for CBox objects
};</code></pre>
<p class="calibre20">I rearranged it a little. You can edit or rearrange the code in any way that you want &mdash; as long as it’s still correct, of course.</p>
<p class="calibre20">If you look at Class View by clicking the tab, and then clicking the <code class="calibre23">CBox</code> class name, you’ll see that all the members of the class are shown in the lower pane.</p>
<p class="calibre20">This completes the <code class="calibre23">CBox</code> class with its members, but you still need to define the global functions that implement operators that compare the volume of a <code class="calibre23">CBox</code> object with a numerical value. These are short and can be inline for efficiency.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">Adding Global Functions</i></h4>
<p class="calibre20">You might think that you put definitions for inline functions in a <code class="calibre23">.cpp</code> file like other function definitions, but this is not the case. Inline functions may not end up being “real” functions in the compiled code because the compiler may insert the code from the body of an inline function at each position it is called. The definitions for inline functions need to be available when a file containing calls to them is compiled. If they’re not, you’ll get linker errors and your program will not run. The <code class="calibre23">.h</code> files that you include into a <code class="calibre23">.cpp</code> file must contain everything the compiler needs to compile the code in the <code class="calibre23">.cpp</code> file. If you call an inline function in a <code class="calibre23">.cpp</code> file, the inline function definition <i class="calibre15">must</i> appear in an <code class="calibre23">.h</code> file that is included into the <code class="calibre23">.cpp</code> file. This also applies to inline member functions that you define outside the class definition.</p>
<p class="calibre20">The global functions that support operations on <code class="calibre23">CBox</code> objects will all be inline. You could put the global functions that support operations on <code class="calibre23">CBox</code> objects after the <code class="calibre23">CBox</code> class definition in <code class="calibre23">Box.h</code>, but to get the experience, you will add another <code class="calibre23">.h</code> file to the project to house them. Click the Solution Explorer tab to display it (you currently will have the Class View tab displayed) and right-click the <code class="calibre23">Header Files</code> folder. Select Add <img src="images/000122.png" alt="image" class="calibre25" />  New Item from the context menu. Choose the category as Code and the template as Header File (<code class="calibre23">.h</code>) in the right pane of the dialog, and enter the filename as <code class="calibre23"><b class="calibre12">BoxOperators</b></code>.</p>
<p class="calibre20">You can now enter the following code in the editor pane:</p>
<pre class="calibre28"><code class="calibre23">// BoxOperators.h
// CBox object operations that don't need to access private members
#pragma once
#include "Box.h"
        
// Function for testing if a constant is &gt; a CBox object
inline bool operator&gt;(const double value, const CBox&amp; aBox)
{ return value &gt; aBox.volume(); }
        
// Function for testing if a constant is &lt; CBox object
inline bool operator&lt;(const double value, const CBox&amp; aBox)
{ return value &lt; aBox.volume(); }
        
// Function for testing if CBox object is &gt; a constant
inline bool operator&gt;(const CBox&amp; aBox, const double value)
{ return aBox.volume() &gt; value; }
        
// Function for testing if CBox object is &lt; a constant
inline bool operator&lt;( const CBox&amp; aBox, const double value)
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="400" id="calibre_link-862" class="calibre14"></span>{ return aBox.volume() &lt; value; }
        
// Function for testing if a constant is &gt;= a CBox object
inline bool operator&gt;=(const double value, const CBox&amp; aBox)
{ return value &gt;= aBox.volume(); }
        
// Function for testing if a constant is &lt;= CBox object
inline bool operator&lt;=(const double value, const CBox&amp; aBox)
{ return value &lt;= aBox.volume(); }
        
// Function for testing if CBox object is &gt;= a constant
inline bool operator&gt;=( const CBox&amp; aBox, const double value)
{ return aBox.volume() &gt;= value; }
        
// Function for testing if CBox object is &lt;= a constant
inline bool operator&lt;=( const CBox&amp; aBox, const double value)
{ return aBox.volume() &lt;= value; }
        
// Function for testing if a constant is == CBox object
inline bool operator==(const double value, const CBox&amp; aBox)
{ return value == aBox.volume(); }
        
// Function for testing if CBox object is == a constant
inline bool operator==(const CBox&amp; aBox, const double value)
{ return aBox.volume() == value; }
        
// Function for testing if a constant is != CBox object
inline bool operator!=(const double value, const CBox&amp; aBox)
{
  return value != aBox.volume();
}
 
// Function for testing if CBox object is != a constant
inline bool operator!=(const CBox&amp; aBox, const double value)
{
  return aBox.volume() != value;
}
 
// CBox multiply operator n*aBox
inline CBox operator*(int n, const CBox&amp; aBox)
{ return aBox * n; }
        
// Operator to return the free volume in a packed CBox
inline double operator%( const CBox&amp; aBox, const CBox&amp; bBox)
{ return aBox.volume() - (aBox / bBox) * bBox.volume(); }</code></pre>
<p class="calibre20">The <code class="calibre23">#pragma once</code> directive ensures the contents of this cannot be included into another file more than once. You have an <code class="calibre23">#include</code> directive for <code class="calibre23">Box.h</code> because the functions refer to the <code class="calibre23">CBox</code> class. Save the file. When you have completed this, you can select the Class View tab. The Class View tab now includes a <code class="calibre23">Global Functions and Variables</code> folder that contains all the functions you have just added.</p>
<p class="calibre20">When you define global functions in a project that are not inline, you put their definitions in a <code class="calibre23">.cpp</code> file. You also need to put the prototypes for the functions in an <code class="calibre23">.h</code> file with a <code class="calibre23">#pragma once</code> directive at the beginning. You can then include the <code class="calibre23">.h</code> file into any <code class="calibre23">.cpp</code> file that calls any of the functions so the compiler knows what they are.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="401" id="calibre_link-863" class="calibre14"></span>You’re now ready to start applying these global functions along with the <code class="calibre23">CBox</code> class to a specific problem in the world of boxes.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">Using the CBox Class</i></h4>
<p class="calibre20">Suppose that you are packaging candies. The candies are on the big side, real jawbreakers, occupying an envelope 1.5 inches long by 1 inch wide by 1 inch high. You have access to a standard candy box that is 4.5 inches by 7 inches by 2 inches, and you want to know how many candies will fit in the box so that you can set the price. You also have a standard carton that is 2 feet, 6 inches long by 18 inches wide and 18 inches deep, and you want to know how many boxes of candy it can hold and how much space you’re wasting when it has been filled.</p>
<p class="calibre20">In case the standard candy box isn’t a good solution, you would also like to know what custom candy box would be suitable. You know that you can get a good price on boxes with a length from 3 inches to 7.5 inches, a width from 3 inches to 5 inches, and a height from 1 inch to 2.5 inches, where each dimension can vary in steps of half an inch. You also know that you need to have at least 30 candies in a box, because this is the minimum quantity consumed by your largest customers at a sitting. Also, the candy box should not have empty space; complaints go up because customers think they are being cheated when the box is not full. Further, ideally, you want to pack the standard carton completely so the candies don’t rattle around. You don’t want to be too stringent about this; otherwise, packing could become difficult, so let’s say you have no wasted space if the free space in the packed carton is less than the volume of a single candy box.</p>
<p class="calibre20">With the <code class="calibre23">CBox</code> class, the problem becomes almost trivial; the solution is generated by the following <code class="calibre23">main()</code> function. Add a new source file, <code class="calibre23">Ex8_13.cpp</code>, to the project through the context menu you get when you right-click Source Files in the Solution Explorer pane, as you’ve done before. You can then type in the code shown here:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_13.cpp
// A sample packaging problem
#include &lt;iostream&gt;
#include "Box.h"
#include "BoxOperators.h"
using std::cout;
using std::endl;
        
int main()
{
  CBox candy {1.5, 1.0, 1.0};            // Candy definition
  CBox candyBox {7.0, 4.5, 2.0};         // Candy box definition
  CBox carton {30.0, 18.0, 18.0};        // Carton definition
        
  // Calculate candies per candy box
  int numCandies {candyBox/candy};
        
  // Calculate candy boxes per carton
  int numCboxes {carton/candyBox};
        
  // Calculate wasted carton space
  double wasted {carton%candyBox};
        
  cout &lt;&lt; "There are " &lt;&lt; numCandies &lt;&lt; " candies per candy box" &lt;&lt; endl
       <span {http://www.idpf.org/2007/ops}type="pagebreak" title="402" id="calibre_link-864" class="calibre14"></span>&lt;&lt; "For the standard boxes there are " &lt;&lt; numCboxes
       &lt;&lt; " candy boxes per carton " &lt;&lt; endl &lt;&lt; "with "
       &lt;&lt; wasted &lt;&lt; " cubic inches wasted." &lt;&lt; endl;
 
  cout &lt;&lt; endl &lt;&lt; "CUSTOM CANDY BOX ANALYSIS (No Waste)" &lt;&lt; endl;
  const int minCandiesPerBox {30};
 
  // Try the whole range of custom candy boxes
  for (double length{3.0}; length &lt;= 7.5; length += 0.5)
  {
    for (double width {3.0}; width &lt;= 5.0; width += 0.5)
    {
      for (double height {1.0}; height &lt;= 2.5; height += 0.5)
      {
        // Create new box each cycle
        CBox tryBox(length, width, height);
 
        if ((carton%tryBox &lt; tryBox.volume()) &amp;&amp; // Carton waste &lt; a candy box
          (tryBox%candy == 0.0) &amp;&amp;               // &amp; no waste in candy box
          (tryBox/candy &gt;= minCandiesPerBox))    // &amp; candy box holds minimum
        {
          cout &lt;&lt; "Trial Box L = " &lt;&lt; tryBox.getLength()
               &lt;&lt; " W = " &lt;&lt; tryBox.getWidth()
               &lt;&lt; " H = " &lt;&lt; tryBox.getHeight()
               &lt;&lt; endl;
          cout &lt;&lt; "Trial Box contains " &lt;&lt; tryBox / candy &lt;&lt; " candies"
               &lt;&lt; " and a carton contains " &lt;&lt; carton / tryBox
               &lt;&lt; " candy boxes." &lt;&lt; endl;
        }
      }
    }
  }
  return 0;
}</code></pre>
<p class="calibre20">Let’s look at how the program is organized. You have divided it into a number of files, which is typical in C++. You can see the files in the Solution Explorer tab. <code class="calibre23">Ex8_13.cpp</code> contains <code class="calibre23">main()</code> and has <code class="calibre23">#include</code> directives for the <code class="calibre23">iostream</code> standard header, <code class="calibre23">Box.h</code> that contains the definition for <code class="calibre23">CBox</code>, and <code class="calibre23">BoxOperators.h</code> that contains the definitions for the inline nonmembers functions.</p>
<p class="calibre20">A console program is usually divided into a number of files that fall into one of three basic categories:</p>
<ol class="calibre5">
<li class="calibre6"><code class="calibre23">.h</code> files containing library <code class="calibre23">#include</code> commands, global constants and variables, class definitions, and function prototypes &mdash; in other words, everything that is not executable code. They also contain inline function definitions. Where a program has several classes, the definitions are usually placed in separate <code class="calibre23">.h</code> files.</li>
<li class="calibre6"><code class="calibre23">.cpp</code> files containing the executable code for the program, plus <code class="calibre23">#include</code> directives for <code class="calibre23">.h</code> files that provide the definitions required by the executable code.</li>
<li class="calibre6">A <code class="calibre23">.cpp</code> file containing the function <code class="calibre23">main()</code>.</li>
</ol>
<p class="calibre20">The code in <code class="calibre23">main()</code>doesn’t need a lot of explanation &mdash; it’s almost a direct expression of the definition of the problem in words, because the operators in the class interface perform problem-oriented actions on <code class="calibre23">CBox</code> objects.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="403" id="calibre_link-865" class="calibre14"></span>The solution to the question of the use of standard boxes is in the declaration statements, which also compute the required answers as initializing values. You output these values with some explanatory comments.</p>
<p class="calibre20">The second part of the problem is solved by the nested <code class="calibre23">for</code> loops that iterate over the possible ranges of <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code> to evaluate all possible combinations. You could output them all, but this would involve 200 combinations of which you might only be interested in a few, so you have an <code class="calibre23">if</code> statement which identifies the options that you’re interested in. The <code class="calibre23">if</code> expression is only <code class="calibre23">true</code> if there’s no space wasted in the carton <i class="calibre15">and</i> the current trial candy box has no wasted space <i class="calibre15">and</i> it contains at least 30 candies.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Here’s the output from this program:</p>
<pre class="calibre28"><code class="calibre23">There are 42 candies per candy box
For the standard boxes there are 144 candy boxes per carton
with 648 cubic inches wasted.
 
CUSTOM CANDY BOX ANALYSIS (No Waste)
Trial Box L = 5 W = 4.5 H = 2
Trial Box contains 30 candies and a carton contains 216 candy boxes.
Trial Box L = 5 W = 4.5 H = 2
Trial Box contains 30 candies and a carton contains 216 candy boxes.
Trial Box L = 6 W = 3 H = 2.5
Trial Box contains 30 candies and a carton contains 216 candy boxes.
Trial Box L = 6 W = 4.5 H = 2
Trial Box contains 36 candies and a carton contains 180 candy boxes.
Trial Box L = 6 W = 4.5 H = 2.5
Trial Box contains 45 candies and a carton contains 144 candy boxes.
Trial Box L = 6 W = 5 H = 1.5
Trial Box contains 30 candies and a carton contains 216 candy boxes.
Trial Box L = 6 W = 5 H = 2
Trial Box contains 40 candies and a carton contains 162 candy boxes.
Trial Box L = 6 W = 5 H = 2.5
Trial Box contains 50 candies and a carton contains 129 candy boxes.
Trial Box L = 7.5 W = 3 H = 2
Trial Box contains 30 candies and a carton contains 216 candy boxes.</code></pre>
<p class="calibre20">You have a duplicate solution because you evaluate boxes in the nested loop that have a length of 5 and a width of 4.5, and boxes that have a length of 4.5 and a width of 5. Because the <code class="calibre23">CBox</code> constructor ensures that the length is not less than the width, these are identical. You could include additional logic to avoid presenting duplicates, but it hardly seems worth the effort. You could treat it as an exercise if you like.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-306" class="calibre3"></a>ORGANIZING YOUR PROGRAM CODE</h2>
<p class="calibre13">In example <code class="calibre23">Ex8_13</code>, you distributed the code among several files for the first time. This is common practice with C++ applications generally and with Windows programming it is essential. The sheer volume of code involved in even the simplest Windows program necessitates dividing it into workable chunks.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="404" id="calibre_link-866" class="calibre14"></span>As I discussed in the previous section, there are basically two kinds of source code files in a C++ program, <code class="calibre23">.h</code> files and <code class="calibre23">.cpp</code> files. This is illustrated in <a id="calibre_link-1372" href="#calibre_link-420" class="calibre3">Figure 8-10</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000086.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-420" href="#calibre_link-1372" class="calibre3">FIGURE 8-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">From time to time, you might want to use code from existing files in a new project. In this case, you can add the files to the project, either by using the Project <img src="images/000122.png" alt="image" class="calibre25" />  Add Existing Item menu option, or by right-clicking Source Files or Header Files in the Solution Explorer tab and selecting Add <img src="images/000122.png" alt="image" class="calibre25" />  Existing Item from the context menu. You don’t need to add <code class="calibre23">.h</code> files to your project, although you can if you want them shown in the Solution Explorer pane immediately. The code from <code class="calibre23">.h</code> files will be added at the beginning of the <code class="calibre23">.cpp</code> files that require them as a result of the <code class="calibre23">#include</code> directives that you specify. You need <code class="calibre23">#include</code> directives for header files containing standard library functions and other standard definitions, as well as for your own header files. Visual C++ automatically keeps track of all these files, and enables you to view them in the Solution Explorer tab. As you saw in the previous example, you can also view class definitions and global constants and variables in the Class View tab.</p>
<p class="calibre13">In a Windows program, there are other kinds of definitions for the specification of such things as menus and toolbar buttons. These are stored in files with extensions like <code class="calibre23">.rc</code> and <code class="calibre23">.ico</code>. These are created and tracked automatically by Visual C++.</p>
<section class="toclist">
<h3 class="calibre21">Naming Program Files</h3>
<p class="calibre13">As I have said, for classes of any complexity, it’s usual to store the class definition in an <code class="calibre23">.h</code> file with a filename based on the class name, and to store the implementation of function members that are defined outside the class in a <code class="calibre23">.cpp</code> file with the same name. On this basis, the definition of our <code class="calibre23">CBox</code> class appeared in a file with the name <code class="calibre23">Box.h</code>. Similarly, the class implementation was stored in <code class="calibre23">Box.cpp</code>. We didn’t follow this convention in the earlier examples because they were very short, and it was easier to reference the examples with names derived from the chapter number and the sequence <span {http://www.idpf.org/2007/ops}type="pagebreak" title="405" id="calibre_link-867" class="calibre14"></span>number of the example within the chapter. With programs of any size though, it becomes essential to structure the code this way, so it would be a good idea to get into the habit of creating <code class="calibre23">.h</code> and <code class="calibre23">.cpp</code> files from now on.</p>
<p class="calibre13">Segmenting a program into <code class="calibre23">.h</code> and <code class="calibre23">.cpp</code> files is a very convenient approach, as it makes it easy to find the definition or implementation of any class, particularly if you’re working in a development environment that doesn’t have all the tools that Visual C++ provides. As long as you know the class name, you can go directly to the file you want. This isn’t a rigid rule though. It’s sometimes useful to group the definitions of a set of closely related classes together in a single file and assemble their implementations similarly. However you choose to structure your files, Class View still displays all the classes, as well as the members of each class. Double-clicking any of the entries in the Class View tree will take you directly to the relevant source code.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-307" class="calibre3"></a>LIBRARY CLASSES FOR STRINGS</h2>
<p class="calibre13">As I said in Chapter 4, the <code class="calibre23">string</code> header defines the <code class="calibre23">std::string</code> and <code class="calibre23">std::wstring</code> classes that represent character strings. They are both instances of the <code class="calibre23">std::basic_string&lt;T&gt;</code> class template. The <code class="calibre23">string</code> class is defined as <code class="calibre23">basic_string&lt;char&gt;</code>, and <code class="calibre23">wstring</code> is defined as <code class="calibre23">basic_string&lt;wchar_t&gt;</code>, so <code class="calibre23">string</code> objects are strings of characters of type <code class="calibre23">char</code>, and <code class="calibre23">wstring</code> represents strings of characters of type <code class="calibre23">wchar_t</code>.</p>
<p class="calibre13">These string types are much easier to use than null-terminated strings and bring with them a whole range of powerful functions. Because <code class="calibre23">string</code> and <code class="calibre23">wstring</code> are both instances of the <code class="calibre23">basic_string&lt;T&gt;</code> template, they provide the same functionality, so I’ll only discuss their features and use in the context of the <code class="calibre23">string</code> type. The <code class="calibre23">wstring</code> type works in the same way, except that the strings contain Unicode UTF-16 character codes and you must use the <code class="calibre23">L</code> prefix for string literals. Subsequent code fragments assume that there is a <code class="calibre23">using</code> declaration for <code class="calibre23">std::string</code>.</p>
<section class="toclist">
<h3 class="calibre21">Creating String Objects</h3>
<p class="calibre13">Creating <code class="calibre23">string</code> objects is easy but you have a lot of choices as to how. First, you can create and initialize a <code class="calibre23">string</code> object like this:</p>
<pre class="calibre28"><code class="calibre23">string sentence {"This sentence is false."};</code></pre>
<p class="calibre13">The <code class="calibre23">sentence</code> object is initialized with the literal that appears in the initializer list. A <code class="calibre23">string</code> object has no terminating null character, so the string length is the number of characters in the string, 23 in this instance. You can obtain the length of the string encapsulated by a <code class="calibre23">string</code> object by calling its <code class="calibre23">length()</code> member function. For example:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; "The string is of length " &lt;&lt; sentence.length() &lt;&lt; endl;</code></pre>
<p class="calibre13">Executing the statement produces the output:</p>
<pre class="calibre28"><code class="calibre23">The string is of length 23</code></pre>
<p class="calibre13">Incidentally, you can output a <code class="calibre23">string</code> object to <code class="calibre23">cout</code> in the same way as any other variable:</p>
<pre class="calibre28"><code class="calibre23">cout &lt;&lt; sentence &lt;&lt; endl;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="406" id="calibre_link-868" class="calibre14"></span>This displays the <code class="calibre23">sentence</code> string on a line by itself. You can also read a string into a <code class="calibre23">string</code> object like this:</p>
<pre class="calibre28"><code class="calibre23">cin &gt;&gt; sentence;</code></pre>
<p class="calibre13">Reading from <code class="calibre23">cin</code> in this way ignores leading whitespace until a non-whitespace character is found, and input ends when you enter a space after one or more non-whitespace characters. You will often want to read text into a <code class="calibre23">string</code> object that includes spaces and may span several lines. In this case, the <code class="calibre23">getline()</code> function template that is defined in the <code class="calibre23">string</code> header file is much more convenient. For example:</p>
<pre class="calibre28"><code class="calibre23">getline(cin, sentence, '*');</code></pre>
<p class="calibre13">This template function is specifically for reading data from a stream into a <code class="calibre23">string</code> or <code class="calibre23">wstring</code> object. The first argument is the stream that is the source of input, which doesn’t have to be <code class="calibre23">cin</code>; the second argument is the object that is to receive the input; and the third argument is the character that terminates input. Here, the terminating character is <code class="calibre23">'*'</code>, so this statement reads a string including any characters that are not <code class="calibre23">*</code> into <code class="calibre23">sentence</code> from <code class="calibre23">cin.</code>  Input ends when an asterisk is read from the stream.</p>
<p class="calibre13">If you don’t specify an initial string literal when you create a <code class="calibre23">string</code> object, the object will contain an empty string:</p>
<pre class="calibre28"><code class="calibre23">string astring;                     // Create an empty string</code></pre>
<p class="calibre13">Calling <code class="calibre23">length()</code> for <code class="calibre23">astring</code> will return zero.</p>
<p class="calibre13">Another possibility is to initialize a <code class="calibre23">string</code> object with a single character repeated a number of times:</p>
<pre class="calibre28"><code class="calibre23">string bees(7, 'b');                // String is "bbbbbbb"</code></pre>
<p class="calibre13">The first argument to the constructor is the number of repetitions of the character specified by the second argument. Note that you can’t use uniform initialization here because of the rules for constructor selection with a constructor initialization list.</p>
<p class="calibre13">Finally, you can initialize a <code class="calibre23">string</code> object with all or part of another <code class="calibre23">string</code> object:</p>
<pre class="calibre28"><code class="calibre23">string letters {bees};</code></pre>
<p class="calibre13">The <code class="calibre23">letters</code> object will be initialized with the string from <code class="calibre23">bees</code>.</p>
<p class="calibre13">To select part of a <code class="calibre23">string</code> object as initializer, you call the string constructor with three arguments; the first is the <code class="calibre23">string</code> object that is the source of the initializing string, the second is the index position of the first character to be selected, and the third argument is the number of characters to be selected. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">string sentence {"This sentence is false."};
string part {sentence, 5, 11};</code></pre>
<p class="calibre13">The <code class="calibre23">part</code> object will be initialized with 11 characters from <code class="calibre23">sentence</code> beginning with the sixth character (the first character is at index position 0). Thus, <code class="calibre23">part</code> will contain <code class="calibre23">"sentence is"</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="407" id="calibre_link-869" class="calibre14"></span>Of course, you can create arrays of <code class="calibre23">string</code> objects and initialize them using the usual notation. For example:</p>
<pre class="calibre28"><code class="calibre23">  string animals[] { "dog", "cat", "horse", "donkey", "lion"};</code></pre>
<p class="calibre13">This creates an array of five <code class="calibre23">string</code> objects initialized with the string literals between the braces.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Concatenating Strings</h3>
<p class="calibre13">Perhaps the most common operation with strings is joining two strings to form a single string. You can use the <code class="calibre23">+</code> operator to join string objects or a <code class="calibre23">string</code> object with a string literal. Here are some examples:</p>
<pre class="calibre28"><code class="calibre23">string sentence1 {"This sentence is false."};
string sentence2 {"Therefore the sentence above must be true!"};
string combined;                       // Create an empty string
sentence1 = sentence1 + "\n";          // Append string containing newline
combined = sentence1 + sentence2;      // Join two strings
cout &lt;&lt; combined &lt;&lt; endl;              // Output the result</code></pre>
<p class="calibre13">The first three statements create <code class="calibre23">string</code> objects. The next statement appends <code class="calibre23">"\n"</code> to <code class="calibre23">sentence1</code> and stores the result in <code class="calibre23">sentence1</code>. The next statement joins <code class="calibre23">sentence1</code> and <code class="calibre23">sentence2</code> and stores the result in <code class="calibre23">combined</code>. The last statement outputs <code class="calibre23">combined</code>. Executing these statements will result in the following output:</p>
<pre class="calibre28"><code class="calibre23">This sentence is false.
Therefore the sentence above must be true!</code></pre>
<p class="calibre13">String concatenation using the <code class="calibre23">+</code> operator is possible because the <code class="calibre23">string</code> class implements <code class="calibre23">operator+()</code>. This implies that one of the operands must be a <code class="calibre23">string</code> object, so you can’t use the <code class="calibre23">+</code> operator to join two string literals. Keep in mind that each time you use the <code class="calibre23">+</code> operator, you are creating a new <code class="calibre23">string</code> object, which involves a certain amount of overhead. However, the string class does use move semantics where possible.</p>
<p class="calibre13">You can use the <code class="calibre23">+</code> operator to join a character to a <code class="calibre23">string</code> object, so you could have written the fourth statement in the previous code fragment as:</p>
<pre class="calibre28"><code class="calibre23">sentence1 = sentence1 + '\n';          // Append newline character to string</code></pre>
<p class="calibre13">The <code class="calibre23">string</code> class implements <code class="calibre23">operator+=()</code> such that the right operand can be a string literal, a <code class="calibre23">string</code> object, or a single character. You could write the previous statement as,</p>
<pre class="calibre28"><code class="calibre23">sentence1 += '\n';</code></pre>
<p class="calibre13">or:</p>
<pre class="calibre28"><code class="calibre23">sentence1 += "\n";</code></pre>
<p class="calibre13">There is a difference between using the <code class="calibre23">+=</code> operator and using the <code class="calibre23">+</code> operator. As I said, the <code class="calibre23">+</code> operator creates a new <code class="calibre23">string</code> object containing the combined string. The <code class="calibre23">+=</code> operator appends the string or character that is the right operand to the <code class="calibre23">string</code> object that is the left operand, so the <code class="calibre23">string</code> object is modified directly and no new object is created.</p>
<p class="calibre13">Let’s exercise some of what I have described in an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="408" id="calibre_link-870" class="calibre24"></span>TRY IT OUT: Creating and Joining Strings</h3>
<p class="calibre20">This is a simple example that reads names and ages from the keyboard and then lists what you entered. Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_14.cpp
// Creating and joining string objects
#include &lt;iostream&gt;
#include &lt;string&gt;
using std::cout;
using std::endl;
using std::string;
        
// List names and ages
void listnames(string names[], string ages[], size_t count)
{
  cout &lt;&lt; "The names you entered are: " &lt;&lt; endl;
  for(size_t i {}; i &lt; count &amp;&amp; !names[i].empty(); ++i)
    cout &lt;&lt; names[i] + " aged " + ages[i] + '.' &lt;&lt; endl;
}
        
int main()
{
  const size_t count {100};
  string names[count];
  string ages[count];
  string firstname;
  string secondname;
        
  for(size_t i {}; i&lt;count; ++i)
  {
    cout &lt;&lt; "Enter a first name or press Enter to end: ";
    std::getline(cin, firstname, '\n');
    if(firstname.empty())
    {
      listnames(names, ages, i);
      cout &lt;&lt; "Done!!" &lt;&lt; endl;
      return 0;
    }
        
    cout &lt;&lt; "Enter a second name: ";
    std::getline(std::cin, secondname, '\n');
        
    names[i] = firstname + ' ' + secondname;
    cout &lt;&lt; "Enter " + firstname + "'s age: ";
    std::getline(std::cin, ages[i], '\n');
  }
  cout &lt;&lt; "No space for more names." &lt;&lt; endl;
  listnames(names, ages, count);
  return 0;
}</code></pre>
<p class="calibre20"><code class="calibre23">ages</code> would usually be an array of integers but I made it an array of strings here just to use more strings. The example produces output similar to the following:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="409" id="calibre_link-871" class="calibre14"></span>Enter a first name or press Enter to end: Marilyn
Enter a second name: Munroe
Enter Marilyn's age: 26
        
Enter a first name or press Enter to end: Tom
Enter a second name: Crews
Enter Tom's age: 45
        
Enter a first name or press Enter to end: Arnold
Enter a second name: Weisseneggar
Enter Arnold's age: 52
        
Enter a first name or press Enter to end:
        
The names you entered are:
Marilyn Munroe aged 26.
Tom Crews aged 45.
Arnold Weisseneggar aged 52.
Done!!</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">listnames</code> function lists names and ages stored in arrays that are passed as the first two arguments. The third argument is a count of the number of elements in the arrays. Listing of the data occurs in a loop:</p>
<pre class="calibre28"><code class="calibre23">  for(size_t i {}; i &lt; count &amp;&amp; !names[i].empty(); ++i)
    cout &lt;&lt; names[i] + " aged " + ages[i] + '.' &lt;&lt; endl;</code></pre>
<p class="calibre20">The loop condition is a belt-and-braces control mechanism in that it not only checks that the index <code class="calibre23">i</code> is less than <code class="calibre23">count</code> that is passed as the third argument, but it also calls <code class="calibre23">empty()</code>for the current element to verify that it is not an empty string. The single statement in the body of the loop concatenates the current string in <code class="calibre23">names[i]</code> with the literal <code class="calibre23">" aged "</code>, the <code class="calibre23">ages[i]</code> string, and the character <code class="calibre23">'.'</code>, and it writes the resultant string to <code class="calibre23">cout</code>. The expression concatenating the strings is equivalent to:</p>
<pre class="calibre28"><code class="calibre23">((names[i].operator+(" aged ")).operator+(ages[i])).operator+('.')</code></pre>
<p class="calibre20">Each call of the <code class="calibre23">operator+()</code> function returns a new <code class="calibre23">string</code> object. Thus, the expression demonstrates combining a <code class="calibre23">string</code> object with a string literal, a <code class="calibre23">string</code> object with another <code class="calibre23">string</code> object, and a <code class="calibre23">string</code> object with a character literal.</p>
<p class="calibre20">Although the preceding code demonstrates the <code class="calibre23">string::operator+()</code> function, for performance reasons, it would be better to use the following:</p>
<pre class="calibre28"><code class="calibre23">  cout &lt;&lt; names[i] &lt;&lt; " aged " &lt;&lt; ages[i] &lt;&lt; '.' &lt;&lt; endl;</code></pre>
<p class="calibre20">This avoids the calls to the operator function and the creation of the <code class="calibre23">string</code> objects that result from that.</p>
<p class="calibre20">In <code class="calibre23">main()</code>, you create two arrays that can store <code class="calibre23">count</code> objects of type <code class="calibre23">string</code>:</p>
<pre class="calibre28"><code class="calibre23">  const size_t count {100};
  string names[count];
  string ages[count];</code></pre>
<p class="calibre20">The <code class="calibre23">names</code> and <code class="calibre23">ages</code> arrays store names and corresponding age values that are entered from the keyboard.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="410" id="calibre_link-872" class="calibre14"></span>Within the <code class="calibre23">for</code> loop in <code class="calibre23">main()</code>, you read the first and second names separately using the <code class="calibre23">getline()</code>function template:</p>
<pre class="calibre28"><code class="calibre23">    cout &lt;&lt; "Enter a first name or press Enter to end: ";
    std::getline(std::cin, firstname, '\n');
    if(firstname.empty())
    {
      listnames(names, ages, i);
      cout &lt;&lt; "Done!!" &lt;&lt; endl;
      return 0;
    }
        
    cout &lt;&lt; "Enter a second name: ";
    std::getline(std::cin, secondname, '\n');</code></pre>
<p class="calibre20">The <code class="calibre23">getline()</code> function allows an empty string to be read, something you cannot do using the <code class="calibre23">&gt;&gt;</code> operator. The first argument to <code class="calibre23">getline()</code> is the stream that is the source of the input, the second argument is the destination for the input, and the third argument is the character that signals the end of the input. If you omit the third argument, the default is <code class="calibre23">'\n'</code>, so you could omit it here. You use the ability to read an empty string here because you test for an empty string in <code class="calibre23">firstname</code> by calling its <code class="calibre23">empty()</code> function. An empty string signals the end of input, so you call <code class="calibre23">listnames()</code> to output the data, and you end the program.</p>
<p class="calibre20">When <code class="calibre23">firstname</code> is not empty, you continue to read the second name into <code class="calibre23">secondname</code>, again using the <code class="calibre23">getline()</code>function template. You concatenate <code class="calibre23">firstname</code> and <code class="calibre23">secondname</code> using the <code class="calibre23">+</code> operator and store the result in <code class="calibre23">names[i]</code>, the currently unused element in the <code class="calibre23">names</code> array.</p>
<p class="calibre20">Finally in the loop, you read a string for the age of the person and store the result in <code class="calibre23">ages[i]</code>. The <code class="calibre23">for</code> loop limits the number of entries to <code class="calibre23">count</code>, which corresponds to the number of elements in the arrays. If you fall through the end of the loop, the arrays are full, so after displaying a message, you output the data that was entered.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Accessing and Modifying Strings</h3>
<p class="calibre13">You can access any character in a <code class="calibre23">string</code> object to read it or overwrite it using the subscript operator, <code class="calibre23">[]</code>. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">string sentence {"Too many cooks spoil the broth."};
for(size_t i {}; i &lt; sentence.length(); i++)
{
  if(' ' == sentence[i])
    sentence[i] = '*';
}</code></pre>
<p class="calibre13">This inspects each character in the <code class="calibre23">sentence</code> string in turn to see if it is a space, and if it is, replaces the character with an asterisk.</p>
<p class="calibre13">You can use the <code class="calibre23">at()</code> member function to achieve the same result:</p>
<pre class="calibre28"><code class="calibre23">string sentence {"Too many cooks spoil the broth."};
for(size_t i {}; i &lt; sentence.length(); i++)
{
  if(' ' == sentence.at(i))
    sentence.at(i) = '*';
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="411" id="calibre_link-873" class="calibre14"></span>This does exactly the same as the previous fragment, so what’s the difference between them? Well, subscripting is faster than using <code class="calibre23">at()</code> but the downside is that the validity of the index is not checked. If the index is out of range, the result of using the subscript operator is undefined. The <code class="calibre23">at()</code> function is a bit slower but it does check the index and if it is not valid, the function will throw an <code class="calibre23">std::out_of_range</code> exception. You would use the <code class="calibre23">at()</code> function when there is the possibility of the index value being out of range, and in this situation you should put the code in a <code class="calibre23">try</code> block and handle the exception appropriately. If you are sure index out of range conditions cannot arise, then use the <code class="calibre23">[]</code> operator.</p>
<p class="calibre13">You can use the range-based <code class="calibre23">for</code> loop with a <code class="calibre23">string</code> object to iterate over all of the characters in the string:</p>
<pre class="calibre28"><code class="calibre23">string sentence {"Too many cooks spoil the broth."};
for(auto&amp; ch : sentence)
{
  if(' ' == ch)
    ch = '*';
}</code></pre>
<p class="calibre13">This replaces spaces with asterisks like the loop you saw earlier. This is much simpler. Using a reference type for <code class="calibre23">ch</code> enables you to change the string.</p>
<p class="calibre13">You can extract part of an existing object as a new <code class="calibre23">string</code> object. For example:</p>
<pre class="calibre28"><code class="calibre23">string sentence {"Too many cooks spoil the broth."};
string substring {sentence.substr(4, 10)};           // Extracts "many cooks"</code></pre>
<p class="calibre13">The first argument to <code class="calibre23">substr()</code>is the first character of the substring to be extracted, and the second argument is the count of the number of characters in the substring.</p>
<p class="calibre13">By using the <code class="calibre23">append()</code> function for a <code class="calibre23">string</code> object, you can add one or more characters to the end of the string. This function comes in several versions. You can append one or more of a given character or a string literal or a <code class="calibre23">string</code> object to the object for which the function is called. For example:</p>
<pre class="calibre28"><code class="calibre23">string phrase {"The higher"};
string word {"fewer"};
phrase.append(1, ' ');                 // Append one space
phrase.append("the ");                 // Append a string literal
phrase.append(word);                   // Append a string object
phrase.append(2, '!');                 // Append two exclamation marks</code></pre>
<p class="calibre13">After executing this sequence, <code class="calibre23">phrase</code> will contain <code class="calibre23">"The higher the fewer!!"</code>. With the version of <code class="calibre23">append()</code> with two arguments, the first argument is the count of the number of times the character specified by the second argument is to be appended. When you call <code class="calibre23">append()</code>, the function returns a reference to the object for which it was called, so you could write the preceding four <code class="calibre23">append()</code> calls in a single statement:</p>
<pre class="calibre28"><code class="calibre23">phrase.append(1, ' ').append("the ").append(word).append(2, '!');</code></pre>
<p class="calibre13">You can also use <code class="calibre23">append()</code> to append part of a string literal or part of a <code class="calibre23">string</code> object to an existing string:</p>
<pre class="calibre28"><code class="calibre23">string phrase {"The more the merrier."};
string query {"Any"};
query.append(phrase, 3, 5).append(1, '?');</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="412" id="calibre_link-874" class="calibre14"></span>After these statements <code class="calibre23">query</code> will contain <code class="calibre23">"Any more?"</code>. In the last statement, the first call to the <code class="calibre23">append()</code> function has three arguments:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The first argument, <code class="calibre23">phrase</code>, is the <code class="calibre23">string</code> object from which characters are to be extracted and appended to <code class="calibre23">query</code>.</li>
<li class="calibre6">The second argument, 3, is the index position of the first character to be extracted.</li>
<li class="calibre6">The third argument, 5, is the count of the total number of characters to be appended.</li>
</ul>
<p class="calibre13">Thus, the substring <code class="calibre23">" more"</code> is appended to <code class="calibre23">query</code> by this call. The second call for the <code class="calibre23">append()</code> function appends a question mark to <code class="calibre23">query</code>.</p>
<p class="calibre13">You could use the <code class="calibre23">push_back()</code> function as an alternative to <code class="calibre23">append()</code> when you want to append a single character, like this:</p>
<pre class="calibre28"><code class="calibre23">query.push_back('*');</code></pre>
<p class="calibre13">This appends an asterisk to the end of the <code class="calibre23">query</code> string.</p>
<p class="calibre13">Sometimes, adding characters to the end of a string just isn’t enough. There are occasions when you want to insert one or more characters into the interior of a string. Versions of the <code class="calibre23">insert()</code> function will do that for you:</p>
<pre class="calibre28"><code class="calibre23">string saying {"A horse"};
string word {"blind"};
string sentence {"He is as good as gold."};
string phrase {"a wink too far"};
saying.insert(1, " ");                  // Insert a space character
saying.insert(2, word);                 // Insert a string object
saying.insert(2, "nodding", 3);         // Insert 3 characters of a string literal
saying.insert(5, sentence, 2, 15);      // Insert part of a string at position 5
saying.insert(20, phrase, 0, 9);        // Insert part of a string at position 20
saying.insert(29, " ").insert(30, "a poor do", 0, 2);</code></pre>
<p class="calibre13">I’m sure you’ll be interested to know that after executing these statements, <code class="calibre23">saying</code> will contain the string <code class="calibre23">"A nod is as good as a wink to a blind horse"</code>. The parameters to the various versions of <code class="calibre23">insert()</code> are:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION PROTOTYPE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; insert(<br class="calibre10" />  size_t index,<br class="calibre10" />  const char* pstring)</code></td>
<td class="calibre32">Inserts the null-terminated string <code class="calibre23">pstring</code> at position <code class="calibre23">index</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; insert(<br class="calibre10" />  size_t index,<br class="calibre10" />  const string&amp; astring)</code></td>
<td class="calibre32">Inserts the <code class="calibre23">string</code> object <code class="calibre23">astring</code> at position <code class="calibre23">index</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; insert(<br class="calibre10" />  size_t index,<br class="calibre10" />  const char* pstring,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Inserts the first <code class="calibre23">count</code> characters from the null-terminated string <code class="calibre23">pstring</code> at position <code class="calibre23">index</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="413" id="calibre_link-875" class="calibre14"></span><code class="calibre23">string&amp; insert(<br class="calibre10" />  size_t index,<br class="calibre10" />  size_t count,<br class="calibre10" />  char ch)</code></td>
<td class="calibre32">Inserts <code class="calibre23">count</code> copies of the character <code class="calibre23">ch</code> at position <code class="calibre23">index</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; insert(<br class="calibre10" />  size_t index,<br class="calibre10" />  const string&amp; astring,<br class="calibre10" />  size_t start,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Inserts <code class="calibre23">count</code> characters from the <code class="calibre23">string</code> object <code class="calibre23">astring</code>, beginning with the character at position <code class="calibre23">start</code>; the substring is inserted at position <code class="calibre23">index</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13">These versions of <code class="calibre23">insert()</code> return a reference to the <code class="calibre23">string</code> object for which the function is called. This allows you to chain calls together, as in the last statement in the previous code fragment.</p>
<p class="calibre13">This is not the complete set of <code class="calibre23">insert()</code> functions, but you can do everything you need with those in the table. The other versions use <i class="calibre15">iterators</i> as arguments, and you’ll learn about iterators in Chapter 10.</p>
<p class="calibre13">You can interchange the strings encapsulated by two <code class="calibre23">string</code> objects by calling the <code class="calibre23">swap()</code> member function. For example:</p>
<pre class="calibre28"><code class="calibre23">string phrase {"The more the merrier."};
string query {"Any"};
query.swap(phrase);</code></pre>
<p class="calibre13">This results in <code class="calibre23">query</code> containing <code class="calibre23">"The more the merrier."</code> and <code class="calibre23">phrase</code> containing <code class="calibre23">"Any"</code>. Of course, executing <code class="calibre23">phrase.swap(query)</code> would have the same effect.</p>
<p class="calibre13">You can obtain the string in <code class="calibre23">string</code> object as a null-terminated string by calling its <code class="calibre23">c_str()</code> member. For example:</p>
<pre class="calibre28"><code class="calibre23">string phrase {"The higher the fewer"};
const char *pstring {phrase.c_str()};</code></pre>
<p class="calibre13">The <code class="calibre23">c_str()</code> function returns a pointer to a null-terminated string with the same contents as the <code class="calibre23">string</code> object.</p>
<p class="calibre13">You can obtain the contents of a <code class="calibre23">string</code> object as an array of <code class="calibre23">char</code> elements by calling its <code class="calibre23">data()</code> member. Note that the array contains just the characters from the <code class="calibre23">string</code> object, without a terminating null.</p>
<p class="calibre13">You can replace part of a <code class="calibre23">string</code> object by calling its <code class="calibre23">replace()</code> function. This comes in several versions, as the table shows.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION PROTOTYPE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; replace(<br class="calibre10" />  size_t index,<br class="calibre10" />  size_t count,<br class="calibre10" />  const char* pstring)</code></td>
<td class="calibre32">Replaces <code class="calibre23">count</code> characters, starting at position <code class="calibre23">index</code>, with the first <code class="calibre23">count</code> characters from <code class="calibre23">pstring</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="414" id="calibre_link-876" class="calibre14"></span><code class="calibre23">string&amp; replace(<br class="calibre10" />  size_t index,<br class="calibre10" />  size_t count,<br class="calibre10" />  const string&amp; astring)</code></td>
<td class="calibre32">Replaces <code class="calibre23">count</code> characters, starting at position <code class="calibre23">index</code>, with the first <code class="calibre23">count</code> characters from <code class="calibre23">astring</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; replace(<br class="calibre10" />  size_t index,<br class="calibre10" />  size_t count1,<br class="calibre10" />  const char* pstring,<br class="calibre10" />  size_t count2)</code></td>
<td class="calibre32">Replaces <code class="calibre23">count1</code> characters, starting at position <code class="calibre23">index</code>, with up to <code class="calibre23">count2</code> characters from <code class="calibre23">pstring</code>. This allows the replacement substring to be longer or shorter than the substring that is replaced.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; replace(<br class="calibre10" />  size_t index1,<br class="calibre10" />  size_t count1,<br class="calibre10" />  const string&amp; astring,<br class="calibre10" />  size_t index2,<br class="calibre10" />  size_t count2)</code></td>
<td class="calibre32">Replaces <code class="calibre23">count1</code> characters, starting at position <code class="calibre23">index1</code>, with <code class="calibre23">count2</code> characters from <code class="calibre23">astring</code>, starting at position <code class="calibre23">index2</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">string&amp; replace(<br class="calibre10" />  size_t index,<br class="calibre10" />  size_t count1,<br class="calibre10" />  size_t count2,<br class="calibre10" />  char ch)</code></td>
<td class="calibre32">Replaces <code class="calibre23">count1</code> characters, starting at <code class="calibre23">index</code>, with <code class="calibre23">count2</code> occurrences of the character <code class="calibre23">ch</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13">In each case, a reference to the <code class="calibre23">string</code> object for which the function is called is returned.</p>
<p class="calibre13">Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">string proverb {"A nod is as good as a wink to a blind horse"};
string sentence {"It's bath time!"};
proverb.replace(38, 5, sentence, 5, 3);</code></pre>
<p class="calibre13">This uses the fourth version of <code class="calibre23">replace()</code> from the preceding table to substitute <code class="calibre23">"bat"</code> in place of <code class="calibre23">"horse"</code> in the string <code class="calibre23">proverb</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Comparing Strings</h3>
<p class="calibre13">You have a full complement of operators for comparing <code class="calibre23">string</code> objects or comparing a <code class="calibre23">string</code> object with a literal. Operator overloading has been implemented in the <code class="calibre23">string</code> class for the following operators:</p>
<pre class="calibre28"><code class="calibre23"> ==   !=   &lt;   &lt;=   &gt;   &gt;=</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="415" id="calibre_link-877" class="calibre14"></span>Here’s an example of the use of these:</p>
<pre class="calibre28"><code class="calibre23">string dog1 {"St Bernard"};
string dog2 {"Tibetan Mastiff"};
if(dog1 &lt; dog2)
  cout &lt;&lt; dog1 &lt;&lt; " comes first!" &lt;&lt; endl;
else if(dog1 &gt; dog2)
  cout &lt;&lt; dog2 &lt;&lt; " comes first!" &lt;&lt; endl;
else
  cout &lt;&lt; dog1 &lt;&lt; " is equal to " &lt;&lt; dog2 &lt;&lt; "." &lt;&lt; endl;</code></pre>
<p class="calibre13">When you compare strings, corresponding characters are compared until either a pair of characters is found that differ, or the end of one or both strings is reached. When two corresponding characters differ, the character code values determine which string is less than the other. If no character pairs are different, the string with fewer characters is less than the other string. Two strings are equal if they contain the same number of characters and corresponding characters are identical.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Comparing Strings</h3>
<p class="calibre20">This example illustrates the use of the comparison operators by implementing an extremely inefficient sorting method. Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_15.cpp
// Comparing and sorting words
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using std::cout;
using std::endl;
using std::string;
        
string* sort(string* strings, size_t count)
{
  bool swapped {false};
  while(true)
  {
    for(size_t i {}; i &lt; count-1; i++)
    {
      if(strings[i] &gt; strings[i+1])
      {
        swapped = true;
        strings[i].swap(strings[i+1]);
      }
    }
    if(!swapped)
      break;
    swapped = false;
  }
  return strings;
}
        
int main()
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="416" id="calibre_link-878" class="calibre14"></span>{
  const size_t maxstrings {100};
  string strings[maxstrings];
  size_t nstrings {};
  size_t maxwidth {};
        
  // Read up to 100 words into the strings array
  while(nstrings &lt; maxstrings)
  {
    cout &lt;&lt; "Enter a word or press Enter to end: ";
    std::getline(std::cin, strings[nstrings]);
    if(maxwidth &lt; strings[nstrings].length())
      maxwidth = strings[nstrings].length();
    if(strings[nstrings].empty())
      break;
    ++nstrings;
  }
        
  // Sort the input in ascending sequence
  sort(strings,nstrings);
  cout &lt;&lt; endl
       &lt;&lt; "In ascending sequence, the words you entered are:"
       &lt;&lt; endl
       &lt;&lt; std::setiosflags(std::ios::left);      // Left-justify the output
  for(size_t i {}; i &lt; nstrings; i++)
  {
    if(i % 5 == 0)
      cout &lt;&lt; endl;
    cout &lt;&lt; std::setw(maxwidth+2) &lt;&lt; strings[i];
  }
  cout &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">Here’s some typical output from this example:</p>
<pre class="calibre28"><code class="calibre23">Enter a word or press Enter to end: loquacious
Enter a word or press Enter to end: transmogrify
Enter a word or press Enter to end: abstemious
Enter a word or press Enter to end: facetious
Enter a word or press Enter to end: xylophone
Enter a word or press Enter to end: megaphone
Enter a word or press Enter to end: chauvinist
Enter a word or press Enter to end:
        
In ascending sequence, the words you entered are:
        
abstemious    chauvinist    facetious     loquacious    megaphone
transmogrify  xylophone</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="417" id="calibre_link-879" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The most interesting part is the <code class="calibre23">sort()</code> function that accepts two arguments, the address of a <code class="calibre23">string</code> array and the number of array elements. The function implements the bubble sort, which works by scanning through the array and comparing successive elements. All the work is done in the <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  bool swapped {false};
  while(true)
  {
    for(size_t i {}; i &lt; count-1; i++)
    {
      if(strings[i] &gt; strings[i+1])
      {
        swapped = true;
        strings[i].swap(strings[i+1]);
      }
    }
    if(!swapped)
      break;
    swapped = false;
  }</code></pre>
<p class="calibre20">Successive elements in the <code class="calibre23">strings</code> array are compared using the <code class="calibre23">&gt;</code> operator. If any element is greater than its successor, the elements are swapped. Elements are interchanged by calling the <code class="calibre23">swap()</code> function for one <code class="calibre23">string</code> object with the second <code class="calibre23">string</code> object as argument. Comparing successive elements and swapping when necessary continues for the entire array. This process is repeated until there is a pass through all the elements where no elements are swapped. The elements are then in ascending sequence. <code class="calibre23">swapped</code> acts as an indicator for whether swapping occurreded on any pass. It is only set to <code class="calibre23">true</code> when two elements are swapped.</p>
<p class="calibre20">The <code class="calibre23">main()</code> function reads up to 100 words into the <code class="calibre23">strings</code> array in a loop:</p>
<pre class="calibre28"><code class="calibre23">  while(nstrings &lt; maxstrings)
  {
    cout &lt;&lt; "Enter a word or press Enter to end: ";
    std::getline(std::cin, strings[nstrings]);
    if(maxwidth &lt; strings[nstrings].length())
      maxwidth = strings[nstrings].length();
    if(strings[nstrings].empty())
      break;
    ++nstrings;
  }</code></pre>
<p class="calibre20"><code class="calibre23">getline()</code>reads characters from <code class="calibre23">cin</code> until <code class="calibre23">'\n'</code> is read. The input is stored in the <code class="calibre23">string</code> object specified by the second argument, <code class="calibre23">strings[nstrings]</code>. Just pressing the Enter key will result in an <code class="calibre23">empty()</code> string, so the loop is terminated when calling <code class="calibre23">empty()</code>for a <code class="calibre23">string</code> object returns <code class="calibre23">true</code>. The <code class="calibre23">maxwidth</code> variable is used to record the length of the longest string entered. This is used in the output process after the input has been sorted.</p>
<p class="calibre20">Calling the <code class="calibre23">sort()</code> function sorts the contents of the <code class="calibre23">strings</code> array in ascending sequence. The result is output in a loop:</p>
<pre class="calibre28"><code class="calibre23">  cout &lt;&lt; endl
       &lt;&lt; "In ascending sequence, the words you entered are:"
       <span {http://www.idpf.org/2007/ops}type="pagebreak" title="418" id="calibre_link-880" class="calibre14"></span>&lt;&lt; endl
       &lt;&lt; std::setiosflags(ios::left);           // Left-justify the output
  for(size_t i {}; i &lt; nstrings; i++)
  {
    if(i % 5 == 0)
      cout &lt;&lt; endl;
    cout &lt;&lt; std::setw(maxwidth+2) &lt;&lt; strings[i];
  }</code></pre>
<p class="calibre20">This outputs each element in a field of <code class="calibre23">maxwidth+2</code> characters. Each word is left-justified in the field because of the call to the <code class="calibre23">setiosflags()</code> manipulator with the argument <code class="calibre23">ios::left</code>. Unlike <code class="calibre23">setw()</code>, the <code class="calibre23">setiosflags()</code> manipulator remains in effect until you reset it.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Searching Strings</h3>
<p class="calibre13">You have four versions of the <code class="calibre23">find()</code> function that search a <code class="calibre23">string</code> object for a given character or substring, and they are described in the following table. All the <code class="calibre23">find()</code> functions are <code class="calibre23">const</code>.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION PROTOTYPE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size_t find(<br class="calibre10" />  char ch,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for <code class="calibre23">ch,</code> starting at index position <code class="calibre23">offset</code>. You can omit the second argument, in which case, the default value is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size_t find(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the null-terminated string <code class="calibre23">pstr</code>, starting at index position <code class="calibre23">offset</code>. You can omit the second argument, in which case, the default value is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size_t find(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the first <code class="calibre23">count</code> characters of the null-terminated string <code class="calibre23">pstr</code>, starting at index position <code class="calibre23">offset</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size_t find(<br class="calibre10" />  const string&amp; str,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the string object <code class="calibre23">str</code>, starting at index position <code class="calibre23">offset</code>. You can omit the second argument, in which case, the default value is 0.</td>
</tr>
</tbody>
</table>
<p class="calibre13">In each case, <code class="calibre23">find()</code>returns the index position where the character or first character of the substring was found, and returns <code class="calibre23">string::npos</code> if the item was not found. This is a constant defined in the <code class="calibre23">string</code> class that represents an illegal position in a <code class="calibre23">string</code> object; it is used generally to signal a search failure.</p>
<p class="calibre13">Here’s a fragment showing some of the ways you might use <code class="calibre23">find()</code>:</p>
<pre class="calibre28"><code class="calibre23">string phrase {"So near and yet so far"};
string str {"So near"};
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="419" id="calibre_link-881" class="calibre14"></span>cout &lt;&lt; phrase.find(str) &lt;&lt; endl;           // Outputs 0
cout &lt;&lt; phrase.find("so far") &lt;&lt; endl;      // Outputs 16
cout &lt;&lt; phrase.find("so near") &lt;&lt; endl;     // Outputs string::npos = 4294967295</code></pre>
<p class="calibre13">The value of <code class="calibre23">string::npos</code> can vary with different compiler implementations, so you should always use <code class="calibre23">string::npos</code> to test for it, not the explicit value.</p>
<p class="calibre13">Here’s another example that scans a string repeatedly, searching for occurrences of a particular substring:</p>
<pre class="calibre28"><code class="calibre23">string str {"Smith, where Jones had had \"had had\", \"had had\" had."
            " \"Had had\" had had the examiners' approval."};
string substr {"had"};
        
cout &lt;&lt; "The string to be searched is:" &lt;&lt; endl &lt;&lt; str &lt;&lt; endl;
size_t offset {};
size_t count {};
size_t increment {substr.length()};
        
while(true)
{
  offset = str.find(substr, offset);
  if(string::npos == offset)
    break;
  offset += increment;
  ++count;
}
cout &lt;&lt; " The string \"" &lt;&lt; substr
     &lt;&lt; "\" was found " &lt;&lt; count &lt;&lt; " times in the string above."
     &lt;&lt; endl;</code></pre>
<p class="calibre13">This searches <code class="calibre23">str</code> to see how many times <code class="calibre23">"had"</code> appears. The search is done in the <code class="calibre23">while</code> loop, where <code class="calibre23">offset</code> records the position found, and is used as the start position for each search. The search starts at index position 0, the start of the string, and each time the substring is found, the starting position for the next search is set to the found position plus the length of the substring. This bypasses the substring that was found. Each time the substring is found, <code class="calibre23">count</code> is incremented. If <code class="calibre23">find()</code> returns <code class="calibre23">string::npos</code>, then the substring was not found and the search ends. Executing this fragment produces the output:</p>
<pre class="calibre28"><code class="calibre23">The string to be searched is:
Smith, where Jones had had "had had", "had had" had. "Had had" had had the
examiners' approval.
The string "had" was found 10 times in the string above.</code></pre>
<p class="calibre13"><code class="calibre23">"Had"</code> is not a match for <code class="calibre23">"had"</code>, so 10 is the correct result.</p>
<p class="calibre13">The <code class="calibre23">find_first_of()</code> and <code class="calibre23">find_last_of()</code> member functions search a <code class="calibre23">string</code> object for any character from a given set. You could search a string to find spaces or punctuation characters, for example, to break a string into individual words. Both functions come in several flavors, as the following table shows. All functions in the table are <code class="calibre23">const</code> and return a value of type <code class="calibre23">size_t</code>.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="420" id="calibre_link-882" class="calibre14"></span><b class="calibre12">FUNCTION PROTOTYPE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_of(<br class="calibre10" />  char ch,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the first occurrence of the character, <code class="calibre23">ch</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the first occurrence of any character in the null-terminated string, <code class="calibre23">pstr</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the first occurrence of any character in the first <code class="calibre23">count</code> characters of the null-terminated string, <code class="calibre23">pstr</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_of(<br class="calibre10" />  const string&amp; str,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches a <code class="calibre23">string</code> object for the first occurrence of any character in the string, <code class="calibre23">str</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_of(<br class="calibre10" />  char ch,<br class="calibre10" />  size_t offset=npos)</code></td>
<td class="calibre32">Searches backward through a <code class="calibre23">string</code> object for the last occurrence of the character, <code class="calibre23">ch</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is <code class="calibre23">npos</code>, which is the end of the string.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset=npos)</code></td>
<td class="calibre32">Searches backward through a <code class="calibre23">string</code> object for the last occurrence of any character in the null-terminated string, <code class="calibre23">pstr</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is <code class="calibre23">npos</code>, which is the end of the string.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Searches backward through a <code class="calibre23">string</code> object for the last occurrence of any of the first <code class="calibre23">count</code> characters in the null-terminated string, <code class="calibre23">pstr</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_of(<br class="calibre10" />  const string&amp; str,<br class="calibre10" />  size_t offset=npos)</code></td>
<td class="calibre32">Searches backward through a <code class="calibre23">string</code> object for the last occurrence of any character in the string, <code class="calibre23">str</code>, starting at position <code class="calibre23">offset</code>, and returns the index position where the character is found as a value of type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is <code class="calibre23">npos</code>, which is the end of the string.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="421" id="calibre_link-883" class="calibre14"></span>All versions of <code class="calibre23">find_first_of()</code> and <code class="calibre23">find_last_of()</code> return <code class="calibre23">string::npos</code> if no matching character is found. With the same string as the previous fragment, you could see what the <code class="calibre23">find_last_of()</code> function does with the same search string, <code class="calibre23">"had"</code>.</p>
<pre class="calibre28"><code class="calibre23">string str {"Smith, where Jones had had \"had had\", \"had had\" had."
            " \"Had had\" had had the examiners' approval."};
string substr {"had"};
        
cout &lt;&lt; "The string to be searched is:" &lt;&lt; endl &lt;&lt; str &lt;&lt; endl;
size_t count {};
size_t offset {string::npos};
while(true)
{
  offset = str.find_last_of(substr, offset);
  if(string::npos == offset)
    break;
  --offset;
  ++count;
}
cout &lt;&lt; " Characters from the string \"" &lt;&lt; substr &lt;&lt; "\" were found "
     &lt;&lt; count &lt;&lt; " times in the string above." &lt;&lt; endl;</code></pre>
<p class="calibre13">The default starting position is <code class="calibre23">string::npos</code>, the end of the string, because you will search the string backward. The output from this fragment is:</p>
<pre class="calibre28"><code class="calibre23">The string to be searched is:
Smith, where Jones had had "had had", "had had" had. "Had had" had had
the examiners' approval.
Characters from the string "had" were found 38 times in the string above.</code></pre>
<p class="calibre13">The result should not be a surprise. You are searching for occurrences of <i class="calibre15">any</i> of the characters in <code class="calibre23">"had"</code> in the string <code class="calibre23">str</code>. There are 32 in the <code class="calibre23">"Had"</code> and <code class="calibre23">"had"</code> words, and 6 in the remaining words. Because you are searching backward, you decrement <code class="calibre23">offset</code> when you find a character.</p>
<p class="calibre13">The last set of search facilities are versions of the <code class="calibre23">find_first_not_of()</code> and <code class="calibre23">find_last_not_of()</code> functions. All of the functions in the following table are <code class="calibre23">const</code> and return a <code class="calibre23">size_t</code> value.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION PROTOTYPE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_not_of(<br class="calibre10" />  char ch,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches for the first occurrence of a character that is not <code class="calibre23">ch</code>, starting at position <code class="calibre23">offset</code>. The function returns the index position where the character is found as type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_not_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches for the first occurrence of a character that is not in <code class="calibre23">pstr</code>, starting at <code class="calibre23">offset</code>, and returns the index where the character is found as type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_not_of(<br class="calibre10" />  const char*  pstr,<br class="calibre10" />  size_t offset,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Searches for the first occurrence of a character that is not in the first <code class="calibre23">count</code> characters of <code class="calibre23">pstr</code>, starting at <code class="calibre23">offset</code>. The function returns the index position where the character is found as type <code class="calibre23">size_t</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_first_not_of(<br class="calibre10" />  const string&amp; str,<br class="calibre10" />  size_t offset=0)</code></td>
<td class="calibre32">Searches for the first occurrence of any character that is not in <code class="calibre23">str</code>, starting at <code class="calibre23">offset</code>. The function returns the index where the character is found as type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is 0.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="422" id="calibre_link-884" class="calibre14"></span><code class="calibre23">find_last_not_of(<br class="calibre10" />  char ch,<br class="calibre10" />  size_t offset=npos)</code></td>
<td class="calibre32">Searches backward for the last occurrence of a character that is not <code class="calibre23">ch</code> starting at <code class="calibre23">offset</code>. The index where the character is found is returned as type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is <code class="calibre23">npos</code>, which is the end of the string.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_not_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset=npos)</code></td>
<td class="calibre32">Searches backward for the last occurrence of any character that is not in <code class="calibre23">pstr</code>, starting at <code class="calibre23">offset</code>. The index where a character is found is returned as type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is <code class="calibre23">npos</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_not_of(<br class="calibre10" />  const char* pstr,<br class="calibre10" />  size_t offset,<br class="calibre10" />  size_t count)</code></td>
<td class="calibre32">Searches backward for the last occurrence of a character that is not in the first <code class="calibre23">count</code> characters in <code class="calibre23">pstr</code> starting at <code class="calibre23">offset</code>. The function returns the index where a character is found as type <code class="calibre23">size_t</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">find_last_not_of(<br class="calibre10" />  const string&amp; str,<br class="calibre10" />  size_t offset=npos)</code></td>
<td class="calibre32">Searches backward for the last occurrence of any character not in <code class="calibre23">str</code> starting at <code class="calibre23">offset</code>. The function returns the index where a character is found as type <code class="calibre23">size_t</code>. If you omit the second argument, the default value of <code class="calibre23">offset</code> is <code class="calibre23">npos</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13">As with previous search functions, <code class="calibre23">string::npos</code> is returned if the search does not find a character. These functions have many uses, typically finding tokens in a string that may be separated by characters of various kinds. For example, you could use these functions to find the words in a block of text that are separated by spaces or punctuation characters. Let’s see that working in an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Sorting Words from Text</h3>
<p class="calibre20">This example reads a block of text, and then extracts the words and outputs them in ascending sequence. I’ll use the somewhat inefficient bubble sort function that you saw in <code class="calibre23">Ex8_14</code> here. In Chapter 10, you will use a library function for sorting that would be much better, but you need to learn about some other stuff before you can use that. The program will also figure out how many times each word occurs and output the count for each word. Such an analysis is called a <i class="calibre15">collocation</i>. Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">// Ex8_16.cpp
// Extracting words from text
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using std::cout;
using std::endl;
using std::string;
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="423" id="calibre_link-885" class="calibre14"></span>// Sort an array of string objects
string* sort(string* strings, size_t count)
{
  bool swapped {false};
  while(true)
  {
    for(size_t i {}; i &lt; count-1; i++)
    {
      if(strings[i] &gt; strings[i+1])
      {
        swapped = true;
        strings[i].swap(strings[i+1]);
      }
    }
    if(!swapped)
      break;
    swapped = false;
  }
  return strings;
}
        
int main()
{
  const size_t maxwords {100};
  string words[maxwords];
  string text;
  string separators {" \".,:;!?()\n"};
  size_t nwords {};
  size_t maxwidth {};
        
  cout &lt;&lt; "Enter some text on as many lines as you wish."
    &lt;&lt; endl &lt;&lt; "Terminate the input with an asterisk:" &lt;&lt; endl;
        
  std::getline(std::cin, text, '*');
        
  size_t start {}, end {}, offset {};   // Record start &amp; end of word &amp; offset
  while(true)
  {
    // Find first character of a word
    start = text.find_first_not_of(separators, offset);  // Find non-separator
    if(string::npos == start)           // If we did not find it, we are done
      break;
    offset = start + 1;                 // Move past character found
        
        
    // Find first separator past end of current word
    end = text.find_first_of(separators,offset);         // Find separator
    if(string::npos == end)             // If it's the end of the string
    {                                   // current word is last in string
      offset = end;                     // We use offset to end loop later
      end = text.length();              // Set end as 1 past last character
    }
    else
      offset = end + 1;                 // Move past character found
        
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="424" id="calibre_link-886" class="calibre14"></span>words[nwords] = text.substr(start, end-start);       // Extract the word
        
    // Keep track of longest word
    if(maxwidth &lt; words[nwords].length())
      maxwidth = words[nwords].length();
    if(++nwords == maxwords)            // Check for array full
    {
      cout &lt;&lt; "Maximum number of words reached." 
           &lt;&lt; " Processing what we have." &lt;&lt; endl;
      break;
    }
        
    if(string::npos == offset)          // If we reached the end of the string
      break;                            // We are done
  }
        
  sort(words, nwords);
        
  cout &lt;&lt; endl &lt;&lt; "In ascending sequence, the words in the text are:" &lt;&lt; endl;
        
  size_t count {1};                             // Count of duplicate words
  char initial {words[0][0]};                   // First word character
 
  // Output words and number of occurrences
  for(size_t i {}; i&lt;nwords; i++)
  {
    if(i &lt; nwords-1 &amp;&amp; words[i] == words[i+1])
    {
      ++count;
      continue;
    }
 
    if (initial != words[i][0])                 
    {                                           // New first character...
      initial = words[i][0];                    // ...so save it...    
      cout &lt;&lt; endl;                             // ...and start a new line
    }
 
    cout &lt;&lt; std::setiosflags(std::ios::left)     // Output word left-justified
         &lt;&lt; std::setw(maxwidth+2) &lt;&lt; words[i];
    cout &lt;&lt; std::resetiosflags(std::ios::right)  // and word count right-justified
         &lt;&lt; std::setw(5) &lt;&lt; count;
    count = 1;
  }
  cout &lt;&lt; endl;
  return 0;
}</code></pre>
<p class="calibre20">Here’s an example of output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter some text on as many lines as you wish.
Terminate the input with an asterisk:
I sometimes think I'd rather crow
And be a rooster than to roost
And be a crow. But I dunno.
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="425" id="calibre_link-887" class="calibre14"></span>A rooster he can roost also,
Which don't seem fair when crows can't crow
Which may help some. Still I dunno.*
 
In ascending sequence, the words in the text are:
A          1    And        2
But        1
I          3    I'd        1
Still      1
Which      2
a          2    also       1
be         2
can        1    can't      1    crow       3    crows      1
don't      1    dunno      2
fair       1
he         1    help       1
may        1
rather     1    roost      2    rooster    2
seem       1    some       1    sometimes  1
than       1    think      1    to         1
when       1</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The input is read from <code class="calibre23">cin</code> using <code class="calibre23">getline()</code> with the termination character as an asterisk. This allows an arbitrary number of lines of input to be entered. Individual words are extracted from the input in the string object <code class="calibre23">text</code> and stored in the <code class="calibre23">words</code> array. This is done in the indefinite <code class="calibre23">while</code> loop.</p>
<p class="calibre20">The first step in extracting a word from <code class="calibre23">text</code> is to find the index position of the first character of the word:</p>
<pre class="calibre28"><code class="calibre23">    start = text.find_first_not_of(separators, offset);  // Find non-separator
    if(string::npos == start)           // If we did not find it, we are done
      break;
    offset = start + 1;                 // Move past character found</code></pre>
<p class="calibre20">The <code class="calibre23">find_first_not_of()</code> function returns the index of the first character that is not one of the characters in <code class="calibre23">separators</code> starting at <code class="calibre23">offset</code>. You could use the <code class="calibre23">find_first_of()</code> function here to search for any of A to Z, a to z, to achieve the same result. When the last word has been extracted, the search will reach the end of the string without finding a character, so you test for this by comparing the value returned with <code class="calibre23">string::npos</code>. If it is the end of the string, all words have been extracted, so you exit the loop. In any other instance, you set <code class="calibre23">offset</code> at one past the character that was found and continue with the next step.</p>
<p class="calibre20">The next search is for any separator character:</p>
<pre class="calibre28"><code class="calibre23">    end = text.find_first_of(separators,offset);         // Find separator
    if(string::npos == end)             // If it's the end of the string
    {                                   // current word is last in string
      offset = end;                     // We use offset to end loop later
      end = text.length();              // Set end as 1 past last character
    }
    else
      offset = end + 1;                 // Move past character found</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="426" id="calibre_link-888" class="calibre14"></span>The search is from position <code class="calibre23">offset</code>, which is one past the first character of the word, so usually you will find the separator that is one past the last character of the word. When it’s the last word in <code class="calibre23">text</code> and there is no separator following the last character of the word, the function returns <code class="calibre23">string::npos</code>, so you deal with this by setting <code class="calibre23">end</code> to one past the last character in the string and setting <code class="calibre23">offset</code> to <code class="calibre23">string::npos. offset</code> is tested later in the loop after the current word has been extracted to determine whether the loop should end.</p>
<p class="calibre20">Extracting a word is easy:</p>
<pre class="calibre28"><code class="calibre23">    words[nwords] = text.substr(start, end-start);       // Extract the word</code></pre>
<p class="calibre20">The <code class="calibre23">substr()</code> function extracts <code class="calibre23">end-start</code> characters from <code class="calibre23">text</code>, starting with the character at <code class="calibre23">start</code>. The length of the word is <code class="calibre23">end-start</code> because <code class="calibre23">start</code> is the first character and <code class="calibre23">end</code> is one past the last character.</p>
<p class="calibre20">The rest of the <code class="calibre23">while</code> loop keeps track of the maximum word length in the way you have seen before, checks for the end-of-string condition, and checks whether the <code class="calibre23">words</code> array is full.</p>
<p class="calibre20">The words are output in a <code class="calibre23">for</code> loop that iterates over all the elements in the <code class="calibre23">words</code> array. Before the loop you define <code class="calibre23">count</code> to record the number of identical words and <code class="calibre23">initial</code> as the first character of the first word. The second index to the <code class="calibre23">words</code> array accesses a character within the <code class="calibre23">string</code> element selected by the first element. You use the latter later in the <code class="calibre23">while</code> loop to output words with the same initial letter on the same line. The <code class="calibre23">if</code> statements deal with counting duplicate words:</p>
<pre class="calibre28"><code class="calibre23">    if(i &lt; nwords-1 &amp;&amp; words[i] == words[i+1])
    {
      ++count;
      continue;
    }</code></pre>
<p class="calibre20">The <code class="calibre23">count</code> variable records the number of duplicate words, so it is always a minimum of 1. <code class="calibre23">count</code> is set to 1 at the end of the loop body when a word and its count are written out.</p>
<p class="calibre20">The second <code class="calibre23">if</code> statement checks if the next word is the same as the current word, and if it is, <code class="calibre23">count</code> is incremented and the rest of the current loop iteration is skipped. This mechanism accumulates the number of times a word is duplicated in <code class="calibre23">count</code>. The loop condition also checks that the index, <code class="calibre23">i</code>, is less than <code class="calibre23">nwords-2</code>, because we don’t want to check the next word when the current word is the last in the array. Thus, we only output a word and its count when the next word is different, or the current word is the last in the array.</p>
<p class="calibre20">After a sequence of duplicate words has been counted, the <code class="calibre23">if</code> statement checks whether the initial letter in the current word is different from that recorded in <code class="calibre23">initial</code>. If it is, <code class="calibre23">initial</code> is updated and a newline is written to the output stream.</p>
<p class="calibre20">The last step in the <code class="calibre23">for</code> loop is to output a word and its count:</p>
<pre class="calibre28"><code class="calibre23">    cout &lt;&lt; std::setiosflags(std::ios::left)       // Output word left-justified
         &lt;&lt; std::setw(maxwidth + 2) &lt;&lt; words[i];
    cout &lt;&lt; std::resetiosflags(std::ios::right)    // and word count right-justified
         &lt;&lt; std::setw(5) &lt;&lt; count;
    count = 1;</code></pre>
<p class="calibre20">A word is left-justified in a field width that is two greater than the longest word. The <code class="calibre23">count</code> is output right-justified in a field width of five.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-308" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="427" id="calibre_link-889" class="calibre18"></span>SUMMARY</h2>
<p class="calibre13">In this chapter, you have learned the basics of how you can define classes and how you create and use class objects. You have also learned about overloading operators to allow the operators to be applied to class objects. A class template is a parameterized specification of a class type that is used by the compiler to create class instances based on the arguments you supply for the template.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Define a class to represent an estimated integer, such as “about 40.” These are integers whose value may be regarded as exact or estimated, so the class needs to have as data members a value and an “estimation” flag. The state of the estimation flag affects arithmetic operations, so that “2 <code class="calibre23">*</code> about 40” is “about 80.” The state of variables should be switchable between “estimated” and “exact.”
<ol class="none">
<li class="calibre6">Provide one or more constructors for such a class. Overload the <code class="calibre23">+</code> operator so that these integers can be used in arithmetic expressions. Do you want the <code class="calibre23">+</code> operator to be a global or a member function? Do you need an assignment operator? Provide a <code class="calibre23">print()</code>function member so that they can be printed out, using a leading “E” to denote that the “estimation” flag is set. Write a program to test the operation of your class, checking especially that the operation of the estimation flag is correct.</li></ol></li>
<li class="calibre6">Implement a simple string class that holds a <code class="calibre23">char*</code> and an integer length as <code class="calibre23">private</code> data members. Provide a constructor that takes an argument of type <code class="calibre23">const char*</code>, and implement the copy constructor, assignment operator, and destructor functions. Verify that your class works. You will find it easiest to use the string functions from the <code class="calibre23">cstring</code> header file.</li>
<li class="calibre6">Modify your class from Exercise 2 to support move semantics. Are there other constructors that would be useful? If so code them up.</li>
<li class="calibre6">(Advanced) Does your class from Exercise 3 correctly deal with cases such as this?
<pre class="calibre28"><code class="calibre23">    string s1;
    ...
    s1 = s1;</code></pre>
<ol class="none">
<li class="calibre6">If not, how should it be modified?</li></ol></li>
<li class="calibre6">(Advanced) Overload the <code class="calibre23">+</code> and <code class="calibre23">+=</code> operators of your class for concatenating strings.</li>
<li class="calibre6">Modify the stack example from Exercise 5 in the previous chapter so that the size of the stack is specified in the constructor and dynamically allocated. What else will you need to add? Test the operation of your new class.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="428" id="calibre_link-890" class="calibre14"></span>Write a program that uses the <code class="calibre23">string</code> class that is declared in the <code class="calibre23">string</code> header to read a text string of arbitrary length from the keyboard. The program should then prompt for entry of one or more words that appear in the input text. All occurrences of the chosen words in the input text, regardless of case, should be replaced, with as many asterisks as there are letters in the word. Only whole words should be replaced, so if the string is <code class="calibre23">"Our friend Wendy is at the end of the road."</code> and the chosen word is <code class="calibre23">"end"</code>, the result should be <code class="calibre23">"Our friend Wendy is at the *** of the road."</code>, not <code class="calibre23">"Our fri*** W***y is at the *** of the road."</code>.</li>
<li class="calibre6">Write a class called <code class="calibre23">CTrace</code> that you can use to show at run time when code blocks have been entered and exited, by producing output like this:
<pre class="calibre28"><code class="calibre23">    function 'f1' entry
    'if' block entry
    'if' block exit
    function 'f1' exit</code></pre></li>
<li class="calibre6">Can you think of a way to automatically control the indentation in the last exercise so that the output looks like this?
<pre class="calibre28"><code class="calibre23">    function 'f1' entry
     'if' block entry
     'if' block exit
    function 'f1' exit</code></pre></li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="429" id="calibre_link-891" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Destructors</b></td>
<td class="calibre32">Objects are destroyed using functions called destructors. It is essential to define a destructor in native C++ classes to destroy objects which contain members that are allocated on the heap, because the default constructor will not do this.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The default copy constructor</b></td>
<td class="calibre32">The compiler will supply a default copy constructor for a native C++ class if you do not define one. The default copy constructor will not deal correctly with objects of classes that have data members allocated on the free store.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Defining a copy constructor</b></td>
<td class="calibre32">When you define your own copy constructor in a native C++ class, you must use a reference parameter.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Operator overloading</b></td>
<td class="calibre32">Most basic operators can be overloaded to provide actions specific to objects of a class. You should only implement operator functions for your classes that are consistent with the normal interpretation of the basic operators.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The assignment operator in a class</b></td>
<td class="calibre32">If you do not define an assignment operator for a class, the compiler will supply a default version. As with the copy constructor, the default assignment operator will not work correctly with classes that have data members allocated on the free store.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Classes that allocate memory on the heap</b></td>
<td class="calibre32">It is essential that you provide a destructor, a copy constructor, and an assignment operator for classes that have members allocated by <code class="calibre23">new</code>. It is recommended that you add a move constructor and move assignment operator too.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">string</code> class</b></td>
<td class="calibre32">The <code class="calibre23">string</code> class in the standard library provides a powerful and superior way to process strings in your programs.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Class templates</b></td>
<td class="calibre32">A class template is a pattern that you can use to create classes with the same structure, but which support different data types.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Class template parameters</b></td>
<td class="calibre32">You can define a class template that has multiple parameters, including parameters that can assume constant values rather than types.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Template specialization</b></td>
<td class="calibre32">You can redefine a general template to provide code unique to a particular template type argument or set of arguments. This enables you to accommodate situations where the general form of the template will not work with a given type or set of types. A partial specialization is a redefinition of a template for a set of types such as pointers, or with one or more template parameters unbound.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="430" id="calibre_link-892" class="calibre14"></span><b class="calibre12">Move semantics</b></td>
<td class="calibre32">You can use the <code class="calibre23">std::move()</code> function that is declared in the <code class="calibre23">utility</code> header to convert an lvalue or an rvalue to an rvalue without copying. This allows you to move rather than copy objects when it is appropriate to do so and avoid the unnecessary copying overhead.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Perfect forwarding</b></td>
<td class="calibre32">Perfect forwarding is enabled by the <code class="calibre23">std::forward&lt;T&gt;()</code> template function that is declared in the <code class="calibre23">utility</code> header. This allows you to avoid unnecessary copying in a template function that has an rvalue reference argument when the argument is passed to another function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Organizing your code</b></td>
<td class="calibre32">You should put definitions for your programs in <code class="calibre23">.h</code> files, and executable code &mdash; function definitions &mdash; in <code class="calibre23">.cpp</code> files. You can then incorporate <code class="calibre23">.h</code> files into your <code class="calibre23">.cpp</code> files by using <code class="calibre23">#include</code> directives.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-190">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2322" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="431" id="calibre_link-893" class="calibre9"></span><span class="chapternumber">Chapter 9</span><br class="calibre10" /><span class="chapternumber">Class Inheritance and Virtual Functions</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How inheritance fits into object-oriented programming</li>
<li class="calibre6">How you define a new class in terms of an existing class</li>
<li class="calibre6">How you use the <code class="calibre23">protected</code> keyword</li>
<li class="calibre6">How a class can be a friend to another class</li>
<li class="calibre6">How to use virtual functions</li>
<li class="calibre6">What pure virtual functions are</li>
<li class="calibre6">What an abstract class is</li>
<li class="calibre6">When you should use a virtual destructor</li>
<li class="calibre6">How to define a conversion operator in a class</li>
<li class="calibre6">What a nested class is</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 9 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-309" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="432" id="calibre_link-894" class="calibre18"></span>OBJECT-ORIENTED PROGRAMMING BASICS</h2>
<p class="calibre13">As you have seen, a class is a data type that you define to suit your own application requirements. Classes define the objects to which your program relates. You program the solution to a problem in terms of the objects that are specific to the problem, using operations that work directly with those objects. You can define a class to represent something abstract, such as a complex number, which is a mathematical concept, or a truck, which is decidedly physical (especially if you run into one on the highway). So, as well as being a data type, a class can also define a set of real-world objects of a particular kind, at least to the degree necessary to solve a given problem.</p>
<p class="calibre13">You can think of a class as defining the characteristics of a particular group of things that are identified by a common set of parameters or properties and share operations that may be performed on or between them. The operations for objects of a given class type are defined by the <i class="calibre15">class interface</i>, which corresponds to the <code class="calibre23">public</code> function members of the class. The <code class="calibre23">CBox</code> class in the previous chapter is a good example &mdash; it defined a box in terms of its dimensions plus a set of public functions that you could apply to <code class="calibre23">CBox</code> objects to solve a problem.</p>
<p class="calibre13">Of course, there are many different kinds of boxes in the real world: there are cartons, coffins, candy boxes, and cereal boxes, to name but a few, and you will certainly be able to come up with many others. You can differentiate boxes by the kinds of things they hold, the materials from which they are made, and in a multitude of other ways; but even though there are many different kinds of boxes, they share some common characteristics &mdash; the essence of <i class="calibre15">boxiness</i>, perhaps. Therefore, you can visualize all kinds of boxes as being related to one another because, even though they have many differentiating features, they share some fundamental characteristics. You could define a general kind of box as having the generic characteristics of all boxes &mdash; perhaps just a length, a width, and a height. You could then add additional characteristics to the basic box type to differentiate a particular kind of box from the rest. You may also find that there are things you can do with one specific type of box that you can’t do with others.</p>
<p class="calibre13">It’s also possible that some objects may be the result of combining a particular kind of box with some other type of object: a box of candy or a crate of beer, for example. To accommodate this, you could define one kind of box as a generic box with basic “boxiness” characteristics and then specify another sort of box as a further specialization of that. <a id="calibre_link-192" href="#calibre_link-191" class="calibre3">Figure 9-1</a> illustrates an example of the kinds of relationships you might define between different sorts of boxes.</p>
<figure class="calibre16">
<img class="center" src="images/000046.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-191" href="#calibre_link-192" class="calibre3">FIGURE 9-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The boxes become more specialized as you move down the diagram, and the arrows run from a given box type to the one on which it is based. <a href="#calibre_link-191" class="calibre3">Figure 9-1</a> defines three kinds of boxes based on the generic type, <code class="calibre23">CBox</code>. It also defines beer crates as a refinement of crates designed to hold bottles.</p>
<p class="calibre13">Thus, a good way to approximate the real world relatively well is to define classes that are interrelated. A candy box can be considered to be a box with all the characteristics of a basic box, plus a few characteristics of its own. This precisely illustrates the relationship between classes when one class is defined based on another. A more specialized class has all the characteristics of the class on which it is based, plus a few characteristics of its own that identify what makes it special. Let’s look at how this works in practice.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-310" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="433" id="calibre_link-895" class="calibre18"></span>INHERITANCE IN CLASSES</h2>
<p class="calibre13">When you define one class based on an existing class, the new class is called a <i class="calibre15">derived class</i>. A derived class automatically contains all the data members of the class that you used to define it and, with some restrictions, the function members too. The class <i class="calibre15">inherits</i> the members of the class on which it is based.</p>
<p class="calibre13">The only members of a base class that are not inherited in a derived class are the destructor, the constructors, and any member functions overloading the assignment operator. All other members are inherited by a derived class. Of course, the reason for certain base members not being inherited is that a derived class always has its own constructors and destructor. If the base class has an assignment operator, the derived class provides its own version. When I say these functions are not inherited, I mean that they don’t exist as members of a derived class object. However, they still exist for the base class part of an object, as you will see.</p>
<section class="toclist">
<h3 class="calibre21">What Is a Base Class?</h3>
<p class="calibre13">A <i class="calibre15">base class</i> is any class that you use as a basis for defining another class. For example, if you define a class, <code class="calibre23">B</code>, directly in terms of a class, <code class="calibre23">A, A</code> is said to be a <i class="calibre15">direct base class</i> of <code class="calibre23">B</code>. In <a href="#calibre_link-191" class="calibre3">Figure 9-1</a>, the <code class="calibre23">CCrate</code> class is a direct base class of <code class="calibre23">CBeerCrate</code>. When a class such as <code class="calibre23">CBeerCrate</code> is defined in terms of another class, <code class="calibre23">CCrate, CBeerCrate</code> is said to be derived from <code class="calibre23">CCrate</code>. Because <code class="calibre23">CCrate</code> is itself defined in terms of the class <code class="calibre23">CBox, CBox</code> is said to be an <i class="calibre15">indirect base class</i> of <code class="calibre23">CBeerCrate</code>. You’ll see how this is expressed in the class definition in a moment. <a id="calibre_link-194" href="#calibre_link-193" class="calibre3">Figure 9-2</a> illustrates the way in which base class members are inherited in a derived class.</p>
<figure class="calibre16">
<img class="center" src="images/000073.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-193" href="#calibre_link-194" class="calibre3">FIGURE 9-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Just because member functions are inherited doesn’t mean that you won’t want to replace them by new versions in the derived class, and, of course, you can do that when necessary.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="434" id="calibre_link-896" class="calibre24"></span>Deriving Classes from a Base Class</h3>
<p class="calibre13">We can define a simple <code class="calibre23">CBox</code> class with <code class="calibre23">public</code> data members:</p>
<pre class="calibre28"><code class="calibre23">// Header file Box.h in project Ex9_01
#pragma once
        
class CBox
{
public:
  double m_Length;
  double m_Width;
  double m_Height;
      
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                         m_Length {lv}, m_Width {wv}, m_Height {hv} {}
};</code></pre>
<p class="calibre13">Create an empty Win32 console project with the name <code class="calibre23">Ex9_01</code> and save this code in a new header file in the project with the name <code class="calibre23">Box.h</code>. The <code class="calibre23">#pragma once</code> directive ensures the definition of <code class="calibre23">CBox</code> appears only once in a build. There’s a constructor in the class so that you can initialize objects when you create them. Suppose you need another class, <code class="calibre23">CCandyBox</code>, that defines objects that have the same characteristics as <code class="calibre23">CBox</code> objects but also have another data member &mdash; a pointer to a string that identifies the contents of the box. I’ll use a pointer here to demonstrate aspects of constructors and destructors in derived classes. In real-world code you should use <code class="calibre23">std::string</code> to store strings.</p>
<p class="calibre13">You can define <code class="calibre23">CCandyBox</code> as a derived class with <code class="calibre23">CBox</code> as the base class:</p>
<pre class="calibre28"><code class="calibre23">// Header file CandyBox.h in project Ex9_01
#pragma once
#include &lt;cstring&gt;                     // For strlen() and strcpy_s()
#include "Box.h"
 
class CCandyBox : CBox
{
public:
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="435" id="calibre_link-897" class="calibre14"></span>char* m_Contents;
        
  explicit CCandyBox(const char* str = "Candy")               // Constructor
  {
    size_t length {strlen(str) + 1};
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  }
 
  CCandyBox(const CCandyBox&amp; box) = delete;
  CCandyBox&amp; operator=(const CCandyBox&amp; box) = delete;
        
  ~CCandyBox()                                                // Destructor
  { delete[] m_Contents; } 
};</code></pre>
<p class="calibre13">Add this header file to the project <code class="calibre23">Ex9_01</code>. You need the <code class="calibre23">#include</code> directive for <code class="calibre23">Box.h</code> because you refer to the <code class="calibre23">CBox</code> class in the code. If you were to leave this directive out, <code class="calibre23">CBox</code> would be unknown to the compiler, so the code would not compile. The base class name, <code class="calibre23">CBox</code>, appears after the name of the derived class, <code class="calibre23">CCandyBox</code>, and is separated from it by a colon. In all other respects, it looks like a normal class definition. The new member, <code class="calibre23">m_Contents</code> is a pointer to a string so you need a constructor to initialize it and a destructor to release the memory for it. You also need an assignment operator to prevent shallow assignments, and a copy constructor; or if you don’t want them, define them as <code class="calibre23">=delete</code>. There’s a default value for the string describing the contents of a <code class="calibre23">CCandyBox</code> object in the constructor. Objects of type <code class="calibre23">CCandyBox</code> contain all the members of the base class, <code class="calibre23">CBox</code>, plus the additional data member, <code class="calibre23">m_Contents</code>.</p>
<p class="calibre13">Note the use of the <code class="calibre23">strcpy_s()</code> function that you first saw in Chapter 6. Here, there are three arguments &mdash; the destination for the copy operation, the length of the destination buffer, and the source. If both arrays were static &mdash; that is, not allocated on the heap &mdash; you could omit the second argument and just supply the destination and source pointers. This is possible because the <code class="calibre23">strcpy_s()</code> function is also available as a template function that can infer the length of the destination string buffer automatically. You can therefore call the function with just the destination and source strings as arguments when you are working with static destination string buffers.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Derived Class</h3>
<p class="calibre20">Now, you’ll see how the derived class works in an example. Add the following code to the <code class="calibre23">Ex9_01</code> project as the source file <code class="calibre23">Ex9_01.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">// Ex9_01.cpp
// Using a derived class
#include &lt;iostream&gt;                               // For stream I/O
#include "CandyBox.h"                             // For CBox and CCandyBox
        
int main()
{
  CBox myBox {4.0, 3.0, 2.0};                     // Create CBox object
  CCandyBox myCandyBox;
  CCandyBox myMintBox {"Wafer Thin Mints"};       // Create CCandyBox object
        
  std::cout &lt;&lt; "myBox occupies " &lt;&lt; sizeof myBox  // Show how much memory
            <span {http://www.idpf.org/2007/ops}type="pagebreak" title="436" id="calibre_link-898" class="calibre14"></span>&lt;&lt; " bytes" &lt;&lt; std::endl              // the objects require
            &lt;&lt; "myCandyBox occupies " &lt;&lt; sizeof myCandyBox
            &lt;&lt; " bytes" &lt;&lt; std::endl
            &lt;&lt; "myMintBox occupies " &lt;&lt; sizeof myMintBox
            &lt;&lt; " bytes" &lt;&lt; std::endl;
        
  std::cout &lt;&lt; "myBox length is " &lt;&lt; myBox.m_Length &lt;&lt; std::endl;
        
  myBox.m_Length = 10.0;
        
  // myCandyBox.m_Length = 10.0;       // uncomment this for an error
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You have an <code class="calibre23">#include</code> directive for the <code class="calibre23">CandyBox.h</code> header here, and because you know that contains an <code class="calibre23">#include</code> directive for <code class="calibre23">Box.h</code>, you don’t need to add a directive to include <code class="calibre23">Box.h</code>. You could put an <code class="calibre23">#include</code> directive for <code class="calibre23">Box.h</code> in this file, in which case, the <code class="calibre23">#pragma once</code> directive in <code class="calibre23">Box.h</code> would prevent its inclusion more than once. This is important because each class can only be defined once in a program; two definitions for a class would be an error.</p>
<p class="calibre20">After defining a <code class="calibre23">CBox</code> object and two <code class="calibre23">CCandyBox</code> objects, you output the number of bytes that each object occupies. Let’s look at the output:</p>
<pre class="calibre28"><code class="calibre23">myBox occupies 24 bytes
myCandyBox occupies 32 bytes
myMintBox occupies 32 bytes
myBox length is 4</code></pre>
<p class="calibre20">The first line is what you would expect from the discussion in the previous chapter. A <code class="calibre23">CBox</code> object has three data members of type <code class="calibre23">double</code>, each of which is 8 bytes, making 24 bytes in all. Both <code class="calibre23">CCandyBox</code> objects are the same size &mdash; 32 bytes. The length of the string doesn’t affect the size of an object because the memory to hold the string is allocated in the free store. The 32 bytes are made up of 24 bytes for the three <code class="calibre23">double</code> members inherited from the base class <code class="calibre23">CBox</code>, plus 4 bytes for the pointer, <code class="calibre23">m_Contents</code>, which makes 28 bytes. So where did the other 4 bytes come from? This is due to the compiler aligning members at addresses that are multiples of 8 bytes. You should be able to demonstrate this by adding an extra member of type <code class="calibre23">int</code>, say, to the class <code class="calibre23">CCandyBox</code>. You will find that the size of a class object is still 32 bytes.</p>
<p class="calibre20">You also output the value of the <code class="calibre23">m_Length</code> member of the <code class="calibre23">CBox</code> object, <code class="calibre23">myBox</code>. Even though you have no difficulty accessing this member of the <code class="calibre23">CBox</code> object, if you uncomment the following statement in the function <code class="calibre23">main()</code>,</p>
<pre class="calibre28"><code class="calibre23">// myCandyBox.m_Length = 10.0;      // uncomment this for an error</code></pre>
<p class="calibre20">the program no longer compiles. The compiler generates the following message:</p>
<pre class="calibre28"><code class="calibre23">error C2247: 'CBox::m_Length' not accessible because 'CCandyBox'
uses 'private' to inherit from 'CBox'</code></pre>
<p class="calibre20">It says quite clearly that the <code class="calibre23">m_Length</code> member from the base class is not accessible because <code class="calibre23">m_Length</code> has become <code class="calibre23">private</code> in the derived class. This is because there is a default access specifier of <code class="calibre23">private</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="437" id="calibre_link-899" class="calibre14"></span>for a base class when you define a derived class &mdash; it’s as if the first line of the derived class definition had been:</p>
<pre class="calibre28"><code class="calibre23">class CCandyBox : private CBox</code></pre>
<p class="calibre20">There always has to be an access specification for a base class that determines the status of the inherited members in the derived class. If you omit the access specification for a base class, the compiler assumes that it’s <code class="calibre23">private</code>. If you change the definition of the <code class="calibre23">CCandyBox</code> class in <code class="calibre23">CandyBox.h</code> to the following,</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">class CCandyBox : public CBox</b>
{
public:
  char* m_Contents;
      
  explicit CCandyBox(const char* str = "Candy")               // Constructor
  {
    size_t length {strlen(str) + 1};
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  }
 
  CCandyBox(const CCandyBox&amp; box) = delete;
  CCandyBox&amp; operator=(const CCandyBox&amp; box) = delete;
      
  ~CCandyBox()                                                // Destructor
  { delete[] m_Contents; } 
};</code></pre>
<p class="calibre20">the <code class="calibre23">m_Length</code> member is inherited in the derived class as <code class="calibre23">public</code>, and is accessible in the function <code class="calibre23">main()</code>. With the access specifier <code class="calibre23">public</code> for the base class, all the inherited members originally specified as <code class="calibre23">public</code> in the base class have the same access level in the derived class.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-311" class="calibre3"></a>ACCESS CONTROL UNDER INHERITANCE</h2>
<p class="calibre13">The access to inherited members in a derived class needs to be looked at more closely. Let’s consider the status of the <code class="calibre23">private</code> members of a base class in a derived class.</p>
<p class="calibre13">There was a good reason to choose the version of the class <code class="calibre23">CBox</code> with <code class="calibre23">public</code> data members in the previous example, rather than the more secure version with <code class="calibre23">private</code> data members. Although <code class="calibre23">private</code> data members of a base class are also members of a derived class, they remain <code class="calibre23">private</code> to the base class in the derived class, so function members defined in the derived class cannot access them. They are only accessible in the derived class through function members of the base class that are not <code class="calibre23">private</code>. You can demonstrate this very easily by changing all the <code class="calibre23">CBox</code> class data members to <code class="calibre23">private</code> and putting a <code class="calibre23">volume()</code> function in the derived class, <code class="calibre23">CCandyBox</code>:</p>
<pre class="calibre28"><code class="calibre23">// Version of the classes that will not compile
#include &lt;cstring&gt;                     // For strlen() and strcpy_s()
 
class CBox
{
public:
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                          <span {http://www.idpf.org/2007/ops}type="pagebreak" title="438" id="calibre_link-900" class="calibre14"></span>m_Length {lv}, m_Width {wv}, m_Height {hv} {}
     
private:
  double m_Length;
  double m_Width;
  double m_Height;
};
        
class CCandyBox : public CBox
{
public:
  char* m_Contents;
      
  // Function to calculate the volume of a CCandyBox object
  double volume() const              // Error - members not accessible
  { return m_Length*m_Width*m_Height; }
      
  // Rest of the code as before...
};</code></pre>
<p class="calibre13">A program using these classes does not compile. The <code class="calibre23">volume()</code>function in <code class="calibre23">CCandyBox</code> attempts to access the <code class="calibre23">private</code> members of the base class, which is not legal, so the compiler will flag each instance with error C2248.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Accessing Private Members of the Base Class</h3>
<p class="calibre20">However, it is legal to call a public function in the base class. If you move the definition of <code class="calibre23">volume()</code> from <code class="calibre23">CCandyBox</code> to the <code class="calibre23">public</code> section of the base class, <code class="calibre23">CBox</code>, not only will the program compile, but you can call the function to obtain the volume of a <code class="calibre23">CCandyBox</code> object. Create a new Win32 project, <code class="calibre23">Ex9_02</code>, with the <code class="calibre23">Box.h</code> contents as the following:</p>
<pre class="calibre28"><code class="calibre23">// Box.h in Ex9_02
#pragma once
        
class CBox
{
public:
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                           m_Length {lv}, m_Width {wv}, m_Height{hv} {}
      
  //Function to calculate the volume of a CBox object
  double volume() const
  { return m_Length*m_Width*m_Height; }
 
private:
  double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre20">The <code class="calibre23">CandyBox.h</code> header in the project contains:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Header file CandyBox.h in project Ex9_02</b>
#pragma once
#include "Box.h"
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="439" id="calibre_link-901" class="calibre14"></span>#include &lt;cstring&gt;                     // For strlen() and strcpy_s()

<b class="calibre12">class CCandyBox : public CBox</b>
{
public:
  char* m_Contents;
 
  explicit CCandyBox(const char* str = "Candy")               // Constructor
  {
    size_t length {strlen(str) + 1};
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  }
 
  CCandyBox(const CCandyBox&amp; box) = delete;
  CCandyBox&amp; operator=(const CCandyBox&amp; box) = delete;
 
  ~CCandyBox()                                                // Destructor
  { delete[] m_Contents; }
};</code></pre>
<p class="calibre20">The <code class="calibre23">Ex9_02.cpp</code> file in the project contains:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_02.cpp</b>
<b class="calibre12">// Using a function inherited from a base class</b>
#include &lt;iostream&gt;                    // For stream I/O
#include "CandyBox.h"                  // For CBox and CCandyBox
 
int main()
{
  CBox myBox {4.0, 3.0, 2.0};                    // Create CBox object
  CCandyBox myCandyBox;
  CCandyBox myMintBox {"Wafer Thin Mints"};      // Create CCandyBox object
  
  std::cout &lt;&lt; "myBox occupies " &lt;&lt; sizeof  myBox     // Show how much memory
            &lt;&lt; " bytes" &lt;&lt; std::endl                  // the objects require
            &lt;&lt; "myCandyBox occupies " &lt;&lt; sizeof myCandyBox
            &lt;&lt; " bytes" &lt;&lt; std::endl
            &lt;&lt; "myMintBox occupies " &lt;&lt; sizeof myMintBox    
            &lt;&lt; " bytes" &lt;&lt; std::endl;
  <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">myMintBox volume is</b> " <b class="calibre12">&lt;&lt; myMintBox.volume()  // Get volume of a</b> 
            <b class="calibre12">&lt;&lt; std::endl;                                    // CCandyBox object</b>  
  return 0;
}</code></pre>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">myBox occupies 24 bytes
myCandyBox occupies 32 bytes
myMintBox occupies 32 bytes
myMintBox volume is 1</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The last line is the interesting additional output. It shows the value produced by the <code class="calibre23">volume()</code> function, which is now in the <code class="calibre23">public</code> section of the base class. Within the derived class, it operates on the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="440" id="calibre_link-902" class="calibre14"></span>members of the derived class that are inherited from the base. It is a full member of the derived class, so it can be used freely with objects of the derived class.</p>
<p class="calibre20">The volume of the derived class object is <code class="calibre23">1</code> because, in creating the <code class="calibre23">CCandyBox</code> object, the <code class="calibre23">CBox()</code> default constructor was called first to create the base class part of the object, and this sets default <code class="calibre23">CBox</code> dimensions to <code class="calibre23">1</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21">Constructor Operation in a Derived Class</h3>
<p class="calibre13">Although I said that base class constructors are not inherited in a derived class, they still exist in the base class and are used to create the base part of a derived class object. This is because creating the base class part of a derived class object is really the business of a base class constructor, not the derived class constructor. After all, you have seen that private members of a base class are inaccessible in a derived class object, even though they are inherited, so responsibility for these has to lie with the base class constructors.</p>
<p class="calibre13">The default base class constructor was called by default in the last example to create the base part of a derived class object, but this doesn’t have to be the case. You can call a particular base class constructor from a derived class constructor. This enables you to initialize the base class data members with a constructor other than the default, or, indeed, to choose to call a particular base class constructor, depending on the data supplied to the derived class constructor.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Calling Constructors</h3>
<p class="calibre20">You can see this in action through a modified version of the previous example. To make the class usable, you really need to provide a constructor for the derived class that allows you to specify the dimensions of the object. You can add an additional constructor in the derived class to do this, and call the base class constructor explicitly to set the values of the data members that are inherited from the base class.</p>
<p class="calibre20">In the <code class="calibre23">Ex9_03</code> project, <code class="calibre23">Box.h</code> contains:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Box.h in Ex9_03</b>
#pragma once
<b class="calibre12">#include &lt;iostream&gt;</b>
class CBox
{
public:
  // Base class constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                       m_Length {lv}, m_Width {wv}, m_Height {hv}
  <b class="calibre12">{  std::cout &lt;&lt;</b> "<b class="calibre12">CBox constructor called" &lt;&lt; std::endl;  }</b>
 
  //Function to calculate the volume of a CBox object
  double volume() const
  { return m_Length*m_Width*m_Height; }
 
private:
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="441" id="calibre_link-903" class="calibre14"></span>double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre20">The <code class="calibre23">CandyBox.h</code> header file should contain:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// CandyBox.h in Ex9_03</b>
#pragma once
#include &lt;cstring&gt;                     // For strlen() and strcpy()
<b class="calibre12">#include &lt;iostream&gt;</b>
#include "Box.h"
 
class CCandyBox : public CBox
{
public:
  char* m_Contents;

  <b class="calibre12">// Constructor to set dimensions and contents</b>
  <b class="calibre12">// with explicit call of CBox constructor</b>
  <b class="calibre12">CCandyBox(double lv, double wv, double hv, const char* str =</b> "<b class="calibre12">Candy")</b>
                                                      <b class="calibre12">: CBox {lv, wv, hv}</b>
  <b class="calibre12">{</b>
    <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">CCandyBox constructor2 called" &lt;&lt; std::endl;</b>
    size_t length {strlen(str) + 1};
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  <b class="calibre12">}</b>

  <b class="calibre12">// Constructor to set contents</b>
  <b class="calibre12">// calls default CBox constructor automatically</b>
  <b class="calibre12">explicit CCandyBox(const char* str =</b> "<b class="calibre12">Candy")</b>
  <b class="calibre12">{</b>
    <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">CCandyBox constructor1 called" &lt;&lt; std::endl;</b>
    size_t length {strlen(str) + 1};
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  <b class="calibre12">}</b>
 
  CCandyBox(const CCandyBox&amp; box) = delete;
  CCandyBox&amp; operator=(const CCandyBox&amp; box) = delete;
 
  ~CCandyBox()                                 // Destructor
  { delete[] m_Contents; }
};</code></pre>
<p class="calibre20">The <code class="calibre23">#include</code> directive for the <code class="calibre23">iostream</code> header is not strictly necessary here because <code class="calibre23">Box.h</code> contains the same code, but it does no harm to put them in. On the contrary, putting these statements in here also means that if you were to remove this code from <code class="calibre23">Box.h</code> because it was no longer required there, <code class="calibre23">CandyBox.h</code> would still compile.</p>
<p class="calibre20">The contents of <code class="calibre23">Ex9_03.cpp</code> are:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_03.cpp</b>
<b class="calibre12">// Calling a base constructor from a derived class constructor</b>
#include &lt;iostream&gt;                    // For stream I/O
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="442" id="calibre_link-904" class="calibre14"></span>#include "CandyBox.h"                  // For CBox and CCandyBox
 
int main()
{
  CBox myBox {4.0, 3.0, 2.0};
  CCandyBox myCandyBox;
  <b class="calibre12">CCandyBox myMintBox {1.0, 2.0, 3.0,</b> "<b class="calibre12">Wafer Thin Mints"};</b>
  std::cout &lt;&lt; "myBox occupies " &lt;&lt; sizeof  myBox     // Show how much memory
            &lt;&lt; " bytes" &lt;&lt; std::endl                  // the objects require
            &lt;&lt; "myCandyBox occupies " &lt;&lt; sizeof myCandyBox
            &lt;&lt; " bytes" &lt;&lt; std::endl
            &lt;&lt; "myMintBox occupies " &lt;&lt; sizeof myMintBox
            &lt;&lt; " bytes" &lt;&lt; std::endl;
 
  std::cout &lt;&lt; "myMintBox volume is "                 // Get volume of a
            &lt;&lt; myMintBox.volume() &lt;&lt; std::endl;       // CCandyBox object
 
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">As well as adding a constructor to the derived class, you have added an output statement in each constructor so you know when either gets called. The explicit <code class="calibre23">CBox</code> constructor call appears after a colon in the function header of the derived class constructor. The notation is exactly the same as what you have been using for initializing members in a constructor:</p>
<pre class="calibre28"><code class="calibre23">// Calling the base class constructor
CCandyBox(double lv, double wv, double hv, const char* str= "Candy"):
                                                         CBox {lv, wv, hv}
{
...
}</code></pre>
<p class="calibre20">The notation for calling the base class constructor is perfectly consistent with initializing other members in the initializer list, because you are essentially initializing the <code class="calibre23">CBox</code> sub-object of a derived class object. Earlier, you were explicitly calling the default constructor for the <code class="calibre23">double</code> members <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code> in the initialization list. Here, you are calling the constructor for <code class="calibre23">CBox</code>. This causes the specific <code class="calibre23">CBox</code> constructor you have chosen to be called before the <code class="calibre23">CCandyBox</code> constructor code is executed.</p>
<p class="calibre20">If you build and run this example, it produces the following output:</p>
<pre class="calibre28"><code class="calibre23">CBox constructor called
CBox constructor called
CCandyBox constructor1 called
CBox constructor called
CCandyBox constructor2 called
myBox occupies 24 bytes
myCandyBox occupies 32 bytes
myMintBox occupies 32 bytes
myMintBox volume is 6</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="443" id="calibre_link-905" class="calibre14"></span>The constructor calls are explained in the following table:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">OUTPUT</b></th>
<th class="calibre32"><b class="calibre12">OBJECT BEING CONSTRUCTED</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CBox</code> constructor called</td>
<td class="calibre32"><code class="calibre23">myBox</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CBox</code> constructor called</td>
<td class="calibre32"><code class="calibre23">myCandyBox</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CCandyBox</code> constructor1 called</td>
<td class="calibre32"><code class="calibre23">myCandyBox</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CBox</code> constructor called</td>
<td class="calibre32"><code class="calibre23">myMintBox</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CCandyBox</code> constructor2 called</td>
<td class="calibre32"><code class="calibre23">myMintBox</code></td>
</tr>
</tbody>
</table>
<p class="calibre20">The first line is due to the <code class="calibre23">CBox</code> constructor call, originating from the definition of the <code class="calibre23">CBox</code> object, <code class="calibre23">myBox</code>. The second line arises from the automatic call of the base class constructor caused by the definition of the <code class="calibre23">CCandyBox</code> object, <code class="calibre23">myCandyBox</code>. Notice how the base class constructor is always called before the derived class constructor. The base class is the foundation on which the derived class is built, so the base class must be created first.</p>
<p class="calibre20">The next line is due to your version of the default derived class constructor being called for the <code class="calibre23">myCandyBox</code> object. This constructor is invoked because the object is not initialized. The fourth line arises from the explicit call of the <code class="calibre23">CBox</code> class constructor in our new constructor for <code class="calibre23">CCandyBox</code> objects. The arguments for the dimensions of the <code class="calibre23">CCandyBox</code> object are passed to the base class constructor. Next comes the output from the new derived class constructor itself, so constructors are again called, first for the base class, then for the derived class.</p>
<p class="calibre20">It should be clear from what you have seen that when a derived class constructor executes, a base class constructor is always called to create the base part of the derived class object. If you don’t specify the base class constructor, the compiler arranges for the default base constructor to be called. The last line in the table shows that the initialization of the base part of the <code class="calibre23">myMintBox</code> object is working as it should be, with the <code class="calibre23">private</code> members initialized by the <code class="calibre23">CBox</code> constructor.</p>
<p class="calibre20">Having the <code class="calibre23">private</code> members of a base class that are only accessible to member functions of the base class isn’t always convenient. There will be many instances where you want to have <code class="calibre23">private</code> members of a base class that can be accessed from within the derived class. As you surely have anticipated by now, C++ provides a way to do this.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Declaring Protected Class Members</h3>
<p class="calibre13">In addition to the <code class="calibre23">public</code> and <code class="calibre23">private</code> access specifiers for members of a class, you can also declare members as <code class="calibre23">protected</code>. The <code class="calibre23">protected</code> keyword has the same effect as the <code class="calibre23">private</code> keyword within a class: members that are <code class="calibre23">protected</code> can only be accessed by member functions of the class, and by <code class="calibre23">friend</code> functions of the class (also by member functions of a <code class="calibre23">friend</code> class &mdash; you will learn about <code class="calibre23">friend</code> classes later in this chapter). Base class members that are <code class="calibre23">protected</code> can be <span {http://www.idpf.org/2007/ops}type="pagebreak" title="444" id="calibre_link-906" class="calibre14"></span>accessed from any derived class function. Using the <code class="calibre23">protected</code> keyword, you could redefine <code class="calibre23">CBox</code> as follows:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Box.h in Ex9_04</b>
#pragma once
#include &lt;iostream&gt;
        
class CBox
{
public:
  // Base class constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                       m_Length {lv}, m_Width {wv}, m_Height {hv}
  {  std::cout &lt;&lt; "CBox constructor called" &lt;&lt; std::endl;  }
      
  <b class="calibre12">// CBox destructor - just to track calls</b>
  <b class="calibre12">~CBox()</b>
  <b class="calibre12">{ std::cout &lt;&lt;</b> "<b class="calibre12">CBox destructor called" &lt;&lt; std::endl; }</b>

<b class="calibre12">protected:</b>
  double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre13">The data members are still effectively <code class="calibre23">private</code>, in that they can’t be accessed by ordinary global functions, but they can still be accessed by member functions of a derived class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Protected Members</h3>
<p class="calibre20">You can demonstrate the use of <code class="calibre23">protected</code> data members by using this version of <code class="calibre23">CBox</code> to derive a new version of the <code class="calibre23">CCandyBox</code> class that accesses the members of the base class through its own member function, <code class="calibre23">volume()</code>:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// CandyBox.h in Ex9_04</b>
#pragma once
#include "Box.h"
#include &lt;cstring&gt;                     // For strlen() and strcpy()
#include &lt;iostream&gt;
 
class CCandyBox : public CBox
{
public:
  char* m_Contents;

  <b class="calibre12">// Derived class function to calculate volume</b>
  <b class="calibre12">double volume() const</b>
  <b class="calibre12">{ return m_Length*m_Width*m_Height; }</b>
 
  // Constructor to set dimensions &amp; contents with explicit CBox constructor call
  CCandyBox(double lv, double wv, double hv, 
                   const char* str = "Candy") : CBox {lv, wv, hv}
  {
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="445" id="calibre_link-907" class="calibre14"></span>std::cout &lt;&lt;"CCandyBox constructor2 called" &lt;&lt; std::endl;
    size_t length{ strlen(str) + 1 };
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  }
 
  // Constructor to set contents - calls default CBox constructor automatically
  explicit CCandyBox(const char* str = "Candy")
  {
    std::cout &lt;&lt; "CCandyBox constructor1 called" &lt;&lt; std::endl;
    size_t length{ strlen(str) + 1 };
    m_Contents = new char[length];
    strcpy_s(m_Contents, length, str);
  }
 
  CCandyBox(const CCandyBox&amp; box) = delete;
  CCandyBox&amp; operator=(const CCandyBox&amp; box) = delete;
 
  ~CCandyBox()                                                // Destructor
  {
    <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">CCandyBox destructor called" &lt;&lt; std::endl;</b>
    delete[] m_Contents;
  }
};</code></pre>
<p class="calibre20">The code for <code class="calibre23">main()</code> in <code class="calibre23">Ex9_04.cpp</code> is:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_04.cpp</b>
<b class="calibre12">// Using the protected access specifier</b>
#include &lt;iostream&gt;                    // For stream I/O
#include "CandyBox.h"                  // For CBox and CCandyBox

<b class="calibre12">int main()</b>
<b class="calibre12">{</b>
  <b class="calibre12">CCandyBox myCandyBox;</b>
  <b class="calibre12">CCandyBox myToffeeBox {2, 3, 4,</b> "<b class="calibre12">Stickjaw Toffee"};</b>
  <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">myCandyBox volume is</b> " <b class="calibre12">&lt;&lt; myCandyBox.volume() &lt;&lt; std::endl</b>
            <b class="calibre12">&lt;&lt;</b> "<b class="calibre12">myToffeeBox volume is</b> " <b class="calibre12">&lt;&lt; myToffeeBox.volume() &lt;&lt; std::endl;</b>

  <b class="calibre12">// std::cout &lt;&lt; myToffeeBox.m_Length;  // Uncomment this for an error</b>

  <b class="calibre12">return 0;</b>
<b class="calibre12">}</b></code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">In this example you calculate the volumes of the two <code class="calibre23">CCandyBox</code> objects by invoking the <code class="calibre23">volume()</code>function that is a member of the derived class. This function accesses the inherited members <code class="calibre23">m_Length, m_Width</code>, and <code class="calibre23">m_Height</code> to produce the result. The members are declared as <code class="calibre23">protected</code> in the base class and remain <code class="calibre23">protected</code> in the derived class. The program produces the output:</p>
<pre class="calibre28"><code class="calibre23">CBox constructor called
CCandyBox constructor1 called
CBox constructor called
CCandyBox constructor2 called
myCandyBox volume is 1
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="446" id="calibre_link-908" class="calibre14"></span>myToffeeBox volume is 24
CCandyBox destructor called
CBox destructor called
CCandyBox destructor called
CBox destructor called</code></pre>
<p class="calibre20">The output shows that the volume is calculated properly for both <code class="calibre23">CCandyBox</code> objects. The first object has the default dimensions produced by calling the default <code class="calibre23">CBox</code> constructor so the volume is <code class="calibre23">1</code>, and the second object has the dimensions defined as initial values in its definition.</p>
<p class="calibre20">The output also shows the sequence of constructor and destructor calls, and you can see how each derived class object is destroyed in two steps. Destructors for a derived class object are called in the reverse order of the constructors for the object. This is a general rule that always applies. Constructors are called starting with the base class constructor and then the derived class constructor, whereas the destructor for the derived class is called first when an object is destroyed, followed by the base class destructor.</p>
<p class="calibre20">You can demonstrate that the <code class="calibre23">protected</code> members of the base class remain <code class="calibre23">protected</code> in the derived class by uncommenting the statement preceding the <code class="calibre23">return</code> statement in <code class="calibre23">main()</code>. If you do this, you get this error message:</p>
<p class="calibre20">error C2248: 'CBox::m_Length': cannot access protected member declared in class 'CBox'</p>
<p class="calibre20">This indicates clearly that <code class="calibre23">m_Length</code> is inaccessible.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">The Access Level of Inherited Class Members</h3>
<p class="calibre13">If you have no access specifier for the base class in the definition of a derived class, the default specification is <code class="calibre23">private</code>. This has the effect of causing the inherited <code class="calibre23">public</code> and <code class="calibre23">protected</code> members of the base class to be <code class="calibre23">private</code> in the derived class. The <code class="calibre23">private</code> members of the base class remain <code class="calibre23">private</code> to the base and, therefore, inaccessible in the derived class. In fact they remain <code class="calibre23">private</code> to the base class regardless of how the base class is specified in the derived class definition.</p>
<p class="calibre13">Specifying a base class as <code class="calibre23">public</code> gives base class members the same access level in the derived class as they had in the base, so <code class="calibre23">public</code> members remain <code class="calibre23">public,</code> and <code class="calibre23">protected</code> members remain <code class="calibre23">protected</code>.</p>
<p class="calibre13">The last possibility is that you declare a base class as <code class="calibre23">protected</code>. This makes the inherited <code class="calibre23">public</code> members of the base <code class="calibre23">protected</code> in the derived class. The <code class="calibre23">protected</code> and <code class="calibre23">private</code> base members retain their original access level in the derived class. This is summarized in <a id="calibre_link-196" href="#calibre_link-195" class="calibre3">Figure 9-3</a>, which shows classes <code class="calibre23">CABox, CBBox</code>, and <code class="calibre23">CCBox</code> derived from <code class="calibre23">CBox</code>.</p>
<figure class="calibre16">
<img class="center" src="images/000133.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-195" href="#calibre_link-196" class="calibre3">FIGURE 9-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">This may look a little complicated, but you can reduce it to the following three rules for inherited members of a derived class:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">private</code> members of a base class are never accessible in a derived class.</li>
<li class="calibre6">Defining a base class as <code class="calibre23">public</code> doesn’t change the access level of its members in a derived class.</li>
<li class="calibre6">Defining a base class as <code class="calibre23">protected</code> changes its <code class="calibre23">public</code> members to <code class="calibre23">protected</code> in a derived class.</li>
</ul>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="447" id="calibre_link-909" class="calibre14"></span>Being able to change the access level of inherited members in a derived class gives you a degree of flexibility, but don’t forget that you cannot relax the level specified in the base class; you can only make the access level more stringent. This suggests that base classes need to have <code class="calibre23">public</code> members if you want to be able to vary the access level in derived classes. This may seem contrary to the idea of encapsulating data in a class in order to protect it from unauthorized access, but, as you’ll see, it is often the case that you define base classes that only act as a base for other classes and aren’t intended to be used for instantiating objects in their own right.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-312" class="calibre3"></a>THE COPY CONSTRUCTOR IN A DERIVED CLASS</h2>
<p class="calibre13">Remember that the copy constructor is called automatically when you define an object that is initialized with an object of the same class. Look at these statements:</p>
<pre class="calibre28"><code class="calibre23">CBox myBox {2.0, 3.0, 4.0};            // Calls constructor
CBox copyBox {myBox};                  // Calls copy constructor</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="448" id="calibre_link-910" class="calibre14"></span>The first statement calls the constructor that accepts three arguments of type <code class="calibre23">double</code>, and the second calls the copy constructor. If you don’t define a copy constructor, the compiler supplies one that copies the initializing object member by member to the corresponding members of the new object. So that you can see what is going on during execution, you can add your own version of a copy constructor to the <code class="calibre23">CBox</code> class. You can then use this class as a base for defining the <code class="calibre23">CCandyBox</code> class:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Box.h in Ex9_05</b>
#pragma once
#include &lt;iostream&gt;
        
class CBox                   // Base class definition
{
public:
  // Base class constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0):
                       m_Length {lv}, m_Width {wv}, m_Height {hv}
  {  std::cout &lt;&lt; "CBox constructor called" &lt;&lt; std::endl;  }
      
  <b class="calibre12">// Copy constructor</b>
  <b class="calibre12">CBox(const CBox&amp; initB)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">CBox copy constructor called" &lt;&lt; std::endl;</b>
    <b class="calibre12">m_Length = initB.m_Length;</b>
    <b class="calibre12">m_Width = initB.m_Width;</b>
    <b class="calibre12">m_Height = initB.m_Height;</b>
  <b class="calibre12">}</b>
 
  // CBox destructor - just to track calls
  ~CBox()
  { std::cout &lt;&lt; "CBox destructor called" &lt;&lt; std::endl; }
 
protected:
  double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre13">Don’t forget that a copy constructor must have its parameter specified as a reference to avoid the infinite number of calls to itself that would otherwise result from copying an argument by value. When the copy constructor in our example is called, it outputs a message, so you can see from the output when this is happening. You need to add a similar copy constructor to the <code class="calibre23">CCandyBox</code> class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: The Copy Constructor in a Derived Class</h3>
<p class="calibre20">Add the following code for the copy constructor to the <code class="calibre23">public</code> section of the derived <code class="calibre23">CCandyBox</code> class in <code class="calibre23">Ex9_04</code> in place of the deleted copy constructor:</p>
<pre class="calibre28"><code class="calibre23">    // Derived class copy constructor
    CCandyBox(const CCandyBox&amp; initCB)
    {
      <span {http://www.idpf.org/2007/ops}type="pagebreak" title="449" id="calibre_link-911" class="calibre14"></span><code class="calibre23">std::</code>cout &lt;&lt; "CCandyBox copy constructor called" &lt;&lt; std::endl;
      size_t length {strlen(initCB.m_Contents) + 1};
      m_Contents = new char[length];                       // Get new memory
      strcpy_s(m_Contents, length, initCB.m_Contents);     // Copy string
    }</code></pre>
<p class="calibre20">You can now run this new version (<code class="calibre23">Ex9_05</code>) of the last example with the following <code class="calibre23">main()</code> function to see how the new copy constructor works:</p>
<pre class="calibre28"><code class="calibre23">// Ex9_05
// Using the copy constructor in a derived class
#include &lt;iostream&gt;                               // For stream I/O
#include "CandyBox.h"                             // For CBox and CCandyBox
 
int main()
{
  CCandyBox chocBox {2.0, 3.0, 4.0, "Chockies"};  // Declare and initialize
  CCandyBox chocolateBox {chocBox};               // Use copy constructor
        
  std::cout &lt;&lt; "Volume of chocBox is " &lt;&lt; chocBox.volume() &lt;&lt; std::endl
            &lt;&lt; "Volume of chocolateBox is " &lt;&lt; chocolateBox.volume() &lt;&lt; std::endl;
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">CBox constructor called
CCandyBox constructor2 called
CBox constructor called
CCandyBox copy constructor called
Volume of chocBox is 24
Volume of chocolateBox is 1
CCandyBox destructor called
CBox destructor called
CCandyBox destructor called
CBox destructor called</code></pre>
<p class="calibre20">Although this looks okay at first sight, there’s something wrong. The third line of output shows that the default constructor is called for the <code class="calibre23">CBox</code> part of the <code class="calibre23">chocolateBox</code> object, rather than the copy constructor. As a consequence, the object has default dimensions rather than the dimensions of the initializing object, so the volume is incorrect. The reason for this is that when you write a constructor for an object of a derived class, you are responsible for ensuring that the members of the derived class object are properly initialized. This includes the inherited members.</p>
<p class="calibre20">The fix for this is to call the copy constructor for the base part of the class in the initialization list for the copy constructor for the <code class="calibre23">CCandyBox</code> class. The copy constructor then becomes:</p>
<pre class="calibre28"><code class="calibre23">// Derived class copy constructor
<b class="calibre12">CCandyBox(const CCandyBox&amp; initCB): CBox {initCB}</b>
{
  std::cout &lt;&lt; "CCandyBox copy constructor called" &lt;&lt; std::endl;
  size_t length {strlen(initCB.m_Contents) + 1};
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="450" id="calibre_link-912" class="calibre14"></span>m_Contents = new char[length];                       // Get new memory
  strcpy_s(m_Contents, length, initCB.m_Contents);     // Copy string
}</code></pre>
<p class="calibre20">The <code class="calibre23">CBox</code> copy constructor is called with the <code class="calibre23">initCB</code> object. This initializes the base part of the object that is being created so everything works out. If you modify the example by adding the base copy constructor call, the output is:</p>
<pre class="calibre28"><code class="calibre23">CBox constructor called
CCandyBox constructor2 called
CBox copy constructor called
CCandyBox copy constructor called
Volume of chocBox is 24
Volume of chocolateBox is 24
CCandyBox destructor called
CBox destructor called
CCandyBox destructor called
CBox destructor called</code></pre>
<p class="calibre20">This shows that all the constructors and destructors are called in the correct sequence, and the copy constructor for the <code class="calibre23">CBox</code> part of <code class="calibre23">chocolateBox</code> is called before the <code class="calibre23">CCandyBox</code> copy constructor. The volume of the <code class="calibre23">chocolateBox</code> object is now the same as that of its initializing object, which is as it should be.</p>
<p class="calibre20">You have, therefore, another golden rule to remember.</p>
<p class="calibre20"><i class="calibre15">If you write any kind of constructor for a derived class, you are responsible for the initialization of all members of the derived class object, including all its inherited members.</i></p>
<p class="calibre20">Of course, as you saw in the previous chapter, if you want to make a class that allocates memory on the heap as efficient as possible, you should overload the copy constructor with a version that uses an rvalue reference parameter. You could add the following to the <code class="calibre23">CCandyBox</code> class to take care of this:</p>
<pre class="calibre28"><code class="calibre23">// Move constructor
CCandyBox(CCandyBox&amp;&amp; initCB): CBox {std::move(initCB)}
{
  std::cout &lt;&lt; “CCandyBox move constructor called”&lt;&lt; std::endl;
  m_Contents = initCB.m_Contents;
  initCB.m_Contents = 0;
}</code></pre>
<p class="calibre20">You still have to call the base class move constructor to get the base members initialized.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-313" class="calibre3"></a>PREVENTING CLASS DERIVATION</h2>
<p class="calibre13">Circumstances can arise where you want to be sure that your class cannot be used as a base class. You can do this by specifying your class as <code class="calibre23">final</code>. Here’s how you could prevent derivation from the <code class="calibre23">CBox</code> class:</p>
<pre class="calibre28"><code class="calibre23">class CBox final
{
  // Class details as before...
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="451" id="calibre_link-913" class="calibre14"></span>The <code class="calibre23">final</code> modifier following the class name tells the compiler that derivation from the <code class="calibre23">CBox</code> class is not to be allowed. If you modify the <code class="calibre23">CBox</code> class in <code class="calibre23">Ex9_05</code> in this way, the code will not compile.</p>
<p class="calibre13">Note that <code class="calibre23">final</code> is not a keyword; it just has a special meaning in context. You are not allowed to use a keyword as a name, whereas you could use <code class="calibre23">final</code> as the name for a variable, for example.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-314" class="calibre3"></a>CLASS MEMBERS AS FRIENDS</h2>
<p class="calibre13">You saw in Chapter 7 how a function can be declared as a <code class="calibre23">friend</code> of a class. This gives the <code class="calibre23">friend</code> function the privilege of free access to any of the class members. Of course, there is no reason why a <code class="calibre23">friend</code> function cannot be a member of another class.</p>
<p class="calibre13">Suppose you define a <code class="calibre23">CBottle</code> class to represent a bottle:</p>
<pre class="calibre28"><code class="calibre23">// Bottle.h
#pragma once
        
class CBottle
{
public:
  CBottle(double height, double diameter) :
   m_Height {height}, m_Diameter {diameter} {}
      
private:
  double m_Height;                        // Bottle height
  double m_Diameter;                      // Bottle diameter
};</code></pre>
<p class="calibre13">You now need a class to represent the packaging for a dozen bottles that automatically has custom dimensions to accommodate a particular kind of bottle. You might define this as the following &mdash; although this won’t compile as it is:</p>
<pre class="calibre28"><code class="calibre23">// Carton.h
#pragma once
class CBottle;                            // Forward declaration
        
class CCarton
{
public:
  CCarton(const CBottle&amp; aBottle)
  {
    m_Height = aBottle.m_Height;          // Bottle height
    m_Length = 4.0*aBottle.m_Diameter;    // Four rows of ...
    m_Width = 3.0*aBottle.m_Diameter;     // ...three bottles
  }
      
private:
  double m_Length;                        // Carton length
  double m_Width;                         // Carton width
  double m_Height;                        // Carton height
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="452" id="calibre_link-914" class="calibre14"></span>We now have two class definitions that each reference the other class type. The forward declaration for the <code class="calibre23">CBottle</code> class in <code class="calibre23">Carton.h</code> is essential; without it the compiler won’t know what <code class="calibre23">CBottle</code> refers to. Forward declarations are always needed to resolve cyclic references between two or more classes. The <code class="calibre23">CCarton</code> constructor sets the height to be the same as that of the bottle it is to accommodate, and the length and width are set based on the diameter of the bottle so that 12 fit in the box. As you know by now, this won’t work. The data members of the <code class="calibre23">CBottle</code> class are <code class="calibre23">private</code>, so the <code class="calibre23">CCarton</code> constructor can’t access them. As you also know, a <code class="calibre23">friend</code> declaration in the <code class="calibre23">CBottle</code> class fixes it:</p>
<pre class="calibre28"><code class="calibre23">// Bottle.h
#pragma once;
<b class="calibre12">class CCarton;                            // Forward declaration</b>
        
class CBottle
{
public:
  CBottle(double height, double diameter) :
   m_Height {height}, m_Diameter {diameter} {}
      
private:
  double m_Height;                        // Bottle height
  double m_Diameter;                      // Bottle diameter
      
<b class="calibre12">// Let the carton constructor in</b>
<b class="calibre12">friend CCarton::CCarton(const CBottle&amp; aBottle);</b>
};</code></pre>
<p class="calibre13">The only difference between the <code class="calibre23">friend</code> declaration here and what you saw in Chapter 7 is that you must put the class name and the scope resolution operator with the <code class="calibre23">friend</code> function name to identify it. You must have a forward declaration for the <code class="calibre23">CCarton</code> class because the friend function refers to it.</p>
<p class="calibre13">You might think that this will compile correctly, but there’s a problem. You have put a forward declaration of the <code class="calibre23">CCarton</code> class in the <code class="calibre23">CBottle</code> class and vice versa to resolve the cyclic dependency, but this still won’t allow the classes to compile. The problem is with the <code class="calibre23">CCarton</code> constructor. This appears within the <code class="calibre23">CCarton</code> class definition and the compiler cannot compile this function without having first compiled the <code class="calibre23">CBottle</code> class. On the other hand, it can’t compile the <code class="calibre23">CBottle</code> class without having compiled the <code class="calibre23">CCarton</code> class. The only way to resolve this is to put the <code class="calibre23">CCarton</code> constructor definition in a <code class="calibre23">.cpp</code> file, thus removing the need to compile it when the <code class="calibre23">CCarton</code> class is compiled. The header file holding the <code class="calibre23">CCarton</code> class definition will be:</p>
<pre class="calibre28"><code class="calibre23">// Carton.h
#pragma once
class CBottle;                            // Forward declaration
        
class CCarton
{
public:
  <b class="calibre12">CCarton(const CBottle&amp; aBottle);</b>
      
private:
  double m_Length;                        // Carton length
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="453" id="calibre_link-915" class="calibre14"></span>double m_Width;                           // Carton width
  double m_Height;                          // Carton height
};</code></pre>
<p class="calibre13">The contents of the <code class="calibre23">Carton.cpp</code> file will be:</p>
<pre class="calibre28"><code class="calibre23">// Carton.cpp
#include "Carton.h"
#include "Bottle.h"
        
CCarton::CCarton(const CBottle&amp; aBottle)
{
  m_Height = aBottle.m_Height;              // Bottle height
  m_Length = 4.0*aBottle.m_Diameter;        // Four rows of ...
  m_Width = 3.0*aBottle.m_Diameter;         // ...three bottles
}</code></pre>
<p class="calibre13">Now, the compiler can compile both class definitions and the <code class="calibre23">carton.cpp</code> file.</p>
<section class="toclist">
<h3 class="calibre21">Friend Classes</h3>
<p class="calibre13">You can allow all the member functions of one class to have access to all the data members of another by declaring it as a <i class="calibre15">friend class</i>. You could define the <code class="calibre23">CCarton</code> class as a friend of the <code class="calibre23">CBottle</code> class by adding a <code class="calibre23">friend</code> declaration within the <code class="calibre23">CBottle</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">friend CCarton;</code></pre>
<p class="calibre13">With this declaration in the <code class="calibre23">CBottle</code> class, all function members of the <code class="calibre23">CCarton</code> class have free access to all the data members of the <code class="calibre23">CBottle</code> class.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Limitations on Class Friendship</h3>
<p class="calibre13">Class friendship is not reciprocated. Making the <code class="calibre23">CCarton</code> class a <code class="calibre23">friend</code> of the <code class="calibre23">CBottle</code> class does not mean that the <code class="calibre23">CBottle</code> class is a <code class="calibre23">friend</code> of the <code class="calibre23">CCarton</code> class. If you want this to be so, you must add a <code class="calibre23">friend</code> declaration for the <code class="calibre23">CBottle</code> class to the <code class="calibre23">CCarton</code> class.</p>
<p class="calibre13">Class friendship is also not inherited. If you define another class with <code class="calibre23">CBottle</code> as a base, members of the <code class="calibre23">CCarton</code> class will not have access to its data members, not even those inherited from <code class="calibre23">CBottle</code>.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-315" class="calibre3"></a>VIRTUAL FUNCTIONS</h2>
<p class="calibre13">Let’s look more closely at the behavior of inherited member functions and their relationship with derived class member functions. You could add a function to the <code class="calibre23">CBox</code> class to output the volume of a <code class="calibre23">CBox</code> object. The simplified class then becomes:</p>
<pre class="calibre28"><code class="calibre23">// Box.h in Ex9_06
#pragma once
#include &lt;iostream&gt;
        
class CBox                             // Base class
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="454" id="calibre_link-916" class="calibre14"></span>{
public:
  // Function to show the volume of an object
  void showVolume() const
  { std::cout &lt;&lt; "CBox usable volume is " &lt;&lt; volume() &lt;&lt; std::endl; }
      
  // Function to calculate the volume of a CBox object
  double volume() const
  { return m_Length*m_Width*m_Height; }
      
  // Constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0)
                          :m_Length {lv}, m_Width {wv}, m_Height {hv} {}
      
protected:
  double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre13">Now, you can output the usable volume of a <code class="calibre23">CBox</code> object just by calling the <code class="calibre23">showVolume()</code> function for any object for which you require it. The constructor sets the data member values in the initialization list, so no statements are necessary in its body. The data members are <code class="calibre23">protected</code> so they are accessible to the member functions of any derived class.</p>
<p class="calibre13">Suppose you want to derive a class for a different kind of box called <code class="calibre23">CGlassBox</code>, to hold glassware. The contents are fragile, and because packing material is added to protect them, the capacity of the box is less than the capacity of a basic <code class="calibre23">CBox</code> object. You therefore need a different <code class="calibre23">volume()</code> function to account for this, so you add it to the derived class:</p>
<pre class="calibre28"><code class="calibre23">// GlassBox.h in Ex9_06
#pragma once
#include "Box.h"
      
class CGlassBox : public CBox           // Derived class
{
public:
  // Function to calculate volume of a CGlassBox
  // allowing 15% for packing
  double volume() const
  { return 0.85*m_Length*m_Width*m_Height; }
      
  // Constructor
  CGlassBox(double lv, double wv, double hv): CBox {lv, wv, hv} {}
};</code></pre>
<p class="calibre13">There could be other members of the derived class, but we’ll keep it simple and concentrate on how the inherited functions work for the moment. The constructor for the derived class calls the base constructor in its initialization list to set the data member values. No statements are necessary in its body. You have a new version of the <code class="calibre23">volume()</code> function to replace the version from the base class, the idea being that you can get the inherited function <code class="calibre23">showVolume()</code> to call the derived class version of the member function <code class="calibre23">volume()</code> when you call it for a <code class="calibre23">CGlassBox</code> object.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="455" id="calibre_link-917" class="calibre24"></span>TRY IT OUT: Using an Inherited Function</h3>
<p class="calibre20">You can see how the derived class works in practice very simply by creating objects of the base class and the derived class with the same dimensions and then verifying that the correct volumes are being calculated. The <code class="calibre23">main()</code> function to do this is as follows:</p>
<pre class="calibre28"><code class="calibre23">// Ex9_06.cpp
// Behavior of inherited functions in a derived class
#include &lt;iostream&gt;
#include "GlassBox.h"                   // For CBox and CGlassBox
        
int main()
{
  CBox myBox {2.0, 3.0, 4.0};           // Define a base box
  CGlassBox myGlassBox {2.0, 3.0, 4.0}; // Define derived box - same size
        
  myBox.showVolume();                   // Display volume of base box
  myGlassBox.showVolume();              // Display volume of derived box
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">If you run this example, it produces the following output:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
CBox usable volume is 24</code></pre>
<p class="calibre20">This isn’t only dull and repetitive, but it’s also disastrous. It isn’t working the way you want at all, and the only interesting thing about it is why. Evidently, the fact that the second call is for an object of the derived class <code class="calibre23">CGlassBox</code> is not being taken into account. You can see this from the incorrect result for the volume in the output. The volume of a <code class="calibre23">CGlassBox</code> object should definitely be less than that of a basic <code class="calibre23">CBox</code> with the same dimensions.</p>
<p class="calibre20">The incorrect output is because the <code class="calibre23">volume()</code> function call in <code class="calibre23">showVolume()</code>is being set once and for all by the compiler as the version defined in the base class. <code class="calibre23">showVolume()</code> is a base class function and when <code class="calibre23">CBox</code> is compiled, the call to <code class="calibre23">volume()</code> is resolved at that time to the base class <code class="calibre23">volume()</code> function; the compiler has no knowledge of any other <code class="calibre23">volume()</code> function. This is called <i class="calibre15">static resolution</i> of the function call since the function call is fixed before the program is executed. This is also called <i class="calibre15">early binding</i> because the particular <code class="calibre23">volume()</code> function chosen is bound to the call from <code class="calibre23">showVolume()</code> during the compilation of the program rather than at execution time.</p>
<p class="calibre20">What we were hoping for was that the question of which <code class="calibre23">volume()</code> function call to use in any given instance would be resolved when the program was executed. This sort of operation is referred to as <i class="calibre15">dynamic binding</i>, or <i class="calibre15">late binding</i>. We want the version of <code class="calibre23">volume()</code> called by <code class="calibre23">showVolume()</code> to be determined by the kind of object being processed, and not arbitrarily fixed by the compiler before the program is executed.</p>
<p class="calibre20">No doubt, you’ll be less than astonished that C++ does, in fact, provide you with a way to do this, because this whole discussion would have been futile otherwise! You need something called a <i class="calibre15">virtual function</i>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="456" id="calibre_link-918" class="calibre24"></span>What Is a Virtual Function?</h3>
<p class="calibre13">A <i class="calibre15">virtual function</i> is a function in a base class that is declared using the keyword <code class="calibre23">virtual</code>. If you specify a function in a base class as <code class="calibre23">virtual</code> and the function is redefined in a derived class, it signals to the compiler that you don’t want early binding for it. What you <i class="calibre15">do</i> want is the function to be called at any given point in the program to be chosen based on the kind of object for which it is called.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Fixing the CGlassBox</h3>
<p class="calibre20">To make this example work as originally hoped, you just need to add the <code class="calibre23">virtual</code> keyword to the definitions of the <code class="calibre23">volume()</code> function in the two classes. You can try this in a new project, <code class="calibre23">Ex9_07</code>. Here’s how the definition of <code class="calibre23">CBox</code> should be:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Box.h in Ex9_07</b>
#pragma once
#include &lt;iostream&gt;
        
class CBox                             // Base class
{
public:
  // Function to show the volume of an object
  void showVolume() const
  {
    std::cout &lt;&lt; "CBox usable volume is " &lt;&lt; volume() &lt;&lt; std::endl;
  }
        
  // Function to calculate the volume of a CBox object
  <b class="calibre12">virtual double volume() const</b>
  { return m_Length*m_Width*m_Height; }
        
  // Constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0) :
                           m_Length{ lv }, m_Width{ wv }, m_Height{ hv } {}
        
protected:
  double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre20">The <code class="calibre23">GlassBox.h</code> header file contents should be:</p>
<pre class="calibre28"><code class="calibre23">// GlassBox.h in Ex9_07
#pragma once
#include "Box.h"
        
class CGlassBox: public CBox           // Derived class
{
public:
  // Function to calculate volume of a CGlassBox allowing 15% for packing
  <b class="calibre12">virtual double volume() const</b>
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="457" id="calibre_link-919" class="calibre14"></span>{ return 0.85*m_Length*m_Width*m_Height; }
        
  // Constructor
  CGlassBox(double lv, double wv, double hv): CBox {lv, wv, hv} {}
};</code></pre>
<p class="calibre20">The <code class="calibre23">Ex9_07.cpp</code> file version of <code class="calibre23">main()</code> is the same as for the previous example.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">This version of the program with just the little word <code class="calibre23">virtual</code> added to the definitions of <code class="calibre23">volume()</code> produces this output:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
CBox usable volume is 20.4</code></pre>
<p class="calibre20">This is now clearly doing what you wanted in the first place. The first call to <code class="calibre23">showVolume()</code> with the <code class="calibre23">CBox</code> object <code class="calibre23">myBox</code> calls the <code class="calibre23">CBox</code> class version of <code class="calibre23">volume()</code>. The second call with the <code class="calibre23">CGlassBox</code> object <code class="calibre23">myGlassBox</code> calls the version defined in the derived class.</p>
<p class="calibre20">Note that although you have put the keyword <code class="calibre23">virtual</code> in the derived class definition of the function <code class="calibre23">volume()</code>, it’s not essential to do so. Specifying the base version of the function as <code class="calibre23">virtual</code> is sufficient. However, I recommend that you do specify the keyword for virtual functions in derived classes because it makes it clear to anyone reading the class definition that they are virtual functions and that they are selected dynamically.</p>
<p class="calibre20">For a function to behave as virtual, it must have the same name, parameter list, and return type in any derived class as the function in the base class, and if the base class function is <code class="calibre23">const</code>, the derived class function must be, too. If you try to use different parameters or return types, or declare one as <code class="calibre23">const</code> and the other not, the virtual function mechanism won’t work.</p>
<p class="calibre20">The operation of virtual functions is an extraordinarily powerful mechanism. You may have heard the term <i class="calibre15">polymorphism</i> in relation to object-oriented programming, and this refers to the virtual function capability. Something that is polymorphic can appear in different guises, like Dr. Jekyll, or like a politician before and after an election. Calling a virtual function produces different effects depending on the kind of object for which it is being called.</p>
<p class="calibre20">Note that the <code class="calibre23">volume()</code>in the derived <code class="calibre23">CGlassBox</code> class hides the base class version from the view of derived class functions. If you wanted to call the base version of <code class="calibre23">volume()</code> from a derived class function, you would need to use the scope resolution operator and refer to the function as <code class="calibre23">CBox::volume()</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Ensuring Correct Virtual Function Operation</h3>
<p class="calibre13">As I said in the previous section, for a function to behave as virtual, it must have the same name, parameter list, and return type in any derived class as a function in the base class. It’s not difficult to make a mistake though. If you forget to specify <code class="calibre23">volume()</code>as <code class="calibre23">const</code> in <code class="calibre23">CGlassBox</code> in <code class="calibre23">Ex9_07</code>, the program will still compile &mdash; it just won’t work correctly. When the function in the derived class has a different signature from the function in the base class it is supposed to be overriding, you are not overriding the base function at all. You can tell the compiler that a virtual function in a derived class <span {http://www.idpf.org/2007/ops}type="pagebreak" title="458" id="calibre_link-920" class="calibre14"></span>is overriding a virtual function in a base class by using the <code class="calibre23">override</code> modifier. You could do this for the <code class="calibre23">volume()</code> function in <code class="calibre23">CGlassBox</code> in <code class="calibre23">Ex9_07</code> like this:</p>
<pre class="calibre28"><code class="calibre23">  class CGlassBox : public CBox           // Derived class
  {
  public:
    // Function to calculate volume of a CGlassBox allowing 15% for packing
    <b class="calibre12">virtual double volume() const override</b>
    { return 0.85*m_Length*m_Width*m_Height; }
        
    // Constructor
    CGlassBox(double lv, double wv, double hv): CBox {lv, wv, hv} {}
  };</code></pre>
<p class="calibre13">Now the compiler will check that there is a base class <code class="calibre23">volume()</code> function with the same signature. If there isn’t, you will get an error message. You can demonstrate this by changing the definition of <code class="calibre23">volume()</code> in <code class="calibre23">CGlassBox</code> by adding the <code class="calibre23">override</code> modifier and omitting the <code class="calibre23">const</code> keyword.</p>
<p class="calibre13">If you always use the <code class="calibre23">override</code> modifier with virtual functions in derived classes, you are guaranteed that any mistakes in specifying the overrides will be reported by the compiler. Note that like the <code class="calibre23">final</code> modifier, <code class="calibre23">override</code> is not a keyword. It just has special meaning in context.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Preventing Function Overriding</h3>
<p class="calibre13">You may want to prevent a member function being overridden. This could be because you want to preserve a particular aspect of behavior. In this case you can specify a member function as <code class="calibre23">final</code>. For example, you could specify that the <code class="calibre23">volume()</code> member <code class="calibre23">CBox</code> class in <code class="calibre23">Ex9_07</code> is not to be overridden like this:</p>
<pre class="calibre28"><code class="calibre23">  class CBox                             // Base class
  {
  public:
    // Class definition as before....
        
    // Function to calculate the volume of a CBox object
    <b class="calibre12">virtual double volume() const final</b>
    { return m_Length*m_Width*m_Height; }
        
    // Rest of the class as before...
  };</code></pre>
<p class="calibre13">The <code class="calibre23">final</code> modifier tells the compiler that the <code class="calibre23">volume()</code> function must not be overridden. With this amendment in <code class="calibre23">Ex9_07</code> the compiler will flag the <code class="calibre23">volume()</code> function in the derived class as an error.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using Pointers to Class Objects</h3>
<p class="calibre13">Using pointers to base class and derived class objects is an important technique. You can use a pointer to a base class type to store the address of a derived class object, as well as that of a base class object. Thus you can use a pointer of type “pointer to base” to obtain different behavior with virtual functions, depending on what type of object the pointer is pointing to. You’ll see more clearly how this works by looking at an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="459" id="calibre_link-921" class="calibre24"></span>TRY IT OUT: Pointers to Base and Derived Classes</h3>
<p class="calibre20">You’ll use essentially the same classes as in the previous example, but make a small modification to <code class="calibre23">main()</code>so that it uses a pointer to a base class object. Create the <code class="calibre23">Ex9_08</code> project with <code class="calibre23">Box.h</code> and <code class="calibre23">GlassBox.h</code> header files as in the previous example. You can copy the <code class="calibre23">Box.h</code> and <code class="calibre23">Glassbox.h</code> files from the <code class="calibre23">Ex9_07</code> project to this project folder. Adding an existing file to a project is quite easy; you right-click Ex9_08 in the Solution Explorer tab, select Add <img src="images/000122.png" alt="image" class="calibre25" /> Existing Item from the pop-up menu, and then select a file to add it to the project. You can select multiple files to add, if you want. When you have added the headers, modify <code class="calibre23">Ex9_08.cpp</code> to the following:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_08.cpp</b>
<b class="calibre12">// Using a base class pointer to call a virtual function</b>
#include &lt;iostream&gt;
#include "GlassBox.h"                    // For CBox and CGlassBox
 
int main()
{
  CBox myBox {2.0, 3.0, 4.0};            // Define a base box
  CGlassBox myGlassBox {2.0, 3.0, 4.0};  // Define derived box of same size
  <b class="calibre12">CBox* pBox {};             // A pointer to base class objects</b>
  <b class="calibre12">pBox = &amp;myBox;             // Set pointer to address of base object</b>
  <b class="calibre12">pBox-&gt;showVolume();        // Display volume of base box</b>
  <b class="calibre12">pBox = &amp;myGlassBox;        // Set pointer to derived class object</b>
  <b class="calibre12">pBox-&gt;showVolume();        // Display volume of derived box</b>
 
  return 0;
}</code></pre>
<p class="calibre20">In the code download for this example, you will find that I also added the <code class="calibre23">override</code> modifier to the <code class="calibre23">volume()</code> member of the <code class="calibre23">CGlassBox</code> class.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The classes are the same as in <code class="calibre23">Ex9_07</code> but <code class="calibre23">main()</code> now uses a pointer to call <code class="calibre23">showVolume()</code>. Because you are using a pointer, you use the indirect member selection operator, <code class="calibre23">-&gt;</code>, to call the function. The <code class="calibre23">showVolume()</code>function is called twice, and both calls use the same pointer to base class objects, <code class="calibre23">pBox</code>. In the first call, the pointer contains the address of the base object, <code class="calibre23">myBox</code>, and in the second call, it contains the address of the derived class object, <code class="calibre23">myGlassBox</code>.</p>
<p class="calibre20">The output produced is:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
CBox usable volume is 20.4</code></pre>
<p class="calibre20">This is exactly the same as that from the previous example, where you used explicit objects in the function calls. You can conclude from this that the virtual function mechanism works just as well through a pointer to a base class, and the function that is called is selected based on the type of object pointed to. This is illustrated in <a id="calibre_link-198" href="#calibre_link-197" class="calibre3">Figure 9-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000055.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-197" href="#calibre_link-198" class="calibre3">FIGURE 9-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">This is an important result. You don’t need to know the type of object pointed to by a base class pointer (when a pointer is passed to a function as an argument, for example); the virtual function mechanism will ensure that the correct function is called. This is an extraordinarily powerful capability, so make sure you understand it. Polymorphism is a fundamental mechanism that you will be using again and again.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="460" id="calibre_link-922" class="calibre24"></span>Using References with Virtual Functions</h3>
<p class="calibre13">If you define a function with a parameter that is a reference to a base class type, you can pass an object of a derived class type to it. When the function executes, the appropriate virtual function for the object passed as the reference argument is selected automatically. You can see this happening by modifying <code class="calibre23">main()</code> in the previous example to call a function that has a reference parameter.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using References with Virtual Functions</h3>
<p class="calibre20">Let’s move the call to <code class="calibre23">showVolume()</code> in <code class="calibre23">main()</code> into a separate function and call that separate function from <code class="calibre23">main()</code>:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_09.cpp</b>
<b class="calibre12">// Using a reference to call a virtual function</b>
#include &lt;iostream&gt;
#include "GlassBox.h"                  // For CBox and CGlassBox
 
<b class="calibre12">void output(const CBox&amp; aBox);         // Function prototype</b>
 
int main()
{
  CBox myBox {2.0, 3.0, 4.0};           // Define a base box
  CGlassBox myGlassBox {2.0, 3.0, 4.0}; // Define derived box of same size
  <b class="calibre12">output(myBox);                        // Output volume of base class object</b>
  <b class="calibre12">output(myGlassBox);                   // Output volume of derived class object</b>
 
  return 0;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="461" id="calibre_link-923" class="calibre14"></span>}

<b class="calibre12">void output(const CBox&amp; aBox)</b>
<b class="calibre12">{</b>
  <b class="calibre12">aBox.showVolume();</b>
<b class="calibre12">}</b></code></pre>
<p class="calibre20"><code class="calibre23">Box.h</code> and <code class="calibre23">GlassBox.h</code> for this example are the same as in the previous example.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">main()</code>function now consists of two calls of the <code class="calibre23">output()</code>function: the first with a base class object as the argument and the second with a derived class object. Because the parameter is a reference to the base class, the <code class="calibre23">output()</code> function will accept an object of any class derived from <code class="calibre23">CBox</code> as an argument, as well as a <code class="calibre23">CBox</code> object, of course. The appropriate version of the virtual function <code class="calibre23">volume()</code> will be called, depending on the object that initialized the reference parameter.</p>
<p class="calibre20">The program produces the same output as the previous example, demonstrating that the virtual function mechanism does indeed work through a reference parameter. You now know that polymorphism works with both pointers and references.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Pure Virtual Functions</h3>
<p class="calibre13">It’s possible that you’d want to include a virtual function in a base class so that it may be redefined in a derived class and thus get polymorphic behavior with derived class objects, but there is no meaningful definition for the function in the base class. For example, you might have a <code class="calibre23">CContainer</code> class, which could be a base for defining the <code class="calibre23">CBox</code> class, or a <code class="calibre23">CBottle</code> class, or even a <code class="calibre23">CTeapot</code> class. The <code class="calibre23">CContainer</code> class wouldn’t have data members, but you might want to provide <code class="calibre23">volume()</code>as a virtual member function to allow it to be called polymorphically for any derived class object. Because <code class="calibre23">CContainer</code> has no data members and therefore no container dimensions, there is no sensible definition for the <code class="calibre23">volume()</code> function. However, you can still define the class including <code class="calibre23">volume()</code> like this:</p>
<pre class="calibre28"><code class="calibre23">// Container.h for Ex9_10
#pragma once
#include &lt;iostream&gt;
        
class CContainer        // Generic base class for specific containers
{
public:
  // Function for calculating a volume - no content
  // This is defined as a 'pure' virtual function, signified by '= 0'
  virtual double volume() const = 0;
        
  // Function to display a volume
  virtual void showVolume() const
  {  std::cout &lt;&lt; "Volume is " &lt;&lt; volume() &lt;&lt; std::endl;  }
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="462" id="calibre_link-924" class="calibre14"></span>The statement for the virtual function <code class="calibre23">volume()</code> defines it as having no content by placing the equals sign and zero in the function header. This is called a <i class="calibre15">pure virtual function</i>. The class also contains the <code class="calibre23">showVolume()</code> function that displays the volume of derived class objects. Because this function is <code class="calibre23">virtual</code>, it can be replaced in a derived class but if it isn’t, this inherited base class version is called for derived class objects.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Abstract Classes</h3>
<p class="calibre13">A class that contains a pure virtual function is called an <i class="calibre15">abstract class</i>. It’s called <i class="calibre15">abstract</i> because you can’t define objects of a class that contains a pure virtual function. However, you can define pointers and references of an abstract class type. An abstract class exists only for the purpose of deriving classes from it. If a class that is derived from an abstract class does not define a pure virtual function that is inherited from the base class, then it is also an abstract class.</p>
<p class="calibre13">You should not conclude from the example of the <code class="calibre23">CContainer</code> class that an abstract class can’t have data members. An abstract class can have both data members and member functions. The presence of a pure virtual function is the only condition that makes a class abstract. An abstract class can have several pure virtual functions. In this case a derived class must define every pure virtual function inherited from its base, otherwise it too will be an abstract class. If you forget to make the derived class version of the <code class="calibre23">volume()</code> function <code class="calibre23">const</code>, the derived class will still be abstract because it contains the pure virtual <code class="calibre23">volume()</code> function that is <code class="calibre23">const</code>, as well as the non-<code class="calibre23">const</code> version. <code class="calibre23">const</code> and non-<code class="calibre23">const</code> functions are always differentiated.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: An Abstract Class</h3>
<p class="calibre20">You could implement a <code class="calibre23">CCan</code> class, representing beer or cola cans, perhaps, together with the original <code class="calibre23">CBox</code> class, and derive both from the <code class="calibre23">CContainer</code> class that you defined in the previous section. The definition of <code class="calibre23">CBox</code> as a subclass of <code class="calibre23">CContainer</code> is as follows:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Box.h for Ex9_10</b>
#pragma once
<b class="calibre12">#include</b> "<b class="calibre12">Container.h"                 // For CContainer definition</b>
#include &lt;iostream&gt;
        
<b class="calibre12">class CBox : public CContainer          // Derived class</b>
{
public:
        
  // Function to show the volume of an object
  virtual void showVolume() const override
  {  std::cout &lt;&lt; "CBox usable volume is " &lt;&lt; volume() &lt;&lt; std::endl; }
        
  // Function to calculate the volume of a CBox object
  virtual double volume() const override
  { return m_Length*m_Width*m_Height; }
        
  // Constructor
  explicit CBox(double lv = 1.0, double wv = 1.0, double hv = 1.0)
                             :m_Length {lv}, m_Width {wv}, m_Height{hv} {}
        
protected:
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="463" id="calibre_link-925" class="calibre14"></span>double m_Length;
  double m_Width;
  double m_Height;
};</code></pre>
<p class="calibre20">The <code class="calibre23">CBox</code> class is essentially as you had it in the previous example, except that this time you have specified that it is derived from the <code class="calibre23">CContainer</code> class. The <code class="calibre23">volume ()</code> function is fully defined within <code class="calibre23">CBox</code> (as it must be if this class is to be used to define objects). The only other option would be to specify it as a pure virtual function because it is pure in the base class but then you could not create <code class="calibre23">CBox</code> objects.</p>
<p class="calibre20">You can define the <code class="calibre23">CCan</code> class in the <code class="calibre23">Can.h</code> header file like this:</p>
<pre class="calibre28"><code class="calibre23">// Can.h for Ex9_10
#pragma once
#define _USE_MATH_DEFINES              // For constants in math.h
#include &lt;math.h&gt;
#include "Container.h"                 // For CContainer definition
        
class CCan : public CContainer
{
public:
  // Function to calculate the volume of a can
  virtual double volume() const override
  { return 0.25*M_PI*m_Diameter*m_Diameter*m_Height; }
        
  // Constructor
  explicit CCan(double hv = 4.0, double dv = 2.0): m_Height {hv}, m_Diameter {dv} {}
    
protected:
  double m_Height;
  double m_Diameter;
};</code></pre>
<p class="calibre20">The <code class="calibre23">CCan</code> class also defines a <code class="calibre23">volume()</code> function based on the formula <i class="calibre15">h</i>π<i class="calibre15">r</i>2 where <i class="calibre15">h</i> is the height of a can and <i class="calibre15">r</i> is the radius of the cross-section. The constant, <code class="calibre23">M_PI</code>, is defined in <code class="calibre23">math.h</code> and becomes available when <code class="calibre23">_USE_MATH_DEFINES</code> is defined. The <code class="calibre23">math.h</code> header defines a wealth of other mathematical constants that you can see if you place the cursor in <code class="calibre23">math.h</code> in the code and press Ctrl+Shift+G. The volume is calculated as the height multiplied by the area of the base. Notice that the <code class="calibre23">CBox</code> class redefines the <code class="calibre23">showVolume()</code> function, but the <code class="calibre23">CCan</code> class does not. You will see the effect of this in the output.</p>
<p class="calibre20">You can exercise these classes with the following source file:</p>
<pre class="calibre28"><code class="calibre23">// Ex9_10.cpp
// Using an abstract class
#include "Box.h"                       // For CBox and CContainer
#include "Can.h"                       // For CCan (and CContainer)
#include &lt;iostream&gt;                    // For stream I/O
        
int main()
{
  // Pointer to abstract base class
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="464" id="calibre_link-926" class="calibre14"></span>// initialized with address of CBox object
  CContainer* pC1 {new CBox {2.0, 3.0, 4.0}};
        
  // Pointer to abstract base class
  // initialized with address of CCan object
  CContainer* pC2 {new CCan {6.5, 3.0}};
        
  pC1-&gt;showVolume();                   // Output the volumes of the two
  pC2-&gt;showVolume();                   // objects pointed to
        
  delete pC1;                          // Now clean up ... 
  delete pC2;                          // ... the free store
        
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You define two pointers to the base class, <code class="calibre23">CContainer</code>. Although you can’t define <code class="calibre23">CContainer</code> objects (because <code class="calibre23">CContainer</code> is an abstract class), you can still define pointers of type <code class="calibre23">CContainer*</code>, which you can use to store the address of any object whose type is a direct or indirect subclass of <code class="calibre23">CContainer</code>. The pointer <code class="calibre23">pC1</code> is assigned the address of a <code class="calibre23">CBox</code> object created in the free store by the operator <code class="calibre23">new</code>. The second pointer is assigned the address of a <code class="calibre23">CCan</code> object in a similar manner.</p>
<p class="calibre20">Of course, because you created the derived class objects dynamically, you must use the <code class="calibre23">delete</code> operator to clean up the free store when you have finished with them. You learned about <code class="calibre23">delete</code> back in Chapter 4.</p>
<p class="calibre20">The output produced by this example is as follows:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
Volume is 45.9458</code></pre>
<p class="calibre20">Because you defined <code class="calibre23">showVolume()</code> in the <code class="calibre23">CBox</code> class, the derived class version of the function is called for the <code class="calibre23">CBox</code> object. You did not define this function in the <code class="calibre23">CCan</code> class, so the base class version that <code class="calibre23">CCan</code> inherits is called for the <code class="calibre23">CCan</code> object. Because <code class="calibre23">volume()</code> is a virtual function that is implemented in both derived classes (necessarily, because it is a pure virtual function in the base class), the call to it is resolved when the program executes by selecting the version from the class of the object being pointed to. Thus, for the pointer <code class="calibre23">pC1</code>, the <code class="calibre23">CBox</code> version is called and for <code class="calibre23">pC2</code> the <code class="calibre23">CCan</code> version is called. Therefore you obtain the correct result in each case.</p>
<p class="calibre20">You could equally well have used one pointer and assigned the address of the <code class="calibre23">CCan</code> object to it after calling the <code class="calibre23">volume()</code> function for the <code class="calibre23">CBox</code> object. A base class pointer can contain the address of any derived class object, even when several different classes are derived from the same base class, and so you can have automatic selection of the appropriate virtual function across a whole range of derived classes. Impressive stuff, isn’t it?</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Indirect Base Classes</h3>
<p class="calibre13">At the beginning of this chapter, I said that a base class for a given class could, in turn, be derived from another, “more” base class. A small extension of the last example will illustrate this, as well as demonstrating the use of a virtual function across a second level of inheritance.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="465" id="calibre_link-927" class="calibre24"></span>TRY IT OUT: More Than One Level of Inheritance</h3>
<p class="calibre20">All you need to do is to add the <code class="calibre23">CGlassBox</code> class to the classes you have from the previous example. The relationship between the classes you will then have is illustrated in <a id="calibre_link-200" href="#calibre_link-199" class="calibre3">Figure 9-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000050.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-199" href="#calibre_link-200" class="calibre3">FIGURE 9-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><code class="calibre23">CGlassBox</code> is derived from <code class="calibre23">CBox</code> exactly as before, but you omit the derived class version of <code class="calibre23">showVolume()</code> to show that the base class version still propagates through the derived classes. With the class hierarchy shown in <a href="#calibre_link-199" class="calibre3">Figure 9-5</a>, <code class="calibre23">CContainer</code> is an indirect base of <code class="calibre23">CGlassBox</code>, and a direct base of the <code class="calibre23">CBox</code> and <code class="calibre23">CCan</code> classes.</p>
<p class="calibre20">The <code class="calibre23">GlassBox.h</code> header file for the example contains:</p>
<pre class="calibre28"><code class="calibre23">// GlassBox.h for Ex9_11
#pragma once
#include "Box.h"                       // For CBox
        
class CGlassBox: public CBox           // Derived class
{
public:
      
  // Function to calculate volume of a CGlassBox allowing 15% for packing
  virtual double volume() const override
  { return 0.85*m_Length*m_Width*m_Height; }
      
  // Constructor
  CGlassBox(double lv, double wv, double hv): CBox {lv, wv, hv} {}
};</code></pre>
<p class="calibre20">The <code class="calibre23">Container.h, Can.h</code>, and <code class="calibre23">Box.h</code> header files contain the same code as those in the previous example, <code class="calibre23">Ex9_10</code>.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="466" id="calibre_link-928" class="calibre14"></span>The main source file for the new example is as follows:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_11.cpp</b>
<b class="calibre12">// Using an abstract class with multiple levels of inheritance</b>
#include "Box.h"                        // For CBox and CContainer
#include "Can.h"                        // For CCan (and CContainer)
<b class="calibre12">#include</b> "<b class="calibre12">GlassBox.h"                   // For CGlassBox (and CBox and CContainer)</b>
#include &lt;iostream&gt;                     // For stream I/O

<b class="calibre12">int main()</b>
<b class="calibre12">{</b>
  <b class="calibre12">// Pointer to abstract base class initialized with CBox object address</b>
  <b class="calibre12">CContainer* pC1 {new CBox {2.0, 3.0, 4.0}};</b>
  <b class="calibre12">CCan myCan {6.5, 3.0};                // Define CCan object</b>
  <b class="calibre12">CGlassBox myGlassBox {2.0, 3.0, 4.0}; // Define CGlassBox object</b>
  <b class="calibre12">pC1-&gt;showVolume();                    // Output the volume of CBox</b>
  <b class="calibre12">delete pC1;                           // Now clean up the free store</b>

  <b class="calibre12">pC1 = &amp;myCan;                         // Put myCan address in pointer</b>
  <b class="calibre12">pC1-&gt;showVolume();                    // Output the volume of CCan</b>
  <b class="calibre12">pC1 = &amp;myGlassBox;                    // Put myGlassBox address in pointer</b>
  <b class="calibre12">pC1-&gt;showVolume();                    // Output the volume of CGlassBox</b>

  <b class="calibre12">return 0;</b>
<b class="calibre12">}</b></code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You have the three-level class hierarchy shown in <a href="#calibre_link-199" class="calibre3">Figure 9-5</a> with <code class="calibre23">CContainer</code> as an abstract base class because it contains the pure virtual function, <code class="calibre23">volume()</code>. The <code class="calibre23">main()</code> function now calls <code class="calibre23">showVolume()</code>three times using the same base class pointer, but with the pointer containing the address of an object of a different type each time. Because <code class="calibre23">showVolume()</code> is not defined in either <code class="calibre23">CCan</code> or <code class="calibre23">CGlassBox</code>, the inherited version is called in each instance. A separate branch from the base <code class="calibre23">CContainer</code> defines the derived class <code class="calibre23">CCan</code> so <code class="calibre23">CCan</code> inherits <code class="calibre23">showVolume()</code> from <code class="calibre23">CContainer</code> and <code class="calibre23">CGlassBox</code> inherits the function from <code class="calibre23">CBox</code>.</p>
<p class="calibre20">The example produces this output:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
Volume is 45.9458
CBox usable volume is 20.4</code></pre>
<p class="calibre20">The output shows that one of the three different versions of the function <code class="calibre23">volume()</code> is selected for execution according to the type of object involved.</p>
<p class="calibre20">Note that you must delete the <code class="calibre23">CBox</code> object from the free store before you assign another value to the pointer. If you don’t do this, you won’t be able to clean up the free store, because you would have no record of the address of the original object. This is an easy mistake to make when reassigning pointers and using the free store. You’ll be able to avoid the possibility of this mistake by using smart pointers that you’ll learn about in Chapter 10.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="467" id="calibre_link-929" class="calibre24"></span>Virtual Destructors</h3>
<p class="calibre13">A problem that arises when dealing with objects of derived classes using a pointer to a base class is that the correct destructor may not be called. You can see this happening by modifying the last example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Calling the Wrong Destructor</h3>
<p class="calibre20">You need to add a public destructor that outputs a message to each of the classes in the example so that you can track which destructor is called when the objects are destroyed. The destructor for the <code class="calibre23">CContainer</code> class in the <code class="calibre23">Container.h</code> file for this example is:</p>
<pre class="calibre28"><code class="calibre23">~CContainer()
{ std::cout &lt;&lt; "CContainer destructor called" &lt;&lt; std::endl; }</code></pre>
<p class="calibre20">The destructor for the <code class="calibre23">CCan</code> class in <code class="calibre23">Can.h</code> in the example is:</p>
<pre class="calibre28"><code class="calibre23">~CCan()
{ std::cout &lt;&lt; "CCan destructor called" &lt;&lt; std::endl; }</code></pre>
<p class="calibre20">The <code class="calibre23">CBox</code> class destructor in <code class="calibre23">Box.h</code> should be:</p>
<pre class="calibre28"><code class="calibre23">~CBox()
{ std::cout &lt;&lt; "CBox destructor called" &lt;&lt; std::endl; }</code></pre>
<p class="calibre20">The <code class="calibre23">CGlassBox</code> destructor in the <code class="calibre23">GlassBox.h</code> header file should be:</p>
<pre class="calibre28"><code class="calibre23">~CGlassBox()
{ std::cout &lt;&lt; "CGlassBox destructor called" &lt;&lt; std::endl; }</code></pre>
<p class="calibre20">Finally, the source file <code class="calibre23">Ex9_12.cpp</code> for the program should be:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Ex9_12.cpp</b>
<b class="calibre12">// Destructor calls with derived classes using objects via a base class pointer</b>
#include "Box.h"                           // For CBox and CContainer
#include "Can.h"                           // For CCan (and CContainer)
#include "GlassBox.h"                       // For CGlassBox (and CBox, CContainer)
#include &lt;iostream&gt;                        // For stream I/O
 
int main()
{
  // Pointer to abstract base class initialized with CBox object address
  CContainer* pC1 {new CBox{2.0, 3.0, 4.0}};
  CCan myCan {6.5, 3.0};
  CGlassBox myGlassBox {2.0, 3.0, 4.0};
  pC1-&gt;showVolume();                       // Output the volume of CBox
  <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">Delete CBox" &lt;&lt; std::endl;</b>
  delete pC1;                              // Now clean up the free store
  <b class="calibre12">pC1 = new CGlassBox {4.0, 5.0, 6.0};      // Create CGlassBox dynamically</b>
  <b class="calibre12">pC1-&gt;showVolume();                        // ...output its volume...</b>
  <b class="calibre12">std::cout &lt;&lt;</b> "<b class="calibre12">Delete CGlassBox" &lt;&lt; std::endl;</b>
  <b class="calibre12">delete pC1;                               // ...and delete it</b>
  pC1 = &amp;myCan;                            // Get myCan address in pointer
  pC1-&gt;showVolume();                       // Output the volume of CCan
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="468" id="calibre_link-930" class="calibre14"></span>pC1 = &amp;myGlassBox;                       // Get myGlassBox address in pointer
  pC1-&gt;showVolume();                     // Output the volume of CGlassBox
 
  return 0;
}</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Apart from adding a destructor to each class that outputs a message to the effect that it was called, the only other change is a couple of additions to <code class="calibre23">main()</code>. There are additional statements that create a <code class="calibre23">CGlassBox</code> object dynamically, output its volume, and then delete it. There are messages displayed to indicate when the dynamically created objects are deleted. The output generated by this example is:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
Delete CBox
CContainer destructor called
CBox usable volume is 102
Delete CGlassBox
CContainer destructor called
Volume is 45.9458
CBox usable volume is 20.4
CGlassBox destructor called
CBox destructor called
CContainer destructor called
CCan destructor called
CContainer destructor called</code></pre>
<p class="calibre20">You can see that when you delete the <code class="calibre23">CBox</code> object pointed to by <code class="calibre23">pC1</code>, the destructor for the base class <code class="calibre23">CContainer</code> is called, but there is no call of the <code class="calibre23">CBox</code> destructor. Similarly, when the <code class="calibre23">CGlassBox</code> object is deleted, the destructor for the base class <code class="calibre23">CContainer</code> is called but not the <code class="calibre23">CGlassBox</code> or <code class="calibre23">CBox</code> destructors. For the <code class="calibre23">myCan</code> and <code class="calibre23">myGlassBox</code> objects that are created statically, the correct destructor calls occur with the derived class destructor being called first, followed by the base class destructor. For the <code class="calibre23">myGlassBox</code> object, there are three destructor calls: first, the destructor for the derived class, then the direct base destructor, and finally the indirect base destructor.</p>
<p class="calibre20">All the problems are with objects created in the free store. In both cases, the wrong destructor is called. The reason for this is that the linkage to the destructors is resolved statically, at compile time. For the automatic objects, there is no problem &mdash; the compiler knows what they are and arranges for the correct destructors to be called. With objects created dynamically and accessed through a pointer, things are different. The only information that the compiler has when the <code class="calibre23">delete</code> operation is compiled is that the pointer type is a pointer to the base class. The type of object the pointer is pointing to is unknown to the compiler because this is determined when the program executes. The compiler, therefore, simply ensures that the <code class="calibre23">delete</code> operation is set up to call the base class destructor. In a real application, this can cause a lot of problems, with bits of objects left strewn around the free store and possibly more serious problems, depending on the nature of the objects.</p>
<p class="calibre20">The solution is simple. You need the calls to be resolved dynamically &mdash; as the program is executed. You can organize this by using <i class="calibre15">virtual destructors</i>. As I said when I first discussed virtual functions, it’s sufficient to declare a base class function as virtual to ensure that all functions in any derived classes with the same name, parameter list, and return type are virtual as well. This applies to destructors just <span {http://www.idpf.org/2007/ops}type="pagebreak" title="469" id="calibre_link-931" class="calibre14"></span>as it does to ordinary member functions. You need to add the keyword <code class="calibre23">virtual</code> to the definition of the destructor in the class <code class="calibre23">CContainer</code> in <code class="calibre23">Container.h</code>:</p>
<pre class="calibre28"><code class="calibre23">class CContainer                   // Generic base class for containers
{
 public:
      
   // Destructor
   <b class="calibre12">virtual ~CContainer()</b>
   { std::cout &lt;&lt; "CContainer destructor called" &lt;&lt; std::endl; }
     
   // Rest of the class as before
};</code></pre>
<p class="calibre20">Now, the destructors in all the derived classes are automatically virtual, even though you don’t explicitly specify them as such. Of course, you’re free to specify them as virtual if you want the code to be absolutely clear.</p>
<p class="calibre20">If you rerun the example with this change, it produces the following output:</p>
<pre class="calibre28"><code class="calibre23">CBox usable volume is 24
Delete CBox
CBox destructor called
CContainer destructor called
CBox usable volume is 102
Delete CGlassBox
CGlassBox destructor called
CBox destructor called
CContainer destructor called
Volume is 45.9458
CBox usable volume is 20.4
CGlassBox destructor called
CBox destructor called
CContainer destructor called
CCan destructor called
CContainer destructor called</code></pre>
<p class="calibre20">As you can see, all the objects are now destroyed with a proper sequence of destructor calls. Destroying the dynamic objects produces the same sequence of destructor calls as the automatic objects of the same type.</p>
<p class="calibre20">The question may arise in your mind at this point, can constructors be declared as virtual? The answer is no &mdash; only destructors and other member functions.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">It’s a good idea to declare your base class destructor as virtual as a matter of course when using inheritance. There is a small overhead in the execution of the destructors but you won’t notice it in the majority of circumstances. Using virtual destructors ensures that your objects will be properly destroyed and avoids potential program crashes that might otherwise occur.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-316" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="470" id="calibre_link-932" class="calibre18"></span>CASTING BETWEEN CLASS TYPES</h2>
<p class="calibre13">You have seen how you can store the address of a derived class object in a variable that is a pointer to a base class type, so a variable of type <code class="calibre23">CContainer*</code> can store the address of a <code class="calibre23">CBox</code> object for example. So if you have an address stored in a pointer of type <code class="calibre23">CContainer*</code>, can you cast it to type <code class="calibre23">CBox*</code>? Indeed, you can, and the <code class="calibre23">dynamic_cast</code> operator is specifically intended for this kind of operation. Here’s how it works:</p>
<pre class="calibre28"><code class="calibre23">CContainer* pContainer {new CGlassBox {2.0, 3.0, 4.0}};
CBox* pBox {dynamic_cast&lt;CBox*&gt;(pContainer)};
CGlassBox* pGlassBox {dynamic_cast&lt;CGlassBox*&gt;(pContainer)};</code></pre>
<p class="calibre13">The first statement stores the address of the <code class="calibre23">CGlassBox</code> object created on the heap in a base class pointer of type <code class="calibre23">CContainer*</code>. The second statement casts <code class="calibre23">pContainer</code> down the class hierarchy to type <code class="calibre23">CBox*</code>. The third statement casts the address in <code class="calibre23">pContainer</code> to its actual type, <code class="calibre23">CGlassBox*</code>.</p>
<p class="calibre13">You can apply the <code class="calibre23">dynamic_cast</code> operator to references as well as pointers. The difference between <code class="calibre23">dynamic_cast</code> and <code class="calibre23">static_cast</code> is that <code class="calibre23">dynamic_cast</code> checks the validity of a cast at run time, whereas the <code class="calibre23">static_cast</code> operator does not. If a <code class="calibre23">dynamic_cast</code> operation is not valid, the result is <code class="calibre23">nullptr</code>. The compiler relies on the programmer for the validity of a <code class="calibre23">static_cast</code> operation, so you should always use <code class="calibre23">dynamic_cast</code> for casting up and down a class hierarchy and check for a <code class="calibre23">nullptr</code> result if you want to avoid abrupt termination of your program.</p>
<section class="toclist">
<h3 class="calibre21">Defining Conversion Operators</h3>
<p class="calibre13">You can define operator functions in a class that convert an object to another type. The conversion can be to a fundamental type or a class type. For example, suppose you want to test whether a <code class="calibre23">CBox</code> object has dimensions other than the defaults of 1. You could provide for this by defining an operator function for <code class="calibre23">CBox</code> objects for conversion to type <code class="calibre23">bool</code>. For example, you could define the following member within the <code class="calibre23">CBox</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">operator bool()
{  return m_Length == 1 &amp;&amp; m_Width == 1 &amp;&amp; m_Height == 1;  }</code></pre>
<p class="calibre13">This defines the function <code class="calibre23">operator bool()</code>. The function returns <code class="calibre23">true</code> when all the dimensions of the <code class="calibre23">CBox</code> object are 1 and <code class="calibre23">false</code> otherwise. The name of an operator function for conversion is always the <code class="calibre23">operator</code> keyword followed by the destination type name. The destination type in the function name is the return type, so no return type needs to be specified in addition.</p>
<p class="calibre13">With the <code class="calibre23">operator bool()</code> function defined in the <code class="calibre23">CBox</code> class you could write this:</p>
<pre class="calibre28"><code class="calibre23">CBox box1;                            // Calls default constructor
if(box1)                              // Implicit conversion of box1 to bool
  std::cout &lt;&lt; "box1 has default dimensions." &lt;&lt; std::endl;</code></pre>
<p class="calibre13">The <code class="calibre23">if</code> expression has to be type <code class="calibre23">bool</code> so the compiler will insert a call of the <code class="calibre23">operator bool()</code> function for <code class="calibre23">box1</code> to make the <code class="calibre23">if</code> expression <code class="calibre23">box1.operator bool()</code>.</p>
<p class="calibre13">You can also write the following:</p>
<pre class="calibre28"><code class="calibre23">CBox box2 {1, 2, 3};
bool isDefault {true};
isDefault = box2;                     // Implicit conversion to bool</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="471" id="calibre_link-933" class="calibre14"></span>Assigning the value of <code class="calibre23">box2</code> to <code class="calibre23">isDefault</code> also requires an implicit conversion so the operator function call will be inserted. Of course, you can write explicit conversions, too:</p>
<pre class="calibre28"><code class="calibre23">isDefault = static_cast&lt;bool&gt;(box1);   // Explicit conversion</code></pre>
<p class="calibre13">This statement also calls <code class="calibre23">operator bool()</code> so it is equivalent to:</p>
<pre class="calibre28"><code class="calibre23">isDefault = box1.operator bool();</code></pre>
</section>
<section class="toclist">
<h3 class="calibre21">Explicit Conversion Operators</h3>
<p class="calibre13">It may be that you do not want to allow implicit conversions that use a conversion operator function. This is particularly the case for conversions between class types. You can prevent this by prefixing the conversion operator function with the <code class="calibre23">explicit</code> keyword. Now compilation of any statement requiring an implicit type conversion will fail with an error message.</p>
<p class="calibre13">Only explicit conversion will compile correctly.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-317" class="calibre3"></a>NESTED CLASSES</h2>
<p class="calibre13">You can put the definition of one class inside the definition of another, in which case, you have defined a <i class="calibre15">nested class</i>. A nested class has the appearance of being a static member of the class that encloses it and is subject to the member access specifiers, just like any other member of the class. If you place a nested class definition in the private section of a class, the class can only be referenced from within the scope of the enclosing class. If you specify a nested class as <code class="calibre23">public</code>, the class is accessible from outside the enclosing class, but the nested class name must be qualified by the outer class name in such circumstances.</p>
<p class="calibre13">A nested class has free access to all the static members of the enclosing class. All the instance members can be accessed through an object of the enclosing class type, or a pointer or reference to an object. The enclosing class can only access the public members of the nested class, but in a nested class that is private in the enclosing class, the members are frequently declared as <code class="calibre23">public</code> to allow functions in the enclosing class free access to the entire nested class.</p>
<p class="calibre13">A nested class is particularly useful when you want to define a type that is only to be used within another type. In this case the nested class can be declared as <code class="calibre23">private</code>. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">// A push-down stack to store CBox objects
#pragma once
class CBox;                           // Forward class declaration
 
class CStack
{
private:
  // Defines items to store in the stack
  struct CItem
  {
    CBox* pBox;                       // Pointer to the object in this node
    CItem* pNext;                     // Pointer to next item in the stack or null
        
    // Constructor
    CItem(CBox* pB, CItem* pN): pBox {pB}, pNext {pN} {}
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="472" id="calibre_link-934" class="calibre14"></span>};
        
  CItem* pTop {};                     // Pointer to item that is at the top
        
public:
  CStack()=default;                   // Constructor
 
  // Inhibit copy construction and assignment
  CStack(const CStack&amp; stack) = delete;
  CStack&amp; operator=(const CStack&amp; stack) = delete;
        
  // Push a Box object onto the stack
  void push(CBox* pBox)
  {
    pTop = new CItem(pBox, pTop);     // Create new item and make it the top
  }
        
  // Pop an object off the stack
  CBox* pop()
  {
    if(!pTop)                         // If the stack is empty
      return nullptr;                 // return null
        
    CBox* pBox = pTop-&gt;pBox;          // Get box from item
    CItem* pTemp = pTop;              // Save address of the top item
    pTop = pTop-&gt;pNext;               // Make next item the top
    delete pTemp;                     // Delete old top item from the heap
    return pBox;
  }
        
  // Destructor
  virtual ~CStack()
  {
    CItem* pTemp {};
    while(pTop)                       // While pTop not null
    {
      pTemp = pTop;
      pTop = pTop-&gt;pNext;
      delete pTemp;
    }
  }
};</code></pre>
<p class="calibre13">The <code class="calibre23">CStack</code> class defines a push-down stack for storing <code class="calibre23">CBox</code> objects. To be absolutely precise, it stores pointers to <code class="calibre23">CBox</code> objects so the objects pointed to are still the responsibility of the code using the <code class="calibre23">CStack</code> class. The nested <code class="calibre23">struct, CItem</code>, defines the items that are held in the stack. I chose to define <code class="calibre23">CItem</code> as a nested <code class="calibre23">struct</code> rather than a nested class because members of a <code class="calibre23">struct</code> are <code class="calibre23">public</code> by default. You could define <code class="calibre23">CItem</code> as a class and then specify the members as public so they can be accessed from the functions in <code class="calibre23">CStack</code>. The stack is implemented as a linked list of <code class="calibre23">CItem</code> objects, where each object stores a pointer to a <code class="calibre23">CBox</code> object plus the address of the next <code class="calibre23">CItem</code> object down in the stack. The <code class="calibre23">push()</code> function in <code class="calibre23">CStack</code> pushes a <code class="calibre23">CBox</code> object onto the stack, and the <code class="calibre23">pop()</code> function pops an object off the stack.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="473" id="calibre_link-935" class="calibre14"></span>Pushing an object onto the stack creates a new <code class="calibre23">CItem</code> object holding the address of the object to be stored plus the address of the previous top item. The top item is <code class="calibre23">nullptr</code> initially. Popping an object off the stack returns the address of the object in <code class="calibre23">pTop</code>. The top item is deleted and the next item becomes the top of the stack.</p>
<p class="calibre13">Because a <code class="calibre23">CStack</code> object creates <code class="calibre23">CItem</code> objects on the heap, we need a destructor to delete any remaining <code class="calibre23">CItem</code> objects when a <code class="calibre23">CStack</code> object is destroyed. The process works down through the stack, deleting the top item after the address of the next item has been saved in <code class="calibre23">pTop</code>. Let’s see if it works.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Nested Class</h3>
<p class="calibre20">This example uses the <code class="calibre23">CContainer, CBox</code>, and <code class="calibre23">CGlassBox</code> classes from <code class="calibre23">Ex9_12</code>, so create an empty Win32 console project, <code class="calibre23">Ex9_13</code>, and add the header files containing those class definitions to it. Then add <code class="calibre23">Stack.h</code> to the project containing the definition of the <code class="calibre23">CStack</code> class from the previous section, and add <code class="calibre23">Ex9_13.cpp</code> to the project with the following contents:</p>
<pre class="calibre28"><code class="calibre23">// Ex9_13.cpp
// Using a nested class to define a stack
#include "Box.h"                    // For CBox and CContainer
#include "GlassBox.h"               // For CGlassBox (and CBox and CContainer)
#include "Stack.h"                  // For the stack class with nested struct CItem 
#include &lt;iostream&gt;                 // For stream I/O
        
int main()
{
  CBox* pBoxes[] { new CBox{2.0, 3.0, 4.0},
                   new CGlassBox{2.0, 3.0, 4.0},
                   new CBox{4.0, 5.0, 6.0},
                   new CGlassBox{4.0, 5.0, 6.0}
                 };
  std::cout &lt;&lt; "The boxes have the following volumes:\n";
  for (const CBox* pBox : pBoxes)
    pBox-&gt;showVolume();                // Output the volume of a box
 
  std::cout &lt;&lt; "\nNow pushing the boxes on the stack...\n\n";
  CStack stack;                        // Create the stack
  for (CBox* pBox : pBoxes)            // Store box pointers in the stack
    stack.push(pBox);
 
  std::cout &lt;&lt; "Popping the boxes off the stack presents them in reverse order:\n";
  CBox* pTemp {};
  while(pTemp = stack.pop())
    pTemp-&gt;showVolume();
 
  for (CBox* pBox : pBoxes)            // Delete the boxes
    delete pBox;
  return 0;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="474" id="calibre_link-936" class="calibre14"></span>I removed the output statements from the <code class="calibre23">CContainer, CBox</code>, and <code class="calibre23">CGlassBox</code> class destructors. The output from this example is:</p>
<pre class="calibre28"><code class="calibre23">The boxes have the following volumes:
CBox usable volume is 24
CBox usable volume is 20.4
CBox usable volume is 120
CBox usable volume is 102
        
Now pushing the boxes on the stack...
 
Popping the boxes off the stack presents them in reverse order:
CBox usable volume is 102
CBox usable volume is 120
CBox usable volume is 20.4
CBox usable volume is 24</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">An array of pointers to <code class="calibre23">CBox</code> objects can store addresses of <code class="calibre23">CBox</code> objects or addresses of any type that is derived from <code class="calibre23">CBox</code>. The <code class="calibre23">pBoxes</code> array is initialized with the addresses of four objects created on the heap:</p>
<pre class="calibre28"><code class="calibre23">  CBox* pBoxes[] { new CBox{2.0, 3.0, 4.0},
                   new CGlassBox{2.0, 3.0, 4.0},
                   new CBox{4.0, 5.0, 6.0},
                   new CGlassBox{4.0, 5.0, 6.0}
                 };</code></pre>
<p class="calibre20">There are two <code class="calibre23">CBox</code> objects and two <code class="calibre23">CGlassBox</code> objects with the same dimensions as the <code class="calibre23">CBox</code> objects.</p>
<p class="calibre20">You list the volumes of the objects in the <code class="calibre23">pBoxes</code> array in a range-based <code class="calibre23">for</code> loop. You then create a <code class="calibre23">CStack</code> object and push the pointers to the objects onto the stack in another range-based <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  CStack stack;                        // Create the stack
  for (CBox* pBox : pBoxes)            // Store box pointers in the stack
    stack.push(pBox);</code></pre>
<p class="calibre20">Each element in the <code class="calibre23">pBoxes</code> array is pushed onto the stack by passing the element to the <code class="calibre23">push()</code> member for the <code class="calibre23">stack</code> object. This results in the first element from the array being at the bottom of the stack, and the last element at the top.</p>
<p class="calibre20">You pop the objects off the stack in a <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">CBox* pTemp {};
while(pTemp = stack.pop())
  pTemp-&gt;showVolume();</code></pre>
<p class="calibre20">The <code class="calibre23">pop()</code> function returns the address of the element at the top of the stack, and you use this to call the <code class="calibre23">showVolume()</code> function for the object. The loop ends when the <code class="calibre23">pop()</code> function returns <code class="calibre23">nullptr</code>. Because the last element was at the top of the stack, the loop lists the volumes of the objects in reverse order. From the output, you can see that the <code class="calibre23">CStack</code> class does, indeed, implement a stack using a nested <code class="calibre23">struct</code> to define the items to be stored in the stack.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-318" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="475" id="calibre_link-937" class="calibre18"></span>SUMMARY</h2>
<p class="calibre13">This chapter covered the principal ideas involved in using inheritance.</p>
<p class="calibre13">You have now gone through all of the important language features of C++. It’s important that you feel comfortable with the mechanisms for defining and deriving classes and the process of inheritance. Windows programming with Visual C++ involves extensive use of all these concepts.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">What’s wrong with the following code?
<pre class="calibre28"><code class="calibre23">class CBadClass
{
private:
   int len;
   char* p;
public:
   CBadClass(const char* str): p {str}, len {strlen(p)} {}
   CBadClass(){}
};</code></pre></li>
<li class="calibre6">Suppose you have a <code class="calibre23">CBird</code> class that you want to use as a base class for deriving a hierarchy of bird classes:
<pre class="calibre28"><code class="calibre23">class CBird
{
protected:
   int wingSpan {};
   int eggSize {};
   int airSpeed {};
   int altitude {};
public:
   virtual void fly() { altitude = 100; }
};</code></pre>
<ol class="none">
<li class="calibre6">Is it reasonable to create a <code class="calibre23">CHawk</code> by deriving from <code class="calibre23">CBird</code>? How about a <code class="calibre23">COstrich</code>? Justify your answers. Derive an avian hierarchy that can cope with both of these birds.</li></ol></li>
<li class="calibre6">Given the following class,
<pre class="calibre28"><code class="calibre23">class CBase
{
protected:
   int m_anInt;
public:
   CBase(int n): m_anInt {n} { std::cout &lt;&lt; "Base constructor\n"; }
   virtual void print() const = 0;
};</code></pre>
<ol class="none">
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="476" id="calibre_link-938" class="calibre14"></span>what sort of class is <code class="calibre23">CBase</code> and why? Derive a class from <code class="calibre23">CBase</code> that sets the value of <code class="calibre23">m_anInt</code> when an object is created and prints it on request. Write a test program to verify that your class is correct.</li></ol></li>
<li class="calibre6">A binary tree is a structure made up of nodes, where each node contains a pointer to a “left” node and a pointer to a “right” node plus a data item, as shown in <a id="calibre_link-202" href="#calibre_link-201" class="calibre3">Figure 9-6</a>.
<figure class="calibre16">
<img class="center" src="images/000008.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-201" href="#calibre_link-202" class="calibre3">FIGURE 9-6</a></b></span></p>
</figcaption>
</figure>
<ol class="none">
<li class="calibre6">The tree starts with a root node, and this is the starting point for accessing the nodes in the tree. Either or both pointers in a node can be <code class="calibre23">nullptr</code>. <a href="#calibre_link-201" class="calibre3">Figure 9-6</a> shows an ordered binary tree, which is a tree organized so that the value of each node is always greater than or equal to the left node and less than or equal to the right node.</li>
<li class="calibre6">Define a class that defines an ordered binary tree that stores integer values. You also need to define a <code class="calibre23">Node</code> class, but that can be an inner class to the <code class="calibre23">BinaryTree</code> class. Write a program to test the operation of your <code class="calibre23">BinaryTree</code> class by storing an arbitrary sequence of integers in it and retrieving and outputting them in ascending sequence.</li>
<li class="calibre6">Hint: Don’t be afraid to use recursion.</li></ol></li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="477" id="calibre_link-939" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Inherited members of a class</b></td>
<td class="calibre32">A derived class inherits all the members of a base class except for constructors, the destructor, and the overloaded assignment operator.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Accessibility of inherited members of a class</b></td>
<td class="calibre32">Members of a base class declared as <code class="calibre23">private</code> in the base class are not accessible in any derived class. To obtain the effect of the keyword <code class="calibre23">private</code> but allow access in a derived class, you should use the keyword <code class="calibre23">protected</code> in place of <code class="calibre23">private</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Access specifiers for a base class</b></td>
<td class="calibre32">A base class can be specified for a derived class with the keyword <code class="calibre23">public, private</code>, or <code class="calibre23">protected</code>. If none is specified, the default is <code class="calibre23">private</code>. Depending on the keyword specified for a base, the access level of the inherited members may be modified.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Constructors in derived classes</b></td>
<td class="calibre32">If you write a derived class constructor, you must arrange for data members of the base class to be initialized properly, as well as those of the derived class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Virtual functions</b></td>
<td class="calibre32">A function in a base class may be declared as <code class="calibre23">virtual</code>. This allows other definitions of the function appearing in derived classes to be selected at execution time, depending on the type of object for which the function call is made.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Using <code class="calibre23">override</code></b></td>
<td class="calibre32">When you define a virtual function in a derived class with the <code class="calibre23">override</code> modifier specified, the compiler will verify that a direct or indirect base class contains a virtual function with the same signature, and will issue an error message if this is not the case.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Final function members of a class</b></td>
<td class="calibre32">If a member function of a class is specified using the <code class="calibre23">final</code> modifier, a derived class cannot override the function. Any attempt to override the function will result in a compiler error message.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Final classes</b></td>
<td class="calibre32">A class that is <code class="calibre23">final</code> cannot be used as a base for another class. Attempting to use a <code class="calibre23">final</code> class as a base will result in a compiler error message.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Virtual destructors</b></td>
<td class="calibre32">You should declare class destructors as <code class="calibre23">virtual</code> in a class that can be a base for other classes. This ensures correct selection of a destructor for dynamically-created derived class objects.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="478" id="calibre_link-940" class="calibre14"></span><b class="calibre12"><code class="calibre23">friend</code> classes</b></td>
<td class="calibre32">A class may be designated as a <code class="calibre23">friend</code> of another class. In this case, all the member functions of the <code class="calibre23">friend</code> class may access all the members of the other class. If class <code class="calibre23">A</code> is a <code class="calibre23">friend</code> of <code class="calibre23">B</code>, class <code class="calibre23">B</code> is not a <code class="calibre23">friend</code> of <code class="calibre23">A</code> unless it has been declared as such.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Pure virtual functions</b></td>
<td class="calibre32">A virtual function in a base class can be specified as pure by placing <code class="calibre23">=0</code> at the end of the function declaration. The class then is an abstract class for which no objects can be created. In any derived class, all pure virtual functions inherited from the base class must be defined; if not, the derived class is abstract.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-319">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2323" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="479" id="calibre_link-941" class="calibre9"></span><span class="chapternumber">Chapter 10</span><br class="calibre10" /><span class="chapternumber">The Standard Template Library</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The capabilities offered by the Standard Template Library (STL)</li>
<li class="calibre6">How to use smart pointers</li>
<li class="calibre6">How to create and use containers</li>
<li class="calibre6">How to use iterators with containers</li>
<li class="calibre6">The types of algorithms that are available with the STL, and how you can apply the more common ones</li>
<li class="calibre6">How to use function objects with the STL</li>
<li class="calibre6">How to define lambda expressions and use them with the STL</li>
<li class="calibre6">How to use polymorphic function wrappers with lambda expressions</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 10 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-320" class="calibre3"></a>WHAT IS THE STANDARD TEMPLATE LIBRARY?</h2>
<p class="calibre13">As its name implies, the Standard Template Library is a library of standard class and function templates. You can use these templates to create a wide range of powerful general-purpose classes for organizing your data, as well as functions for processing that data in various ways. The STL is defined by the standard for C++ and is therefore always available with a conforming compiler. Because of its broad applicability, the STL can greatly simplify programming in many of your applications.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="480" id="calibre_link-942" class="calibre14"></span>I’ll first explain, in general terms, the kinds of resources the STL provides and how they interact with one another, before diving into the details of working examples. The STL contains six kinds of components: containers, container adapters, iterators, algorithms, function objects, and function adapters. Because they are part of the standard library, the names of the STL components are all defined within the <code class="calibre23">std</code> namespace.</p>
<p class="calibre13">The STL is a very large library, some of which is highly specialized, and to cover the contents fully would require a book in its own right. In this chapter, I’ll introduce the fundamentals of how you use the STL and describe the more commonly used capabilities. Let’s start with containers.</p>
<section class="toclist">
<h3 class="calibre21">Containers</h3>
<p class="calibre13">Containers are objects that you use to store and organize other objects. A class that implements a linked list is an example of a container. You create a container class from an STL template by supplying the type of the object that you intend to store. For example, <code class="calibre23">vector&lt;T&gt;</code> is a template for a container that is a linear array that automatically increases in size when necessary. <code class="calibre23">T</code> is the type parameter that specifies the type of objects to be stored. Here are a couple of statements that create <code class="calibre23">vector&lt;T&gt;</code> containers:</p>
<pre class="calibre28"><code class="calibre23">std::vector&lt;std::string&gt; strings;     // Stores object of type string
std::vector&lt;double&gt; data;             // Stores values of type double</code></pre>
<p class="calibre13">The first statement creates the <code class="calibre23">strings</code> container class that stores objects of type <code class="calibre23">string</code>, while the second statement creates the <code class="calibre23">data</code> container that stores values of type <code class="calibre23">double</code>.</p>
<p class="calibre13">You can store items of a fundamental type, or of any class type, in a container. If your type argument for a container template is a class type, the container can store objects of that type, or potentially of any derived class type. However, storing objects of a derived class type in a container created for base class objects will cause object slicing. Object slicing results in the derived part of an object being sliced off and occurs when you pass a derived class object by value for a parameter of a base class type. The base class copy constructor will be called to copy the derived class object, and because this constructor has no knowledge of derived class data members, they will not be copied. You can avoid slicing of objects of a derived type by storing pointers in the container. You can store pointers to a derived class type in a container that stores base class pointers.</p>
<p class="calibre13">The templates for the STL container classes are defined in the standard headers shown in the following table:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">HEADER FILE</b></th>
<th class="calibre32"><b class="calibre12">CONTENTS</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">vector</code></td>
<td class="calibre32">A <code class="calibre23">vector&lt;T&gt;</code> container represents an array that stores elements of type <code class="calibre23">T</code> that automatically increases its size when required. You can only add new elements efficiently to the end of a vector container.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">array</code></td>
<td class="calibre32">An <code class="calibre23">array&lt;T,N&gt;</code> container represents an array with a fixed number of elements, <code class="calibre23">N</code>, of type <code class="calibre23">T</code>. One advantage of this container over a normal array is that it is an object that knows its size, so when you pass an <code class="calibre23">array&lt;&gt;</code> container to a function it retains knowledge of the number of elements. An <code class="calibre23">array&lt;&gt;</code> container has an advantage over a <code class="calibre23">vector&lt;&gt;</code> in that it can be allocated entirely on the stack, whereas a <code class="calibre23">vector&lt;&gt;</code> needs heap access.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="481" id="calibre_link-943" class="calibre14"></span><code class="calibre23">deque</code></td>
<td class="calibre32">A <code class="calibre23">deque&lt;T&gt;</code> container implements a double-ended queue of elements of type <code class="calibre23">T</code>. This is equivalent to a vector with the capability for adding elements to the beginning efficiently.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">list</code></td>
<td class="calibre32">A <code class="calibre23">list&lt;T&gt;</code> container is a doubly-linked list of elements of type <code class="calibre23">T</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">forward_list</code></td>
<td class="calibre32">A <code class="calibre23">forward_list&lt;T&gt;</code> container is a singly linked list of elements of type <code class="calibre23">T</code>. Inserting and deleting elements in a <code class="calibre23">forward_list&lt;T&gt;</code> will be faster than in a <code class="calibre23">list&lt;T&gt;</code> as long as you are processing the list elements in a forward direction.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">map</code></td>
<td class="calibre32">A map<code class="calibre23">&lt;K,T&gt;</code> is an associative container that stores each object (of type <code class="calibre23">T</code>) with an associated key (of type <code class="calibre23">K</code>). Key/object pairs are stored in the map as objects of type <code class="calibre23">pair&lt;K,T&gt;</code>, which is another STL template type. The key determines where the key/object pair is located and is used to retrieve an object. Each key must be unique.<br class="calibre10" />This header also defines the <code class="calibre23">multimap&lt;K,T&gt;</code> container where the keys in the key/object pairs need not be unique.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unordered_map</code></td>
<td class="calibre32">An <code class="calibre23">unordered_map&lt;K,T&gt;</code> container is similar to a <code class="calibre23">map&lt;K,T&gt;</code>, except that the key/object pairs are in no particular order in the container. Pairs are grouped into buckets based on hash values produced from the keys.<br class="calibre10" />The <code class="calibre23">unordered_multimap&lt;K,T&gt;</code> container is also in this header. This differs from an <code class="calibre23">unordered_map&lt;K,T&gt;</code> container in that the keys do not have to be unique.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">set</code></td>
<td class="calibre32">A <code class="calibre23">set&lt;T&gt;</code> container is a map where each element serves as its own key. All elements in a set must be unique. A consequence of using an object as its own key is that you cannot change an object in a set; to change an object you must delete it and then insert the modified version. The elements in the container are ordered in ascending sequence by default but you can arrange to order them in any sequence you want.<br class="calibre10" />This header also defines the <code class="calibre23">multiset&lt;T&gt;</code> container, which is a set container where the elements need not be unique.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">unordered_set</code></td>
<td class="calibre32">An <code class="calibre23">unordered_set&lt;T&gt;</code> container is similar to a <code class="calibre23">set&lt;T&gt;</code> except that the elements are not ordered in any particular way, but are organized into buckets depending on the hash values of the elements. Like <code class="calibre23">set&lt;T&gt;</code>, the elements must be unique.<br class="calibre10" />The <code class="calibre23">unordered_multiset&lt;T&gt;</code> container that is also in this header is similar to <code class="calibre23">unordered_set&lt;T&gt;</code>, except that the elements can be duplicated.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">bitset</code></td>
<td class="calibre32">Defines the <code class="calibre23">bitset&lt;T&gt;</code> class template that represents a fixed number of bits. This is typically used to store flags that represent a set of states or conditions.</td>
</tr>
</tbody>
</table>
<p class="calibre13">All the template names are defined within the <code class="calibre23">std</code> namespace. <code class="calibre23">T</code> is the template type parameter for the type of elements stored in a container; where keys are used, <code class="calibre23">K</code> is the type of key.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="482" id="calibre_link-944" class="calibre14"></span>Allocators</h4>
<p class="calibre13">Most of the STL containers grow their size automatically to accommodate however many elements you store. Additional memory for these containers is made available by an object called an allocator that allocates space when required. You can optionally supply your own allocator object type through an additional type parameter. For example, the <code class="calibre23">vector&lt;T&gt;</code> template for creating a vector is really a <code class="calibre23">vector&lt;T, Allocator=allocator&lt;T&gt;&gt;</code> template, where the second type parameter, <code class="calibre23">Allocator</code>, is the allocator type. The second type parameter has the default value <code class="calibre23">allocator&lt;T&gt;</code> so this allocator type is used when you don’t specify your own.</p>
<p class="calibre13">Your allocator must be defined as a class template with a type parameter so that an instance of the allocator type can match the type of element stored in the container. For example, suppose you have defined your own class template, <code class="calibre23">My_Allocator&lt;T&gt;</code>, to provide memory to a container on request. You could then create a vector container that will use your allocator with the statement:</p>
<pre class="calibre28"><code class="calibre23">auto data = vector&lt;CBox, My_Allocator&lt;CBox&gt;&gt;();</code></pre>
<p class="calibre13">This container stores elements of type <code class="calibre23">CBox</code> with additional memory being allocated to the container by an object of type <code class="calibre23">My_Allocator&lt;CBox&gt;</code>.</p>
<p class="calibre13">So why would you want to define your own allocator when you can always use the default? The primary reason is efficiency in particular circumstances. For example, your application may lend itself to allocating a large chunk of memory on the heap that your allocator can issue piecemeal to the container without further dynamic memory operations. You can then release the memory in one go when the container is no longer required. I won’t be delving deeper into how you can define your own allocators. It’s not that it’s difficult &mdash; but I have to stop somewhere.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Comparators</h4>
<p class="calibre13">Some containers use a comparator object that is used to determine the order of elements within the container. For example, the <code class="calibre23">map&lt;K,T&gt;</code> container template is really:</p>
<pre class="calibre28"><code class="calibre23">map&lt;K, T, Compare=less&lt;K&gt;, Allocator=allocator&lt;pair&lt;K,T&gt;&gt; &gt;</code></pre>
<p class="calibre13"><code class="calibre23">allocator&lt;pair&lt;K,T&gt;&gt;</code> is an allocator type for key/object pairs and <code class="calibre23">Compare</code> is a function object type that acts as a comparator for keys of type <code class="calibre23">K</code> and determines the order in which the key/object pairs are stored. The last two type parameters have default values so you don’t have to supply them. The default comparator type, <code class="calibre23">less&lt;K&gt;</code>, is a function object template defined in the STL that implements a “less than” comparison between objects of type <code class="calibre23">K</code>. I will discuss function objects later in this chapter.</p>
<p class="calibre13">It is quite likely that you will want to specify your own comparator for a map. You might want ordering based on “greater than” comparisons for the keys you are using. Supplying your own allocator type is much less likely. For this reason the allocator type parameter for the template comes last.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">I won’t be discussing allocators or comparators further. I will therefore ignore the optional template type parameters for these in all subsequent discussions of containers.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="483" id="calibre_link-945" class="calibre24"></span>Container Adapters</h3>
<p class="calibre13">A <i class="calibre15">container adapter</i> is a template class that wraps an existing container class to provide a different, and typically more restricted, capability. The container adapters are defined in the headers in the following table.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">HEADER FILE</b></th>
<th class="calibre32"><b class="calibre12">CONTENTS</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">queue</code></td>
<td class="calibre32">A <code class="calibre23">queue&lt;T&gt;</code> container is defined by an adapter from a <code class="calibre23">deque&lt;T&gt;</code> container by default, but you could define it using a <code class="calibre23">list&lt;T&gt;</code> container. You can only access the first and last elements in a queue, and you can only add elements at the back and remove them from the front. Thus, a <code class="calibre23">queue&lt;T&gt;</code> container works more or less like the queue in your local coffee shop.<br class="calibre10" />This header also defines a <code class="calibre23">priority_queue&lt;T&gt;</code> container, which is a queue that orders the elements it contains so that the largest element is always at the front. Only the element at the front can be accessed or removed. A priority queue is defined by an adapter from a <code class="calibre23">vector&lt;T&gt;</code> by default, but you could use a <code class="calibre23">deque&lt;T&gt;</code> as the base container.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">stack</code></td>
<td class="calibre32">A <code class="calibre23">stack&lt;T&gt;</code> container is defined by an adapter from a <code class="calibre23">deque&lt;T&gt;</code> container by default, but you could define it using a <code class="calibre23">vector&lt;T&gt;</code> or a <code class="calibre23">list&lt;T&gt;</code> container. A stack is a last-in first-out container, so adding or removing elements always occurs at the top, and you can only access the top element.</td>
</tr>
</tbody>
</table>
</section>
<section class="toclist">
<h3 class="calibre21">Iterators</h3>
<p class="calibre13">Iterators are objects that behave like pointers and are very important for accessing the contents of all containers except for those defined by a container adapter; container adapters do not support iterators. You can obtain an iterator from a container, which you can use to access the objects you have stored in it. You can also create iterators that will allow input and output of objects, or data items of a given type from or to a stream. Although basically all iterators behave like pointers, not all iterators provide the same functionality. However, they do share a base level of capability. Given two iterators, <code class="calibre23">iter1</code> and <code class="calibre23">iter2</code>, accessing the same set of objects, the comparison operations <code class="calibre23">iter1 == iter2, iter1 != iter2</code>, and the assignment <code class="calibre23">iter1 = iter2</code> are always possible, regardless of the types of <code class="calibre23">iter1</code> and <code class="calibre23">iter2</code>.</p>
<section class="toclist">
<h4 class="calibre22">Iterator Categories</h4>
<p class="calibre13">There are four categories of iterators, and each category supports a different range of operations. The operations described for each category in the following table are in addition to the three operations that I mentioned in the previous paragraph:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="484" id="calibre_link-946" class="calibre14"></span><b class="calibre12">ITERATOR CATEGORY</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">Input and output iterators</td>
<td class="calibre32">These iterators read or write a sequence of objects and may only be used once. To read or write a second time, you must obtain a new iterator. You can perform the following operations on these iterators:<br class="calibre10" /><code class="calibre23">++iter</code> or <code class="calibre23">iter++</code><br class="calibre10" /><code class="calibre23">*iter</code><br class="calibre10" />For the dereferencing operation, only read access is allowed in the case of an input iterator, and only write access for an output iterator.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Forward iterators</td>
<td class="calibre32">Forward iterators incorporate the capabilities of both input and output iterators, so you can apply the operations shown for the previous category to them, and you can use them for access and store operations. Forward iterators can also be reused to traverse a set of objects in a forward direction as many times as you want.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Bidirectional iterators</td>
<td class="calibre32">Bidirectional iterators provide the same capabilities as forward iterators and additionally allow the operations <code class="calibre23">--iter</code> and <code class="calibre23">iter--</code>. This means you can traverse backward as well as forward through a sequence of objects.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Random access iterators</td>
<td class="calibre32">Random access iterators have the same capabilities as bidirectional iterators but also allow the following operations:<br class="calibre10" /><code class="calibre23">iter+n</code> or <code class="calibre23">iter-n</code><br class="calibre10" /><code class="calibre23">iter += n</code> or <code class="calibre23">iter -= n</code><br class="calibre10" /><code class="calibre23">iter1 - iter2</code><br class="calibre10" /><code class="calibre23">iter1 &lt; iter2</code> or <code class="calibre23">iter1 &gt; iter2</code><br class="calibre10" /><code class="calibre23">iter1 &lt;= iter2</code> or <code class="calibre23">iter1 &gt;= iter2</code><br class="calibre10" /><code class="calibre23">iter[n]</code><br class="calibre10" />Being able to increment or decrement an iterator by an arbitrary value <code class="calibre23">n</code> allows random access to the set of objects. The last operation using the <code class="calibre23">[]</code> operator is equivalent to <code class="calibre23">*(iter + n)</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13">Thus, iterators in the four successive categories provide a progressively greater range of functionality. Where an algorithm requires an iterator with a given level of functionality, you can use any iterator that provides the required level of capability. For example, if a forward iterator is required, you must use at least a forward iterator; an input or an output iterator will not do. On the other hand, you could use a bidirectional iterator or a random access iterator because they both have the capability provided by a forward iterator.</p>
<p class="calibre13">Note that when you obtain an iterator from a container, the kind of iterator you get will depend on the sort of container you are using. The types of some iterators can be complex, but as you’ll see, in many instances the <code class="calibre23">auto</code> keyword can deduce the type for you.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="485" id="calibre_link-947" class="calibre14"></span>SCARY Iterators</h4>
<p class="calibre13">Visual C++ supports SCARY iterators, which in spite of the name, are nothing to be frightened of. SCARY is a strange acronym that is less than obvious, standing for “Seemingly erroneous (appearing Constrained by conflicting generic parameters), but Actually work with the Right implementation (unconstrained bY the conflicts due to minimized dependencies).” SCARY iterators are simply iterators that have a type that depends only on the type of element stored in a container, and not on other template parameters used to instantiate the container, such as the allocator and comparator types. In previous implementations of the STL, different containers created to store elements of a given type, but with different comparator or allocator types, would have iterators of different types. There is no necessity for an iterator type to be dependent on the type of comparator or allocator used by a container. With the current implementation of the STL, the iterators will have the same type, determined only by the element type. SCARY iterators can make the code faster and more compact.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Functions Returning Iterators</h4>
<p class="calibre13">The <code class="calibre23">std::begin()</code> and <code class="calibre23">std::end()</code> functions return an iterator that points to the first element and one past the last element respectively of the container, <code class="calibre23">std::string</code> object or array that you pass as the argument. The <code class="calibre23">std::rbegin()</code> and <code class="calibre23">std::rend()</code> functions return reverse iterators that enable you to traverse backwards through a sequence. The <code class="calibre23">std::cbegin(), std::cend(),std::crbegin()</code>and <code class="calibre23">std::crend()</code>functions are similar to the first four I mentioned except that they return <code class="calibre23">const</code> iterators for the argument. These functions are included in the <code class="calibre23">iterator</code> header, the <code class="calibre23">string</code> header, and the headers for the majority of containers. You’ll see these functions in action later in this chapter. In most situations you can use these functions without the <code class="calibre23">std</code> prefix. The compiler will deduce that the function is from the <code class="calibre23">std</code> namespace from the argument type.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-321" class="calibre3"></a>SMART POINTERS</h2>
<p class="calibre13">Smart pointers are objects of a template type that behave like pointers but are different &mdash; they are smart. They are intended for use with objects you allocate dynamically. If you use a smart pointer when you allocate heap memory, the smart pointer will take care of deleting it. Using smart pointers for objects you create dynamically means never having to use <code class="calibre23">delete</code>. This means that you avoid the possibility of memory leaks. You can store smart pointers in a container, as you’ll see.</p>
<p class="calibre13">Smart pointers come in three flavors. The <code class="calibre23">memory</code> header defines the following template types for smart pointers in the <code class="calibre23">std</code> namespace:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">unique_ptr&lt;T&gt;</code> defines a unique object that behaves as a pointer to <code class="calibre23">T</code>; i.e., there can be only one such object. Assigning or copying a <code class="calibre23">unique_ptr&lt;T&gt;</code> object is not possible. The address stored by one such object can be moved to another using <code class="calibre23">std::move()</code>. After such an operation the original object will be invalid.</li>
<li class="calibre6">A <code class="calibre23">shared_ptr&lt;T&gt;</code> object stores an address of an object of type <code class="calibre23">T</code>, and several <code class="calibre23">shared_ptr&lt;T&gt;</code> objects can point to the same object. The number of <code class="calibre23">shared_ptr&lt;T&gt;</code> objects pointing to a given object is recorded. All <code class="calibre23">shared_ptr&lt;T&gt;</code> objects that point to the same object must be destroyed before the object that they point to can be deleted. When the last of the <code class="calibre23">shared_ptr&lt;T&gt;</code> objects pointing to a given object dies, the object to which it points will be destroyed and the memory released.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="486" id="calibre_link-948" class="calibre14"></span><code class="calibre23">weak_ptr&lt;T&gt;</code> stores a pointer that is linked to a <code class="calibre23">shared_ptr</code>. A <code class="calibre23">weak_ptr&lt;T&gt;</code> does not increment or decrement the reference count of the linked <code class="calibre23">shared_ptr</code> so it does not prevent the object from being destroyed and its memory released when the last <code class="calibre23">shared_ptr</code> referencing it is destroyed.</li>
</ul>
<p class="calibre13">The reference count for a <code class="calibre23">shared_ptr&lt;T&gt;</code> pointing to a given object, <code class="calibre23">obj</code>, is incremented each time a new one is  created and is decremented each time one of the <code class="calibre23">shared_ptr&lt;T&gt;</code> objects is destroyed. When the last <code class="calibre23">shared_ptr&lt;T&gt;</code> object pointing to <code class="calibre23">obj</code> is destroyed, <code class="calibre23">obj</code> will also be destroyed.</p>
<p class="calibre13">It is possible to inadvertently create reference cycles with <code class="calibre23">shared_ptr</code> objects. Conceptually a reference cycle is where a <code class="calibre23">shared_ptr</code> object, <code class="calibre23">pA</code>, points to another <code class="calibre23">shared_ptr</code> object <code class="calibre23">pB</code>, and <code class="calibre23">pB</code> points to <code class="calibre23">pA</code>. With this situation, neither can be destroyed. In practice this occurs in a way that is a lot more complicated. <code class="calibre23">weak_ptr</code> objects are designed to avoid the problem of reference cycles. By using <code class="calibre23">weak_ptr</code> objects to point to an object that a single <code class="calibre23">shared_ptr</code> object points to, you avoid reference cycles. When the single <code class="calibre23">shared_ptr</code> object is destroyed, the object pointed to is also destroyed. Any <code class="calibre23">weak_ptr</code> objects associated with the <code class="calibre23">shared_ptr</code> will then not point to anything.</p>
<section class="toclist">
<h3 class="calibre21">Using unique_ptr Objects</h3>
<p class="calibre13">A <code class="calibre23">unique_ptr</code> object stores a pointer uniquely. No other <code class="calibre23">unique_ptr</code> object can contain the same address so the object pointed to is effectively owned by the <code class="calibre23">unique_ptr</code> object. When the <code class="calibre23">unique_ptr</code> object is destroyed, the object to which it points is destroyed too.</p>
<p class="calibre13">You can create and initialize a smart pointer like this:</p>
<pre class="calibre28"><code class="calibre23">unique_ptr&lt;CBox&gt; pBox {new CBox {2,2,2}};</code></pre>
<p class="calibre13"><code class="calibre23">pBox</code> will behave just like an ordinary pointer and you can use it in the same way to call public member functions for the <code class="calibre23">CBox</code> object. The big difference is that you no longer have to worry about deleting the <code class="calibre23">CBox</code> object from the heap.</p>
<p class="calibre13">Here’s a version of some code that you saw back in Chapter 5, modified to use a <code class="calibre23">unique_ptr</code>:</p>
<pre class="calibre28"><code class="calibre23">#include &lt;iostream&gt;
#include &lt;memory&gt;
        
std::unique_ptr&lt;double&gt; treble(double);     // Function prototype
        
int main()
{
   double num {5.0};
   std::unique_ptr&lt;double&gt; ptr {};
   ptr = treble(num);
   std::cout &lt;&lt; "Three times num = " &lt;&lt; 3.0*num &lt;&lt; std::endl;
   std::cout &lt;&lt; "Result = " &lt;&lt; *ptr &lt;&lt; std::endl;
}
        
std::unique_ptr&lt;double&gt; treble(double data)
{
   std::unique_ptr&lt;double&gt; result {new double {}};
   *result = 3.0*data;
   return result;
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="487" id="calibre_link-949" class="calibre14"></span>This produces the result you would expect. <code class="calibre23">ptr</code> points to a <code class="calibre23">double</code> value of 15.0 after the statement that calls <code class="calibre23">treble()</code> has executed. You cannot copy a <code class="calibre23">unique_ptr</code> object or pass it by value to a function. The <code class="calibre23">treble()</code> function creates a local <code class="calibre23">unique_ptr&lt;double&gt;</code> object, modifies the value that it points to, and returns it. How does the <code class="calibre23">treble()</code> function return a <code class="calibre23">unique_ptr&lt;double&gt;</code> object when it cannot be copied? When you return a <code class="calibre23">unique_ptr</code> object from a function, <code class="calibre23">std::move()</code>is used to move the pointer from the local <code class="calibre23">unique_ptr</code> object to the object that is received by the calling function. Moving the pointer from one <code class="calibre23">unique_ptr</code> to another transfers ownership of the object pointed to, so the source <code class="calibre23">unique_ptr</code> object will contain <code class="calibre23">nullptr</code>. This has implications when you store <code class="calibre23">unique_ptr</code> objects in a container. I’ll show you how you can store smart pointers in an STL container later in this chapter.</p>
<p class="calibre13">The <code class="calibre23">make_unique&lt;T&gt;()</code> function template creates a new <code class="calibre23">T</code> object on the heap and then creates a <code class="calibre23">unique_ptr&lt;T&gt;</code> object that points to the <code class="calibre23">T</code>object. The arguments that you pass to <code class="calibre23">make_unique&lt;T&gt;()</code> are the arguments to the <code class="calibre23">T</code> class constructor. Here’s how you could create a <code class="calibre23">unique_ptr</code> object holding the address of a <code class="calibre23">CBox</code> object:</p>
<pre class="calibre28"><code class="calibre23">auto pBox = std::make_unique&lt;CBox&gt;(2.0, 3.0, 4.0);</code></pre>
<p class="calibre13">This creates a <code class="calibre23">CBox</code> object on the heap and stores its address in a new <code class="calibre23">unique_ptr&lt;CBox&gt;</code> object, <code class="calibre23">pBox</code>. Apart from the fact that it cannot be duplicated, you can use <code class="calibre23">pBox</code> just like an ordinary pointer.</p>
<p class="calibre13">Another version of <code class="calibre23">make_unique&lt;&gt;()</code> can create a <code class="calibre23">unique_ptr</code> object pointing to a new array in the free store. For example:</p>
<pre class="calibre28"><code class="calibre23">auto pBoxes = std::make_unique&lt;CBox[]&gt;(6);</code></pre>
<p class="calibre13">This statement creates an array of six <code class="calibre23">CBox</code> objects on the heap and stores the address of the array in a <code class="calibre23">unique_ptr&lt;CBox[]&gt;</code> object. You put the array type as the function template argument and the array dimension as the argument to the function. You access the array elements by indexing the <code class="calibre23">unique_ptr</code> object, <code class="calibre23">pBoxes</code>. For example:</p>
<pre class="calibre28"><code class="calibre23">pBoxes[1] = CBox {1.0, 2.0, 3.0};</code></pre>
<p class="calibre13">This sets the second element in the array to a <code class="calibre23">CBox</code> object with the dimensions you see. Thus the <code class="calibre23">unique_ptr</code> object acts just like the array name for a normal array.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using shared_ptr Objects</h3>
<p class="calibre13">You can define a <code class="calibre23">shared_ptr</code> object explicitly using the <code class="calibre23">shared_ptr&lt;T&gt;</code> constructor, but it is better to use the <code class="calibre23">make_shared&lt;T&gt;()</code> function that creates an object of type <code class="calibre23">T</code> on the heap and then returns a <code class="calibre23">shared_ptr&lt;T&gt;</code> object that points to it because the memory allocation is more efficient. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">auto pBox = make_shared&lt;CBox&gt;(1.0, 2.0, 3.0);  // Points to a CBox object</code></pre>
<p class="calibre13">This creates a <code class="calibre23">CBox</code> object on the heap with length, width, and height values as 1.0, 2.0, and 3.0 and stores the <code class="calibre23">shared_ptr&lt;CBox&gt;</code> object that points to it in <code class="calibre23">pBox</code>.</p>
<p class="calibre13">In contrast to <code class="calibre23">unique_ptr</code>, you can have multiple <code class="calibre23">shared_ptr</code> objects pointing to the same object. The object pointed to will survive until the last <code class="calibre23">shared_ptr</code> object that points to it is destroyed, then it too will be destroyed. A <code class="calibre23">shared_ptr</code> object will be copied when you return it from a function.</p>
<p class="calibre13">You can initialize a <code class="calibre23">shared_ptr</code> with another <code class="calibre23">shared_ptr</code>:</p>
<pre class="calibre28"><code class="calibre23">std::shared_ptr&lt;CBox&gt; pBox2 {pBox};</code></pre>
<p class="calibre13"><code class="calibre23">pBox2</code> points to the same object as <code class="calibre23">pBox</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="488" id="calibre_link-950" class="calibre14"></span>Using a smart pointer works in the same way as an ordinary pointer:</p>
<pre class="calibre28"><code class="calibre23">std::cout &lt;&lt; "Box volume = " &lt;&lt; pBox-&gt;volume() &lt;&lt; std::endl;</code></pre>
<p class="calibre13">A smart pointer that you define with a base class type, can store a pointer to a derived class type. For example, given the <code class="calibre23">CBox</code> and <code class="calibre23">CCandyBox</code> classes that you saw in Chapter 9, you could define a <code class="calibre23">shared_ptr</code> like this:</p>
<pre class="calibre28"><code class="calibre23">shared_ptr&lt;CBox&gt; pBox {new CCandyBox {2,2,2}};</code></pre>
<p class="calibre13"><code class="calibre23">pBox</code> points to a <code class="calibre23">CCandyBox</code> object so smart pointers work in the same way as ordinary pointers in this respect too.</p>
<p class="calibre13">If you use a local smart pointer in a function to point to an object on the heap, the memory for the object will be automatically released when the function returns &mdash; assuming that you are not returning the smart pointer from the function. You can use smart pointers as class members. If you are defining a class that uses smart pointers to keep track of heap objects, you won’t need to implement a destructor to be sure that the memory for the objects is released when the class object is destroyed. The default constructor will call the destructor for each member that is a smart pointer.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Accessing the Raw Pointer in a Smart Pointer</h3>
<p class="calibre13">You will sometimes need access to the address that a smart pointer contains; this is called a raw pointer. You will see later in the book that there are circumstances with the MFC where you need a raw pointer because MFC member functions do not accept smart pointers as arguments. Calling the <code class="calibre23">get()</code> memberof a smart pointer object returns the raw pointer, which you can then pass to a function that requires it.</p>
<p class="calibre13">Calling the <code class="calibre23">reset()</code> member of a smart pointer resets the raw pointer to <code class="calibre23">nullptr</code>. This will cause the object that is pointed to be destroyed when there are no other smart pointers that contain the same address.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Casting Smart Pointers</h3>
<p class="calibre13">You cannot use the standard cast operators such as <code class="calibre23">static_cast, dynamic_cast</code>, and <code class="calibre23">const_cast</code> with smart pointers. When you need to cast a smart pointer, you must use <code class="calibre23">static_pointer_cast, dynamic_pointer_cast</code>, and <code class="calibre23">const_pointer_cast</code> instead of the standard operators. When you use <code class="calibre23">dynamic_pointer_cast</code> to cast a <code class="calibre23">shared_ptr&lt;T&gt;</code> object to a <code class="calibre23">shared_ptr&lt;Base&gt;</code> object, the result will be a <code class="calibre23">shared_ptr</code> containing <code class="calibre23">nullptr</code> if <code class="calibre23">Base</code> is not a base class for <code class="calibre23">T</code>. The cast operations for smart pointers are defined as function templates in the <code class="calibre23">memory</code> header.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-322" class="calibre3"></a>ALGORITHMS</h2>
<p class="calibre13">Algorithms are STL function templates that operate on a set of objects that are made available to them by an iterator. Because the objects are accessed through an iterator, an algorithm needs no knowledge of the source of the objects. The objects could be retrieved by the iterator from a container or even from a stream. Because iterators work like pointers, all STL functions that accept an iterator as an argument will work equally well with a regular pointer.</p>
<p class="calibre13">As you’ll see, you will frequently use containers, iterators, and algorithms in concert, in the manner illustrated in <a id="calibre_link-1381" href="#calibre_link-421" class="calibre3">Figure 10-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000135.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-421" href="#calibre_link-1381" class="calibre3">FIGURE 10-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="489" id="calibre_link-951" class="calibre14"></span>To apply an algorithm to the contents of a container, you supply iterators that point to objects within the container. The algorithm uses these iterators to access these objects in sequence and to write them back to the container when appropriate. For example, when you apply the <code class="calibre23">sort()</code> algorithm to a vector, you pass two iterators to the function. One points to the first element, and the other to one past the last element. The <code class="calibre23">sort()</code> function uses these iterators to access the objects for comparison, and to write them back to the container to establish the ordering. You’ll see this working in an example later in this chapter.</p>
<p class="calibre13">Algorithms are defined in two standard header files, the <code class="calibre23">algorithm</code> header and the <code class="calibre23">numeric</code> header.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-323" class="calibre3"></a>FUNCTION OBJECTS IN THE STL</h2>
<p class="calibre13">Function objects are objects of a class type that overloads the <code class="calibre23">()</code> operator (the function call operator), which means that the class implements the <code class="calibre23">operator()()</code> function. The implementation of the <code class="calibre23">operator()()</code> member function in a function object can return a value of any type. Function objects are also called functors.</p>
<p class="calibre13">The STL defines a set of function templates object types that define functors in the <code class="calibre23">functional</code> header. For example, the STL defines the <code class="calibre23">less&lt;T&gt;</code> template that I mentioned in the context of the map container. If you instantiate the template as <code class="calibre23">less&lt;MyClass&gt;</code>, you have a type for function objects that implement <code class="calibre23">operator()()</code> to provide the less-than comparison for <code class="calibre23">MyClass</code> objects. For this to work, <code class="calibre23">MyClass</code> must implement the <code class="calibre23">operator&lt;()</code> function.</p>
<p class="calibre13">Many algorithms make use of function objects to specify binary operations to be carried out, or to specify predicates that determine how or whether a particular operation is to be carried out. A predicate is a function that returns a value of type <code class="calibre23">bool</code>, and because a function object can implement the <code class="calibre23">operator()()</code> member function to return a value of type <code class="calibre23">bool</code>, a function object can be a predicate. For example, suppose you have defined a <code class="calibre23">Comp</code> class that implements <code class="calibre23">operator()()</code>to compare two objects and return a <code class="calibre23">bool</code> value. If you create an object <code class="calibre23">obj</code> of type <code class="calibre23">Comp</code>, the expression <code class="calibre23">obj(a,b)</code> returns a <code class="calibre23">bool</code> value that results from comparing <code class="calibre23">a</code> and <code class="calibre23">b</code>, and thus acts as a predicate.</p>
<p class="calibre13">Predicates come in two flavors, binary predicates that involve two operands, and unary predicates that require one operand. Comparisons such as less-than and equal-to, and logical operations such as AND and OR, are implemented as binary predicates that are members of function objects; logical negation, NOT, is implemented as a unary predicate member of a function object.</p>
<p class="calibre13">You can define your own function objects when necessary. You’ll see function objects in action with algorithms and some container class functions later in this chapter. You can also define lambda expressions, which I’ll also introduce later in this chapter. Lambda expressions are often easier to use than function objects.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-324" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="490" id="calibre_link-952" class="calibre18"></span>FUNCTION ADAPTERS</h2>
<p class="calibre13">Function adapters are function templates that allow function objects to be combined to produce a more complex function object. A simple example is the <code class="calibre23">not1</code> function adapter. This takes an existing function object that provides a unary predicate and inverts it. Thus, if the function object function returns <code class="calibre23">true</code>, the function that results from applying <code class="calibre23">not1</code> to it will be <code class="calibre23">false</code>. Function adapters are yet another topic I won’t be discussing in depth, not because they are terribly difficult to understand &mdash; they aren’t &mdash; but because there’s a limit to how much I can cram into a single chapter.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-325" class="calibre3"></a>THE RANGE OF STL CONTAINERS</h2>
<p class="calibre13">You can apply the STL container templates in a wide range of applications. Sequence containers are containers in which you store objects of a given type in a linear fashion, either as a dynamic array or as a list. Elements are retrieved based on their position in the container. Associative containers store objects based on a key that you supply with each object to be stored; the key is used to locate the object within the container. Keys can be values of fundamental types or class objects. In a typical application, you might store phone numbers in an associative container, using names as the keys. You can retrieve a particular number from the container just by supplying the appropriate name. Sets are containers that hold elements that are stored and retrieved based on the elements themselves. They can be unordered, rather like objects rattling around in a bag, or they can be ordered, where a sequence is established within the container that depends on what the objects are. There are also sets that allow you to specify a comparator that will establish a particular order within the set. I won’t be discussing sets in detail. I’ll first introduce you to sequence containers, and then I’ll delve into associative containers and what you can do with them.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-326" class="calibre3"></a>SEQUENCE CONTAINERS</h2>
<p class="calibre13">The class templates for the five basic sequence containers are <code class="calibre23">vector&lt;T&gt;, array&lt;T,N&gt;, list&lt;T&gt;, forward_list&lt;T&gt;</code>, and <code class="calibre23">deque&lt;T&gt;</code>.</p>
<p class="calibre13">Which template you choose in any particular instance depends on the application. These containers are differentiated by the operations they can perform efficiently, as <a id="calibre_link-1382" href="#calibre_link-422" class="calibre3">Figure 10-2</a> shows.</p>
<figure class="calibre16">
<img class="center" src="images/000120.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-422" href="#calibre_link-1382" class="calibre3">FIGURE 10-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">If you need random access to the contents of a container with a variable size, and you are happy to always add or delete objects at the end of a sequence, then <code class="calibre23">vector&lt;T&gt;</code> is the container template to choose. It is possible to add or delete objects randomly within a vector, but the process will be somewhat slower than adding objects to the end because all the objects past the insertion or deletion point have to be moved. If you can manage with a fixed number of elements, the <code class="calibre23">array&lt;T,N&gt;</code> container will be faster than a <code class="calibre23">vector&lt;T&gt;</code> in store and retrieve operations because you don’t have the overhead of providing for increasing the capacity of the container. An <code class="calibre23">array&lt;T,N&gt;</code> container can be allocated on the stack and is more flexible than a normal array.</p>
<p class="calibre13">A <code class="calibre23">deque&lt;T&gt;</code> container is similar to a <code class="calibre23">vector&lt;T&gt;</code> and supports the same operations, but it has the additional capability to add and delete elements at the beginning of the sequence. A <code class="calibre23">list&lt;T&gt;</code> container is a doubly-linked list, so adding and deleting at any position is efficient. The downside of a list is that there is no random access to the contents; the only way to access an object that is internal to the list is to traverse the contents from the beginning, or to run backward from the end.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="491" id="calibre_link-953" class="calibre14"></span><span {http://www.idpf.org/2007/ops}type="pagebreak" title="492" id="calibre_link-954" class="calibre14"></span>Let’s look at sequence containers in more detail and try some examples. I’ll be introducing the use of iterators, algorithms, and function objects along the way.</p>
<section class="toclist">
<h3 class="calibre21">Creating Vector Containers</h3>
<p class="calibre13">The simplest way to create a vector container is like this:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; mydata;</code></pre>
<p class="calibre13">This creates a container that will store values of type <code class="calibre23">int</code>. The initial capacity is zero, so you will be allocating more memory right from the outset when you insert the first value.</p>
<p class="calibre13">The <code class="calibre23">push_back()</code> member function adds a new element to the end of a vector, so to store a value in this vector you would write:</p>
<pre class="calibre28"><code class="calibre23">mydata.push_back(99);</code></pre>
<p class="calibre13">The argument to <code class="calibre23">push_back()</code> is the item to be stored. This statement stores 99 in the vector, so after executing this, the vector contains one element. The <code class="calibre23">push_back()</code> function is overloaded with an rvalue reference parameter version so it will move temporary objects into the vector rather than copy them.</p>
<p class="calibre13">Here’s another way to create a vector to store integers:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; mydata(100);</code></pre>
<p class="calibre13">This creates a vector that contains 100 elements that are all initialized to zero. Note that you must use parentheses here. If you put 100 between braces, the vector will contain one element with the value 100. If you add new elements, the memory allocated for the vector will be increased automatically, so obviously it’s a good idea to choose a reasonably accurate value for the number of integers you are likely to store. This vector can be used just like an array. For example, to store a value in the third element, you can write:</p>
<pre class="calibre28"><code class="calibre23">mydata[2] = 999;</code></pre>
<p class="calibre13">Of course, you can only use an index value to access elements that are within the range that exist in the vector. You can’t add new elements in this way though. To add a new element, you can use the <code class="calibre23">push_back()</code> function.</p>
<p class="calibre13">You can initialize the elements in a vector to a different value, when you create it by using this statement:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; mydata(100, -1);</code></pre>
<p class="calibre13">You must use parentheses here too. The second argument is the initial value to be used for elements, so all 100 elements will be set to -1.</p>
<p class="calibre13">If you don’t want to create elements when you create a vector container, you can increase the capacity after you create it by calling its <code class="calibre23">reserve()</code> function:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; mydata;
mydata.reserve(100);</code></pre>
<p class="calibre13">The argument to the <code class="calibre23">reserve()</code> function is the minimum number of elements to be accommodated. If the argument is less than the current capacity of the vector, then calling <code class="calibre23">reserve()</code> will have no effect. In this code fragment, calling <code class="calibre23">reserve()</code> causes the vector container to allocate sufficient memory for a total of 100 elements although the elements are not yet created.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="493" id="calibre_link-955" class="calibre14"></span>When you want to specify a set of initial values for elements, you use an initializer list:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; values {100, 200, 300, 400);</code></pre>
<p class="calibre13">This creates a vector containing four elements with the values from the list.</p>
<p class="calibre13">You can also create a vector with initial values for elements from an external array. For example:</p>
<pre class="calibre28"><code class="calibre23">double data[] {1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5};
vector&lt;double&gt; mydata(data, data+8);</code></pre>
<p class="calibre13">Here, the <code class="calibre23">data</code> array is created with 10 elements of type <code class="calibre23">double</code>, with the initial values shown. The second statement creates a vector storing elements of type <code class="calibre23">double</code>, with eight elements initially having the values corresponding to <code class="calibre23">data[0]</code> through <code class="calibre23">data[7]</code>. The arguments to the <code class="calibre23">vector&lt;double&gt;</code> constructor are pointers (and can also be iterators), where the first pointer points to the first initializing element in the array, and the second points to one past the last initializing element. Thus, the <code class="calibre23">mydata</code> vector will contain eight elements with initial values 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, and 8.5.</p>
<p class="calibre13">Because the constructor in the previous fragment can accept either pointer or iterator arguments, you can initialize a vector when you create it with values from another vector that contains elements of the same type. You just supply the constructor with an iterator pointing to the first element you want to use as an initializer, plus a second iterator pointing to one past the last element you want to use. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;double&gt; values(begin(mydata), end(mydata));</code></pre>
<p class="calibre13">After executing this statement, the <code class="calibre23">values</code> vector will have elements that are duplicates of the <code class="calibre23">mydata</code> vector. As <a id="calibre_link-1383" href="#calibre_link-423" class="calibre3">Figure 10-3</a> illustrates, the <code class="calibre23">begin()</code> template function returns a random access iterator that points to the first element in the argument, and <code class="calibre23">end()</code>returns a random access iterator pointing to one past the last element. A sequence of elements is typically specified in the STL by two iterators, one pointing to the first element and the other pointing to one past the last element, so you’ll see this time and time again.</p>
<figure class="calibre16">
<img class="center" src="images/000092.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-423" href="#calibre_link-1383" class="calibre3">FIGURE 10-3</a></b></span></p>
</figcaption>
</figure>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">If you check the documentation, you’ll see that the</i> <code class="calibre23">vector</code> <i class="calibre15">container and other sequence containers have</i> <code class="calibre23">begin()</code> <i class="calibre15">and</i> <code class="calibre23">end()</code> <i class="calibre15">member functions that you can call for a container object:</i></p>
<pre class="calibre28"><code class="calibre23">vector&lt;double&gt; values(mydata.begin(),mydata.end());</code></pre>
<p class="calibre20"><i class="calibre15">This does the same as the preceding statement, but I recommend that you use the non-member</i> <code class="calibre23">begin()</code> <i class="calibre15">and</i> <code class="calibre23">end()</code> <i class="calibre15">functions because they are more flexible. They work with arrays, strings and other containers. The</i> <code class="calibre23">rbegin(), rend(), cbegin()</code>, <i class="calibre15">and</i> <code class="calibre23">cend()</code> <i class="calibre15">template functions that I’ll use later in this chapter also exist as members of container classes</i>.</p>
<p class="calibre20"><i class="calibre15">You can usually use non-member</i> <code class="calibre23">begin(), end()</code>, <i class="calibre15">and etc. functions without qualifying them with</i> <code class="calibre23">std</code> <i class="calibre15">because the compiler can deduce that the function is from the</i> <code class="calibre23">std</code> <i class="calibre15">namespace from the argument</i>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Because <code class="calibre23">begin()</code> and <code class="calibre23">end()</code>return random access iterators, you can modify what they point to when you use them. For a <code class="calibre23">vector&lt;T&gt;</code>, the type of the iterators that <code class="calibre23">begin()</code> and <code class="calibre23">end()</code>return is <code class="calibre23">vector&lt;T&gt;::iterator</code>, where <code class="calibre23">T</code> is the type of object in the vector. Most of the time you can use the <code class="calibre23">auto</code> keyword to specify the iterator type.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="494" id="calibre_link-956" class="calibre14"></span>Here’s a statement that creates a vector that is initialized with the third through the seventh elements from the <code class="calibre23">mydata</code> vector:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;double&gt; values(begin(mydata)+2, end(mydata)-1);</code></pre>
<p class="calibre13">Adding 2 to the first iterator makes it point to the third element in <code class="calibre23">mydata</code>. Subtracting 1 from the second iterator makes it point to the last element in <code class="calibre23">mydata</code>; remember that the second argument to the constructor is an iterator that points to a position that is one past the element to be used as the last initializer, so the object that the second iterator points to is not included in the set.</p>
<p class="calibre13">As I said earlier, it is pretty much standard practice in the STL to indicate a sequence of elements in a container by a begin iterator that points to the first element and an end iterator that points to one past the last element. This allows you to iterate over all the elements in a sequence by incrementing the begin iterator until it equals the end iterator. This means that the iterators only need to support the equality operator to allow you to walk through the sequence.</p>
<p class="calibre13">Occasionally, you may want to access the contents of a vector in reverse order. Calling the <code class="calibre23">rbegin()</code> function for a vector returns an iterator that points to the last element, while <code class="calibre23">rend()</code> points to one before the first element (that is, the position preceding the first element), as <a id="calibre_link-1384" href="#calibre_link-424" class="calibre3">Figure 10-4</a> illustrates.</p>
<figure class="calibre16">
<img class="center" src="images/000101.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-424" href="#calibre_link-1384" class="calibre3">FIGURE 10-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The iterators returned by <code class="calibre23">rbegin()</code> and <code class="calibre23">rend()</code> are called reverse iterators because they present the elements in reverse sequence. For a <code class="calibre23">vector&lt;T&gt;</code> container, reverse iterators are of type <code class="calibre23">vector&lt;T&gt;::reverse_iterator</code>. <a href="#calibre_link-424" class="calibre3">Figure 10-4</a> shows how adding a positive integer to the <code class="calibre23">rbegin()</code> iterator moves back through the sequence, and subtracting an integer from <code class="calibre23">rend()</code> moves forward through the sequence.</p>
<p class="calibre13">Here’s how you could create a vector containing the contents of another vector in reverse order:</p>
<pre class="calibre28"><code class="calibre23">double data[] {1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5};
vector&lt;double&gt; mydata(data, data+8);
vector&lt;double&gt; values(rbegin(mydata), rend(mydate));</code></pre>
<p class="calibre13">Because you are using reverse iterators as arguments to the constructor in the last statement, the <code class="calibre23">values</code> vector will contain the elements from <code class="calibre23">mydata</code> in reverse order.</p>
<p class="calibre13">When you want to use iterators to access the elements in a vector but do not want to modify the elements you can use the <code class="calibre23">cbegin()</code> and <code class="calibre23">cend()</code>template functions that return <code class="calibre23">const</code> iterators. For example, suppose you want to list the squares of the integer values stored in a vector:</p>
<pre class="calibre28"><code class="calibre23">  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="495" id="calibre_link-957" class="calibre14"></span>std::vector&lt;int&gt; mydata {1, 2, 3, 4, 5};
  for(auto iter = std::cbegin(mydata) ; iter != std::cend(mydata) ; ++iter)
    std::cout &lt;&lt; (*iter) &lt;&lt; " squared is " &lt;&lt; (*iter)*(*iter) &lt;&lt; std::endl;</code></pre>
<p class="calibre13">Using <code class="calibre23">cbegin()</code> and <code class="calibre23">cend()</code>, there is no possibility of modifying the elements in <code class="calibre23">mydata</code> accidentally within the loop. You also have the standalone template functions and container member functions <code class="calibre23">crbegin()</code> and <code class="calibre23">crend()</code> available that provide <code class="calibre23">const</code> reverse iterators.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Capacity and Size of a Vector Container</h3>
<p class="calibre13">The capacity of a vector is the maximum number of objects it can currently accommodate without allocating more memory. The size is the number of objects actually stored in the container. Obviously the size cannot be greater than the capacity.</p>
<p class="calibre13">You can obtain the size and capacity of the <code class="calibre23">data</code> container by calling the <code class="calibre23">size()</code> and <code class="calibre23">capacity()</code> member functions. For example:</p>
<pre class="calibre28"><code class="calibre23">std::cout &lt;&lt; "The capacity of the container is: " &lt;&lt; data.capacity() &lt;&lt; std::endl
          &lt;&lt; "The size of the container is: " &lt;&lt; data.size() &lt;&lt; std::endl;</code></pre>
<p class="calibre13">Calling <code class="calibre23">capacity()</code>for a vector returns the current capacity, and calling its <code class="calibre23">size()</code> function returns the current size, both values being returned as type <code class="calibre23">vector&lt;T&gt;::size_type</code>. This is an implementation-defined integer type that is defined within the <code class="calibre23">vector&lt;T&gt;</code> class template. To create a variable to store the value returned from the <code class="calibre23">size()</code> or <code class="calibre23">capacity()</code> function, you can specify it as type <code class="calibre23">vector&lt;T&gt;::size_type</code>, where you replace <code class="calibre23">T</code> with the type of object stored in the container. The following fragment illustrates this:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;double&gt; values;
vector&lt;double&gt;::size_type cap {values.capacity()};</code></pre>
<p class="calibre13">Of course, the <code class="calibre23">auto</code> keyword makes it much easier:</p>
<pre class="calibre28"><code class="calibre23">auto cap = values.capacity();</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The Visual C++ implementation of STL defines</i> <code class="calibre23">vector&lt;T&gt;::size_type</code> <i class="calibre15">as</i> <code class="calibre23">size_t</code>, <i class="calibre15">which is an unsigned integer type that is also the type for the result of the</i> <code class="calibre23">sizeof</code> <i class="calibre15">operator</i>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">If the value returned by the <code class="calibre23">size()</code> function is zero, then clearly the vector contains no elements; thus, you can use it as a test for an empty vector. You can also call the <code class="calibre23">empty()</code> function for a vector to test for this:</p>
<pre class="calibre28"><code class="calibre23">if(values.empty())
  std::cout &lt;&lt; "No more elements in the vector.";</code></pre>
<p class="calibre13">The <code class="calibre23">empty()</code> function returns a value of type <code class="calibre23">bool</code> that is <code class="calibre23">true</code> when the vector is empty and <code class="calibre23">false</code> otherwise.</p>
<p class="calibre13">You are unlikely to need it very often, but you can discover the maximum possible number of elements in a vector by calling its <code class="calibre23">max_size()</code> function. For example:</p>
<pre class="calibre28"><code class="calibre23">std::vector&lt;std::string&gt; strings;
std::cout &lt;&lt; "Maximum length of strings vector: " 
          &lt;&lt; strings.max_size() &lt;&lt; std::endl;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="496" id="calibre_link-958" class="calibre14"></span>Executing this fragment produces the output:</p>
<pre class="calibre28"><code class="calibre23">Maximum length of strings vector: 153391689</code></pre>
<p class="calibre13">The maximum length is returned as type <code class="calibre23">vector&lt;string&gt;::size_type</code>. Note that the maximum length of a vector will depend on the type of element stored. If you try this with a vector storing values of type <code class="calibre23">int</code>, you will get 1073741823 as the maximum length, and for a vector storing values of type <code class="calibre23">double</code> it is 536870911.</p>
<p class="calibre13">You can increase or decrease the size of a vector by calling its <code class="calibre23">resize()</code> function. If you specify a new size that is less than the current size, sufficient elements will be deleted from the end of the vector to reduce it to its new size. If the new size is greater than the old, new elements will be added to the end of the vector to increase its length to the new size. Here’s code illustrating this:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; values(5, 66);   // Contains 66 66 66 66 66
values.resize(7, 88);        // Contains 66 66 66 66 66 88 88
values.resize(10);           // Contains 66 66 66 66 66 88 88 0 0 0
values.resize(4);            // Contains 66 66 66 66</code></pre>
<p class="calibre13">The first argument to <code class="calibre23">resize()</code> is the new size. The second argument, when it is present, is the value to be used for new elements that need to be added to make up the new size. If you are increasing the size and you don’t specify a value for new elements, the default value will be used. In the case of a vector storing objects of a class type, the default value will be the object produced by the no-arg constructor for the class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Exploring the Size and Capacity of a Vector</h3>
<p class="calibre20">This example exercises some of the ways you have seen for creating a vector and shows how the capacity changes as you add elements:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_01.cpp
// Exploring the size and capacity of a vector
        
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector;
        
// Template function to display the size and capacity of any vector
template&lt;class T&gt;
void listInfo(const vector&lt;T&gt;&amp; v)
{
  std::cout &lt;&lt; "Container capacity: " &lt;&lt; v.capacity()
            &lt;&lt; " size: " &lt;&lt; v.size() &lt;&lt; std::endl;
}
        
int main()
{
  // Basic vector creation
  vector&lt;double&gt; data;
  listInfo(data);
        
  data.reserve(100);
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="497" id="calibre_link-959" class="calibre14"></span>std::cout &lt;&lt; "After calling reserve(100):" &lt;&lt; std::endl;
 
  listInfo(data);
        
  
  vector&lt;int&gt; numbers(10,-1); // Create a vector with 10 elements and initialize it
  std::cout &lt;&lt; "The initial values are: ";
 
  for(auto n : numbers)       // You can use the range-based for loop with a vector
    std::cout &lt;&lt; " " &lt;&lt; n;
  std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
        
  // See how adding elements affects capacity increments
  auto oldC = numbers.capacity();   // Old capacity
  auto newC = oldC;                 // New capacity after adding element
  listInfo(numbers);
  for(int i {}; i&lt;1000; i++)
  {
    numbers.push_back(2*i);
    newC = numbers.capacity();
    if(oldC &lt; newC)                 // Only output when capacity increases
    {
      oldC = newC;
      listInfo(numbers);
    }
  }
}</code></pre>
<p class="calibre20">This example produces the following output:</p>
<pre class="calibre28"><code class="calibre23">Container capacity: 0 size: 0
After calling reserve(100):
Container capacity: 100 size: 0
The initial values are: -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
        
Container capacity: 10 size: 10
Container capacity: 15 size: 11
Container capacity: 22 size: 16
Container capacity: 33 size: 23
Container capacity: 49 size: 34
Container capacity: 73 size: 50
Container capacity: 109 size: 74
Container capacity: 163 size: 110
Container capacity: 244 size: 164
Container capacity: 366 size: 245
Container capacity: 549 size: 367
Container capacity: 823 size: 550
Container capacity: 1234 size: 824</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">#include</code> directive for the <code class="calibre23">vector</code> header adds the definition for the <code class="calibre23">vector&lt;T&gt;</code> template to the source file.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="498" id="calibre_link-960" class="calibre14"></span>Following the <code class="calibre23">using</code> declaration you have a definition of the <code class="calibre23">listInfo()</code> function template:</p>
<pre class="calibre28"><code class="calibre23">template&lt;class T&gt;
void listInfo(const vector&lt;T&gt;&amp; v)
{
  std::cout &lt;&lt; "Container capacity: " &lt;&lt; v.capacity()
            &lt;&lt; " size: " &lt;&lt; v.size() &lt;&lt; std::endl;
}</code></pre>
<p class="calibre20">This template outputs the current capacity and size of any vector. You will often find it convenient to write function templates when working with the STL. The example shows how easy it is. The <code class="calibre23">T</code> template parameter determines the parameter type for the function. You call this function with a vector container as the argument. Specifying the parameter as the reference type, <code class="calibre23">const vector&lt;T&gt;&amp;</code>, enables the function body to access the container you pass as the argument to the function directly. If you specified the parameter as type <code class="calibre23">const vector&lt;T&gt;</code>, then the vector would be copied each time the function is called, which could be time-consuming for a large vector container.</p>
<p class="calibre20">The first action in <code class="calibre23">main()</code> is to create a vector and output its size and capacity:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;double&gt; data;
  listInfo(data);</code></pre>
<p class="calibre20">You can see from the output that the size and the capacity are both zero. Adding an element requires more space to be allocated.</p>
<p class="calibre20">Next, you call the <code class="calibre23">reserve()</code> function for the container:</p>
<pre class="calibre28"><code class="calibre23">  data.reserve(100);</code></pre>
<p class="calibre20">You can see from the output that the capacity is now 100 and the size is zero. This means that the container contains no elements but has memory allocated to accommodate up to 100 elements. Only when you add the 101st element will the capacity be increased automatically.</p>
<p class="calibre20">Next, you create another container with this statement:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;int&gt; numbers(10,-1);</code></pre>
<p class="calibre20">This creates a vector that contains 10 elements, each initialized with -1. To demonstrate that this is indeed the case, you output the elements in the container with the following loop:</p>
<pre class="calibre28"><code class="calibre23">  for(auto n : numbers)
    std::cout &lt;&lt; " " &lt;&lt; n;</code></pre>
<p class="calibre20">This demonstrates that the range-based <code class="calibre23">for</code> loop works with a vector.</p>
<p class="calibre20">Alternatively, you could write the loop using a regular <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  for(vector&lt;int&gt;::size_type i {}; i&lt;numbers.size(); ++i)
    std::cout &lt;&lt; " " &lt;&lt; numbers[i];</code></pre>
<p class="calibre20">You could also use an iterator to access the elements in the loop:</p>
<pre class="calibre28"><code class="calibre23">  for(auto iter = begin(numbers); iter != end(numbers); ++iter)
   std::cout &lt;&lt; " " &lt;&lt; *iter;</code></pre>
<p class="calibre20">The loop variable, <code class="calibre23">iter</code>, is an iterator of type <code class="calibre23">vector&lt;int&gt;::iterator</code>, that you initialize with the iterator returned by the <code class="calibre23">begin()</code> function. This is incremented on each loop iteration, and the loop ends when it reaches <code class="calibre23">end(numbers)</code>, which points to one past the last element. Note how you dereference the iterator just like a pointer to get at the value of the element.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="499" id="calibre_link-961" class="calibre14"></span>The remaining statements in <code class="calibre23">main()</code> demonstrate how the capacity of a vector increases as you add elements. The first two statements create variables to store the current capacity and the new capacity after adding an element:</p>
<pre class="calibre28"><code class="calibre23">  auto oldC = numbers.capacity();   // Old capacity
  auto newC = oldC;                 // New capacity after adding element</code></pre>
<p class="calibre20">After displaying the initial size and capacity, you execute the following loop:</p>
<pre class="calibre28"><code class="calibre23">  for(int i {}; i&lt;1000 ;i++)
  {
    numbers.push_back(2*i);
    newC = numbers.capacity();
    if(oldC &lt; newC)
    {
      oldC = newC;
      listInfo(numbers);
    }
  }</code></pre>
<p class="calibre20">This loop calls <code class="calibre23">push_back()</code>for the <code class="calibre23">numbers</code> vector to add 1,000 elements. The <code class="calibre23">if</code> condition ensures that we only display the capacity and size when the capacity increases.</p>
<p class="calibre20">The output shows an interesting pattern in the way additional space is allocated in the container. As you would expect with the initial size and capacity at 10, the first capacity increase occurs when you add the 11th element. The increase in this case is half the capacity, so the capacity increases to 15. The next capacity increase is when the size reaches 15, and the increase is to 22, so the increment is again half the capacity. This process continues with each capacity increase being half the current capacity. Thus, you automatically get larger chunks of memory space allocated when required, the more elements the vector contains. On the one hand, this mechanism ensures that once the initial memory allocation in the container is occupied, you don’t cause more memory to be allocated every time you add a new element. On the other hand, this implies that you should take care when reserving space for a large number of elements in a vector. If you create a vector that provides for 100,000 elements initially, for example, exceeding this by one element will cause space for another 50,000 to be allocated. In this sort of situation you could check for reaching the capacity, and use <code class="calibre23">reserve()</code> to increase the available memory by a less extravagant amount.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Accessing the Elements in a Vector</h3>
<p class="calibre13">You have already seen that you can access the elements in a vector by using the subscript operator, just as you would for an array. You can also use the <code class="calibre23">at()</code> member function where the argument is the index of the element you want to access. Here’s how you could list the contents of the <code class="calibre23">numbers</code> vector in the previous example using <code class="calibre23">at()</code>:</p>
<pre class="calibre28"><code class="calibre23">  for(vector&lt;int&gt;::size_type i {}; i&lt;numbers.size() ;i++)
    std::cout &lt;&lt; " " &lt;&lt; numbers.at(i);</code></pre>
<p class="calibre13">The operation of <code class="calibre23">at()</code>differs from the subscript operator, <code class="calibre23">[]</code>. If you use a subscript with the subscript operator that is outside the valid range, the result is undefined. If you do the same with <code class="calibre23">at()</code>, an exception of type <code class="calibre23">out_of_range</code> will be thrown. If there’s the potential for subscript values outside the legal range to arise, it’s better to use the <code class="calibre23">at()</code> function and catch the exception than to allow the possibility for undefined results.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="500" id="calibre_link-962" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">operator[]()</code> <i class="calibre15">member function of a vector does check for index out of bounds in debug builds, but not in release builds.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Of course, when you want to access all the elements in a vector, the range-based <code class="calibre23">for</code> loop always provides a simpler mechanism:</p>
<pre class="calibre28"><code class="calibre23">  for(auto number : numbers)
    std::cout &lt;&lt; " " &lt;&lt; number;</code></pre>
<p class="calibre13">To access the first or last element in a vector you can call the <code class="calibre23">front()</code> or <code class="calibre23">back()</code> function, respectively:</p>
<pre class="calibre28"><code class="calibre23">std::cout &lt;&lt; "The value of the first element is: " &lt;&lt; numbers.front() &lt;&lt; std::endl;
std::cout &lt;&lt; "The value of the last element is: " &lt;&lt; numbers.back() &lt;&lt; std::endl;</code></pre>
<p class="calibre13">Both functions come in two versions; one returns a reference to the element, and the other returns a <code class="calibre23">const</code> reference. The latter will be called when the vector object is const. If you call <code class="calibre23">front()</code> for a <code class="calibre23">const</code> vector, you cannot use the reference that is returned to modify the element and you cannot store the return value in a non-<code class="calibre23">const</code> variable.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Inserting and Deleting Elements in a Vector</h3>
<p class="calibre13">In addition to the <code class="calibre23">push_back()</code> function you have seen, a vector container supports the <code class="calibre23">pop_back()</code> operation that deletes the last element. Both operations execute in constant time, that is, the time to execute will be the same, regardless of the number of elements in the vector. The <code class="calibre23">pop_back()</code> function is very simple to use:</p>
<pre class="calibre28"><code class="calibre23">vec.pop_back();</code></pre>
<p class="calibre13">This statement removes the last element from the vector <code class="calibre23">vec</code> and reduces the size by 1. If you call <code class="calibre23">pop_back()</code> for an empty vector the behavior is undefined.</p>
<p class="calibre13">You could remove all the elements in a vector by calling the <code class="calibre23">pop_back()</code> function repeatedly, but the <code class="calibre23">clear()</code> function does this much more simply:</p>
<pre class="calibre28"><code class="calibre23">vec.clear();</code></pre>
<p class="calibre13">This statement removes all the elements from <code class="calibre23">vec</code>, so the size will be zero. Of course, the capacity will be left unchanged.</p>
<section class="toclist">
<h4 class="calibre22">Insert Operations</h4>
<p class="calibre13">You can call the <code class="calibre23">insert()</code> function to insert one or more new elements anywhere in a vector. This operation will execute in linear time, which means that the time increases in proportion to the number of elements in the container. This is because inserting new elements involves moving the existing elements. The simplest version of <code class="calibre23">insert()</code>inserts a single element at a specific position; the first argument is an iterator specifying the insertion position and the second argument is the element to be inserted. For example:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; vec(5, 99);
vec.insert(begin(vec)+1, 88);</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="501" id="calibre_link-963" class="calibre14"></span>The first statement creates a vector with five integer elements, all initialized to 99. The second statement inserts 88 after the first element; so, after executing this, the vector will contain:</p>
<pre class="calibre28"><code class="calibre23">99 88 99 99 99 99</code></pre>
<p class="calibre13">For a vector storing objects, an <code class="calibre23">insert()</code> function call will invoke the version with an rvalue reference parameter when the argument is a temporary object so a temporary object will be moved into the vector, not copied. If the second argument to <code class="calibre23">insert()</code> is an lvalue, the version with a normal reference parameter will be called.</p>
<p class="calibre13">You can insert several identical elements, starting from a given position:</p>
<pre class="calibre28"><code class="calibre23">vec.insert(begin(vec)+2, 3, 77);</code></pre>
<p class="calibre13">The first argument is an iterator specifying the insertion position for the first element, the second argument is the number of elements to be inserted, and the third argument is the element to be inserted. After executing this statement, <code class="calibre23">vec</code> will contain:</p>
<pre class="calibre28"><code class="calibre23">99 88 77 77 77 99 99 99 99</code></pre>
<p class="calibre13">You have yet another version of <code class="calibre23">insert()</code>that inserts a sequence of elements at a given position. The first argument is an iterator pointing to the insertion position for the first element. The second and third arguments are input iterators specifying the range of elements to be inserted from some source. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; newvec(5, 22);
newvec.insert(begin(newvec)+1, begin(vec)+1, begin(vec)+5);</code></pre>
<p class="calibre13">The first statement creates a vector with five integer elements initialized to 22. The second statement inserts four elements from <code class="calibre23">vec</code>, starting with the second. After executing these statements, <code class="calibre23">newvec</code> will contain:</p>
<pre class="calibre28"><code class="calibre23">22 88 77 77 77 22 22 22 22</code></pre>
<p class="calibre13">Don’t forget that the second iterator in the interval specifies the position that is one past the last element, so the element it points to is not included.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Emplace Operations</h4>
<p class="calibre13">The <code class="calibre23">emplace()</code> and <code class="calibre23">emplace_back()</code> member functions insert an object in a vector by creating it in place, rather than moving or copying it. This is useful when the object is constructed using two or more constructor arguments. The <code class="calibre23">emplace()</code> function inserts an object at a specified position. The first parameter is an iterator specifying the insertion position. This is followed by one or more rvalue reference parameters that will be used in a constructor call for type <code class="calibre23">T</code> to create the object in place. The <code class="calibre23">emplace_back()</code> function has one or more rvalue reference parameters that specify the object to be added at the end of the vector. For example, suppose you have defined a vector like this:</p>
<pre class="calibre28"><code class="calibre23">std::vector&lt;CBox&gt; boxes;</code></pre>
<p class="calibre13">You could add <code class="calibre23">CBox</code> objects to the vector like this:</p>
<pre class="calibre28"><code class="calibre23">boxes.push_back(CBox {1, 2, 3});
boxes.push_back(CBox {2, 4, 6});
boxes.push_back(CBox {3, 6, 9});</code></pre>
<p class="calibre13">This will create and append three <code class="calibre23">CBox</code> objects to the vector.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="502" id="calibre_link-964" class="calibre14"></span>Alternatively you could write this:</p>
<pre class="calibre28"><code class="calibre23">boxes.emplace_back(1, 2, 3);
boxes.emplace_back(2, 4, 6);
boxes.emplace_back(3, 6, 9);</code></pre>
<p class="calibre13">Each <code class="calibre23">emplace_back()</code> call selects the <code class="calibre23">CBox</code> constructor to create the object to be added to the end of the vector based on the arguments to the function. Using <code class="calibre23">emplace_back()</code> will result in fewer <code class="calibre23">CBox</code> objects being created than in the case of <code class="calibre23">push_back()</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Erase Operations</h4>
<p class="calibre13">The <code class="calibre23">erase()</code> member function deletes one or more elements from any position within a vector, but this also is a linear time function and will typically be slow. Here’s how you erase a single element at a given position:</p>
<pre class="calibre28"><code class="calibre23">newvec.erase(end(newvec)-2);</code></pre>
<p class="calibre13">The argument is an iterator that points to the element to be erased, so this statement removes the second to last element from <code class="calibre23">newvec</code>.</p>
<p class="calibre13">To delete several elements, you supply two iterator arguments specifying the interval. For example:</p>
<pre class="calibre28"><code class="calibre23">newvec.erase(begin(newvec)+1, begin(newvec)+4);</code></pre>
<p class="calibre13">This will delete the second, third, and fourth elements from <code class="calibre23">newvec</code>. The element that the second iterator argument points to is not included in the operation.</p>
<p class="calibre13">As I said, both the <code class="calibre23">erase()</code> and <code class="calibre23">insert()</code> operations are slow, so you should use them sparingly.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Swap and Assign Operations</h4>
<p class="calibre13">The <code class="calibre23">swap()</code> member function enables you to swap the contents of two vectors, provided, of course, the elements in the two vectors are of the same type. Here’s a code fragment showing an example of how this works:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;int&gt; first(5, 77);              // Contains 77 77 77 77 77
vector&lt;int&gt; second(8, -1);             // Contains -1 -1 -1 -1 -1 -1 -1 -1
first.swap(second);</code></pre>
<p class="calibre13">After executing the last statement, the contents of the vectors <code class="calibre23">first</code> and <code class="calibre23">second</code> will have interchanged. Note that the capacities of the vectors are swapped as well as the contents and, of course, the size.</p>
<p class="calibre13">The <code class="calibre23">assign()</code> member function replaces the entire contents of a vector with another sequence, or replaces the contents with a given number of instances of an object. Here’s how you could replace the contents of one vector with a sequence from another:</p>
<pre class="calibre28"><code class="calibre23">vector&lt;double&gt; values;
for(int i {1}; i &lt;= 50 ;++i)
  values.emplace_back(2.5*i);
vector&lt;double&gt; newdata(5, 3.5);
newdata.assign(begin(values)+1, end(values)-1);</code></pre>
<p class="calibre13">This creates the <code class="calibre23">values</code> vector and stores 50 elements that have the values 2.5, 5.0, 7.5, ... 125.0. The <code class="calibre23">newdata</code> vector is created with five elements, each having the value 3.5. The last statement calls the <code class="calibre23">assign()</code> member of <code class="calibre23">newdata</code>, which deletes all elements from <code class="calibre23">newdata</code>, and then inserts copies of all the elements from <code class="calibre23">values</code>, except for the first and the last. You specify the new sequence to be <span {http://www.idpf.org/2007/ops}type="pagebreak" title="503" id="calibre_link-965" class="calibre14"></span>inserted by two iterators, the first pointing to the first element to be inserted and the second pointing to one past the last element to be inserted. Because you specify the new elements to be inserted by two iterators, the source of the data can be from any sequence, not just a vector. The <code class="calibre23">assign()</code> function will also work with regular pointers, so, for example, you could insert elements from an array of <code class="calibre23">double</code> elements.</p>
<p class="calibre13">Here’s how you use <code class="calibre23">assign()</code>to replace the contents of a vector with a sequence of instances of the same element:</p>
<pre class="calibre28"><code class="calibre23">newdata.assign(30, 99.5);</code></pre>
<p class="calibre13">The first argument is the count of elements in the replacement sequence, and the second argument is the element to be used. This statement will cause the contents of <code class="calibre23">newdata</code> to be deleted and replaced by 30 elements, each having the value 99.5.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Storing Class Objects in a Vector</h3>
<p class="calibre13">You can store objects of any class type in a vector, but the class must meet certain minimum criteria. Here’s a minimum specification for a given class <code class="calibre23">T</code> to be compatible with a vector or, in fact, any sequence container:</p>
<pre class="calibre28"><code class="calibre23">class T
{
public:
  T();                                 // Default constructor
  T(const T&amp; t);                       // Copy constructor
  ~T();                                // Destructor
  T&amp; operator=(const T&amp; t);            // Assignment operator
};</code></pre>
<p class="calibre13">The compiler will supply default versions of these class members if you don’t define them, so it’s not difficult for a class to meet these requirements. The important thing to note is that they are required and are likely to be used, so when the default implementation that the compiler supplies will not suffice, you must provide your own implementation.</p>
<p class="calibre13">If you store objects of your own class types in a vector, it’s highly recommended that you implement a move constructor and a move assignment operator for your class because the vector container fully supports move semantics. For example, if the vector needs to resize itself to allow more elements to be added, without move semantics the following sequence of events will occur:</p>
<ol class="calibre5">
<li class="calibre6">A new vector with the new size is allocated.</li>
<li class="calibre6">All objects from the old vector are copied to the new vector.</li>
<li class="calibre6">All objects in the old vector are destroyed.</li>
<li class="calibre6">The old vector is deallocated.</li>
</ol>
<p class="calibre13">With move semantics support in your class, this is what happens:</p>
<ol class="calibre5">
<li class="calibre6">A new vector with the new size is allocated.</li>
<li class="calibre6">All objects from the old vector are moved to the new vector.</li>
<li class="calibre6">All objects in the old vector are destroyed.</li>
<li class="calibre6">The old vector is deallocated.</li>
</ol>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="504" id="calibre_link-966" class="calibre14"></span>This will be significantly faster because no copying is necessary.</p>
<p class="calibre13">Let’s try an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Storing Objects in a Vector</h3>
<p class="calibre20">In this example you create <code class="calibre23">Person</code> objects that represent individuals by their name. Just to make it more interesting, we will pretend we have never heard of the <code class="calibre23">string</code> class, so we are stuck with using null-terminated strings to store names. This means you have to take care how you implement the class if you want to store objects in a <code class="calibre23">vector&lt;Person&gt;</code> container. In general, a <code class="calibre23">Person</code> class might have lots of data members relating to a person, but we will keep it simple with just their first and second names.</p>
<p class="calibre20">Here’s the definition of the <code class="calibre23">Person</code> class:</p>
<pre class="calibre28"><code class="calibre23">// Person.h in Ex10_02
// A class defining people by their names
#pragma once
#include &lt;cstring&gt;
#include &lt;iostream&gt;
        
class Person
{
  public:
  // Constructor, includes no-arg constructor
  Person (const char* first, const char* second)
  {
    initName(first, second);
  }
        
  // Copy constructor
  Person(const Person&amp; p)
  {
    initName(p.firstname, p.secondname);
  }
        
  // Move constructor
  Person(Person&amp;&amp; p)
  {
  firstname = p.firstname;
  secondname = p.secondname;
    // Reset rvalue object pointers to prevent deletion
    p.firstname = nullptr;
    p.secondname = nullptr;
  }
        
  // Destructor
  virtual ~Person()
  {
    delete[] firstname;
    delete[] secondname;
  }
        
  // Copy assignment operator
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="505" id="calibre_link-967" class="calibre14"></span>Person&amp; operator=(const Person&amp; p)
  {
    // Deal with p = p assignment situation
    if(&amp;p != this)
    {        
      delete[] firstname;
      delete[] secondname;
      initName(p.firstname, p.secondname);
    }
    return *this;
  }
        
  // Move assignment operator
  Person&amp; operator=(Person&amp;&amp; p)
  {
    // Deal with p = p assignment situation
    if(&amp;p != this)
    {
      // Release current memory        
      delete[] firstname;
      delete[] secondname;
      firstname = p.firstname;
      secondname = p.secondname;
      p.firstname = nullptr;
      p.secondname = nullptr;
    }
    return *this;
  }
  // Less-than operator
  bool operator&lt;(const Person&amp; p) const
  {
    int result {strcmp(secondname, p.secondname)};
    return (result &lt; 0 || result ==  0 &amp;&amp; strcmp(firstname, p.firstname) &lt; 0);
  }
        
  // Output a person
  void showPerson() const
  {
    std::cout &lt;&lt; firstname &lt;&lt; " " &lt;&lt; secondname &lt;&lt; std::endl;
  }
        
  private:
  char* firstname {};
  char* secondname {};
        
  // Private helper function to avoid code duplication
  void initName(const char* first, const char* second)
  {
    size_t length {strlen(first)+1};
    firstname = new char[length];
    strcpy_s(firstname, length, first);
    length = strlen(second)+1;
    secondname = new char[length];
    strcpy_s(secondname, length, second);
  }
};</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="506" id="calibre_link-968" class="calibre14"></span>The private <code class="calibre23">initName()</code> function is there because the constructors and the assignment operator function need to carry out the same operations to initialize the data members. Using this helper function avoids repeating the same code.</p>
<p class="calibre20">Because the <code class="calibre23">Person</code> class allocates memory dynamically to store the first and second names of a person, you must implement the destructor to release the memory when an object is destroyed. You must also implement the assignment operator because this involves more memory allocation. Note the code at the beginning for dealing with the <code class="calibre23">a = a</code> assignment situation. Assigning an object to itself can arise in ways that are less than obvious, and can cause problems if you don’t implement the <code class="calibre23">operator=()</code> function to take account of this.</p>
<p class="calibre20">The <code class="calibre23">showPerson()</code> function is a convenience function for outputting an entire name. It is declared as <code class="calibre23">const</code> to allow it to work with <code class="calibre23">const</code> and non-<code class="calibre23">const Person</code> objects. The <code class="calibre23">operator&lt;()</code> function is there for use later.</p>
<p class="calibre20">The program to store <code class="calibre23">Person</code> objects in a vector looks like this:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_02.cpp
// Storing objects in a vector
        
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "Person.h"
        
using std::vector;
        
int main()
{
  vector&lt;Person&gt; people;               // Vector of Person objects
  const size_t maxlength {50};
  char firstname[maxlength];
  char secondname[maxlength];
        
  // Input all the people
  while(true)
  {
    std::cout &lt;&lt; "Enter a first name or press Enter to end: ";
    std::cin.getline(firstname, maxlength, '\n');
    if(strlen(firstname) == 0)
      break;
    std::cout &lt;&lt; "Enter the second name: ";
    std::cin.getline(secondname, maxlength, '\n');
    people.emplace_back(Person(firstname, secondname));
  }
        
  // Output the contents of the vector using an iterator
  std::cout &lt;&lt; std::endl;
  auto iter = cbegin(people); 
  while(iter != cend(people))
  { 
    iter-&gt;showPerson();
    ++iter;
  }
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="507" id="calibre_link-969" class="calibre14"></span>Here’s an example of some output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter a first name or press Enter to end: Jane
Enter the second name: Fonda
Enter a first name or press Enter to end: Bill
Enter the second name: Cosby
Enter a first name or press Enter to end: Sally
Enter the second name: Field
Enter a first name or press Enter to end: Mae
Enter the second name: West
Enter a first name or press Enter to end: Oliver
Enter the second name: Hardy
Enter a first name or press Enter to end:
        
Jane Fonda
Bill Cosby
Sally Field
Mae West
Oliver Hardy</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You create a vector to store <code class="calibre23">Person</code> objects like this:</p>
<pre class="calibre28"><code class="calibre23"> vector&lt;Person&gt; people;               // Vector of Person objects</code></pre>
<p class="calibre20">You then create two arrays of type <code class="calibre23">char[]</code> that you’ll use as working storage when reading names from the standard input stream:</p>
<pre class="calibre28"><code class="calibre23">  const size_t maxlength {50};
  char firstname[maxlength];
  char secondname[maxlength];</code></pre>
<p class="calibre20">Each array accommodates up to <code class="calibre23">maxlength</code> characters, including the terminating null.</p>
<p class="calibre20">You read names from the standard input stream in an indefinite loop:</p>
<pre class="calibre28"><code class="calibre23">  while(true)
  {
    std::cout &lt;&lt; "Enter a first name or press Enter to end: ";
    std::cin.getline(firstname, maxlength, '\n');
    if(strlen(firstname) == 0)
      break;
    std::cout &lt;&lt; "Enter the second name: ";
    std::cin.getline(secondname, maxlength, '\n');
    people.emplace_back(firstname, secondname);
  }</code></pre>
<p class="calibre20">You read each name using the <code class="calibre23">getline()</code> member function for <code class="calibre23">cin</code>. This reads characters until a newline is read, or until <code class="calibre23">maxlength-1</code> characters have been read. This ensures that you don’t overrun the capacity of the input array because both arrays have <code class="calibre23">maxlength</code> elements, allowing for strings up to <code class="calibre23">maxlength-1</code> characters plus the terminating null. When an empty string is entered for the first name, the loop ends.</p>
<p class="calibre20">The <code class="calibre23">Person</code> object is created from the arguments to the <code class="calibre23">emplace_back()</code> function at the end of the vector.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="508" id="calibre_link-970" class="calibre14"></span>The last step is to output the contents of the vector:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; std::endl;
  auto iter = cbegin(people); 
  while(iter != cend(people))
  { 
    iter-&gt;showPerson();
    ++iter;
  }</code></pre>
<p class="calibre20">Here, you use an iterator of type <code class="calibre23">vector&lt;Person&gt;::const_iterator</code> to output the elements with the type deduced automatically from the initial value. Within the body of the loop, you output the element that the iterator points to and then increment the iterator. The loop continues as long as <code class="calibre23">iter</code> is not equal to the iterator returned by <code class="calibre23">cend()</code>.</p>
<p class="calibre20">This demonstrated the use of iterators but a range-based <code class="calibre23">for</code> loop would greatly simplify the code for the output:</p>
<pre class="calibre28"><code class="calibre23">  for(const auto&amp; p : people)
   p.showPerson();</code></pre>
<p class="calibre20">The loop variable, <code class="calibre23">p</code>, will be of type <code class="calibre23">Person&amp;</code>, which is a reference to the type of element stored in the vector.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Sorting Vector Elements</h3>
<p class="calibre13">The <code class="calibre23">sort&lt;T&gt;()</code> function template that is defined in the <code class="calibre23">algorithm</code> header will sort a sequence of objects of any type as long as the required comparisons are supported. Objects are sorted in ascending sequence by default so the <code class="calibre23">&lt;</code> operation must be supported. You identify the sequence by two random access iterators that point to the first and one-past-the-last objects. Note that random access iterators are essential; iterators with lesser capability will not suffice. The type parameter, <code class="calibre23">T</code>, specifies the type of random access iterator that the function will use. Thus, the <code class="calibre23">sort&lt;T&gt;()</code> template can sort the contents of any container that provides random access iterators, as long as the object type supports comparisons.</p>
<p class="calibre13">In the previous example, you implemented <code class="calibre23">operator &lt;()</code> in the <code class="calibre23">Person</code> class, so you could sort a sequence of <code class="calibre23">Person</code> objects. Here’s how you could sort the contents of the <code class="calibre23">vector&lt;Person&gt;</code> container:</p>
<pre class="calibre28"><code class="calibre23">std::sort(stdbegin(people), stdend(people));</code></pre>
<p class="calibre13">This sorts the contents of the vector in ascending sequence. You can add an <code class="calibre23">#include</code> directive for <code class="calibre23">algorithm</code>, and put the statement in <code class="calibre23">main()</code> before the output loop, to see the sort in action. Note that you can use <code class="calibre23">sort&lt;T&gt;()</code> to sort arrays. The only requirement is that the <code class="calibre23">&lt;</code> operator should work with the type of the elements. Here’s a code fragment showing how you could use it to sort an array of integers:</p>
<pre class="calibre28"><code class="calibre23">const size_t N {100};
int data[N];
std::cout &lt;&lt; "Enter up to " &lt;&lt; N &lt;&lt; " non-zero integers. Enter 0 to end:\n";
int value {};
size_t count {};
for(size_t i {} ;i&lt;N ;i++)            // Read up to N integers
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="509" id="calibre_link-971" class="calibre14"></span>{
  std::cin &gt;&gt; value;                  // Read a value
  if(!value)                          // If it is zero,
    break;                            // we are done
  data[count++] = value;
}
std::sort(data, data+count);          // Sort the integers</code></pre>
<p class="calibre13">Note how the pointer marking the end of the sequence of elements to be sorted must still be one past the last element.</p>
<p class="calibre13">When you need to sort a sequence in descending order, you can use the version of the <code class="calibre23">sort&lt;T&gt;()</code> algorithm that accepts a third argument that is a function object that defines a binary predicate. The <code class="calibre23">functional</code> header defines a complete set of function object types for comparison predicates:</p>
<pre class="calibre28"><code class="calibre23">less&lt;T&gt;   less_equal&lt;T&gt;   equal&lt;T&gt;   greater_equal&lt;T&gt;   greater&lt;T&gt;</code></pre>
<p class="calibre13">Each of these templates creates a class type for function objects that you can use with <code class="calibre23">sort()</code> and other algorithms for sorting objects of type <code class="calibre23">T</code>. The <code class="calibre23">sort()</code> function used in the previous fragment uses a <code class="calibre23">less&lt;int&gt;</code> function object by default. To specify a different function object to be used as the sort criterion, you add it as a third argument, like this:</p>
<pre class="calibre28"><code class="calibre23">std::sort(data, data+count, std::greater&lt;int&gt;());     // Sort the integers</code></pre>
<p class="calibre13">The third argument to the function is an expression that calls the constructor for the <code class="calibre23">greater&lt;int&gt;</code> type, so you are passing an object of this type to the <code class="calibre23">sort()</code> function. This statement will sort the contents of the <code class="calibre23">data</code> array in descending sequence. If you are trying these fragments out, don’t forget that you need the <code class="calibre23">functional</code> header to be included for the function object. The comparison predicates also come in the form of transparent operator functors. They are referred to as transparent because they perform perfect forwarding of the arguments. When you want to use the transparent form with an algorithm, you just omit the template type argument, like this:</p>
<pre class="calibre28"><code class="calibre23">std::sort(data, data+count, std::greater&lt;&gt;());</code></pre>
<p class="calibre13">This sorts the container contents with perfect forwarding of the objects to be compared.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Storing Pointers in a Vector</h3>
<p class="calibre13">A vector container, like other containers, makes a copy of the objects you add to it. This has tremendous advantages in many circumstances, but it could be very inconvenient in some situations. For example, if your objects are large, there could be considerable overhead in copying each object as you add it to the container. This is an occasion where you might be better off storing smart pointers to the objects in the container. You could create a new version of the <code class="calibre23">Ex10_02.cpp</code> example to store pointers to <code class="calibre23">Person</code> objects in a container.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Storing Pointers in a Vector</h3>
<p class="calibre20">The <code class="calibre23">Person</code> class definition is exactly the same as before. Here’s a revised version of the source file that defines <code class="calibre23">main()</code>:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_03.cpp
// Storing pointers to objects in a vector
#include &lt;iostream&gt;
#include &lt;vector&gt;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="510" id="calibre_link-972" class="calibre14"></span>#include &lt;memory&gt;
#include "Person.h" 
using std::vector;
using std::unique_ptr;
using std::make_unique;
 
int main()
{
  vector&lt;unique_ptr&lt;Person&gt;&gt; people;           // Vector of Person object pointers
  const size_t maxlength {50};
  char firstname[maxlength];
  char secondname[maxlength];
  while(true)
  {
    std::cout &lt;&lt; "Enter a first name or press Enter to end: ";
    std::cin.getline(firstname, maxlength, '\n'); 
    if(strlen(firstname) == 0)
      break;
    std::cout &lt;&lt; "Enter the second name: ";
    std::cin.getline(secondname, maxlength, '\n'); 
    people.push_back(make_unique&lt;Person&gt;(firstname, secondname));
  }
  // Output the contents of the vector
  std::cout &lt;&lt; std::endl;
  for( const auto&amp; p : people)
    p-&gt;showPerson();
}</code></pre>
<p class="calibre20">The output is essentially the same as before.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">There is an <code class="calibre23">#include</code> directive for the <code class="calibre23">memory</code> header and additional <code class="calibre23">using</code> declarations for the <code class="calibre23">unique_ptr</code> and the <code class="calibre23">make_unique</code> names. The first change in <code class="calibre23">main()</code> from <code class="calibre23">Ex10_02</code> is in the definition of the container:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;unique_ptr&lt;Person&gt;&gt; people;           // Vector of Person object pointers</code></pre>
<p class="calibre20">The <code class="calibre23">vector&lt;T&gt;</code> template type parameter is now <code class="calibre23">unique_ptr&lt;Person&gt;</code>, which is a smart pointer to a <code class="calibre23">Person</code> object. We can use <code class="calibre23">unique_ptr</code> because there is not sharing of ownership in the example.</p>
<p class="calibre20">Within the input loop, each <code class="calibre23">Person</code> object is now created on the heap, and the address wrapped inside a <code class="calibre23">unique_ptr</code> is passed to the <code class="calibre23">push_back()</code> function for the vector:</p>
<pre class="calibre28"><code class="calibre23">  people.push_back(make_unique&lt;Person&gt;(firstname, secondname));</code></pre>
<p class="calibre20">The arguments to <code class="calibre23">make_unique&lt;Person&gt;()</code> are the arguments that it will use for the <code class="calibre23">Person</code> class constructor that will be pointed to by the <code class="calibre23">uniqued_ptr&lt;Person&gt;</code> object it will return. This is stored in the vector by the <code class="calibre23">push_back()</code> function.</p>
<p class="calibre20">You output the <code class="calibre23">Person</code> objects using the range-based <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  for(const auto&amp; p : people)
   p-&gt;showPerson();</code></pre>
<p class="calibre20">This time <code class="calibre23">p</code> is of type <code class="calibre23">unique_ptr&lt;Person&gt;&amp;</code>, so you use the indirect member selection operator to call <code class="calibre23">showPerson()</code> for each <code class="calibre23">Person</code> object.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="511" id="calibre_link-973" class="calibre14"></span>Finally, you empty the vector by calling its <code class="calibre23">clear()</code> function. This deletes everything stored in the container. There is no need to delete <code class="calibre23">Person</code> objects. This will be taken care of when the smart pointers are destroyed.</p>
<p class="calibre20">You could also store <code class="calibre23">shared_ptr&lt;Person&gt;</code> objects in the vector:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;shared_ptr&lt;Person&gt;&gt; people;          // Vector of Person object pointers</code></pre>
<p class="calibre20">The statement to store the pointers in the vector would be:</p>
<pre class="calibre28"><code class="calibre23">  people.push_back(make_shared&lt;Person&gt;(firstname, secondname));</code></pre>
<p class="calibre20">The loop to output the <code class="calibre23">Person</code> objects would be the same. However, there’s a difference between using <code class="calibre23">unique_ptr</code> and <code class="calibre23">shared_ptr</code>. This rather less efficient loop would work with <code class="calibre23">shared_ptr</code> objects:</p>
<pre class="calibre28"><code class="calibre23">  for(auto p : people)
   p-&gt;showPerson();</code></pre>
<p class="calibre20">However, this will not compile with <code class="calibre23">unique_ptr</code> objects in the vector because they cannot be copied. You must use a reference to access the elements in this case.</p>
<p class="calibre20">These statements also would not compile:</p>
<pre class="calibre28"><code class="calibre23">  auto pPerson = make_unique&lt;Person&gt;(firstname, secondname);
  people.push_back(pPerson);</code></pre>
<p class="calibre20">This involves copying the <code class="calibre23">unique_ptr</code> object so it’s not allowed.</p>
<p class="calibre20">You could do this though:</p>
<pre class="calibre28"><code class="calibre23">  people.push_back(std::move(pPerson));</code></pre>
<p class="calibre20">This moves the pointer in <code class="calibre23">pPerson</code> to a <code class="calibre23">unique_ptr</code> in the vector. But now <code class="calibre23">pPerson</code> is not valid, so this statement would throw an exception:</p>
<pre class="calibre28"><code class="calibre23">  pPerson-&gt;showPerson();</code></pre>
<p class="calibre20">If you plan to retain a smart pointer for use after you have stored it in a container, use a <code class="calibre23">shared_ptr</code> and not a <code class="calibre23">unique_ptr</code>.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Array Containers</h3>
<p class="calibre13">The <code class="calibre23">array&lt;T,N&gt;</code> template that is defined in the <code class="calibre23">array</code> header defines a container that is similar to an ordinary array in that it is of fixed length, <code class="calibre23">N</code>, and you can use the subscript operator to access the elements. You can also initialize an array container with an initializer list. For example:</p>
<pre class="calibre28"><code class="calibre23">std::array&lt;double, 5&gt; values {1.5, 2.5, 3.5, 4.5, 5.5};</code></pre>
<p class="calibre13">If you supply fewer initializers than there are elements, the remaining elements will be initialized with the equivalent of zero. This means <code class="calibre23">nullptr</code> if the elements are pointers, and objects created by the default constructor if the elements are objects of a class type. If you supply too many initializers, the code won’t compile.</p>
<p class="calibre13">You can define an array container without initializing it:</p>
<pre class="calibre28"><code class="calibre23">std::array&lt;int, 4&gt; data;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="512" id="calibre_link-974" class="calibre14"></span>The size is fixed and the four elements of type <code class="calibre23">int</code> will be created containing junk values. Array container elements of a fundamental type will not be initialized by default, but elements of a class type will be initialized by calling the no-arg constructor. You could construct an array of <code class="calibre23">Person</code> objects where the <code class="calibre23">Person</code> class is as in <code class="calibre23">Ex10_03</code>:</p>
<pre class="calibre28"><code class="calibre23">std::array&lt;Person, 10&gt; people;</code></pre>
<p class="calibre13">This container has 10 elements of type <code class="calibre23">Person</code>, all with the <code class="calibre23">firstname and secondname members as nullptr</code>.</p>
<p class="calibre13">An array container knows its size, so you can use the range-based <code class="calibre23">for</code> loop when it is passed to a function. For example, here’s a function template that will list any array container of <code class="calibre23">Person</code> objects:</p>
<pre class="calibre28"><code class="calibre23">template&lt;size_t N&gt;
void listPeople(const std::array&lt;Person, N&gt;&amp; folks)
{
  for(const auto&amp; p : folks)
    p.showPerson();
}</code></pre>
<p class="calibre13">Defining the function by a template with a parameter, <code class="calibre23">N</code>, allows it to be used to list an array of any number of <code class="calibre23">Person</code> objects. If your application classes use a standard function to display an object, you could add a template type parameter for the type of element stored and get a function that will list any of your arrays of any length or type. Remember, though, that each unique set of template parameter values will produce a separate instance of the template.</p>
<p class="calibre13">Because the elements of an array container are always created when you define it, you can reference an element using the subscript operator and use it as an lvalue. For example:</p>
<pre class="calibre28"><code class="calibre23">people[1] = Person("Joe", "Bloggs");</code></pre>
<p class="calibre13">This stores a <code class="calibre23">Person</code> object in the second element in the array.</p>
<p class="calibre13">Here’s a summary of some of the most useful members of an array container type:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">void fill(const T&amp; arg)</code> sets all the array elements to <code class="calibre23">arg</code>:
<pre class="calibre28"><code class="calibre23">people.fill(Person("Ned", "Kelly"));   // Fill array with Ned Kellys</code></pre></li>
<li class="calibre6"><code class="calibre23">size()</code> returns the size of the array as an integer.</li>
<li class="calibre6"><code class="calibre23">back()</code> returns a reference to the last array element:
<pre class="calibre28"><code class="calibre23">people.back().showPerson();            // Output the last person</code></pre></li>
<li class="calibre6"><code class="calibre23">begin()</code> returns an iterator pointing to the first array element.</li>
<li class="calibre6"><code class="calibre23">end()</code> returns an iterator pointing to one past the last array element.</li>
<li class="calibre6"><code class="calibre23">rbegin()</code> returns a reverse iterator pointing to the last array element.</li>
<li class="calibre6"><code class="calibre23">rend()</code> returns a reverse iterator pointing to before the first array element.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="513" id="calibre_link-975" class="calibre14"></span><code class="calibre23">swap(array&amp; right)</code> swaps the current array with <code class="calibre23">right</code>. The current array and <code class="calibre23">right</code> must store the same type of elements and have the same size.
<pre class="calibre28"><code class="calibre23">array&lt;int, 3&gt; left = {1, 2, 3};
array&lt;int, 3&gt; right = {10, 20, 30};
left.swap(right);           // Swap contents of left and right</code></pre></li>
</ul>
<p class="calibre13">You can use any of the comparison operators, <code class="calibre23">&lt;, &lt;=, ==, &gt;=, &gt;</code>, and <code class="calibre23">!=</code>, to compare two array containers as long as they store the same number of elements of the same type. Corresponding elements are compared in sequence to determine the result. For example, <code class="calibre23">array1&lt;array2</code> will result in <code class="calibre23">true</code> if <code class="calibre23">array1</code> has the first occurring element that is less than the corresponding element in <code class="calibre23">array2</code>. Two arrays are equal if all corresponding elements are equal and unequal if any pair of corresponding elements differ.</p>
<p class="calibre13">Let’s see an example of an array in use.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using an Array</h3>
<p class="calibre20">This example creates an interesting series of values in array containers:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_04
// Using array containers
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;array&gt;
#include &lt;numeric&gt;
using std::array;
 
// Lists array container contents
template&lt;class T, size_t N&gt;
void listValues(const array&lt;T, N&gt;&amp; data)
{
  const int values_per_line {6};
  int count {};
  for(const auto&amp; value: data)
  {
    std::cout &lt;&lt; std::setw(14) &lt;&lt; value;
    if(++count % values_per_line == 0)
      std::cout &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; std::endl;
}
 
int main()
{
  // Create the famous Fibonacci series
  const size_t N {20};
  array&lt;long, N&gt; fibonacci {1L, 1L};
  for(size_t i {2} ;i&lt;fibonacci.size() ;++i)
    fibonacci[i] = fibonacci[i-1] + fibonacci[i-2];
  std::cout &lt;&lt; "Fibonacci series is:" &lt;&lt; std::endl;
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="514" id="calibre_link-976" class="calibre14"></span>listValues(fibonacci);
 
  array&lt;long, N&gt; numbers;
  numbers.fill(99L); 
  fibonacci.swap(numbers);
  std::cout &lt;&lt; std::endl &lt;&lt; "After swap fibonacci contains:" &lt;&lt; std::endl;
  listValues(fibonacci);
 
  // Create the series for pi/4
  array&lt;double, 120&gt; series;
  double factor {-1.0};
  for(size_t x {} ;x&lt;series.size() ;++x)
  {
    factor *= -1.0;
    series[x] = factor/(2*x+1);
  }
  std::cout &lt;&lt; std::endl &lt;&lt; "Series for pi is:" &lt;&lt; std::endl;
  listValues(series);
  double result {std::accumulate(cbegin(series), cend(series), 0.0)};
  std::cout &lt;&lt; "The series sum converges slowly to pi/4. The sum x 4 is: " 
            &lt;&lt; 4.0*result &lt;&lt; std::endl;
}</code></pre>
<p class="calibre20">I won’t include the output here because there’s quite a lot of it.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You create the first array container with 20 elements of type <code class="calibre23">long</code> with the first two initialized to <code class="calibre23">1L</code>. In the Fibonacci series, each element is the sum of the two preceding elements and the <code class="calibre23">for</code> loop sets the values for the array from the third element onwards. You output the contents of the array using the <code class="calibre23">listValues()</code> template function. This lists values of elements from an array container of any size that contains elements of any type that can be written to the standard output stream.</p>
<p class="calibre20">Next, you create the <code class="calibre23">numbers</code> container storing the same number of <code class="calibre23">long</code> elements as <code class="calibre23">fibonacci</code>. The elements are all set to <code class="calibre23">99L</code> using the <code class="calibre23">fill()</code> member function. You use the <code class="calibre23">swap()</code>member function to swap the contents of <code class="calibre23">numbers</code> and <code class="calibre23">fibonacci</code>, and the output shows that <code class="calibre23">fibonacci</code> now contains elements that are all 99.</p>
<p class="calibre20">The third container, <code class="calibre23">series</code>, contains 120 elements of type <code class="calibre23">double</code>. The values are set in the <code class="calibre23">for</code> loop to those of the Leibnitz series that total π/4 if you sum an infinite number of them.</p>
<p class="calibre20">You sum the 120 elements using the <code class="calibre23">accumulate()</code> template function that is defined in the numeric header. The first argument is an iterator specifying the first container element, the second is an iterator specifying one past the last element, and the third argument is an initial value to which the values specified by the first two arguments are to be added. This function works with any sequence container that contains elements that support the <code class="calibre23">+</code> operator. There is another version of <code class="calibre23">accumulate()</code> that accepts a fourth argument that specifies the operation to be applied between elements if you don’t want to add them. You specify the operation by a function object or lambda expression that defines a binary predicate.</p>
<p class="calibre20">You’ll see from the output that the sum of the first 120 elements in the Leibnitz series is fairly close to π/4.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="515" id="calibre_link-977" class="calibre24"></span>Double-ended Queue Containers</h3>
<p class="calibre13">The double-ended queue container template, <code class="calibre23">deque&lt;T&gt;</code>, is defined in the <code class="calibre23">deque</code> header. A double-ended queue is very similar to a vector in that it can do everything a vector container can, and includes the same function members, but you can also add and delete elements efficiently at the beginning of the sequence as well as at the end. You could replace the vector in <code class="calibre23">Ex10_02.cpp</code> with a double-ended queue, and it would work just as well:</p>
<pre class="calibre28"><code class="calibre23">  std::deque&lt;Person&gt; people;               // Double-ended queue of Person objects</code></pre>
<p class="calibre13">The <code class="calibre23">push_front()</code> member function adds an element to the front of the container and you can delete the first element by calling <code class="calibre23">pop_front()</code>. There’s also an <code class="calibre23">emplace_front()</code> member so if you were using a <code class="calibre23">deque&lt;Person&gt;</code> container in <code class="calibre23">Ex10_02.cpp</code>, you could add elements at the front instead of the back:</p>
<pre class="calibre28"><code class="calibre23">    people.emplace_front(firstname, secondname);</code></pre>
<p class="calibre13">Using this statement to add elements, the order of elements in the double-ended queue would be the reverse of those in the vector.</p>
<p class="calibre13">Here are examples of constructors  for a <code class="calibre23">deque&lt;T&gt;</code> container:</p>
<pre class="calibre28"><code class="calibre23">deque&lt;string&gt; strings;            // An empty container
deque&lt;int&gt; items(50);             // 50 elements initialized to default value
deque&lt;double&gt; values(5, 0.5);     // 5 elements of 0.5
deque&lt;int&gt; data(cbegin(items), cend(items));  // Initialized with a sequence
deque&lt;int&gt; numbers {1, 3, 5, 7, 9, 11};</code></pre>
<p class="calibre13">Although a double-ended queue is very similar to a vector and does everything a vector can do, it does have one disadvantage. Because of the additional capability, the memory management for a double-ended queue is more complicated than for a vector, so it will be slightly slower. Unless you need to add elements to the front of the container, a vector is a better choice. Let’s see a double-ended queue in action.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Double-ended Queue</h3>
<p class="calibre20">This example stores an arbitrary number of integers in a double-ended queue and then operates on them:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_05.cpp
// Using a double-ended queue
        
#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;algorithm&gt;                 // For sort&lt;T&gt;()
#include &lt;numeric&gt;                   // For accumulate&lt;T&gt;()
#include &lt;functional&gt;                // For transparent operator functors
        
int main()
{
  std::deque&lt;int&gt; data;
        
  // Read the data
  std::cout &lt;&lt; "Enter a series of non-zero integers separated by spaces."
            &lt;&lt; " Enter 0 to end." &lt;&lt; std::endl;
  int value {};
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="516" id="calibre_link-978" class="calibre14"></span>while(std::cin &gt;&gt; value, value != 0)
    data.push_front(value);
        
  // Output the data
  std::cout &lt;&lt; std::endl &lt;&lt; "The values you entered are:" &lt;&lt; std::endl;
  for(const auto&amp; n : data)
    std::cout &lt;&lt; n &lt;&lt; "  ";
  std::cout &lt;&lt; std::endl;
        
  // Output the data using a reverse iterator
  std::cout &lt;&lt; std::endl 
            &lt;&lt; "In reverse order the values you entered are:" &lt;&lt; std::endl;
  for(auto riter = crbegin(data) ;riter != crend(data) ; ++riter)
    std::cout &lt;&lt; *riter &lt;&lt; "  ";
  std::cout &lt;&lt; std::endl;
        
  // Sort the data in descending sequence
  std::cout &lt;&lt; std::endl 
            &lt;&lt; "In descending sequence the values you entered are:" &lt;&lt; std::endl;
  std::sort(begin(data), end(data), std::greater&lt;&gt;());   // Sort the elements
  for(const auto&amp; n : data)
    std::cout &lt;&lt; n &lt;&lt; "  ";
  std::cout &lt;&lt; std::endl;
        
  // Calculate the sum of the elements
  std::cout &lt;&lt; std::endl &lt;&lt; "The sum of the elements in the queue is: "
            &lt;&lt; std::accumulate(cbegin(data), cend(data), 0)  &lt;&lt; std::endl;
        
}</code></pre>
<p class="calibre20">Here is some sample output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter a series of non-zero integers separated by spaces. Enter 0 to end.
405 302 1 23 67 34 56 111 56 99 77 82 3 23 34 111 89 0
        
The values you entered are:
89  111  34  23  3  82  77  99  56  111  56  34  67  23  1  302  405
        
In reverse order the values you entered are:
405  302  1  23  67  34  56  111  56  99  77  82  3  23  34  111  89
        
In descending sequence the values you entered are:
405  302  111  111  99  89  82  77  67  56  56  34  34  23  23  3  1
        
The sum of the elements in the queue is: 1573</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You create the double-ended queue container at the beginning of <code class="calibre23">main()</code>:</p>
<pre class="calibre28"><code class="calibre23">  std::deque&lt;int&gt; data;</code></pre>
<p class="calibre20">The <code class="calibre23">data</code> container is empty to start with and the input is read in a <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  int value {};
  while(std::cin &gt;&gt; value, value != 0)
   data.push_front(value);</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="517" id="calibre_link-979" class="calibre14"></span>The <code class="calibre23">while</code> loop condition makes use of the comma operator to separate two expressions, one that reads an integer from <code class="calibre23">cin</code> into <code class="calibre23">value</code> and another that tests whether the value read is non-zero. You saw in Chapter 2 that the value of a series of expressions separated by commas is the value of the rightmost, so the <code class="calibre23">while</code> loop continues as long as the expression <code class="calibre23">value != 0</code> is <code class="calibre23">true</code>, and the value read is non-zero. Within the loop you store the value in the queue using the <code class="calibre23">push_front()</code> function.</p>
<p class="calibre20">The next loop lists the values that you stored in the queue:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; std::endl &lt;&lt; "The values you entered are:" &lt;&lt; std::endl;
  for(const auto&amp; n : data)
    std::cout &lt;&lt; n &lt;&lt; "  ";
  std::cout &lt;&lt; std::endl;</code></pre>
<p class="calibre20">This uses a range-based <code class="calibre23">for</code> loop to output the values. You could also write this as a <code class="calibre23">while</code> loop using an iterator:</p>
<pre class="calibre28"><code class="calibre23">  auto iter = cbegin(data);
  while(iter != cend(data))
    std::cout &lt;&lt; *iter++ &lt;&lt; "  ";</code></pre>
<p class="calibre20">Here, you increment the iterator after the value it points to is written to <code class="calibre23">cout</code>. It’s just for illustration &mdash; not a good alternative to the range-based <code class="calibre23">for</code>!</p>
<p class="calibre20">The next loop outputs the values in reverse order:</p>
<pre class="calibre28"><code class="calibre23">  for(auto riter = crbegin(data) ;riter != crend(data) ;++riter)
   std::cout &lt;&lt; *riter &lt;&lt; "  ";</code></pre>
<p class="calibre20">This uses a reverse iterator, so the loop starts with the last element and ends when <code class="calibre23">riter</code> is equal to the iterator returned by <code class="calibre23">crend()</code>. The <code class="calibre23">crbegin()</code> function returns an iterator pointing to the last element and the <code class="calibre23">crend()</code> function returns an iterator pointing to one before the first element. For vectors and double-ended queues, you get random access iterators. The <code class="calibre23">auto</code> keyword selects the type automatically; it will be <code class="calibre23">deque&lt;int&gt;::reverse_iterator</code>.</p>
<p class="calibre20">Next, you sort the elements in descending sequence and output them:</p>
<pre class="calibre28"><code class="calibre23">  std::sort(begin(data), end(data), std::greater&lt;&gt;());   // Sort the elements
  for(const auto&amp; n : data)
    std::cout &lt;&lt; n &lt;&lt; "  ";
  std::cout &lt;&lt; std::endl;</code></pre>
<p class="calibre20">By default, <code class="calibre23">sort&lt;T&gt;()</code> sorts in ascending sequence using a <code class="calibre23">less&lt;T&gt;()</code> function object as the comparator. When you supply the <code class="calibre23">greater&lt;&gt;()</code> object as the optional third argument, the integer elements will be sorted into descending sequence. The arguments will be forwarded to the comparator because omitting the template parameter selects the transparent version of the functor.</p>
<p class="calibre20">You could sort the queue elements in descending sequence like this:</p>
<pre class="calibre28"><code class="calibre23"> std::sort(rbegin(data), rend(data));        // Sort into descending sequence</code></pre>
<p class="calibre20">The default operation of the <code class="calibre23">sort()</code> algorithm is to sort the sequence passed to it by the iterator arguments in ascending sequence. Here, you pass reverse iterators to the function, so it sees the elements in reverse order and sorts the reversed sequence in ascending order. The result is that the elements end up in descending sequence when seen in the normal forward order.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="518" id="calibre_link-980" class="calibre14"></span>The last operation in <code class="calibre23">main()</code> is to output the sum of the elements:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; std::endl &lt;&lt; "The sum of the elements in the queue is: "
            &lt;&lt; std::accumulate(cbegin(data), cend(data), 0)  &lt;&lt; std::endl;</code></pre>
<p class="calibre20">You could use a conventional loop to do this, but here you make use of the <code class="calibre23">accumulate()</code> algorithm from the numeric header that you saw in the previous example. The default addition operation applies here.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Using List Containers</h3>
<p class="calibre13">The <code class="calibre23">list&lt;T&gt;</code> container template from the <code class="calibre23">list</code> header implements a doubly-linked list. The big advantage this has over a vector or a double-ended queue is that you can insert or delete elements anywhere in the sequence in constant time. The main drawback is that a list cannot directly access an element by its position. It’s necessary to traverse the elements in a list from a known position when you want to do this, usually the first or the last. The range of constructors for a list container is similar to that for a vector or double-ended queue. This statement creates an empty list:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;std::string&gt; names;</code></pre>
<p class="calibre13">You can also create a list with a given number of default elements:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;std::string&gt; sayings(20);              // A list of 20 empty strings</code></pre>
<p class="calibre13">Here’s how you create a list containing a given number of identical elements:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;double&gt; values(50, 2.71828);</code></pre>
<p class="calibre13">This creates a list of 50 values of type <code class="calibre23">double</code> equal to 2.71828.</p>
<p class="calibre13">You can also construct a list initialized with values from a sequence specified by two iterators:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;double&gt; samples(++cbegin(values), --cend(values));</code></pre>
<p class="calibre13">This creates a list from the contents of the <code class="calibre23">values</code> list, omitting the first and last elements. The iterators returned by the <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> functions for a list are bidirectional iterators, so you do not have the same flexibility as with a <code class="calibre23">vector</code> or a <code class="calibre23">deque</code> container that support random access iterators. You can only change the value of a bidirectional iterator using the increment or decrement operators.</p>
<p class="calibre13">Just like the other sequence containers, you can discover the number of elements in a list by calling its <code class="calibre23">size()</code> member. You can also change the number of elements by calling its <code class="calibre23">resize()</code> function. If the argument to <code class="calibre23">resize()</code> is less than the number of elements, elements will be deleted from the end; if the argument is greater, elements will be added using the default constructor for the type of elements stored.</p>
<section class="toclist">
<h4 class="calibre22">Adding Elements to a List</h4>
<p class="calibre13">You add an element to the beginning or end of a list by calling <code class="calibre23">push_front()</code> or <code class="calibre23">push_back()</code>, just as you would for a double-ended queue. To add elements to the interior of a list, you use the <code class="calibre23">insert()</code> function, which comes in three versions. Using the first version, you can insert a new element at a position specified by an iterator:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; data(20, 1);           // List of 20 elements value 1
data.insert(++begin(data), 77);       // Insert 77 as the second element</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="519" id="calibre_link-981" class="calibre14"></span>The first argument to <code class="calibre23">insert()</code> is an iterator specifying the insertion position, and the second argument is the element to be inserted. Incrementing the bidirectional iterator returned by <code class="calibre23">begin()</code> makes it point to the second element. After executing this, the list contents will be:</p>
<pre class="calibre28"><code class="calibre23">1 77 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</code></pre>
<p class="calibre13">You can see that the list now contains 21 elements, and that the elements from the insertion point on are simply displaced to the right.</p>
<p class="calibre13">You can insert a number of copies of the same element at a given position:</p>
<pre class="calibre28"><code class="calibre23">auto iter = begin(data); 
  std::advance(iter, 9);    // Increment iterator by 9
data.insert(iter, 3, 88);   // Insert 3 copies of 88 starting at the 10th</code></pre>
<p class="calibre13"><code class="calibre23">iter</code> will be of type <code class="calibre23">list&lt;int&gt;::iterator</code>. The first argument to the <code class="calibre23">insert()</code> function is an iterator specifying the insertion position, the second is the number of elements to be inserted, and the third is the element to be inserted repeatedly. To get to the tenth element you increment the iterator by caling the <code class="calibre23">advance()</code> template function. The <code class="calibre23">advance()</code> function increments the iterator specified by the first argument by the amount specified by the second. Using the <code class="calibre23">advance()</code> function is necessary because you cannot just add 9 to a bidirectional iterator. Thus, this fragment inserts three copies of 88 into the list, starting at the tenth element. Now the contents of the list will be:</p>
<pre class="calibre28"><code class="calibre23">1 77 1 1 1 1 1 1 1 88 88 88 1 1 1 1 1 1 1 1 1 1 1 1</code></pre>
<p class="calibre13">Now the list contains 24 elements.</p>
<p class="calibre13">Here’s how you can insert a sequence of elements into a list:</p>
<pre class="calibre28"><code class="calibre23">std::vector&lt;int&gt; numbers(10, 5);         // Vector of 10 elements with value 5
data.insert(--(--end(data)), cbegin(numbers), cend(numbers));</code></pre>
<p class="calibre13">The first argument to <code class="calibre23">insert()</code> is an iterator pointing to the second-to-last element position. The sequence to be inserted is specified by the second and third arguments to the <code class="calibre23">insert()</code> function, so this will insert all the elements from the vector into the list, starting at the second to last element position. After executing this, the contents of the list will be:</p>
<pre class="calibre28"><code class="calibre23">1 77 1 1 1 1 1 1 1 88 88 88 1 1 1 1 1 1 1 1 1 1 5 5 5 5 5 5 5 5 5 5 1 1</code></pre>
<p class="calibre13">Inserting the 10 elements from <code class="calibre23">numbers</code> in the second-to-last element position displaces the last two elements in the list to the right. The list now contains 34 elements.</p>
<p class="calibre13">There are three functions that will construct an element in place in the list: <code class="calibre23">emplace()</code>, which constructs an element at a position specified by an iterator; <code class="calibre23">emplace_front()</code>, which constructs an element at the beginning; and <code class="calibre23">emplace_back()</code>, which constructs an element at the end. Here are some examples of their use:</p>
<pre class="calibre28"><code class="calibre23">  std::list&lt;std::string&gt; strings;
  strings.emplace_back("first");
  std::string second("second");
  strings.emplace_back(std::move(second));
  strings.emplace_front("third");
  strings.emplace(++begin(strings), "fourth");</code></pre>
<p class="calibre13">The fourth line of code uses the <code class="calibre23">std::move()</code> function to pass an rvalue reference to <code class="calibre23">s</code> to the <code class="calibre23">emplace_back()</code> function. After executing this operation, <code class="calibre23">s</code> will be empty because the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="520" id="calibre_link-982" class="calibre14"></span>contents will have been moved to the list. After executing these statements, strings will contain the elements:</p>
<pre class="calibre28"><code class="calibre23">third  fourth  first  second</code></pre>
</section>
<section class="toclist">
<h4 class="calibre22">Accessing Elements in a List</h4>
<p class="calibre13">You can obtain a reference to the first or last element in a list by calling its <code class="calibre23">front()</code> or <code class="calibre23">back()</code> member. To access elements that are interior to the list you must use an iterator and increment or decrement it to get to the element you want. As you have seen, <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> return a bidirectional iterator pointing at the first element, or one past the last element, respectively. The <code class="calibre23">rbegin()</code> and <code class="calibre23">rend()</code> functions return bidirectional iterators and enable you to iterate through the elements in reverse sequence. You can use the range-based <code class="calibre23">for</code> loop with a list so you don’t have to use iterators when you want to process all the elements:</p>
<pre class="calibre28"><code class="calibre23">  std::list&lt;std::string&gt; strings;
  strings.emplace_back("first");
  std::string second("second");
  strings.emplace_back(std::move(second));
  strings.emplace_front("third");
  strings.emplace(++begin(strings), "fourth");
  for(const auto&amp; s : strings) 
    std::cout &lt;&lt; s &lt;&lt; std::endl;</code></pre>
<p class="calibre13">The loop variable, <code class="calibre23">s</code>, is a reference that will reference each list element in turn.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Sorting List Elements</h4>
<p class="calibre13">Because a <code class="calibre23">list&lt;T&gt;</code> container does not provide random access iterators, you cannot use the <code class="calibre23">sort()</code> function that is defined in the <code class="calibre23">algorithm</code> header. This is why the <code class="calibre23">list&lt;T&gt;</code> template defines its own <code class="calibre23">sort()</code> member function. It comes in two versions. To sort a list in ascending sequence you call the <code class="calibre23">sort()</code> member with no arguments. Alternatively, you can specify a function object or a lambda expression that defines a different predicate for comparing members. For example:</p>
<pre class="calibre28"><code class="calibre23"> strings.sort(std::greater&lt;std::string&gt;());     // Descending sequence</code></pre>
<p class="calibre13">You can also use the transparent version of the predicate:</p>
<pre class="calibre28"><code class="calibre23">strings.sort(std::greater&lt;&gt;());                 // Perfect forwarding</code></pre>
<p class="calibre13">This will be faster because the arguments to the comparison operation will be moved, not copied. Let’s try out some of what we have seen in an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Working with a List</h3>
<p class="calibre20">In this example you read sentences from the keyboard and store them in a list:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_06.cpp
// Working with a list
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
 
using std::string;
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="521" id="calibre_link-983" class="calibre14"></span>void listAll(const std::list&lt;string&gt;&amp; strings)
{
  for (auto&amp; s : strings)
    std::cout &lt;&lt; s &lt;&lt; std::endl;
}
 
int main()
{
  std::list&lt;string&gt; text;
 
  // Read the data
  std::cout &lt;&lt; "Enter a few lines of text. Just press Enter to end:" &lt;&lt; std::endl;
  string sentence;
  while (getline(std::cin, sentence, '\n'), !sentence.empty())
    text.push_front(sentence);
 
  std::cout &lt;&lt; "Your text in reverse order:" &lt;&lt; std::endl;
  listAll(text);
  
  text.sort();                            // Sort the data in ascending sequence
  std::cout &lt;&lt; "\nYour text in  ascending sequence:" &lt;&lt; std::endl;
  listAll(text);
 
  text.sort(std::greater&lt;&gt;());            // Sort the data in descending sequence
  std::cout &lt;&lt; "\nYour text in  descending sequence:" &lt;&lt; std::endl;
  listAll(text);
}</code></pre>
<p class="calibre20">Here is some sample output:</p>
<pre class="calibre28"><code class="calibre23">Enter a few lines of text. Just press Enter to end:
This sentance contains three erors.
This sentence is false.
People who live in glass houses might as well answer the door.
If all else fails, read the instructions.
Home is where the mortgage is.
 
Your text in reverse order:
Home is where the mortgage is.
If all else fails, read the instructions.
People who live in glass houses might as well answer the door.
This sentence is false.
This sentance contains three erors.
 
Your text in ascending sequence:
Home is where the mortgage is.
If all else fails, read the instructions.
People who live in glass houses might as well answer the door.
This sentance contains three erors.
This sentence is false.
 
Your text in descending sequence:
This sentence is false.
This sentance contains three erors.
People who live in glass houses might as well answer the door.
If all else fails, read the instructions.
Home is where the mortgage is.</code></pre>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="522" id="calibre_link-984" class="calibre14"></span><i class="calibre15">How It Works</i></h4>
<p class="calibre20">There’s a helper function, <code class="calibre23">listAll()</code>, that outputs the contents of the <code class="calibre23">list&lt;string&gt;</code> container that is passed to it. The parameter is a reference so the container won’t be copied. You output the contents of a list in a loop in the <code class="calibre23">listAll()</code> function like this:</p>
<pre class="calibre28"><code class="calibre23">  for(auto&amp; s : strings)
    std::cout &lt;&lt; s &lt;&lt; std::endl;</code></pre>
<p class="calibre20">This lists each element from the list on a separate line.</p>
<p class="calibre20">You create a list container in <code class="calibre23">main()</code> to hold strings:</p>
<pre class="calibre28"><code class="calibre23">  std::list&lt;string&gt; text;</code></pre>
<p class="calibre20">You then read an arbitrary number of input lines from the standard input stream:</p>
<pre class="calibre28"><code class="calibre23">  string sentence;
  while(getline(std::cin, sentence, '\n'), !sentence.empty())
    text.push_front(sentence);</code></pre>
<p class="calibre20">This uses the same idiom for input as the previous example. The second expression in the <code class="calibre23">while</code> loop condition determines when the loop ends, which will be when calling <code class="calibre23">empty()</code> for <code class="calibre23">sentence</code> returns <code class="calibre23">true</code>. You add each input to the list using the <code class="calibre23">push_front()</code> function, but you could equally well use <code class="calibre23">push_back()</code>. The only difference would be that the order of elements in the list would be reversed.</p>
<p class="calibre20">A better way to code this would be to use an <code class="calibre23">emplace</code> function:</p>
<pre class="calibre28"><code class="calibre23">  while(getline(std::cin, sentence, '\n'), !sentence.empty())
    text.emplace_front(std::move(sentence));</code></pre>
<p class="calibre20">This would move the string from the sentence to the front of the list. This would avoid any copying and therefore would be faster to execute. The sentence object would be empty after each <code class="calibre23">emplace_front()</code> operation.</p>
<p class="calibre20">You output the contents of the list by calling the <code class="calibre23">listAll()</code> function. The output presents the input in reverse order because using <code class="calibre23">push_front()</code> creates the list in reverse sequence. If you used <code class="calibre23">push_back()</code>, elements would be in the sequence they were entered.</p>
<p class="calibre20">Next, you sort the contents of the list and output it:</p>
<pre class="calibre28"><code class="calibre23">  text.sort();                            // Sort the data in ascending sequence
  std::cout &lt;&lt; "\nYour text in  ascending sequence:" &lt;&lt; std::endl;
  listAll(text);</code></pre>
<p class="calibre20">This uses the <code class="calibre23">sort()</code> member of the <code class="calibre23">list&lt;string&gt;</code> object with no argument to sort the contents in ascending sequence. You sort the elements in descending sequence, like this:</p>
<pre class="calibre28"><code class="calibre23">    text.sort(std::greater&lt;&gt;());            // Sort the data in descending sequence</code></pre>
<p class="calibre20">This uses the transparent version of the functor to get perfect forwarding.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Other Operations on Lists</h4>
<p class="calibre13">The <code class="calibre23">clear()</code> function deletes all the elements from a list. The <code class="calibre23">erase()</code> function allows you to delete either a single element specified by a single iterator, or a sequence of elements specified by a pair of iterators in the usual fashion &mdash; the first in the sequence and one past the last:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="523" id="calibre_link-985" class="calibre14"></span>std::list&lt;int&gt; numbers {10, 22, 4, 56, 89, 77, 13, 9};
numbers.erase(++begin(numbers));      // Remove the second element
        
// Remove all except the first and the last two
numbers.erase(++begin(numbers), --(--end(numbers)));</code></pre>
<p class="calibre13">Initially, the list contains all the values in the initializer list. The first <code class="calibre23">erase()</code> operation deletes the second element, so the list will contain:</p>
<pre class="calibre28"><code class="calibre23">10 4 56 89 77 13 9</code></pre>
<p class="calibre13">For the second <code class="calibre23">erase()</code> operation, the first argument is the iterator returned by <code class="calibre23">begin()</code>, incremented by 1, so it points to the second element. The second argument is the iterator returned by <code class="calibre23">end()</code>, decremented twice, so it points to the second-to-last element. Of course, this is one past the end of the sequence, so the element that this iterator points to is not included in the set to be deleted. The list contents after this operation will be:</p>
<pre class="calibre28"><code class="calibre23">10 13 9</code></pre>
<p class="calibre13">The <code class="calibre23">remove()</code> function removes elements from a list that match a particular value. With the <code class="calibre23">numbers</code> list defined as in the previous fragment, you could remove all elements equal to <code class="calibre23">22</code> with the following statement:</p>
<pre class="calibre28"><code class="calibre23">numbers.remove(22);</code></pre>
<p class="calibre13">The <code class="calibre23">assign()</code> function removes all the elements from a list and copies either a single object into the list a given number of times, or copies a sequence of objects specified by two iterators. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers {10, 22, 4, 56, 89, 77, 13, 9};
numbers.assign(10, 99);         // Replace contents by 10 copies of 99
numbers.assign(data+1, data+4); // Replace contents by 22 4 56</code></pre>
<p class="calibre13">The <code class="calibre23">assign()</code> function comes in the two overloaded versions illustrated here. The arguments to the first are the count of the number of replacement elements, and the replacement element value. The arguments to the second version are either two iterators or two pointers, specifying a sequence in the way you have already seen.</p>
<p class="calibre13">The <code class="calibre23">unique()</code> function will eliminate adjacent duplicate elements from a list, so if you sort the contents first, applying the function ensures that all elements are unique. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers {10, 22, 4, 10, 89, 22, 89, 10} ; // 10 22 4 10 89 22 89 10
numbers.sort();                                          // 4 10 10 10 22 22 89 89
numbers.unique();                                        // 4 10 22 89</code></pre>
<p class="calibre13">The result of each operation is shown in the comments.</p>
<p class="calibre13">The <code class="calibre23">splice()</code> function removes all or part of one list and inserts it in another. Obviously, both lists must store elements of the same type. Here’s the simplest way you could use the <code class="calibre23">splice()</code> function:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers {1, 2, 3};                        // 1 2 3
std::list&lt;int&gt; values {5, 6, 7, 8};                      // 5 6 7 8
numbers.splice(++begin(numbers), values);                // 1 5 6 7 8 2 3</code></pre>
<p class="calibre13">The first argument to <code class="calibre23">splice()</code> is an iterator specifying where the elements should be inserted, and the second argument is the list that is the source of the elements. This operation removes all the elements from the <code class="calibre23">values</code> list and inserts them immediately preceding the second element in the <code class="calibre23">numbers</code> list.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="524" id="calibre_link-986" class="calibre14"></span>Here’s another version of <code class="calibre23">splice()</code> that removes elements from a given position in a source list and inserts them at a given position in a destination list:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers {1, 2, 3};                        // 1 2 3
std::list&lt;int&gt; values {5, 6, 7, 8};                      // 5 6 7 8
numbers.splice(begin(numbers), values, --end(values));   // 8 1 2 3</code></pre>
<p class="calibre13">In this version, the first two arguments to <code class="calibre23">splice()</code> are the same as the previous version of the function. The third argument is an iterator specifying the position of the first element to be selected from the source list; all elements, from this position to the end, are removed from the source and inserted in the destination list. After executing this code fragment, <code class="calibre23">values</code> will contain <code class="calibre23">5 6 7</code>.</p>
<p class="calibre13">The third version of <code class="calibre23">splice()</code> requires four arguments and selects a range of elements from the source list:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers {1, 2, 3};                        // 1 2 3
std::list&lt;int&gt; values {5, 6, 7, 8};                      // 5 6 7 8
numbers.splice(++begin(numbers), values, ++begin(values),
                                          --end(values));// 1 6 7 2 3</code></pre>
<p class="calibre13">The first three arguments to this version of <code class="calibre23">splice()</code> are the same as the previous version, and the last argument is one past the last element to be removed from the source. After executing this, <code class="calibre23">values</code> will contain:</p>
<pre class="calibre28"><code class="calibre23">5 8</code></pre>
<p class="calibre13">The <code class="calibre23">merge()</code> function removes elements from the list that you supply as an argument and inserts them in the list for which the function is called. Both lists must be ordered in the same sense before you call <code class="calibre23">merge()</code>. The order of the second list argument determines the ordering of the final combined list. If the lists are not ordered in the same sense, the debug version of the code will assert; the release version will run but the result will not be correct. Here’s a fragment showing how you might use it:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers {1, 2, 3};                        // 1 2 3
std::list&lt;int&gt; values {2, 3, 4, 5, 6, 7, 8};             // 2 3 4 5 6 7 8
numbers.merge(values);                                   // 1 2 2 3 3 4 5 6 7 8</code></pre>
<p class="calibre13">This merges the contents of <code class="calibre23">values</code> into <code class="calibre23">numbers</code>, so <code class="calibre23">values</code> will be empty after this operation. The <code class="calibre23">merge()</code> member function that accepts a single argument orders the result in the sequence corresponding to that of the argument. Because the values in both lists are already ordered here, you don’t need to sort them. To merge the same lists in descending sequence, the code would be as follows:</p>
<pre class="calibre28"><code class="calibre23">numbers.sort(std::greater&lt;&gt;());                          // 3 2 1
values.sort(std::greater&lt;&gt;());                           // 8 7 6 5 4 3 2
numbers.merge(values, std::greater&lt;&gt;());                 // 8 7 6 5 4 3 3 2 2 1</code></pre>
<p class="calibre13">A <code class="calibre23">greater&lt;&gt;()</code> function object specifies that the lists should be sorted in descending sequence and then merged into the same sequence. The transparent version of the function object is used here where the type argument is deduced. The second argument to <code class="calibre23">merge()</code> is a function object specifying the ordering, which must be the same as that of the lists for correct operation. You can omit the second argument to <code class="calibre23">merge()</code>, in which case it will be deduced to be the same as <code class="calibre23">values</code>.</p>
<p class="calibre13">The <code class="calibre23">remove_if()</code> function removes elements based on the result of applying a unary predicate; I’m sure you’ll recall that a unary predicate is a function object that applies to a single argument and returns a <code class="calibre23">bool</code> value, <code class="calibre23">true</code> or <code class="calibre23">false</code>. If the result of applying the predicate to an element is <code class="calibre23">true</code>, <span {http://www.idpf.org/2007/ops}type="pagebreak" title="525" id="calibre_link-987" class="calibre14"></span>then the element will be deleted from the list. Typically, you would define your own predicate to do this. This involves defining your own class template for the function object or lambda expression that you want, while the STL defines the <code class="calibre23">unary_function&lt;T,R&gt;</code> base class template for use when you want to define your own class template. This template just defines types that will be inherited by the derived class that specifies your function object type. The base class template is defined as follows:</p>
<pre class="calibre28"><code class="calibre23">template&lt;class _Arg, class _Result&gt;
struct unary_function
{ // base class for unary functions
  typedef _Arg argument_type;
  typedef _Result result_type;
};</code></pre>
<p class="calibre13">This defines <code class="calibre23">argument_type</code> and <code class="calibre23">result_type</code> for use in your definition of the <code class="calibre23">operator()()</code> function. You must use this base template if you want to use your predicates with function adapters. You’ll see later in this chapter that lambda expressions provide a much easier way to define a predicate.</p>
<p class="calibre13">The way in which you can use the <code class="calibre23">remove_if()</code> function is best explained with a specific application, so let’s try this in a working example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Defining a Predicate for Filtering a List</h3>
<p class="calibre20">Here’s how you could define a template for a function object based on the helper template from the STL, which you could then use to remove negative values from a list:</p>
<pre class="calibre28"><code class="calibre23">// function_object.h
// Unary predicate to identify negative values
#pragma once
#include &lt;functional&gt;
        
template &lt;class T&gt; class is_negative : public std::unary_function&lt;T, bool&gt;
{
  public:
  result_type operator()(argument_type&amp; value)
  {
    return value &lt; 0;
  }
};</code></pre>
<p class="calibre20">This predicate works with any type that supports a less-than comparison with the value 0. The base template is very useful in that it standardizes the representation of the argument and return types for the predicate, and this is required if you want your function object to be usable with function adapters. Function adapters allow function objects to be used in combination to provide more complex functions. You should be able to see how you could define unary predicates for filtering a list in other ways &mdash; selecting even or odd numbers for example, or multiples of a given number, or numbers falling within a given range.</p>
<p class="calibre20">If you are not concerned about the use of your predicate with function adapters, you could define the template without the base class template:</p>
<pre class="calibre28"><code class="calibre23">// Unary predicate to identify negative values
#pragma once
        
template &lt;class T&gt; class is_negative
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="526" id="calibre_link-988" class="calibre14"></span>{
  public:
  bool operator()(const T&amp; value)
  {
    return value &lt; 0;
  }
};</code></pre>
<p class="calibre20">You don’t need the <code class="calibre23">#include</code> directive for <code class="calibre23">functional</code> here because you are not using the base template. This definition is simple, and perhaps easier to understand, but I included the original version just to show how you use the base template. You will want to do this if you intend to use your predicate in a more general context. I’ll create the example with the first version, but you can use either version, or perhaps try both.</p>
<p class="calibre20">To make the example more interesting, I’ll include function templates for inputting data to a list and for writing out the contents of a list. Here’s the program to make use of the predicate:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_07.cpp
// Using the remove_if() function for a list
        
#include &lt;iostream&gt;
#include &lt;list&gt;
#include "function_object.h"
        
// Template function to list the contents of a list
template &lt;class T&gt;
void listAll(const std::list&lt;T&gt;&amp; data)
{
  for(const auto&amp; t : data)
    std::cout &lt;&lt; t &lt;&lt; "  ";
  std::cout &lt;&lt; std::endl;
}
        
// Template function to read data from cin and store it in a list
template&lt;class T&gt;
void loadList(std::list&lt;T&gt;&amp; data)
{
  T value;
  while(std::cin &gt;&gt; value , value != T())  //Read non-zero values
    data.emplace_back(std::move(value));
}
        
int main()
{
  // Process integers
  std::list&lt;int&gt; numbers;
  std::cout &lt;&lt; "Enter non-zero integers separated by spaces. Enter 0 to end."
            &lt;&lt; std::endl;
  loadList(numbers);
  std::cout &lt;&lt; "The list contains:" &lt;&lt; std::endl;
  listAll(numbers);
  numbers.remove_if(is_negative&lt;int&gt;());
  std::cout &lt;&lt; "After applying remove_if() the list contains:" &lt;&lt; std::endl;
  listAll (numbers);
        
  // Process floating-point values
  std::list&lt;double&gt; values;
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="527" id="calibre_link-989" class="calibre14"></span>std::cout &lt;&lt; "\nEnter non-zero float values separated by spaces(some negative!)."
            &lt;&lt;  "Enter 0 to end." &lt;&lt; std::endl;
  loadList(values);
  std::cout &lt;&lt; "The list contains:" &lt;&lt; std::endl;
  listAll(values);
  values.remove_if(is_negative&lt;double&gt;());
  std::cout &lt;&lt; "After applying remove_if() the list contains:" &lt;&lt; std::endl;
  listAll(values);        
}</code></pre>
<p class="calibre20">Here’s some sample output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter non-zero integers separated by spaces. Enter 0 to end.
23 -4 -5 66 67 89 -1 22 34 -34 78 62 -9 99 -19 0
The list contains:
23  -4  -5  66  67  89  -1  22  34  -34  78  62  -9  99  -19
After applying remove_if() the list contains: 
23  66  67  89  22  34  78  62  99
 
Enter non-zero float values separated by spaces(some negative!).Enter 0 to end.
2.5 -3.1 5.5 100 -99 -.075 1.075 13 -12.1 13.2 0
The list contains:
2.5  -3.1  5.5  100  -99  -0.075  1.075  13  -12.1  13.2
After applying remove_if() the list contains: 
2.5  5.5  100  1.075  13  13.2</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The output shows that the predicate works for <code class="calibre23">int</code> and <code class="calibre23">double</code> values. The <code class="calibre23">remove_if()</code> function applies the predicate to each element in a list and deletes the elements for which the predicate returns <code class="calibre23">true</code>.</p>
<p class="calibre20">The body of the <code class="calibre23">loadList&lt;T&gt;()</code> template function that reads the input is:</p>
<pre class="calibre28"><code class="calibre23">  T value;
  while(std::cin &gt;&gt; value , value != T())  //Read non-zero values
    data.emplace_back(std::move(value));</code></pre>
<p class="calibre20">The local variable <code class="calibre23">value</code> is defined as type <code class="calibre23">T</code>, the type parameter for the template, so this will be of whatever type you use to instantiate the function. The input is read in the <code class="calibre23">while</code> loop, and values continue to be read until you enter zero, in which case the last expression in the <code class="calibre23">while</code> loop condition will be <code class="calibre23">false</code>, thus ending the loop. Using <code class="calibre23">emplace_back()</code>with an rvalue reference to <code class="calibre23">value</code> moves <code class="calibre23">value</code> to the list, rather than copying it.</p>
<p class="calibre20">The body of the <code class="calibre23">listAll&lt;T&gt;()</code> function template is essentially the same as the function with the same name in the previous example. Note how you can use <code class="calibre23">auto</code>, even in a template. This deduces the type for the <code class="calibre23">for</code> loop control variable, <code class="calibre23">t</code>, which maps to the type required for the elements in the list container that is passed as the argument. If you wanted to try out the <code class="calibre23">merge()</code> function within this example, you could add the following code before the <code class="calibre23">return</code> statement in <code class="calibre23">main()</code>:</p>
<pre class="calibre28"><code class="calibre23">  // Another list to use in merge
  std::list&lt;double&gt; morevalues;
  std::cout &lt;&lt; "\nEnter non-zero float values separated by spaces. Enter 0 to end."
            &lt;&lt; std::endl;
  loadlist(morevalues);
  std::cout &lt;&lt; "The list contains:" &lt;&lt; std::endl;
  listAll(morevalues);
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="528" id="calibre_link-990" class="calibre14"></span>morevalues.remove_if(is_negative&lt;double&gt;());
  std::cout &lt;&lt; "After applying the remove_if() function the list contains:"
            &lt;&lt; std::endl;
  listAll(morevalues);
        
  // Merge the last two lists
  values.sort(std::greater&lt;&gt;());
  morevalues.sort(std::greater&lt;&gt;());
  values.merge(morevalues, std::greater&lt;&gt;()); 
  std::cout &lt;&lt; "\nSorting and merging two lists produces:" &lt;&lt; std::endl;
  listAll(values);</code></pre>
<p class="calibre20">The use of <code class="calibre23">std::greater&lt;&gt;()</code> requires that the <code class="calibre23">functional</code> header is included.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Using forward_list Containers</h3>
<p class="calibre13">The <code class="calibre23">forward_list</code> header defines the <code class="calibre23">forward_list&lt;T&gt;</code> container template that implements a singly linked list of elements of type <code class="calibre23">T</code>, where each element contains a pointer to the next element. This means that, unlike a <code class="calibre23">list&lt;T&gt;</code> container, you can only traverse the elements forwards. Like the <code class="calibre23">list&lt;T&gt;</code> container, you cannot access an element by its position. The only way to access an element is to traverse the list from the beginning. Because the operations for a <code class="calibre23">forward_list&lt;T&gt;</code> container are similar to those for a <code class="calibre23">list&lt;T&gt;</code>, I’ll just highlight a few of them.</p>
<p class="calibre13">The <code class="calibre23">front()</code> member function returns a reference to the first element in the list as long as the list is not empty and the reference will be <code class="calibre23">const</code> if the container object is <code class="calibre23">const</code>. You can test whether or not the list is empty using the <code class="calibre23">empty()</code> member, which returns <code class="calibre23">false</code> as long as there is at least one element in the list. The <code class="calibre23">remove()</code> function removes the element that matches the object you supply as the argument. There’s also the <code class="calibre23">remove_if()</code> member for which you supply a predicate as an argument, which can be a function object or a lambda expression. All elements for which the predicate is true are removed.</p>
<p class="calibre13">Because it is a singly linked list, a <code class="calibre23">forward_list&lt;T&gt;</code> container only has forward iterators. You can use the global functions to obtain iterators such as <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> with it, except for those that return reverse iterators.</p>
<p class="calibre13">You can add an element to a <code class="calibre23">forward_list</code> using either <code class="calibre23">push_front()</code> or <code class="calibre23">emplace_front()</code>. The <code class="calibre23">emplace_front()</code> function creates an object from the arguments that you supply and inserts it at the front of the list. The <code class="calibre23">push_front()</code> function inserts the object you supply as the argument at the front of the list.</p>
<p class="calibre13">For example:</p>
<pre class="calibre28"><code class="calibre23">std::forward_list&lt;std::string&gt; words;
std::string s1 {"first"};
words.push_front(s1);
words.emplace_front("second");
std::string s2 {"third"};
words.emplace_front(std::move(s2));
words.emplace_front("fourth");</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="529" id="calibre_link-991" class="calibre14"></span>After executing this fragment, <code class="calibre23">words</code> will contain:</p>
<pre class="calibre28"><code class="calibre23">fourth  third  second  first</code></pre>
<p class="calibre13">A <code class="calibre23">forward_list&lt;T&gt;</code> container also has a <code class="calibre23">before_begin()</code> function that returns an iterator pointing to the position before the first element. This is for use with the <code class="calibre23">insert_after()</code> and <code class="calibre23">emplace_after()</code> member functions. You can insert one or more objects after a given position in the list using the <code class="calibre23">insert_after()</code> function. There are several versions of this. Here are some examples:</p>
<pre class="calibre28"><code class="calibre23">std::forward_list&lt;int&gt; datalist;
 
// Returns an iterator pointing to the inserted element, 11
auto iter = datalist.insert_after(datalist.before_begin(), 11); // 11
 
// Inserts 3 copies of the 3rd argument after iter and increments iter 
iter = datalist.insert_after(iter, 3, 15);                  // 11 15 15 15
 
// Insert a range following iter, and increments iter to point to 5  
int data[] {1, 2, 4, 5};
iter = datalist.insert_after(
                 iter, std::cbegin(data), std::cend(data)); // 11 15 15 15 1 2 4 5</code></pre>
<p class="calibre13"><code class="calibre23">iter</code> will be of type <code class="calibre23">forward_list&lt;int&gt;::iterator</code>.</p>
<p class="calibre13">You can insert an element after a given position in the list using the <code class="calibre23">emplace_after()</code> function. The first argument is an iterator specifying the element after which the new element should be inserted. The second and subsequent arguments are passed to the constructor for the class type of the object to be inserted. For example:</p>
<pre class="calibre28"><code class="calibre23">  words.emplace_after(std::cbegin(words), "fifth");</code></pre>
<p class="calibre13">After executing this statement with <code class="calibre23">words</code> as it was left by the previous fragment adding elements, the list will contain:</p>
<pre class="calibre28"><code class="calibre23">fourth  fifth  third  second  first</code></pre>
<p class="calibre13">The function created a <code class="calibre23">string("fifth")</code> object and stored it following the position pointed to by the first argument.</p>
<p class="calibre13">A <code class="calibre23">forward_list&lt;T&gt;</code> container provides better performance than a <code class="calibre23">list&lt;T&gt;</code> container. Having only one link to maintain makes it faster in operation and there is no size member keeping track of the number of elements. If you need to know the number of elements, you can obtain it using the <code class="calibre23">distance()</code> function from the <code class="calibre23">algorithm</code> header:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; "Size = " &lt;&lt; std::distance(std::cbegin(words), std::cend(words));</code></pre>
<p class="calibre13">The arguments are iterators specifying the first element and one past the last element to be counted.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using Other Sequence Containers</h3>
<p class="calibre13">The remaining sequence containers are implemented through container adapters that I introduced at the beginning of this chapter. I’ll discuss each of them briefly and illustrate their operation with examples.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="530" id="calibre_link-992" class="calibre14"></span>Queue Containers</h4>
<p class="calibre13">A <code class="calibre23">queue&lt;T&gt;</code> container implements a first-in first-out storage mechanism through an adapter. You can only add to the end of the queue or remove from the front. Here’s one way you can create a queue:</p>
<pre class="calibre28"><code class="calibre23">std::queue&lt;std::string&gt; names;</code></pre>
<p class="calibre13">This creates a queue storing elements of type <code class="calibre23">string</code>. By default, the <code class="calibre23">queue&lt;T&gt;</code> adapter class uses a <code class="calibre23">deque&lt;T&gt;</code> container as the base, but you can specify a different sequence container as a base, as long as it supports the operations <code class="calibre23">front(), back(), push_back()</code>, and <code class="calibre23">pop_front()</code>. These four functions are used to operate the queue. Thus, a queue can be based on a list or a vector. You specify the alternate container as a second template parameter. Here’s how you would create a queue based on a list:</p>
<pre class="calibre28"><code class="calibre23">std::queue&lt;std::string, std::list&lt;std::string&gt;&gt; names;</code></pre>
<p class="calibre13">The second type parameter to the adapter template specifies the underlying sequence container to be used. The queue adapter class acts as a wrapper for the underlying container class and essentially restricts the range of operations you can carry out to those described in the following table.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">back()</code></td>
<td class="calibre32">Returns a reference to the element at the back of the queue. There are two versions, one returning a <code class="calibre23">const</code> reference and the other returning a non-<code class="calibre23">const</code> reference. If the queue is empty, then the value returned is undefined.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">front()</code></td>
<td class="calibre32">Returns a reference to the element at the front of the queue. There are two versions, one returning a <code class="calibre23">const</code> reference and the other returning a non-<code class="calibre23">const</code> reference. If the queue is empty, then the value returned is undefined.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">push()</code></td>
<td class="calibre32">Adds the element specified by the argument to the back of the queue.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">pop()</code></td>
<td class="calibre32">Removes the element at the front of the queue.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size()</code></td>
<td class="calibre32">Returns the number of elements in the queue.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">empty()</code></td>
<td class="calibre32">Returns <code class="calibre23">true</code> if the queue is empty and <code class="calibre23">false</code> otherwise.</td>
</tr>
</tbody>
</table>
<p class="calibre13">Note that there are no functions that make iterators available for a queue. The only way to access the contents of a queue is via the <code class="calibre23">back()</code> or <code class="calibre23">front()</code> functions.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Queue Container</h3>
<p class="calibre20">In this example you read a succession of one or more sayings, store them in a queue, and then retrieve and output them:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_08.cpp
// Exercising a queue container
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
        
int main()
{
  std::queue&lt;std::string&gt; sayings;
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="531" id="calibre_link-993" class="calibre14"></span>std::string saying;
  std::cout &lt;&lt; "Enter one or more sayings. Press Enter to end." &lt;&lt; std::endl;
  while(true)
  {
    std::getline(std::cin, saying);
    if(saying.empty())
      break;
    sayings.push(saying);
  }
        
  std::cout &lt;&lt; "There are " &lt;&lt; sayings.size() &lt;&lt; " sayings in the queue.\n" 
            &lt;&lt; std::endl;
  std::cout &lt;&lt; "The sayings that you entered are:" &lt;&lt; std::endl;
  while(!sayings.empty())
  {
    std::cout &lt;&lt; sayings.front() &lt;&lt; std::endl;
    sayings.pop();
  }
}</code></pre>
<p class="calibre20">Here’s an example of some output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter one or more sayings. Press Enter to end.
If at first you don't succeed, give up.
A preposition is something you should never end a sentence with.
The bigger they are, the harder they hit.
A rich man is just a poor man with money.
Wherever you go, there you are.
Common sense is not so common.
        
There are 6 sayings in the queue.
        
The sayings that you entered are:
If at first you don't succeed, give up.
A preposition is something you should never end a sentence with.
The bigger they are, the harder they hit.
A rich man is just a poor man with money.
Wherever you go, there you are.
Common sense is not so common.</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You first create a queue container that stores string objects:</p>
<pre class="calibre28"><code class="calibre23">  std::queue&lt; std::string&gt; sayings;</code></pre>
<p class="calibre20">You read sayings from the standard input stream and store them in the container in a <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  while(true)
  {
    std::getline(std::cin, saying);
    if(saying.empty())
      break;
    sayings.push(saying);
  }</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="532" id="calibre_link-994" class="calibre14"></span>This version of <code class="calibre23">getline()</code>reads text from <code class="calibre23">cin</code> into the <code class="calibre23">string</code> object, <code class="calibre23">saying</code>, until a newline is recognized. Newline is the default input termination character, and when you want to override this, you specify the termination character as the third argument to <code class="calibre23">getline()</code>. The loop continues until the <code class="calibre23">empty()</code> function for <code class="calibre23">saying</code> returns <code class="calibre23">true</code>, which indicates an empty line was entered. When the input in <code class="calibre23">saying</code> is not empty, you store it in the <code class="calibre23">sayings</code> queue container by calling its <code class="calibre23">push()</code> function.</p>
<p class="calibre20">When input is complete, you output the count of the number of sayings that were stored in the queue:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; "There are " &lt;&lt; sayings.size() &lt;&lt; " sayings in the queue.\n" 
            &lt;&lt; std::endl;</code></pre>
<p class="calibre20">The <code class="calibre23">size()</code> function returns the number of elements in the queue.</p>
<p class="calibre20">You list the contents of the queue in another <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  while(!sayings.empty())
  {
    std::cout &lt;&lt; sayings.front() &lt;&lt; std::endl;
    sayings.pop();
  }</code></pre>
<p class="calibre20">The <code class="calibre23">front()</code> function returns a reference to the object at the front of the queue, but the object remains in its place. Because you want to access each of the elements in the queue in turn, you have to call the <code class="calibre23">pop()</code> function, after listing each element, to remove it from the queue.</p>
<p class="calibre20">The process of listing the elements in the queue also deletes them, so after the loop ends, the queue will be empty. What if you wanted to retain the elements in the queue? Well, one possibility is that you could put each saying back in the queue after you have listed it. Here’s how you could do that:</p>
<pre class="calibre28"><code class="calibre23">  for(std::queue&lt;std::string&gt;::size_type i {} ;i &lt; sayings.size() ;i++)
  {
    saying = sayings.front();
    std::cout &lt;&lt; saying &lt;&lt; std::endl;
    sayings.pop();
    sayings.push(saying);
  }</code></pre>
<p class="calibre20">Here, you make use of the value returned by <code class="calibre23">size()</code> to iterate over the number of sayings in the queue. After writing each saying to <code class="calibre23">cout</code>, you remove it from the queue by calling <code class="calibre23">pop()</code>, and then you return it to the back of the queue by calling <code class="calibre23">push()</code>. When the loop ends, the queue will be left in its original state. Of course, if you don’t want to remove the elements when you access them, you should use a different kind of container.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Priority Queue Containers</h4>
<p class="calibre13">A <code class="calibre23">priority_queue&lt;T&gt;</code> container is a queue that always has the largest or highest priority element at the top. Think of a queue of people arranged from the tallest to the shortest. Here’s one way to define a priority queue container:</p>
<pre class="calibre28"><code class="calibre23">std::priority_queue&lt;int&gt; numbers;</code></pre>
<p class="calibre13">The default criterion for determining the relative priority of elements as you add them to the queue is a standard <code class="calibre23">less&lt;T&gt;()</code> function object. You add an element to the priority queue using the <code class="calibre23">push()</code> function:</p>
<pre class="calibre28"><code class="calibre23">numbers.push(99);                      // Add 99 to the queue</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="533" id="calibre_link-995" class="calibre14"></span>When you add an element, if the queue is not empty the function will use the <code class="calibre23">less&lt;T&gt;()</code> predicate to decide where to insert the new object. This will result in elements being ordered in ascending sequence from the back of the queue to the front. You cannot modify elements while they are in a priority queue, as this could invalidate the ordering that has been established.</p>
<p class="calibre13">The complete set of operations for a priority queue is shown in the following table.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">top()</code></td>
<td class="calibre32">Returns a <code class="calibre23">const</code> reference to the element at the front of the priority queue, which will be the largest or highest priority element in the container. If the container is empty, then the value returned is undefined.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">push()</code></td>
<td class="calibre32">Adds the element specified by the argument to the priority queue at a position determined by the predicate for the container, which by default is <code class="calibre23">less&lt;T&gt;</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">pop()</code></td>
<td class="calibre32">Removes the element at the front of the priority queue, which will be the largest or highest priority element in the container.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size()</code></td>
<td class="calibre32">Returns the number of elements in the priority queue.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">empty()</code></td>
<td class="calibre32">Returns <code class="calibre23">true</code> if the container is empty and <code class="calibre23">false</code> otherwise.</td>
</tr>
</tbody>
</table>
<p class="calibre13">There is a significant difference between the functions available for a priority queue and for a queue. With a priority queue, you have no access to the element at the back; only the element at the front is accessible.</p>
<p class="calibre13">By default, the base container for the priority queue adapter class is <code class="calibre23">vector&lt;T&gt;</code>. You can specify a different sequence container for the base, and an alternative function object for determining the priority of the elements. Here’s how you could do that:</p>
<pre class="calibre28"><code class="calibre23">std::priority_queue&lt;int, std::deque&lt;int&gt;, std::greater&lt;&gt;&gt; numbers;</code></pre>
<p class="calibre13">This statement defines a priority queue based on a <code class="calibre23">deque&lt;int&gt;</code> container, with elements being inserted using a transparent function object of type <code class="calibre23">greater&lt;&gt;</code>. The elements in this priority queue will be in descending sequence, with the smallest element at the top. The three template parameters are the element type, the type of the container to be used as a base, and the type for the predicate to be used for ordering the elements.</p>
<p class="calibre13">You could omit the third template parameter if you want the default predicate to apply, which will be <code class="calibre23">less&lt;int&gt;</code> in this case. If you want a different predicate but want to retain the default base container, you must explicitly specify it, like this:</p>
<pre class="calibre28"><code class="calibre23">std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;&gt;&gt; numbers;</code></pre>
<p class="calibre13">This specifies the default base container as <code class="calibre23">vector&lt;int&gt;</code> and the predicate type <code class="calibre23">greater&lt;&gt;</code> to be used to determine element ordering.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Priority Queue Container</h3>
<p class="calibre20">In this example you store <code class="calibre23">Person</code> objects in the container, with the <code class="calibre23">Person</code> class defined this time to hold the names as type <code class="calibre23">string</code>:</p>
<pre class="calibre28"><code class="calibre23">// Person.h
// A class defining a person
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="534" id="calibre_link-996" class="calibre14"></span>#pragma once
#include &lt;iostream&gt;
#include &lt;string&gt;
        
class Person
{
public:
  Person(const std::string first, const std::string second) :
              firstname {std::move(first)}, secondname {std::move(second)} {}
 
        
  Person()=default;
        
        
  // Less-than operator
  bool operator&lt;(const Person&amp; p)const
  {
    return (secondname &lt; p.secondname ||
           ((secondname == p.secondname) &amp;&amp; (firstname &lt; p.firstname)));
  }
        
  // Greater-than operator
  bool operator&gt;(const Person&amp; p)const
  {
    return p &lt; *this;
  }
        
  // Output a person
  void showPerson() const
  {
    std::cout &lt;&lt; firstname &lt;&lt; " " &lt;&lt; secondname &lt;&lt; std::endl;
  }
        
private:
  std::string firstname;
  std::string secondname;
};</code></pre>
<p class="calibre20">The less-than and greater-than operators are implemented. This will allow objects to be placed in a priority queue that is ordered in either ascending or descending sequence.</p>
<p class="calibre20">Here’s the program that stores <code class="calibre23">Person</code> objects in a priority queue:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_09.cpp
// Exercising a priority queue container
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;
#include "Person.h"
        
int main()
{
  std::priority_queue&lt;Person, std::vector&lt;Person&gt;, std::greater&lt;&gt;&gt; people;
  std::string first, second;
  while(true)
  {
    std::cout &lt;&lt; "Enter a first name or press Enter to end: " ;
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="535" id="calibre_link-997" class="calibre14"></span>std::getline(std::cin, first);
    if(first.empty())
      break;
        
    std::cout &lt;&lt; "Enter a second name: " ;
    std::getline(std::cin, second);
    people.push(Person {first,second}); 
   }
        
  std::cout &lt;&lt; "\nThere are " &lt;&lt; people.size() &lt;&lt; " people in the queue." 
            &lt;&lt; std::endl;
        
  std::cout &lt;&lt; "\nThe names that you entered are:" &lt;&lt; std::endl;
  while(!people.empty())
  {
    people.top().showPerson();
    people.pop();
  }
}</code></pre>
<p class="calibre20">Typical output from this example looks like this:</p>
<pre class="calibre28"><code class="calibre23">Enter a first name or press Enter to end: Oliver
Enter a second name: Hardy
Enter a first name or press Enter to end: Stan
Enter a second name: Laurel
Enter a first name or press Enter to end: Harold
Enter a second name: Lloyd
Enter a first name or press Enter to end: Mel
Enter a second name: Gibson
Enter a first name or press Enter to end: Brad
Enter a second name: Pitt
Enter a first name or press Enter to end:
        
There are 5 people in the queue.
        
The names that you entered are:
Mel Gibson
Oliver Hardy
Stan Laurel
Harold Lloyd
Brad Pitt</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The <code class="calibre23">Person</code> class is simpler than in the earlier version because the names are stored as <code class="calibre23">string</code> objects, and no dynamic memory allocation is necessary. You no longer need to define the assignment operatoror copy constructor, as the defaults will be fine. Defining <code class="calibre23">operator&lt;()</code> is sufficient to allow <code class="calibre23">Person</code> objects to be stored in a default priority queue, and <code class="calibre23">operator&gt;()</code> permits <code class="calibre23">Person</code> objects to be ordered using a <code class="calibre23">greater&lt;&gt;</code> predicate.</p>
<p class="calibre20">You define the priority queue in <code class="calibre23">main()</code> like this:</p>
<pre class="calibre28"><code class="calibre23">  std::priority_queue&lt;Person, std::vector&lt;Person&gt;, std::greater&lt;&gt;&gt; people;</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="536" id="calibre_link-998" class="calibre14"></span>Because you want to specify the third template type parameter, you must supply all three, even though the base container type is the default. Incidentally, don’t confuse the type argument you are using in the template instantiation here, <code class="calibre23">greater&lt;&gt;</code>, with the object, <code class="calibre23">greater&lt;&gt;()</code>, that you might supply as an argument to the <code class="calibre23">sort()</code> algorithm.</p>
<p class="calibre20">Of course, the third parameter to the priority queue template does not have to be a template type. You could use your own function object type as long as it has a suitable implementation of <code class="calibre23">operator()()</code> in the class. For example:</p>
<pre class="calibre28"><code class="calibre23">// function_object.h
#pragma once
#include &lt;functional&gt;
#include "Person.h"
        
class PersonComp : public std::binary_function&lt;Person, Person, bool&gt;
{
public:
  result_type operator()(const first_argument_type&amp; p1,
                         const second_argument_type&amp; p2) const
  {
    return p1 &gt; p2;
  }
};</code></pre>
<p class="calibre20">For function objects that work with the STL, a binary predicate must implement <code class="calibre23">operator()()</code> with two parameters, and if you want the predicate to work with function adapters, your function object type must have an instance of the <code class="calibre23">binary_function&lt;Arg1Type, Arg2Type, ResultType&gt;</code> template as a base. Although you will typically make both arguments to a binary predicate of the same type, the base class does not require it, so when it is meaningful, your predicates can apply to arguments of different types.</p>
<p class="calibre20">If you don’t want to use your function objects with function adapters, you could define the type as:</p>
<pre class="calibre28"><code class="calibre23">// function_object.h
#pragma once
#include "Person.h"
        
class PersonComp
{
public:
  bool operator()(const Person&amp; p1, const Person&amp; p2) const
  {
    return p1 &gt; p2;
  }
};</code></pre>
<p class="calibre20">With this function object type, you could define the priority queue object as:</p>
<pre class="calibre28"><code class="calibre23">  std::priority_queue&lt;Person, std::vector&lt;Person&gt;, PersonComp&gt; people;</code></pre>
<p class="calibre20">You read names from the standard input stream in an indefinite <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  while(true)
  {
    std::cout &lt;&lt; "Enter a first name or press Enter to end: " ;
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="537" id="calibre_link-999" class="calibre14"></span>std::getline(std::cin, first);
    if(first.empty())
      break;
        
    std::cout &lt;&lt; "Enter a second name: " ;
    std::getline(std::cin, second);
    people.push(Person {first, second});
  }</code></pre>
<p class="calibre20">An empty first name will terminate the loop. After reading a second name, you create the <code class="calibre23">Person</code> object in the argument expression to the <code class="calibre23">push()</code> function that adds the object to the priority queue. It will be inserted at a position determined by a <code class="calibre23">greater&lt;&gt;</code> predicate. This will result in the objects being ordered with the smallest at the top. You can see from the output that the names are in ascending sequence based on the second name.</p>
<p class="calibre20">After outputting the number of objects in the queue using the <code class="calibre23">size()</code> function, you output the contents of the queue in a <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  while(!people.empty())
  {
    people.top().showPerson();
    people.pop();
  }</code></pre>
<p class="calibre20">The <code class="calibre23">top()</code> function returns a reference to the object at the front of the queue, and you use this reference to call <code class="calibre23">showPerson()</code> to output the name. You then call <code class="calibre23">pop()</code> to remove the element at the front of the queue; unless you do this, you can’t access the next element.</p>
<p class="calibre20">When the loop ends, the priority queue will be empty. There’s no way to access all the elements and retain them in the queue. If you want to keep them, you would have to put them somewhere else &mdash; perhaps in another priority queue.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h4 class="calibre22">Stack Containers</h4>
<p class="calibre13">The <code class="calibre23">stack&lt;T&gt;</code> adapter template is defined in the <code class="calibre23">stack</code> header and implements a pushdown stack based on a <code class="calibre23">deque&lt;T&gt;</code> container by default. A pushdown stack is a last-in first-out storage mechanism where only the object that was added most recently is accessible.</p>
<p class="calibre13">Here’s how you can define a stack:</p>
<pre class="calibre28"><code class="calibre23">std::stack&lt;Person&gt; people;</code></pre>
<p class="calibre13">This defines a stack to store <code class="calibre23">Person</code> objects.</p>
<p class="calibre13">The base container can be any sequence container that supports the operations <code class="calibre23">back(), push_back()</code>, and <code class="calibre23">pop_back()</code>. You could define a stack based on a list like this:</p>
<pre class="calibre28"><code class="calibre23">std::stack&lt;std::string, std::list&lt;std::string&gt;&gt; names;</code></pre>
<p class="calibre13">The first template argument is the element type as before, and the second is the container type to be used as a base for the stack.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="538" id="calibre_link-1000" class="calibre14"></span>There are only five operations available with a <code class="calibre23">stack&lt;T&gt;</code> container, and they are shown in the following table.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">top()</code></td>
<td class="calibre32">Returns a reference to the element at the top of the stack. If the stack is empty, then the value returned is undefined. You can assign the reference returned to a <code class="calibre23">const</code> or non-<code class="calibre23">const</code> reference and if it is assigned to the latter, you can modify the object in the stack.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">push()</code></td>
<td class="calibre32">Adds the element specified by the argument to the top of the stack.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">pop()</code></td>
<td class="calibre32">Removes the element at the top of the stack.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size()</code></td>
<td class="calibre32">Returns the number of elements in the stack.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">empty()</code></td>
<td class="calibre32">Returns <code class="calibre23">true</code> if the stack is empty and <code class="calibre23">false</code> otherwise.</td>
</tr>
</tbody>
</table>
<p class="calibre13">As with the other containers provided through container adapters, you cannot use iterators to access the contents. Let’s see a stack working.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Stack Container</h3>
<p class="calibre20">This example stores <code class="calibre23">Person</code> objects in a stack. The <code class="calibre23">Person</code> class is the same as in the previous example, so I won’t repeat the code here.</p>
<pre class="calibre28"><code class="calibre23">// Ex10_10.cpp
// Exercising a stack container
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;list&gt;
#include "Person.h"
        
int main()
{
  std::stack&lt;Person, std::list&lt;Person&gt;&gt; people;
        
  std::string first, second;
  while(true)
  {
    std::cout &lt;&lt; "Enter a first name or press Enter to end: " ;
    std::getline(std::cin, first);
    if(first.empty())
      break;
        
    std::cout &lt;&lt; "Enter a second name: " ;
    std::getline(std::cin, second);
    people.push(Person {first, second});
  }
        
  std::cout &lt;&lt; "\nThere are " &lt;&lt; people.size() &lt;&lt; " people in the stack."
            &lt;&lt; std::endl;
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="539" id="calibre_link-1001" class="calibre14"></span>std::cout &lt;&lt; "\nThe names that you entered are:" &lt;&lt; std::endl;
  while(!people.empty())
  {
    people.top().showPerson();
    people.pop();
  }
}</code></pre>
<p class="calibre20">Here is an example of the output:</p>
<pre class="calibre28"><code class="calibre23">Enter a first name or press Enter to end: Gordon
Enter a second name: Brown
Enter a first name or press Enter to end: Harold
Enter a second name: Wilson
Enter a first name or press Enter to end: Margaret
Enter a second name: Thatcher
Enter a first name or press Enter to end: Winston
Enter a second name: Churchill
Enter a first name or press Enter to end: David
Enter a second name: Lloyd-George
Enter a first name or press Enter to end:
        
There are 5 people in the stack.
        
The names that you entered are:
David Lloyd-George
Winston Churchill
Margaret Thatcher
Harold Wilson
Gordon Brown</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">The code in <code class="calibre23">main()</code> is more or less the same as in the previous example. Only the container definition is significantly different:</p>
<pre class="calibre28"><code class="calibre23">  std::stack&lt;Person, std::list&lt;Person&gt;&gt; people;</code></pre>
<p class="calibre20">The stack container stores <code class="calibre23">Person</code> objects and is based on a <code class="calibre23">list&lt;T&gt;</code> container in this instance. You could also use a <code class="calibre23">vector&lt;T&gt;</code>, and if you omit the second type parameter, the stack will use a <code class="calibre23">deque&lt;T&gt;</code> container as a base.</p>
<p class="calibre20">The output demonstrates that a stack is indeed a last-in first-out container, as the order of names in the output is the reverse of the input.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">The tuple Class Template</h3>
<p class="calibre13">The <code class="calibre23">tuple&lt;&gt;</code> class template that is defined in the tuple header is a useful adjunct to the <code class="calibre23">array&lt;&gt;</code> container, and to other sequence containers such as the <code class="calibre23">vector&lt;&gt;</code>. As its name suggests, a <code class="calibre23">tuple&lt;&gt;</code> object encapsulates a number of different items of different types. If you were working with fixed records from a file, or possibly from an SQL database, you could use a <code class="calibre23">vector&lt;&gt;</code> or an array&lt;&gt; container to store <code class="calibre23">tuple&lt;&gt;</code> objects that encapsulate the fields in a record. Let’s look at a specific example.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="540" id="calibre_link-1002" class="calibre14"></span>Suppose you are working with personnel records that contain an integer employee number, a first name, a second name, and the age of the individual in years. You could define an alias for a <code class="calibre23">tuple&lt;&gt;</code> instance to encapsulate an employee record like this:</p>
<pre class="calibre28"><code class="calibre23">using Record = std::tuple&lt;int, std::string, std::string, int&gt;;</code></pre>
<p class="calibre13">An alias is very useful for reducing the verbosity of the type specification. The <code class="calibre23">Record</code> type name is the equivalent of a <code class="calibre23">tuple&lt;&gt;</code> that stores values of type <code class="calibre23">int, string, string</code>, and <code class="calibre23">int</code>, corresponding to a person’s ID, first name, second name, and age. You could now define an <code class="calibre23">array&lt;&gt;</code> container to store <code class="calibre23">Record</code> objects:</p>
<pre class="calibre28"><code class="calibre23">std::array&lt;Record, 5&gt; personnel { Record {1001, "Joan", "Jetson", 35},
                                  Record {1002, "Jim" , "Jones" , 26},
                                  Record {1003, "June", "Jello" , 31},
                                  Record {1004, "Jack", "Jester", 39} };</code></pre>
<p class="calibre13">This defines the <code class="calibre23">personnel</code> container, which is an array that can store five <code class="calibre23">Record</code> objects. If you wanted flexibility in the number of tuples you were dealing with, you could use a <code class="calibre23">vector&lt;&gt;</code> or a <code class="calibre23">list&lt;&gt;</code>. Here, you initialize four of the five elements in <code class="calibre23">personnel</code> from the initializer list. Here’s how you might store a fifth element:</p>
<pre class="calibre28"><code class="calibre23">personnel[4] = Record {1005, "Jean", "Jorell", 29};</code></pre>
<p class="calibre13">This uses the index operator to access the fifth element in the array container. You also have the option of creating a <code class="calibre23">tuple&lt;&gt;</code> object using the <code class="calibre23">make_tuple()</code> function template:</p>
<pre class="calibre28"><code class="calibre23">personnel[4] = std::make_tuple(1005, "Jean", "Jorell", 29);</code></pre>
<p class="calibre13">The <code class="calibre23">make_tuple()</code> function creates a <code class="calibre23">tuple&lt;&gt;</code> instance that is equivalent to our <code class="calibre23">Record</code> type because the deduced type parameters are the same.</p>
<p class="calibre13">To access the fields in a tuple, you use the <code class="calibre23">get()</code> template function. The template parameter is the index position of the field you want, indexed from zero. The argument to the function is the tuple that you are accessing. Here’s how you could list the records in the <code class="calibre23">personnel</code> container:</p>
<pre class="calibre28"><code class="calibre23">std::cout &lt;&lt; std::setiosflags(std::ios::left);      // Left align output
for (const auto&amp; r : personnel)
{
  std::cout &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;0&gt;(r) &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;1&gt;(r)
            &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;2&gt;(r) &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;3&gt;(r)
            &lt;&lt; std::endl;
}</code></pre>
<p class="calibre13">You need to include <code class="calibre23">iomanip</code> to compile this fragment. This outputs the fields in each tuple in <code class="calibre23">personnel</code> on a single line, with the fields left-justified in a field width of 10 characters, so it looks tidy. Note that the type parameter to the <code class="calibre23">get()</code> function template must be a compile-time constant. This implies that you cannot use a loop index variable as the type parameter, so you can’t iterate over the fields in a loop at runtime. It is helpful to define some integer constants that you can use to identify the fields in a tuple in a more readable way. For example, you could define the following constants:</p>
<pre class="calibre28"><code class="calibre23">const size_t ID {}, firstname {1}, secondname {2}, age {3};</code></pre>
<p class="calibre13">Now you can use these variables as type parameters in <code class="calibre23">get()</code> function instantiations making it much clearer which field you are retrieving:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="541" id="calibre_link-1003" class="calibre14"></span>for (const auto&amp; r : personnel))
{
  std::cout &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;ID&gt;(r) 
            &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;firstname&gt;(r)
            &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;secondname&gt;(r)
            &lt;&lt; std::setw(10) &lt;&lt; std::get&lt;age&gt;(r) &lt;&lt; std::endl;
}</code></pre>
<p class="calibre13">Let’s put some of the fragments together into something you can compile and run.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Storing Tuples in an Array</h3>
<p class="calibre20">Here’s the code for the example:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_11.cpp Using an array storing tuple objects
#include &lt;array&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
 
const size_t maxRecords{ 100 };
using Record = std::tuple&lt;int, std::string, std::string, int&gt;;
using Records = std::array&lt;Record, maxRecords&gt;;
 
// Lists the contents of a Records array
void listRecords(const Records&amp; people)
{
  const size_t ID{}, firstname{ 1 }, secondname{ 2 }, age{ 3 };
  std::cout &lt;&lt; std::setiosflags(std::ios::left);
  Record empty;
  for (const auto&amp; record : people))
  {
    if (record == empty) break;            // In case array is not full
    std::cout &lt;&lt; "ID: " &lt;&lt; std::setw(6) &lt;&lt; std::get&lt;ID&gt;(record)
              &lt;&lt; "Name: " &lt;&lt; std::setw(25) 
              &lt;&lt; (std::get&lt;firstname&gt;(record) +" " + std::get&lt;secondname&gt;(record))
              &lt;&lt; "Age: " &lt;&lt; std::setw(5) &lt;&lt; std::get&lt;age&gt;(record) &lt;&lt; std::endl;
  }
}
 
int main()
{
  Records personnel { Record {1001, "Arthur", "Dent", 35},
                      Record {1002, "Mary", "Poppins", 55},
                      Record {1003, "David", "Copperfield", 34},
                      Record {1004, "James", "Bond", 44} };
  personnel[4] = std::make_tuple(1005, "Harry", "Potter", 15);
  personnel.at(5) = Record {1006, "Bertie", "Wooster", 28};
 
  listRecords(personnel);
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="542" id="calibre_link-1004" class="calibre14"></span>This program produces the following output:</p>
<pre class="calibre28"><code class="calibre23">ID: 1001  Name: Arthur Dent              Age: 35
ID: 1002  Name: Mary Poppins             Age: 55
ID: 1003  Name: David Copperfield        Age: 34
ID: 1004  Name: James Bond               Age: 44
ID: 1005  Name: Harry Potter             Age: 15
ID: 1006  Name: Bertie Wooster           Age: 28</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">To make the code easier to read, there are two aliases defined:</p>
<pre class="calibre28"><code class="calibre23">using Record = std::tuple&lt;int, std::string, std::string, int&gt;;
using Records = std::array&lt;Record, maxRecords&gt;;</code></pre>
<p class="calibre20">The first defines <code class="calibre23">Record</code> as equivalent to the <code class="calibre23">tuple&lt;&gt;</code> type that stores four fields of type <code class="calibre23">int, string, string</code>, and <code class="calibre23">int</code>. The second defines <code class="calibre23">Records</code> as an <code class="calibre23">array&lt;&gt;</code> type, storing <code class="calibre23">maxRecords</code> elements of type <code class="calibre23">Record. maxRecords</code> is defined as a <code class="calibre23">const</code> value of type <code class="calibre23">size_t</code>. Aliases are a great help in simplifying code that uses the STL.</p>
<p class="calibre20">The <code class="calibre23">listRecords()</code> function outputs the elements in a <code class="calibre23">Records</code> array. The first statement in the function body defines constants for accessing the fields in a <code class="calibre23">Record</code> tuple. This enables meaningful names to be used, rather than numeric index values whose meaning would not be obvious. The next statement ensures that subsequent output to the output stream will be left-aligned. The range-based <code class="calibre23">for</code> loop runs through the elements in the <code class="calibre23">Records</code> array that has been passed to the function until an element that is the equivalent of zero is found. Elements that were not explicitly initialized will have been initialized using the no-arg constructor for the element type, <code class="calibre23">Record</code>. Fields in the tuple that each array element contains are accessed with the <code class="calibre23">get&lt;&gt;()</code> function using the constants that were defined for that purpose. The <code class="calibre23">setw()</code> manipulators set the width of the output field for the next item that is written to <code class="calibre23">cout</code>.</p>
<p class="calibre20">In <code class="calibre23">main()</code> you create the <code class="calibre23">personnel</code> array as type <code class="calibre23">Records</code> and initialize the first four elements with <code class="calibre23">Record</code> objects:</p>
<pre class="calibre28"><code class="calibre23">  Records personnel   { Record {1001, "Arthur", "Dent", 35},
                        Record {1002, "Mary", "Poppins", 55},
                        Record {1003, "David", "Copperfield", 34},
                        Record {1004, "James", "Bond", 44} };</code></pre>
<p class="calibre20">This is clearly a much more readable statement because of the aliases for <code class="calibre23">Records</code> and <code class="calibre23">Record</code>.</p>
<p class="calibre20">The next statement adds another <code class="calibre23">Record</code> to the array:</p>
<pre class="calibre28"><code class="calibre23">  personnel[4] = std::make_tuple(1005, "Harry", "Potter", 15);</code></pre>
<p class="calibre20">This uses the <code class="calibre23">operator[]()</code> function overload for the <code class="calibre23">personnel</code> array to access the element, and uses the <code class="calibre23">make_tuple()</code> function to create a tuple that is similar to the tuple of type <code class="calibre23">Record</code> to be stored in the array.</p>
<p class="calibre20">Curiously, the next statement uses a different technique to set the value for an array element:</p>
<pre class="calibre28"><code class="calibre23">  personnel.at(5) = Record {1006, "Bertie", "Wooster", 28};</code></pre>
<p class="calibre20">This uses the <code class="calibre23">at()</code> function for the array, and the argument value of 5 selects the sixth element in the array. Here, the tuple is created using the <code class="calibre23">Record</code> type name. Finally, you call <code class="calibre23">listRecords()</code> to list the contents of <code class="calibre23">personnel</code>. The output shows that everything works as it should.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-327" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="543" id="calibre_link-1005" class="calibre18"></span>ASSOCIATIVE CONTAINERS</h2>
<p class="calibre13">I’ll just discuss some of those available to give you an idea of how they work. The most significant feature of an associative container such as map&lt;K,T&gt; is that you can retrieve a particular object without searching. The location of an object of type T is determined from a key of type K that you supply along with the object when you add it to the container. You can retrieve any object rapidly just by supplying its key.</p>
<p class="calibre13">For <code class="calibre23">set&lt;T&gt;</code> and <code class="calibre23">multiset&lt;T&gt;</code> containers, objects act as their own keys. You might be wondering what the use of a container is, if before you can retrieve an object, you have to have the object available. After all, if you already have the object, why would you need to retrieve it? The point of set and multiset containers is not so much to store objects for later retrieval, but to create an aggregation of objects that you can test to see whether or not a given object is already a member.</p>
<p class="calibre13">I’ll concentrate on map containers. The set and multiset containers are used somewhat less frequently, and their operations are very similar so you should have little difficulty using these after you have learned how to apply map containers.</p>
<section class="toclist">
<h3 class="calibre21">Using Map Containers</h3>
<p class="calibre13">When you create a <code class="calibre23">map&lt;K,T&gt;</code> container, <code class="calibre23">K</code> is the type of key you use to store an object of type <code class="calibre23">T</code>. Key/object pairs are stored as objects of type <code class="calibre23">pair&lt;K,T&gt;</code> that is defined in the <code class="calibre23">utility</code> header. The <code class="calibre23">utility</code> header is included into the <code class="calibre23">map</code> header so this type definition is automatically available. Here’s an example of creating a map:</p>
<pre class="calibre28"><code class="calibre23">std::map&lt;Person, std::string&gt; phonebook;</code></pre>
<p class="calibre13">This defines an empty map container that stores entries that are key/object pairs, with keys of type <code class="calibre23">Person</code> and objects of type <code class="calibre23">string</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Although you use class objects here for both keys and objects in the map, the keys and objects can also be fundamental types such as</i> <code class="calibre23">int</code>, <i class="calibre15">or</i> <code class="calibre23">double</code>, <i class="calibre15">or</i> <code class="calibre23">char</code>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You can also create a map that is initialized with a sequence of <code class="calibre23">pair&lt;K,T&gt;</code> objects from another container:</p>
<pre class="calibre28"><code class="calibre23">std::map&lt;Person, std::string&gt; phonebook {iter1, iter2};</code></pre>
<p class="calibre13"><code class="calibre23">iter1</code> and <code class="calibre23">iter2</code> are a pair of iterators defining a series of key/object pairs from another container in the usual way, with <code class="calibre23">iter2</code> specifying a position one past the last pair to be included in the sequence. These iterators can be input iterators although the iterators you obtain from a map are bidirectional. You obtain iterators to access the contents of a map using the <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> functions, just as you would for a sequence container.</p>
<p class="calibre13">The entries in a map are ordered based on a function object of type <code class="calibre23">less&lt;Key&gt;</code> by default, so they will be stored in ascending key sequence. You can change the type function object used for ordering entries by supplying a third template type parameter. For example:</p>
<pre class="calibre28"><code class="calibre23">std::map&lt;Person, std::string, std::greater&lt;&gt;&gt; phonebook;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="544" id="calibre_link-1006" class="calibre14"></span>This map stores entries that are <code class="calibre23">Person</code>/<code class="calibre23">string</code> pairs, where <code class="calibre23">Person</code> is the key with an associated string object. The ordering of entries will be determined by a function object of type <code class="calibre23">greater&lt;&gt;</code>, so the entries will be in descending key sequence.</p>
<section class="toclist">
<h4 class="calibre22">Storing Objects</h4>
<p class="calibre13">You can define a pair object like this:</p>
<pre class="calibre28"><code class="calibre23">auto entry = std::pair&lt;Person, std::string&gt;
                                {Person {"Mel", "Gibson"}, "213 345 5678"};</code></pre>
<p class="calibre13">This creates the variable <code class="calibre23">entry</code> of type <code class="calibre23">pair&lt;Person,string&gt;</code> and initializes it to an object created from a <code class="calibre23">Person</code> object and a <code class="calibre23">string</code> object. I’m representing a phone number in a very simplistic way, just as a string, but of course it could be a class object identifying the components of the number, such as country code and area code. The <code class="calibre23">Person</code> class is the class from the previous example.</p>
<p class="calibre13">The <code class="calibre23">pair&lt;K,T&gt;</code> class template defines two constructors, a default constructor that creates an object from the default constructors for types <code class="calibre23">K</code> and <code class="calibre23">T</code>, and a constructor that defines an object from a key and its associated object. There are also constructor templates for copy constructors and constructors creating an object from rvalue references.</p>
<p class="calibre13">You can access the elements in a pair through the members <code class="calibre23">first</code> and <code class="calibre23">second</code>; thus, in the example, <code class="calibre23">entry.first</code> references the <code class="calibre23">Person</code> object and <code class="calibre23">entry.second</code> references the <code class="calibre23">string</code> object.</p>
<p class="calibre13">There is a helper template function, <code class="calibre23">make_pair()</code>, defined in the <code class="calibre23">utility</code> header that creates a pair object:</p>
<pre class="calibre28"><code class="calibre23">auto entry = std::make_pair(Person {"Nell", "Gwynne"}, "213 345 5678");</code></pre>
<p class="calibre13">The <code class="calibre23">make_pair()</code> function automatically deduces the type for the pair, from the argument types. Note that in this case it will be a <code class="calibre23">pair&lt;Person, const char*&gt;</code> object but that will be converted to <code class="calibre23">pair&lt;Person, string&gt;</code> when you insert it into the phonebook map.</p>
<p class="calibre13">All of the comparison operators are overloaded for pair objects, so you can compare them with any of the operators <code class="calibre23">&lt;, &lt;=, ==, !=, &gt;=</code>, and <code class="calibre23">&gt;</code>.</p>
<p class="calibre13">It’s often convenient to define an alias to abbreviate the <code class="calibre23">pair&lt;K,T&gt;</code> type you are using. For example:</p>
<pre class="calibre28"><code class="calibre23">using Entry = std::pair&lt;Person, std::string&gt; ;</code></pre>
<p class="calibre13">This defines <code class="calibre23">Entry</code> as the alias for the key/object pair type. Having defined <code class="calibre23">Entry</code>, you can use it to create objects. For example:</p>
<pre class="calibre28"><code class="calibre23">Entry entry1 {Person {"Jack", "Jones"}, "213 567 1234"};</code></pre>
<p class="calibre13">This statement defines a pair of type <code class="calibre23">pair&lt;Person, string&gt;</code>, using <code class="calibre23">Person("Jack", "Jones")</code> as the <code class="calibre23">Person</code> argument and <code class="calibre23">"213 567 1234"</code> as the <code class="calibre23">string</code> argument.</p>
<p class="calibre13">You can insert one or more pairs in a map using the <code class="calibre23">insert()</code> function. For example, here’s how you insert a single object:</p>
<pre class="calibre28"><code class="calibre23">phonebook.insert(entry1);</code></pre>
<p class="calibre13">This inserts the <code class="calibre23">entry1</code> pair into the <code class="calibre23">phonebook</code> container, as long as there is no other entry in the map that uses the same key. This version of the <code class="calibre23">insert()</code> function returns a value that is also a pair, <span {http://www.idpf.org/2007/ops}type="pagebreak" title="545" id="calibre_link-1007" class="calibre14"></span>where the first object in the pair is an iterator and the second is a <code class="calibre23">bool</code> value. The <code class="calibre23">bool</code> value will be <code class="calibre23">true</code> if the insertion was made, and <code class="calibre23">false</code> otherwise. The iterator will point to the element if it was stored in the map, or the element that is already in the map for the <code class="calibre23">entry1</code> key if the insert failed. Therefore, you can check if the object was stored, like this:</p>
<pre class="calibre28"><code class="calibre23">auto checkpair = phonebook.insert(entry1);
if(checkpair.second)
  std::cout &lt;&lt; "Insertion succeeded." &lt;&lt; std::endl;
else
  std::cout &lt;&lt; "Insertion failed." &lt;&lt; std::endl;</code></pre>
<p class="calibre13">The pair that <code class="calibre23">insert()</code> returns is stored in <code class="calibre23">checkpair</code>. The type for <code class="calibre23">checkpair</code> is <code class="calibre23">pair&lt;map&lt;Person,string&gt;::iterator, bool&gt;</code>, so <code class="calibre23">auto</code> is very helpful here. The type corresponds to a pair encapsulating an iterator of type <code class="calibre23">map&lt;Person,string&gt;::iterator</code> that you can access as <code class="calibre23">checkpair.first</code>; and a <code class="calibre23">bool</code> value that you access as <code class="calibre23">checkpair.second</code>. Dereferencing the iterator in the pair will give you access to the pair that is stored in the map; you can use the <code class="calibre23">first</code> and <code class="calibre23">second</code> members of that pair to access the key and object, respectively. This can be a little tricky, so let’s see what it looks like for <code class="calibre23">checkpair</code> in the preceding code:</p>
<pre class="calibre28"><code class="calibre23">std::cout &lt;&lt; "The key for the entry is:" &lt;&lt; std::endl;
checkpair.first-&gt;first.showPerson();</code></pre>
<p class="calibre13">The expression <code class="calibre23">checkpair.first</code> references the first member of <code class="calibre23">checkpair</code>, which is an iterator, so this expression accesses a pointer to the entry in the map. The entry in the map is another pair, so <code class="calibre23">checkpair.first-&gt;first</code> accesses the first member of that pair, the key, which is the <code class="calibre23">Person</code> object. You use this to call the <code class="calibre23">showPerson()</code> member to output the name. You could access the pair member that represents the phone number in a similar way, with the expression <code class="calibre23">checkpair.first-&gt;second</code>.</p>
<p class="calibre13">Another version of <code class="calibre23">insert()</code> inserts a series of pairs in a map. The pairs are defined by two iterators and the series would typically be from another map, although it could be from a different type of container.</p>
<p class="calibre13">A map defines the <code class="calibre23">operator[]()</code> member function, so you can use the subscript operator to insert an object. Here’s how you could insert the <code class="calibre23">entry1</code> object in the <code class="calibre23">phonebook</code> map:</p>
<pre class="calibre28"><code class="calibre23">phonebook[Person {"Jack", "Jones"}] = "213 567 1234";</code></pre>
<p class="calibre13">The subscript value is the key for the object that appears to the right of the assignment operator. This is perhaps a somewhat more intuitive way to store objects in a map. The disadvantage compared to <code class="calibre23">insert()</code> is that you lose the ability to discover whether the key was already in the map.</p>
<p class="calibre13">You can insert a pair that is constructed in place using the <code class="calibre23">emplace()</code> function template:</p>
<pre class="calibre28"><code class="calibre23">Entry him {Person {"Jack", "Spratt"}, "213 456 7899"};
auto checkpair = phonebook.emplace(std::move(him));</code></pre>
<p class="calibre13">This creates the pair, <code class="calibre23">him</code>, and calls <code class="calibre23">emplace()</code> with an rvalue reference to <code class="calibre23">him</code> as the argument. The pair that is returned contains an iterator and a <code class="calibre23">bool</code> value, with the same significance as the pair returned by the <code class="calibre23">insert()</code> function.</p>
<p class="calibre13">Of course, you can also write:</p>
<pre class="calibre28"><code class="calibre23">auto checkpair = phonebook.emplace(Person {"Jack", "Spratt"}, "213 456 7899");</code></pre>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="546" id="calibre_link-1008" class="calibre14"></span>Accessing Objects</h4>
<p class="calibre13">You can use the subscript operator to retrieve the object from a map that corresponds to a given key. For example:</p>
<pre class="calibre28"><code class="calibre23">string number {phonebook[Person{"Jack", "Jones"}]};</code></pre>
<p class="calibre13">This initializes <code class="calibre23">number</code> with the object corresponding to the key <code class="calibre23">Person {"Jack", "Jones"}</code>. If the key is not in the map, then a pair entry will be inserted into the map for this key, with the object as the default for the object type. This implies that for the preceding statement, the no-arg <code class="calibre23">string</code> constructor will be called to create the object corresponding to this key if the entry is not there.</p>
<p class="calibre13">Of course, you may not want a default object inserted when you attempt to retrieve an object for a given key. In this case you can use the <code class="calibre23">find()</code> function to check whether there’s an entry for a key, and then retrieve it if it’s there:</p>
<pre class="calibre28"><code class="calibre23">std::string number;
Person key {"Jack", "Jones"};
auto iter = phonebook.find(key);
        
if(iter != phonebook.end())
{
  number = iter-&gt;second;
  std::cout &lt;&lt; "The number is " &lt;&lt; number &lt;&lt; std::endl;
}
else
{
  std::cout &lt;&lt; "No number for the key ";
  key.showPerson();
}</code></pre>
<p class="calibre13">The <code class="calibre23">find()</code> function returns an iterator of type <code class="calibre23">map&lt;Person,string&gt;::iterator</code> that points to the object corresponding to the key if the key is present, or to one past the last map entry, which corresponds to the iterator returned by the <code class="calibre23">end()</code> function. Thus, if <code class="calibre23">iter</code> is not equal to the iterator returned by <code class="calibre23">end()</code>, the entry exists so you can access the object through the second member of the pair. If you want to prevent the object in the map from being modified, you could define the iterator type explicitly as <code class="calibre23">map&lt;Person,string&gt;::const_iterator</code>.</p>
<p class="calibre13">Calling <code class="calibre23">count()</code>for a map with a key as the argument will return a count of the number of entries found corresponding to the key. For a map, the value returned can only be <code class="calibre23">0</code> or <code class="calibre23">1</code>, because each key must be unique. A multimap container allows multiple entries for a given key, so in this case other values are possible for the return value from <code class="calibre23">count()</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Other Map Operations</h4>
<p class="calibre13">The <code class="calibre23">erase()</code> function enables you to remove a single entry or a range of entries from a map. You have two versions of <code class="calibre23">erase()</code> that will remove a single entry. One requires an iterator as the argument pointing to the entry to be erased, and the other requires a key corresponding to the entry to be erased. For example:</p>
<pre class="calibre28"><code class="calibre23">Person key {"Jack", "Jones"};
auto count = phonebook.erase(key);
if(!count)
  std::cout &lt;&lt; "Entry was not found." &lt;&lt; std::endl;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="547" id="calibre_link-1009" class="calibre14"></span>When you supply a key to <code class="calibre23">erase()</code>, it returns a count of the number of entries that were erased. The value returned can only be <code class="calibre23">0</code> or <code class="calibre23">1</code> for a map. A multimap container can have several entries with the same key, in which case <code class="calibre23">erase()</code> may return a value greater than 1.</p>
<p class="calibre13">You can also supply an iterator as an argument to <code class="calibre23">erase()</code>:</p>
<pre class="calibre28"><code class="calibre23">Person key {"Jack", "Jones"};
auto iter = phonebook.find(key);
if(iter != phonebook.end())
  iter = phonebook.erase(iter);
if(iter == phonebook.end())
  std::cout &lt;&lt; "End of the map reached." &lt;&lt; std::endl;</code></pre>
<p class="calibre13">In this case, <code class="calibre23">erase()</code>returns an iterator that points to the entry that remains in the map beyond the entry that was erased, or a pointer to one beyond the end of the map if no such element is present.</p>
<p class="calibre13">The following table shows other operations available with a map.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">begin()</code></td>
<td class="calibre32">Returns a bidirectional iterator pointing to the first entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">end()</code></td>
<td class="calibre32">Returns a bidirectional iterator pointing to one past the last entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">cbegin()</code></td>
<td class="calibre32">Returns a <code class="calibre23">const</code> bidirectional iterator pointing to the first entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">cend()</code></td>
<td class="calibre32">Returns a <code class="calibre23">const</code> bidirectional iterator pointing to one past the last entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">rbegin()</code></td>
<td class="calibre32">Returns a reverse bidirectional iterator pointing to the last entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">rend()</code></td>
<td class="calibre32">Returns a reverse bidirectional iterator pointing to one before the first entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">crbegin()</code></td>
<td class="calibre32">Returns a <code class="calibre23">const</code> reverse bidirectional iterator pointing to the last entry in the map.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">crend()</code></td>
<td class="calibre32">Returns a <code class="calibre23">const</code> reverse bidirectional iterator pointing to one before the first entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">at()</code></td>
<td class="calibre32">Returns a reference to the data value corresponding to the key you supply as the argument.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">lower_bound()</code></td>
<td class="calibre32">Accepts a key as an argument and returns an iterator pointing to the first entry with a key that is greater than or equal to (the lower bound of) the specified key. If the key is not present, the iterator pointing to one past the last entry will be returned.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">upper_bound()</code></td>
<td class="calibre32">Accepts a key as an argument and returns an iterator pointing to the first entry with a key that is greater than (the upper bound of) the specified key. If the key is not present, the iterator pointing to one past the last entry will be returned.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="548" id="calibre_link-1010" class="calibre14"></span><code class="calibre23">equal_range()</code></td>
<td class="calibre32">Accepts a key as an argument and returns a pair containing two iterators. The first pair-member points to the lower bound of the specified key, and the second points to the upper bound of the specified key. If the key is not present, both iterators will point to one past the last entry.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">swap()</code></td>
<td class="calibre32">Interchanges the entries you pass as the argument, with the entries for which the function is called.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">clear()</code></td>
<td class="calibre32">Erases all entries in the map.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">size()</code></td>
<td class="calibre32">Returns the number of entries in the map.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">max_size()</code></td>
<td class="calibre32">Returns the maximum capacity of the map.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">empty()</code></td>
<td class="calibre32">Returns <code class="calibre23">true</code> if the map is empty and <code class="calibre23">false</code> otherwise.</td>
</tr>
</tbody>
</table>
<p class="calibre13">The <code class="calibre23">lower_bound(), upper_bound()</code>, and <code class="calibre23">equal_range()</code> functions are not very useful with a map container. However, they come into their own with a multimap when you want to find all elements with a given key. Let’s see a map in action.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using a Map Container</h3>
<p class="calibre20">This example uses a map to store phone numbers and provides a mechanism for finding a phone number for a person. It uses a variation on the <code class="calibre23">Person</code> class:</p>
<pre class="calibre28"><code class="calibre23">// Person.h
// A class defining a person
#pragma once
#include &lt;string&gt;
 
class Person
{
public:
  Person(const std::string&amp; first = "", const std::string&amp; second = "") :
                                          firstname {first}, secondname {second} {}
  // Move constructor
  Person(std::string&amp;&amp; first, std::string&amp;&amp; second) :
                   firstname {std::move(first)}, secondname {std::move(second)}  {}
 
  // Move constructor
  Person(Person&amp;&amp; person) : 
                            firstname {std::move(person.firstname)},
                            secondname {std::move(person.secondname)} {}
        
  // Move assignment operator
  Person&amp; operator=(Person&amp;&amp; person)
  {
    firstname = std::move(person.firstname);
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="549" id="calibre_link-1011" class="calibre14"></span>secondname = std::move(person.secondname);
  }
  
  // Less-than operator
  bool operator&lt;(const Person&amp; p)const
  {
    return (secondname &lt; p.secondname ||
                     ((secondname == p.secondname) &amp;&amp; (firstname &lt; p.firstname)));
  }
        
  // Get the name
  std::string getName()const
  {
    return firstname + " " + secondname;
  }
        
private:
  std::string firstname;
  std::string secondname;
};</code></pre>
<p class="calibre20">The no-arg constructor is defined by providing default values for the constructor arguments. There is a move constructor for rvalue arguments for the data members and a move constructor for an rvalue <code class="calibre23">Person</code> argument. The new function <code class="calibre23">getName()</code> returns the complete name as a <code class="calibre23">string</code>.</p>
<p class="calibre20">The source file containing <code class="calibre23">main()</code> and some helper functions looks like this:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_12.cpp
// Using a map container
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include "Person.h"
        
using std::string;
using PhoneBook = std::map&lt;Person, string&gt;;
using Entry = std::pair&lt;Person, string&gt;;
 
// Read a person from cin
Person getPerson()
{
  string first, second;
  std::cout &lt;&lt; "Enter a first name: " ;
  getline(std::cin, first);
  std::cout &lt;&lt; "Enter a second name: " ;
  getline(std::cin, second);
  return Person {std::move(first), std::move(second)};
}
 
// Read a phone book entry from standard input
Entry inputEntry()
{
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="550" id="calibre_link-1012" class="calibre14"></span>Person person {getPerson()};
        
  string number;
  std::cout &lt;&lt; "Enter the phone number for " &lt;&lt; person.getName() &lt;&lt; ": ";
  getline(std::cin, number);
  return std::make_pair(std::move(person), std::move(number));
}
 
// Add a new entry to a phone book
void addEntry(PhoneBook&amp; book) 
{
  auto pr = book.insert(inputEntry());
        
    if(pr.second)
      std::cout &lt;&lt; "Entry successful." &lt;&lt; std::endl;
    else
    {
      std::cout &lt;&lt; "Entry exists for " &lt;&lt; pr.first-&gt;first.getName()
                &lt;&lt; ". The number is " &lt;&lt; pr.first-&gt;second &lt;&lt; std::endl;
    }
}
        
// List the contents of a phone book
void listEntries(const PhoneBook&amp; book) 
{
  if(book.empty())
  {
    std::cout &lt;&lt; "The phone book is empty." &lt;&lt; std::endl;
    return;
  }
  std::cout &lt;&lt; setiosflags(std::ios::left);              // Left justify output
  for(const auto&amp; entry : book)
  {
    std::cout &lt;&lt; std::setw(30) &lt;&lt; entry.first.getName()
              &lt;&lt; std::setw(12) &lt;&lt; entry.second &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; resetiosflags(std::ios::right);           // Right justify output
}
        
// Retrieve an entry from a phone book
void getEntry(const PhoneBook&amp; book) 
{
  Person person {getPerson()};
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="551" id="calibre_link-1013" class="calibre14"></span>auto iter = book.find(person);
  if(iter == book.end())
    std::cout &lt;&lt; "No entry found for " &lt;&lt; person.getName() &lt;&lt; std::endl;
  else
    std::cout &lt;&lt; "The number for " &lt;&lt; person.getName()
         &lt;&lt; " is " &lt;&lt; iter-&gt;second &lt;&lt; std::endl;
}
        
// Delete an entry from a phone book
void deleteEntry(PhoneBook&amp; book)
{
  Person person {getPerson()};
  auto iter = book.find(person);
  if(iter == book.end())
    std::cout &lt;&lt; "No entry found for " &lt;&lt; person.getName() &lt;&lt; std::endl;
  else
  {
    book.erase(iter);
    std::cout &lt;&lt; person.getName() &lt;&lt; " erased." &lt;&lt; std::endl;
  }
}
        
int main()
{
  PhoneBook phonebook;
  char answer {};
        
  while(true)
  {
    std::cout &lt;&lt; "Do you want to enter a phone book entry(Y or N): " ;
    std::cin &gt;&gt; answer;
    while(std::cin.get() != '\n');    // Ignore up to newline
    if(toupper(answer) == 'N')
      break;
    if(toupper(answer) != 'Y')
    {
      std::cout &lt;&lt; "Invalid response. Try again." &lt;&lt; std::endl;
      continue;
    }
    addEntry(phonebook);
  }
        
  // Query the phonebook
  while(true)
  {
    std::cout &lt;&lt; "\nChoose from the following options:" &lt;&lt; std::endl
         &lt;&lt; "A  Add an entry   D Delete an entry   G  Get an entry" &lt;&lt; std::endl
         &lt;&lt; "L  List entries   Q  Quit" &lt;&lt; std::endl;
    std::cin &gt;&gt; answer;
    while(std::cin.get() != '\n');    // Ignore up to newline
        
    switch(toupper(answer))
    {
      case 'A':
        addEntry(phonebook);
        break;
      case 'G':
        getEntry(phonebook);
        break;
      case 'D':
        deleteEntry(phonebook);
        break;
      case 'L':
        listEntries(phonebook);
        break;
      case 'Q':
        return 0;
      <span {http://www.idpf.org/2007/ops}type="pagebreak" title="552" id="calibre_link-1014" class="calibre14"></span>default:
        std::cout &lt;&lt; "Invalid selection. Try again." &lt;&lt; std::endl;
        break;
    }
  }
  return 0;
}</code></pre>
<p class="calibre20">Here is some output from this program:</p>
<pre class="calibre28"><code class="calibre23">Do you want to enter a phone book entry(Y or N): y
Enter a first name: Jack
Enter a second name: Bateman
Enter the phone number for Jack Bateman: 312 455 6576
Entry successful.
Do you want to enter a phone book entry(Y or N): y
Enter a first name: Mary
Enter a second name: Jones
Enter the phone number for Mary Jones: 213 443 5671
Entry successful.
Do you want to enter a phone book entry(Y or N): y
Enter a first name: Jane
Enter a second name: Junket
Enter the phone number for Jane Junket: 413 222 8134
Entry successful.
Do you want to enter a phone book entry(Y or N): n
        
Choose from the following options:
A  Add an entry   D Delete an entry   G  Get an entry
L  List entries   Q  Quit
a
Enter a first name: Bill
Enter a second name: Smith
Enter the phone number for Bill Smith: 213 466 7688
Entry successful.
        
Choose from the following options:
A  Add an entry   D Delete an entry   G  Get an entry
L  List entries   Q  Quit
g
Enter a first name: Mary
Enter a second name: Miller
No entry found for Mary Miller
        
Choose from the following options:
A  Add an entry   D Delete an entry   G  Get an entry
L  List entries   Q  Quit
g
Enter a first name: Mary
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="553" id="calibre_link-1015" class="calibre14"></span>Enter a second name: Jones
The number for Mary Jones is 213 443 5671
        
Choose from the following options:
A  Add an entry   D Delete an entry   G  Get an entry
L  List entries   Q  Quit
d
Enter a first name: Mary
Enter a second name: Jones
Mary Jones erased.
        
Choose from the following options:
A  Add an entry   D Delete an entry   G  Get an entry
L  List entries   Q  Quit
L
Jack Bateman                  312 455 6576
Jane Junket                   413 222 8134
Bill Smith                    213 466 7688
        
Choose from the following options:
A  Add an entry   D Delete an entry   G  Get an entry
L  List entries   Q  Quit
q</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You define aliases for the types for a <code class="calibre23">PhoneBook</code> container and its entries like this:</p>
<pre class="calibre28"><code class="calibre23">using PhoneBook = std::map&lt;Person, string&gt;;
using Entry = std::pair&lt;Person, string&gt;;</code></pre>
<p class="calibre20">The object in an entry is a <code class="calibre23">string</code> containing a phone number, and the key is a <code class="calibre23">Person</code> object. These type aliases will make the code easier to read.</p>
<p class="calibre20">You load up the map initially in a <code class="calibre23">while</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  while(true)
  {
    std::cout &lt;&lt; "Do you want to enter a phone book entry(Y or N): " ;
    std::cin &gt;&gt; answer;
    while(std::cin.get() != '\n');    // Ignore up to newline
    if(toupper(answer) == 'N')
      break;
    if(toupper(answer) != 'Y')
    {
      std::cout &lt;&lt; "Invalid response. Try again." &lt;&lt; std::endl;
      continue;
    }
    addEntry(phonebook);
  }</code></pre>
<p class="calibre20">You check whether an entry is to be read by reading a character from the input stream. Reading a character from <code class="calibre23">cin</code> leaves at least a newline character in the buffer, and this can cause problems for subsequent input. The user might accidentally type additional characters to the response, too. The <code class="calibre23">while</code> loop skips everything up to the next newline by calling <code class="calibre23">get()</code> for <code class="calibre23">cin</code> repeatedly until a newline is reached. If <code class="calibre23">'n'</code> or <code class="calibre23">'N'</code> is entered, the loop is terminated. When <code class="calibre23">'y'</code> or <code class="calibre23">'Y'</code> is entered, an entry is created by calling the helper function <code class="calibre23">addEntry()</code> that is coded like this:</p>
<pre class="calibre28"><code class="calibre23">void addEntry(PhoneBook&amp; book)
{
  auto pr = book.insert(inputEntry());        
  if(pr.second)
    std::cout &lt;&lt; "Entry successful." &lt;&lt; std::endl;
  else
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="554" id="calibre_link-1016" class="calibre14"></span>{
    std::cout &lt;&lt; "Entry exists for " &lt;&lt; pr.first-&gt;first.getName()
              &lt;&lt; ". The number is " &lt;&lt; pr.first-&gt;second &lt;&lt; std::endl;
   
   }
}</code></pre>
<p class="calibre20">The parameter for <code class="calibre23">addEntry()</code> is a reference. The function modifies the container that is passed as the argument, so the function must have access to the original object. In any event, even if read-only access to the container argument was needed, it is important not to allow potentially very large objects, such as a map container, to be passed by value, because copying them can seriously degrade performance.</p>
<p class="calibre20">An entry is created by calling the <code class="calibre23">inputEntry()</code> helper function, which makes use of the <code class="calibre23">getPerson()</code> function that creates a <code class="calibre23">Person</code> object from keyboard input in the way you saw in the previous section. You then call <code class="calibre23">insert()</code> for the <code class="calibre23">phonebook</code> object, and store the object returned in <code class="calibre23">pr</code>. The <code class="calibre23">pr</code> object enables you to check that the entry was successfully inserted into the map, by testing its <code class="calibre23">bool</code> member. The <code class="calibre23">pr</code> variable is of type <code class="calibre23">pair&lt;map&lt;Person,string&gt;::iterator,bool&gt;</code>, but the <code class="calibre23">auto</code> keyword works that out for you. The first member of <code class="calibre23">pr</code> provides access to the entry, whether it’s an existing entry or the new entry, and the second is the <code class="calibre23">bool</code> value. You use these to output a message.</p>
<p class="calibre20">After initial input is complete, a <code class="calibre23">while</code> loop provides the mechanism for querying and modifying the phone book. The <code class="calibre23">switch</code> statement decides the action to be taken, based on the character that is entered and stored in <code class="calibre23">answer</code>. Querying the phone book is managed by the <code class="calibre23">getEntry()</code> function:</p>
<pre class="calibre28"><code class="calibre23">void getEntry(const PhoneBook&amp; book) 
{
  Person person {getPerson()};
  auto iter = book.find(person);
  if(iter == book.end())
    std::cout &lt;&lt; "No entry found for " &lt;&lt; person.getName() &lt;&lt; std::endl;
  else
    std::cout &lt;&lt; "The number for " &lt;&lt; person.getName()
              &lt;&lt; " is " &lt;&lt; iter-&gt;second &lt;&lt; std::endl;
}</code></pre>
<p class="calibre20">A <code class="calibre23">Person</code> object is created from a name that is read from the keyboard by calling the <code class="calibre23">getPerson()</code> function. The <code class="calibre23">Person</code> object is then used as the argument to the <code class="calibre23">find()</code> function for the map object. This returns an iterator of type <code class="calibre23">map&lt;Person,string&gt;::const_iterator</code> that either points to the required entry, or points to one past the last entry in the map. If an entry is found, accessing the <code class="calibre23">second</code> member of the pair pointed to by the iterator provides the number corresponding to the <code class="calibre23">Person</code> object key.</p>
<p class="calibre20">The <code class="calibre23">deleteEntry()</code> function deletes an entry from the map. The process is similar to that used in the <code class="calibre23">getEntry()</code> function, the difference being that when an entry is found by the <code class="calibre23">find()</code> function, the <code class="calibre23">erase()</code> function is called to remove it. You could use another version of <code class="calibre23">erase()</code> to do this, in which case the code would be like this:</p>
<pre class="calibre28"><code class="calibre23">void deleteEntry(PhoneBook&amp; book)
{
  Person person getPerson();
  if(book.erase(person))
    std::cout &lt;&lt; person.getName() &lt;&lt; " erased." &lt;&lt; std::endl;
  else
    std::cout &lt;&lt; "No entry found for " &lt;&lt; person.getName() &lt;&lt; std::endl;
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="555" id="calibre_link-1017" class="calibre14"></span>The code turns out to be much simpler if you pass the key to the <code class="calibre23">erase()</code> function.</p>
<p class="calibre20">The <code class="calibre23">listEntries()</code> function lists the contents of a phone book. After an initial check for an empty map, the entries are listed in a range-based <code class="calibre23">for</code> loop. The output is left-justified by the <code class="calibre23">setiosflags</code> manipulator to produce tidy output. This remains in effect until the <code class="calibre23">resetiosflags</code> manipulator is used to restore right-justification.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Using a Multimap Container</h3>
<p class="calibre13">A multimap works very much like the map container, in that it supports the same range of functions &mdash; except for the subscript operator, which you cannot use with a multimap. The principle difference between a map and a multimap is that you can have multiple entries with the same key in a multimap, and this affects the way some of the functions behave. Obviously, with the possibility of several keys having the same value, overloading <code class="calibre23">operator[]()</code> would not make much sense.</p>
<p class="calibre13">The <code class="calibre23">insert()</code> function flavors for a multimap are a little different from those for a map. The simplest version accepts a <code class="calibre23">pair&lt;K,T&gt;</code> object as an argument and returns an iterator pointing to the entry that was inserted. The equivalent function for a map returns a pair object because this provides an indication of when the key already exists in the map and the insertion is not possible; of course, this cannot arise with a multimap. A multimap also has a version of <code class="calibre23">insert()</code> with two arguments: the second being the pair object to be inserted, and the first being an iterator pointing to the position from which to start searching for an insertion point. This gives you some control over where a pair is inserted when the same key already exists. This version of <code class="calibre23">insert()</code> also returns an iterator pointing to the element that was inserted. A third version of <code class="calibre23">insert()</code> accepts two iterator arguments that specify a range of elements to be inserted from another source and this version doesn’t return anything.</p>
<p class="calibre13">When you pass a key to <code class="calibre23">erase()</code>for a multimap, it erases all entries with the same key, and the value returned indicates how many were deleted. The significance of having a version of <code class="calibre23">erase()</code>that accepts an iterator as an argument should now be apparent &mdash; it allows you to delete a single element. You also have a version of <code class="calibre23">erase()</code> that accepts two iterators to delete a range of entries.</p>
<p class="calibre13">The <code class="calibre23">find()</code> member function can only find the first element with a given key. You really need a way to find several elements with the same key and the <code class="calibre23">lower_bound(), upper_bound()</code>, and <code class="calibre23">equal_range()</code> functions provide you with a way to do this. For example, given a <code class="calibre23">phonebook</code> object that is of type <code class="calibre23">multimap&lt;Person, string&gt;</code>, you could list the phone numbers corresponding to a given key like this:</p>
<pre class="calibre28"><code class="calibre23">Person person("Jack", "Jones");
auto iter = phonebook.lower_bound(person);
if(iter == phonebook.end())
  std::cout &lt;&lt; "There are no entries for " &lt;&lt; person.getName() &lt;&lt; std::endl;
else
{
  std::cout &lt;&lt; "The following numbers are listed for " &lt;&lt; person.getName()
            &lt;&lt; ":" &lt;&lt; std::endl;
  auto upper = phonebook.upper_bound(person);
  for (; iter != upper; ++iter)
    std::cout &lt;&lt; iter-&gt;second &lt;&lt; std::endl;
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="556" id="calibre_link-1018" class="calibre14"></span>It’s important to check the iterator returned by <code class="calibre23">lower_bound()</code>. If you don’t, you could end up referencing an entry one beyond the last entry.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-328" class="calibre3"></a>MORE ON ITERATORS</h2>
<p class="calibre13">The <code class="calibre23">iterator</code> header defines templates for stream iterators that transfer data from a source to a destination. These act as pointers to a stream for input or output, and they enable you to transfer data between a stream and any source or destination that works with iterators, such as an algorithm. Inserter iterators can transfer data into a basic sequence container. There are two stream iterator templates: <code class="calibre23">istream_iterator&lt;T&gt;</code> for input streams and <code class="calibre23">ostream_iterator&lt;T&gt;</code> for output streams, where <code class="calibre23">T</code> is the type of object to be extracted from, or written to, the stream. The header also defines three inserter templates, <code class="calibre23">insert_iterator&lt;T&gt;, back_insert_iterator&lt;T&gt;,</code> and <code class="calibre23">front_insert_iterator&lt;T&gt;</code>, where <code class="calibre23">T</code> is the type of sequence container in which data is to be inserted.</p>
<p class="calibre13">Let’s explore some of these iterators in a little more depth.</p>
<section class="toclist">
<h3 class="calibre21">Using Input Stream Iterators</h3>
<p class="calibre13">Here’s an example of how you create an input stream iterator:</p>
<pre class="calibre28"><code class="calibre23">std::istream_iterator&lt;int&gt; numbersInput {std::cin};</code></pre>
<p class="calibre13">This creates the iterator <code class="calibre23">numbersInput</code> of type <code class="calibre23">istream_iterator&lt;int&gt;</code> that can point to objects of type <code class="calibre23">int</code> in a stream. The argument to the constructor specifies the stream to which the iterator relates, so this is an iterator that can read integers from <code class="calibre23">cin</code>, the standard input stream.</p>
<p class="calibre13">The default <code class="calibre23">istream_iterator&lt;T&gt;</code> constructor creates an end-of-stream iterator, which will be equivalent to the end iterator for a container that you have been obtaining by calling the <code class="calibre23">end()</code> function. Here’s how you could create an end-of-stream iterator, complementing the <code class="calibre23">numbersInput</code> iterator:</p>
<pre class="calibre28"><code class="calibre23">std::istream_iterator&lt;int&gt; numbersEnd;</code></pre>
<p class="calibre13">Now you have a pair of iterators that defines a sequence of values of type <code class="calibre23">int</code> from <code class="calibre23">cin</code>. You could use these to load values from <code class="calibre23">cin</code> into a <code class="calibre23">vector&lt;int&gt;</code> container:</p>
<pre class="calibre28"><code class="calibre23">std::vector&lt;int&gt; numbers;
std::cout &lt;&lt; "Enter integers separated by spaces then a letter to end:" 
          &lt;&lt; std::endl;
std::istream_iterator&lt;int&gt; numbersInput {std::cin}, numbersEnd;
while(numbersInput != numbersEnd)
  numbers.push_back(*numbersInput++);</code></pre>
<p class="calibre13">After defining the vector container to hold values of type <code class="calibre23">int</code>, you create two input stream iterators: <code class="calibre23">numbersInput</code> is an input stream iterator reading values of type <code class="calibre23">int</code> from <code class="calibre23">cin</code>, and <code class="calibre23">numbersEnd</code> is an end-of-stream iterator. The <code class="calibre23">while</code> loop continues as long as <code class="calibre23">numbersInput</code> is not equal to the end-of-stream iterator, <code class="calibre23">numbersEnd</code>. When you execute this fragment, input continues until end-of-stream is recognized for <code class="calibre23">cin</code>. But what produces that condition? The end-of-stream condition will arise if you enter <code class="calibre23">Ctrl+Z</code> to close the input stream, or if you enter an invalid character such as a letter.</p>
<p class="calibre13">Of course, you are not limited to using input stream iterators as loop control variables. You can use them to pass data to an algorithm, such as <code class="calibre23">accumulate()</code>, which is defined in the <code class="calibre23">numeric</code> header:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="557" id="calibre_link-1019" class="calibre14"></span>std::cout &lt;&lt; "Enter integers separated by spaces then a letter to end:"
          &lt;&lt; std::endl;
std::istream_iterator&lt;int&gt; numbersInput {std::cin}, numbersEnd;
std::cout &lt;&lt; "The sum of the input values that you entered is "
          &lt;&lt; std::accumulate(numbersInput, numbersEnd, 0) &lt;&lt; std::endl;</code></pre>
<p class="calibre13">This fragment outputs the sum of however many integers you enter. You will recall that the arguments to <code class="calibre23">accumulate()</code> are an iterator pointing to the first value in the sequence, an iterator pointing to one past the last value, and the initial value for the sum. Here, you are transferring data directly from <code class="calibre23">cin</code> to the algorithm.</p>
<p class="calibre13">The <code class="calibre23">sstream</code> header defines the <code class="calibre23">basic_istringstream&lt;T&gt;</code> template that defines an object type that can access data from a stream buffer such as a <code class="calibre23">string</code> object. The header also defines the <code class="calibre23">istringstream</code> type as <code class="calibre23">basic_istringstream&lt;char&gt;</code>, which will be a stream of characters of type <code class="calibre23">char</code>. You can construct an <code class="calibre23">istringstream</code> object from a <code class="calibre23">string</code> object, which means you can read data from the <code class="calibre23">string</code> object, just as you read from <code class="calibre23">cin</code>. Because an <code class="calibre23">istringstream</code> object is a stream, you can pass it to an input iterator constructor and use the iterator to access the data in the underlying stream buffer. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">std::string data {"2.4 2.5 3.6 2.1 6.7 6.8 94 95 1.1 1.4 32"};
std::istringstream input {data};
std::istream_iterator&lt;double&gt; begin(input), end;
std::cout &lt;&lt; "The sum of the values from the data string is "
          &lt;&lt; std::accumulate(begin, end, 0.0) &lt;&lt; std::endl;</code></pre>
<p class="calibre13">You create the <code class="calibre23">istringstream</code> object, <code class="calibre23">input</code>, from the <code class="calibre23">string</code> object, <code class="calibre23">data</code>, so you can read from <code class="calibre23">data</code> as a stream. You create two stream iterators that can access <code class="calibre23">double</code> values in the <code class="calibre23">input</code> stream, and you use these to pass the contents of the <code class="calibre23">input</code> stream to the <code class="calibre23">accumulate()</code> algorithm. Note that the type of the third argument to the <code class="calibre23">accumulate()</code> function determines the type of the result, so you must specify this as a value of type <code class="calibre23">double</code> to get the sum produced correctly. Let’s try an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using an Input Stream Iterator</h3>
<p class="calibre20">This example uses a stream iterator to read text from the standard input stream and transfer it to a map container to produce a word count for the text. Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_13.cpp
// A simple word collocation
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iterator&gt;
        
int main()
{
  std::map&lt;std::string, int&gt; words;           // Map to store words and word counts
  std::cout &lt;&lt; "Enter some text, press Enter followed by Ctrl+Z"
               "then Enter to end:\n"
            &lt;&lt; std::endl;
 
  std::istream_iterator&lt;std::string&gt; stream_begin {std::cin}; // Stream iterator
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="558" id="calibre_link-1020" class="calibre14"></span>std::istream_iterator&lt;std::string&gt; stream_end;              // End stream iterator
 
  while (stream_begin != stream_end)          // Iterate over words in the stream
    words[*stream_begin++]++;                 // Increment and store a word count
 
  // Output the words and their counts
  std::cout &lt;&lt; "Here are the word counts for the text you entered:" &lt;&lt; std::endl;
  const int wordsPerLine {4};
  int wordCount {};
  std::cout &lt;&lt; std::setiosflags(std::ios::left);       // Ouput left-justified
  for (const auto&amp; word : words)
  {
    std::cout &lt;&lt; std::setw(15) &lt;&lt; word.first &lt;&lt; " " &lt;&lt; std::setw(5) &lt;&lt; word.second;
    if (++wordCount % wordsPerLine == 0) std::cout &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; std::endl;
}</code></pre>
<p class="calibre20">Here’s an example of some output from this program:</p>
<pre class="calibre28"><code class="calibre23">Enter some text and press Enter followed by Ctrl+Z then Enter to end:
Peter Piper picked a peck of pickled pepper
A peck of pickled pepper Peter Piper picked
If Peter Piper picked a peck of pickled pepper
Where's the peck of pickled pepper Peter Piper picked
^Z
Here are the word counts for the text you entered:
A               1    If              1    Peter           4    Piper           4
Where's         1    a               2    of              4    peck            4
pepper          4    picked          4    pickled         4    the             1</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You first define a map container to store the words and their counts:</p>
<pre class="calibre28"><code class="calibre23">  std::map&lt;std::string, int&gt; words;           // Map to store words and word counts</code></pre>
<p class="calibre20">This container stores each word count of type <code class="calibre23">int</code>, using the word of type <code class="calibre23">string</code> as the key. This will make it easy to accumulate the count for each word when you read from the input stream using stream iterators:</p>
<pre class="calibre28"><code class="calibre23">  std::istream_iterator&lt;std::string&gt;  stream_begin{std::cin}; // Stream iterator
  std::istream_iterator&lt;std::string&gt;  stream_end;             // End stream iterator</code></pre>
<p class="calibre20">The <code class="calibre23">begin</code> iterator is a stream iterator for the standard input stream, and <code class="calibre23">end</code> is an end-of-stream iterator.</p>
<p class="calibre20">You read the words and accumulate the counts in a loop:</p>
<pre class="calibre28"><code class="calibre23">  while(stream_begin != stream_end)           // Iterate over words in the stream
    words[*stream_begin++]++;                 // Increment and store a word count</code></pre>
<p class="calibre20">This simple <code class="calibre23">while</code> loop does a great deal of work. The loop control expression will iterate over the words entered via the standard input stream until the end-of-stream state is reached. The stream iterator reads words from <code class="calibre23">cin</code> delimited by whitespace, just like the overloaded <code class="calibre23">&gt;&gt;</code> operator for <code class="calibre23">cin</code>. You use the subscript operator for the map to store a count with the word as the key; remember, the argument to the subscript operator for a map is the key. The expression <code class="calibre23">*begin</code> accesses a word, and the expression <code class="calibre23">*stream_begin++</code> increments the iterator after accessing the word.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="559" id="calibre_link-1021" class="calibre14"></span>The first time a word is read, it will not be in the map, so the expression <code class="calibre23">words[*stream_begin++]</code> will store a new entry with the count having the default value <code class="calibre23">0</code>, and increment the begin iterator to the next word, ready for the next loop iteration. The whole expression <code class="calibre23">words[*stream_begin++]++</code> will increment the count for the entry, regardless of whether it is a new entry or not. Thus, an existing entry will just get its count incremented, whereas a new entry will be created and then its count incremented from 0 to 1.</p>
<p class="calibre20">Finally, you output the count for each word in a <code class="calibre23">for</code> loop:</p>
<pre class="calibre28"><code class="calibre23">  for (const auto&amp; word : words)
  {
    std::cout &lt;&lt; std::setw(15) &lt;&lt; word.first &lt;&lt; " " &lt;&lt; std::setw(5) &lt;&lt; word.second;
    if(++wordCount % wordsPerLine == 0) std::cout &lt;&lt; std::endl;
  }</code></pre>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Using Inserter Iterators</h3>
<p class="calibre13">An inserter iterator can add new elements to the sequence containers <code class="calibre23">vector&lt;T&gt;, deque&lt;T&gt;</code>, and <code class="calibre23">list&lt;T&gt;</code>. There are three templates that create inserter iterators defined in the <code class="calibre23">iterator</code> header:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">back_insert_iterator&lt;T&gt;</code> &mdash; Inserts elements at the end of a container of type <code class="calibre23">T</code>. The container must provide the <code class="calibre23">push_back()</code> member function for this to work.</li>
<li class="calibre6"><code class="calibre23">front_insert_iterator&lt;T&gt;</code> &mdash; Inserts elements at the beginning of a container of type <code class="calibre23">T</code>. This depends on <code class="calibre23">push_front()</code> being available for the container so it won’t work with a vector.</li>
<li class="calibre6"><code class="calibre23">insert_iterator&lt;T&gt;</code> &mdash; Inserts elements starting at a specified position within a container of type <code class="calibre23">T</code>. The container must have an <code class="calibre23">insert()</code>member function that accepts an iterator as the first argument, and an item to be inserted as the second argument. This also works with sorted/ordered associative containers because they satisfy the requirements.</li>
</ul>
<p class="calibre13">The constructors for the first two inserter iterator types expect a single argument specifying the container. For example:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;int&gt; numbers;
std::front_insert_iterator&lt;std::list&lt;int&gt;&gt; iter {numbers};</code></pre>
<p class="calibre13">Here, you create an iterator that can insert data at the beginning of the <code class="calibre23">list&lt;int&gt;</code> container <code class="calibre23">numbers</code>.</p>
<p class="calibre13">Inserting a value into the container is very simple:</p>
<pre class="calibre28"><code class="calibre23">*iter = 99;                  // Insert 99 at the front of the numbers container</code></pre>
<p class="calibre13">You could also use <code class="calibre23">front_inserter()</code> with the <code class="calibre23">numbers</code> container, like this:</p>
<pre class="calibre28"><code class="calibre23">std::front_inserter (numbers) = 99;</code></pre>
<p class="calibre13">This creates a front inserter for the numbers list and uses it to insert <code class="calibre23">99</code> at the beginning of the list. The argument to front_inserter() is the container to which the iterator is to be applied.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="560" id="calibre_link-1022" class="calibre14"></span>The constructor for an <code class="calibre23">insert_iterator&lt;T&gt;</code> iterator requires two arguments:</p>
<pre class="calibre28"><code class="calibre23">std::vector&lt;int&gt; values;
std::insert_iterator&lt;std::vector&lt;int&gt;&gt; iter_anywhere {values, std::begin(values)};</code></pre>
<p class="calibre13">The second argument is an iterator specifying where data is to be inserted &mdash; the start of the sequence in this instance. You can use this iterator in exactly the same way as the previous one. Here’s how you could insert a series of values into the vector using this iterator:</p>
<pre class="calibre28"><code class="calibre23">for(int i {}; i &lt; 100; i++)
  *iter_anywhere = i + 1;</code></pre>
<p class="calibre13">This loop inserts the integers <code class="calibre23">1</code> to <code class="calibre23">100</code> in the <code class="calibre23">values</code> container at the beginning. After executing this, the first 100 elements will be <code class="calibre23">1, 2</code>, and so on, through to <code class="calibre23">100</code>.</p>
<p class="calibre13">You could also use <code class="calibre23">inserter()</code> to insert the elements in reverse order:</p>
<pre class="calibre28"><code class="calibre23">for(int i {}; i &lt; 100; i++)
  std::inserter(values, std::begin(values)) = i + 1;</code></pre>
<p class="calibre13">The first argument to <code class="calibre23">inserter()</code> is the container, and the second is an iterator identifying the position where data is to be inserted. The values will be in reverse order from 100 down to 1.</p>
<p class="calibre13">The inserter iterators can be used in conjunction with the <code class="calibre23">copy()</code> algorithm in a particularly useful way. Here’s how you could read values from <code class="calibre23">cin</code> and transfer them to a <code class="calibre23">list&lt;T&gt;</code> container:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;double&gt; values;
std::cout &lt;&lt; "Enter a series of values separated by spaces"
          &lt;&lt; " followed by Ctrl+Z or a letter to end:" &lt;&lt; std::endl;
std::istream_iterator&lt;double&gt; input {std::cin}, input_end;
std::copy(input, input_end, std::back_inserter&lt;std::list&lt;double&gt;&gt; {values});</code></pre>
<p class="calibre13">You first create a list container that stores <code class="calibre23">double</code> values. After prompting for input, you create two input stream iterators for <code class="calibre23">double</code> values. The first iterator points to <code class="calibre23">cin</code>, and the second is an end-of-stream iterator created by the default constructor. You specify the input to the <code class="calibre23">copy()</code> algorithm with the two iterators; the destination for the copy operation is a back inserter iterator that you create in the third argument to the <code class="calibre23">copy()</code> function. The back inserter iterator adds the data transferred by the copy operation to the list container, <code class="calibre23">values</code>. This is quite powerful stuff. If you ignore the prompt, in two statements you read an arbitrary number of values from the standard input stream and transfer them to a list container.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Using Output Stream Iterators</h3>
<p class="calibre13">Complementing the input stream iterator template, the <code class="calibre23">ostream_iterator&lt;T&gt;</code> template provides output stream iterators for writing objects of type <code class="calibre23">T</code> to an output stream. There are two constructors for output stream iterators. One creates an iterator that transfers data to the destination stream:</p>
<pre class="calibre28"><code class="calibre23">std::ostream_iterator&lt;int&gt; out {std::cout};</code></pre>
<p class="calibre13">The template type argument, <code class="calibre23">int</code>, specifies the type of data to be handled, while the constructor argument, <code class="calibre23">cout</code>, specifies the stream that will be the destination for data, so the <code class="calibre23">out</code> iterator can write values of type <code class="calibre23">int</code> to the standard output stream. Here’s how you might use this iterator:</p>
<pre class="calibre28"><code class="calibre23">   int data[] {1, 2, 3, 4, 5, 6, 7, 8, 9};
   std::copy(std::cbegin(data), std::cend(data), out);</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="561" id="calibre_link-1023" class="calibre14"></span>The <code class="calibre23">copy()</code> algorithm that is defined in the <code class="calibre23">algorithm</code> header copies the sequence of objects specified by the first two iterator arguments to the output iterator specified by the third argument. Here, the function copies the elements from the <code class="calibre23">data</code> array to the <code class="calibre23">out</code> iterator, which will write the elements to <code class="calibre23">cout</code>. The result of executing this fragment will be:</p>
<pre class="calibre28"><code class="calibre23">123456789</code></pre>
<p class="calibre13">As you can see, the values are written to the output stream with no spaces in between. The second constructor can improve on this:</p>
<pre class="calibre28"><code class="calibre23">std::ostream_iterator&lt;int&gt; out{std::cout, ", "};</code></pre>
<p class="calibre13">The second argument is a string to be used as a delimiter for output values. If you use this iterator as the third argument to the <code class="calibre23">copy()</code> function in the previous fragment, the output will be:</p>
<pre class="calibre28"><code class="calibre23">1, 2, 3, 4, 5, 6, 7, 8, 9,</code></pre>
<p class="calibre13">The delimiter string that you specify as a second constructor argument is written to the stream following each value.</p>
<p class="calibre13">Let’s see how an output stream iterator works in practice.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using an Output Stream Iterator</h3>
<p class="calibre20">Suppose you want to read a series of integer values from <code class="calibre23">cin</code> and store them in a vector. You then want to output the values and their sum. Here’s how you could do this with the STL:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_14.cpp
// Using stream and inserter iterators
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
        
int main()
{
  std::vector&lt;int&gt; numbers;
  std::cout &lt;&lt; "Enter a series of integers separated by spaces"
            &lt;&lt; " followed by Ctrl+Z or a letter:" &lt;&lt; std::endl;
 
  std::istream_iterator&lt;int&gt; input {std::cin}, input_end;
  std::ostream_iterator&lt;int&gt; out {std::cout, " "};
 
  std::copy(input, input_end, std::back_inserter&lt;std::vector&lt;int&gt;&gt; {numbers});
 
  std::cout &lt;&lt; "You entered the following values:" &lt;&lt; std::endl;
  std::copy(std::cbegin(numbers), std::cend(numbers), out);
 
  std::cout &lt;&lt; "\nThe sum of these values is "
            &lt;&lt; std::accumulate(std::cbegin(numbers), std::cend(numbers), 0) 
            &lt;&lt; std::endl;
}</code></pre>
<p class="calibre20">Here’s an example of some output:</p>
<pre class="calibre28"><code class="calibre23">Enter a series of integers separated by spaces followed by Ctrl+Z or a letter:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ^Z
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="562" id="calibre_link-1024" class="calibre14"></span>You entered the following values:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
The sum of these values is 120</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">After creating the <code class="calibre23">numbers</code> vector to store integers and issuing a prompt for input, you create three stream iterators:</p>
<pre class="calibre28"><code class="calibre23">  std::istream_iterator&lt;int&gt; input{std::cin}, input_end;
  std::ostream_iterator&lt;int&gt; out {std::cout, " "};</code></pre>
<p class="calibre20">The first statement creates two input stream iterators, <code class="calibre23">input</code> and <code class="calibre23">input_end</code>, for reading values of type <code class="calibre23">int</code> from the standard input stream; the latter is an end-of-stream iterator. The second statement creates an output stream iterator for transferring values of type <code class="calibre23">int</code> to the standard output stream, with a single space following each output value.</p>
<p class="calibre20">Data is read from <code class="calibre23">cin</code> and transferred to the vector container using the <code class="calibre23">copy()</code> algorithm:</p>
<pre class="calibre28"><code class="calibre23">  std::copy(input, input_end, std::back_inserter&lt;std::vector&lt;int&gt;&gt; {numbers});</code></pre>
<p class="calibre20">You specify the data source by two input stream iterators, <code class="calibre23">input</code> and <code class="calibre23">input_end</code>, and the destination is a back inserter iterator for the <code class="calibre23">numbers</code> container. Thus, the copy operation will transfer data from <code class="calibre23">cin</code> to the <code class="calibre23">numbers</code> container via the back inserter.</p>
<p class="calibre20">You output the values in the container using another copy operation:</p>
<pre class="calibre28"><code class="calibre23">  std::copy(std::cbegin(numbers), std::cend(numbers), out);</code></pre>
<p class="calibre20">The source for the copy is specified by the begin and end iterators for the container, and the destination is the output stream iterator, <code class="calibre23">out</code>. This operation writes the data from <code class="calibre23">numbers</code> to <code class="calibre23">cout</code>, with the values separated by a space.</p>
<p class="calibre20">Finally, you calculate the sum of the values in the <code class="calibre23">numbers</code> container in the output statement using the <code class="calibre23">accumulate()</code> algorithm:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; "\nThe sum of these values is "
            &lt;&lt; std::accumulate(std::cbegin(numbers), std::cend(numbers), 0) 
            &lt;&lt; std::endl;</code></pre>
<p class="calibre20">You specify the range of values to be summed by the begin and end iterators for the container, and the initial value for the sum is zero. If you wanted the average rather than the sum, this is easy too, using the statement:</p>
<pre class="calibre28"><code class="calibre23"> std::cout &lt;&lt; "\nThe average is "
    &lt;&lt; std::accumulate(std::cbegin(numbers), std::cend(numbers), 0.0)/numbers.size()
    &lt;&lt; std::endl;</code></pre>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-329" class="calibre3"></a>MORE ON FUNCTION OBJECTS</h2>
<p class="calibre13">I mentioned earlier that the <code class="calibre23">functional</code> header defines an extensive set of templates for creating function objects that you can use with algorithms and containers. I won’t discuss them all in detail, but I’ll summarize the most useful ones. The function objects for comparisons are:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="563" id="calibre_link-1025" class="calibre14"></span><b class="calibre12">FUNCTION OBJECT TEMPLATE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">less&lt;T&gt;</code></td>
<td class="calibre32">A binary predicate representing the <code class="calibre23">&lt;</code> operation between objects of type <code class="calibre23">T</code>. For example, <code class="calibre23">less&lt;string&gt;()</code> defines a function object for comparing objects of type <code class="calibre23">string</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">less_equal&lt;T&gt;</code></td>
<td class="calibre32">A binary predicate representing the <code class="calibre23">&lt;=</code> operation between objects of type <code class="calibre23">T</code>. For example, <code class="calibre23">less_equal&lt;double&gt;()</code> defines a function object for comparing objects of type <code class="calibre23">double</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">equal_to&lt;T&gt;</code></td>
<td class="calibre32">A binary predicate representing the <code class="calibre23">==</code> operation between objects of type <code class="calibre23">T</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">not_equal_to&lt;T&gt;</code></td>
<td class="calibre32">A binary predicate representing the <code class="calibre23">!=</code> operation between objects of type <code class="calibre23">T</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">greater_equal&lt;T&gt;</code></td>
<td class="calibre32">A binary predicate representing the <code class="calibre23">&gt;=</code> operation between objects of type <code class="calibre23">T</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">greater&lt;T&gt;</code></td>
<td class="calibre32">A binary predicate representing the <code class="calibre23">&gt;</code> operation between objects of type <code class="calibre23">T</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13">There is also the <code class="calibre23">not2&lt;&gt;()</code> template function that creates a binary predicate that is the negation of a binary predicate defined by a function object you pass as the argument. For example, <code class="calibre23">not2(less&lt;int&gt;())</code> creates a binary predicate for comparing objects of type <code class="calibre23">int</code> that returns <code class="calibre23">true</code> if the left operand is not less than the right operand. You could use the <code class="calibre23">not2()</code> function template to define a binary predicate for use with the <code class="calibre23">sort()</code> algorithm to sort a container, <code class="calibre23">v</code>, with elements of type <code class="calibre23">string</code>:</p>
<pre class="calibre28"><code class="calibre23">std::sort(std::begin(v), std::end(v), std::not2(std::greater&lt;std::string&gt;()));</code></pre>
<p class="calibre13">The argument to the <code class="calibre23">not2</code> constructor is <code class="calibre23">greater&lt;string&gt;()</code>, so the <code class="calibre23">sort()</code> function will sort using “not greater than” as the comparison between the <code class="calibre23">string</code> objects in the container, <code class="calibre23">v</code>.</p>
<p class="calibre13">The <code class="calibre23">functional</code> header also defines function objects for performing arithmetic operations. You would typically use these to apply operations to sequences of numerical values using the <code class="calibre23">transform()</code> algorithm that is defined in the <code class="calibre23">algorithm</code> header. These function objects are described in the following table.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION OBJECT TEMPLATE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">plus&lt;T&gt;</code></td>
<td class="calibre32">Calculates the sum of two elements of type <code class="calibre23">T</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">minus&lt;T&gt;</code></td>
<td class="calibre32">Calculates the difference between two elements of type <code class="calibre23">T</code> by subtracting the second operand from the first.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">multiplies&lt;T&gt;</code></td>
<td class="calibre32">Calculates the product of two elements of type <code class="calibre23">T</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">divides&lt;T&gt;</code></td>
<td class="calibre32">Divides the first operand of type <code class="calibre23">T</code> by the second.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">modulus&lt;T&gt;</code></td>
<td class="calibre32">Calculates the remainder after dividing the first operand of type <code class="calibre23">T</code> by the second.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">negate&lt;T&gt;</code></td>
<td class="calibre32">Returns the negative of the operand of type <code class="calibre23">T</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="564" id="calibre_link-1026" class="calibre14"></span>To make use of these, you need to apply the <code class="calibre23">transform()</code> function. I’ll explain how this works in the next section.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-330" class="calibre3"></a>MORE ON ALGORITHMS</h2>
<p class="calibre13">The <code class="calibre23">algorithm</code> and <code class="calibre23">numeric</code> headers define a large number of algorithms. The algorithms in the <code class="calibre23">numeric</code> header are primarily devoted to processing arrays of numerical values, whereas those in the <code class="calibre23">algorithm</code> header are more general purpose and provide such things as the ability to search, sort, copy, and merge sequences of objects specified by iterators. There are far too many to discuss in detail in this introductory chapter, so I’ll just introduce a few of the most useful algorithms from the <code class="calibre23">algorithm</code> header to give you a basic idea of how they can be used.</p>
<p class="calibre13">You have already seen the <code class="calibre23">sort()</code> and <code class="calibre23">copy()</code> algorithms in action. Let’s take a brief look at a few others.</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The <code class="calibre23">fill()</code> algorithm &mdash; This algorithm is of this form:
<pre class="calibre28"><code class="calibre23">fill(ForwardIterator begin, ForwardIterator end, const Type&amp; value)</code></pre>
<ol class="none">
<li class="calibre6">This fills the elements specified by the iterators begin and end with value. For example, given a vector <code class="calibre23">v</code>, containing more than 10 values of type string, you could write:</li></ol>
<pre class="calibre28"><code class="calibre23">std::fill(std::begin(v), std::begin(v)+10, "invalid");</code></pre>
<ol class="none">
<li class="calibre6">This would set the first 10 elements in <code class="calibre23">v</code> to <code class="calibre23">"invalid"</code>, the value specified by the last argument.</li></ol></li>
<li class="calibre6">The <code class="calibre23">replace()</code> algorithm &mdash; The <code class="calibre23">replace()</code> algorithm is of the form:
<pre class="calibre28"><code class="calibre23">replace(ForwardIterator begin_it, ForwardIterator end_it,
                                    const Type&amp; oldValue, const Type&amp; newValue)</code></pre>
<ol class="none">
<li class="calibre6">This examines each element in the range specified by <code class="calibre23">begin_it</code> and <code class="calibre23">end_it</code>, and replaces each occurrence of <code class="calibre23">oldValue</code> by <code class="calibre23">newValue</code>. Given a vector <code class="calibre23">v</code> that stores <code class="calibre23">string</code> objects, you could replace occurrences of <code class="calibre23">"yes"</code> by <code class="calibre23">"no"</code> using the following statement:</li></ol>
<pre class="calibre28"><code class="calibre23">std::replace(std::begin(v), std::end(v), "yes", "no");</code></pre>
<ol class="none">
<li class="calibre6">Like all the algorithms that receive an interval defined by a couple of iterators, <code class="calibre23">replace()</code> will also work with pointers. For example:</li></ol>
<pre class="calibre28"><code class="calibre23">char str[] =  "A nod is as good as a wink to a blind horse.";
std::replace(str, str + strlen(str), 'o', '*');
std::cout &lt;&lt; str &lt;&lt; std::endl;</code></pre>
<ol class="none">
<li class="calibre6">This will replace every occurrence of <code class="calibre23">'o'</code> in the null-terminated string <code class="calibre23">str</code> by <code class="calibre23">'*'</code>, so the result of executing this fragment will be:</li></ol>
<pre class="calibre28"><code class="calibre23">A n*d is as g**d as a wink t* a blind h*rse.</code></pre></li>
<li class="calibre6">The <code class="calibre23">find()</code> algorithm &mdash; The <code class="calibre23">find()</code> algorithm is of the form:
<pre class="calibre28"><code class="calibre23">InputIterator find(InputIterator begin, InputIterator end, const Type&amp; value)</code></pre>
<ol class="none">
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="565" id="calibre_link-1027" class="calibre14"></span>This searches the sequence specified by the first two arguments for the first occurrence of <code class="calibre23">value</code>. For example, given a vector <code class="calibre23">v</code> containing values of type <code class="calibre23">int</code>, you could write:</li></ol>
<pre class="calibre28"><code class="calibre23">auto iter = std::find(std::cbegin(v), std::cend(v), 21);</code></pre>
<ol class="none">
<li class="calibre6">By using <code class="calibre23">iter</code> as the starting point for a new search, you could use <code class="calibre23">find()</code> repeatedly to find all occurrences of a given value:</li></ol>
<pre class="calibre28"><code class="calibre23">auto iter = std::cbegin(v); 
const int value {21};
size_t count {};
while((iter = std::find(iter, std::cend(v), value)) != std::cend(v))
{
  ++iter;
  ++count;
}
std::cout &lt;&lt; "The vector contains " &lt;&lt; count &lt;&lt; " occurrences of " &lt;&lt; value
          &lt;&lt; std::endl;</code></pre>
<ol class="none">
<li class="calibre6">This searches the vector <code class="calibre23">v</code> for all occurrences of <code class="calibre23">value</code>. On the first iteration, the search starts at <code class="calibre23">cbegin(v)</code>. On subsequent iterations, the search starts at one past the previous position that was found. The loop will accumulate the total number of occurrences of <code class="calibre23">value</code> in <code class="calibre23">v</code>.</li></ol></li>
<li class="calibre6">The <code class="calibre23">transform()</code> algorithm &mdash; <code class="calibre23">transform()</code> comes in two versions. The first applies an operation specified by a unary function object to a set of elements specified by a pair of iterators, and is of the form:
<pre class="calibre28"><code class="calibre23">OutputIterator transform(InputIterator begin, InputIterator end,
                                       OutputIterator result, UnaryFunction f)</code></pre>
<ol class="none">
<li class="calibre6">This applies the unary function <code class="calibre23">f</code> to all elements in the range specified by the iterators <code class="calibre23">begin</code> and <code class="calibre23">end</code>, and stores the results, beginning at the position specified by the <code class="calibre23">result</code> iterator. The <code class="calibre23">result</code> iterator can be the same as <code class="calibre23">begin</code>, in which case the results will replace the original elements. The function returns an iterator that is one past the last result stored. Here’s an example:</li></ol>
<pre class="calibre28"><code class="calibre23">std::vector&lt;double&gt; data{ 2.5, -3.5, 4.5, -5.5, 6.5, -7.5};
std::transform(std::begin(data), std::end(data), std::begin(data),
                                                         std::negate&lt;double&gt;());</code></pre>
<ol class="none">
<li class="calibre6">The <code class="calibre23">transform()</code> call applies a <code class="calibre23">negate&lt;double&gt;</code> predicate object to all the elements in the vector data. The results are stored back in <code class="calibre23">data</code> and overwrite the original values so after this operation the vector will contain:</li></ol>
<pre class="calibre28"><code class="calibre23">-2.5, 3.5, -4.5, 5.5, -6.5, 7.5</code></pre>
<ol class="none">
<li class="calibre6">Because the operation writes the results back to <code class="calibre23">data</code>, the <code class="calibre23">transform()</code> function will return the iterator <code class="calibre23">std::end(data)</code>.</li>
<li class="calibre6">The second version of <code class="calibre23">transform()</code> applies a binary function, with the operands coming from two ranges specified by iterators. The function is of the form:</li></ol>
<pre class="calibre28"><code class="calibre23">transform(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,
                                       OutputIterator result, BinaryFunction f)</code></pre>
<ol class="none">
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="566" id="calibre_link-1028" class="calibre14"></span>The range specified by <code class="calibre23">begin1</code> and <code class="calibre23">end1</code> defines the set of left operands for the binary function <code class="calibre23">f</code> that is specified by the last argument. The range defining the right operands starts at the position specified by the <code class="calibre23">begin2</code> iterator; an end iterator does not need to be supplied for this range because there must be the same number of elements as in the range specified by <code class="calibre23">begin1</code> and <code class="calibre23">end1</code>. The results will be stored in the range, starting at the <code class="calibre23">result</code> iterator position. The <code class="calibre23">result</code> iterator can be the same as <code class="calibre23">begin1</code> if you want the results stored back in that range, but it must not be any other position between <code class="calibre23">begin1</code> and <code class="calibre23">end1</code>. Here’s an example:</li></ol>
<pre class="calibre28"><code class="calibre23">double values[] { 2.5, -3.5, 4.5, -5.5, 6.5, -7.5};
std::vector&lt;double&gt; squares(_countof(values));
std::transform (std::begin(values), std::end(values), std::begin(values),
                              std::begin(squares), std::multiplies&lt;double&gt;());
std::ostream_iterator&lt;double&gt; out {std::cout, " "};
std::copy(std::cbegin(squares), std::cend(squares), out);</code></pre>
<ol class="none">
<li class="calibre6">You create the <code class="calibre23">squares</code> vector with the same number of elements as <code class="calibre23">values</code> to store the results of the <code class="calibre23">transform()</code> operation. The <code class="calibre23">transform()</code> function uses the <code class="calibre23">multiplies&lt;double&gt;()</code> function object to multiply each element of <code class="calibre23">values</code> by itself. The results are stored in <code class="calibre23">squares</code>. The last two statements use an output stream iterator to list the contents of <code class="calibre23">squares</code>, which will be:</li></ol>
<pre class="calibre28"><code class="calibre23">6.25 12.25 20.25 30.25 42.25 56.25</code></pre></li>
</ul>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-331" class="calibre3"></a>TYPE TRAITS AND STATIC ASSERTIONS</h2>
<p class="calibre13">A static assertion enables you to detect usage errors at compile time. A static assertion is of the form:</p>
<pre class="calibre28"><code class="calibre23">static_assert(constant_expression, string_literal);</code></pre>
<p class="calibre13">The <code class="calibre23">constant_expression</code> should result in a value that is convertible to type <code class="calibre23">bool</code>. If the result is <code class="calibre23">true</code>, the statement does nothing; if it is <code class="calibre23">false</code>, the string literal will be displayed by the compiler. A static assertion has no effect on the compiled code. Note that <code class="calibre23">static_assert</code> is a keyword.</p>
<p class="calibre13">The <code class="calibre23">type_traits</code> header defines a range of templates that enable you to create compile-time constants that you can use in conjunction with static assertions to cause the compiler to issue customized error messages. I don’t have the space to describe the contents of <code class="calibre23">type_traits</code> in detail so I’ll just give you one example and use type traits in the next section.</p>
<p class="calibre13">The <code class="calibre23">type_traits</code> header includes several templates for testing types that are particularly useful when you are defining your own templates. Suppose you define the following template:</p>
<pre class="calibre28"><code class="calibre23">template&lt;class T&gt;
T average(const std::vector&lt;T&gt;&amp; data)
{
  T sum {};
  for(const auto&amp; value : data)
    sum += value;
  return sum/data.size();
}</code></pre>
<p class="calibre13">This template is intended to be used with a vector of values that are of an arithmetic type. It would be useful to be able to prevent the template from being used with non-arithmetic types &mdash; <code class="calibre23">Person</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="567" id="calibre_link-1029" class="calibre14"></span>objects, for example. It would be useful if this can be caught at compile time. A <code class="calibre23">static_assert</code> in conjunction with the <code class="calibre23">is_arithmetic&lt;T&gt;</code> template from <code class="calibre23">type_traits</code> will do the trick:</p>
<pre class="calibre28"><code class="calibre23">template&lt;class T&gt;
T average(const std::vector&lt;T&gt;&amp; data)
{
  static_assert(std::is_arithmetic&lt;T&gt;::value,
                             "Type parameter for average() must be arithmetic.");
  T sum {};
  for(auto&amp; value : data) 
    sum += value;
  return sum/data.size();
}</code></pre>
<p class="calibre13">The <code class="calibre23">value</code> member of the <code class="calibre23">is_arithmetic&lt;T&gt;</code> template will be <code class="calibre23">true</code> if <code class="calibre23">T</code> is an arithmetic type and <code class="calibre23">false</code> otherwise. If it is <code class="calibre23">false</code> during compilation; that is, when the compiler processes the <code class="calibre23">average&lt;T&gt;()</code> template used with a non-arithmetic type, the error message will be displayed. An arithmetic type is a floating-point type or an integral type.</p>
<p class="calibre13">Other type testing templates include <code class="calibre23">is_integral&lt;T&gt;, is_signed&lt;T&gt;, is_unsigned&lt;T&gt;, is_floating_point&lt;T&gt;</code>, and <code class="calibre23">is_enum&lt;T&gt;</code>. There are many other useful templates in the <code class="calibre23">type_traits</code> header so it is well worth exploring the contents further.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-332" class="calibre3"></a>LAMBDA EXPRESSIONS</h2>
<p class="calibre13">A lambda expression provides you with an alternative programming mechanism to function objects. Lambda expressions are a C++ language feature and not specific to STL but they can be applied extensively in this context, which is why I chose to discuss them here. A lambda expression defines a function object without a name, and without the need for an explicit class definition. You would typically use a lambda expression as the means of passing a function as an argument to another function. A lambda expression is much easier to use and understand, and requires less code than defining and creating a function object. Of course, it is not a replacement for function objects in general.</p>
<p class="calibre13">Let’s consider an example. Suppose you want to calculate the cubes (x3) of the elements in a vector containing numerical values. You could use the <code class="calibre23">transform()</code> operation for this, except that there is no function object to calculate cubes. You can easily create a lambda expression to do it, though:</p>
<pre class="calibre28"><code class="calibre23">double values[] { 2.5, -3.5, 4.5, -5.5, 6.5, -7.5};
std::vector&lt;double&gt; cubes(_countof(values));
std::transform(std::begin(values), std::end(values), std::begin(cubes),
                                            [](double x){ return x*x*x;} );</code></pre>
<p class="calibre13">The last statement uses <code class="calibre23">transform()</code> to calculate the cubes of the elements in the array, <code class="calibre23">values</code>, and store the result in the vector <code class="calibre23">cubes</code>. The lambda expression is the last argument to the <code class="calibre23">transform()</code> function:</p>
<pre class="calibre28"><code class="calibre23">[](double x){ return x*x*x;}</code></pre>
<p class="calibre13">The opening square brackets are called the lambda introducer, because they mark the beginning of the lambda expression. There’s a bit more to this, so I’ll come back to it a little later in this chapter.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="568" id="calibre_link-1030" class="calibre14"></span>The lambda introducer is followed by the lambda parameter list between parentheses, just like a normal function. In this case, there’s just a single parameter, <code class="calibre23">x</code>. There are restrictions on the lambda parameter list, compared to a regular function: You cannot specify default values for the parameters and the parameter list cannot be of a variable length.</p>
<p class="calibre13">Finally, you have the body of the lambda expression between braces, again just like a normal function. In this case the body is just a single <code class="calibre23">return</code> statement, but in general, it can consist of as many statements as you like, just like a normal function. I’m sure you have noticed that there is no return type specification. The return type defaults to that of the value returned. Otherwise, the default return type is <code class="calibre23">void</code>. Of course, you can specify the return type. To specify the return type you would write the lambda expression like this:</p>
<pre class="calibre28"><code class="calibre23">[](double x) -&gt; double { return x*x*x; }</code></pre>
<p class="calibre13">The type <code class="calibre23">double</code> following the arrow specifies the return type.</p>
<p class="calibre13">If you wanted to output the values calculated, you could do so in the lambda expression:</p>
<pre class="calibre28"><code class="calibre23">[](double x) {
               double result{x*x*x}; 
               std::cout &lt;&lt; result &lt;&lt; "  ";
               return result;
             }</code></pre>
<p class="calibre13">This extends the body of the lambda to provide for writing the value that is calculated to the standard output stream. In this case, the return type is still deduced from the type of the value returned.</p>
<section class="toclist">
<h3 class="calibre21">The Capture Clause</h3>
<p class="calibre13">The lambda introducer can contain a capture clause that determines how the body of the lambda can access variables in the enclosing scope. In the previous section, the lambda expression had nothing between the square brackets, indicating that no variables in the enclosing scope can be accessed within the body of the lambda. A lambda that does not access anything from the enclosing scope is called a stateless lambda.</p>
<p class="calibre13">The first possibility is to specify a default capture clause that applies to all variables in the enclosing scope. You have two options for this. If you place <code class="calibre23">=</code> between the square brackets, the body has access to all automatic variables in the enclosing scope by value &mdash; that is, the values of the variables are made available within the lambda expression, but the original variables cannot be changed. If you put <code class="calibre23">&amp;</code> between the square brackets, all the variables in the enclosing scope are accessible by reference, and therefore can be changed by the code in the body of the lambda. Look at this code fragment:</p>
<pre class="calibre28"><code class="calibre23">double factor {5.0};
double values[] { 2.5, -3.5, 4.5, -5.5, 6.5, -7.5};
std::vector&lt;double&gt; cubes(_countof(values));
std::transform(std::begin(values), std::end(values), std::begin(cubes),
                                         [=](double x){ return factor*x*x*x;} );</code></pre>
<p class="calibre13">In this fragment, the <code class="calibre23">=</code> capture clause allows all the variables in scope to be accessible by value from within the body of the lambda. Note that this is not quite the same as passing arguments by value. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="569" id="calibre_link-1031" class="calibre14"></span>The value of the variable <code class="calibre23">factor</code> is available within the lambda, but you cannot update the copy of <code class="calibre23">factor</code> because it is effectively <code class="calibre23">const</code>. The following statement will not compile, for example:</p>
<pre class="calibre28"><code class="calibre23">std::transform(std::begin(values), std::end(values),std::begin(cubes),
           [=](double x)  { factor += 10.0;          // Not allowed!
                            return factor*x*x*x;} );</code></pre>
<p class="calibre13">If you want to modify the temporary copy of a variable in scope from within the lambda, adding the <code class="calibre23">mutable</code> keyword will enable this:</p>
<pre class="calibre28"><code class="calibre23">std::transform(std::begin(values), std::end(values),std::begin(cubes),
           [=](double x)mutable { factor += 10.0;          // OK
                                   return factor*x*x*x;} );</code></pre>
<p class="calibre13">Now you can modify the copy of any variable within the enclosing scope without changing the original variable. After executing this statement, the value of <code class="calibre23">factor</code> will still be <code class="calibre23">5.0</code>. The lambda remembers the local value of <code class="calibre23">factor</code> from one call to the next, so for the first element <code class="calibre23">factor</code> will be 5 + 10 = 15, for the second element it will be 15 + 10 = 25, and so on.</p>
<p class="calibre13">If you want to change the original value of <code class="calibre23">factor</code> from within the lambda, just use <code class="calibre23">&amp;</code> as the capture clause:</p>
<pre class="calibre28"><code class="calibre23">std::transform(std::begin(values), std::end(values),std::begin(cubes),
             [&amp;](double x){ factor += 10.0;   // Changes original variable
                            return factor*x*x*x;} );
std::cout &lt;&lt; "factor = " &lt;&lt; factor &lt;&lt; std::endl;</code></pre>
<p class="calibre13">You don’t need the <code class="calibre23">mutable</code> keyword here. All variables within the enclosing scope are available by reference, so you can use and alter their values. The result of executing this will be that <code class="calibre23">factor</code> is <code class="calibre23">65</code>. If you thought it was going to be <code class="calibre23">15.0</code>, remember that the lambda expression executes once for each element in <code class="calibre23">data</code>, and the cubes of the elements will be multiplied by successive values of <code class="calibre23">factor</code> from <code class="calibre23">15.0</code> to <code class="calibre23">65.0</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The use of a default capture clause is discouraged. It’s recommended that you should explicitly state which variables you want to capture.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Capturing Specific Variables</h3>
<p class="calibre13">You can explicitly identify the variables in the enclosing scope that you want to access. You could rewrite the previous <code class="calibre23">transform()</code> statement as:</p>
<pre class="calibre28"><code class="calibre23">std::transform(std::begin(values), std::end(values),std::begin(cubes),
      [&amp;factor](double x) { factor += 10.0;    // Changes original variable
                            return factor*x*x*x;} );</code></pre>
<p class="calibre13">Now, <code class="calibre23">factor</code> is the only variable from the enclosing scope that is accessible, and it is available by reference. If you omit the <code class="calibre23">&amp;, factor</code> would be available by value and not updatable. If you want to identify several variables in the capture clause, just separate them with commas. You could include <code class="calibre23">=</code> in the capture clause list, as well as explicit variable names. For example, with the capture clause <code class="calibre23">[=,&amp;factor]</code> the lambda would have access to <code class="calibre23">factor</code> by reference and all other variables in the enclosing scope by value. Conversely, putting <code class="calibre23">[&amp;,factor]</code> as the capture clause would capture <span {http://www.idpf.org/2007/ops}type="pagebreak" title="570" id="calibre_link-1032" class="calibre14"></span><code class="calibre23">factor</code> by value and all other variables by reference. Note that in a function member of a class, you can include the <code class="calibre23">this</code> pointer in the capture clause for a lambda expression, which allows access to the other functions and data members that belong to the class.</p>
<p class="calibre13">A lambda expression can also include a <code class="calibre23">throw()</code> exception specification that indicates that the lambda does not throw exceptions. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">std::transform(std::begin(values), std::end(values),std::begin(cubes),
      [&amp;factor](double x)throw() { factor += 10.0;
                                   return factor*x*x*x;} );</code></pre>
<p class="calibre13">If you want to include the <code class="calibre23">mutable</code> specification, as well as the <code class="calibre23">throw()</code> specification, the <code class="calibre23">mutable</code> keyword must precede <code class="calibre23">throw()</code> and must be separated from it by one or more spaces.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Templates and Lambda Expressions</h3>
<p class="calibre13">You can use a lambda expression inside a template. Here’s an example of a function template that uses a lambda expression:</p>
<pre class="calibre28"><code class="calibre23">template &lt;class T&gt;
T average(const vector&lt;T&gt;&amp; vec)
{
  static_assert(std::is_arithmetic&lt;T&gt;::value,
                            "Type parameter for average() must be arithmetic.");
  T sum {};
  std::for_each(std::cbegin(vec), std::cend(vec),
    [&amp;sum](const T&amp; value){ sum += value; });
  return sum/vec.size();
}</code></pre>
<p class="calibre13">This template generates functions for calculating the average of a set of numerical values stored in a vector. The <code class="calibre23">algorithm</code> header defines <code class="calibre23">for_each()</code>. The lambda expression uses the template type parameter in the lambda parameter specification, and accumulates the sum of all the elements in a vector. The <code class="calibre23">sum</code> variable is accessed from the lambda by reference, so it is able to accumulate the sum there. The last line of the function returns the average, which is calculated by dividing <code class="calibre23">sum</code> by the number of elements in the vector. Let’s try an example.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Using Lambda Expressions</h3>
<p class="calibre20">This example shows the use of a variety of lambda expressions:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_15.cpp Using lambda expressions
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;random&gt;
 
using namespace std; // Just to make the code easier  to read in the example...
        
// Template function to return the average of the elements in a vector
template &lt;class T&gt; T average(const vector&lt;T&gt;&amp; vec)
{
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="571" id="calibre_link-1033" class="calibre14"></span>static_assert(std::is_arithmetic&lt;T&gt;::value,
                            "Type parameter for average() must be arithmetic.");
  T sum {};
  for_each(cbegin(vec), cend(vec),
    [&amp;sum](const T&amp; value){ sum += value; });
  return sum/vec.size();
}
        
// Template function to set a vector to values beginning with start
// and incremented by increment
template &lt;class T&gt; void setValues(vector&lt;T&gt;&amp; vec, T start, T increment)
{
  static_assert(std::is_arithmetic&lt;T&gt;::value,
                            "Type parameter for setValues() must be arithmetic.");
  T current {start};
  generate(begin(vec), end(vec),
    [increment, &amp;current]() { T result {current}; 
                              current += increment;
                              return result;});
}
        
// Template function to set a vector to random values between min and max
template&lt;class T&gt; void randomValues(vector&lt;T&gt;&amp; vec, T min_value, T max_value)
{
  static_assert(std::is_arithmetic&lt;T&gt;::value,
    "Type parameter for randomValues() must be arithmetic.");
 
    random_device engine;                // Random number source
    auto max_rand = engine.max();        // Maximum random value
    auto min_rand = engine.min();        // Minimum random value
 
  generate(begin(vec), end(vec),
    [&amp;engine, max_rand, min_rand, min_value, max_value] 
    {  return static_cast&lt;T&gt;(static_cast&lt;double&gt;(engine()) /
                                max_rand*(max_value - min_value) + min_value); } );
}
        
// Template function to list the values in a vector
template&lt;class T&gt; void listVector(const vector&lt;T&gt;&amp; vec)
{
  int count {};       // Used to control outputs per line
  const int valuesPerLine {5};
  for_each(cbegin(vec), cend(vec),
    [&amp;count, valuesPerLine](const T&amp; n){
                                 cout &lt;&lt; setw(10) &lt;&lt; n &lt;&lt; "  ";
                                 if(++count % valuesPerLine == 0)
                                   cout &lt;&lt; endl;});
}
        
int main()
{
  vector&lt;int&gt; integerData(50);
  randomValues(integerData, 1, 10);            // Set random integer values
  cout &lt;&lt; "Vector contains random integers:" &lt;&lt; endl;
  listVector(integerData);
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="572" id="calibre_link-1034" class="calibre14"></span>cout &lt;&lt; "Average value is " &lt;&lt; average(integerData) &lt;&lt; endl;
 
  vector&lt;double&gt; realData(20);
  setValues(realData, 5.0, 2.5);   // Set real values starting at 5.0
  cout &lt;&lt; "\nVector contains real values:" &lt;&lt; endl;
  listVector(realData);
  cout &lt;&lt; "Average value is " &lt;&lt; average(realData) &lt;&lt; endl;
 
  vector&lt;double&gt; randomData(20);
  randomValues(randomData, 5.0, 25.0);   // Set random values from 5.0 to 25
  cout &lt;&lt; "\nVector contains random real values:" &lt;&lt; endl;
  listVector(randomData);
  cout &lt;&lt; "Average value is " &lt;&lt; average(randomData) &lt;&lt; endl;
}</code></pre>
<p class="calibre20">This example produces output similar to the following:</p>
<pre class="calibre28"><code class="calibre23">Vector contains random integers:
         2           9           9           2           8
         7           4           1           9           9
         7           3           3           2           4
         3           9           2           7           1
         4           6           6           8           9
         9           6           2           8           2
         9           3           1           5           8
         1           2           5           7           1
         4           2           8           4           2
         5           2           5           9           8
Average value is 5
 
Vector contains real values:
         5         7.5          10        12.5          15
      17.5          20        22.5          25        27.5
        30        32.5          35        37.5          40
      42.5          45        47.5          50        52.5
Average value is 28.75
 
Vector contains random real values:
   6.37904     19.0177     16.8027     10.6446      17.174
   12.1957     24.9999     10.8728     23.6502     16.9032
   16.7498     11.7784     17.3076     11.2226     15.8428
   8.52583     5.54059     10.3581      23.161     22.7069
Average value is 15.0917</code></pre>
<p class="calibre20">Where the example uses random number generation, the values are likely to be different.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">There are four function templates that use lambda expressions in the implementation of the functions that operate on vectors. The first, <code class="calibre23">average()</code>, calculates the average value of the elements in a vector by passing the following lambda expression as the last argument to the <code class="calibre23">for_each()</code> function:</p>
<pre class="calibre28"><code class="calibre23">[&amp;sum](const T&amp; value){ sum += value; }</code></pre>
<p class="calibre20">The <code class="calibre23">sum</code> variable that is defined in <code class="calibre23">average()</code>is accessed by reference in the lambda to accumulate the sum of all the elements. The parameter to the lambda is <code class="calibre23">value</code>, which is of type reference to <code class="calibre23">T</code>, so the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="573" id="calibre_link-1035" class="calibre14"></span>lambda automatically deals with whatever element type is in the vector. The static assertion ensures that the template type argument is arithmetic.</p>
<p class="calibre20">The next function template is <code class="calibre23">setValues()</code>. This sets the elements of a vector in sequence with the first element set to <code class="calibre23">start</code>, the next to <code class="calibre23">start+increment</code>, the next to <code class="calibre23">start+2*increment</code>, and so on. Thus, the function will set the vector elements to any set of equi-spaced values. The function calls the <code class="calibre23">generate()</code> function that is defined in the <code class="calibre23">algorithm</code> header. This sets a sequence of elements, defined by the first two iterator arguments, to the value returned by the function object you specify as the third argument. In this case, the third argument is the lambda expression:</p>
<pre class="calibre28"><code class="calibre23">[increment, &amp;current](){ T result {current}; 
                       current += increment;
                     return result;}</code></pre>
<p class="calibre20">The lambda accepts no arguments, but it accesses <code class="calibre23">increment</code> by value and <code class="calibre23">current</code> by reference, the latter being used to store the next value to be set. This lambda has the side effect that <code class="calibre23">current</code> will be updated when <code class="calibre23">generate</code> is finished. The following lambda expression is similar, but without the side effect:</p>
<pre class="calibre28"><code class="calibre23">[=]()mutable { T result {current}; 
             current += increment;
            return result;}</code></pre>
<p class="calibre20">The third function template is <code class="calibre23">randomValues()</code>, which stores random values of the appropriate type in the elements of a vector. The values will be in the range from <code class="calibre23">min</code> to <code class="calibre23">max</code>, the second and third arguments to the function. This uses a <code class="calibre23">std::random_device</code> function object from the <code class="calibre23">random</code> header for generating random numbers. The <code class="calibre23">min()</code> and <code class="calibre23">max()</code> member functions of <code class="calibre23">std::random_device</code> return the minimum and maximum values that it generates. The <code class="calibre23">random</code> header provides an extensive range of random number generators that are beyond the scope of this book but I encourage you to explore it if you need random number generators of any kind.</p>
<p class="calibre20">The <code class="calibre23">randomValues()</code> function calls <code class="calibre23">generate()</code>to store values produced by the following lambda expression in the vector:</p>
<pre class="calibre28"><code class="calibre23">[&amp;engine, &amp;max_rand, min_rand, min_value, max_value] 
{  return static_cast&lt;T&gt;(static_cast&lt;double&gt;(engine()) /
                               max_rand*(max_value - min_value) + min_value); }</code></pre>
<p class="calibre20">The <code class="calibre23">engine</code> functor is created in the outer scope, along with the values <code class="calibre23">max_rand</code> and <code class="calibre23">min_rand</code>. The four variables in the outer scope that are accessed by the lambda expression are identified in the capture clause. Only <code class="calibre23">engine</code> is accessed by reference; the other three are accessed by value. The arithmetic expression in the lambda scales the random value produced by <code class="calibre23">engine()</code> to the range <code class="calibre23">min_value</code> to <code class="calibre23">max_value</code>.</p>
<p class="calibre20">The last template function is <code class="calibre23">listVector()</code>, which outputs the values of the elements in a vector with the number of values per line specified by <code class="calibre23">valuesPerLine</code>. It uses the following lambda as the argument to the <code class="calibre23">for_each()</code> function to do this:</p>
<pre class="calibre28"><code class="calibre23">[&amp;count, valuesPerLine](const T&amp; n) {
                         cout &lt;&lt; setw(10) &lt;&lt; n &lt;&lt; "  ";
                         if(++count % valuesPerLine == 0)
                           cout &lt;&lt; endl;}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="574" id="calibre_link-1036" class="calibre14"></span>The capture clause captures the <code class="calibre23">count</code> variable that is defined in the <code class="calibre23">listVector()</code> function by reference, and this is used to record the number of values processed. <code class="calibre23">valuesPerLine</code> is captured by value. The parameter is a <code class="calibre23">const</code> reference to <code class="calibre23">T</code>, so any element type can be processed. The body of the lambda outputs the value of the current element, <code class="calibre23">n</code>, and the <code class="calibre23">if</code> statement ensures that after every fifth value, a newline is written to <code class="calibre23">cout</code>. The <code class="calibre23">setw()</code> manipulator ensures values are presented in the output in a field that is 10 characters wide, so we get nice neat columns of output.</p>
<p class="calibre20">You create a vector storing 50 integers and call <code class="calibre23">randomValues()</code> to set the elements to random values between 1 and 10:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;int&gt; integerData(50);
  randomValues(integerData, 1, 10);    // Set random integer values
  cout &lt;&lt; "Vector contains random integers:" &lt;&lt; endl;
  listVector(integerData);
  cout &lt;&lt; "Average value is "&lt;&lt; average(integerData) &lt;&lt; endl;</code></pre>
<p class="calibre20">The call to <code class="calibre23">listVector()</code> outputs the values, five to a line, as you see. The last statement calls the <code class="calibre23">average()</code> template function to calculate the average of the values in the vector. In all three template functions, the type is deduced from the <code class="calibre23">vector&lt;int&gt;</code> argument that is passed, and this also determines the type in the lambda that each function uses.</p>
<p class="calibre20">The next block of code in <code class="calibre23">main()</code> is:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;double&gt; realData(20);
  setValues(realData, 5.0, 2.5);   // Set real values starting at 5.0
  cout &lt;&lt; "\nVector contains real values:" &lt;&lt; endl;
  listVector(realData);
  cout &lt;&lt; "Average value is "&lt;&lt; average(realData) &lt;&lt; endl;</code></pre>
<p class="calibre20">This vector stores values of type <code class="calibre23">double</code>, and its elements are set using <code class="calibre23">setValues()</code>, which creates a sequence by incrementing from an initial value.</p>
<p class="calibre20">The last block of code stores random real values in a vector:</p>
<pre class="calibre28"><code class="calibre23">  vector&lt;double&gt; randomData(20);
  randomValues(randomData, 5.0, 25.0);   // Set random values from 5.0 to 25
  cout &lt;&lt; "\nVector contains random real values:" &lt;&lt; endl;
  listVector(randomData);
  cout &lt;&lt; "Average value is " &lt;&lt; average(randomData) &lt;&lt; endl;</code></pre>
<p class="calibre20">The output shows that everything works as expected.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Naming a Lambda Expression</h3>
<p class="calibre13">You can assign a stateless lambda &mdash; one that does not reference anything in an external scope &mdash; to a variable that is a function pointer, thus giving the lambda a name. You can then use the function pointer to call the lambda as many times as you like. For example:</p>
<pre class="calibre28"><code class="calibre23">  auto sum = [](int a,int b){return a+b; };</code></pre>
<p class="calibre13">The function pointer, <code class="calibre23">sum</code>, points to the lambda expression, so you can use it as many times as you like:</p>
<pre class="calibre28"><code class="calibre23">  std::cout &lt;&lt; "5 + 10 equals " &lt;&lt; sum(5,10) &lt;&lt; std::endl;
  std::cout &lt;&lt; "15 + 16 equals " &lt;&lt; sum(15,16) &lt;&lt; std::endl;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="575" id="calibre_link-1037" class="calibre14"></span>This is quite useful, but there’s a much more powerful capability. An extension to the <code class="calibre23">functional</code> header defines the <code class="calibre23">function&lt;&gt;</code> class template that you can use to define a wrapper for a function object; this includes a lambda expression. The <code class="calibre23">function&lt;&gt;</code> template is referred to as a polymorphic function wrapper because an instance of the template can wrap a variety of function objects with a given parameter list and return type. I won’t discuss all the details of the <code class="calibre23">function&lt;&gt;</code> class template, but I’ll just show how you can use it to wrap a lambda expression. Using the <code class="calibre23">function&lt;&gt;</code> template to wrap a lambda effectively gives a name to the lambda, which not only provides the possibility of recursion within a lambda expression, it also allows you to use the lambda in multiple statements or pass it to several different functions. The same function wrapper could also wrap different lambda expressions at different times.</p>
<p class="calibre13">To create a wrapper object from the <code class="calibre23">function&lt;&gt;</code> template you need to supply information about the return type, and the types of any parameters, to a lambda expression. Here’s how you could create an object of type <code class="calibre23">function</code> that can wrap a function object that has one parameter of type <code class="calibre23">double</code> and returns a value of type <code class="calibre23">int</code>:</p>
<pre class="calibre28"><code class="calibre23">std::function&lt;int(double)&gt; f = [](double x)-&gt;int{ return static_cast&lt;int&gt;(x*x); };</code></pre>
<p class="calibre13">The type specification for the function template is the return type for the function object to be wrapped, followed by its parameter types between parentheses, and separated by commas. Let’s try a working example that uses the basic capability that is built into the C++ language as well as the <code class="calibre23">function&lt;T&gt;</code> template.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: Recursion in a Lambda Expression</h3>
<p class="calibre20">This example will find the highest common factor (HCF) for a pair of integer values. The HCF is the largest number that will divide exactly into both integers. The HCF is also called the greatest common divisor (GCD). Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">// Ex10_16.cpp Wrapping a lambda expression
#include &lt;iostream&gt;
#include &lt;functional&gt;
 
// Global wrapper for lambda expression computing HCF
std::function&lt;long long(long long,long long)&gt; hcf = 
                            [&amp;](long long m, long long n) mutable -&gt;long long{
                                   if(m &lt; n) return hcf(n,m);
                                   long long remainder {m%n};
                                   if(0 == remainder) return n;
                                   return hcf(n, remainder);};
int main()
{
  // A lambda expression assigned to a function pointer
  // that outputs the highest common factor of the arguments
  auto showHCF = [](long long a, long long b) {
  std::cout &lt;&lt; "For numbers " &lt;&lt; a &lt;&lt; " and " &lt;&lt; b
            &lt;&lt; " the highest common factor is " &lt;&lt; hcf(a, b) &lt;&lt; std::endl;
  };
  long long a {17719LL}, b {18879LL};
  showHCF(a,b);
  showHCF(103LL*53*17*97, 3LL*29*103);
  showHCF(53LL*941*557*43*29*229, 83LL*89*941*11*17*863*431);
}</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="576" id="calibre_link-1038" class="calibre14"></span>This produces the output:</p>
<pre class="calibre28"><code class="calibre23">For numbers 17719 and 18879 the highest common factor is 29
For numbers 9001891 and 8961 the highest common factor is 103
For numbers 7932729108943 and 483489887381237 the highest common factor is 941</code></pre>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">You define a wrapper with the name <code class="calibre23">hcf</code> for a lambda expression that calculates the HCF at global scope:</p>
<pre class="calibre28"><code class="calibre23">std::function&lt;long long(long long,long long)&gt; hcf = 
                            [&amp;](long long m, long long n) mutable -&gt;long long{
                                   if(m &lt; n) return hcf(n,m);
                                   long long remainder {m%n};
                                   if(0 == remainder) return n;
                                   return hcf(n, remainder);};</code></pre>
<p class="calibre20">The lambda needs to refer to <code class="calibre23">hcf</code> in order to work, and because this is defined outside the scope of the lambda, you cannot use a regular function pointer for <code class="calibre23">hcf</code>.</p>
<p class="calibre20">The lambda expression has two parameters of type <code class="calibre23">long long</code> and returns a value of type <code class="calibre23">long long</code>, so <code class="calibre23">hcf</code> is of type:</p>
<p class="calibre20"><code class="calibre23">function&lt;long long(long long, long long)&gt;</code></p>
<p class="calibre20">The lambda expression uses Euclid’s method for finding the highest common factor for two integer values. This involves dividing the larger number by the smaller number, and if the remainder is zero, the HCF is the smaller number. If the remainder is non-zero, the process continues by dividing the previous smaller number by the remainder, and this is repeated until the remainder is zero.</p>
<p class="calibre20">The code for the lambda expression assumes <code class="calibre23">m</code> is the larger of the two numbers that are passed as arguments, so if it isn’t, it calls <code class="calibre23">hcf()</code> with the arguments reversed. If the first argument is the larger number, the remainder after dividing <code class="calibre23">m</code> by <code class="calibre23">n</code> is calculated. If the remainder is zero, then <code class="calibre23">n</code> is the highest common factor and is returned. If the remainder is not zero, <code class="calibre23">hcf()</code> is called with <code class="calibre23">n</code> and the remainder.</p>
<p class="calibre20">The first statement in <code class="calibre23">main()</code> assigns a stateless lambda to the <code class="calibre23">showHCF</code> pointer:</p>
<pre class="calibre28"><code class="calibre23">  auto showHCF = [](long long a, long long b) {
  std::cout &lt;&lt; "For numbers " &lt;&lt; a &lt;&lt; " and " &lt;&lt; b
            &lt;&lt; " the highest common factor is " &lt;&lt; hcf(a, b) &lt;&lt; std::endl;
  };</code></pre>
<p class="calibre20">This lambda outputs the values for which the HCF is requested together with the HCF produced using the <code class="calibre23">hcf</code> object. The rest of <code class="calibre23">main()</code> calls this lambda through the <code class="calibre23">showHCF</code> function pointer three times to produce the results that you see. The results show that the lambda pointed to by <code class="calibre23">hcf</code> does indeed produce the highest common factor for its arguments.</p>
<p class="calibre20">You can use the <code class="calibre23">function&lt;&gt;</code> class template to specify the type for a function parameter. This enables you to define a function with a parameter for which you can supply an argument that can be a function object, a lambda expression, or a normal function pointer.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-333" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="577" id="calibre_link-1039" class="calibre18"></span>SUMMARY</h2>
<p class="calibre13">This chapter introduced the capabilities of the STL. My objective in this chapter was to introduce enough of the details of the STL to enable you to explore the rest on your own. Even though this is a substantial chapter, I have barely scratched the surface of the STL’s capabilities so I would encourage you to explore it further.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Write a program that will read some text from the standard input stream, possibly involving several lines of input, and store the letters from the text in a <code class="calibre23">list&lt;T&gt;</code> container. Sort the letters in ascending sequence and output them.</li>
<li class="calibre6">Use a <code class="calibre23">priority_queue&lt;T&gt;</code> container to achieve the same result as in Exercise 1.</li>
<li class="calibre6">Modify <code class="calibre23">Ex10_12.cpp</code> so that it allows multiple phone numbers to be stored for a given name. The functionality in the program should reflect this: The <code class="calibre23">getEntry()</code> function should display all numbers for a given name, and the <code class="calibre23">deleteEntry()</code> function should delete a particular person/number combination.</li>
<li class="calibre6">Write a program to implement a phone book capability that will allow a name to be entered to retrieve one or more numbers, or a number to be entered to retrieve a name.</li>
<li class="calibre6">As you know, the Fibonacci series consists of the sequence of integers 0, 1, 1, 2, 3, 5, 8, 13, 21, ... where each integer after the first two is the sum of the two preceding integers (note the series sometimes omits the initial zero). Write a program that uses a lambda expression to initialize a vector of integers with values from the Fibonacci series.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="578" id="calibre_link-1040" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Standard Template Library</b></td>
<td class="calibre32">The STL includes templates for containers, iterators, algorithms, and function objects.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Containers</b></td>
<td class="calibre32">A container is a class object for storing and organizing other objects. Sequence containers store objects in a sequence, like an array. Associative containers store elements that are key/object pairs, where the key determines where the pair is stored in the container.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Iterators</b></td>
<td class="calibre32">Iterators are objects that behave like pointers. Iterators are used in pairs to define a set of objects by a semi-open interval, where the first iterator points to the first object in the series, and the second iterator points to a position one past the last object in the series.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Stream iterators</b></td>
<td class="calibre32">Stream iterators are iterators that allow you to access or modify the contents of a stream.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Iterator categories</b></td>
<td class="calibre32">There are four categories of iterators: input and output iterators, forward iterators, bidirectional iterators, and random access iterators. Each successive category of iterator provides more functionality than the previous one; thus, input and output iterators provide the least functionality, and random access iterators provide the most.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Smart pointers</b></td>
<td class="calibre32">Smart pointers are objects of template class types that encapsulate raw pointers. By using smart pointers instead of raw pointers you can often avoid the need to worry about deleting objects that you have allocated on the heap and thus avoid the risk of memory leaks.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Algorithms</b></td>
<td class="calibre32">Algorithms are template functions that operate on a sequence of objects specified by a pair of iterators.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Function objects</b></td>
<td class="calibre32">Function objects are objects of a type that overloads the <code class="calibre23">()</code> operator (by implementing <code class="calibre23">operator()()</code> in the class). The STL defines a wide range of standard function objects for use with containers and algorithms; you can also write your own classes to define function objects.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Lambda expressions</b></td>
<td class="calibre32">A lambda expression defines an anonymous function object without the need to explicitly define a class type. You can use a lambda expression as an argument to STL algorithms that expect a function object as an argument.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Stateless lambda expressions</b></td>
<td class="calibre32">A stateless lambda expression does not refer to any variables in an enclosing scope. You can store a pointer to a stateless lambda expression in a function pointer.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Polymorphic function wrappers</b></td>
<td class="calibre32">A polymorphic function wrapper is an instance of the <code class="calibre23">function&lt;&gt;</code> template that you can use to wrap a function object. You can also use a polymorphic function wrapper to wrap a lambda expression.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-20">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2324" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="579" id="calibre_link-1041" class="calibre9"></span><span class="chapternumber">Chapter 11</span><br class="calibre10" /><span class="chapternumber">Windows Programming Concepts</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The basic structure of a window</li>
<li class="calibre6">The Windows API and how it is used</li>
<li class="calibre6">Windows messages and how you deal with them</li>
<li class="calibre6">The notation that is commonly used in Windows programs</li>
<li class="calibre6">The basic structure of a Windows program</li>
<li class="calibre6">How you create an elementary program using the Windows API and how it works</li>
<li class="calibre6">Microsoft Foundation Classes</li>
<li class="calibre6">The basic elements of an MFC-based program</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 11 download and individually named according to the names throughout the chapter.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="580" id="calibre_link-1042" class="calibre14"></span>This chapter will take you on a tour of the basic ideas that are involved in every Windows program in C++. You’ll first develop a simple example that uses the Windows operating system API directly. This will enable you to understand how a Windows application works behind the scenes, which will be useful when you are developing applications using the more sophisticated facilities provided by Visual C++. Next you will see what you get when you create a Windows program using the Microsoft Foundation Classes (MFC) that encapsulates Win32 capabilities.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-334" class="calibre3"></a>WINDOWS PROGRAMMING BASICS</h2>
<p class="calibre13">The Windows API is referred to as <i class="calibre15">WinAPI</i> or <i class="calibre15">Win32</i>, the latter being a slightly dated term since the availability of 64-bit versions of Windows. When you are developing an application with the Windows API, you are writing code at a relatively low level throughout &mdash; all the elements that make up the GUI for your application must be created programmatically by calling operating system functions. With MFC applications you are using a set of standard classes that insulate you from the Windows API and make coding much easier. There’s also some help with GUI creation in that you can assemble controls on a dialog form graphically and just program the interactions with the user; however, you are still involved in a lot of coding.</p>
<p class="calibre13">Using the Windows API directly is the most laborious method for developing an application so I won’t go into this in detail. However, you will put together a basic Windows API application so you’ll have an opportunity to understand the mechanism that all Windows applications use under the covers to work with the operating system. Of course, it also is possible to develop applications in C++ that do not require the Windows operating system, and games sometimes take this approach. Many games use DirectX, which is a Windows specific graphics library. Although this is an interesting topic, it would require a whole book to do it justice, so I won’t pursue it further.</p>
<p class="calibre13">Before getting to the examples I’ll review the terminology that is used to describe an application window. You have already created a Windows program in Chapter 1 without writing a single line of code yourself, and I’ll use the window generated by this example to illustrate the elements that go to make up a window.</p>
<section class="toclist">
<h3 class="calibre21">Elements of a Window</h3>
<p class="calibre13">You will inevitably be familiar with most, if not all, of the principal elements of the user interface to a Windows program. However, I will go through them anyway just to be sure we have a common understanding of what the terms mean. The best way to understand what the elements of a window can be is to look at one. An annotated version of the window displayed by the example that you saw in Chapter 1 is shown in <a id="calibre_link-22" href="#calibre_link-21" class="calibre3">Figure 11-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000140.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-21" href="#calibre_link-22" class="calibre3">FIGURE 11-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="581" id="calibre_link-1043" class="calibre14"></span>The example generated two windows. The larger window with the menu and the toolbars is the main application window, or <i class="calibre15">parent window</i>, and the smaller window is a <i class="calibre15">child window</i> of the parent. The child window can be closed without closing the parent window by double-clicking the title bar icon that is in the upper-left corner of the child window or by clicking the Close button in the upper-right corner of the child window. Closing the parent window automatically closes the child window. This is because the child window is owned by and dependent upon the parent window. In general, a parent window may have a number of child windows, as you’ll see.</p>
<p class="calibre13">The most fundamental parts of a typical window are its <i class="calibre15">border</i>, the <i class="calibre15">title bar</i> that shows the name that you give to the window, the <i class="calibre15">title bar icon</i> that appears at the left end of the title bar, and the <i class="calibre15">client area</i>, which is the area in the center of the window not used by the title bar or borders. You can get all of these created for free in a Windows program. As you will see, all you have to do is provide some text for the title bar.</p>
<p class="calibre13">The border defines the boundary of a window and may be fixed or resizable. If the border is resizable, you can drag it to alter the size of the window. The window also may possess a size grip, which you can use to alter the size of a window. When you define a window, you can modify how the border behaves and appears if you want. Most windows will also have the maximize, minimize, and close buttons in the upper-right corner of the window. These allow the window to be increased to full screen size, reduced to an icon, or closed.</p>
<p class="calibre13">When you click the title bar icon, it provides a standard menu for altering or closing the window called the <i class="calibre15">system menu</i> or <i class="calibre15">control menu</i>. The system menu also appears when you right-click the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="582" id="calibre_link-1044" class="calibre14"></span>title bar of a window. Although it’s optional, it is always a good idea to include the title bar icon in any main windows that your program generates. Including the title bar icon provides you with a very convenient way of closing the program when things don’t work during debugging, which is the process by which you find and eliminate errors in your code.</p>
<p class="calibre13">The client area is the part of the window where you usually want your program to write text or graphics. You can address the client area for this purpose in exactly the same way as the yard that you saw in <a href="#calibre_link-23" class="calibre3">Figure 7-1</a>, in Chapter 7. The upper-left corner of the client area has the coordinates (0, 0), with x increasing from left to right, and y increasing from top to bottom.</p>
<p class="calibre13">The menu bar is optional in a window but is probably the most common way to control an application. Each menu in the menu bar displays a drop-down list of menu items when you click it. The contents of a menu and the physical appearance of many objects that are displayed in a window, such as the icons on the toolbar that appear in <a href="#calibre_link-21" class="calibre3">Figure 11-1</a>, the cursor, and many others, are defined by a <i class="calibre15">resource file</i>. You will see many more resource files when we get to write some more sophisticated Windows programs.</p>
<p class="calibre13">A ribbon is an alternative to the menu bar. The latest editions of Microsoft Word and Microsoft Excel provide a ribbon as the primary mechanism for navigating around application functions. The MFC provides an extensive set of classes for creating a ribbon but I don’t have the space to go into these.</p>
<p class="calibre13">The toolbar provides a set of icons that usually act as alternatives to the menu options that you use most often. Because they give a pictorial clue to the function provided, they can often make a program easier and faster to use.</p>
<p class="calibre13">I’ll mention a caveat about terminology that you need to be conscious of. Users tend to think of a window as the thing that appears on the screen with a border around it, and, of course, it is, but it is only one kind of window. In Windows a window is a generic term covering a whole range of entities. Many entities that are displayed are windows &mdash; for example, a dialog is a window and each toolbar and dockable menu bar are also windows. I will generally use terminology to refer to objects that describe what they are, buttons, dialogs, and so on, but you need to have tucked in the back of your mind that many of them are windows too, because you can do things to them that you can do with a regular window &mdash; you can draw on a button, for instance.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Windows Programs and the Operating System</h3>
<p class="calibre13">When you write a Windows program, your program is subservient to the operating system and Windows is in control. Your program cannot deal directly with the hardware, and all communications with the outside world must pass through Windows. When you use a Windows program, you are interacting primarily with Windows, which then communicates with the application program on your behalf. Your Windows program is the tail, Windows is the dog, and your program wags only when Windows tells it to.</p>
<p class="calibre13">There are a number of reasons why this is so. First and foremost, because your program is potentially always sharing the computer with other programs that may be executing at the same time, Windows has to have primary control to manage the sharing of machine resources. If one application were allowed to have primary control in a Windows environment, this would inevitably make programming more complicated because of the need to provide for the possibility of other <span {http://www.idpf.org/2007/ops}type="pagebreak" title="583" id="calibre_link-1045" class="calibre14"></span>programs, and information intended for other applications could be lost. A second reason is that Windows embodies a standard user interface and needs to be in charge to enforce that standard. You can only display information on the screen using the tools that Windows provides, and then only when authorized.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Event-Driven Programs</h3>
<p class="calibre13">You have already seen in Chapter 1 that a Windows program is <i class="calibre15">event-driven</i>, so a Windows program essentially waits around for something to happen. A significant part of the code for a Windows application is dedicated to processing events that are caused by external actions of the user, but activities that are not directly associated with your application can nonetheless require that bits of your program code are executed. For example, if the operating system determines that your application window needs to be redrawn because it is no longer valid, it will send a message to you application to signal that your application must redraw the part of the application window that has been exposed.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Windows Messages</h3>
<p class="calibre13">Events in a Windows application are occurrences such as the user clicking the mouse or pressing a key, or a timer reaching zero. The Windows operating system records each event in a <i class="calibre15">message</i> and places the message in a <i class="calibre15">message queue</i> for the program for which the message is intended. A Windows message is simply a record of the data relating to an event, and the message queue for an application is just a sequence of such messages waiting to be processed. By sending a message, Windows can tell your program that something needs to be done, or that some information has become available, or that an event such as a mouse click has occurred. If your program is properly organized, it will respond in the appropriate way to the message. There are many different kinds of messages and they can occur very frequently &mdash; several times per second when the mouse is being dragged for example.</p>
<p class="calibre13">A Windows program must contain a function specifically for handling these messages. The function is often called <code class="calibre23">WndProc()</code> or <code class="calibre23">WindowProc()</code>, although it doesn’t have to have a particular name because Windows accesses the function through a pointer to a function that you supply. So the sending of a message to your program boils down to Windows calling a function that you provide that is typically called <code class="calibre23">WindowProc()</code>, and passing any necessary data to your program by means of arguments to this function. Within your <code class="calibre23">WindowProc()</code> function, it is up to you to work out what the message is from the data supplied and decide what to do about it.</p>
<p class="calibre13">Fortunately, you don’t need to write code to process every message that Windows sends to your application. You can filter out those that are of interest, deal with those in whatever way you want, and pass the rest back to Windows. You pass a message back to Windows by calling a standard function called <code class="calibre23">DefWindowProc()</code>, which provides default message processing.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Windows API</h3>
<p class="calibre13">All of the communications between a Windows application and Windows itself use the Windows application programming interface, otherwise known as the <i class="calibre15">Windows API</i>. This consists of literally hundreds of functions that come as a standard with the Windows operating system that <span {http://www.idpf.org/2007/ops}type="pagebreak" title="584" id="calibre_link-1046" class="calibre14"></span>provide the means by which an application communicates with Windows, and vice versa. The Windows API was developed in the days when C was the primary language in use, long before the advent of C++, and for this reason structures rather than classes are frequently used for passing data between Windows and your application program.</p>
<p class="calibre13">The Windows API covers all aspects of the communications between Windows and your application. Because there is such a large number of functions in the API, using them in the raw can be very difficult &mdash; just understanding what they all are is a task in itself. This is where Visual C++ makes the life of the application developer very much easier. Visual C++ packages the Windows API in a way that structures the functions in an object-oriented manner, and provides an easier way to use the interface in C++ with more default functionality. This takes the form of the Microsoft Foundation Classes, MFC.</p>
<p class="calibre13">Visual C++ also provides Application Wizards that create basic applications of various kinds, including MFC applications. The Application Wizard can generate a complete working application that includes all of the boilerplate code necessary for a basic Windows application, leaving you just to customize this for your particular purposes. The example in Chapter 1 illustrated how much functionality Visual C++ is capable of providing without any coding effort at all on your part. I will discuss this in more detail when we get to write some more examples using the Application Wizard.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Windows Data Types</h3>
<p class="calibre13">Windows defines a significant number of data types that are used to specify function parameter types and return types in the Windows API. These Windows-specific types also propagate through to functions that are defined in MFC. Each of these Windows types will map to some C++ type, but because the mapping between Windows types and C++ types can change over time, you should always use the Windows type where this applies. For example, in the past the Windows type <code class="calibre23">WORD</code> has been defined in one version of Windows as type <code class="calibre23">unsigned short</code> and in another Windows version as type <code class="calibre23">unsigned int</code>. On 16-bit machines these types are equivalent, but on 32-bit machines they are decidedly different so anyone using the C++ type rather than the Windows type could run into problems.</p>
<p class="calibre13">You can find the complete list of Windows data types in the documentation, but here are a few of the most common you are likely to meet:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">BOOL</code> or <code class="calibre23">BOOLEAN</code></td>
<td class="calibre32">A Boolean variable can have the values <code class="calibre23">TRUE</code> or <code class="calibre23">FALSE</code>. Note that this is not the same as the C++ type <code class="calibre23">bool</code>, which can have the values <code class="calibre23">true</code> or <code class="calibre23">false</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">BYTE</code></td>
<td class="calibre32">An 8-bit byte.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CHAR</code></td>
<td class="calibre32">An 8-bit character.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">DWORD</code></td>
<td class="calibre32">A 32-bit unsigned integer that corresponds to type <code class="calibre23">unsigned long</code> in C++.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HANDLE</code></td>
<td class="calibre32">A handle to an object &mdash; a handle being a 32-bit integer value that records the location of an object in memory, or 64-bit when compiling for 64-bit.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="585" id="calibre_link-1047" class="calibre14"></span><code class="calibre23">HBRUSH</code></td>
<td class="calibre32">A handle to a brush, a brush being used to fill an area with color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HCURSOR</code></td>
<td class="calibre32">A handle to a cursor.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HDC</code></td>
<td class="calibre32">Handle to a device context &mdash; a device context being an object that enables you to draw on a window.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HINSTANCE</code></td>
<td class="calibre32">Handle to an instance.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPARAM</code></td>
<td class="calibre32">A message parameter.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPCTSTR</code></td>
<td class="calibre32"><code class="calibre23">LPCWSTR</code> if <code class="calibre23">_UNICODE</code> is defined, otherwise <code class="calibre23">LPCSTR</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPCWSTR</code></td>
<td class="calibre32">A pointer to a constant null-terminated string of 16-bit characters.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPCSTR</code></td>
<td class="calibre32">A pointer to a constant null-terminated string of 8-bit characters.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPHANDLE</code></td>
<td class="calibre32">A pointer to a handle.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LRESULT</code></td>
<td class="calibre32">A signed value that results from processing a message.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WORD</code></td>
<td class="calibre32">A 16-bit unsigned integer, so it corresponds to type <code class="calibre23">unsigned short</code> in C++.</td>
</tr>
</tbody>
</table>
<p class="calibre13">I’ll introduce any other Windows types we are using in examples as the need arises. All Windows types and the prototypes of the Windows API functions are contained in the header file <code class="calibre23">windows.h</code>, so you need to include this header file when you put your basic Windows program together.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Notation in Windows Programs</h3>
<p class="calibre13">In many Windows programs, variable names have a prefix, which indicates what kind of value the variable holds and how it is used. There are quite a few prefixes and they are often used in combination. For example, the prefix <code class="calibre23">lpfn</code> signifies a long pointer to a function. A sample of the prefixes you might come across is:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">PREFIX</b></th>
<th class="calibre32"><b class="calibre12">MEANING</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">b</td>
<td class="calibre32">a logical variable of type <code class="calibre23">BOOL</code>, equivalent to <code class="calibre23">int</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32">by</td>
<td class="calibre32">type <code class="calibre23">unsigned char</code>; a <b class="calibre12">by</b>te</td>
</tr>
<tr class="calibre31">
<td class="calibre32">c</td>
<td class="calibre32">type <code class="calibre23">char</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32">dw</td>
<td class="calibre32">type <code class="calibre23">DWORD</code>, which is <code class="calibre23">unsigned long</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32">fn</td>
<td class="calibre32">a <b class="calibre12">f</b>unctio<b class="calibre12">n</b></td>
</tr>
<tr class="calibre31">
<td class="calibre32">h</td>
<td class="calibre32"><b class="calibre12">a h</b>andle, used to reference something</td>
</tr>
<tr class="calibre31">
<td class="calibre32">i</td>
<td class="calibre32">type <code class="calibre23">int</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="586" id="calibre_link-1048" class="calibre14"></span>l</td>
<td class="calibre32">type <code class="calibre23">long</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32">lp</td>
<td class="calibre32"><code class="calibre23">long</code> <b class="calibre12">p</b>ointer</td>
</tr>
<tr class="calibre31">
<td class="calibre32">n</td>
<td class="calibre32">type <code class="calibre23">unsigned int</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32">p</td>
<td class="calibre32">a <b class="calibre12">p</b>ointer</td>
</tr>
<tr class="calibre31">
<td class="calibre32">s</td>
<td class="calibre32">a string</td>
</tr>
<tr class="calibre31">
<td class="calibre32">sz</td>
<td class="calibre32">a zero terminated string</td>
</tr>
<tr class="calibre31">
<td class="calibre32">w</td>
<td class="calibre32">type <code class="calibre23">WORD</code>, which is <code class="calibre23">unsigned short</code></td>
</tr>
</tbody>
</table>
<p class="calibre13">The use of these prefixes is called <i class="calibre15">Hungarian notation</i>. It was introduced to minimize the possibility of misusing a variable by interpreting it differently from how it was defined or intended to be used. Such misinterpretation is easily done in the C language. With C++ and its stronger type checking you don’t need to make such a special effort with your notation to avoid such problems. The compiler always flags an error for type inconsistencies in your program, and many of the kinds of bugs that plagued earlier C programs can’t occur with C++.</p>
<p class="calibre13">On the other hand, Hungarian notation can still help to make programs easier to understand, particularly when you are dealing with a lot of variables of different types that are arguments to Windows API functions. Because Windows programs are still written in C, and, of course, because parameters for Windows API functions are still defined using Hungarian notation, the method is still used quite widely.</p>
<p class="calibre13">You can make up your own mind as to the extent to which you want to use Hungarian notation, as it is by no means obligatory. You may choose not to use it at all, but in any event, if you have an idea of how it works, you will find it easier to understand what the arguments to the Windows API functions are. There is a small caveat, however. As Windows has developed, the types of some of the API function arguments have changed slightly, but the variable names that are used remain the same. As a consequence, the prefix may not be quite correct in specifying the variable type.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-335" class="calibre3"></a>THE STRUCTURE OF A WINDOWS PROGRAM</h2>
<p class="calibre13">For a minimal Windows program that just uses the Windows API, you will write two functions. These are a <code class="calibre23">WinMain()</code> function, where execution of the program begins and basic program initialization is carried out, and a <code class="calibre23">WindowProc()</code> function that is called by Windows to pass messages to the application. The <code class="calibre23">WindowProc()</code> part of a Windows program is usually the larger portion because this is where most of the application-specific code is, responding to messages caused by user input of one kind or another.</p>
<p class="calibre13">Although these two functions make up a complete program, they are not directly connected. <code class="calibre23">WinMain()</code> does not call <code class="calibre23">WindowProc()</code>, Windows does. Windows also calls <code class="calibre23">WinMain()</code>. This is illustrated in <a id="calibre_link-25" href="#calibre_link-24" class="calibre3">Figure 11-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000093.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-24" href="#calibre_link-25" class="calibre3">FIGURE 11-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="587" id="calibre_link-1049" class="calibre14"></span>The <code class="calibre23">WinMain()</code> function communicates with Windows by calling Windows API functions. The same applies to <code class="calibre23">WindowProc()</code>. The integrating factor in your Windows desktop application is Windows itself, which links to both <code class="calibre23">WinMain()</code> and <code class="calibre23">WindowProc()</code>. After looking into what the pieces are that make up <code class="calibre23">WinMain()</code> and <code class="calibre23">WindowProc()</code> you will assemble them into a working example of a simple Windows program.</p>
<section class="toclist">
<h3 class="calibre21">The WinMain() Function</h3>
<p class="calibre13">The <code class="calibre23">WinMain()</code> function is the equivalent of <code class="calibre23">main()</code> in a console program. It’s where execution starts and where the basic initialization for the program is carried out. To allow Windows to pass data to it, <code class="calibre23">WinMain()</code> has four parameters and a return value of type <code class="calibre23">int</code>. Its prototype is:</p>
<pre class="calibre28"><code class="calibre23">int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow
                  );</code></pre>
<p class="calibre13">Following the return type specifier, <code class="calibre23">int</code>, you have a specification for the function, <code class="calibre23">WINAPI</code>. This is a Windows-defined macro that causes the function name and arguments to be handled in a special way that is specific to Windows API functions. This is different from the way functions are normally handled in C++. The precise details are unimportant &mdash; this is simply the way Windows requires things to be, so you need to put the <code class="calibre23">WINAPI</code> macro name in front of the names of functions called by Windows.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">If you really want to know about calling conventions, they are described in the documentation that comes with Visual C++</i>. <code class="calibre23">WINAPI</code> <i class="calibre15">is defined as</i> <code class="calibre23">__stdcall</code>, <i class="calibre15">and putting this modifier before a function name indicates that the standard Windows calling convention is to be used. This requires that the parameters are pushed on the stack in reverse order and that the function that is called will clean up the stack when it ends. The</i> <code class="calibre23">CALLBACK</code> <i class="calibre15">modifier that you will see later in this chapter is also defined as</i> <code class="calibre23">__stdcall</code> <i class="calibre15">and is therefore the equivalent of</i> <code class="calibre23">WINAPI</code>. <i class="calibre15">The standard C++ calling convention is specified by the</i> <code class="calibre23">__cdecl</code> <i class="calibre15">modifier.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="588" id="calibre_link-1050" class="calibre14"></span>The four arguments that are passed to your <code class="calibre23">WinMain()</code> function contain important data:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">hInstance</code> is of type <code class="calibre23">HINSTANCE</code>, which is a handle to an instance &mdash; an instance here being a running program. A <i class="calibre15">handle</i> is an integer value that identifies an object of some kind &mdash; in this case, the instance of the application. The actual integer value of a handle is not important. There can be several programs in execution at any given instant. This raises the possibility of several copies of the same application being active at once, and this needs to be recognized. Hence, the <code class="calibre23">hInstance</code> handle identifies a particular copy. If you start more than one copy of a program, each one has its own unique <code class="calibre23">hInstance</code> value. As you will see, handles are used to identify all sorts of other things.</li>
<li class="calibre6"><code class="calibre23">hPrevInstance</code> is a legacy from the old 16-bit versions of the Windows operating system, and you can safely ignore it. On current versions of Windows, it is always <code class="calibre23">nullptr</code>.</li>
<li class="calibre6"><code class="calibre23">lpCmdLine</code> is a pointer to a string containing the command line that started the program. This pointer allows you to pick up any parameter values that may appear in the command line. The type <code class="calibre23">LPSTR</code> is another Windows type, specifying a 32-bit (long) pointer to a string, or 64-bit when compiling in 64-bit mode. There is also a version of <code class="calibre23">WinMain()</code> that accepts <code class="calibre23">LPWSTR</code> for Unicode builds.</li>
<li class="calibre6"><code class="calibre23">nCmdShow</code> determines how the window is to look when it is created. It could be displayed normally or it might need to be minimized; for example, if the shortcut for the program specifies that the program should be minimized when it starts. This argument can take one of a fixed set of <code class="calibre23">int</code> values that are defined by symbolic constants such as <code class="calibre23">SW_SHOWNORMAL</code> and <code class="calibre23">SW_SHOWMAXIMIZED</code>. There are nine other constants like these that define the way a window is to be displayed, and they all begin with <code class="calibre23">SW_</code>. You don’t usually need to examine the value of <code class="calibre23">nCmdShow</code>. You typically pass it directly to the Windows API function responsible for displaying your application window.</li>
</ul>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">If you want to know what all the constants are that specify how a window displays, you can find a complete list of the possible values if you search for</i> <code class="calibre23">WinMain</code> <i class="calibre15">in the MSDN Library. You can access the MSDN library online at</i> <a href="http://msdn.microsoft.com/en-us/library/default.aspx" class="calibre3">http://msdn.microsoft.com/en-us/library/default.aspx</a>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The <code class="calibre23">WinMain()</code> function in your program needs to do four things:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Tell Windows what kind of window the program requires</li>
<li class="calibre6">Create the program window</li>
<li class="calibre6">Initialize the program window</li>
<li class="calibre6">Retrieve Windows messages intended for the program</li>
</ul>
<p class="calibre13">We will take a look at each of these in turn and then create a complete <code class="calibre23">WinMain()</code> function.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="589" id="calibre_link-1051" class="calibre14"></span>Specifying a Program Window</h4>
<p class="calibre13">The first step in creating a window is to define just what sort of window it is that you want to create. Windows defines a special <code class="calibre23">struct</code> type called <code class="calibre23">WNDCLASSEX</code> to contain the data specifying a window. The data that is stored in an instance of the <code class="calibre23">struct</code> defines a window class, which determines the type of window. You need to create a variable of type <code class="calibre23">WNDCLASSEX</code>, and give values to each of its members. After you’ve filled in the variables, you can pass it to Windows (via a function that you’ll see later) to register the class. When that’s been done, whenever you want to create a window of that class, you can tell Windows to look up the class that you have already registered.</p>
<p class="calibre13">The definition of the <code class="calibre23">WNDCLASSEX</code> structure is:</p>
<pre class="calibre28"><code class="calibre23">struct WNDCLASSEX
{
  UINT cbSize;            // Size of this object in bytes
  UINT style;             // Window style
  WNDPROC lpfnWndProc;    // Pointer to message processing function
  int cbClsExtra;         // Extra bytes after the window class
  int cbWndExtra;         // Extra bytes after the window instance
  HINSTANCE hInstance;    // The application instance handle
  HICON hIcon;            // The application icon
  HCURSOR hCursor;        // The window cursor
  HBRUSH hbrBackground;   // The brush defining the background color
  LPCTSTR lpszMenuName;   // A pointer to the name of the menu resource
  LPCTSTR lpszClassName;  // A pointer to the class name
  HICON hIconSm;          // A small icon associated with the window
};</code></pre>
<p class="calibre13">You construct an object of type <code class="calibre23">WNDCLASSEX</code> in the way that you saw when I discussed structures, for example:</p>
<pre class="calibre28"><code class="calibre23">WNDCLASSEX WindowClass;                // Create a window class object</code></pre>
<p class="calibre13">You can now fill in values for the members of <code class="calibre23">WindowClass</code>. They are all <code class="calibre23">public</code> by default because <code class="calibre23">WindowClass</code> is a <code class="calibre23">struct</code>. Setting the value for the <code class="calibre23">cbSize</code> member of the <code class="calibre23">struct</code> is easy when you use the <code class="calibre23">sizeof</code> operator:</p>
<pre class="calibre28"><code class="calibre23">WindowClass.cbSize = sizeof(WNDCLASSEX);</code></pre>
<p class="calibre13">The <code class="calibre23">style</code> member of the <code class="calibre23">struct</code> determines various aspects of the window’s behavior, in particular, the conditions under which the window should be redrawn. You can select from a number of options for this member’s value, each defined by a symbolic constant beginning with <code class="calibre23">CS_</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You’ll find all the possible constant values for style if you search for “Window Class Styles” in the MSDN Library that you’ll find at</i> <a href="http://msdn.microsoft.com/en-us/library/default.aspx" class="calibre3">http://msdn.microsoft.com/en-us/library/default.aspx</a>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="590" id="calibre_link-1052" class="calibre14"></span>Where two or more options are required, the constants can be combined to produce a composite value using the bitwise OR operator, <code class="calibre23">|</code>. For example:</p>
<pre class="calibre28"><code class="calibre23">WindowClass.style = CS_HREDRAW | CS_VREDRAW;</code></pre>
<p class="calibre13">The option <code class="calibre23">CS_HREDRAW</code> indicates to Windows that the window is to be redrawn if its horizontal width is altered, and <code class="calibre23">CS_VREDRAW</code> indicates that it is to be redrawn if the vertical height of the window is changed. In the preceding statement, you have elected to have the window redrawn in either case. As a result, Windows sends a message to your program indicating that you should redraw the window whenever the width or height of the window is altered by the user. Each of the possible options for the window style is defined by a unique bit in a 32-bit word being set to 1. That’s why the bitwise OR is used to combine them. These bits indicating a particular style are usually called <i class="calibre15">flags</i>. Flags are used very frequently, not only in Windows but also in C++, because they are an efficient way of representing and processing features that are either there or not, or parameters that are either true or false.</p>
<p class="calibre13">The member <code class="calibre23">lpfnWndProc</code> stores a pointer to the function in your program that handles messages for the window you create. The prefix to the name signifies that this is a <code class="calibre23">long</code> pointer to a function. If you followed the herd and called the function to handle messages for the application <code class="calibre23">WindowProc()</code>, you would initialize this member with the statement:</p>
<pre class="calibre28"><code class="calibre23">WindowClass.lpfnWndProc = WindowProc;</code></pre>
<p class="calibre13">The next two members, <code class="calibre23">cbClsExtra</code> and <code class="calibre23">cbWndExtra</code>, allow you to ask that extra space be provided internally to Windows for your own use. An example of this could be when you want to associate additional data with each instance of a window to assist in message handling for each window instance. Normally you won’t need extra space allocated for you, in which case you set the <code class="calibre23">cbClsExtra</code> and <code class="calibre23">cbWndExtra</code> members to zero.</p>
<p class="calibre13">The <code class="calibre23">hInstance</code> member holds the handle for the current application instance, so you should set this to the <code class="calibre23">hInstance</code> value that was passed to <code class="calibre23">WinMain()</code> by Windows:</p>
<pre class="calibre28"><code class="calibre23">WindowClass.hInstance = hInstance;</code></pre>
<p class="calibre13">The members <code class="calibre23">hIcon, hCursor</code>, and <code class="calibre23">hbrBackground</code> are handles that in turn reference objects that represent:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The application when minimized</li>
<li class="calibre6">The cursor the window uses</li>
<li class="calibre6">The background color of the client area of the window</li>
</ul>
<p class="calibre13">As you saw earlier, a handle is just a 32-bit integer (or 64-bit when compiled in 64-bit mode) used as an ID to represent something. These members are set using Windows API functions. For example:</p>
<pre class="calibre28"><code class="calibre23">WindowClass.hIcon = LoadIcon(nullptr, IDI_APPLICATION); 
WindowClass.hCursor = LoadCursor(nullptr, IDC_ARROW); 
WindowClass.hbrBackground = static_cast&lt;HBRUSH&gt;(GetStockObject(GRAY_BRUSH));</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="591" id="calibre_link-1053" class="calibre14"></span>All three members are set to standard Windows values by these function calls. The icon is a default provided by Windows and the cursor is the standard arrow cursor used by the majority of Windows applications. A brush is a Windows object used to fill an area, in this case the client area of the window. The function <code class="calibre23">GetStockObject()</code> returns a generic type for all stock objects, so you need to cast it to type <code class="calibre23">HBRUSH</code>. In the preceding example, it returns a handle to the standard gray brush, and the background color for our window is thus set to gray. This function can also be used to obtain other standard objects for a window, such as fonts, for example. You could also set the <code class="calibre23">hIcon</code> and <code class="calibre23">hCursor</code> members to <code class="calibre23">nullptr</code>, in which case Windows would provide the default icon and cursor. If you set <code class="calibre23">hbrBackground</code> to <code class="calibre23">nullptr</code>, your program is expected to paint the window background, and messages are sent to your application whenever this becomes necessary.</p>
<p class="calibre13">The <code class="calibre23">lpszMenuName</code> member is set to the name of a resource defining the window menu, or to <code class="calibre23">nullptr</code> if there is no menu for the window:</p>
<pre class="calibre28"><code class="calibre23">WindowClass.lpszMenuName = nullptr;</code></pre>
<p class="calibre13">You will look into creating and using menu resources when you use the AppWizard.</p>
<p class="calibre13">The <code class="calibre23">lpszClassName</code> member of the <code class="calibre23">struct</code> stores the name that you supply to identify this particular class of window. You would usually use the name of the application for this. You need to keep track of this name because you will need it again when a window is created. This member would therefore be typically set with the statements:</p>
<pre class="calibre28"><code class="calibre23">static LPCTSTR szAppName {_T("OFWin")};    // Define window class name
WindowClass.lpszClassName = szAppName;     // Set class name</code></pre>
<p class="calibre13">I have defined <code class="calibre23">szAppName</code> using the <code class="calibre23">_T()</code> macro that is defined in the <code class="calibre23">tchar.h</code> header. The <code class="calibre23">LPCTSTR</code> type is defined as <code class="calibre23">const wchar_t*</code> if <code class="calibre23">UNICODE</code> is defined for the application, or <code class="calibre23">const char*</code> if it is not. The <code class="calibre23">_T()</code> macro will create a string of the correct type automatically.</p>
<p class="calibre13">The last member is <code class="calibre23">hIconSm</code>, which identifies a small icon associated with the window class. If you specify this as <code class="calibre23">nullptr</code>, Windows searches for a small icon related to the <code class="calibre23">hIcon</code> member and uses that.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Creating a Program Window</h4>
<p class="calibre13">After you have set the members of your <code class="calibre23">WNDCLASSEX</code> structure to the values required, the next step is to tell Windows about it. You do this by calling the Windows API function <code class="calibre23">RegisterClassEx()</code>. Given that your <code class="calibre23">WNDCLASSEX</code> structure object is <code class="calibre23">WindowClass</code>, the statement to do this would be:</p>
<pre class="calibre28"><code class="calibre23">RegisterClassEx(&amp;WindowClass);</code></pre>
<p class="calibre13">Easy, isn’t it? The address of the <code class="calibre23">struct</code> is passed to the function, and Windows extracts and squirrels away all the values that you have set in the structure members. This process is called <i class="calibre15">registering</i> the window class. Just to remind you, the term <i class="calibre15">class</i> here is used in the sense of classification and is not the same as the idea of a <code class="calibre23">class</code> in C++, so don’t confuse the two. Each instance of the application must make sure that it registers the window classes that it needs.</p>
<p class="calibre13">After Windows knows the characteristics of the window that you want, and the function that is going to handle messages for it, you can go ahead and create it. You call the <code class="calibre23">CreateWindow()</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="592" id="calibre_link-1054" class="calibre14"></span>function for this. The window class that you have created determines the broad characteristics of the application window, and further arguments to <code class="calibre23">CreateWindow()</code> add additional characteristics. Because an application may have several windows in general, <code class="calibre23">CreateWindow()</code> returns a handle to the window it created that you can store to enable you to refer to that particular window later. There are many API calls that require you to specify the window handle as a parameter. Let’s look at a typical use of <code class="calibre23">CreateWindow()</code>. This might be:</p>
<pre class="calibre28"><code class="calibre23">HWND hWnd;                                // Window handle
...
hWnd = CreateWindow(
        szAppName,                        // the window class name
        _T("A Basic Window the Hard Way"),// The window title
        WS_OVERLAPPEDWINDOW,              // Window style as overlapped
        CW_USEDEFAULT,                    // Default screen position of upper left
        CW_USEDEFAULT,                    // corner of our window as x,y.
        CW_USEDEFAULT,                    // Default window size, width...
        CW_USEDEFAULT,                    // ...and height
        nullptr,                          // No parent window
        nullptr,                          // No menu
        hInstance,                        // Program Instance handle
        nullptr                           // No window creation data
      );</code></pre>
<p class="calibre13">The <code class="calibre23">hWnd</code> variable of type <code class="calibre23">HWND</code> is a 32-bit integer handle to a window, or 64-bit in 64-bit mode. You use this variable to record the window handle that <code class="calibre23">CreateWindow()</code> returns. The first argument that you pass to <code class="calibre23">CreateWindow()</code> is the class name. This is used to identify the <code class="calibre23">WNDCLASSEX</code> object that you passed to the operating system previously in the <code class="calibre23">RegisterClassEx()</code> function call, so that information from this <code class="calibre23">struct</code> can be used in the window creation process.</p>
<p class="calibre13">The second argument to <code class="calibre23">CreateWindow()</code> defines the text that is to appear on the title bar. The third argument specifies the style that the window has after it is created. The option specified here, <code class="calibre23">WS_OVERLAPPEDWINDOW</code>, combines several options. It defines the window as having the <code class="calibre23">WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX</code>, and <code class="calibre23">WS_MAXIMIZEBOX</code> styles. This results in an overlapped window, which is a window intended to be the main application window, with a title bar and a thick frame, which has a title bar icon, system menu, and maximize and minimize buttons. A window that you specify as having a thick frame has borders that can be resized.</p>
<p class="calibre13">The next four arguments determine the position and size of the window on the screen. The first two are the screen coordinates of the upper-left corner of the window, and the second two define the width and height. The value <code class="calibre23">CW_USEDEFAULT</code> indicates that you want Windows to assign the default position and size for the window. This tells Windows to arrange successive windows in cascading positions down the screen. <code class="calibre23">CW_USEDEFAULT</code> only applies to windows specified as <code class="calibre23">WS_OVERLAPPED</code>.</p>
<p class="calibre13">The next argument value is <code class="calibre23">nullptr</code>, indicating that the window being created is not a child window (i.e., not a window that is dependent on a parent window). If you wanted it to be a child window, you would set this argument to the handle of the parent window. The next argument is also <code class="calibre23">nullptr</code>, indicating that no menu is required. You then specify the handle of the current instance of the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="593" id="calibre_link-1055" class="calibre14"></span>program that was passed to the program by Windows. The last argument for window creation data is <code class="calibre23">nullptr</code> because you just want a simple window in the example. If you wanted to create a multiple-document interface (MDI) client window, the last argument would point to a structure related to this. You’ll learn more about MDI windows later in the book.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The Windows API also includes a</i> <code class="calibre23">CreateWindowEx()</code> <i class="calibre15">function that you use to create a window with extended style information.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">After you call <code class="calibre23">CreateWindow()</code>, the window exists but is not yet displayed on the screen. You must call another Windows API function to get it displayed:</p>
<pre class="calibre28"><code class="calibre23">ShowWindow(hWnd, nCmdShow);             // Display the window</code></pre>
<p class="calibre13">Only two arguments are required here. The first identifies the window and is the handle returned by <code class="calibre23">CreateWindow()</code>. The second is the <code class="calibre23">nCmdShow</code> value that was passed to <code class="calibre23">WinMain()</code>, which indicates how the window is to appear on-screen.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Initializing the Program Window</h4>
<p class="calibre13">After calling <code class="calibre23">ShowWindow()</code>, the window appears on-screen but still has no application content, so you need to get your program to draw in the client area of the window. You could just put together some code to do this directly in the <code class="calibre23">WinMain()</code> function, but this would be most unsatisfactory: in this case, the contents of the client area would not be permanent &mdash; if you want the client area contents to be retained, you can’t just output what you want and forget about it. Any action on the part of the user that modifies the window in some way, such as dragging a border or dragging the whole window, typically requires that the window <i class="calibre15">and</i> its client area are redrawn.</p>
<p class="calibre13">When the client area needs to be redrawn for any reason, Windows sends a particular message to your program, and your <code class="calibre23">WindowProc()</code> function needs to respond by reconstructing the client area of the window. Therefore, the best way to get the client area drawn in the first instance is to put the code to draw the client area in the <code class="calibre23">WindowProc()</code> function and get Windows to send the message requesting that the client area be redrawn to your program. Whenever you know in your program that the window should be redrawn (when you change something, for example), you need to tell Windows to send a message back to get the window redrawn.</p>
<p class="calibre13">You can ask Windows to send your program a message to redraw the client area of the window by calling another Windows API function, <code class="calibre23">UpdateWindow()</code>. The statement to accomplish this is:</p>
<pre class="calibre28"><code class="calibre23">UpdateWindow(hWnd);                // Cause window client area to be drawn</code></pre>
<p class="calibre13">This function requires only one argument: the window handle <code class="calibre23">hWnd</code>, which identifies your particular program window. The result of the call is that Windows sends a message to your program requesting that the client area be redrawn.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="594" id="calibre_link-1056" class="calibre14"></span>Dealing with Windows Messages</h4>
<p class="calibre13">The last task that <code class="calibre23">WinMain()</code> needs to address is dealing with the messages that Windows may have queued for your application. This may seem a bit odd because I said earlier that you needed the function <code class="calibre23">WindowProc()</code> to deal with messages, but let me explain a little further.</p>
<section class="toclist">
<h5 class="calibre27">Queued and Non-Queued Messages</h5>
<p class="calibre13">I oversimplified Windows messaging when I introduced the idea. There are, in fact, two kinds of Windows messages:</p>
<p class="calibre13">There are <i class="calibre15">queued messages</i> that Windows places in a queue, and the <code class="calibre23">WinMain()</code> function must extract these messages from the queue for processing. The code in <code class="calibre23">WinMain()</code> that does this is called the <i class="calibre15">message loop</i>. Queued messages include those arising from user input from the keyboard, moving the mouse, and clicking the mouse buttons. Messages from a timer and the Windows message to request that a window be redrawn are also queued.</p>
<p class="calibre13">There are <i class="calibre15">non-queued messages</i> that result in the <code class="calibre23">WindowProc()</code> function being called directly by Windows. A lot of the non-queued messages arise as a consequence of processing queued messages. What you are doing in the message loop in <code class="calibre23">WinMain()</code> is retrieving a message that Windows has queued for your application and then asking Windows to invoke your <code class="calibre23">WindowProc()</code> function to process it. Why can’t Windows just call <code class="calibre23">WindowProc()</code> whenever necessary? Well, it could, but it just doesn’t work this way. The reasons have to do with how Windows manages multiple applications executing simultaneously.</p>
</section>
<section class="toclist">
<h5 class="calibre27">The Message Loop</h5>
<p class="calibre13">As I said, retrieving messages from the message queue is done using a standard mechanism in Windows programming called the <i class="calibre15">message pump</i> or <i class="calibre15">message loop</i>. The code for this would be:</p>
<pre class="calibre28"><code class="calibre23">MSG msg;                                     // Windows message structure
while(GetMessage(&amp;msg, nullptr, 0, 0) == TRUE)  // Get any messages
{
  TranslateMessage(&amp;msg);                   // Translate the message
  DispatchMessage(&amp;msg);                    // Dispatch the message
}</code></pre>
<p class="calibre13">This involves three steps in dealing with each message:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">GetMessage()</code> &mdash; Retrieves a message from the queue.</li>
<li class="calibre6"><code class="calibre23">TranslateMessage()</code> &mdash; Performs any conversion necessary on the message retrieved.</li>
<li class="calibre6"><code class="calibre23">DispatchMessage()</code> &mdash; Causes Windows to call the <code class="calibre23">WindowProc()</code> function in your application to deal with the message.</li>
</ul>
<p class="calibre13">The operation of <code class="calibre23">GetMessage()</code> is important because it has a significant contribution to the way Windows works with multiple applications, so we should explore it in a little more detail.</p>
<p class="calibre13">The <code class="calibre23">GetMessage()</code> function retrieves a message queued for the application window and stores information about the message in the variable <code class="calibre23">msg</code>, pointed to by the first argument. The <code class="calibre23">msg</code> variable is <span {http://www.idpf.org/2007/ops}type="pagebreak" title="595" id="calibre_link-1057" class="calibre14"></span>a <code class="calibre23">struct</code> of type <code class="calibre23">MSG</code> that contains members that you are not accessing here. Still, for completeness, the definition of the structure looks like this:</p>
<pre class="calibre28"><code class="calibre23">struct MSG
{
  HWND   hwnd;                // Handle for the relevant window
  UINT   message;             // The message ID
  WPARAM wParam;              // Message parameter (32-bits)
  LPARAM lParam;              // Message parameter (32-bits)
  DWORD  time;                // The time when the message was queued
  POINT  pt;                  // The mouse position
};</code></pre>
<p class="calibre13">The <code class="calibre23">wParam</code> member is an example of a slightly misleading Hungarian notation prefix that I mentioned is now possible. You might assume that it was of type <code class="calibre23">WORD</code> (a 16-bit <code class="calibre23">unsigned integer</code>), which used to be true in earlier Windows versions, but now it is of type <code class="calibre23">WPARAM</code>, which is a 32-bit integer value.</p>
<p class="calibre13">The exact contents of the <code class="calibre23">wParam</code> and <code class="calibre23">lParam</code> members are dependent on what kind of message it is. The message ID in the member <code class="calibre23">message</code> is an integer value and can be one of a set of values that are predefined in the header file, <code class="calibre23">windows.h</code>, as symbolic constants. Message IDs for general windows all start with <code class="calibre23">WM_</code>; typical examples are shown in the following table. General windows messages cover a wide variety of events and include messages relating to mouse and menu events, keyboard input, and window creation and management.</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">ID</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_PAINT</code></td>
<td class="calibre32">The window should be redrawn.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_SIZE</code></td>
<td class="calibre32">The window has been resized.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_LBUTTONDOWN</code></td>
<td class="calibre32">The left mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_RBUTTONDOWN</code></td>
<td class="calibre32">The right mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_MOUSEMOVE</code></td>
<td class="calibre32">The mouse has moved.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_CLOSE</code></td>
<td class="calibre32">The window or application should close.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_DESTROY</code></td>
<td class="calibre32">The window is being destroyed.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_QUIT</code></td>
<td class="calibre32">The program should be terminated.</td>
</tr>
</tbody>
</table>
<p class="calibre13">The function <code class="calibre23">GetMessage()</code> always returns <code class="calibre23">TRUE</code> unless the message is <code class="calibre23">WM_QUIT</code> to end the program, in which case the value returned is <code class="calibre23">FALSE</code>, or unless an error occurs, in which case the return value is <code class="calibre23">-1</code>. Thus, the <code class="calibre23">while</code> loop continues until a quit message is generated to close the application or until an error condition arises. In either case, you need to end the program by passing the <code class="calibre23">wParam</code> value back to Windows in a <code class="calibre23">return</code> statement.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="596" id="calibre_link-1058" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">There are prefixes other than</i> <code class="calibre23">WM</code> <i class="calibre15">for messages destined for other types of windows than a general window.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The second argument in the call to <code class="calibre23">GetMessage()</code> is the handle of the window for which you want to get messages. This parameter can be used to retrieve messages for one application window separately from another. If this argument is <code class="calibre23">nullptr</code>, as it is here, <code class="calibre23">GetMessage()</code> retrieves all messages for an application. This is an easy way of retrieving all messages for an application regardless of how many windows it has. It is also the safest way because you are sure of getting all the messages for your application. When the user of your Windows program closes the application window for example, the window is closed before the <code class="calibre23">WM_QUIT</code> message is generated. Consequently, if you only retrieve messages by specifying a window handle to the <code class="calibre23">GetMessage()</code> function, you cannot retrieve the <code class="calibre23">WM_QUIT</code> message and your program is not able to terminate properly.</p>
<p class="calibre13">The last two arguments to <code class="calibre23">GetMessage()</code> are integers that hold minimum and maximum values for the message IDs you want to retrieve from the queue. This allows messages to be retrieved selectively. A range is usually specified by symbolic constants. Using <code class="calibre23">WM_MOUSEFIRST</code> and <code class="calibre23">WM_MOUSELAST</code> as these two arguments would select just mouse messages, for example. If both arguments are zero, as you have them here, all messages are retrieved.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Multitasking</h5>
<p class="calibre13">If there are no messages queued, the <code class="calibre23">GetMessage()</code> function does not return control to your program. Windows allows execution to pass to another application, and you will only get a value returned from calling <code class="calibre23">GetMessage()</code> when a message appears in the queue.</p>
<p class="calibre13">This mechanism was fundamental in enabling multiple applications to run under older versions of Windows and is referred to as <i class="calibre15">cooperative multitasking</i> because it depends on concurrent applications giving up control of the processor from time to time. After your program calls <code class="calibre23">GetMessage()</code>, unless there is a message for it another application is executed and your program gets another opportunity to do something only if the other application releases the processor, perhaps by a call to <code class="calibre23">GetMessage()</code> when there are no messages queued for it, but this is not the only possibility.</p>
<p class="calibre13">With current versions of Windows, the operating system can interrupt an application after a period of time and transfer control to another application. This mechanism is called <i class="calibre15">pre-emptive multitasking</i> because an application can be interrupted at any time. With pre-emptive multitasking, however, you must still program the message loop in <code class="calibre23">WinMain()</code> using <code class="calibre23">GetMessage()</code> as before, and make provision for relinquishing control of the processor to Windows from time to time in a long-running calculation (this is usually done using the <code class="calibre23">PeekMessage()</code> API function). If you don’t do this, your application may be unable to respond to messages to repaint the application window when these arise. This can be for reasons that are quite independent of your application &mdash; when an overlapping window for another application is closed, for example.</p>
<p class="calibre13">The conceptual operation of the <code class="calibre23">GetMessage()</code> function is illustrated in <a id="calibre_link-27" href="#calibre_link-26" class="calibre3">Figure 11-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000158.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-26" href="#calibre_link-27" class="calibre3">FIGURE 11-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="597" id="calibre_link-1059" class="calibre14"></span>Within the <code class="calibre23">while</code> loop, the first call to <code class="calibre23">TranslateMessage()</code> requests Windows to do some conversion work for keyboard-related messages. Then the call to <code class="calibre23">DispatchMessage()</code> causes Windows to <i class="calibre15">dispatch</i> the message, which it does by calling the <code class="calibre23">WindowProc()</code> function in your program to process the message. The return from <code class="calibre23">DispatchMessage()</code> does not occur until <code class="calibre23">WindowProc()</code> has finished processing the message. A <code class="calibre23">WM_QUIT</code> message indicates that the program should end, so this results in <code class="calibre23">FALSE</code> being returned to the application, which stops the message loop.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="598" id="calibre_link-1060" class="calibre14"></span>A Complete WinMain() Function</h4>
<p class="calibre13">You have looked at all the bits that need to go into <code class="calibre23">WinMain()</code> so now you can assemble them into a complete function:</p>
<pre class="calibre28"><code class="calibre23">// Listing OFWIN_1
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow)
{
  WNDCLASSEX WindowClass;     // Structure to hold our window's attributes
     
  static LPCTSTR szAppName {_T("OFWin")};     // Define window class name
  HWND hWnd;                                  // Window handle
  MSG msg;                                    // Windows message structure
     
  WindowClass.cbSize = sizeof(WNDCLASSEX);    // Set structure size
     
  // Redraw the window if the size changes
  WindowClass.style   = CS_HREDRAW | CS_VREDRAW;
     
  // Define the message handling function
  WindowClass.lpfnWndProc = WindowProc;
     
  WindowClass.cbClsExtra = 0;     // No extra bytes after the window class
  WindowClass.cbWndExtra = 0;     // structure or the window instance
     
  WindowClass.hInstance = hInstance;           // Application instance handle
     
  // Set default application icon
  WindowClass.hIcon = LoadIcon(nullptr, IDI_APPLICATION);
     
  // Set window cursor to be the standard arrow
  WindowClass.hCursor = LoadCursor(nullptr, IDC_ARROW);
     
  // Set gray brush for background color
  WindowClass.hbrBackground = static_cast&lt;HBRUSH&gt;(GetStockObject(GRAY_BRUSH));
     
  WindowClass.lpszMenuName = nullptr;         // No menu
  WindowClass.lpszClassName = szAppName;      // Set class name
  WindowClass.hIconSm = nullptr;              // Default small icon
     
  // Now register our window class
  RegisterClassEx(&amp;WindowClass);
     
  // Now we can create the window
  hWnd = CreateWindow(
          szAppName,                          // the window class name
          _T("A Basic Window the Hard Way"),  // The window title
          WS_OVERLAPPEDWINDOW,                // Window style as overlapped
          CW_USEDEFAULT,                      // Default position of upper left
          CW_USEDEFAULT,                      // corner of our window as x,y...
          CW_USEDEFAULT,                      // Default window size
          CW_USEDEFAULT,                      // ....
          nullptr,                            // No parent window
          <span {http://www.idpf.org/2007/ops}type="pagebreak" title="599" id="calibre_link-1061" class="calibre14"></span>nullptr,                            // No menu
          hInstance,                          // Program Instance handle
          nullptr                             // No window creation data
        );
     
  ShowWindow(hWnd, nCmdShow);                 // Display the window
  UpdateWindow(hWnd);                         // Redraw window client area
     
  // The message loop
  while(GetMessage(&amp;msg, nullptr, 0, 0) == TRUE) // Get any messages
  {
    TranslateMessage(&amp;msg);                   // Translate the message
    DispatchMessage(&amp;msg);                    // Dispatch the message
  }
     
  return static_cast&lt;int&gt;(msg.wParam);        // End, so return to Windows
}</code></pre>
<p class="calibre13">You need a <code class="calibre23">WindowProc()</code> implementation to make this into a working Windows application. We will look at that after we explore how this code works.</p>
</section>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre13">After declaring the variables that you need in <code class="calibre23">WinMain()</code>, all the members of the <code class="calibre23">WindowClass</code> structure are initialized and the window is registered. Next you call the <code class="calibre23">CreateWindow()</code> function to create the data for the physical appearance of the window based on the arguments and the data established in the <code class="calibre23">WindowClass</code> structure that was previously passed to Windows using the <code class="calibre23">RegisterClassEx()</code> function. The call to <code class="calibre23">ShowWindow()</code> causes the window to be displayed according to the mode specified by <code class="calibre23">nCmdShow</code>, and the <code class="calibre23">UpdateWindow()</code> function signals that a message to draw the window client area should be generated.</p>
<p class="calibre13">The message loop retrieves messages until a <code class="calibre23">WM_QUIT</code> message is issued for the application. When this occurs, the <code class="calibre23">GetMessage()</code> function returns <code class="calibre23">FALSE</code> and the loop ends. The value of the <code class="calibre23">wParam</code> member of the <code class="calibre23">msg</code> structure is passed back to Windows in the <code class="calibre23">return</code> statement.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Processing Windows Messages</h3>
<p class="calibre13">The <code class="calibre23">WinMain()</code> function contains nothing that was application-specific beyond the general appearance of the application window. All of the code that makes the application behave in the way that you want is included in the message processing part of the program. This is the function <code class="calibre23">WindowProc()</code> that you identify to Windows in the <code class="calibre23">WindowClass</code> structure. Windows calls this function each time a message for your main application window is dispatched. Because you identify your <code class="calibre23">WindowProc()</code> function to Windows by a function pointer, you can use any name for the function that you like. I’ll continue to call it <code class="calibre23">WindowProc()</code>.</p>
<p class="calibre13">This example is simple, so you will be putting all the code to process messages in the one function, <code class="calibre23">WindowProc()</code>. More generally, though, the <code class="calibre23">WindowProc()</code> function is responsible for analyzing what a given message is and which window it is destined for and then calling one of a whole range of functions, each of which would be geared to handling a particular message in the context <span {http://www.idpf.org/2007/ops}type="pagebreak" title="600" id="calibre_link-1062" class="calibre14"></span>of the window concerned. However, the overall sequence of operations and the way in which <code class="calibre23">WindowProc()</code> analyzes an incoming message is much the same in most application contexts.</p>
<section class="toclist">
<h4 class="calibre22">The WindowProc() Function</h4>
<p class="calibre13">The prototype of the <code class="calibre23">WindowProc()</code> function is:</p>
<pre class="calibre28"><code class="calibre23">LRESULT CALLBACK WindowProc(HWND hWnd, UINT message,
                            WPARAM wParam, LPARAM lParam);</code></pre>
<p class="calibre13">The return type is <code class="calibre23">LRESULT</code>, which is a Windows type that is normally equivalent to type <code class="calibre23">long</code>. Because the function is called by Windows through a pointer (you set up the pointer with the address of <code class="calibre23">WindowProc()</code> in <code class="calibre23">WinMain()</code> in the <code class="calibre23">WNDCLASSEX</code> structure), you need to qualify the function as <code class="calibre23">CALLBACK</code>. I mentioned this specifier earlier, and its effect is the same as the <code class="calibre23">WINAPI</code> specifier that determines how the function arguments are handled. You could use <code class="calibre23">WINAPI</code> here instead of <code class="calibre23">CALLBACK</code>, although the latter expresses better what this function is about. The four arguments that are passed to <code class="calibre23">WindowProc()</code> provide information about the message causing the function to be called. The meaning of each argument is described in the following table:</p>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">ARGUMENT</b></th>
<th class="calibre32"><b class="calibre12">MEANING</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HWND hWnd</code></td>
<td class="calibre32">A handle to the window in which the event causing the message occurred.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">UINT message</code></td>
<td class="calibre32">The message ID, which is a 32-bit value indicating the type of message.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WPARAM wParam</code></td>
<td class="calibre32">A 32-bit (or 64-bit in 64-bit mode) value containing additional information depending on what sort of message it is.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPARAM lParam</code></td>
<td class="calibre32">A 32-bit (or 64-bit in 64-bit mode) value containing additional information depending on what sort of message it is.</td>
</tr>
</tbody>
</table>
<p class="calibre13">The window that the incoming message relates to is identified by the first argument, <code class="calibre23">hWnd</code>. In this case, you have only one window, so you can ignore it.</p>
<p class="calibre13">Messages are identified by the <code class="calibre23">message</code> value that is passed to <code class="calibre23">WindowProc()</code>. You can test this value against predefined symbolic constants, each of which identifies a particular message. General windows messages begin with <code class="calibre23">WM_</code>, and typical examples are <code class="calibre23">WM_PAINT</code>, which corresponds to a request to redraw part of the client area of a window, and <code class="calibre23">WM_LBUTTONDOWN</code>, which indicates that the left mouse button was pressed. You can find the whole set of these by searching for <code class="calibre23">WM_</code> in the MSDN Library.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Decoding a Windows Message</h4>
<p class="calibre13">Decoding the message that Windows sends is usually done using a <code class="calibre23">switch</code> statement in the <code class="calibre23">WindowProc()</code> function, based on the value of <code class="calibre23">message</code>. You select the message types that you want to process by putting a <code class="calibre23">case</code> statement for each message ID in the <code class="calibre23">switch</code>. The typical structure of such a <code class="calibre23">switch</code> statement is:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="601" id="calibre_link-1063" class="calibre14"></span>switch(message)
{
  case WM_PAINT:
    // Code to deal with drawing the client area
    break;
     
  case WM_LBUTTONDOWN:
    // Code to deal with the left mouse button being pressed
    break;
     
  case WM_LBUTTONUP:
    // Code to deal with the left mouse button being released
    break;
     
  case WM_DESTROY:
    // Code to deal with a window being destroyed
    break;
     
  default:
    // Code to handle any other messages
}</code></pre>
<p class="calibre13"><i class="calibre15">Every</i> Windows program has something like this somewhere, although it will be hidden from sight in the Windows programs that you will write later using MFC. Each case corresponds to a particular message ID and provides suitable processing for that message. Any messages that a program does not want to deal with individually are handled by the default statement, which should hand the messages back to Windows by calling <code class="calibre23">DefWindowProc()</code>. This is the Windows API function that provides default message handling.</p>
<p class="calibre13">In a complex program dealing with a wide range of possible Windows messages, this <code class="calibre23">switch</code> statement can become large and rather cumbersome. When you get to use the Application Wizard to generate a Windows application that uses the MFC, you won’t have to worry about this because it is all taken care of for you and you never see the <code class="calibre23">WindowProc()</code> function. You just need to supply the code to process the messages in which you are interested.</p>
<section class="toclist">
<h5 class="calibre27">Drawing the Window Client Area</h5>
<p class="calibre13">Windows sends a <code class="calibre23">WM_PAINT</code> message to the program to signal that the client area should be redrawn. So you need to draw the client area of the window in response to the <code class="calibre23">WM_PAINT</code> message.</p>
<p class="calibre13">You can’t go drawing in the window willy-nilly. Before you can write to the application window, you need to tell Windows that you want to do so, and get Windows’ authority to go ahead. You do this by calling the Windows API function <code class="calibre23">BeginPaint()</code>, which should only be called in response to a <code class="calibre23">WM_PAINT</code> message. It is used like this:</p>
<pre class="calibre28"><code class="calibre23">HDC hDC;                               // A display context handle
PAINTSTRUCT PaintSt;                   // Structure defining area to be redrawn
     
hDC = BeginPaint(hWnd, &amp;PaintSt);      // Prepare to draw in the window</code></pre>
<p class="calibre13">The <code class="calibre23">HDC</code> type represents a handle to a <i class="calibre15">display context</i>, or more generally a <i class="calibre15">device context</i>. A device context provides the link between the device-independent Windows API functions for outputting <span {http://www.idpf.org/2007/ops}type="pagebreak" title="602" id="calibre_link-1064" class="calibre14"></span>information to the screen or a printer, and the device drivers that support writing to the specific devices attached to your PC. You can also regard a device context as a token of authority that is handed to you on request by Windows and grants you permission to output some information. Without a device context, you simply can’t generate any output.</p>
<p class="calibre13">The <code class="calibre23">BeginPaint()</code> function returns a handle to a display context. It requires two arguments. The first argument is a handle, <code class="calibre23">hWnd</code>, for the window to which you want to write. The second argument is the address of a <code class="calibre23">PAINTSTRUCT</code> variable <code class="calibre23">PaintSt</code>, in which Windows will place information about the area that is to be redrawn in response to the <code class="calibre23">WM_PAINT</code> message. I will ignore the details of this because you are not going to use it. You will just redraw the whole of the client area. You can obtain the coordinates of the client area in a <code class="calibre23">RECT</code> structure with the statements:</p>
<pre class="calibre28"><code class="calibre23">RECT aRect;                         // A working rectangle
GetClientRect(hWnd, &amp;aRect);</code></pre>
<p class="calibre13">The <code class="calibre23">GetClientRect()</code> function supplies the coordinates of the upper-left and lower-right corners of the client area for the window specified by the first argument. These coordinates are stored in the <code class="calibre23">RECT</code> structure <code class="calibre23">aRect</code> that you create, and you pass the address of this structure as the second argument. You can use <code class="calibre23">aRect</code> to identify the area in the client area where the text is to be written by the <code class="calibre23">DrawText()</code> function. Because your window has a gray background, you should alter the background of the text to be transparent, to allow the gray to show through; otherwise, the text appears against a white background. You can do this with this API function call:</p>
<pre class="calibre28"><code class="calibre23">SetBkMode(hDC, TRANSPARENT);           // Set text background mode</code></pre>
<p class="calibre13">The first argument identifies the device context and the second sets the background mode. The default option is <code class="calibre23">OPAQUE</code>.</p>
<p class="calibre13">You can now write the text with the statement:</p>
<pre class="calibre28"><code class="calibre23">DrawText(hDC,                     // Device context handle
         _T("But, soft! What light through yonder window breaks?"),
         -1,                      // Indicate null terminated string
         &amp;aRect,                  // Rectangle in which text is to be drawn
         DT_SINGLELINE|           // Text format - single line
         DT_CENTER|               //             - centered in the line
         DT_VCENTER               //             - line centered in aRect
      );</code></pre>
<p class="calibre13">The first argument to the <code class="calibre23">DrawText()</code> function is your certificate of authority to draw on the window, the display context <code class="calibre23">hDC</code>. The next argument is the text string that you want to output. You could equally well have defined this in a variable and passed the pointer to the text as the second argument in the function call. The next argument, with the value <code class="calibre23">−1</code>, signifies that your string is terminated with a null character. If it weren’t, you would put the count of the number of characters in the string here. The fourth argument is a pointer to a <code class="calibre23">RECT</code> structure defining a rectangle in which you want to write the text. In this case, it is the whole client area of the window defined in <code class="calibre23">aRect</code>. The last argument defines the format for the text in the rectangle. Here you have combined three specifications with a bitwise OR (<code class="calibre23">|</code>). The string is written as a single line, with the text centered on the line and the line centered vertically within the rectangle. This places it nicely in the center of the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="603" id="calibre_link-1065" class="calibre14"></span>window. There are also a number of other options, which include the possibility to place text at the top or the bottom of the rectangle, and to left- or right-justify it.</p>
<p class="calibre13">After you have written all that you want to display, you must tell Windows that you have finished drawing the client area. For every <code class="calibre23">BeginPaint()</code> function call, there must be a corresponding <code class="calibre23">EndPaint()</code> function call. Thus, to end processing of the <code class="calibre23">WM_PAINT</code> message, you need the statement:</p>
<pre class="calibre28"><code class="calibre23">EndPaint(hWnd, &amp;PaintSt);           // Terminate window redraw operation</code></pre>
<p class="calibre13">The <code class="calibre23">hWnd</code> argument identifies your program window, and the second argument is the address of the <code class="calibre23">PAINTSTRUCT</code> structure that was filled in by the <code class="calibre23">BeginPaint()</code> function.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Ending the Program</h4>
<p class="calibre13">You might assume that closing the window closes the application, but to get this behavior, you actually have to add some more code. The reason that the application won’t close by default when the window is closed is that you may need to do some clearing up. It is also possible that the application may have more than one window. When the user closes the window by double-clicking the title bar icon or clicking the Close button, this causes a <code class="calibre23">WM_DESTROY</code> message to be generated. Therefore, to close the application, you need to process the <code class="calibre23">WM_DESTROY</code> message in <code class="calibre23">WindowProc()</code>. You do this by generating a <code class="calibre23">WM_QUIT</code> message:</p>
<pre class="calibre28"><code class="calibre23">PostQuitMessage(0);</code></pre>
<p class="calibre13">The argument here is an exit code. This API function does exactly what its name suggests: it posts a <code class="calibre23">WM_QUIT</code> message in the message queue for your application. This results in the <code class="calibre23">GetMessage()</code> function that is called in <code class="calibre23">WinMain()</code> returning <code class="calibre23">FALSE</code> and ending the message loop, thus ending the program.</p>
</section>
<section class="toclist">
<h4 class="calibre22">A Complete WindowProc() Function</h4>
<p class="calibre13">You have covered all the elements necessary to assemble the complete <code class="calibre23">WindowProc()</code> function for the example. The code for the function is:</p>
<pre class="calibre28"><code class="calibre23">// Listing OFWIN_2
LRESULT CALLBACK WindowProc(HWND hWnd, UINT message,
                          WPARAM wParam, LPARAM lParam)
{
     
  switch(message)                // Process selected messages
  {
    case WM_PAINT:                     // Message is to redraw the window
      HDC hDC;                         // Display context handle
      PAINTSTRUCT PaintSt;             // Structure defining area to be drawn
      RECT aRect;                      // A working rectangle
      hDC = BeginPaint(hWnd, &amp;PaintSt);// Prepare to draw the window
     
      // Get upper left and lower right of client area
      GetClientRect(hWnd, &amp;aRect);
     
      <span {http://www.idpf.org/2007/ops}type="pagebreak" title="604" id="calibre_link-1066" class="calibre14"></span>SetBkMode(hDC, TRANSPARENT);     // Set text background mode
     
      // Now draw the text in the window client area
      DrawText(
             hDC,                 // Device context handle
             _T("But, soft! What light through yonder window breaks?"),
             -1,                  // Indicate null terminated string
             &amp;aRect,              // Rectangle in which text is to be drawn
             DT_SINGLELINE|       // Text format - single line
             DT_CENTER|           //             - centered in the line
             DT_VCENTER);         //             - line centered in aRect
     
      EndPaint(hWnd, &amp;PaintSt);   // Terminate window redraw operation
      return 0;
     
    case WM_DESTROY:              // Window is being destroyed
      PostQuitMessage(0);
      return 0;
  }
  return DefWindowProc(hWnd, message, wParam, lParam);
}</code></pre>
</section>
<section class="toclist">
<h4 class="calibre22">How It Works</h4>
<p class="calibre13">Apart from the last statement, the entire function body is just a <code class="calibre23">switch</code> statement. A particular <code class="calibre23">case</code> is selected based on the message ID that is passed to the function through the <code class="calibre23">message</code> parameter. Because this example is simple, you need to process only two types of message: <code class="calibre23">WM_PAINT</code> and <code class="calibre23">WM_DESTROY</code>. You hand all other messages back to Windows by calling the <code class="calibre23">DefWindowProc()</code> function after the <code class="calibre23">switch</code> statement. The arguments to <code class="calibre23">DefWindowProc()</code> are those that were passed to the function, so you are just passing them back as they are. Note the <code class="calibre23">return</code> statement at the end of processing each message type. For the messages that you handle, a zero value is returned.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: A Simple Windows API Program</h3>
<p class="calibre20">Because you have written <code class="calibre23">WinMain()</code> and <code class="calibre23">WindowProc()</code> to handle messages, you have enough to create a complete Windows program using just the Windows API. Of course, you’ll need to create a project for this program, but instead of choosing Win32 Console Application as you’ve done up to now, you should create this project using the Win32 Project template. You should elect to create it as an empty project with the name <code class="calibre23">Ex11_01</code> and add the <code class="calibre23">Ex11_01.cpp</code> file that will contain the following code:</p>
<pre class="calibre28"><code class="calibre23">// Ex11_01.cpp   Native windows program to display text in a window
#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
LRESULT CALLBACK WindowProc(HWND hWnd, UINT message,
                          WPARAM wParam, LPARAM lParam);
     
   // Insert code for WinMain() here (Listing OFWIN_1)
     
   // Insert code for WindowProc() here (Listing OFWIN_2)</code></pre>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="605" id="calibre_link-1067" class="calibre14"></span>If you build and execute the example, it produces the window shown in <a id="calibre_link-29" href="#calibre_link-28" class="calibre3">Figure 11-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000115.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-28" href="#calibre_link-29" class="calibre3">FIGURE 11-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20">Note that the window has a number of properties provided by the operating system that require no programming effort on your part to manage. The boundaries of the window can be dragged to resize it, and the whole window can be moved about on-screen. The maximize and minimize buttons also work. Of course, all of these actions do affect the program. Every time you modify the position or size of the window, a <code class="calibre23">WM_PAINT</code> message is queued and your program has to redraw the client area, but all the work of drawing and modifying the window itself is done by Windows.</p>
<p class="calibre20">The system menu and Close button are also standard features of your window because of the options that you specified in the <code class="calibre23">WindowClass</code> structure. Again, Windows takes care of the management. The only additional effect on your program arising from this is the passing of a <code class="calibre23">WM_DESTROY</code> message if you close the window, as previously discussed.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-336" class="calibre3"></a>THE MICROSOFT FOUNDATION CLASSES</h2>
<p class="calibre13">The <i class="calibre15">Microsoft Foundation Classes (MFC)</i> are a set of predefined classes that make it easy to develop Windows desktop applications with Visual C++. These classes represent an object-oriented approach to Windows programming that encapsulates the Windows API. MFC does not adhere strictly to the object-oriented principles of encapsulation and data hiding, principally because much of the MFC code was written before such principles were well established.</p>
<p class="calibre13">The process of writing a Windows program involves creating and using MFC objects or objects of classes derived from MFC. In the main, you’ll derive your own classes from MFC, with considerable assistance from the specialized tools in Visual C++ that make this easy. The objects of these MFC-based class types incorporate member functions for communicating with Windows, for processing Windows messages, and for sending messages to each other. Your derived classes inherit all of the members of their base classes. These inherited functions do practically all of the general grunt work necessary for a Windows application to work. All you need to do is to add data and function members to the classes to provide the application-specific functionality that you need in your program. In doing this, you’ll apply most of the techniques that you’ve been grappling with in the preceding chapters, particularly those involving class inheritance and virtual functions.</p>
<section class="toclist">
<h3 class="calibre21">MFC Notation</h3>
<p class="calibre13">All the classes in MFC have names beginning with C, such as <code class="calibre23">CDocument</code> or <code class="calibre23">CView</code>. If you use the same convention when defining your own classes, or when deriving them from those in the MFC library, your programs will be easier to follow. Data members of an MFC class are prefixed with <code class="calibre23">m_</code>. I’ll also follow this convention in the MFC examples.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="606" id="calibre_link-1068" class="calibre14"></span>You’ll find that the MFC uses Hungarian notation for many variable names, particularly those that originate in the Windows API. As you recall, this involves using a prefix of <code class="calibre23">p</code> for a pointer, <code class="calibre23">n</code> for an <code class="calibre23">unsigned int, l</code> for <code class="calibre23">long, h</code> for a handle, and so on. The name <code class="calibre23">m_lpCmdLine</code>, for example, refers to a data member of a class (because of the <code class="calibre23">m_</code> prefix) that is of type ‘long pointer to a string’. Because C++ has strong type checking that picks up the sort of misuse that used to happen regularly in C, this kind of notation isn’t essential, so I won’t use it generally for variables in the examples in the book. I will, however, retain the <code class="calibre23">p</code> prefix for pointers and some of the other simple type denotations because this helps to make the code more readable.</p>
</section>
<section class="toclist">
<h3 class="calibre21">How an MFC Program Is Structured</h3>
<p class="calibre13">You know from Chapter 1 that you can produce a Windows program using the Application Wizard without writing a single line of code. Of course, this uses the MFC library, but it’s quite possible to write a Windows program that uses MFC without using the Application Wizard. If you first scratch the surface by constructing the minimum MFC-based program, you’ll get a clearer idea of the fundamental elements involved.</p>
<p class="calibre13">The simplest program that you can produce using MFC is slightly less sophisticated than the example that you wrote earlier in this chapter using the raw Windows API. The example you’ll produce here has a window, but no text displayed in it. This is sufficient to show the fundamentals, so try it out.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT: A Minimal MFC Application</h3>
<p class="calibre20">Create a new project using the File <img src="images/000122.png" alt="image" class="calibre25" /> New <img src="images/000122.png" alt="image" class="calibre25" /> Project menu option, as you’ve done many times before. You won’t use the Application Wizard that creates the basic code here, so select the template for the project as Win32 Project and choose Windows Application and the Empty project options in the second dialog. After the project is created, select Project π Properties from the main menu, and on the General sub-page from Configuration Properties, click the Use of MFC property to set its value to Use MFC in a Shared DLL.</p>
<p class="calibre20">With the project created, you can create a new source file in the project as <code class="calibre23">Ex11_02.cpp</code>. So that you can see all the code for the program in one place, put the class definitions you need together with their implementations in this file. To achieve this, just add the code manually in the edit window &mdash; there isn’t very much of it.</p>
<p class="calibre20">To begin with, add a statement to include the header file <code class="calibre23">afxwin.h</code>, as this contains the definitions for many MFC classes. This allows you to derive your own classes from MFC:</p>
<pre class="calibre28"><code class="calibre23">#include &lt;afxwin.h&gt;                 // For the class library</code></pre>
<p class="calibre20">To produce the complete program, you’ll only need to derive two classes from MFC: an <i class="calibre15">application class</i> and a <i class="calibre15">window class</i>. You won’t even need to write a <code class="calibre23">WinMain()</code> function, as you did in the previous example in this chapter, because this is automatically provided by the MFC library behind the scenes. Take a look at how you define the two classes that you need.</p>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">The Application Class</i></h4>
<p class="calibre20">The <code class="calibre23">CWinApp</code> class is fundamental to any Windows program written using the MFC. An object of this class type includes everything necessary for starting, initializing, running, and closing the application. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="607" id="calibre_link-1069" class="calibre14"></span>You need to derive your own application class from <code class="calibre23">CWinApp</code> to produce your application type. You will define a specialized version of the class to suit your application needs. The code for this is as follows:</p>
<pre class="calibre28"><code class="calibre23">class COurApp: public CWinApp
{
public:
  virtual BOOL InitInstance() override;
};</code></pre>
<p class="calibre20">As you might expect for a simple example, there isn’t a great deal of specialization necessary. You’ve only included one member in the definition of the class: the <code class="calibre23">InitInstance()</code> function. This function is defined as a virtual function in the base class, so it’s an override in your derived class; you are simply redefining the base class function for your application class. All the other data and function members that you need in the class are inherited from <code class="calibre23">CWinApp</code>.</p>
<p class="calibre20">The application class is endowed with quite a number of data members, many of which correspond to variables that are used as arguments in Windows API function calls. For example, the <code class="calibre23">m_pszAppName</code> member stores a pointer to a string that defines the name of the application. The <code class="calibre23">m_nCmdShow</code> member specifies how the application window is to be shown when the application starts up. You don’t need to go into all the inherited data members now. You’ll see how they are used as the need arises in developing application-specific code.</p>
<p class="calibre20">In deriving your own application class from <code class="calibre23">CWinApp</code>, you must implement <code class="calibre23">InitInstance()</code>. Your version will be called by the version of <code class="calibre23">WinMain()</code> that’s provided by the MFC, and you’ll include code in the function to create and display your application window. However, before you write <code class="calibre23">InitInstance()</code>, I should introduce you to an MFC class that defines a window.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">The Window Class</i></h4>
<p class="calibre20">Your MFC application needs a window to provide the interface to the user; this is referred to as a <i class="calibre15">frame window</i>. You derive a window class for the application from the MFC class <code class="calibre23">CFrameWnd</code>, which is designed specifically for this purpose. Because <code class="calibre23">CFrameWnd</code> provides everything for creating and managing an application window, all you need to add to the derived class is a constructor. This will enable you to specify the title bar text for the window to suit the application context:</p>
<pre class="calibre28"><code class="calibre23">class COurWnd: public CFrameWnd
{
public:
  // Constructor
  COurWnd()
  {
    Create(nullptr, _T("Our Dumb MFC Application"));
  }
};</code></pre>
<p class="calibre20">The <code class="calibre23">Create()</code> function that you call in the constructor is inherited from the base class. It creates the window and attaches it to the <code class="calibre23">COurWnd</code> object that is being created. Note that the <code class="calibre23">COurWnd</code> object is not the same thing as the window that is displayed by Windows &mdash; the class object and the physical window are distinct entities.</p>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="608" id="calibre_link-1070" class="calibre14"></span>The first argument value for the <code class="calibre23">Create()</code> function, <code class="calibre23">nullptr</code>, specifies that you want to use the base class default attributes for the window &mdash; you’ll recall that you needed to define window attributes in the previous example in this chapter that used the Windows API directly. The second argument specifies the text that is to be displayed in the window title bar. You won’t be surprised to learn that there are other parameters to the function <code class="calibre23">Create()</code>, but they all have default values that are quite satisfactory so you can ignore them here.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">Completing the Program</i></h4>
<p class="calibre20">Having defined a window class for the application, you can implement the <code class="calibre23">InitInstance()</code> function in our <code class="calibre23">COurApp</code> class:</p>
<pre class="calibre28"><code class="calibre23">BOOL COurApp::InitInstance(void)
{
  m_pMainWnd = new COurWnd;               // Construct a window object...
  m_pMainWnd-&gt;ShowWindow(m_nCmdShow);     // ...and display it
  return TRUE;
}</code></pre>
<p class="calibre20">This overrides the virtual function defined in the base class <code class="calibre23">CWinApp</code>, and as I said previously, it is called by the <code class="calibre23">WinMain()</code> function that’s automatically supplied by the MFC library. The <code class="calibre23">InitInstance()</code> function constructs a main window object for the application in the free store by using the operator <code class="calibre23">new</code>. You store the address that is returned in the variable <code class="calibre23">m_pMainWnd</code>, which is an inherited member of your <code class="calibre23">COurApp</code> class. The effect of this is that the window object is owned by the application object. You don’t even need to worry about freeing the memory for the object you have created &mdash; the supplied <code class="calibre23">WinMain()</code> function takes care of any cleanup necessary.</p>
<p class="calibre20">The only other item you need for a complete, albeit rather limited, program is to define an application object. An instance of our application class, <code class="calibre23">COurApp</code>, must exist before <code class="calibre23">WinMain()</code> is executed, so you must declare it at global scope with the statement:</p>
<pre class="calibre28"><code class="calibre23">COurApp AnApplication;     // Define an application object</code></pre>
<p class="calibre20">The reason that this object needs to exist at global scope is that it encapsulates the application, and the application needs to exist before it can start executing. The <code class="calibre23">WinMain()</code> function that is provided by the MFC calls the <code class="calibre23">InitInstance()</code> member of the application object to construct the window object, which implies that the application object must already exist.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">The Finished Product</i></h4>
<p class="calibre20">Now that you’ve seen all the code, you can add it to the <code class="calibre23">Ex11_02.cpp</code> source file in the project. Classes are usually defined in <code class="calibre23">.h</code> files and the member functions that are not defined within the class definitions are defined in <code class="calibre23">.cpp</code> files. This application is so short that you may as well put it all in a single <code class="calibre23">.cpp</code> file. The merit of this is that you can view the whole lot together. The program code is:</p>
<pre class="calibre28"><code class="calibre23">// Ex11_02.cpp  An elementary MFC program
#include &lt;afxwin.h&gt;                        // For the class library
     
// Application class definition
class COurApp:publicCWinApp
{
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="609" id="calibre_link-1071" class="calibre14"></span>public:
  virtual BOOL InitInstance() override;
};
     
// Window class definition
class COurWnd:publicCFrameWnd
{
public:
  // Constructor
  COurWnd()
  {
  Create(nullptr, _T("Our Dumb MFC Application"));
  }
};
     
// Function to create an instance of the main application window
BOOL COurApp::InitInstance(void)
{
  m_pMainWnd = new COurWnd;               // Construct a window object...
  m_pMainWnd-&gt;ShowWindow(m_nCmdShow);     // ...and display it
  return TRUE;
}
     
// Application object definition at global scope
COurApp AnApplication;                     // Define an application object</code></pre>
<p class="calibre20">That’s all you need. It looks a bit odd because no <code class="calibre23">WinMain()</code> function appears, but as I noted previously, there is a <code class="calibre23">WinMain()</code> function supplied by the MFC library.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">Now you’re ready to roll, so build and run the application. Select the Build <img src="images/000122.png" alt="image" class="calibre25" /> Build Ex11_02 menu item, click the appropriate toolbar button, or just press F7 to build the solution. You should end up with a clean compile and link, in which case you can press Ctrl+F5 to run it. Your minimum MFC program appears as shown in <a id="calibre_link-31" href="#calibre_link-30" class="calibre3">Figure 11-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000144.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre20"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-30" href="#calibre_link-31" class="calibre3">FIGURE 11-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="610" id="calibre_link-1072" class="calibre14"></span>You can resize the window by dragging the border, move the whole thing around, and minimize or maximize it in the usual ways. The only other function that the program supports is “close,” for which you can use the system menu, the Close button at the upper right of the window, or just key Alt+F4. It doesn’t look like much, but considering that there are so few lines of code, it’s quite impressive.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-337" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter you’ve seen two ways of creating an elementary Windows application with Visual C++. You should now have a feel for the relationship between these two approaches. In subsequent chapters you’ll be exploring in more depth how you develop applications using the MFC.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="611" id="calibre_link-1073" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table border="1" class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows API</b></td>
<td class="calibre32">The Windows API provides a standard programming interface by which a desktop application communicates with the Windows operating system.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows messages</b></td>
<td class="calibre32">Windows communicates with a desktop application by passing messages to it. A message typically indicates that an event of some kind has occurred that requires action on the part of the application.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows application structure</b></td>
<td class="calibre32">All Windows desktop applications must include two functions, <code class="calibre23">WinMain()</code> and <code class="calibre23">WindowProc()</code>, that will be called by the operating system. You can use any name you like for the <code class="calibre23">WindowProc()</code> function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">WinMain()</code> function</b></td>
<td class="calibre32">The <code class="calibre23">WinMain()</code> function is called by the operating system to begin execution of an application. The function includes code to set up the initial conditions required by the application, to specify the application window, and to retrieve messages from the operating system that are intended for the application.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">WindowProc()</code> function</b></td>
<td class="calibre32">The Windows operating system calls a particular function that is usually called <code class="calibre23">WindowProc()</code> to process messages. A desktop application identifies the message processing function for each application window in <code class="calibre23">WinMain()</code> by passing a pointer to the message processing function to a Windows API function as part of a <code class="calibre23">WNDCLASSEX</code> structure.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The Microsoft Foundation Classes</b></td>
<td class="calibre32">The MFC consists of a set of classes that encapsulate the Windows API and greatly simplify the development of Windows desktop applications.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="612" id="calibre_link-1074" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-338">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2325" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="613" id="calibre_link-1075" class="calibre9"></span><span class="chapternumber">Chapter 12</span><br class="calibre10" /><span class="chapternumber">Windows Programming with the Microsoft Foundation Classes (MFC)</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The basic elements of an MFC-based program</li>
<li class="calibre6">The difference between Single Document Interface (SDI) applications and Multiple Document Interface (MDI) applications</li>
<li class="calibre6">How to use the MFC Application Wizard to generate SDI and MDI programs</li>
<li class="calibre6">The files generated by the MFC Application Wizard and what they contain</li>
<li class="calibre6">How an MFC Application Wizard-generated program is structured</li>
<li class="calibre6">The key classes in an MFC Application Wizard-generated program, and how they are interconnected</li>
<li class="calibre6">How to customize an MFC Application Wizard-generated program</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 11 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-339" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="614" id="calibre_link-1076" class="calibre18"></span>THE MFC DOCUMENT/VIEW CONCEPT</h2>
<p class="calibre13">When you write applications using the MFC, it implies acceptance of a specific structure for your program, with application data stored and processed in a particular way. This may sound restrictive, but it really isn’t for the most part, and the benefits in speed and ease of implementation far outweigh any disadvantages. The structure of an MFC program incorporates two application-oriented entities &mdash; a document and a view &mdash; so let’s look at what they are and how they’re used.</p>
<section class="toclist">
<h3 class="calibre21">What Is a Document?</h3>
<p class="calibre13">A <i class="calibre15">document</i> is a collection of data in your application with which the user interacts. Although the word ****<i class="calibre15">document</i> seems to imply something of a textual nature, it isn’t limited to text. It could be data for a game, a geometric model, a text file, a collection of data on the distribution of orange trees in California, or, indeed, anything you want. The term document is just a convenient label for the application data in your program, treated as a unit.</p>
<p class="calibre13">You won’t be surprised to hear that a document is defined as an object of a document class. Your document class is derived from the <code class="calibre23">CDocument</code> class in the MFC library, and you add your own data members to store items that your application requires, and member functions to support processing of that data. Your application is not limited to a single document type; you can define multiple document classes when there are several different kinds of documents involved in your application.</p>
<p class="calibre13">Handling application data in this way enables standard mechanisms to be provided within the MFC for managing a collection of application data as a unit and for storing the data on disk. These mechanisms are inherited by your document class from <code class="calibre23">CDocument</code>, so you get a broad range of functionality built into your application automatically, without having to write any code.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Document Interfaces</h3>
<p class="calibre13">You have a choice as to whether your program deals with just one document at a time, or with several. The <i class="calibre15">Single Document Interface (SDI)</i> is supported by the MFC for programs that require only one document to be open at a time. A program using this interface is an <i class="calibre15">SDI application</i>.</p>
<p class="calibre13">For programs needing several documents to be open at one time, you use the <i class="calibre15">Multiple Document Interface (MDI)</i>. With the MDI, as well as being able to open multiple documents of one type, your program can also be organized to handle documents of different types simultaneously with each document displayed in its own window. Of course, you need to supply the code to deal with processing all the types of documents you intend to use. In an MDI application, each document is displayed in a child window of the application window. You also have an application variant called the <i class="calibre15">multiple top-level document architecture</i> where each document window is a child of the desktop.</p>
</section>
<section class="toclist">
<h3 class="calibre21">What Is a View?</h3>
<p class="calibre13">A <i class="calibre15">view</i> always relates to a particular document object. A document object contains a set of application data, and a view is an object that provides a mechanism for displaying some or all of that data. A view defines how the data is to be displayed in a window and how the user can interact with it. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="615" id="calibre_link-1077" class="calibre14"></span>You define a view class by deriving it from the MFC class, <code class="calibre23">CView</code>. Note that a view object and the window, in which it is displayed, are distinct. The window in which a view appears is called a <i class="calibre15">frame window</i>. A view is displayed in its own window that exactly fills the client area of a frame window. <a id="calibre_link-1349" href="#calibre_link-425" class="calibre3">Figure 12-1</a> illustrates how a document might be displayed in two views.</p>
<figure class="calibre16">
<img class="center" src="images/000097.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-425" href="#calibre_link-1349" class="calibre3">FIGURE 12-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">In <a href="#calibre_link-425" class="calibre3">Figure 12-1</a>, each view displays all the data that the document contains in a different form, although a view could display just part of the data if that’s what’s required.</p>
<p class="calibre13">A document can have as many view objects associated with it as you want. Each view can provide a different presentation of the document data or a subset of the data. If you were dealing with text, for example, different views could display independent blocks of text from the same document. For a program handling graphical data, you could display the document data at different scales in separate windows, or in different formats, such as a textual representation of the elements that form the image. <a href="#calibre_link-425" class="calibre3">Figure 12-1</a> illustrates a document that contains numerical data &mdash; product sales data by month &mdash; where one view provides a bar chart representation of sales performance and a second view shows the data in the form of a graph.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Linking a Document and Its Views</h3>
<p class="calibre13">The MFC incorporates a mechanism for integrating a document with its views, and each frame window with a currently active view. A document automatically maintains a list of pointers to its associated views, and a view object has a data member holding a pointer to the document to which it relates. Each frame window stores a pointer to the currently active view. The coordination between a document, a view, and a frame window is established by another MFC class of objects called document templates.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="616" id="calibre_link-1078" class="calibre14"></span>Document Templates</h4>
<p class="calibre13">A <i class="calibre15">document template</i> manages the document objects in your program, as well as the windows and views associated with each of them. There is one document template for each type of document that you have in your application. If you have two or more documents of the same type, you need only one document template to manage them. A document template object creates document objects and frame window objects, and views for a document are created by a frame window object. The application object that is fundamental to every MFC application creates the document template object. <a id="calibre_link-1350" href="#calibre_link-426" class="calibre3">Figure 12-2</a> shows a graphical representation of these interrelationships.</p>
<figure class="calibre16">
<img class="center" src="images/000058.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-426" href="#calibre_link-1350" class="calibre3">FIGURE 12-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><a href="#calibre_link-426" class="calibre3">Figure 12-2</a> uses dashed arrows to show how pointers are used to relate objects. These pointers enable function members of one object to access the public data or function members in the interface of another object.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Document Template Classes</h4>
<p class="calibre13">The MFC has two document template classes. <code class="calibre23">CSingleDocTemplate</code> is used for SDI applications. This is relatively straightforward because an SDI application has only one document and usually just one view. MDI applications are rather more complicated. They have multiple documents active at <span {http://www.idpf.org/2007/ops}type="pagebreak" title="617" id="calibre_link-1079" class="calibre14"></span>one time and the <code class="calibre23">CMultiDocTemplate</code> class defines the document template. You’ll see more of these classes as you develop application code.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Your Application and MFC</h3>
<p class="calibre13"><a id="calibre_link-1351" href="#calibre_link-427" class="calibre3">Figure 12-3</a> shows the four basic classes that are going to appear in virtually all your MFC-based Windows applications:</p>
<figure class="calibre16">
<img class="center" src="images/000017.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-427" href="#calibre_link-1351" class="calibre3">FIGURE 12-3</a></b></span></p>
</figcaption>
</figure>
<ul class="chapterfeaturinglist">
<li class="calibre6">The application class <code class="calibre23">CMyApp</code></li>
<li class="calibre6">The frame window class <code class="calibre23">CMyWnd</code></li>
<li class="calibre6">The view class <code class="calibre23">CMyView</code>, which defines how data contained in <code class="calibre23">CMyDoc</code> is to be displayed in the client area of a window created by a <code class="calibre23">CMyWnd</code> object</li>
<li class="calibre6">The document class <code class="calibre23">CMyDoc</code>, defining a document to contain the application data</li>
</ul>
<p class="calibre13">The names for these classes are specific to an application, but the derivation from the MFC is much the same, although there can be alternative base classes, particularly with the view class. The <span {http://www.idpf.org/2007/ops}type="pagebreak" title="618" id="calibre_link-1080" class="calibre14"></span>MFC provides several variations of the view class that provide a lot of prepackaged functionality, saving you lots of coding. You normally don’t need to extend the document template class so the standard <code class="calibre23">CSingleDocTemplate</code> class usually suffices in an SDI program. <code class="calibre23">CMultiDocTemplate</code> is the document template class in an MDI program and this is also derived from <code class="calibre23">CDocTemplate</code>. An MDI application also contains an additional class that defines a child window.</p>
<p class="calibre13">The arrows in <a href="#calibre_link-427" class="calibre3">Figure 12-3</a> point from a derived class to a base class. The MFC classes shown here form quite a complex inheritance structure, but these are just a very small part of the complete MFC structure. You need not be concerned about the details of the complete MFC hierarchy, but it is important to have a general appreciation of it if you want to understand what the inherited members of your classes are. You will not see any of the definitions of the base classes in your code, but the inherited members in a derived class are accumulated from the direct base class and each of the indirect base classes in the hierarchy. To determine what members one of your program’s classes has, you need to know from which classes it inherits. After you know that, you can look up its members using the Help facility.</p>
<p class="calibre13">You don’t need to worry about remembering which classes you need to have in your program and what base classes to use in their definition. As you’ll see next, all of this is taken care of for you by Visual C++.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-340" class="calibre3"></a>CREATING MFC APPLICATIONS</h2>
<p class="calibre13">You use four primary tools in the development of your MFC-based Windows programs:</p>
<ol class="calibre5">
<li class="calibre6">An <i class="calibre15">Application Wizard</i> for creating the basic application program code when you start. You use an Application Wizard whenever you create a project.</li>
<li class="calibre6">The <i class="calibre15">project context menu</i> in Class View enables you to add new classes and resources to a project. You display this menu by right-clicking the project name in the Class View pane and using the Add/Class menu item to add a new class. Resources are composed of non-executable data such as bitmaps, icons, menus, and dialog boxes. The Add/Resource menu item from the same menu helps you to add a new resource.</li>
<li class="calibre6">The <i class="calibre15">class context menu</i> in Class View enables you to extend and customize classes in your program. You use the Add/Add Function and Add/Add Variable menu items to do this.</li>
<li class="calibre6">You use a <i class="calibre15">Resource Editor</i> for creating or modifying resources such as menus and toolbars.</li>
</ol>
<p class="calibre13">There are several resource editors; the one you use in any particular situation depends on the kind of resource that you’re editing. You’ll look at editing resources in the next chapter, but for now, let’s jump in and create an MFC application.</p>
<p class="calibre13">Creating an MFC application is just as straightforward as creating a console program; there are just a few more choices along the way. As you have already seen, you start by creating a new project by selecting the File <img src="images/000122.png" alt="image" class="calibre25" /> New <img src="images/000122.png" alt="image" class="calibre25" /> Project menu item, or you can use the shortcut and press Ctrl+Shift+N. The New Project dialog box is displayed, where you can choose MFC as the project type and MFC Application as the template to be used. You also need to enter a name for the project, which can be anything you want &mdash; I’ve used <code class="calibre23">TextEditor</code>. You won’t be developing this particular example into a serious application, so you can use any name you like.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="619" id="calibre_link-1081" class="calibre14"></span>The name that you assign to the project &mdash; <code class="calibre23">TextEditor</code> in this case &mdash; is used as the name of the folder that contains all the project files. It is also used as the basis for creating the names for classes that the Application Wizard generates for your project. When you click OK in the New Project dialog window, you’ll see the MFC Application Wizard dialog, where you can choose options for the application, as shown in <a id="calibre_link-1352" href="#calibre_link-428" class="calibre3">Figure 12-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000087.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-428" href="#calibre_link-1352" class="calibre3">FIGURE 12-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The dialog explains the project settings that are currently in effect, and in the left pane you have a range of options. You can choose any of these to have a look if you want &mdash; you can always get back to the base dialog by selecting the Overview option. Selecting any of the options on the left presents you with a range of further choices, so there are a lot of options in total. I won’t discuss all of them &mdash; I’ll just outline the ones that you are most likely to be interested in and leave you to investigate the others. Selecting Application Type enables you to choose from an SDI application, an MDI application that optionally can be tabbed, a dialog-based application, or an application with multiple top-level documents. Let’s create an SDI application first and explore what some of the choices are.</p>
<section class="toclist">
<h3 class="calibre21">Creating an SDI Application</h3>
<p class="calibre13">Select the Application Type option from the list in the left dialog pane. The default option selected is Multiple documents with the tabbed option, which selects the MDI with each document in its own tabbed page; the appearance of this is shown at the top left in the dialog so that you’ll know what to expect. Select the Single document Application type option, the MFC standard Project style option, and the Windows Native/Default option from the drop-down list of visual styles. The representation for the application that is shown top-left changes to a single window, as shown in <a id="calibre_link-1353" href="#calibre_link-429" class="calibre3">Figure 12-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000100.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-429" href="#calibre_link-1353" class="calibre3">FIGURE 12-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="620" id="calibre_link-1082" class="calibre14"></span>Some of the other options you have for the application type are:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">OPTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">Dialog based</td>
<td class="calibre32">The application window is a dialog window rather than a frame window.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Multiple top-level documents</td>
<td class="calibre32">Documents are displayed in child windows of the desktop rather than child windows of the application as they are with an MDI application.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Document/View architecture support</td>
<td class="calibre32">This option is selected by default so you get code built in to support the document/view architecture. If you uncheck this option, the support is not provided and it’s up to you to implement whatever you want.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Resource language</td>
<td class="calibre32">The list box displays the choices available that apply to resources such as menus and text strings.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Project style</td>
<td class="calibre32">Here you can choose the visual appearance of the application window. Your choice will depend on the environment in which you want to run the application and the kind of application. For example, you would select the Office option for a Microsoft Office&ndash;related application.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="621" id="calibre_link-1083" class="calibre14"></span>If you hover the mouse cursor over any of the options, a tooltip will be displayed explaining the option.</p>
<p class="calibre13">You have several options for the Project style. I’ll select the MFC Standard option and suggest that you do the same. I also selected Windows Native/Default from the Visual style and colors drop-down list. This makes the application appearance the same as your current operating system.</p>
<p class="calibre13">You can also choose how the MFC library is used in your project. The default choice of using the MFC library as a shared DLL (<i class="calibre15">Dynamic Link Library</i>) means that your program links to MFC routines at run time. This reduces the size of the executable file that you’ll generate, but requires the MFC DLL to be on the machine that’s running it. Your application’s <code class="calibre23">.exe</code> module and the MFC <code class="calibre23">.dll</code> together may be bigger than if you statically link the MFC library. If you opt for static linking, the MFC library routines are included in the executable module for your program when it is built. If you keep the default option, several programs running simultaneously using the dynamic link library can all share a single copy of the library in memory.</p>
<p class="calibre13">If you select Document Template Properties in the left pane of the dialog, you can enter a file extension for files that the program creates in the right pane. The extension <code class="calibre23">txt</code> is a good choice for this example. You can also enter a Filter Name, which is the name of the filter that will appear in Open and Save As dialogs to filter the file list so only files with your file extension are displayed.</p>
<p class="calibre13">If you select User Interface Features from the list in the left pane, you get a further set of options that can be included in your application:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">OPTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">Thick Frame</td>
<td class="calibre32">Enables you to resize the application window by dragging a border. It is selected by default.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Minimize box</td>
<td class="calibre32">This is also selected by default and provides a minimize box at the top right of the application window.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Maximize box</td>
<td class="calibre32">This option is also selected by default and provides a maximize box at the top right of the application window.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Minimized</td>
<td class="calibre32">If you select this option, the application starts with the window minimized so it appears as an icon.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Maximized</td>
<td class="calibre32">With this option selected, the application starts with the window maximized.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">System Menu</td>
<td class="calibre32">This provides the main application window with a control-menu box in the title bar.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">About box</td>
<td class="calibre32">This provides your application with an About dialog.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Initial status bar</td>
<td class="calibre32">This adds a status bar at the bottom of the application window containing indicators for CAPS LOCK, NUM LOCK, and SCROLL LOCK and a message line that displays help strings for menus and toolbar buttons. It also adds menu commands to hide or show the status bar.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Split window</td>
<td class="calibre32">This provides a splitter bar for each of the application’s main views.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="622" id="calibre_link-1084" class="calibre14"></span>In the Command bars sub-options you can choose whether you use a classic Windows menu with a docking toolbar, an Internet Explorer style toolbar, a menu bar and toolbar that you can customize at run time, or a ribbon. The User-defined toolbars and images sub-option allows the toolbar and images to be customized at run time. The Personalized menu behavior sub-option enables menus to display only the items used most frequently. You would typically use a ribbon with applications that complement Microsoft Office. In this example, we will use the classic menu with a classic docking toolbar.</p>
<p class="calibre13">You should be aware of a couple of features under the Advanced Features set of options. One is Printing and print preview, which is selected by default, and the other is the number of files on the recent file list. You can increase the latter to whatever you think is useful for the application. Printing and print preview add the standard Page Setup, Print Preview, and Print items to the File menu, and the Application Wizard also provides code to support these functions. You can uncheck all the other options for the example.</p>
<p class="calibre13">The Generated Classes option in the left pane of the dialog displays a list of the classes that will be generated, as shown in <a id="calibre_link-1354" href="#calibre_link-430" class="calibre3">Figure 12-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000061.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-430" href="#calibre_link-1354" class="calibre3">FIGURE 12-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You can highlight any class in the list by clicking it, and the boxes below show the class name, the header filename in which the class definition will be stored, the base class, and the name of the source file containing the implementation of the class. The class definition is always in an <code class="calibre23">.h</code> file, and the member function definitions are always in a <code class="calibre23">.cpp</code> file.</p>
<p class="calibre13">You can alter everything except the base class for the <code class="calibre23">CTextEditorDoc</code> class. The only thing you can change for <code class="calibre23">CTextEditorApp</code> is the class name. Try clicking the other classes in the list. For <code class="calibre23">CMainFrame</code>, you can alter everything except the base class, and for the <code class="calibre23">CTextEditorView</code> class shown in <a href="#calibre_link-430" class="calibre3">Figure 12-6</a>, you can change the base class as well. Click the down arrow to display the list of other classes that you can have as a base class. The capability built into your view class depends on which base class you select:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="623" id="calibre_link-1085" class="calibre14"></span>BASE CLASS</b></th>
<th class="calibre32"><b class="calibre12">VIEW CLASS CAPABILITY</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CEditView</code></td>
<td class="calibre32">Provides simple multiline text-editing capability, including find and replace, and printing.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CFormView</code></td>
<td class="calibre32">Provides a view that is a form; a form is a dialog that can contain controls for displaying data and for input.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CHtmlEditView</code></td>
<td class="calibre32">Extends the <code class="calibre23">CHtmlView</code> class and adds the ability to edit HTML pages.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CHtmlView</code></td>
<td class="calibre32">Provides a view in which web pages and local HTML documents can be displayed.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CListView</code></td>
<td class="calibre32">Enables you to use the document-view architecture with list controls.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CRichEditView</code></td>
<td class="calibre32">Provides the capability to display and edit documents containing rich edit text.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CScrollView</code></td>
<td class="calibre32">Provides a view that automatically adds scrollbars when the data that is displayed requires them.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CTreeView</code></td>
<td class="calibre32">Provides the capability to use the document-view architecture with tree controls.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CView</code></td>
<td class="calibre32">Provides the basic capability for viewing a document.</td>
</tr>
</tbody>
</table>
<p class="calibre13">Because you’ve called the application <code class="calibre23">TextEditor</code>, with the notion that it is able to edit text, choose <code class="calibre23">CEditView</code> to get basic text editing. You can now click Finish to generate the program files for a fully working base program using the options you’ve chosen. This will take a little while.</p>
</section>
<section class="toclist">
<h3 class="calibre21">MFC Application Wizard Output</h3>
<p class="calibre13">All the program files generated by the Application Wizard are stored in the <code class="calibre23">TextEditor</code> project folder, which is a subfolder to the solution folder with the same name. There are resource files in the <code class="calibre23">res</code> subfolder to the project folder. The IDE provides several ways for you to view the information relating to your project:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TAB/PANE</b></th>
<th class="calibre32"><b class="calibre12">CONTENTS</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">Solution Explorer</td>
<td class="calibre32">Shows the files included in your project. The files are categorized in virtual folders with the names <code class="calibre23">Header Files, Resource Files</code>, and <code class="calibre23">Source Files</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Class View</td>
<td class="calibre32">Displays the classes in your project and their members and any global entities. The classes are shown in the upper pane, and the lower pane displays the members for the class selected in the upper pane. By right-clicking entities in Class View, you can display a menu that you can use to view the definition of the entity or where it is referenced.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Resource View</td>
<td class="calibre32">Displays resources such as menu items and toolbar buttons used by your project. Right-clicking a resource displays a menu for editing the resource or adding new resources.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="624" id="calibre_link-1086" class="calibre14"></span>Property Manager</td>
<td class="calibre32">Displays the versions you can build for your project. The debug version includes extra facilities to make debugging easier. The release version results in a smaller executable, and you build this version when your code is fully tested. By right-clicking a version you can display a context menu where you can add a property sheet or display the properties currently set for that version. A property sheet enables you to set options for the compiler and linker.</td>
</tr>
</tbody>
</table>
<p class="calibre13">You can switch to view any of these by selecting from the View menu or clicking on a tab label. If you right-click <code class="calibre23">TextEditor</code> in the Solution Explorer pane and select Properties from the pop-up, the project properties window is displayed, as shown in <a id="calibre_link-1355" href="#calibre_link-431" class="calibre3">Figure 12-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000020.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-431" href="#calibre_link-1355" class="calibre3">FIGURE 12-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The left pane shows the property groups you can select to be displayed in the right pane. Currently, the General group of properties is displayed. You can change the value for a property in the right pane by clicking it and selecting a new value from the drop-down list box to the right of the property name or, in some cases, by entering a new value.</p>
<p class="calibre13">At the top of the property pages window, you can see the current project configuration and the target platform when the project is built. You can change these by selecting from the drop-down list for each. By selecting All Configurations you can change properties for both the Debug and Release configurations.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="625" id="calibre_link-1087" class="calibre14"></span>Viewing Project Files</h4>
<p class="calibre13">The left pane in the IDE can display several tabs. The most useful are the Solution Explorer, Class View, and Resource View tabs. You can hide the currently visible tab by clicking the down arrow in the top right of the pane and selecting Hide from the menu. I’ll just show the three interesting tabs in figures. I’ll also show the pane as an undocked window, which you get by dragging its title bar away from the edge of the main window.</p>
<p class="calibre13">If you select the Solution Explorer tab and expand the list by clicking the arrow symbol for <code class="calibre23">TextEditor</code> files and then click the arrow symbol for each of the Source Files, Header Files, and Resource Files folders, you’ll see the complete list of files for the project, as shown in <a id="calibre_link-1356" href="#calibre_link-432" class="calibre3">Figure 12-8</a>. To collapse any expanded branch of the tree, just click the arrow symbol.</p>
<figure class="calibre16">
<img class="center" src="images/000148.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-432" href="#calibre_link-1356" class="calibre3">FIGURE 12-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">There are a total of 18 files shown in the project, excluding <code class="calibre23">ReadMe.txt</code>. You can view the contents of any file by double-clicking the filename. The contents of the file selected are displayed in the Editor window. Try it out with the <code class="calibre23">ReadMe.txt</code> file. You’ll see that it contains a brief explanation of the contents of each of the files that make up the project. I won’t repeat the descriptions of the files here, because they are very clearly summarized in <code class="calibre23">ReadMe.txt</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Viewing Classes</h4>
<p class="calibre13">The Class View tab is often more convenient than the Solution Explorer tab because classes are the basis for the organization of the application. When you want to look at the code, it’s typically a class definition or the implementation of a member function you want, and from Class View you can go directly to either. The Solution Explorer pane comes in handy when you want to check the <code class="calibre23">#include</code> directives in a <code class="calibre23">.cpp</code> file. From Solution Explorer you can open the file you’re interested in directly.</p>
<p class="calibre13">In the Class View pane, you can expand the <code class="calibre23">TextEditor</code> classes item to show the classes defined for the application. Clicking the name of any class shows the members of that class in the lower pane. In the Class View pane shown in <a id="calibre_link-1357" href="#calibre_link-433" class="calibre3">Figure 12-9</a>, the <code class="calibre23">CTextEditorDoc</code>  class has been selected.</p>
<figure class="calibre16">
<img class="center" src="images/000102.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-433" href="#calibre_link-1357" class="calibre3">FIGURE 12-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The icons characterize the things that are displayed. You will find a key to what the icons indicate in the Class View documentation. Search for “Class View and Object Browser Icons.” You can see that you have the four classes that I discussed earlier that are fundamental to an MFC application: <code class="calibre23">CTextEditorApp</code> for the application, <code class="calibre23">CMainFrame</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="626" id="calibre_link-1088" class="calibre14"></span>for the application frame window, <code class="calibre23">CTextEditorDoc</code> for the document, and <code class="calibre23">CTextEditorView</code> for the view. You also have a <code class="calibre23">CAboutDlg</code> class that defines objects that support the dialog box that appears when you select the menu item Help <img src="images/000122.png" alt="image" class="calibre25" /> About in the application. If you select Global Functions and Variables, you’ll see that it contains three items, as in <a id="calibre_link-1358" href="#calibre_link-434" class="calibre3">Figure 12-10</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000064.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-434" href="#calibre_link-1358" class="calibre3">FIGURE 12-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The application object, <code class="calibre23">theApp</code>, appears twice because there is an <code class="calibre23">extern</code> statement for <code class="calibre23">theApp</code> in <code class="calibre23">TextEditor.h</code> and a definition for it in <code class="calibre23">TextEditor.cpp</code>. If you double-click either of the appearances of <code class="calibre23">theApp</code>, it will take you to the corresponding statement. <code class="calibre23">indicators</code> is an array of four IDs for items that appear in the status bar: a separator, caps lock status, num lock status, and scroll lock status.</p>
<p class="calibre13">To view the code for a class definition double-click the class name in Class View. Similarly, to view the code for a member function, double-click the function name. Note that you can drag the edges of any of the panes in an IDE window to view its contents or your code more easily. You can hide or show the set of panes by clicking the close button at the right end of the pane title bar.</p>
</section>
<section class="toclist">
<h4 class="calibre22">The Class Definitions</h4>
<p class="calibre13">I won’t go into the application classes in complete detail here &mdash; you’ll just get a feel for how they look and I’ll highlight a few important aspects. The precise content of each class that is generated depends on the options you select when creating the project. If you double-click the name of a class in the Class View, the code defining the class is displayed.</p>
<section class="toclist">
<h5 class="calibre27">The Application Class</h5>
<p class="calibre13">Take a look at the application class, <code class="calibre23">CTextEditorApp</code>, first. The definition for this class is shown here:</p>
<pre class="calibre28"><code class="calibre23">// TextEditor.h : main header file for the TextEditor application
//
#pragma once
 
#ifndef __AFXWIN_H__
  #error "include 'stdafx.h' before including this file for PCH"
#endif
 
#include "resource.h"       // main symbols
 
 
// CTextEditorApp:
// See TextEditor.cpp for the implementation of this class
//
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="627" id="calibre_link-1089" class="calibre14"></span>class CTextEditorApp : public CWinApp
{
public:
  CTextEditorApp();
 
 
// Overrides
public:
  virtual BOOL InitInstance();
 
// Implementation
  afx_msg void OnAppAbout();
  DECLARE_MESSAGE_MAP()
};
 
extern CTextEditorApp theApp;</code></pre>
<p class="calibre13">The <code class="calibre23">CTextEditorApp</code> class derives from <code class="calibre23">CWinApp</code> and includes a constructor, a virtual function <code class="calibre23">InitInstance()</code>, a function <code class="calibre23">OnAppAbout()</code>, and a macro <code class="calibre23">DECLARE_MESSAGE_MAP()</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A macro is not C++ code. It’s a name defined by a</i> <code class="calibre23">#define</code> <i class="calibre15">pre-processor directive that will be replaced by some text that will normally be code but could also be constants or symbols of some kind.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The <code class="calibre23">DECLARE_MESSAGE_MAP()</code> macro defines which Windows messages are handled by which member functions of the class. The macro appears in the definition of any class that can process Windows messages. Of course, our application class inherits a lot of functions and data members from the base class, and you will be looking further into these as you expand the program examples. If you look at the beginning of the code for the class definition, you will notice that the <code class="calibre23">#pragma once</code> directive prevents the file being included more than once. Following that is a group of preprocessor directives that ensure that the <code class="calibre23">stdafx.h</code> file is included before this file.</p>
</section>
<section class="toclist">
<h5 class="calibre27">The Frame Window Class</h5>
<p class="calibre13">The application frame window for our SDI program is created by an object of the class <code class="calibre23">CMainFrame</code>, which is defined by the following code:</p>
<pre class="calibre28"><code class="calibre23">// MainFrm.h : interface of the CMainFrame class
//
 
#pragma once
 
class CMainFrame : public CFrameWnd
{
 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="628" id="calibre_link-1090" class="calibre14"></span>protected: // create from serialization only
  CMainFrame();
  DECLARE_DYNCREATE(CMainFrame)
 
// Attributes
public:
 
// Operations
public:
 
// Overrides
public:
  virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
 
// Implementation
public:
  virtual ~CMainFrame();
#ifdef _DEBUG
  virtual void AssertValid() const;
  virtual void Dump(CDumpContext&amp; dc) const;
#endif
 
protected:  // control bar embedded members
  CToolBar          m_wndToolBar;
  CStatusBar        m_wndStatusBar;
 
// Generated message map functions
protected:
  afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
  DECLARE_MESSAGE_MAP()
 
};</code></pre>
<p class="calibre13">This class is derived from <code class="calibre23">CFrameWnd</code>, which provides most of the functionality required for our application frame window. The derived class includes two protected data members &mdash; <code class="calibre23">m_wndToolBar</code>, and <code class="calibre23">m_ wndStatusBar</code>, which are instances of the MFC classes <code class="calibre23">CToolBar</code>, and <code class="calibre23">CStatusBar</code>, respectively. The toolbar provides buttons to access standard menu functions, and the status bar appears at the bottom of the application window.</p>
</section>
<section class="toclist">
<h5 class="calibre27">The Document Class</h5>
<p class="calibre13">The definition of the <code class="calibre23">CTextEditorDoc</code> class that was created is:</p>
<pre class="calibre28"><code class="calibre23">// TextEditorDoc.h : interface of the CTextEditorDoc class
//
 
 
#pragma once
 
 
class CTextEditorDoc : public CDocument
{
protected: // create from serialization only
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="629" id="calibre_link-1091" class="calibre14"></span>CTextEditorDoc();
  DECLARE_DYNCREATE(CTextEditorDoc)
 
// Attributes
public:
 
// Operations
public:
 
// Overrides
public:
  virtual BOOL OnNewDocument();
  virtual void Serialize(CArchive&amp; ar);
#ifdef SHARED_HANDLERS
  virtual void InitializeSearchContent();
  virtual void OnDrawThumbnail(CDC&amp; dc, LPRECT lprcBounds);
#endif // SHARED_HANDLERS
 
// Implementation
public:
  virtual ~CTextEditorDoc();
#ifdef _DEBUG
  virtual void AssertValid() const;
  virtual void Dump(CDumpContext&amp; dc) const;
#endif
 
protected:
 
// Generated message map functions
protected:
  DECLARE_MESSAGE_MAP()
 
#ifdef SHARED_HANDLERS
  // Helper function that sets search content for a Search Handler
  void SetSearchContent(const CString&amp; value);
#endif // SHARED_HANDLERS
 
#ifdef SHARED_HANDLERS
private:
  CString m_strSearchContent;
  CString m_strThumbnailContent;
#endif // SHARED_HANDLERS
};</code></pre>
<p class="calibre13">Most of the meat comes from the base class and is therefore not apparent here. The <code class="calibre23">DECLARE_DYNCREATE()</code> macro that appears after the constructor (and was also used in <code class="calibre23">CMainFrame</code>) enables an object of the class to be created dynamically by synthesizing it from data from a file. When you save an SDI document object, the frame window that contains the view is saved along with your data. This allows everything to be restored when you read it back. Reading and writing a document object to a file is supported by a process called <i class="calibre15">serialization</i>. You will see how to serialize your own documents and then read them back in the examples we will develop.</p>
<p class="calibre13">The document class also includes the <code class="calibre23">DECLARE_MESSAGE_MAP()</code> macro to enable Windows messages to be handled by class member functions.</p>
</section>
<section class="toclist">
<h5 class="calibre27"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="630" id="calibre_link-1092" class="calibre14"></span>The View Class</h5>
<p class="calibre13">The view class in our SDI application is defined as:</p>
<pre class="calibre28"><code class="calibre23"> 
// TextEditorView.h : interface of the CTextEditorView class
//
 
#pragma once
 
 
class CTextEditorView : public CEditView
{
protected: // create from serialization only
  CTextEditorView();
  DECLARE_DYNCREATE(CTextEditorView)
 
// Attributes
public:
  CTextEditorDoc* GetDocument() const;
 
// Operations
public:
 
// Overrides
public:
  virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
protected:
  virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
  virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
  virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
 
// Implementation
public:
  virtual ~CTextEditorView();
#ifdef _DEBUG
  virtual void AssertValid() const;
  virtual void Dump(CDumpContext&amp; dc) const;
#endif
 
protected:
 
// Generated message map functions
protected:
  DECLARE_MESSAGE_MAP()
};
 
#ifndef _DEBUG  // debug version in TextEditorView.cpp
inline CTextEditorDoc* CTextEditorView::GetDocument() const
   { return reinterpret_cast&lt;CTextEditorDoc*&gt;(m_pDocument); }
#endif</code></pre>
<p class="calibre13">As you specified in the Application Wizard dialog, the view class is derived from <code class="calibre23">CEditView</code>, which already includes basic text handling facilities. The <code class="calibre23">GetDocument()</code> function returns a pointer to the document object corresponding to the view, and you use this to access data in the document object <span {http://www.idpf.org/2007/ops}type="pagebreak" title="631" id="calibre_link-1093" class="calibre14"></span>when you add your own extensions to the view class that allow user interactions to add to or modify the document data.</p>
<p class="calibre13">There are two implementations for the <code class="calibre23">GetDocument()</code> member of the <code class="calibre23">CTextEditorView</code> class in the code generated by Application Wizard. The one in the <code class="calibre23">.cpp</code> file is used for the debug version of the program. You will normally use this during program development because it provides validation of the pointer value stored for the document. (This is stored in the inherited data member <code class="calibre23">m_pDocument</code> in the view class.) The version that applies to the release version of your program you can find after the class definition in <code class="calibre23">TextEditorView.h</code>. This version is declared as <code class="calibre23">inline</code> and it does not validate the document pointer. The <code class="calibre23">GetDocument()</code> function provides the view object with access to the document object. You can call any of the functions in the interface to the document class using the pointer to the document that the function returns.</p>
<p class="calibre13">By default, you have debug capability included. As well as the special version of <code class="calibre23">GetDocument()</code>, there are lots of checks in the MFC code that are included in this case. If you want to change this, you can use the drop-down list box in the Build toolbar to choose the release configuration, which doesn’t contain the debug code.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Creating an Executable Module</h4>
<p class="calibre13">To compile and link the program, you can click Build <img src="images/000122.png" alt="image" class="calibre25" /> Build Solution, or press F7, or click the Build icon in the toolbar.</p>
<p class="calibre13">The first time you compile and link a program, it will take some time. The second and subsequent times should be quite a bit faster because of <i class="calibre15">precompiled headers</i>. During the initial compilation, the compiler saves the output from compiling header files included in stdafx.cpp. in a file with the extension <code class="calibre23">.pch</code>. On subsequent builds, if the source in a header has not changed, the compiler will skip compiling the header and use the precompiled code, thus saving the compilation time for the header.</p>
<p class="calibre13">You can determine whether or not precompiled headers are used and control how they are handled through the Properties dialog. Right-click <code class="calibre23">TextEditor</code> in Class View and select Properties from the menu. If you expand the C/C++ node, you can select Precompiled Headers to set or unset this property.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Running the Program</h4>
<p class="calibre13">To execute the program, press Ctrl+F5. Because you chose <code class="calibre23">CEditView</code> as the base class for the <code class="calibre23">CTextEditorView</code> class, the program is a fully functioning, simple text editor. You can enter text in the window, as shown in <a id="calibre_link-1359" href="#calibre_link-435" class="calibre3">Figure 12-11</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000023.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-435" href="#calibre_link-1359" class="calibre3">FIGURE 12-11</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Note that the application has scroll bars for viewing text outside the visible area within the window, and, of course, you can resize the window by dragging the boundaries. All the items under all menus are fully operational so you can save and retrieve files, you can cut and paste text, and you can print the text in <span {http://www.idpf.org/2007/ops}type="pagebreak" title="632" id="calibre_link-1094" class="calibre14"></span>the window &mdash; and all that without writing a single line of code! As you move the cursor over the toolbar buttons or the menu options, prompts appear in the status bar describing their functions, and if you let the cursor linger on a toolbar button, a tooltip is displayed showing its purpose. (You’ll learn about tooltips in more detail in Chapter 13.)</p>
</section>
<section class="toclist">
<h4 class="calibre22">How the Program Works</h4>
<p class="calibre13">The application object is created at global scope. You can see this if you expand Global Functions and Variables in Class View and double-click the second <code class="calibre23">theApp</code>. In the Editor window, you’ll see this statement:</p>
<pre class="calibre28"><code class="calibre23">CTextEditorApp theApp;</code></pre>
<p class="calibre13">This declares <code class="calibre23">theApp</code> as an instance of our application class <code class="calibre23">CTextEditorApp</code>. The statement is in <code class="calibre23">TextEditor.cpp</code>, which also contains member function definitions for the application class, and the definition of the <code class="calibre23">CAboutDlg</code> class.</p>
<p class="calibre13">After <code class="calibre23">theApp</code> has been created, the MFC-supplied <code class="calibre23">WinMain()</code> function is called. This calls two member functions of the <code class="calibre23">theApp</code> object. First, it calls <code class="calibre23">InitInstance()</code>, which provides any initialization of the application that is necessary, and then the <code class="calibre23">Run()</code>function that is inherited from <code class="calibre23">CWinApp</code>, which provides initial handling for Windows messages. If you want to see the code for <code class="calibre23">CWinApp</code> functions, extend the tree for <code class="calibre23">CTextEditorApp</code> in Class View and extend <code class="calibre23">Base Types</code>. You can then click on <code class="calibre23">CWinApp</code> to see the members in the lower pane. <code class="calibre23">WinMain()</code> does not appear explicitly in the project source code, because it is supplied by the MFC class library and is called automatically when the application starts.</p>
<section class="toclist">
<h5 class="calibre27">The InitInstance() Function</h5>
<p class="calibre13">You can access the code for the <code class="calibre23">InitInstance()</code> function by double-clicking its entry in Class View after highlighting <code class="calibre23">CTextEditorApp</code> &mdash; or, if you’re in a hurry, you can just look at the code immediately following the line defining the <code class="calibre23">theApp</code> object. There’s a lot of code in the version created by the Application Wizard, so I just want to remark on a couple of fragments in this function. The first is:</p>
<pre class="calibre28"><code class="calibre23">  SetRegistryKey(_T("Local AppWizard-Generated Applications"));
  LoadStdProfileSettings(4);  // Load standard INI file options (including MRU)</code></pre>
<p class="calibre13">The string passed to the <code class="calibre23">SetRegistryKey()</code> function defines a registry key under which program information is stored. You can change this to whatever you want. If I changed the argument to <code class="calibre23">"Horton",</code> information about our program would be stored under the registry key:</p>
<pre class="calibre28"><code class="calibre23">HKEY_CURRENT_USER\Software\Horton\TextEditor\</code></pre>
<p class="calibre13">All the application settings are stored under this key, including the most recently used files list. The call to <code class="calibre23">LoadStdProfileSettings()</code> loads the application settings that were saved last time around. Of course, the first time you run the program, there aren’t any.</p>
<p class="calibre13">A document template object is created dynamically within <code class="calibre23">InitInstance()</code> by the statement:</p>
<pre class="calibre28"><code class="calibre23">pDocTemplate = new CSingleDocTemplate(
    IDR_MAINFRAME,
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="633" id="calibre_link-1095" class="calibre14"></span>RUNTIME_CLASS(CTextEditorDoc),
    RUNTIME_CLASS(CMainFrame),       // main SDI frame window
    RUNTIME_CLASS(CTextEditorView));</code></pre>
<p class="calibre13">The first parameter to the <code class="calibre23">CSingleDocTemplate</code> constructor is a symbol, <code class="calibre23">IDR_MAINFRAME</code>, which defines the menu and toolbar to be used with the document type. The following three parameters define the document, the mainframe window, and the View Class objects that are to be bound together within the document template. Because you have an SDI application here, there is only one of each in the program, managed through one document template object. <code class="calibre23">RUNTIME_CLASS()</code> is a macro that enables the type of a class object to be determined at run time.</p>
<p class="calibre13">There’s a lot of other stuff here for setting up the application instance that you need not worry about. You can add any initialization of your own that you need for the application to the <code class="calibre23">InitInstance()</code> function.</p>
</section>
<section class="toclist">
<h5 class="calibre27">The Run() Function</h5>
<p class="calibre13">The <code class="calibre23">CTextEditorApp</code> class inherits the <code class="calibre23">Run()</code> function from <code class="calibre23">CWinApp</code>. Because the function is declared as <i class="calibre15">virtual</i>, you could replace the inherited version with your own, but this is not usually necessary. <code class="calibre23">Run()</code> receives all the messages from Windows destined for the application and ensures that each message is passed to the function designated to service it, if one exists. Therefore, this function continues executing as long as the application runs.</p>
<p class="calibre13">You can boil the operation of the application down to four steps:</p>
<ol class="calibre5">
<li class="calibre6">Creating an application object, <code class="calibre23">theApp</code>.</li>
<li class="calibre6">Executing <code class="calibre23">WinMain()</code>, which is supplied by MFC.</li>
<li class="calibre6"><code class="calibre23">WinMain()</code> calling <code class="calibre23">InitInstance()</code>, which creates the document template, the mainframe window, the document, and the view.</li>
<li class="calibre6"><code class="calibre23">WinMain()</code> calling <code class="calibre23">Run()</code>, which executes the main message loop to acquire and dispatch Windows messages.</li>
</ol>
</section>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Creating an MDI Application</h3>
<p class="calibre13">Now let’s create an MDI application using the MFC Application Wizard. Press Ctrl+Shift+N and give the project the name <code class="calibre23"><b class="calibre12">Sketcher</b></code> &mdash; and plan on keeping it. You’ll be expanding this into a sketching program during subsequent chapters. You should have no trouble with this procedure, because there are only a few things that you need to do differently from creating the SDI application.</p>
<ol class="calibre5">
<li class="calibre6">For the Application Type group of options:
<ul class="chapterfeaturinglist">
<li class="calibre6">Leave the default option, Multiple documents, but opt out of Tabbed documents.</li>
<li class="calibre6">Keep Document/View architecture support.</li>
<li class="calibre6">Select MFC standard as the project style and Windows Native/Default as the Visual style and colors option.</li>
</ul></li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="634" id="calibre_link-1096" class="calibre14"></span>Compound Document Support options should be the default selection, <code class="calibre23">None</code>.</li>
<li class="calibre6">For the Document Template Properties set of options in the dialog:
<ul class="chapterfeaturinglist">
<li class="calibre6">Specify the file extension as <code class="calibre23">ske</code>. You’ll see that you automatically get a filter for <code class="calibre23">*.ske</code> documents defined.</li>
<li class="calibre6">Change the <code class="calibre23">Doc</code> type name to <code class="calibre23">Sketch</code>.</li>
<li class="calibre6">Change the <code class="calibre23">File new</code> short name to <code class="calibre23">Sketch</code>.</li>
</ul></li>
<li class="calibre6">Leave the Database Support options at the default settings, <code class="calibre23">None</code>.</li>
<li class="calibre6">For the User Interface Features options:
<ul class="chapterfeaturinglist">
<li class="calibre6">Keep Use a classic menu, and the sub-option, Use a classic docking toolbar.</li>
<li class="calibre6">Keep the other options that are selected by default: Thick frame, Minimize box, Maximize box, System menu, Initial status bar, Child minimize box and Child maximize box.</li>
</ul></li>
<li class="calibre6">For the Advanced features set of options:
<ul class="chapterfeaturinglist">
<li class="calibre6">Keep the Printing and print preview option.</li>
<li class="calibre6">Deselect ActiveX controls, and Support Restart Manager.</li>
</ul></li>
<li class="calibre6">Leave the Generated Classes options at the default settings so the base class for the <code class="calibre23">CSketcherView</code> class is <code class="calibre23">CView</code>.</li>
</ol>
<p class="calibre13">You can see in the dialog with Generated Classes selected that you get an extra class for your application compared with the <code class="calibre23">TextEditor</code> example, the <code class="calibre23">CChildFrame</code> class, which is derived from <code class="calibre23">CMDIChildWnd</code>. This class provides a frame window for a view of the document that appears inside the application window created by a <code class="calibre23">CMainFrame</code> object. With an SDI application, there is a single document with a single view, so the view is displayed in the client area of the mainframe window. In an MDI application, you can have multiple documents open, and each document can have multiple views. To provide for this, each document view has its own child frame window created by a <code class="calibre23">CChildFrame</code> object. As you saw earlier, a view is displayed in a separate window, but one which exactly fills the client area of a frame window. Finally, click Finish to generate the project.</p>
<section class="toclist">
<h4 class="calibre22">Running the Program</h4>
<p class="calibre13">You can build and run the program by pressing Ctrl+F5. You get the application window shown in <a id="calibre_link-1360" href="#calibre_link-436" class="calibre3">Figure 12-12</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000054.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-436" href="#calibre_link-1360" class="calibre3">FIGURE 12-12</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">In addition to the main application window, you have a separate document window with the caption Sketch1. <code class="calibre23">Sketch1</code> is the default name for the initial document, and it has the extension<code class="calibre23">.ske</code> if you save it. You can create additional views for <span {http://www.idpf.org/2007/ops}type="pagebreak" title="635" id="calibre_link-1097" class="calibre14"></span>the document by selecting the Window <img src="images/000122.png" alt="image" class="calibre25" /> New Window menu option. You can also create a new document by selecting File <img src="images/000122.png" alt="image" class="calibre25" /> New, so that there will be two active documents in the application. The situation with two views open for a document, is shown in <a id="calibre_link-1361" href="#calibre_link-437" class="calibre3">Figure 12-13</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000026.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-437" href="#calibre_link-1361" class="calibre3">FIGURE 12-13</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You can expand either sketch window to fill the client area. You can then switch between the sketch windows through the Window drop-down menu. You can’t yet actually create any data in the application because we haven’t added any code to do that, but all the code for creating documents and views has already been included by the Application Wizard.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-341" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter, you’ve been concerned with the mechanics of using the MFC Application Wizard. You have seen the basic components of the MFC programs that the Application Wizard generates for both SDI and MDI applications. All our MFC examples are created by the MFC Application Wizard, so it’s a good idea to keep the general structure and broad class relationships in mind. You probably won’t feel comfortable with the details at this point, but don’t worry about that. You’ll find it becomes much clearer after you begin developing applications in the succeeding chapters.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<p class="calibre13">It isn’t possible to give programming examples for this chapter, because it really just introduced the basic mechanics of creating MFC applications. There aren’t solutions to all the exercises because you will either see the answer for yourself on the screen, or be able to check your answer with the text.</p>
<ol class="calibre5">
<li class="calibre6">What is the relationship between a document and a view?</li>
<li class="calibre6">What is the purpose of the document template in an MFC Windows program?</li>
<li class="calibre6">Why do you need to be careful, and plan your program structure in advance, when using the Application Wizard?</li>
<li class="calibre6">Code up the simple text editor program. Build both debug and release versions, and examine the types and sizes of the files produced in each case.</li>
<li class="calibre6">Generate the text editor application several times, trying different project styles from the Application Type in Application Wizard.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="636" id="calibre_link-1098" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The Application Wizard</b></td>
<td class="calibre32">The MFC Application Wizard generates a complete, working, framework Windows application for you to customize to your requirements.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">SDI and MDI programs</b></td>
<td class="calibre32">The Application Wizard can generate single-document interface (SDI) applications that work with a single document and a single view, or multiple-document interface (MDI) programs that can handle multiple documents with multiple views simultaneously.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Classes in SDI programs</b></td>
<td class="calibre32">The four essential classes in an SDI application that are derived from the foundation classes are the application class, the frame window class, the document class, and the view class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The application object</b></td>
<td class="calibre32">A program can have only one application object. This is defined automatically by the Application Wizard at global scope.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Document objects</b></td>
<td class="calibre32">A document class object stores application-specific data, and a view class object displays the contents of a document object.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Document templates</b></td>
<td class="calibre32">A document template class object is used to tie together a document, a view, and a window. For an SDI application, a <code class="calibre23">CSingleDocTemplate</code> class does this, and for an MDI application, the <code class="calibre23">CMultiDocTemplate</code> class is used. These are both foundation classes, and application-specific versions do not normally need to be derived.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-70">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2326" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="637" id="calibre_link-1099" class="calibre9"></span><span class="chapternumber">Chapter 13</span><br class="calibre10" /><span class="chapternumber">Working with Menus and Toolbars</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How an MFC-based program handles messages</li>
<li class="calibre6">How you create and modify menu resources</li>
<li class="calibre6">How you create and modify menu properties</li>
<li class="calibre6">How to create functions to service menu messages</li>
<li class="calibre6">How to add handlers to update menu properties</li>
<li class="calibre6">How to add toolbar buttons associated with menu items</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 13 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-342" class="calibre3"></a>COMMUNICATING WITH WINDOWS</h2>
<p class="calibre13">Windows communicates with your program by sending messages to it. Most of the drudgery of message handling is taken care of in an MFC application, so you don’t have to worry about providing a <code class="calibre23">WndProc()</code> function. The MFC enables you to provide functions to handle the individual messages that you’re interested in and to ignore the rest. These functions are referred to as <i class="calibre15">message handlers</i> or just <i class="calibre15">handlers</i>. In an MFC-based program, a message handler is always a member of one of your application’s classes.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="638" id="calibre_link-1100" class="calibre14"></span>The association between a particular message and a function in your program that is to service it is established by a <i class="calibre15">message map</i>, and each class in your program that handles Windows messages will have one. A message map is a table of member functions that handle messages bounded by a couple of macros. The start of a message map is indicated by a <code class="calibre23">BEGIN_MESSAGE_MAP()</code> macro, and the end is marked by an <code class="calibre23">END_MESSAGE_MAP()</code> macro. Each entry in the message map associates a member function with a particular message; when a given message occurs, the corresponding function is called. Only the messages that are relevant to a class appear in its message map.</p>
<p class="calibre13">A message map for a class is created by the MFC Application Wizard when you create a project, or by <code class="calibre23">Class Wizard</code> when you add a class that handles messages. Additions to, and deletions from, a message map are mainly managed by <code class="calibre23">Class Wizard</code>, but there are circumstances in which you need to modify a message map manually. Let’s look into how a message map operates using the Sketcher example.</p>
<section class="toclist">
<h3 class="calibre21">Understanding Message Maps</h3>
<p class="calibre13">A message map is established by the MFC Application Wizard for each class in your program. In Sketcher <code class="calibre23">CSketcherApp, CSketcherDoc, CSketcherView, CMainFrame</code>, and <code class="calibre23">CChildFrame</code> each have a message map. The message map for a class appears in the <code class="calibre23">.cpp</code> file. Of course, the functions that are in the message map are also declared in the class, but they are identified in the message map in a special way. Look at the definition for <code class="calibre23">CSketcherApp</code> in <code class="calibre23">Sketcher.h</code>:</p>
<pre class="calibre28"><code class="calibre23">class CSketcherApp : public CWinApp
{
public:
  CSketcherApp();
 
 
// Overrides
public:
  virtual BOOL InitInstance();
  virtual int ExitInstance();
 
// Implementation
  <b class="calibre12">afx_msg void OnAppAbout();</b>
  <b class="calibre12">DECLARE_MESSAGE_MAP()</b>
};</code></pre>
<p class="calibre13"><code class="calibre23">OnAppAbout()</code> is the only message handler declared in the class. The <code class="calibre23">afx_msg</code> at the beginning of the line declaring the <code class="calibre23">OnAppAbout()</code> function identifies it as a message handler. <code class="calibre23">afx_msg</code> has no other purpose and is converted to white space by the preprocessor, so it has no effect when the program is compiled.</p>
<p class="calibre13">The <code class="calibre23">DECLARE_MESSAGE_MAP()</code> macro indicates that the class can contain members that are message handlers and therefore will have a message map in the <code class="calibre23">.cpp</code> file. Any class that has <code class="calibre23">CCmdTarget</code> as a direct or indirect base class can have message handlers, so such classes will always have this macro included as part of the class definition, either by the MFC Application Wizard or by the Add Class Wizard that you use to add a new class. The <code class="calibre23">CSketcherApp</code> class has <code class="calibre23">CCmdTarget</code> as an indirect <span {http://www.idpf.org/2007/ops}type="pagebreak" title="639" id="calibre_link-1101" class="calibre14"></span>base and therefore always includes the <code class="calibre23">DECLARE_MESSAGE_MAP()</code> macro. All the other application classes in Sketcher are ultimately derived from <code class="calibre23">CCmdTarget</code> too, so they all can handle messages.</p>
<p class="calibre13">When you add your own members directly to a class, it’s best to leave the <code class="calibre23">DECLARE_MESSAGE_MAP()</code> macro as the last line in the class definition. If you do add members after <code class="calibre23">DECLARE_MESSAGE_MAP()</code>, you’ll need to include an access specifier for them: <code class="calibre23">public, protected</code>, or <code class="calibre23">private</code>.</p>
<section class="toclist">
<h4 class="calibre22">Message Handler Definitions</h4>
<p class="calibre13">A class definition that includes the <code class="calibre23">DECLARE_MESSAGE_MAP()</code> macro will have the <code class="calibre23">BEGIN_MESSAGE_MAP()</code> and <code class="calibre23">END_MESSAGE_MAP()</code> macros in its <code class="calibre23">.cpp</code> file. If you look in <code class="calibre23">Sketcher.cpp</code>, you’ll see the following code as part of the implementation of <code class="calibre23">CSketcherApp</code>:</p>
<pre class="calibre28"><code class="calibre23">BEGIN_MESSAGE_MAP(CSketcherApp, CWinApp)
  ON_COMMAND(ID_APP_ABOUT, &amp;CSketcherApp::OnAppAbout)
  // Standard file based document commands
  ON_COMMAND(ID_FILE_NEW, &amp;CWinApp::OnFileNew)
  ON_COMMAND(ID_FILE_OPEN, &amp;CWinApp::OnFileOpen)
  // Standard print setup command
  ON_COMMAND(ID_FILE_PRINT_SETUP, &amp;CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()</code></pre>
<p class="calibre13">This is a message map. The <code class="calibre23">BEGIN_MESSAGE_MAP()</code> and <code class="calibre23">END_MESSAGE_MAP()</code> macros define its boundaries, and each message handler in the class appears between these macros. These message handlers are all dealing with the same type of message, <code class="calibre23">WM_COMMAND</code> messages. These are called <i class="calibre15">command messages</i>. A command message is generated when the user selects a menu option or enters an accelerator key. (There’s another kind of <code class="calibre23">WM_COMMAND</code> message called a <i class="calibre15">control notification message</i>, which provides information about the activity of a control.)</p>
<p class="calibre13">The message map identifies the menu item or key press that will cause a handler to be called by an identifier (ID) that’s included in the message handler macro. There are four <code class="calibre23">ON_COMMAND</code> macros in the preceding code, one for each of the command messages to be handled by the <code class="calibre23">CSketcherApp</code> object. The first argument to an <code class="calibre23">ON_COMMAND</code> macro is an ID identifying a particular command source, and the macro ties the address of a function (i.e., a pointer to a function) to commands originating from the source specified by the ID. Thus, when a command message corresponding to the identifier <code class="calibre23">ID_APP_ABOUT</code> is received, the <code class="calibre23">OnAppAbout()</code> function is called. Similarly, for a command message corresponding to the <code class="calibre23">ID_FILE_NEW</code> identifier, <code class="calibre23">OnFileNew()</code> is called. This handler is inherited from the base class, <code class="calibre23">CWinApp</code>, as are the two remaining handlers.</p>
<p class="calibre13">The <code class="calibre23">BEGIN_MESSAGE_MAP()</code> macro has two arguments. The first identifies the class name for which the message map is defined, and the second identifies the base class that will be searched for a message handler when a handler isn’t found in the class that defined the message map.</p>
<p class="calibre13">Command IDs for messages from standard menu items and toolbar buttons such as <code class="calibre23">ID_APP_ABOUT</code> are defined in the MFC. The <code class="calibre23">ID_</code> prefix identifies a command as associated with a menu item or a toolbar button, as you’ll see when I discuss resources later. For example, <code class="calibre23">ID_FILE_NEW</code> is the ID that corresponds to the selection of the File <img src="images/000122.png" alt="image" class="calibre25" /> New menu item, and <code class="calibre23">ID_APP_ABOUT</code> corresponds to Help <img src="images/000122.png" alt="image" class="calibre25" /> About.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="640" id="calibre_link-1102" class="calibre14"></span>The <code class="calibre23">WM_</code> prefix for message IDs stands for “Windows message.” There are many other identifiers for Windows messages and these are defined in <code class="calibre23">Winuser.h</code> along with a lot of other stuff. This header is included in <code class="calibre23">Windows.h</code>. If you want to look at the message IDs, you’ll find <code class="calibre23">Winuser.h</code> in the <code class="calibre23">C:\Program Files (x86)\Windows Kits\8.1\Include\um</code> folder.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">There’s a nice shortcut for viewing any</i> <code class="calibre23">.h</code> <i class="calibre15">file that appears in an</i> <code class="calibre23">#include</code> <i class="calibre15">directive in the editor window &mdash; you can right-click the name and select Open Document “Filename.h” from the menu. This works with standard library header files as well as those you have created.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Windows messages often have additional data values that refine the identification of a particular message specified by a given ID. The <code class="calibre23">WM_COMMAND</code> message, for instance, is sent for a range of commands, including those originating from the selection of a menu item or a toolbar button.</p>
<p class="calibre13">When you are adding message handlers manually, you should not map a message (or, in the case of command messages, a command ID) to more than one message handler. If you do, it won’t break anything, but the second message handler is never called. Normally, you add message handlers through the Properties window for a class, and in this case you will not be able to map a message to more than one handler. To see the Properties window for a class such as <code class="calibre23">CSketcherApp</code>, right-click its name in Class View and select Properties from the menu. You add a message handler by selecting the Messages button at the top of the Properties window that is displayed (see <a id="calibre_link-72" href="#calibre_link-71" class="calibre3">Figure 13-1</a>). To determine which button is the Messages button, simply hover the cursor over each button until the tooltip displays.</p>
<figure class="calibre16">
<img class="center" src="images/000003.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-71" href="#calibre_link-72" class="calibre3">FIGURE 13-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Clicking the Messages button brings up a list of message IDs; however, before I go into what you do next, I’ll explain a little more about the types of messages you may be handling.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Message Categories</h3>
<p class="calibre13">Many Windows messages are identified by an ID with the prefix <code class="calibre23">WM_</code>. There are many categories, and the category to which a message belongs determines how it is handled. The categories of Windows messages that your program may be dealing with include:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">MESSAGE CATEGORY</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">Standard Windows messages</td>
<td class="calibre32">These are Windows messages that begin with the <code class="calibre23">WM_</code> prefix other than <code class="calibre23">WM_COMMAND</code> messages. Examples of these messages are <code class="calibre23">WM_PAINT</code>, which indicates that you need to redraw the client area of a window, and <code class="calibre23">WM_LBUTTONUP</code>, which signals that the left mouse button has been released.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="641" id="calibre_link-1103" class="calibre14"></span>Control notification messages</td>
<td class="calibre32">These are <code class="calibre23">WM_COMMAND</code> messages sent from controls (such as a list box) to the window that created the control or from a child window to a parent window. Parameters associated with a <code class="calibre23">WM_COMMAND</code> message enable messages from the controls in your application to be differentiated.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Command messages</td>
<td class="calibre32">These are <code class="calibre23">WM_COMMAND</code> messages that originate from user interface elements such as menu items and toolbar buttons. MFC defines unique identifiers for standard menu and toolbar command messages.</td>
</tr>
</tbody>
</table>
<p class="calibre13">You’ll be writing handlers for standard Windows messages in the first category in the next chapter. The messages in the second category are a group of <code class="calibre23">WM_COMMAND</code> messages that you’ll see in Chapter 16 when you work with dialogs. You’ll deal with command messages originating from menus and toolbars in this chapter. In addition to the message IDs defined by the MFC for standard menus and toolbars, you can define your own message IDs for menus and toolbar buttons that you create. If you don’t supply IDs for these, MFC generates IDs based on the menu text.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Handling Messages in Your Program</h3>
<p class="calibre13">You can’t put message handlers anywhere you like. The classes where you can implement a handler depend on the kind of message. The first two categories in the previous section  &mdash; standard Windows messages and control notification messages &mdash; are always handled by objects of classes that are ultimately derived from <code class="calibre23">CWnd</code>. Frame window classes and view classes, for example, have <code class="calibre23">CWnd</code> as an indirect base class, so they can handle Windows messages and control notification messages. Application classes, document classes, and document template classes are not derived from <code class="calibre23">CWnd</code>, so they can’t handle these messages.</p>
<p class="calibre13">Using the Properties window for a class to add a handler solves the problem of remembering where to place handlers, because it only offers you the IDs allowed for the class. For example, you won’t be offered any of the <code class="calibre23">WM_</code> messages in the Properties window for the <code class="calibre23">CSketcherDoc</code> class.</p>
<p class="calibre13">The <code class="calibre23">CWnd</code> class provides default message handling for standard Windows messages. If your class doesn’t include a handler for one of these, it will be processed by the default handler in <code class="calibre23">CWnd</code>. If you do provide a handler you sometimes still need to call the base class handler from your handler to ensure that the message is processed properly. When you’re creating your own handler through the Properties window for a class, a skeleton implementation is provided that includes a call to the base handler where necessary.</p>
<p class="calibre13">You have much more flexibility with handling command messages than you have with standard Windows messages. You can put handlers for command messages in the application class, the document and document template classes, and in the window and view classes. So what happens when a command message is sent to your application, bearing in mind that there are a lot of options as to where it is handled?</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="642" id="calibre_link-1104" class="calibre14"></span>How Command Messages Are Processed</h4>
<p class="calibre13">All command messages are sent to the main frame window for the application. The main frame window then tries to get the message handled by routing it in a specific sequence to the classes in your program. If one class can’t process the message, the main frame window passes it on to the next.</p>
<p class="calibre13">For an SDI program, the sequence in which classes are offered an opportunity to handle a command message is:</p>
<ol class="calibre5">
<li class="calibre6">The view object</li>
<li class="calibre6">The document object</li>
<li class="calibre6">The document template object</li>
<li class="calibre6">The main frame window object</li>
<li class="calibre6">The application object</li>
</ol>
<p class="calibre13">The view object is given the opportunity to handle a command message first, and, if no handler has been defined, the next class object has a chance to process it. If none of the classes has a handler defined, default Windows processing takes care of it, essentially throwing the message away.</p>
<p class="calibre13">For an MDI program, things are only a little more complicated. Although you have the possibility of multiple documents, each with multiple views, only the active view and its associated document are involved in the routing of a command message. The sequence for routing a command message in an MDI program is:</p>
<ol class="calibre5">
<li class="calibre6">The active view object</li>
<li class="calibre6">The document object associated with the active view</li>
<li class="calibre6">The document template object for the active document</li>
<li class="calibre6">The frame window object for the active view</li>
<li class="calibre6">The main frame window object</li>
<li class="calibre6">The application object</li>
</ol>
<p class="calibre13">It’s possible to alter the sequence for routing messages, but this is so rarely necessary that I won’t go into it in this book.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-343" class="calibre3"></a>EXTENDING THE SKETCHER PROGRAM</h2>
<p class="calibre13">You’re going to add code to the Sketcher program you created in the previous chapter to implement the functionality you need to create sketches. You’ll provide code for drawing lines, circles, rectangles, and curves with various colors and line thicknesses, and for adding annotations to a sketch. The data for a sketch will be stored in a document object, and you’ll allow multiple views of the same document at different scales.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="643" id="calibre_link-1105" class="calibre14"></span>It will take several chapters to learn how to add everything that I’ve described. A good starting point would be to add menu items to enable you to choose the type of element that you want to draw, and to select a drawing color. You’ll make the element type and color selection persistent, which means that once a color and an element type has been selected, they will remain in effect until you choose another color or element type.</p>
<p class="calibre13">You’ll work through the following steps to add menus to Sketcher:</p>
<ol class="calibre5">
<li class="calibre6">Define the menu items that will appear on the main menu bar and the items in each of the corresponding drop-down menus.</li>
<li class="calibre6">Decide which class will handle messages for each menu item.</li>
<li class="calibre6">Add message handling functions to the class for the menu messages.</li>
<li class="calibre6">Add functions to the class that update the appearance of the menus to show the current selection in effect.</li>
<li class="calibre6">Add a toolbar button complete with tooltips for each menu item.</li>
</ol>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-344" class="calibre3"></a>ELEMENTS OF A MENU</h2>
<p class="calibre13">You’ll look at two aspects of dealing with menus: the creation and modification of the menu as it appears in your application, and the processing necessary when a menu item is selected &mdash; the definition of a message handler for it. Let’s look first at how you create new menu items.</p>
<section class="toclist">
<h3 class="calibre21">Creating and Editing Menu Resources</h3>
<p class="calibre13">Menus and other user interface elements are defined separately from the program code in a <i class="calibre15">resource file</i>, and the specification of an interface element is referred to as a <i class="calibre15">resource</i>. You can include many kinds of resources in your application: typical examples are menus, icons, dialogs, toolbars, and toolbar buttons. You’ll be seeing more on these as you extend Sketcher.</p>
<p class="calibre13">Having a menu defined by a resource allows you to change the physical appearance of the menu without affecting the code that processes menu messages. For example, you could change your menu items from English to French, or Norwegian or whatever, without having to modify or recompile the program code. The code to handle a message doesn’t need to be concerned with how the menu looks, only with the fact that it was selected. Of course, if you do add items to a menu, you must add code to handle messages for each of them to ensure that they actually do something!</p>
<p class="calibre13">Sketcher already has a menu, which means that it already has a resource file and menu resources. You can access the resource file contents for Sketcher by selecting the Resource View pane, or, if you have the Solution Explorer pane displayed, you can double-click <code class="calibre23">Sketcher.rc</code>. This switches you to the Resource View, which displays the resources. If you display the menu resources by double-clicking <code class="calibre23">Menu</code>, you’ll see that it includes menus with the identifiers <code class="calibre23">IDR_MAINFRAME</code> and <code class="calibre23">IDR_SketchTYPE</code>. The <code class="calibre23">IDR_MAINFRAME</code> menu will be displayed when there are no documents open in the application, and the <code class="calibre23">IDR_SketchTYPE</code> menu will be displayed when you have a document open. The <code class="calibre23">IDR_</code> prefix identifies a resource that defines a complete menu for a window.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="644" id="calibre_link-1106" class="calibre14"></span>You’re only going to modify the menu that has the identifier <code class="calibre23">IDR_SketchTYPE</code>. You don’t need to change <code class="calibre23">IDR_MAINFRAME</code>, because your new menu items will be relevant only when a document is open. You can open a resource editor for a menu by double-clicking its menu ID in Resource View. If you do this for <code class="calibre23">IDR_SketchTYPE</code>, the Resource Editor pane appears, as shown in <a id="calibre_link-74" href="#calibre_link-73" class="calibre3">Figure 13-2</a>, where I show it as a floating window.</p>
<figure class="calibre16">
<img class="center" src="images/000149.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-73" href="#calibre_link-74" class="calibre3">FIGURE 13-2</a></b></span></p>
</figcaption>
</figure>
<section class="toclist">
<h4 class="calibre22">Adding a Menu Item to the Menu Bar</h4>
<p class="calibre13">To add a new menu item to the menu bar, click the menu box on the menu bar with the text “Type Here” to select it, and then type in your menu name. If you insert an ampersand (&amp;) in front of a letter in the menu item, that letter will be a shortcut key to invoke the menu from the keyboard. Type the first menu item as <code class="calibre23"><b class="calibre12">E&amp;lement</b></code>. This selects <code class="calibre23">l</code> as the shortcut letter, so you will be able to select the menu item and display its pop-up by typing Alt+L. You can’t use E as the shortcut letter because it’s already used by <code class="calibre23">Edit</code>. When you finish typing the name, you can right-click the menu item and select Properties from the pop-up to display its properties, as shown in <a id="calibre_link-76" href="#calibre_link-75" class="calibre3">Figure 13-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000118.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-75" href="#calibre_link-76" class="calibre3">FIGURE 13-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Properties are parameters with values that determine how the menu item will appear and behave. <a href="#calibre_link-75" class="calibre3">Figure 13-3</a> displays the properties grouped by category. If you want them displayed in alphabetical sequence, click the second button from the left. Note that the <code class="calibre23">Popup</code> property is set to True by default because the new <code class="calibre23">Element</code> menu item is at the top level on the menu bar, so it would normally present a pop-up menu when it is selected. Clicking a property in the left column enables you to modify its value in the right column. In this case, you want to leave everything as it is, so you can just close the Properties window. No ID is necessary for a pop-up menu item, because selecting <span {http://www.idpf.org/2007/ops}type="pagebreak" title="645" id="calibre_link-1107" class="calibre14"></span>it just displays the menu beneath and there’s no event for your code to handle. Note that you get a new blank menu box for the first item in the pop-up menu, as well as one on the main menu bar.</p>
<p class="calibre13">It would be better if the <code class="calibre23">Element</code> menu appeared between the View and Window menus, so place the mouse cursor on the menu item and, keeping the left mouse button pressed, drag it to a position between the View and Window menu items. After positioning the new menu item, the next step is to add items to its pop-up menu.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Adding Items to the Element Menu</h4>
<p class="calibre13">Select the first item (currently labeled “Type Here”) in the <code class="calibre23">Element</code> pop-up by clicking it; then, type <code class="calibre23"><b class="calibre12">Line</b></code> as the caption and press Enter. You can see the properties for this item by right-clicking it and selecting Properties; the properties for this item are shown in <a id="calibre_link-78" href="#calibre_link-77" class="calibre3">Figure 13-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000090.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-77" href="#calibre_link-78" class="calibre3">FIGURE 13-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The properties determine the appearance of the menu item and specify the ID of the message passed to your program when the item is selected. Here, you have the ID already specified as <code class="calibre23">ID_ELEMENT_LINE</code>, but you can change it to something else if you want. Sometimes it’s convenient to specify the ID yourself, such as when the generated ID is too long or its meaning is unclear. If you define your own ID, you should use the MFC convention of prefixing it with <code class="calibre23">ID_</code> to indicate that it’s a command ID for a menu item.</p>
<p class="calibre13">The <code class="calibre23">Popup</code> property is <code class="calibre23">False</code> here. When the <code class="calibre23">Popup</code> property for a menu item is <code class="calibre23">True</code>, clicking the item displays a pop-up menu. As you see in <a href="#calibre_link-77" class="calibre3">Figure 13-4</a>, you can display the possible values for the <code class="calibre23">Popup</code> property by selecting the down arrow. Don’t you love the way pop-ups pop up all over the place?</p>
<p class="calibre13">You can enter a text string for the value of the <code class="calibre23">Prompt</code> property that will appear in the status bar for Sketcher when the menu item is highlighted. If you leave it blank, nothing is displayed. I suggest you enter <code class="calibre23">Draw lines</code> as the value for the <code class="calibre23">Prompt</code> property. You get a brief indication of the purpose of a selected property at the bottom of the Properties window. The <code class="calibre23">Break</code> property can alter the appearance of the pop-up by shifting the item into a new column. You don’t need that here, so leave it as it is. Close the Properties window and click the Save icon in the toolbar to save the values you have set.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Modifying Existing Menu Items</h4>
<p class="calibre13">If you make a mistake and want to change an existing menu item, or even if you just want to verify that you set the properties correctly, it’s very easy to go back to an item. Just double-click the item you’re interested in, and the Properties window for that item is displayed. If the Properties pane is already open, just single-clicking an item will display its properties. You can then change the properties in any way you want. If the item you want to access is in a pop-up menu that isn’t displayed, just click the item on the menu bar to display the pop-up.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="646" id="calibre_link-1108" class="calibre14"></span>Completing the Menu</h4>
<p class="calibre13">Now, you can create the remaining <code class="calibre23">Element</code> pop-up menu items that you need: <code class="calibre23">Rectangle, Circle</code>, and <code class="calibre23">Curve</code>. You can accept the default IDs, <code class="calibre23">ID_ELEMENT_RECTANGLE, ID_ELEMENT_CIRCLE</code>, and <code class="calibre23">ID_ELEMENT_CURVE</code>, respectively. You could also set the values for the <code class="calibre23">Prompt</code> property value to <code class="calibre23">Draw rectangles, Draw circles</code>, and <code class="calibre23">Draw curves</code>.</p>
<p class="calibre13">You also need a <code class="calibre23">Color</code> menu on the menu bar, with pop-up menu items for <code class="calibre23">Black, Red, Green</code>, and <code class="calibre23">Blue</code>. You can create these, starting at the empty menu entry on the menu bar, using the same procedure that you just went through. You can use the default IDs (<code class="calibre23">ID_COLOR_BLACK</code>, etc.) as the IDs for the menu items. You can also add the status bar prompt for each as the value of the <code class="calibre23">Prompt</code> property. After you’ve finished, if you drag <code class="calibre23">Color</code> so that it’s just to the right of <code class="calibre23">Element</code>, the menu should be as in <a id="calibre_link-80" href="#calibre_link-79" class="calibre3">Figure 13-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000068.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-79" href="#calibre_link-80" class="calibre3">FIGURE 13-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You need to take care not to use the same shortcut letter more than once in the main menu. There’s no check made as you create menu items, but if you right-click on the menu bar when you’ve finished editing it, you’ll get a pop-up containing <code class="calibre23">Check Mnemonics</code>. Selecting this checks for duplicate shortcut keys. It’s a good idea to do this every time you edit a menu, because it’s easy to create duplicates by accident.</p>
<p class="calibre13">That completes extending the menu for elements and colors. Don’t forget to save the file to make sure that the additions are safely stored away. Next, you’ll decide which classes will deal with messages from your menu items, and add member functions to handle them. For that, you’ll be using the Event Handler Wizard.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-345" class="calibre3"></a>ADDING MENU MESSAGE HANDLERS</h2>
<p class="calibre13">To create an event handler for a menu item, right-click the item and select Add Event Handler from the pop-up displayed. If you try this with the <code class="calibre23">Black</code> menu item in the <code class="calibre23">Color</code> menu pop-up, you’ll see the dialog shown in <a id="calibre_link-82" href="#calibre_link-81" class="calibre3">Figure 13-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000166.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-81" href="#calibre_link-82" class="calibre3">FIGURE 13-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="647" id="calibre_link-1109" class="calibre14"></span>The wizard has already chosen a name for the handler function. You could change it, but <code class="calibre23">OnColorBlack</code> seems like a good name to me.</p>
<p class="calibre13">You obviously need to specify the message type as one of the choices shown in the dialog. The “Message type:” box in the window in <a href="#calibre_link-81" class="calibre3">Figure 13-6</a> shows the two kinds of messages that can arise for a particular menu ID. Each type of message serves a distinct purpose in dealing with a menu item.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">MESSAGE TYPE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">COMMAND</code></td>
<td class="calibre32">This is issued when a menu item has been selected. The handler should provide the action appropriate to the menu item such as setting the current color object or setting the element type.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">UPDATE_COMMAND_UI</code></td>
<td class="calibre32">This is issued when the menu should be updated &mdash; checked or unchecked, for example &mdash; depending on its status. This message occurs before a pop-up menu is displayed so you can set the appearance of the menu item before the user sees it.</td>
</tr>
</tbody>
</table>
<p class="calibre13">The way these messages work is quite simple. When you click a menu item in the menu bar, an <code class="calibre23">UPDATE_COMMAND_UI</code> message is sent for each item in that menu before the menu is displayed. This provides the opportunity to do any necessary updating of the menu items’ properties before the user sees it. When these messages are handled and any changes to the items’ properties are completed, <span {http://www.idpf.org/2007/ops}type="pagebreak" title="648" id="calibre_link-1110" class="calibre14"></span>the menu is drawn. When you then click an item in the menu, a <code class="calibre23">COMMAND</code> message for that menu item is sent. I’ll deal with the <code class="calibre23">COMMAND</code> messages now, and come back to the <code class="calibre23">UPDATE_COMMAND_UI</code> messages a little later in this chapter.</p>
<p class="calibre13">Because events for menu items result in command messages, you can choose to handle them in any of the classes that are currently defined in the Sketcher application. So how do you decide where you should process a message for a menu item?</p>
<section class="toclist">
<h3 class="calibre21">Choosing a Class to Handle Menu Messages</h3>
<p class="calibre13">Before you can decide which class should handle the messages for the menu items you’ve added, you need to decide what you want to do with the messages.</p>
<p class="calibre13">You want the element type and the element color to be modal &mdash; that is, whatever is set for the element type and color should remain in effect until it is changed. This enables you to create as many blue circles as you want, and when you want red circles, you just change the color. You have two possibilities for handling the setting of a color and the selection of an element type: setting them by view or by document. You could set them by view, in which case, if there’s more than one view of a document, each will have its own color and element set. This means that you might draw a red circle in one view, switch to another view, and find that you’re drawing a blue rectangle. This would be confusing and in conflict with how you would probably want your tools to work.</p>
<p class="calibre13">It would be better to have the current color and element selection apply to a document. You can then switch from one view to another and continue drawing the same element in the same color. There might be other differences between the views such as the scale at which the document is displayed, perhaps, but the drawing operation will be consistent across multiple views.</p>
<p class="calibre13">This suggests that you should store the current color and element in the document object. These could then be accessed by any view associated with the document. Of course, if you had more than one document active, each document would have its own color and element type settings. It would therefore be sensible to handle the messages for your new menu items in the <code class="calibre23">CSketcherDoc</code> class and to store information about the current selections in an object of this class. I think you’re ready to dive in and create a handler for the <code class="calibre23">Black</code> menu item.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Creating Menu Message Handlers</h3>
<p class="calibre13">Highlight the <code class="calibre23">CSketcherDoc</code> class name in the Event Handler Wizard dialog by clicking it. You’ll also need to select the <code class="calibre23">COMMAND</code> message type. You can then click the Add and Edit button. This closes the dialog, and the code for the handler you have created in the <code class="calibre23">CSketcherDoc</code> class is displayed in the edit window. The function looks like this:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnColorBlack()
{
  <b class="calibre12">// TODO: Add your command handler code here</b>
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="649" id="calibre_link-1111" class="calibre14"></span>The highlighted line is where you’ll put your code that handles the event that results from the user selecting the <code class="calibre23">Black</code> menu item. The wizard also has updated the <code class="calibre23">CSketcherDoc</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">class CSketcherDoc : public CDocument
{
  ...
        
// Generated message map functions
protected:
  DECLARE_MESSAGE_MAP()
 
#ifdef SHARED_HANDLERS
  // Helper function that sets search content for a Search Handler
  void SetSearchContent(const CString&amp; value);
#endif // SHARED_HANDLERS
public:
  <b class="calibre12">afx_msg void OnColorBlack();</b>
};</code></pre>
<p class="calibre13">The <code class="calibre23">OnColorBlack()</code> method has been added as a public member of the class, and the <code class="calibre23">afx_msg</code> prefix marks it as a message handler.</p>
<p class="calibre13">You can now add <code class="calibre23">COMMAND</code> message handlers to <code class="calibre23">CSketcherDoc</code> for the other color menu items and all the <code class="calibre23">Element</code> menu items in exactly the same way. You can create each of the handler functions with just five mouse clicks. Right-click the menu item, click the Add Event Handler menu item, click the <code class="calibre23">CSketcherDoc</code> class name in the dialog for the Event Handler Wizard, click the COMMAND message type, and click the Add and Edit button for the dialog.</p>
<p class="calibre13">The Event Handler Wizard should now have added the handlers to the <code class="calibre23">CSketcherDoc</code> class, which now looks like this:</p>
<pre class="calibre28"><code class="calibre23">class CSketcherDoc: public CDocument
{
  ...
 
// Generated message map functions
protected:
  DECLARE_MESSAGE_MAP()
 
#ifdef SHARED_HANDLERS
  // Helper function that sets search content for a Search Handler
  void SetSearchContent(const CString&amp; value);
#endif // SHARED_HANDLERS
public:
  <b class="calibre12">afx_msg void OnColorBlack();</b>
  <b class="calibre12">afx_msg void OnColorRed();</b>
  <b class="calibre12">afx_msg void OnColorGreen();</b>
  <b class="calibre12">afx_msg void OnColorBlue();</b>
  <b class="calibre12">afx_msg void OnElementLine();</b>
  <b class="calibre12">afx_msg void OnElementRectangle();</b>
  <b class="calibre12">afx_msg void OnElementCircle();</b>
  <b class="calibre12">afx_msg void OnElementCurve();</b>
 };</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="650" id="calibre_link-1112" class="calibre14"></span>A declaration has been added for each handler that you’ve created using the Event Handler Wizard dialog. Each function declaration is prefixed with <code class="calibre23">afx_msg</code> to indicate that it is a message handler.</p>
<p class="calibre13">The Event Handler Wizard automatically updates the message map in your <code class="calibre23">CSketcherDoc</code> class implementation with the new message handlers. If you look in <code class="calibre23">SketcherDoc.cpp</code>, you’ll see the message map:</p>
<pre class="calibre28"><code class="calibre23">BEGIN_MESSAGE_MAP(CSketcherDoc, CDocument)
  ON_COMMAND(ID_COLOR_BLACK, &amp;CSketcherDoc::OnColorBlack)
  ON_COMMAND(ID_COLOR_RED, &amp;CSketcherDoc::OnColorRed)
  ON_COMMAND(ID_COLOR_GREEN, &amp;CSketcherDoc::OnColorGreen)
  ON_COMMAND(ID_COLOR_BLUE, &amp;CSketcherDoc::OnColorBlue)
  ON_COMMAND(ID_ELEMENT_LINE, &amp;CSketcherDoc::OnElementLine)
  ON_COMMAND(ID_ELEMENT_RECTANGLE, &amp;CSketcherDoc::OnElementRectangle)
  ON_COMMAND(ID_ELEMENT_CIRCLE, &amp;CSketcherDoc::OnElementCircle)
  ON_COMMAND(ID_ELEMENT_CURVE, &amp;CSketcherDoc::OnElementCurve)
  END_MESSAGE_MAP()</code></pre>
<p class="calibre13">The Event Handler Wizard has added an <code class="calibre23">ON_COMMAND()</code> macro for each handler. This associates the pointer to a handler function with the message ID, so, for example, <code class="calibre23">OnColorBlack()</code> will be called to service a <code class="calibre23">COMMAND</code> message for the menu item with the <code class="calibre23">ID_COLOR_BLACK</code> ID.</p>
<p class="calibre13">Each handler generated by the Event Handler Wizard is just a skeleton. For example, look at the code provided for <code class="calibre23">OnColorBlue()</code>. This also appears in <code class="calibre23">SketcherDoc.cpp</code> so you can scroll down to find it, or go directly to it by switching to the Class View,  clicking <code class="calibre23">CSketcherDoc</code> in the upper pane and double-clicking the function name in the lower pane.</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnColorBlue()
{
   <b class="calibre12">// TODO: Add your command handler code here</b>
}</code></pre>
<p class="calibre13">The function takes no arguments and returns nothing. It also does nothing at the moment, but this is hardly surprising. The Event Handler Wizard has no way of knowing what you want to do with these messages!</p>
</section>
<section class="toclist">
<h3 class="calibre21">Implementing Menu Message Handlers</h3>
<p class="calibre13">Now let’s consider what you should do with the <code class="calibre23">COMMAND</code> messages for the new menu items. I said earlier that you want to record the current element and color in the document, so you need to add data members to the <code class="calibre23">CSketcherDoc</code> class to store these.</p>
<section class="toclist">
<h4 class="calibre22">Adding Members to Store Color and Element Mode</h4>
<p class="calibre13">You could add the data members to <code class="calibre23">CSketcherDoc</code> just by editing the class definition directly, but let’s use the Add Member Variable Wizard to do it. Display the dialog for the wizard by right-clicking the <code class="calibre23">CSketcherDoc</code> class name in the Class View and then selecting Add <img src="images/000122.png" alt="image" class="calibre25" /> Add Variable from the pop-up menu that appears. You then see the dialog for the wizard, as shown in <a id="calibre_link-84" href="#calibre_link-83" class="calibre3">Figure 13-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000019.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-83" href="#calibre_link-84" class="calibre3">FIGURE 13-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="651" id="calibre_link-1113" class="calibre14"></span>I’ve already entered the information in the dialog for the <code class="calibre23">m_Element</code> variable that stores the current element type to be drawn. I have selected <code class="calibre23">protected</code> as the access because it should not be accessible directly from outside the class. I have also entered the type as <code class="calibre23">ElementType</code>. You will define this type in the next section. When you click the Finish button, the variable is added to the class definition in the <code class="calibre23">SketcherDoc.h</code> file.</p>
<p class="calibre13">Add the <code class="calibre23">CSketcherDoc</code> class member to store the element color manually just to show that you can. Its name is <code class="calibre23">m_Color</code> and its type is <code class="calibre23">ElementColor</code>, which we will define in the next section. You can add the declaration for the <code class="calibre23">m_Color</code> member to the <code class="calibre23">CSketcherDoc</code> class like this:</p>
<pre class="calibre28"><code class="calibre23">class CSketcherDoc : public CDocument
{
...
// Generated message map functions
protected:
  DECLARE_MESSAGE_MAP()
...
public:
  afx_msg void OnColorBlack();
  afx_msg void OnColorRed();
  afx_msg void OnColorGreen();
  afx_msg void OnColorBlue();
  afx_msg void OnElementLine();
  afx_msg void OnElementRectangle();
  afx_msg void OnElementCircle();
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="652" id="calibre_link-1114" class="calibre14"></span>afx_msg void OnElementCurve();
 
<b class="calibre12">protected:</b>
  <b class="calibre12">ElementType m_Element;         // Current element type</b>
  <b class="calibre12">ElementColor m_Color;          // Current drawing color</b>
};</code></pre>
<p class="calibre13">Of course, you could have used the Add Member Variable Wizard dialog as you did for <code class="calibre23">m_Element</code>; you would type <code class="calibre23">ElementColor</code> in the “Variable type” box, rather than selecting from the drop-down list. The <code class="calibre23">m_Color</code> member is <code class="calibre23">protected</code>, because there’s no reason to allow <code class="calibre23">public</code> access. You can add functions to access or change the values of <code class="calibre23">protected</code> or <code class="calibre23">private</code> class members, with the advantage that you then have complete control over what values can be set. Add the following functions to <code class="calibre23">CSketcherDoc</code> in a public section of the class:</p>
<pre class="calibre28"><code class="calibre23">ElementType GetElementType()const { return m_Element; }
ElementColor GetElementColor() const { return m_Color; }</code></pre>
<p class="calibre13">Now an external class object, a view for instance, can discover the current element type and color.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Defining Element and Color Types</h4>
<p class="calibre13">You can define <code class="calibre23">ElementType</code> as an <code class="calibre23">enum class</code> type in a new header file, <code class="calibre23">ElementType.h</code>. The definition is:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
 
// Standard Sketcher element type identifiers
enum class ElementType{LINE, RECTANGLE, CIRCLE, CURVE};</code></pre>
<p class="calibre13">Because it’s an <code class="calibre23">enum</code> type, each of the possible values is automatically defined as a unique integer value, type <code class="calibre23">int</code> by default. Because it’s an <code class="calibre23">enum class</code> type, the enumerators are type safe and must be prefixed with the type name to access them. If you need to add further types in the future, it will be very easy to add them here. You can add an <code class="calibre23">#include</code> directive for <code class="calibre23">ElementType.h</code> to <code class="calibre23">SketcherDoc.h</code>.</p>
<p class="calibre13">You can define another <code class="calibre23">enum class</code> type for the standard drawing colors in Sketcher in <code class="calibre23">ElementColor.h</code>:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
 
// Standard Sketcher drawing colors
enum class ElementColor : COLORREF{BLACK = RGB(0,0,0),   RED = RGB(255,0,0),
                                   GREEN = RGB(0,255,0), BLUE = RGB(0,0,255)};</code></pre>
<p class="calibre13">You can define enumerators to be of any integer type. A color in Windows is of type <code class="calibre23">COLORREF</code>, which is an unsigned 32-bit integer, so the enumerators in <code class="calibre23">ElementColor</code> can be specified as this type. A color value is composed of three 8-bit unsigned integer values, packed into the 32-bit word, that correspond to the intensities of the red, green, and blue components of the color. The values are stored as <code class="calibre23">0x00bbggrr</code>, where <code class="calibre23">bb, gg</code>, and <code class="calibre23">rr</code> are hexadecimal color component values.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="653" id="calibre_link-1115" class="calibre14"></span>Each <code class="calibre23">ElementColor</code> enumerator is initialized by the <code class="calibre23">RGB()</code> macro, which is used to define <code class="calibre23">COLORREF</code> values. The macro is defined in the <code class="calibre23">Wingdi.h</code> header file that is included as part of <code class="calibre23">Windows.h</code>, so you can add an <code class="calibre23">#include</code> for <code class="calibre23">windows.h</code> to <code class="calibre23">ElementColor.h</code> after the <code class="calibre23">#pragma once</code> directive. The three arguments to the macro define the red, green, and blue components of the color value, respectively. Each argument must be an integer between 0 and 255, 0 being no color component and 255 being the maximum color component. <code class="calibre23">RGB(0,0,0)</code> corresponds to black because there are no components of red, green, or blue. <code class="calibre23">RGB(255,0,0)</code> creates a color value with a maximum red component and no green or blue contribution. <code class="calibre23">RGB(0,255,0)</code>and <code class="calibre23">RGB(0,0,255)</code> correspond to green and blue with maximum intensity. You can create other colors by combining red, green, and blue components with other intensities. Add an <code class="calibre23">#include</code> for <code class="calibre23">ElementColor.h</code> to <code class="calibre23">SketcherDoc.h</code>. The <code class="calibre23">ElementType</code> and <code class="calibre23">ElementColor</code> types should now be visible in Class View.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Initializing the Color and Element Type Members</h4>
<p class="calibre13">It’s important to make sure that the data members you have added to the <code class="calibre23">CSketcherDoc</code> class are initialized appropriately when a document is created. You can modify the code in the class definition in <code class="calibre23">SketcherDoc.h</code>, as shown here:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">ElementType m_Element {ElementType::LINE};                 // Current element type</b>
<b class="calibre12">ElementColor m_Color {ElementColor::BLACK};                // Current drawing color</b></code></pre>
<p class="calibre13"><code class="calibre23">enum class</code> types require that enumerators are explicitly qualified by the class name.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Implementing Menu Command Message Handlers</h4>
<p class="calibre13">Now, you’re ready to add the code for the handler functions that you created for the <code class="calibre23">Element</code> and <code class="calibre23">Color</code> menu items. You can do this from the Class View. Double-click the name of the first handler function, <code class="calibre23">OnColorBlack()</code>. You just need to add one line to the function, so the code for it becomes:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnColorBlack()
{
   <b class="calibre12">m_Color = ElementColor::BLACK;          // Set the drawing color to black</b>
}</code></pre>
<p class="calibre13">The only job that the handler has to do is to set the appropriate color. In the interest of conciseness, the new line replaces the comment provided originally. You can go through and add one line to each of the <code class="calibre23">Color</code> menu handlers setting the appropriate color value.</p>
<p class="calibre13">The <code class="calibre23">element</code> menu handlers are much the same. The handler for the Element <img src="images/000079.png" alt="image" class="calibre25" /> Line menu item is:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnElementLine()
{
   <b class="calibre12">m_Element = ElementType::LINE;         // Set element type as a line</b>
}</code></pre>
<p class="calibre13">With this model, it’s not too difficult to write the other handlers for the <code class="calibre23">Element</code> menu. That’s eight message handlers completed. You can now build the example and see how it works.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="654" id="calibre_link-1116" class="calibre14"></span>Running the Extended Example</h4>
<p class="calibre13">Assuming that there are no typos, the compiled and linked program should run without error. When you run the program, you should see the window shown in <a id="calibre_link-86" href="#calibre_link-85" class="calibre3">Figure 13-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000081.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-85" href="#calibre_link-86" class="calibre3">FIGURE 13-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The new menus are in place on the menu bar, and you can see that the items you have added to the menu are all there and you should see the prompt message in the status bar that you provided in the properties box when the mouse cursor is over a menu item. You can also verify that Alt+C and Alt+L work. Ideally, the currently selected items in the <code class="calibre23">Color</code> and <code class="calibre23">Element</code> menus should be checked as a cue to the current state. Let’s look at how you can arrange for that to happen.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Adding Menu Update Message Handlers</h3>
<p class="calibre13">To set the checkmark correctly for the new menus, you need to add the second kind of message handler, <code class="calibre23">UPDATE_COMMAND_UI</code> (signifying “update command user interface”) for each of the menu items. These handlers are intended for updating the properties of the menu items before the menu is displayed.</p>
<p class="calibre13">Go back to viewing the <code class="calibre23">IDR_SketchTYPE</code> menu in the editor window. Right-click the Black item in the Color menu and select Add Event Handler. You can then select <code class="calibre23">CSketcherDoc</code> as the class and <code class="calibre23">UPDATE_COMMAND_UI</code> as the message type, as shown in <a id="calibre_link-88" href="#calibre_link-87" class="calibre3">Figure 13-9</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000044.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-87" href="#calibre_link-88" class="calibre3">FIGURE 13-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="655" id="calibre_link-1117" class="calibre14"></span>The name for the update function has been generated as <code class="calibre23">OnUpdateColorBlack()</code>. This seems a reasonable name so click the Add and Edit button and have the Event Handler Wizard generate it. The skeleton function definition is added in <code class="calibre23">SketcherDoc.cpp</code> and its declaration is added to the class definition. An entry for it is also made in the message map in the <code class="calibre23">SketcherDoc.cpp</code> that looks like this:</p>
<pre class="calibre28"><code class="calibre23">ON_UPDATE_COMMAND_UI(ID_COLOR_BLACK, &amp;CSketcherDoc::OnUpdateColorBlack)</code></pre>
<p class="calibre13">This uses the <code class="calibre23">ON_UPDATE_COMMAND_UI()</code> macro that identifies the function you have just generated as the handler to deal with update messages corresponding to the <code class="calibre23">ID_COLOR_BLACK</code> ID. You can now enter the code for the new handler, but before you do that, add command update handlers for each of the menu items for both the Color and Element menus first.</p>
<section class="toclist">
<h4 class="calibre22">Coding a Command Update Handler</h4>
<p class="calibre13">You can access the code for the <code class="calibre23">OnUpdateColorBlack()</code> handler in <code class="calibre23">CSketcherDoc</code> by selecting the function in Class View. This is the skeleton code for the function:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnUpdateColorBlack(CCmdUI* pCmdUI)
{
   // TODO: Add your command update UI handler code here
        
}</code></pre>
<p class="calibre13">The argument passed to the handler is a pointer to an object of type <code class="calibre23">CCmdUI</code>. This is an MFC class type that is used only with update handlers, and it applies to toolbar buttons as well as menu items. <code class="calibre23">pCmdUI</code> points to an object that identifies the item that originated the message, so you use this to operate on the item to update it before it is displayed. The <code class="calibre23">CCmdUI</code> class has five member functions that act on user interface items. The operations that these provide are:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">ContinueRouting()</code></td>
<td class="calibre32">Passes the message on to the next priority handler.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Enable()</code></td>
<td class="calibre32">Enables or disables the relevant interface item.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SetCheck()</code></td>
<td class="calibre32">Sets a checkmark for the relevant interface item.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SetRadio()</code></td>
<td class="calibre32">Sets a button in a radio group on or off.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SetText()</code></td>
<td class="calibre32">Sets the text for the relevant interface item.</td>
</tr>
</tbody>
</table>
<p class="calibre13">We’ll use <code class="calibre23">SetCheck()</code> as that seems to do what we want. The function is declared in the <code class="calibre23">CCmdUI</code> class as:</p>
<pre class="calibre28"><code class="calibre23">virtual void SetCheck(int nCheck = 1);</code></pre>
<p class="calibre13">This function sets a menu item as checked if you pass <code class="calibre23">1</code> as the argument, and unchecked if you pass <code class="calibre23">0</code> as the argument. The parameter has a default value of <code class="calibre23">1</code>, so if you just want to set a checkmark for an item, you call this function without an argument.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="656" id="calibre_link-1118" class="calibre14"></span>For Sketcher, you want to set a <code class="calibre23">Color</code> menu item as checked if it corresponds with the current color. You can, therefore, write the update handler for <code class="calibre23">OnUpdateColorBlack()</code> as:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnUpdateColorBlack(CCmdUI* pCmdUI)
{
   <b class="calibre12">// Set menu item Checked if the current color is black</b>
   <b class="calibre12">pCmdUI-&gt;SetCheck(m_Color == ElementColor::BLACK);</b>
}</code></pre>
<p class="calibre13">This calls <code class="calibre23">SetCheck()</code> for the Color <img src="images/000122.png" alt="image" class="calibre25" /> Black menu item with the argument <code class="calibre23">m_Color==ElementColor::BLACK</code>. This results in <code class="calibre23">true</code> if <code class="calibre23">m_Color</code> is <code class="calibre23">ElementColor::BLACK</code>, which will convert to 1, or <code class="calibre23">false</code>, which will convert to 0. The effect is to check the menu item only if the current color in <code class="calibre23">m_Color</code> is <code class="calibre23">ElementColor::BLACK</code>, which is precisely what you want. You can implement the update handlers for the other <code class="calibre23">Color</code> menu items in the same way. Update handlers for menu items are always called before the menu is displayed, so the items are always displayed reflecting their current state.</p>
<p class="calibre13">A typical <code class="calibre23">Element</code> menu item update handler is coded as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnUpdateElementLine(CCmdUI* pCmdUI)
{
   <b class="calibre12">// Set Checked if the current element is a line</b>
   <b class="calibre12">pCmdUI-&gt;SetCheck(m_Element==ElementType::LINE);</b>
}</code></pre>
<p class="calibre13">You can now code all the other update handlers for items in the <code class="calibre23">Element</code> menu in a similar manner.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Exercising the Update Handlers</h4>
<p class="calibre13">When you’ve added the code for the update handlers, you can build and execute the Sketcher application again. Now, when you change a color or an element type selection, this is reflected in the menu, as shown in <a id="calibre_link-90" href="#calibre_link-89" class="calibre3">Figure 13-10</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000006.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-89" href="#calibre_link-90" class="calibre3">FIGURE 13-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You have completed all the code that you need for the menu items. Make sure that you have saved everything before embarking on the next stage. Toolbars are a must in any Windows program of consequence, so the next step is to look at how you add toolbar buttons to support the new menus.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-346" class="calibre3"></a>ADDING TOOLBAR BUTTONS</h2>
<p class="calibre13">Select the Resource View and extend the toolbar resource. You’ll see that the toolbar resource has the same ID as the main menu, <code class="calibre23">IDR_MAINFRAME</code>. This provides you with toolbar icons that have four-bit color pixels (16 colors).</p>
<p class="calibre13">If you double-click <code class="calibre23">IDR_MAINFRAME</code>, the editor window shown in <a id="calibre_link-92" href="#calibre_link-91" class="calibre3">Figure 13-11</a> appears.</p>
<figure class="calibre16">
<img class="center" src="images/000138.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-91" href="#calibre_link-92" class="calibre3">FIGURE 13-11</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="657" id="calibre_link-1119" class="calibre14"></span>A toolbar button is a 16 × 15 (width × height) array of pixels that contains a pictorial representation of the function it initiates. Each pixel in this toolbar is a 4-bit color, so a button is a 16-color bitmap. You can see in <a href="#calibre_link-91" class="calibre3">Figure 13-11</a> that the resource editor provides an enlarged view of a toolbar button so that you can see and manipulate individual pixels. It also provides you with a color palette to the right (not shown in <a href="#calibre_link-91" class="calibre3">Figure 13-11</a>), from which you can choose the current working color. If it is not already visible, you can display the palette from which you can choose a color by right-clicking a toolbar button icon and selecting Show Colors Window from the menu.</p>
<p class="calibre13">If you click the new button icon at the right end of the row, you’ll be able to draw this icon. Before starting editing, drag the new icon about half a button-width to the right on the toolbar. This separates the button from its neighbor on the left to start a new block. You should keep toolbar buttons in the same sequence as the items on the menu bar, so you’ll create the buttons corresponding to the <code class="calibre23">Element</code> menu first. You’ll probably want to use the editing buttons provided by the resource editor, which appear in the IDE application window toolbar and include:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Pencil for drawing individual pixels</li>
<li class="calibre6">Eraser for erasing individual pixels</li>
<li class="calibre6">Fill an area with the current color</li>
<li class="calibre6">Zoom the view of the button</li>
<li class="calibre6">Draw a line</li>
<li class="calibre6">Draw a rectangle</li>
<li class="calibre6">Draw an ellipse</li>
<li class="calibre6">Draw a curve</li>
</ul>
<p class="calibre13">You select a foreground color by left-clicking a color from the palette, and a background color by right-clicking.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="658" id="calibre_link-1120" class="calibre14"></span>The first icon will be for the button corresponding to the Element <img src="images/000122.png" alt="image" class="calibre25" /> Line menu option. You can let your creative juices flow and draw whatever you like here to depict the act of drawing a line, but I’ll keep it simple. If you want to follow my approach, make sure that black is selected as the foreground color and use the line tool to draw a diagonal line in the enlarged image of the new toolbar button icon. In fact, if you want the icon to appear a bit bigger, you can use the Magnification Tool editing button to make it up to eight times its actual size: just click the down arrow alongside the button and select the magnification you want. I drew a double black line.</p>
<p class="calibre13">If you make a mistake, you can select the Undo button or you can change to the Erase Tool editing button and use that, but in the latter case, you need to make sure that the color selected corresponds to the background color for the button you are editing. You can also erase individual pixels by clicking them using the right mouse button, but again, you need to be sure that the background color is set correctly when you do this. After you’re happy with what you’ve drawn, the next step is to edit the toolbar button properties.</p>
<section class="toclist">
<h3 class="calibre21">Editing Toolbar Button Properties</h3>
<p class="calibre13">Right-click your new button icon in the toolbar and select Properties from the pop-up to bring up its Properties window, as shown in <a id="calibre_link-94" href="#calibre_link-93" class="calibre3">Figure 13-12</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000095.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-93" href="#calibre_link-94" class="calibre3">FIGURE 13-12</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The Properties window shows a default ID for the button, but you want to associate the button with the menu item Element <img src="images/000122.png" alt="image" class="calibre25" /> Line that you have already defined, so click ID and then click the down arrow to display alternative values. You can then select <code class="calibre23">ID_ELEMENT_LINE</code> from the drop-down list. If you look at the Prompt property, you’ll find that the same prompt value appears because the prompt is recorded along with the ID. You can click Save to complete the button definition.</p>
<p class="calibre13">You can now move on to designing the other three element buttons. You can use the rectangle editing button to draw a rectangle and the ellipse button to draw a circle. You can draw a curve using the pencil to set individual pixels, or use the curve button. You need to associate each button with the ID for the equivalent menu item that you defined earlier.</p>
<p class="calibre13">Now add the buttons for the colors. You should also drag the first button for selecting a color to the right, so that it starts a new group of buttons. You could keep the color buttons very simple and just color the whole button with the color it selects. You can do this by selecting the appropriate foreground color, then selecting the Fill editing button and clicking on the enlarged button image. Again, you need to use <code class="calibre23">ID_COLOR_BLACK, ID_COLOR_RED</code>, and so on as IDs for the buttons. The toolbar editing window should look like the one shown in <a id="calibre_link-96" href="#calibre_link-95" class="calibre3">Figure 13-13</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000060.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-95" href="#calibre_link-96" class="calibre3">FIGURE 13-13</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">That’s all you need for the moment, so save the resource file and give Sketcher another spin.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="659" id="calibre_link-1121" class="calibre24"></span>Exercising the Toolbar Buttons</h3>
<p class="calibre13">Build the application once again and execute it. You should see the application window shown in <a id="calibre_link-98" href="#calibre_link-97" class="calibre3">Figure 13-14</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000022.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-97" href="#calibre_link-98" class="calibre3">FIGURE 13-14</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">There are some amazing things happening here. The toolbar buttons you added already reflect the default settings that you defined for the new menu items, and the selected button is shown depressed. If you let the cursor linger over one of the buttons, the prompt for the button appears in the status bar. The new buttons work as a complete substitute for the menu items, and any new selection made, with either the menu or the toolbar, is reflected by the toolbar button being shown depressed.</p>
<p class="calibre13">If you close the document view window, Sketch1, you’ll see that your toolbar buttons are automatically grayed and disabled and your menu items disappear. If you open a new document window, the toolbar buttons are automatically enabled once again and your menu items reappear. You can also drag the toolbar using the grip at the left. You can move the toolbar to either side of the application window, or have it free-floating. You got all this toolbar functionality without writing a single additional line of code!</p>
</section>
<section class="toclist">
<h3 class="calibre21">Adding Tooltips</h3>
<p class="calibre13">There’s one further tweak that you can add that is remarkably easy: tooltips. A tooltip is a small box that appears adjacent to the toolbar button when you let the cursor linger on the button. The tooltip contains a text string that is an additional clue to the purpose of the toolbar button.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="660" id="calibre_link-1122" class="calibre14"></span>To add a tooltip for a toolbar button, select the button in the toolbar editor tab. Select the Prompt property for the button in the Properties pane and enter <code class="calibre23">\n</code> followed by the text for the tooltip. For example, for the toolbar button with the ID <code class="calibre23">ID_ELEMENT_LINE</code>, you could enter the Prompt property value as <code class="calibre23">\nDraw lines</code>. The tooltip text will be displayed when you hover the mouse cursor over the toolbar button but you won’t get the status bar text for the corresponding menu item.</p>
<p class="calibre13">You can have status bar text displayed for the menu item and different tooltip text for the toolbar button, though. Set the value for the Prompt property for the Line menu item as <code class="calibre23">Draw lines\nLines</code>. This will display “Draw lines” in the status bar when you hover the mouse cursor over the menu item. When you hover the mouse over the toolbar button, the status bar text will be displayed and the tooltip text will appear a short while afterwards.</p>
<p class="calibre13">You can change the Prompt property text for each of the toolbar buttons corresponding to the Element and Color menus in a similar way. That’s all you have to do. After saving the resource file, you can build the application and execute it. Hovering the cursor over a toolbar button causes the prompt text to appear in the status bar and the tooltip to be displayed.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-347" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter, you learned how MFC connects a message with a class member function to process it, and you wrote your first message handlers. Much of the work in writing a Windows program is writing message handlers, so it’s important to have a good grasp of what happens in the process. When we consider other message handlers, you’ll see that the process for adding them is the same.</p>
<p class="calibre13">You have also extended the standard menu and the toolbar in the MFC Application Wizard&ndash;generated program, which provides a good base for the application code that you add in the next chapter. Although there’s no functionality under the covers yet, the menu and toolbar operation looks very professional, courtesy of the Application Wizard&ndash;generated framework and the Event Handler Wizard.</p>
<p class="calibre13">In the next chapter, you’ll add the code necessary to draw elements in a view, and use the menus and toolbar buttons that you created here to select what to draw and in which color. This is where the Sketcher program begins to live up to its name.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Add an <code class="calibre23">Ellipse</code> menu item to the <code class="calibre23">Element</code> menu.</li>
<li class="calibre6">Implement the command and command update handlers for the <code class="calibre23">Ellipse</code> menu item in the document class.</li>
<li class="calibre6">Add a toolbar button corresponding to the <code class="calibre23">Ellipse</code> menu item, and add status bar text and a tooltip for the button.</li>
<li class="calibre6">Modify the command update handlers for the color menu items so that the currently selected menu item displays in uppercase, and the others in lowercase.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="661" id="calibre_link-1123" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Message maps</b></td>
<td class="calibre32">MFC defines the message handlers for a class in a message map that appears in the <code class="calibre23">.cpp</code> file for the class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Handling command messages</b></td>
<td class="calibre32">Command messages that arise from menus and toolbars can be handled in any class that’s derived from <code class="calibre23">CCmdTarget</code>. These include the application class, the frame and child frame window classes, the document class, and the view class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Handling non-command messages</b></td>
<td class="calibre32">Messages other than command messages can be handled only in a class derived from <code class="calibre23">CWnd</code>. This includes frame window and view classes, but not application or document classes.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Identifying a message handler for command messages</b></td>
<td class="calibre32">MFC has a predefined sequence for searching the classes in your program to find a message handler for a command message.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Adding message handlers</b></td>
<td class="calibre32">You should always use the Event Handler Wizard to add message handlers to your program.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Resource files</b></td>
<td class="calibre32">The physical appearances of menus and toolbars are defined in resource files, which are edited by the built-in resource editor.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Menu IDs</b></td>
<td class="calibre32">Items in a menu that can result in command messages are identified by a symbolic constant with the prefix <code class="calibre23">ID_</code>. These IDs are used to associate a handler with the message from the menu item.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Relating toolbar buttons to menu items</b></td>
<td class="calibre32">To associate a toolbar button with a particular menu item, give it the same ID as the menu item.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Adding tooltips</b></td>
<td class="calibre32">To add a tooltip to a toolbar button corresponding to a menu item in your MFC application, select the Prompt property for the button in the Properties pane and enter <code class="calibre23">\n</code>, followed by the text for the tooltip as the property value.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="662" id="calibre_link-1124" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-100">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2327" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="663" id="calibre_link-1125" class="calibre9"></span><span class="chapternumber">Chapter 14</span><br class="calibre10" /><span class="chapternumber">Drawing in a Window</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The coordinate systems you use to draw in a window</li>
<li class="calibre6">How to use a device context to draw shapes</li>
<li class="calibre6">How and when your program draws in a window</li>
<li class="calibre6">How to define handlers for mouse messages</li>
<li class="calibre6">How to define your own shape classes</li>
<li class="calibre6">How to program the mouse to draw shapes</li>
<li class="calibre6">How to capture the mouse</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 14 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-348" class="calibre3"></a>BASICS OF DRAWING IN A WINDOW</h2>
<p class="calibre13">When you draw in the client area of a window, you must obey the rules. You must redraw the client area whenever a <code class="calibre23">WM_PAINT</code> message is sent to your application. This is because there are many external events that require that your application window is redrawn &mdash; the user resizing the window for example or moving another window to expose part of your window that was hidden. Windows sends information along with the <code class="calibre23">WM_PAINT</code> message that enables you to determine which part of the client area needs to be re-created. This means that you don’t have to draw all the client area in response to a <code class="calibre23">WM_PAINT</code> message, just the area identified as the <i class="calibre15">update region</i>. In an MFC application, the MFC intercepts the <code class="calibre23">WM_PAINT</code> message and redirects it to a function in one of your classes. I’ll explain how you handle this message later in this chapter.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="664" id="calibre_link-1126" class="calibre24"></span>The Window Client Area</h3>
<p class="calibre13">A window doesn’t have a fixed position on-screen, or even a fixed visible area, because the user can drag a window around and resize it by dragging its borders. How, then, do you know where to draw on-screen?</p>
<p class="calibre13">Fortunately, you don’t. Windows provides a consistent way of drawing in a window that is independent of where it is on-screen; without this, drawing in a window would be inordinately complicated. Windows does this by maintaining a coordinate system for the client area of a window that is local to the window. It always uses the upper-left corner of the client area as its reference point. All points within the client area are defined relative to this point, as shown in <a id="calibre_link-102" href="#calibre_link-101" class="calibre3">Figure 14-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000152.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-101" href="#calibre_link-102" class="calibre3">FIGURE 14-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The horizontal and vertical distances of a point in the client area from the upper-left corner will always be the same, regardless of where the window is on-screen or how big it is. Of course, Windows keeps track of where the window is, and when you draw something at a point in the client area, it has to figure out where that point actually is on-screen.</p>
</section>
<section class="toclist">
<h3 class="calibre21">The Windows Graphical Device Interface</h3>
<p class="calibre13">You don’t write data to the screen in any direct sense. All output to your display is graphical, regardless of whether it is lines and circles or text. Windows insists that you define this output using the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="665" id="calibre_link-1127" class="calibre14"></span><i class="calibre15">Graphical Device Interface (GDI)</i>. The GDI enables you to program graphical output in a way that is independent of the hardware on which it is displayed, meaning that your program will work on different machines with different display hardware without change. The GDI also supports printers and plotters, so outputting data to those involves essentially the same mechanism as writing to the screen.</p>
<section class="toclist">
<h4 class="calibre22">Working with a Device Context</h4>
<p class="calibre13">When you draw something on an output device such as a display, you must use a <i class="calibre15">device context</i>. A device context is a Windows data structure that contains information that allows Windows to translate your output requests in the form of device-independent GDI function calls, into actions on the physical device. The MFC class, <code class="calibre23">CDC</code>, encapsulates a device context so you do all drawing by calling functions for an object of this type. A pointer to a <code class="calibre23">CDC</code> object is supplied to the <code class="calibre23">OnDraw()</code> member of your view class object and you implement this to draw in the client area represented by the view. You also use a device context when you want to send output to other graphical devices.</p>
<p class="calibre13">A device context provides you with a choice of coordinate systems called <i class="calibre15">mapping modes</i>, which are automatically converted to client area coordinates. You can alter parameters (called <i class="calibre15">attributes</i>) that affect the output to a device context by calling functions for a <code class="calibre23">CDC</code> object. Examples of attributes that you can change are the drawing color, the background color, the line thickness to be used when drawing, and the font for text output.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Mapping Modes</h4>
<p class="calibre13">Each mapping mode in a device context is identified by an ID, much like a Windows message. Each ID has the prefix <code class="calibre23">MM_</code> to indicate that it defines a mapping mode. The mapping modes are:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">MAPPING MODE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_TEXT</code></td>
<td class="calibre32">A logical unit is one device pixel with positive x from left to right, and positive y from top to bottom of the window client area.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_LOENGLISH</code></td>
<td class="calibre32">A logical unit is 0.01 inches with positive x from left to right, and negative y from top to bottom of the client area.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_HIENGLISH</code></td>
<td class="calibre32">A logical unit is 0.001 inches with the x and y directions as in <code class="calibre23">MM_LOENGLISH</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_LOMETRIC</code></td>
<td class="calibre32">A logical unit is 0.1 millimeters with the x and y directions as in <code class="calibre23">MM_LOENGLISH</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_HIMETRIC</code></td>
<td class="calibre32">A logical unit is 0.01 millimeters with the x and y directions as in <code class="calibre23">MM_LOENGLISH</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_ISOTROPIC</code></td>
<td class="calibre32">A logical unit is of arbitrary length, but the same along both axes. The x and y directions are as in <code class="calibre23">MM_LOENGLISH</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="666" id="calibre_link-1128" class="calibre14"></span><code class="calibre23">MM_ANISOTROPIC</code></td>
<td class="calibre32">This is similar to <code class="calibre23">MM_ISOTROPIC</code>, but allows the length of a logical unit on the x-axis to be different from that of a logical unit on the y-axis.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MM_TWIPS</code></td>
<td class="calibre32">A logical unit is a TWIP, which is a twentieth of an inch point and a point is 1/72 of an inch. Thus, a TWIP corresponds to 1/1440 of an inch, or 6.9 × 10<sup class="calibre33">-4</sup> of an inch. (A point is a font size measurement unit). The axes are as in <code class="calibre23">MM_LOENGLISH</code>.</td>
</tr>
</tbody>
</table>
<p class="calibre13">You will not use all these mapping modes with this book; however, the ones you will use form a good cross-section of those available, so you should not have any problem using the others when you need to.</p>
<p class="calibre13"><code class="calibre23">MM_TEXT</code> is the default mapping mode for a device context. If you need to use a different mapping mode, you have to change it. Note that the direction of the positive y-axis in the <code class="calibre23">MM_TEXT</code> mode is the opposite of what you saw in high-school coordinate geometry, as <a href="#calibre_link-101" class="calibre3">Figure 14-1</a> shows.</p>
<p class="calibre13">By default, the origin point with the coordinates (0,0) is at the upper-left corner of the client area in every mapping mode, although it’s possible to move it. For example, an application that presents data in graphical form might move the origin to the center of the client area to make plotting the data easier. You might also define shapes relative to (0,0) and then move the origin to the position where a shape is to be drawn. This means that a shape can be drawn using the same code, regardless of where it is.</p>
<p class="calibre13">With the default origin position in <code class="calibre23">MM_TEXT</code> mode, a point 50 pixels from the left border and 100 pixels down from the top of the client area has the coordinates (50,100). Because the units are pixels, the physical distance of the point from the upper-left corner of the client area on your screen depends on the resolution of your monitor. If the resolution is set to 1280 × 1024 the point will be nearer to the origin than if it’s set to 1024 × 768 because the pixels are smaller. An object drawn in this mapping mode will be smaller at the 1280 × 1024 resolution than at 1024 × 768. Note that the DPI setting for your display also affects presentation in all mapping modes. The default settings assume 96 DPI, so if the DPI for your display is different, this affects how things look. Coordinates are always 32-bit signed integers. The maximum physical size of the area you can draw varies with the length of a coordinate unit, which depends on the mapping mode.</p>
<p class="calibre13">The directions of the coordinate axes in all mapping modes other than <code class="calibre23">MM_TEXT</code> are the same, but different from <code class="calibre23">MM_TEXT</code> in that the y-coordinate axis is in the opposite direction. The coordinate system for <code class="calibre23">MM_LOENGLISH</code> is shown in <a id="calibre_link-104" href="#calibre_link-103" class="calibre3">Figure 14-2</a>. Although the positive y-direction is consistent with what you learned in high school (y-values increase as you move up the screen), <code class="calibre23">MM_LOENGLISH</code> is still slightly odd because the origin is at the upper-left corner of the client area, so y is always negative for points within the visible client area.</p>
<figure class="calibre16">
<img class="center" src="images/000109.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-103" href="#calibre_link-104" class="calibre3">FIGURE 14-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="667" id="calibre_link-1129" class="calibre14"></span>In the <code class="calibre23">MM_LOENGLISH</code> mapping mode, the units along the axes are 0.01 inches, so a point at the position (50, −100) is half an inch from the left border and one inch down from the top of the client area. An object is the same size in the client area and the same distance from the origin, regardless of the resolution of the monitor on which it’s displayed. Anything you draw in <code class="calibre23">MM_LOENGLISH</code> mode with negative x- or positive y-coordinates will be outside the client area and therefore not visible. You can move the origin by calling the <code class="calibre23">SetViewportOrg()</code> member of the <code class="calibre23">CDC</code> object that encapsulates a device context, which I’ll discuss shortly.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-349" class="calibre3"></a>THE MFC DRAWING MECHANISM</h2>
<p class="calibre13">The MFC encapsulates the Windows interface to your screen and printer and relieves you of the need to worry about much of the details involved in programming graphical output. As you saw in the last chapter, an Application Wizard-generated program already contains a class derived from <code class="calibre23">CView</code> that’s specifically designed to display document data.</p>
<section class="toclist">
<h3 class="calibre21">The View Class in Your Application</h3>
<p class="calibre13">The primary purpose of the Application Wizard-generated <code class="calibre23">CSketcherView</code> class is to display information from a document object in the client area of a document window. The class definition includes overrides for several virtual functions, but the one of particular interest here is the <code class="calibre23">OnDraw()</code> function. This is called whenever the client area of the document window needs to be <span {http://www.idpf.org/2007/ops}type="pagebreak" title="668" id="calibre_link-1130" class="calibre14"></span>redrawn. It’s the function that’s called by the application framework when a <code class="calibre23">WM_PAINT</code> message is received by your program.</p>
<section class="toclist">
<h4 class="calibre22">The OnDraw() Member Function</h4>
<p class="calibre13">The implementation of the <code class="calibre23">OnDraw()</code> function looks like this:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnDraw(CDC* /*pDC*/)
{
   CSketcherDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if(!pDoc)
     return;
        
   // TODO: add draw code for native data here
}</code></pre>
<p class="calibre13">A pointer to a <code class="calibre23">CDC</code> class object is passed to the <code class="calibre23">OnDraw()</code> member of the view class. This object has member functions that call Windows API functions that enable you to draw in the device context. The parameter name is commented out: you must uncomment it or substitute your own name before you can use the pointer.</p>
<p class="calibre13">Because you’ll put all the code to draw a document in this function, the Application Wizard includes a declaration for the <code class="calibre23">pDoc</code> pointer and initializes it using the <code class="calibre23">GetDocument()</code> function that returns the address of the document object for the current view:</p>
<pre class="calibre28"><code class="calibre23">   CSketcherDoc* pDoc = GetDocument();</code></pre>
<p class="calibre13">The <code class="calibre23">GetDocument()</code> function in <code class="calibre23">CSketcherView</code> retrieves the pointer to the document from <code class="calibre23">m_pDocument</code>, an inherited member of the view object. The function performs the important task of casting the pointer stored in this member to the type corresponding to the document class in the application, <code class="calibre23">CSketcherDoc</code>. This is so you can use the pointer to access the members of the document class that you’ve defined; otherwise, you could use the pointer only to access the members of the base class. Thus <code class="calibre23">pDoc</code> points to the document object in your application that is associated with the current view, and you use it to access the data that you’ve stored in the document.</p>
<p class="calibre13">The next line is:</p>
<pre class="calibre28"><code class="calibre23">   ASSERT_VALID(pDoc);</code></pre>
<p class="calibre13">This macro ensures that <code class="calibre23">pDoc</code> contains a valid address, and the <code class="calibre23">if</code> statement that follows verifies that <code class="calibre23">pDoc</code> is not <code class="calibre23">nullptr. ASSERT_VALID</code> is ignored in a release version of the application.</p>
<p class="calibre13">The parameter name, <code class="calibre23">pDC</code>, for the <code class="calibre23">OnDraw()</code> function stands for “pointer to device context.” The <code class="calibre23">CDC</code> object pointed to by <code class="calibre23">pDC</code> is the key to drawing in a window. It provides a device context for the client area of the view, plus the tools you need to write graphics and text to it, so you need to look at this in more detail.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="669" id="calibre_link-1131" class="calibre24"></span>The CDC Class</h3>
<p class="calibre13">You should do all the drawing in your program using members of the <code class="calibre23">CDC</code> class. All objects of this class and classes derived from it contain a device context and the member functions you need for sending graphics and text to your display or your printer. There are also member functions for retrieving information about the physical output device you are using.</p>
<p class="calibre13">Because a <code class="calibre23">CDC</code> object provides almost everything you’re likely to need in the way of graphical output, there are a lot of member functions of this class &mdash; in fact, well over a hundred. You’ll look only at the ones you’re going to use in the Sketcher program in this chapter; I’ll go into others as you need them later on.</p>
<p class="calibre13">The MFC includes more specialized classes for graphics output that are derived from <code class="calibre23">CDC</code>. For example, you will be using <code class="calibre23">CClientDC</code> objects. The <code class="calibre23">CClientDC</code> class has the advantage over <code class="calibre23">CDC</code> that it always contains a device context that represents only the client area of a window, and this is precisely what you want in most circumstances.</p>
<section class="toclist">
<h4 class="calibre22">Displaying Graphics</h4>
<p class="calibre13">You draw entities such as lines, circles, and text relative to the <i class="calibre15">current position</i> in a device context. The current position is a point in the client area that was set either by the previous entity that was drawn or by you calling a function to set it. For example, you could extend the <code class="calibre23">OnDraw()</code> function to set the current position like this:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">void CSketcherView::OnDraw(CDC* pDC)</b>
{
   CSketcherDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if(!pDoc)
     return;
        
   <b class="calibre12">pDC-&gt;MoveTo(50, 50);    // Set the current position as 50,50</b>
}</code></pre>
<p class="calibre13">The first line is bolded because I changed it. You must uncomment the parameter name if the code is to compile. The second bolded line calls the <code class="calibre23">MoveTo()</code> function for the <code class="calibre23">CDC</code> object pointed to by <code class="calibre23">pDC</code>. This function sets the current position to the x- and y-coordinates you specify as arguments. The default mapping mode is <code class="calibre23">MM_TEXT</code> so the coordinates are in pixels. The current position will be set to a point 50 pixels to the right from the inside-left border of the window, and 50 pixels down from the top of the client area.</p>
<p class="calibre13">The <code class="calibre23">CDC</code> class overloads the <code class="calibre23">MoveTo()</code> function to provide flexibility as to how you specify the current position. There are two versions declared in the <code class="calibre23">CDC</code> class as:</p>
<pre class="calibre28"><code class="calibre23">CPoint MoveTo(int x, int y);     // Move to position x,y
CPoint MoveTo(POINT aPoint);     // Move to position defined by aPoint</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="670" id="calibre_link-1132" class="calibre14"></span>The first version accepts the x- and y-coordinates as separate arguments. The second accepts one argument of type <code class="calibre23">POINT</code>. This is a structure that is defined as:</p>
<pre class="calibre28"><code class="calibre23">typedef struct tagPOINT
{
   LONG x;
   LONG y;
} POINT;</code></pre>
<p class="calibre13">The coordinates are the <code class="calibre23">x</code> and <code class="calibre23">y</code> members of the <code class="calibre23">struct</code> and are of type <code class="calibre23">LONG</code>, which is a type defined in the Windows API as a 32-bit signed integer. You may prefer to use a class instead of a structure, in which case, you can use a <code class="calibre23">CPoint</code> object anywhere that a <code class="calibre23">POINT</code> object can be used. The <code class="calibre23">CPoint</code> class has data members <code class="calibre23">x</code> and <code class="calibre23">y</code> of type <code class="calibre23">LONG</code>, and using <code class="calibre23">CPoint</code> objects has the advantage that the class also defines functions that operate on both <code class="calibre23">CPoint</code> and <code class="calibre23">POINT</code> objects. This may seem weird because <code class="calibre23">CPoint</code> would seem to make <code class="calibre23">POINT</code> objects obsolete, but remember that the Windows API was built before the MFC was around, and <code class="calibre23">POINT</code> objects are used in the Windows API and have to be dealt with sooner or later. I’ll use <code class="calibre23">CPoint</code> objects in examples, so you’ll see some of the functions in action.</p>
<p class="calibre13">The <code class="calibre23">MoveTo()</code> function returns a <code class="calibre23">CPoint</code> object that specifies the current position as it was before the move. You might think this is a little odd, but consider the situation in which you want to move to a new position, draw something, and then move back. You may not know the current position before the move, and it is lost after the move occurs, so returning the position as it was before the move makes sure it’s available if you need it.</p>
<section class="toclist">
<h5 class="calibre27">Drawing Lines</h5>
<p class="calibre13">You can follow the call to <code class="calibre23">MoveTo()</code> in the <code class="calibre23">OnDraw()</code> function with a call to the <code class="calibre23">LineTo()</code> function, which draws a line in the client area from the current position to the point specified by the arguments, as illustrated in <a id="calibre_link-106" href="#calibre_link-105" class="calibre3">Figure 14-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000070.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-105" href="#calibre_link-106" class="calibre3">FIGURE 14-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The <code class="calibre23">CDC</code> class defines two versions of the <code class="calibre23">LineTo()</code> function that have the following prototypes:</p>
<pre class="calibre28"><code class="calibre23">BOOL LineTo(int x, int y);   // Draw a line to position x,y
BOOL LineTo(POINT aPoint);   // Draw a line to position defined by aPoint</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="671" id="calibre_link-1133" class="calibre14"></span>This offers you the same flexibility for the arguments as <code class="calibre23">MoveTo()</code>. You can use a <code class="calibre23">CPoint</code> object as the argument to the second version. The function returns <code class="calibre23">TRUE</code> if the line is drawn and <code class="calibre23">FALSE</code> otherwise.</p>
<p class="calibre13">When the <code class="calibre23">LineTo()</code> function executes, the current position is changed to the point at the end of the line. This enables you to draw a series of connected lines by just calling the <code class="calibre23">LineTo()</code> function for each line. Look at the following version of the <code class="calibre23">OnDraw()</code> function:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnDraw(CDC* pDC)
{
   CSketcherDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if(!pDoc)
     return;
        
   <b class="calibre12">pDC-&gt;MoveTo(50,50);        // Set the current position</b>
   <b class="calibre12">pDC-&gt;LineTo(50,200);       // Draw a vertical line down 150 units</b>
   <b class="calibre12">pDC-&gt;LineTo(150,200);      // Draw a horizontal line right 100 units</b>
   <b class="calibre12">pDC-&gt;LineTo(150,50);       // Draw a vertical line up 150 units</b>
   <b class="calibre12">pDC-&gt;LineTo(50,50);        // Draw a horizontal line left 100 units</b>
}</code></pre>
<p class="calibre13">If you plug this code into the Sketcher program and execute it, it will display the document window shown in <a id="calibre_link-108" href="#calibre_link-107" class="calibre3">Figure 14-4</a>. Don’t forget to uncomment the parameter name.</p>
<figure class="calibre16">
<img class="center" src="images/000030.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-107" href="#calibre_link-108" class="calibre3">FIGURE 14-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The four calls to <code class="calibre23">LineTo()</code> draw the rectangle counterclockwise starting with the upper-left corner. The first uses the current position set by the <code class="calibre23">MoveTo()</code> function; the succeeding calls use the current position set by the previous <code class="calibre23">LineTo()</code> function call. You can use this method to draw any figure consisting of a sequence of lines, each connected to the previous line. Of course, you can use <code class="calibre23">MoveTo()</code> to change the current position at any time.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Drawing Circles</h5>
<p class="calibre13">You have a choice of several <code class="calibre23">CDC</code> member functions for drawing circles, but they’re all designed to draw ellipses. As you know from high-school geometry, a circle is a special case of an ellipse that has its major and minor axes equal. You can, therefore, use the <code class="calibre23">Ellipse()</code> member to draw a circle. Like other closed shapes supported by the <code class="calibre23">CDC</code> class, the <code class="calibre23">Ellipse()</code> function fills the interior of the shape with a color that you set. The interior color is determined by a <i class="calibre15">brush</i> that is selected into the device context. A brush is one example of a GDI object that is used to draw in a window and is encapsulated by the MFC <code class="calibre23">CBrush</code> class. The current brush in the device context determines how any closed shape is filled. There are two versions of the <code class="calibre23">Ellipse()</code> function:</p>
<pre class="calibre28"><code class="calibre23">BOOL Ellipse(int x1, int y1, int x2, int y2);
BOOL Ellipse(LPCRECT lpRect);</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="672" id="calibre_link-1134" class="calibre14"></span>The first draws an ellipse bounded by the rectangle defined by the points <code class="calibre23">x1,y1</code>, and <code class="calibre23">x2,y2</code>. The second version defines the ellipse by a <code class="calibre23">RECT</code> object that is pointed to by the argument. The function also accepts a pointer to an object of the MFC <code class="calibre23">CRect</code> class, which has four public data members: <code class="calibre23">left, top, right</code>, and <code class="calibre23">bottom</code>. These correspond to the x- and y-coordinates of the upper-left and lower-right points of the rectangle. <code class="calibre23">CRect</code> provides member functions that operate on <code class="calibre23">CRect</code> objects, and you will be using some of these later. <code class="calibre23">Ellipse()</code> returns <code class="calibre23">TRUE</code> if the operation is successful and <code class="calibre23">FALSE</code> if it is not. With either function, the ellipse that is drawn extends up to, but does not include, the right and bottom sides of the rectangle. This means that the width and height of the ellipse are <code class="calibre23">x2&ndash;x1</code> and <code class="calibre23">y2&ndash;y1,</code> respectively.</p>
<p class="calibre13">You can set the color of a <code class="calibre23">CBrush</code> object and also define a pattern to be produced when you are filling a closed shape such as an ellipse. If you want to draw a closed shape that isn’t filled, you can select a null brush into the device context, which leaves the interior of the shape empty. I’ll come back to brushes a little later in this chapter.</p>
<p class="calibre13">Another way to draw circles that aren’t filled is to use the <code class="calibre23">Arc()</code> function, which doesn’t involve brushes. This is because the curve drawn by the <code class="calibre23">Arc()</code> function is not closed, and therefore cannot be filled. <code class="calibre23">Arc()</code> has the advantage that you can draw any arc of an ellipse. There are two versions of this function in the <code class="calibre23">CDC</code> class:</p>
<pre class="calibre28"><code class="calibre23">BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd);</code></pre>
<p class="calibre13">In the first version, (<code class="calibre23">x1</code>,<code class="calibre23">y1</code>) and (<code class="calibre23">x2</code>,<code class="calibre23">y2</code>) define the upper-left and lower-right corners of a rectangle enclosing the complete curve. If these coordinates are the corners of a square, the curve drawn is a segment of a circle. The points (<code class="calibre23">x3</code>,<code class="calibre23">y3</code>) and (<code class="calibre23">x4</code>,<code class="calibre23">y4</code>) define the start and end points of the segment to be drawn. The segment is drawn counterclockwise from (<code class="calibre23">x3</code>,<code class="calibre23">y3</code>) to (<code class="calibre23">x4</code>,<code class="calibre23">y4</code>). If you make (<code class="calibre23">x4</code>,<code class="calibre23">y4</code>) identical to (<code class="calibre23">x3</code>,<code class="calibre23">y3</code>), you’ll generate a complete ellipse, although it will not be a closed curve.</p>
<p class="calibre13">In the second version of <code class="calibre23">Arc()</code>, the enclosing rectangle is defined by a <code class="calibre23">RECT</code> object, and a pointer to this object is passed as the first argument. The <code class="calibre23">POINT</code> objects <code class="calibre23">startPt</code> and <code class="calibre23">endPt</code> define the start and end of the arc to be drawn, respectively.</p>
<p class="calibre13">Here’s some code that calls the <code class="calibre23">Ellipse()</code> and <code class="calibre23">Arc()</code> functions:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnDraw(CDC* pDC)
{
   CSketcherDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if(!pDoc)
     return;
        
   <b class="calibre12">pDC-&gt;Ellipse(50,50,150,150);             // Draw the 1st (large) circle</b>

   <b class="calibre12">// Define the bounding rectangle for the 2nd (smaller) circle</b>
   <b class="calibre12">CRect rect {250,50,300,100};</b>
   <b class="calibre12">CPoint start {275,100};                  // Arc start point</b>
   <span {http://www.idpf.org/2007/ops}type="pagebreak" title="673" id="calibre_link-1135" class="calibre14"></span><b class="calibre12">CPoint end {250,75};                     // Arc end point</b>
   <b class="calibre12">pDC-&gt;Arc(&amp;rect, start, end);             // Draw the second circle</b>
}</code></pre>
<p class="calibre13">You use a <code class="calibre23">CRect</code> class object instead of a <code class="calibre23">RECT</code> structure to define the bounding rectangle, and you use <code class="calibre23">CPoint</code> objects instead of <code class="calibre23">POINT</code> structures. You’ll be using <code class="calibre23">CRect</code> objects again later, and they have some limitations, as you’ll see. The <code class="calibre23">Arc()</code> and <code class="calibre23">Ellipse()</code> functions do not require a current position to be set because the position and extent of the curve are completely defined by the arguments you supply. The current position is unaffected by the drawing of an arc or an ellipse &mdash; it remains exactly wherever it was before the shape was drawn. Now, try running Sketcher with this code in the <code class="calibre23">OnDraw()</code> function. You should get the results shown in <a id="calibre_link-110" href="#calibre_link-109" class="calibre3">Figure 14-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000167.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-109" href="#calibre_link-110" class="calibre3">FIGURE 14-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Try moving the borders of the window. The client area is automatically redrawn as you cover or uncover the arcs. Remember that screen resolution affects the scale of what is displayed. The lower the screen resolution, the larger and farther from the upper-left corner of the client area the arcs will be.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Drawing in Color</h4>
<p class="calibre13">Everything that you’ve drawn so far has appeared on the screen in black. Drawing always uses a <i class="calibre15">pen object</i> that specifies the color, thickness, and line type (solid, dotted, dashed, and so on) that is drawn. A pen is another GDI object. You have been using the default pen object that is provided in a device context up to now. You’re not obliged to do this, of course &mdash; you can create your own pen with a given thickness, color, and line type. MFC defines the class <code class="calibre23">CPen</code> to help you do this.</p>
<section class="toclist">
<h5 class="calibre27">Creating a Pen</h5>
<p class="calibre13">The simplest way to create a pen is first to define an object of the <code class="calibre23">CPen</code> class using the default class constructor:</p>
<pre class="calibre28"><code class="calibre23">CPen aPen;                   // Define a pen object</code></pre>
<p class="calibre13">This object must be initialized with the properties you want and you do this by calling the <code class="calibre23">CreatePen()</code> function for the object. This function is declared in the <code class="calibre23">CPen</code> class as:</p>
<pre class="calibre28"><code class="calibre23">BOOL CreatePen(int aPenStyle, int aWidth, COLORREF aColor);</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="674" id="calibre_link-1136" class="calibre14"></span>The function returns <code class="calibre23">TRUE</code> as long as the pen is successfully initialized and <code class="calibre23">FALSE</code> otherwise. The first argument defines the line style, which must be one of the following symbolic values:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">PEN STYLE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_SOLID</code></td>
<td class="calibre32">The pen draws a solid line.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_DASH</code></td>
<td class="calibre32">The pen draws a dashed line. This line style is valid only when the pen width is <code class="calibre23">1</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_DOT</code></td>
<td class="calibre32">The pen draws a dotted line. This line style is valid only when the pen width is <code class="calibre23">1</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_DASHDOT</code></td>
<td class="calibre32">The pen draws a line with alternating dashes and dots. This line style is valid only when the pen width is <code class="calibre23">1</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_DASHDOTDOT</code></td>
<td class="calibre32">The pen draws a line with alternating dashes and double dots. This line style is valid only when the pen width is <code class="calibre23">1</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_NULL</code></td>
<td class="calibre32">The pen doesn’t draw anything.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">PS_INSIDEFRAME</code></td>
<td class="calibre32">The pen draws a solid line but, unlike with <code class="calibre23">PS_SOLID</code>, the points that specify the line occur on the edge of the pen rather than in the center, so that the drawn object never extends beyond the defining rectangle for closed shapes such as ellipses.</td>
</tr>
</tbody>
</table>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">There is another</i> <code class="calibre23">CPen</code> <i class="calibre15">class constructor that enables you to create your own line styles. You specify a line style by an array of values that specify the lengths of the dashes and spaces in the line.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The second argument to <code class="calibre23">CreatePen()</code> defines the line width. If <code class="calibre23">aWidth</code> is <code class="calibre23">0</code>, the line is one pixel wide, regardless of the mapping mode in effect. For values of <code class="calibre23">1</code> or more, the pen width is in units determined by the mapping mode. For example, a value of <code class="calibre23">2</code> for <code class="calibre23">aWidth</code> in <code class="calibre23">MM_TEXT</code> mode is two pixels; in <code class="calibre23">MM_LOENGLISH</code> mode, the pen width is 0.02 inches.</p>
<p class="calibre13">The last argument specifies the line color, so you could initialize a pen with the following statement:</p>
<pre class="calibre28"><code class="calibre23">aPen.CreatePen(PS_SOLID, 2, RGB(255,0,0));  // Create a red solid pen</code></pre>
<p class="calibre13">If the mapping mode is <code class="calibre23">MM_TEXT</code>, this pen draws a solid red line that is two pixels wide. <code class="calibre23">RGB</code> is the macro that you met in Chapter 13. It creates a 24-bit color value composed from three unsigned byte integer values that are the intensities of the red, green, and blue components of the color.</p>
<p class="calibre13">You can also create a pen object with specified line type, width, and color using the constructor:</p>
<pre class="calibre28"><code class="calibre23">CPen aPen{PS_SOLID, 2, RGB(0, 255, 0)};     // Create a green solid pen</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="675" id="calibre_link-1137" class="calibre14"></span>When you create a pen of your own in this way, you are creating a Windows GDI <code class="calibre23">PEN</code> object that is encapsulated by the <code class="calibre23">CPen</code> object. When the <code class="calibre23">CPen</code> object is destroyed, the <code class="calibre23">CPen</code> destructor will delete the GDI pen object automatically. If you create a GDI <code class="calibre23">PEN</code> object explicitly, you must delete the object by calling <code class="calibre23">DeleteObject()</code> with the <code class="calibre23">PEN</code> object as the argument.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Using a Pen</h5>
<p class="calibre13">To use a pen, you must select it into the device context. You call the <code class="calibre23">SelectObject()</code> function for the <code class="calibre23">CDC</code> object to do this. To select a pen, you call this function with the address of the pen object as the argument. The function returns a pointer to the previous pen object, so that you can save the old pen and restore it when you have finished drawing. A typical statement selecting a pen is:</p>
<pre class="calibre28"><code class="calibre23">CPen* pOldPen {pDC-&gt;SelectObject(&amp;aPen)}    // Select aPen as the pen</code></pre>
<p class="calibre13">You must always return a device context to its original state once you have finished with whatever you have selected into it. To restore the old pen when you’re done, you call <code class="calibre23">SelectObject()</code> again, passing the pointer returned from the original call as the argument:</p>
<pre class="calibre28"><code class="calibre23">pDC-&gt;SelectObject(pOldPen);                 // Restore the old pen</code></pre>
<p class="calibre13">You can see all this in action if you amend the previous version of the <code class="calibre23">OnDraw()</code> function in <code class="calibre23">CSketcherView</code> to the following:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnDraw(CDC* pDC)
{
   CSketcherDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if(!pDoc)
     return;
 
   <b class="calibre12">// Declare a pen object and initialize it as</b>
   <b class="calibre12">// a red solid pen drawing a line 2 pixels wide</b>
   <b class="calibre12">CPen aPen;</b>
   <b class="calibre12">aPen.CreatePen(PS_SOLID, 2, RGB(255, 0, 0));</b>

   <b class="calibre12">CPen* pOldPen {pDC-&gt;SelectObject(&amp;aPen)}; // Select aPen as the pen</b>
   pDC-&gt;Ellipse(50,50,150,150);              // Draw the 1st (large) circle
 
   // Define the bounding rectangle for the 2nd (smaller) circle
   CRect rect {250,50,300,100};
   CPoint start {275,100};                   // Arc start point
   CPoint end {250,75};                      // Arc end point
   pDC-&gt;Arc(&amp;rect,start, end);               // Draw the second circle
   <b class="calibre12">pDC-&gt;SelectObject(pOldPen);               // Restore the old pen</b>
}</code></pre>
<p class="calibre13">If you build and execute Sketcher with this version of <code class="calibre23">OnDraw()</code>, you get the same curves drawn as before, but this time, the lines will be thicker and they’ll be red. You could usefully experiment with <span {http://www.idpf.org/2007/ops}type="pagebreak" title="676" id="calibre_link-1138" class="calibre14"></span>this example by trying different combinations of arguments to the <code class="calibre23">CreatePen()</code> function and seeing their effects. Note that we have ignored the value returned from the <code class="calibre23">CreatePen()</code> function, so you run the risk of the function failing and not detecting it in the program. It doesn’t matter here, as the program is trivial, but as you develop the program, it is important to check for failures of this kind.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Creating a Brush</h5>
<p class="calibre13">An object of the <code class="calibre23">CBrush</code> class encapsulates a Windows brush. You can define a brush to be solid, hatched, or patterned. A brush is an eight-by-eight block of pixels that’s repeated over the region to be filled.</p>
<p class="calibre13">To define a brush with a solid color, you just specify the color when you create the object. For example:</p>
<pre class="calibre28"><code class="calibre23">CBrush aBrush {RGB(255,0,0)};           // Define a red brush</code></pre>
<p class="calibre13">This defines a red brush. The value passed to the <code class="calibre23">CBrush</code> constructor must be of type <code class="calibre23">COLORREF</code>, which is the type produced by the <code class="calibre23">RGB()</code> macro so this is a good way to specify the color.</p>
<p class="calibre13">Another constructor defines a hatched brush. It requires two arguments: the first defines the type of hatching, and the second specifies the color. The hatching argument can be any of the following:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">HATCHING STYLE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HS_HORIZONTAL</code></td>
<td class="calibre32">Horizontal hatching</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HS_VERTICAL</code></td>
<td class="calibre32">Vertical hatching</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HS_BDIAGONAL</code></td>
<td class="calibre32">Downward hatching from left to right at 45 degrees</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HS_FDIAGONAL</code></td>
<td class="calibre32">Upward hatching from left to right at 45 degrees</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HS_CROSS</code></td>
<td class="calibre32">Horizontal and vertical crosshatching</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HS_DIAGCROSS</code></td>
<td class="calibre32">Crosshatching at 45 degrees</td>
</tr>
</tbody>
</table>
<p class="calibre13">To obtain a red, 45-degree crosshatched brush, you could define the <code class="calibre23">CBrush</code> object with the following statement:</p>
<pre class="calibre28"><code class="calibre23">CBrush aBrush {HS_DIAGCROSS, RGB(255,0,0)};</code></pre>
<p class="calibre13">You can initialize a <code class="calibre23">CBrush</code> object much as you do a <code class="calibre23">CPen</code> object, by calling the <code class="calibre23">CreateSolidBrush()</code> member for a <code class="calibre23">CBrush</code> object to initialize it as a solid brush, and the <code class="calibre23">CreateHatchBrush()</code> member for a hatched brush. They require the same arguments as the equivalent constructors. For example, you could create the same hatched brush as before with the following statements:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="677" id="calibre_link-1139" class="calibre14"></span>CBrush aBrush;                         // Define a brush object
aBrush.CreateHatchBrush(HS_DIAGCROSS, RGB(255,0,0));</code></pre>
</section>
<section class="toclist">
<h5 class="calibre27">Using a Brush</h5>
<p class="calibre13">To use a brush, you select the brush into the device context by calling the <code class="calibre23">SelectObject()</code> member of the <code class="calibre23">CDC</code> object much as you did for a pen. This member function is overloaded to support selecting brush objects into a device context. This selects the brush defined previously:</p>
<pre class="calibre28"><code class="calibre23">CBrush* pOldBrush {pDC-&gt;SelectObject(&amp;aBrush)};    // Select the brush into the DC</code></pre>
<p class="calibre13"><code class="calibre23">SelectObject()</code> returns a pointer to the old brush, or <code class="calibre23">nullptr</code> if the operation fails. You use the pointer that is returned to restore the old brush in the device context when you are done.</p>
<p class="calibre13">There are seven standard brushes available that are identified by predefined constants. They are:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">GRAY_BRUSH</code></td>
<td class="calibre32"><code class="calibre23">LTGRAY_BRUSH</code></td>
<td class="calibre32"><code class="calibre23">DKGRAY_BRUSH</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">BLACK_BRUSH</code></td>
<td class="calibre32"><code class="calibre23">WHITE_BRUSH</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">HOLLOW_BRUSH</code></td>
<td class="calibre32"><code class="calibre23">NULL_BRUSH</code></td>
<td class="calibre32">&nbsp;</td>
</tr>
</tbody>
</table>
<p class="calibre13">The names are quite self-explanatory. To use one, call the <code class="calibre23">SelectStockObject()</code> member of the <code class="calibre23">CDC</code> object, with the symbolic name for the brush that you want to use as the argument. To select the null brush that leaves the interior of a closed shape unfilled, you would write this:</p>
<pre class="calibre28"><code class="calibre23">CBrush* pOldBrush {dynamic_cast&lt;CBrush*&gt;(pDC-&gt;SelectStockObject(NULL_BRUSH))};</code></pre>
<p class="calibre13"><code class="calibre23">pDC</code> is a pointer to the <code class="calibre23">CDC</code> object, as before. You can also select one of a range of standard pens with the <code class="calibre23">SelectStockObject()</code> function. The symbols for standard pens are <code class="calibre23">BLACK_PEN, NULL_PEN</code> (which doesn’t draw anything), and <code class="calibre23">WHITE_PEN. SelectStockObject()</code> works with a variety of object types. You’ve seen pens and brushes in this chapter but it also works with fonts. The return type for <code class="calibre23">SelectStockObject()</code> is <code class="calibre23">CGdiObject*. CGdiObject</code> is a base class for all the GDI object classes, so a pointer to this class type can store the address of any GDI object. You can store the pointer returned by <code class="calibre23">SelectObject()</code> or <code class="calibre23">SelectStockObject()</code> as type <code class="calibre23">CGdiObject*</code> and pass that to <code class="calibre23">SelectObject()</code> when you want to restore it. However, it is better to <code class="calibre23">dynamic_cast</code> the pointer value to the appropriate type so that you can keep track of the types of objects you are restoring.</p>
<p class="calibre13">The typical coding pattern for using a stock brush and later restoring the old brush when you’re done is this:</p>
<pre class="calibre28"><code class="calibre23">CBrush* pOldBrush {dynamic_cast&lt;CBrush*&gt;(pDC-&gt;SelectStockObject(NULL_BRUSH))};
        
// draw something...
        
pDC-&gt;SelectObject(pOldBrush);                // Restore the old brush</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="678" id="calibre_link-1140" class="calibre14"></span>You’ll be using this pattern in an example later in the chapter.</p>
</section>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-350" class="calibre3"></a>DRAWING GRAPHICS IN PRACTICE</h2>
<p class="calibre13">You now know how to draw lines and arcs, so it’s about time to consider how a user is going to draw in Sketcher. In other words, you need to decide how the user interface is going to work.</p>
<p class="calibre13">Because Sketcher is to be a sketching tool, you don’t want the user to worry about coordinates. The easiest mechanism for drawing is using just the mouse. To draw a line for instance, users could position the mouse cursor where the line is to start and press the left mouse button; they could then define the end of the line by moving the cursor to where they want with the button held down, then releasing it. It would be ideal if you could arrange for the line to be continuously drawn as the cursor is moved with the button down (this is known as “rubber-banding”). The line would be fixed when the mouse button is released. <a id="calibre_link-112" href="#calibre_link-111" class="calibre3">Figure 14-6</a> illustrates this process.</p>
<figure class="calibre16">
<img class="center" src="images/000124.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-111" href="#calibre_link-112" class="calibre3">FIGURE 14-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Circles can be drawn in a similar fashion. The point where the mouse button is pressed defines the center, and as the cursor is dragged with the button down, the program tracks and redraws the circle continuously with the cursor position defining a point on the circumference. Like the line, the circle is fixed when the button is released. <a id="calibre_link-114" href="#calibre_link-113" class="calibre3">Figure 14-7</a> shows this process.</p>
<figure class="calibre16">
<img class="center" src="images/000082.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-113" href="#calibre_link-114" class="calibre3">FIGURE 14-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="679" id="calibre_link-1141" class="calibre14"></span>You can draw a rectangle as easily as you draw a line, as illustrated in <a id="calibre_link-116" href="#calibre_link-115" class="calibre3">Figure 14-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000045.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-115" href="#calibre_link-116" class="calibre3">FIGURE 14-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="680" id="calibre_link-1142" class="calibre14"></span>The first point is defined by the cursor position when the left mouse button is pressed. This is one corner of the rectangle. The cursor position when the mouse is moved with the button held down defines the diagonally opposite corner of the rectangle. The rectangle stored is the one defined when the button is released.</p>
<p class="calibre13">A curve is somewhat different. An arbitrary number of points may define a curve. The mechanism you’ll use is illustrated in <a id="calibre_link-118" href="#calibre_link-117" class="calibre3">Figure 14-9</a>. As with the other shapes, the first point is defined by the cursor position when the left mouse button is pressed. Successive cursor positions that are recorded as the mouse cursor is moved are connected by straight line segments to form the curve, so the mouse cursor track defines the curve to be drawn.</p>
<figure class="calibre16">
<img class="center" src="images/000007.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-117" href="#calibre_link-118" class="calibre3">FIGURE 14-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Now that you know how the user is going to define elements, the next step in understanding how you can implement this process is to get a grip on how the mouse is programmed.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-351" class="calibre3"></a>PROGRAMMING FOR THE MOUSE</h2>
<p class="calibre13">To program the drawing of Sketcher elements in the way that I have discussed, you need to identify how the mouse will be used:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="681" id="calibre_link-1143" class="calibre14"></span>Pressing a mouse button signals the start of a drawing operation.</li>
<li class="calibre6">The location of the cursor when the mouse button is pressed provides a first defining point for the shape.</li>
<li class="calibre6">A mouse movement after detecting that a mouse button has been pressed is a cue to draw a shape, and the cursor position provides a second defining point for the shape.</li>
<li class="calibre6">Releasing the mouse button signals the end of the drawing operation and that the final version of the shape should be drawn using the last cursor position.</li>
</ul>
<p class="calibre13">As you may have guessed, all the information about what is happening with the mouse and its buttons is provided by Windows in the form of messages sent to your program. The implementation of the process for drawing lines, rectangles, circles, and curves consists almost entirely of writing message handlers.</p>
<section class="toclist">
<h3 class="calibre21">Messages from the Mouse</h3>
<p class="calibre13">When the users of your program are drawing an element, they will interact with a particular document view. The view class is, therefore, the obvious place to put the message handlers for the mouse. Right-click the <code class="calibre23">CSketcherView</code> class name in Class View and then display its properties window by selecting Properties from the menu. If you then click the messages button (wait for the button tooltips to display if you don’t know which it is) you’ll see the list of IDs for the standard Windows messages that are sent to the class, which are prefixed with <code class="calibre23">WM_</code> (see <a id="calibre_link-120" href="#calibre_link-119" class="calibre3">Figure 14-10</a>).</p>
<figure class="calibre16">
<img class="center" src="images/000139.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-119" href="#calibre_link-120" class="calibre3">FIGURE 14-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You need to know about three mouse messages at the moment:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">MESSAGE</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_LBUTTONDOWN</code></td>
<td class="calibre32">Occurs when the left mouse button is pressed</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_LBUTTONUP</code></td>
<td class="calibre32">Occurs when the left mouse button is released</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WM_MOUSEMOVE</code></td>
<td class="calibre32">Occurs when the mouse is moved</td>
</tr>
</tbody>
</table>
<p class="calibre13">These messages are quite independent of one another and are sent to the document views in your program even if you haven’t supplied handlers for them. It’s quite possible for a window to receive a <code class="calibre23">WM_LBUTTONUP</code> message without having previously received a <code class="calibre23">WM_LBUTTONDOWN</code> message. This can happen if the button is pressed with the cursor over another window and the cursor is then moved to your view window before being released, so you must keep this in mind when coding handlers for these messages.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="682" id="calibre_link-1144" class="calibre14"></span>If you look at the list in the Properties window, you’ll see there are other mouse messages that can occur. You can choose to process any or all of these, depending on your application. Let’s define in general terms what we want to do with the three messages we are currently interested in, based on the process we have defined for drawing lines, rectangles, and circles.</p>
<section class="toclist">
<h4 class="calibre22">WM_LBUTTONDOWN</h4>
<p class="calibre13">This message starts the process of drawing an element. You should do the following:</p>
<ol class="calibre5">
<li class="calibre6">Record that the element-drawing process has started.</li>
<li class="calibre6">Store the current cursor position as the first defining point for an element.</li>
</ol>
</section>
<section class="toclist">
<h4 class="calibre22">WM_MOUSEMOVE</h4>
<p class="calibre13">This message is an intermediate stage in drawing an element in which you want to create and draw a temporary version of it, but only if the left mouse button is down. Complete the following steps:</p>
<ol class="calibre5">
<li class="calibre6">Verify that the left button is down.</li>
<li class="calibre6">If the left button is down, delete any previous version of the current element that was drawn.</li>
<li class="calibre6">If the left button isn’t down, then exit the element creation operation.</li>
<li class="calibre6">Record the current cursor position as the second defining point for the current element.</li>
<li class="calibre6">Cause the current element to be drawn using the two defining points.</li>
</ol>
</section>
<section class="toclist">
<h4 class="calibre22">WM_LBUTTONUP</h4>
<p class="calibre13">This message indicates that the element drawing process is finished. You need to do the following:</p>
<ol class="calibre5">
<li class="calibre6">Store the final version of the element defined by the first point recorded, together with the last cursor position when the button was released for the second point.</li>
<li class="calibre6">Record the end of the process of drawing an element.</li>
</ol>
<p class="calibre13">Now you are ready to generate handlers for these messages.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Mouse Message Handlers</h3>
<p class="calibre13">Display the Properties for the <code class="calibre23">CSketcherView</code> class and click the <code class="calibre23">Messages</code> icon to display the messages this class can handle. You can create a handler for a mouse message by clicking its ID in the Properties window to select it and then selecting from the list that is displayed when you click the down arrow in the adjacent column position. Try selecting <code class="calibre23">&lt;add&gt; OnLButtonUp</code> for the <code class="calibre23">WM_LBUTTONUP</code> message, for example. Repeat the process for the <code class="calibre23">WM_LBUTTONDOWN</code> and <code class="calibre23">WM_MOUSEMOVE</code> messages. The functions generated in <code class="calibre23">CSketcherView</code> are <code class="calibre23">OnLButtonDown(), OnLButtonUp()</code>, and <code class="calibre23">OnMouseMove()</code>. You don’t get the option of changing the names of these, because you’re adding overrides for versions already defined in the base class. Now, we’ll look at how you implement these handlers.</p>
<p class="calibre13">You can start with the <code class="calibre23">WM_LBUTTONDOWN</code> message handler. This is the skeleton code that’s generated:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="683" id="calibre_link-1145" class="calibre14"></span>void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
  // TODO: Add your message handler code here and/or call default
        
  CView::OnLButtonDown(nFlags, point);
}</code></pre>
<p class="calibre13">There is a call to the base class handler in the skeleton version. This ensures that the base handler is called if you don’t add any code. You don’t need to call the base class handler when you handle this message yourself, although you can if you want to. Whether you need to call a base class message handler depends on the circumstances.</p>
<p class="calibre13">Generally, the comment in the implementation of your handler that indicates where you should add your code is a good guide. Where it suggests, as in the present instance, that calling the base class handler is optional, you can omit it when you add your own code. The position of the comment in relation to the base class handler call is also important, because sometimes you must call the base class handler before your code, and sometimes afterwards. The comment indicates where your code should appear in relation to the base class handler call.</p>
<p class="calibre13">The <code class="calibre23">WM_LBUTTONDOWN</code> handler is passed two arguments:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">nFlags</code> is of type <code class="calibre23">UINT</code> and contains a number of status flags indicating which keys and/or mouse buttons are down. The <code class="calibre23">UINT</code> type is defined in the Windows API and corresponds to a 32-bit unsigned integer.</li>
<li class="calibre6">The <code class="calibre23">CPoint</code> object, <code class="calibre23">point</code>, defines the cursor position when the left mouse button was pressed.</li>
</ul>
<p class="calibre13">The value of <code class="calibre23">nFlags</code> can be any combination of the following values:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FLAG</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_CONTROL</code></td>
<td class="calibre32">The control key is pressed.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_LBUTTON</code></td>
<td class="calibre32">The left mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_MBUTTON</code></td>
<td class="calibre32">The middle mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_RBUTTON</code></td>
<td class="calibre32">The right mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_XBUTTON1</code></td>
<td class="calibre32">The first extra mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_XBUTTON2</code></td>
<td class="calibre32">The second extra mouse button is down.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">MK_SHIFT</code></td>
<td class="calibre32">The shift key is pressed.</td>
</tr>
</tbody>
</table>
<p class="calibre13">Being able to detect if a key is pressed enables you to support different actions for the message, depending on the states of the key. <code class="calibre23">nFlags</code> may contain more than one of these flags, each of which corresponds to a unique single bit in the word. You can test if a particular flag bit is 1 using the bitwise <code class="calibre23">AND</code> operator. For example, to test if the control key is pressed you could write:</p>
<pre class="calibre28"><code class="calibre23">if(nFlags &amp; MK_CONTROL)
  // Do something...</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="684" id="calibre_link-1146" class="calibre14"></span>The expression <code class="calibre23">nFlags &amp; MK_CONTROL</code> will be a non-zero value that converts to <code class="calibre23">true</code> only if <code class="calibre23">nFlags</code> has the <code class="calibre23">MK_CONTROL</code> bit set. In this way, you can perform different actions when the left mouse button is pressed, depending on whether or not the control key is pressed. You use the bitwise <code class="calibre23">AND</code> operator here, which <code class="calibre23">AND</code>s corresponding bits together. Don’t confuse this with the logical <code class="calibre23">AND, &amp;&amp;</code>, which would not do what you want.</p>
<p class="calibre13">The arguments passed to the other two message handlers are the same as those for <code class="calibre23">OnLButtonDown()</code>; the code generated for them is:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonUp(UINT nFlags, CPoint point)
{
  // TODO: Add your message handler code here and/or call default
        
  CView::OnLButtonUp(nFlags, point);
}
        
void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  // TODO: Add your message handler code here and/or call default
        
  CView::OnMouseMove(nFlags, point);
}</code></pre>
<p class="calibre13">The skeleton code is more or less the same for each.</p>
<p class="calibre13">If you look at the end of the code for the <code class="calibre23">CSketcherView</code> class definition, you’ll see that three function declarations have been added:</p>
<pre class="calibre28"><code class="calibre23">// Generated message map functions
protected:
  DECLARE_MESSAGE_MAP()
public:
  <b class="calibre12">afx_msg void OnLButtonDown(UINT nFlags, CPoint point);</b>
  <b class="calibre12">afx_msg void OnLButtonUp(UINT nFlags, CPoint point);</b>
  <b class="calibre12">afx_msg void OnMouseMove(UINT nFlags, CPoint point);</b>
};</code></pre>
<p class="calibre13">These identify the functions that you added as message handlers. Now that you understand the information that is passed to the mouse message handlers, you can add your own code to make them do what you want.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Drawing Using the Mouse</h3>
<p class="calibre13">For the <code class="calibre23">WM_LBUTTONDOWN</code> message, you want to record the cursor position as the first defining point for an element. You also want to record the cursor position after a mouse move. The obvious place to store these positions is in the <code class="calibre23">CSketcherView</code> class, so you can add data members for these. Right-click the <code class="calibre23">CSketcherView</code> class name in Class View and select Add <img src="images/000122.png" alt="image" class="calibre25" /> Add Variable from the pop-up. You’ll then be able to add details of the variable to be added to the class, as <a id="calibre_link-122" href="#calibre_link-121" class="calibre3">Figure 14-11</a> shows.</p>
<figure class="calibre16">
<img class="center" src="images/000096.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-121" href="#calibre_link-122" class="calibre3">FIGURE 14-11</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="685" id="calibre_link-1147" class="calibre14"></span>The drop-down list of types includes only fundamental types, so you must enter the variable type as <code class="calibre23">CPoint</code>. The new data member should be <code class="calibre23">protected</code> to prevent direct modification of it from outside the class so change the Access value to that from the list. Enter the name as <code class="calibre23">m_FirstPoint</code>. When you click the Finish button, the variable will be created and an initial value will be set arbitrarily as <code class="calibre23">0</code> in the constructor initializer.</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">CSketcherView::CSketcherView(): m_FirstPoint {CPoint {}}</b>
{
   // TODO: add construction code here
}</code></pre>
<p class="calibre13">The MSDN documentation for the <code class="calibre23">CPoint</code> class says that the default constructor does not initialize the data members but this is not correct. The code for the default <code class="calibre23">CPoint</code> constructor initializes both members to zero. This has been the case since Visual Studio 2010 but the documentation hasn’t caught up yet. This means that if you are happy with (0,0) as the default for a <code class="calibre23">CPoint</code> object you don’t need to worry about initializing it explicitly. I have removed the initialization from the code in <code class="calibre23">SketcherView.cpp</code>.</p>
<p class="calibre13">You can now implement the handler for the <code class="calibre23">WM_LBUTTONDOWN</code> message as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
   <b class="calibre12">m_FirstPoint = point;               // Record the cursor position</b>
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="686" id="calibre_link-1148" class="calibre14"></span>All the handler does is record the point passed by the second argument. You can ignore the first argument in this situation altogether.</p>
<p class="calibre13">You can’t complete the <code class="calibre23">WM_MOUSEMOVE</code> message handler yet, but you can have a stab at outlining the code for it:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
   <b class="calibre12">if(nFlags &amp; MK_LBUTTON)             // Verify the left button is down</b>
   <b class="calibre12">{</b>
      <b class="calibre12">m_SecondPoint = point;           // Save the current cursor position</b>

      <b class="calibre12">// Test for a previous temporary element</b>
      <b class="calibre12">{</b>
         <b class="calibre12">// We get to here if there was a previous mouse move</b>
         <b class="calibre12">// so add code to delete the old element</b>
      <b class="calibre12">}</b>

      <b class="calibre12">// Add code to create new element</b>
      <b class="calibre12">// and cause it to be drawn</b>
   <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">It’s important to verify that the left mouse button is down because you want to handle the mouse move only when this is the case. Without the check, you would be processing the event when the right button was down or when the mouse was moved with no buttons pressed.</p>
<p class="calibre13">If the left mouse button is down, you save the current cursor position. This is the second defining point for an element. The rest of the logic is clear in general terms, but you need to establish a few more things before you can complete the function. You have no means of defining an element &mdash; you’ll want to define an element as a class object, so you must define some classes. You must also devise a way to delete an element and get one drawn when you create a new one. A brief digression is called for.</p>
<section class="toclist">
<h4 class="calibre22">Getting the Client Area Redrawn</h4>
<p class="calibre13">Drawing or erasing elements involves redrawing all or part of the client area of a window. As you’ve already discovered, the client area gets drawn by the <code class="calibre23">OnDraw()</code> member function of the <code class="calibre23">CSketcherView</code> class, and this function is called when a <code class="calibre23">WM_PAINT</code> message is received by the Sketcher application. Along with the basic message to repaint the client area, Windows supplies information about the area that needs to be redrawn. This can save a lot of time when you’re displaying complicated images because only the area specified needs to be redrawn, and this may be a very small proportion of the total area.</p>
<p class="calibre13">You can tell Windows that a particular area should be redrawn by calling the <code class="calibre23">InvalidateRect()</code> member of your view class. The function requires two arguments. The first is a pointer to a <code class="calibre23">RECT</code> or <code class="calibre23">CRect</code> object that defines the rectangle in the client area to be redrawn. Passing <code class="calibre23">nullptr</code> causes the whole client area to be redrawn. The second argument is a <code class="calibre23">BOOL</code> value, which is <code class="calibre23">TRUE</code> if the background to the rectangle is to be erased and <code class="calibre23">FALSE</code> otherwise. This argument has a default value of <code class="calibre23">TRUE</code>, because you normally want the background erased before the rectangle is redrawn, so you don’t need to supply it most of the time.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="687" id="calibre_link-1149" class="calibre14"></span>A typical situation in which you will want to cause an area to be redrawn will be where something has changed in a way that makes it necessary &mdash; moving something displayed in the client area entity is one example. In this case, you want to erase the background to remove the old representation of what was displayed before you draw the new version. When you want to draw over an existing background, you pass <code class="calibre23">FALSE</code> as the second argument to <code class="calibre23">InvalidateRect()</code>.</p>
<p class="calibre13">Calling <code class="calibre23">InvalidateRect()</code> doesn’t directly cause any part of the window to be redrawn; it just communicates the rectangle that you would like to have redrawn to Windows. Windows maintains a cumulative update region &mdash; actually, a rectangle &mdash; that identifies the total area that needs to be redrawn, and this may be due to several <code class="calibre23">InvalidateRect()</code> calls. The area specified in your call to <code class="calibre23">InvalidateRect()</code> is added to the current update region, so the new update region encloses the old region plus the new rectangle you have identified. When a <code class="calibre23">WM_PAINT</code> message is sent to a view, the update region is passed to the view object along with the message. When processing of the <code class="calibre23">WM_PAINT</code> message is complete, the update region is reset to the empty state. Calling the <code class="calibre23">UpdateWindow()</code> function that is inherited in the view class causes a <code class="calibre23">WM_PAINT</code> message to be sent to the view.</p>
<p class="calibre13">Thus, to get a newly created element drawn you need to:</p>
<ol class="calibre5">
<li class="calibre6">Make sure that the <code class="calibre23">OnDraw()</code> function in your view includes the newly created element when it redraws the window.</li>
<li class="calibre6">Call <code class="calibre23">InvalidateRect()</code> with a pointer to the rectangle bounding the element to be redrawn as the first argument.</li>
<li class="calibre6">Cause a <code class="calibre23">WM_PAINT</code> message to be sent to the view by calling the inherited <code class="calibre23">UpdateWindow()</code> function for the view.</li>
</ol>
<p class="calibre13">Similarly, if you want an element removed from the client area of a window, you need to do the following:</p>
<ol class="calibre5">
<li class="calibre6">Remove the element from the items that the <code class="calibre23">OnDraw()</code> function will draw.</li>
<li class="calibre6">Call <code class="calibre23">InvalidateRect()</code> with the first argument pointing to the rectangle bounding the element that is to be removed.</li>
<li class="calibre6">Cause a <code class="calibre23">WM_PAINT</code> message to be sent to the view by calling the inherited <code class="calibre23">UpdateWindow()</code> function for the view.</li>
</ol>
<p class="calibre13">Because the background to the update region is automatically erased, the element disappears as long as the <code class="calibre23">OnDraw()</code> function doesn’t draw the element again. Of course, this means that you need to be able to obtain the rectangle bounding any element that you create, so you’ll include a function to return this rectangle as a member of the classes that define Sketcher elements.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Defining Element Classes</h4>
<p class="calibre13">Thinking ahead a bit, as well as storing sketch elements in a document in some way, you will want to store the document in a file for subsequent retrieval if a sketch is to have any permanence. I’ll deal with the details of file operations later on, but for now, it’s enough to know that the MFC class <code class="calibre23">CObject</code> includes the tools for you to do this, so you’ll use <code class="calibre23">CObject</code> as a base class for the classes that define sketch elements.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="688" id="calibre_link-1150" class="calibre14"></span>You don’t know in advance what sequence of element types a user will create, so Sketcher must be able to handle any sequence of elements. This suggests that using a base class pointer to store the address of the latest element that was created might simplify things a bit. You’ll be able to call element class functions without knowing precisely what kind of element it is. For example, you don’t need to know what an element is to draw it. As long as you are accessing the element through a base class pointer, you can always get an element to draw itself by calling a <code class="calibre23">virtual</code> function. All you must do to achieve this is to make sure that the classes that define elements share a common base class and that you declare all the functions you want to be called polymorphically at run time as <code class="calibre23">virtual</code> in the base class. You could organize the element classes as shown in <a id="calibre_link-124" href="#calibre_link-123" class="calibre3">Figure 14-12</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000037.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-123" href="#calibre_link-124" class="calibre3">FIGURE 14-12</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Each arrow in the diagram points toward a base class. If you need to add another type of element, you derive another class from <code class="calibre23">CElement</code>.</p>
<p class="calibre13">You can create the <code class="calibre23">CElement</code> class by right-clicking Sketcher in Class View and selecting Add <img src="images/000122.png" alt="image" class="calibre25" /> Class from the pop-up. Select MFC from the list of installed templates, and then select MFC Class in the center pane. When you click the Add button in the dialog, another dialog displays in which you can specify the class name and select the base class, as shown in <a id="calibre_link-126" href="#calibre_link-125" class="calibre3">Figure 14-13</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000014.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-125" href="#calibre_link-126" class="calibre3">FIGURE 14-13</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="689" id="calibre_link-1151" class="calibre14"></span>I have already filled in the class name as <code class="calibre23">CElement</code> and selected <code class="calibre23">CObject</code> from the drop-down list as the base class. When you click the Finish button, the code for the class definition is generated:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
        
        
// CElement command target
        
class CElement : public CObject
{
public:
  CElement();
  virtual ~CElement();
};</code></pre>
<p class="calibre13">The only members that have been declared for you are a constructor and a virtual destructor, and skeleton definitions for these appear in the <code class="calibre23">Element.cpp</code> file. You can see that the Class Wizard has included a <code class="calibre23">#pragma once</code> directive to ensure that the contents of the header file cannot be included into another file more than once.</p>
<p class="calibre13">You can add the other element classes using essentially the same process. Because the other element classes have <code class="calibre23">CElement</code> rather than an MFC class as the base class, you should set the class category as <code class="calibre23">C++</code> and the template as <code class="calibre23">C++ class</code>. Select the Virtual destructor option. For the <code class="calibre23">CLine</code> class, the Class Wizard dialog should look like <a id="calibre_link-128" href="#calibre_link-127" class="calibre3">Figure 14-14</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000159.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-127" href="#calibre_link-128" class="calibre3">FIGURE 14-14</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="690" id="calibre_link-1152" class="calibre14"></span>The Class Wizard supplies the names of the header file and <code class="calibre23">.cpp</code> file as <code class="calibre23">Line.h</code> and <code class="calibre23">Line.cpp</code> by default, but you can change these to different names or have the code added to existing files. You get an <code class="calibre23">#include</code> directive for <code class="calibre23">Element.h</code> for the base class definition. When you have created the <code class="calibre23">CLine</code> class, do the same for <code class="calibre23">CRectangle, CCircle</code>, and <code class="calibre23">CCurve</code>. When you are done, you should have <code class="calibre23">.h</code> files containing the definitions of all four subclasses of <code class="calibre23">CElement</code>, each with a constructor and a virtual destructor.</p>
<section class="toclist">
<h5 class="calibre27">Storing a Temporary Element in the View</h5>
<p class="calibre13">When I discussed how sketch elements would be drawn, it was evident that as the mouse was dragged with the left mouse button down, a series of temporary element objects would be created and drawn. The base class for all elements is <code class="calibre23">CElement</code>, so you can add a smart pointer of type <code class="calibre23">std::shared_ptr&lt;CElement&gt;</code> to the view class to store the address of a temporary element. You could consider <code class="calibre23">unique_ptr</code> as a candidate for this but eventually you will need access to a pointer to an element in the mouse event handler functions, while the same pointer is stored in a container in the document object. A <code class="calibre23">unique_ptr</code> would not allow this.</p>
<p class="calibre13">First, you can add <code class="calibre23">#include</code> directives for the <code class="calibre23">memory</code> header and <code class="calibre23">Element.h</code> following the <code class="calibre23">#pragma once</code> directive. Next, right-click <code class="calibre23">CSketcherView</code> and select the Add <img src="images/000122.png" alt="image" class="calibre25" /> Add Variable option. The <code class="calibre23">m_pTempElement</code> variable will be of type <code class="calibre23">std::shared_ptr&lt;CElement&gt;</code>, and it should be <code class="calibre23">protected</code> like the previous two data members that you added. You’ll be able to use the <code class="calibre23">m_pTempElement</code> pointer in the <code class="calibre23">WM_MOUSEMOVE</code> message handler as a test for whether a previous temporary element exists because it will be <code class="calibre23">nullptr</code> when there are none.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="691" id="calibre_link-1153" class="calibre14"></span>The CElement Class</h4>
<p class="calibre13">You’ll be developing the element class definitions incrementally as you increase the functionality of Sketcher &mdash; but what do you need right now? Some data items, such as color and position, are common to all types of elements, so you can put those in the <code class="calibre23">CElement</code> base class so that they are inherited in the derived classes. Other data members that define specific element properties will be declared in the derived class to which they belong.</p>
<p class="calibre13">The <code class="calibre23">CElement</code> class will contain virtual functions that will be implemented in the derived classes, plus data and function members that are common to all the derived classes. The virtual functions will be those that are selected polymorphically for a particular object through a <code class="calibre23">CElement*</code> pointer. You could use the Add Member Wizard to add these members to the <code class="calibre23">CElement</code> class, but modify the class manually for a change. For now, you can modify the <code class="calibre23">CElement</code> class definition to the following:</p>
<pre class="calibre28"><code class="calibre23">class CElement: public CObject
{
<b class="calibre12">protected:</b>
  <b class="calibre12">CPoint m_StartPoint;            // Element position</b>      
  <b class="calibre12">int m_PenWidth;                 // Pen width</b>
  <b class="calibre12">COLORREF m_Color;               // Color of an element</b>
  <b class="calibre12">CRect m_EnclosingRect;          // Rectangle enclosing an element</b>

public:
  virtual ~CElement();
  <b class="calibre12">virtual void Draw(CDC* pDC) {}  // Virtual draw operation</b>

  <b class="calibre12">// Get the element enclosing rectangle</b>
  <b class="calibre12">const CRect&amp; GetEnclosingRect() const {  return m_EnclosingRect;  }</b>

<b class="calibre12">protected:</b>
  <b class="calibre12">// Constructors protected so they cannot be called outside the class</b>
  CElement();              
  <b class="calibre12">CElement(const CPoint&amp; start, COLORREF color, int penWidth = 1);</b>
};</code></pre>
<p class="calibre13">I have made the constructors <code class="calibre23">protected</code> to prevent them from being called from outside the class. The new constructor will only be called from a derived class. It has three parameters with a default value for the pen width because most of the time the pen width will be 1. At the moment, the data members to be inherited in the derived classes store the position, the color, and the pen width for an element, and the enclosing rectangle that identifies the area occupied by an element.</p>
<p class="calibre13">There are two member function definitions within the class:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">GetEnclosingRect()</code> returns <code class="calibre23">m_EnclosingRect</code>. This will be used when the area an element occupies needs to be invalidated.</li>
<li class="calibre6">A virtual <code class="calibre23">Draw()</code> function that will be implemented in the derived classes to draw an element. The <code class="calibre23">Draw()</code> function needs a pointer to a <code class="calibre23">CDC</code> object passed to it to provide access to the functions that you need to draw in a device context.</li>
</ul>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="692" id="calibre_link-1154" class="calibre14"></span>You might be tempted to declare the <code class="calibre23">Draw()</code> member as a pure virtual function in the <code class="calibre23">CElement</code> class and leave it to the derived classes to define &mdash; after all, it can have no meaningful content here. Normally, you would do this, but <code class="calibre23">CElement</code> inherits a facility from <code class="calibre23">CObject</code> called <i class="calibre15">serialization</i> that you’ll use later to store element objects in a file. Serialization requires that <code class="calibre23">CElement</code> is not abstract so an object of this type can be created. If you want to use MFC’s serialization capability, your classes must not be abstract and they must have a no-arg constructor.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Serialization is a general term for writing objects to a file.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You can add the definition for the new constructor to <code class="calibre23">Element.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">CElement::CElement(const CPoint&amp; start, COLORREF color, int penWidth) :
                   m_StartPoint {start}, m_PenWidth {penWidth}, m_Color {color} {}</code></pre>
<p class="calibre13">All members are initialized in the constructor initializer list so there is no code required for the body of the constructor.</p>
</section>
<section class="toclist">
<h4 class="calibre22">The CLine Class</h4>
<p class="calibre13">You can amend the definition of the <code class="calibre23">CLine</code> class to the following:</p>
<pre class="calibre28"><code class="calibre23">class CLine: public CElement
{
public:
  virtual ~CLine(void);
  <b class="calibre12">virtual void Draw(CDC* pDC) override; // Function to display a line</b>

  <b class="calibre12">// Constructor for a line object</b>
  <b class="calibre12">CLine(const CPoint&amp; start, const CPoint&amp; end, COLORREF aColor);</b>

<b class="calibre12">protected:</b>
  <b class="calibre12">CPoint m_EndPoint;                    // End point of line</b>

<b class="calibre12">protected:</b>
  <b class="calibre12">CLine();                              // Default constructor should not be used</b>
};</code></pre>
<p class="calibre13">A line is defined by two points, <code class="calibre23">m_StartPoint</code> that is inherited from <code class="calibre23">CElement</code> and <code class="calibre23">m_EndPoint</code>. The class has a <code class="calibre23">public</code> constructor that has parameters for the values that define a line, and the no-arg default constructor has been moved to the <code class="calibre23">protected</code> section of the class to prevent its use externally. The constructor parameters are <code class="calibre23">const</code> references to avoid copying the arguments. Using the <code class="calibre23">override</code> keyword with the <code class="calibre23">Draw()</code> member declaration ensures that the compiler will verify that it overrides the base class function correctly.</p>
<section class="toclist">
<h5 class="calibre27">Implementing the CLine Class</h5>
<p class="calibre13">You put the implementations of the <code class="calibre23">CLine</code> member functions in the <code class="calibre23">Line.cpp</code> file that was created by the Class Wizard. The <code class="calibre23">stdafx.h</code> file that is included into this file makes the standard system <span {http://www.idpf.org/2007/ops}type="pagebreak" title="693" id="calibre_link-1155" class="calibre14"></span>header files available and the contents of <code class="calibre23">stdafx.h</code> will be precompiled. Any of your headers that you do not anticipate changing can be included in <code class="calibre23">stdafx.h</code> to have them precompiled too. You can now add the basic code for the <code class="calibre23">CLine</code> constructor to <code class="calibre23">Line.cpp</code>.</p>
</section>
<section class="toclist">
<h5 class="calibre27">The CLine Constructor</h5>
<p class="calibre13">The code for the constructor is as follows:</p>
<pre class="calibre28"><code class="calibre23">// CLine class constructor
CLine::CLine(const CPoint&amp; start, const CPoint&amp; end, COLORREF color) :
                                    CElement {start, color}, m_EndPoint {end} {}</code></pre>
<p class="calibre13">You initialize the inherited <code class="calibre23">m_StartPoint</code> and <code class="calibre23">m_Color</code> members by calling the <code class="calibre23">CElement</code> base class constructor. The pen width is set to <code class="calibre23">1</code> by default in this constructor when you omit the third argument. The <code class="calibre23">m_EndPoint</code> member of <code class="calibre23">CLine</code> is initialized in the initialization list for the constructor. You’ll add a bit more code to this later.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Drawing a Line</h5>
<p class="calibre13">The <code class="calibre23">CPen</code> object you need to draw lines will be the same for all elements. You could usefully add a function within the <code class="calibre23">CElement</code> class definition to create it:</p>
<pre class="calibre28"><code class="calibre23"> // Create a pen
 void CreatePen(CPen&amp; aPen)
 {
   if(!aPen.CreatePen(PS_SOLID, m_PenWidth, m_Color))
   {
     // Pen creation failed
     AfxMessageBox(_T("Pen creation failed."), MB_OK);
     AfxAbort();
   }
 }</code></pre>
<p class="calibre13">This will only be called by derived class objects so you can put the definition in a <code class="calibre23">protected</code> section of the class. Defining the function within the class definition will make it inline. The reference parameter allows the function to modify the <code class="calibre23">aPen</code> object that is defined in the calling function. Calling <code class="calibre23">CreatePen()</code> for a <code class="calibre23">CPen</code> object creates a pen and attaches it to the object. You create a pen of the appropriate color and with a line thickness specified by <code class="calibre23">m_PenWidth</code>, and you make sure that the creation works. In the unlikely event that it doesn’t, the most likely cause is that you’re running out of memory, which is a serious problem. This is almost invariably caused by an error in the program, so you have written the function to call <code class="calibre23">AfxMessageBox()</code>, which is an MFC global function to display a message box, and then call <code class="calibre23">AfxAbort()</code> to terminate the program. The first argument to <code class="calibre23">AfxMessageBox()</code> specifies the message, and the second specifies that it should have an OK button. You can get more information on these functions by placing the cursor within the function name in the Editor window and pressing F1.</p>
<p class="calibre13">Without this function in the base class, you would have to repeat this code in the <code class="calibre23">Draw()</code> function in every derived class.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="694" id="calibre_link-1156" class="calibre14"></span><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">Device contexts, pens, brushes, fonts, and other objects you use to draw in a window are</i> GDI objects. <i class="calibre15">You must not attempt to copy or assign GDI objects. If you do, your code will not compile. This has implications. It means, for example, that you cannot pass a GDI object by value to another function.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The <code class="calibre23">Draw()</code> function for the <code class="calibre23">CLine</code> class isn’t too difficult, although you do need to take account of the color that is to be used when the line is drawn:</p>
<pre class="calibre28"><code class="calibre23">// Draw a CLine object
void CLine::Draw(CDC* pDC)
{
  // Create a pen for this object and initialize it
  CPen aPen;
  CreatePen(aPen);
        
  CPen* pOldPen {pDC-&gt;SelectObject(&amp;aPen)};       // Select the pen
        
  // Now draw the line
  pDC-&gt;MoveTo(m_StartPoint);
  pDC-&gt;LineTo(m_EndPoint);
        
  pDC-&gt;SelectObject(pOldPen);                     // Restore the old pen
}</code></pre>
<p class="calibre13">Calling the inherited <code class="calibre23">CreatePen()</code> function sets up the pen in <code class="calibre23">aPen</code>. After selecting the pen into the device context, you move the current position to the start of the line, defined in <code class="calibre23">m_StartPoint</code>, and then draw the line from this point to <code class="calibre23">m_EndPoint</code>. Finally, you restore the old pen in the device context and you are done.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Creating Enclosing Rectangles</h5>
<p class="calibre13">At first sight, obtaining the enclosing rectangle for an element looks trivial. For example, a line is always a diagonal of a rectangle, and a circle is defined by a rectangle, but there are a couple of slight complications. The element must lie completely inside the enclosing rectangle; otherwise, part of the element may not be drawn or erased. You must take account of how the element is drawn in relation to its defining parameters and allow for the thickness of the line used to draw it. How you work out adjustments to the coordinates that define the enclosing rectangle depends on the mapping mode, so you must take that into account too.</p>
<p class="calibre13">Different mapping modes only affect how you adjust the y-coordinates of the corners of a defining rectangle to obtain the enclosing rectangle; adjustment of the x-coordinate is the same for all mapping modes; you subtract the line thickness from the x-coordinate of the top-left corner and add it to the x-coordinate of the bottom-right corner. To adjust the y-coordinate of the top-left corner of the defining rectangle in the <code class="calibre23">MM_TEXT</code> mapping mode, you subtract the line thickness from it. However, in <code class="calibre23">MM_LOENGLISH</code> (and all the other mapping modes), the y-axis increases in the opposite direction, so you need to add the line thickness to the y-coordinate of the upper-left corner of the defining rectangle. You’ll create the enclosing rectangle for an element in the constructor for each element type.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="695" id="calibre_link-1157" class="calibre14"></span><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">The data members of a</i> <code class="calibre23">CRect</code> <i class="calibre15">object are</i> <code class="calibre23">left</code> <i class="calibre15">and</i> <code class="calibre23">top</code> <i class="calibre15">storing the x- and y-coordinates of the top-left corner, and</i> <code class="calibre23">right</code> <i class="calibre15">and</i> <code class="calibre23">bottom</code> <i class="calibre15">storing the coordinates of the bottom-right corner. These are all public members, so you can access them directly. A mistake often made, especially by me, is to write the coordinate pair as (</i><code class="calibre23">top, left</code><i class="calibre15">) instead of the correct order: (<code class="calibre23">left, top</code>).</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h5 class="calibre27">Normalized Rectangles</h5>
<p class="calibre13">A <i class="calibre15">normalized rectangle</i> is a rectangle where the value of the <code class="calibre23">left</code> coordinate is less than the <code class="calibre23">right</code>, and the <code class="calibre23">top</code> coordinate is less than the <code class="calibre23">bottom</code>. If a rectangle is not normalized, functions that operate on <code class="calibre23">CRect</code> objects won’t work correctly. For example, the <code class="calibre23">InflateRect()</code> member of the <code class="calibre23">CRect</code> class works by subtracting the argument values from the <code class="calibre23">top</code> and <code class="calibre23">left</code> members of the rectangle and adding them to the <code class="calibre23">bottom</code> and <code class="calibre23">right</code>. This means that you may find that your rectangle decreases in size when you apply <code class="calibre23">InflateRect()</code> to it if you don’t make sure that the rectangle is normalized. As long as your rectangles are normalized, <code class="calibre23">InflateRect()</code> will work correctly whatever the mapping mode. You can normalize a <code class="calibre23">CRect</code> object by calling its <code class="calibre23">NormalizeRect()</code> member.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Calculating the Enclosing Rectangle for a Line</h5>
<p class="calibre13">You can add code in the <code class="calibre23">CLine</code> constructor to calculate the enclosing rectangle:</p>
<pre class="calibre28"><code class="calibre23">CLine::CLine(const CPoint&amp; start, const CPoint&amp; end, COLORREF color):
         CElement {start, color}, m_EndPoint {end}
{
  <b class="calibre12">// Define the enclosing rectangle</b>
  <b class="calibre12">m_EnclosingRect = CRect {start, end};</b>
  <b class="calibre12">m_EnclosingRect.NormalizeRect();</b>
  <b class="calibre12">m_EnclosingRect.InflateRect(m_PenWidth, m_PenWidth);</b>
}</code></pre>
<p class="calibre13">You ensure that the enclosing rectangle has <code class="calibre23">left</code> and <code class="calibre23">top</code> values that are less than its <code class="calibre23">right</code> and <code class="calibre23">bottom</code> values, regardless of the relative positions of the <code class="calibre23">start</code> and <code class="calibre23">end</code> points of the line, by calling the <code class="calibre23">NormalizeRect()</code> member of the <code class="calibre23">m_EnclosingRect</code> object. Calling <code class="calibre23">InflateRect()</code> enlarges the rectangle by the pen width. The first argument is the adjustment for the left and right sides and the second is the adjustment for the top and bottom. One overload of <code class="calibre23">InflateRect()</code> has a single parameter of type <code class="calibre23">SIZE</code>, which also accepts a <code class="calibre23">CSize</code> object that encapsulates the <code class="calibre23">SIZE</code> struct. A <code class="calibre23">CSize</code> object defines a size by public members <code class="calibre23">cx</code> and <code class="calibre23">cy</code> of type <code class="calibre23">long</code>.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">The CRectangle Class</h4>
<p class="calibre13">You’ll be defining a rectangle object with the same data that you use to define a line; the points define opposite corners. You can define the class as:</p>
<pre class="calibre28"><code class="calibre23">class CRectangle: public CElement
{
public:
  virtual ~CRectangle();
  <b class="calibre12">virtual void Draw(CDC* pDC) override; // Function to display a rectangle</b>
  
  <b class="calibre12">// Constructor for a rectangle object</b>
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="696" id="calibre_link-1158" class="calibre14"></span><b class="calibre12">CRectangle(const CPoint&amp; start, const CPoint&amp; end, COLORREF color);</b>

<b class="calibre12">protected:</b>
  <b class="calibre12">CPoint m_BottomRight;                // Bottom-right point for the rectangle</b>
  <b class="calibre12">CRectangle();                        // Default constructor - should not be used</b>
};</code></pre>
<p class="calibre13">The no-arg constructor is <code class="calibre23">protected</code> to prevent its use externally. The definition of the rectangle class is very simple &mdash; just a constructor, the virtual <code class="calibre23">Draw()</code> function, plus the no-arg constructor in the <code class="calibre23">protected</code> section of the class.</p>
<section class="toclist">
<h5 class="calibre27">The CRectangle Constructor</h5>
<p class="calibre13">The code for the new <code class="calibre23">CRectangle</code> class constructor is a little more complicated than that for <code class="calibre23">CLine</code>:</p>
<pre class="calibre28"><code class="calibre23">// CRectangle constructor
CRectangle::CRectangle (
               const CPoint&amp; start, const CPoint&amp; end, COLORREF color) :
               CElement {start, color}
{
  // Normalize the rectangle defining points
  m_StartPoint = CPoint {(std::min)(start.x, end.x),(std::min)(start.y, end.y)};
  m_BottomRight = CPoint {(std::max)(start.x, end.x), (std::max)(start.y, end.y)};
 
  // Ensure width and height between the points is at least 2
  if((m_BottomRight.x - m_StartPoint.x) &lt; 2)
    m_BottomRight.x = m_StartPoint.x + 2;
  if((m_BottomRight.y - m_StartPoint.y) &lt; 2)
    m_BottomRight.y = m_StartPoint.y + 2;
 
  // Define the enclosing rectangle
  m_EnclosingRect = CRect {m_StartPoint, m_BottomRight};
  m_EnclosingRect.InflateRect(m_PenWidth, m_PenWidth);
}</code></pre>
<p class="calibre13">You call the <code class="calibre23">CElement</code> constructor in the initialization list to get the color and pen width initialized. The <code class="calibre23">CElement</code> constructor also initializes <code class="calibre23">m_StartPoint</code>, but you will replace this. You can only draw a <code class="calibre23">CRect</code> object that has a width and height of at least 2, so you adjust the coordinates of the two defining points if necessary, after arranging that the points define a normalized rectangle. Because you adjusted the points, there’s no need to call <code class="calibre23">NormalizeRect(). std::min()</code> and <code class="calibre23">std::max()</code> are template functions defined in the <code class="calibre23">algorithm</code> header that return the minimum and maximum of their arguments, respectively. Add an <code class="calibre23">#include</code> directive for the <code class="calibre23">algorithm</code> header to <code class="calibre23">Rectangle.cpp</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">The parentheses around</i> <code class="calibre23">std::min</code> <i class="calibre15">and</i> <code class="calibre23">std::max</code> <i class="calibre15">in the code are essential. This is not typical with other C++ compilers but is a peculiarity of Visual C++. The</i> <code class="calibre23">windows.h</code> <i class="calibre15">header defines macros for</i> <code class="calibre23">min</code> <i class="calibre15">and</i> <code class="calibre23">max</code> <i class="calibre15">and without the parentheses, the preprocessor will make the substitution for these macros before compilation starts. This will cause the compiler to generate error messages. The parentheses prevent the preprocessor macro substitutions.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h5 class="calibre27"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="697" id="calibre_link-1159" class="calibre14"></span>Drawing a Rectangle</h5>
<p class="calibre13">The <code class="calibre23">Rectangle()</code> member of the <code class="calibre23">CDC</code> class draws a rectangle. This function draws a closed figure and fills it with the current brush. You want to draw rectangles as outlines and selecting a <code class="calibre23">NULL_BRUSH</code> into the device context will do that. Just so you know, there’s also a <code class="calibre23">PolyLine()</code> member of <code class="calibre23">CDC</code> that draws shapes consisting of multiple line segments from an array of points. You could also use <code class="calibre23">LineTo()</code> to draw the four sides of the rectangle, but the easiest approach is to use the <code class="calibre23">Rectangle()</code> function:</p>
<pre class="calibre28"><code class="calibre23">// Draw a CRectangle object
void CRectangle::Draw(CDC* pDC)
{
  // Create a pen for this object and initialize it
  CPen aPen; 
  CreatePen(aPen);
        
  // Select the pen and the null brush
  CPen* pOldPen {pDC-&gt;SelectObject(&amp;aPen)};
  CBrush* pOldBrush {dynamic_cast&lt;CBrush*&gt;(pDC-&gt;SelectStockObject(NULL_BRUSH))};
        
  // Now draw the rectangle
  pDC-&gt;Rectangle(m_StartPoint.x, m_StartPoint.y,
                 m_BottomRight.x, m_BottomRight.y);
        
  pDC-&gt;SelectObject(pOldBrush);       // Restore the old brush
  pDC-&gt;SelectObject(pOldPen);         // Restore the old pen
}</code></pre>
<p class="calibre13">After setting up the pen and the brush, you call the <code class="calibre23">Rectangle()</code> function to draw the rectangle element. The arguments are the coordinates of the top-left and bottom-right corners. There’s an overload of this function that accepts a <code class="calibre23">CRect</code> object to specify the rectangle. All that remains to do is to restore the device context’s old pen and brush.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">The CCircle Class</h4>
<p class="calibre13">The <code class="calibre23">CCircle</code> class interface is similar to that of the <code class="calibre23">CRectangle</code> class. You draw a circle using the <code class="calibre23">Ellipse()</code> member of the <code class="calibre23">CDC</code> class, which draws an ellipse bounded by a rectangle. As long as the defining rectangle is square, the ellipse will be a circle. You will define a circle from its two defining points, the center and a point on the circumference, so the class definition is:</p>
<pre class="calibre28"><code class="calibre23">class CCircle : public CElement
{
public:
  virtual ~CCircle();
  <b class="calibre12">virtual void Draw(CDC* pDC) override;     // Function to display a circle</b>

  <b class="calibre12">// Constructor for a circle object</b>
  <b class="calibre12">CCircle(const CPoint&amp; start, const CPoint&amp; end, COLORREF color);</b>

<b class="calibre12">protected:</b>
  <b class="calibre12">CPoint m_BottomRight;            // Bottom-right point for defining circle</b>
  <b class="calibre12">CCircle();                       // Default constructor - should not be used</b>
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="698" id="calibre_link-1160" class="calibre14"></span>You have defined a public constructor that creates a circle from two points and its drawing color, and the no-arg constructor is <code class="calibre23">protected</code> to prevent its use externally. You have also added a declaration for the draw function override to the class that will draw a circle.</p>
<section class="toclist">
<h5 class="calibre27">Implementing the CCircle Class</h5>
<p class="calibre13">When you create a circle, the point at which you press the left mouse button will be the center, and the point at which you release the button will be a point on the circumference. The job of the constructor is to obtain the corner points of the defining rectangle from these points.</p>
</section>
<section class="toclist">
<h5 class="calibre27">The CCircle Class Constructor</h5>
<p class="calibre13">The point at which you release the left mouse button can be anywhere on the circumference, so the coordinates of the points specifying the defining rectangle need to be calculated in the way I’ve illustrated in <a id="calibre_link-130" href="#calibre_link-129" class="calibre3">Figure 14-15</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000131.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-129" href="#calibre_link-130" class="calibre3">FIGURE 14-15</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">From <a href="#calibre_link-129" class="calibre3">Figure 14-15</a>, you can see that you can calculate the coordinates of the upper-left and lower-right points of the enclosing rectangle relative to the center of the circle (x<sub class="calibre34">1</sub>, y<sub class="calibre34">1</sub>). Assuming that the mapping mode is <code class="calibre23">MM_TEXT</code>, you get the (left, top) point by subtracting the radius from each of the coordinates of the center. Similarly, you obtain the (right, bottom) point by adding the radius to the coordinates of the center. You can calculate the radius as the square root of the expression in <a href="#calibre_link-129" class="calibre3">Figure 14-15</a>. Based on this you can code the constructor as follows:</p>
<pre class="calibre28"><code class="calibre23">// Constructor for a circle object
CCircle::CCircle(const CPoint&amp; start, const CPoint&amp; end, COLORREF color) :
               CElement {start, color}
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="699" id="calibre_link-1161" class="calibre14"></span>{
  // Calculate the radius using floating-point values
  // because that is required by sqrt() function (in cmath) 
  long radius {static_cast&lt;long&gt; (sqrt(
                  static_cast&lt;double&gt;((end.x-start.x)*(end.x-start.x)+
                                      (end.y-start.y)*(end.y-start.y))))};
  if(radius &lt; 1L) radius = 1L;        // Circle radius must be &gt;= 1
 
  // Define left-top and right-bottom points of rectangle for MM_TEXT mode
  m_StartPoint = CPoint {start.x - radius, start.y - radius};
  m_BottomRight = CPoint {start.x + radius, start.y + radius};
        
  // Define the enclosing rectangle
  m_EnclosingRect = CRect {m_StartPoint.x, m_StartPoint.y,
                           m_BottomRight.x, m_BottomRight.y};
  m_EnclosingRect.InflateRect(m_PenWidth, m_PenWidth);
}</code></pre>
<p class="calibre13">To use the <code class="calibre23">sqrt()</code> function, you need an <code class="calibre23">#include</code> directive for the <code class="calibre23">cmath</code> header at the beginning of the <code class="calibre23">Circle.cpp</code> file. The maximum point coordinate values are 32 bits, and the <code class="calibre23">CPoint</code> members <code class="calibre23">x</code> and <code class="calibre23">y</code> are declared as <code class="calibre23">long</code>, so converting the value returned from <code class="calibre23">sqrt()</code> to type <code class="calibre23">long</code> should produce accurate results. The result of the square root calculation is of type <code class="calibre23">double</code>, so you cast it to type <code class="calibre23">long</code> to use it as an integer. The radius must be at least 1, otherwise nothing will be drawn by the <code class="calibre23">Ellipse()</code> member of <code class="calibre23">CDC</code>.</p>
<p class="calibre13">You store a <code class="calibre23">CPoint</code> object in <code class="calibre23">m_StartPoint</code> with the coordinates of the top left of the defining rectangle that you obtain by subtracting <code class="calibre23">radius</code> from the coordinates of the center. The <code class="calibre23">m_BottomRight</code> point is produced by adding <code class="calibre23">radius</code> to the coordinates of the center.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Drawing a Circle</h5>
<p class="calibre13">The implementation of the <code class="calibre23">Draw()</code> function in the <code class="calibre23">CCircle</code> class is:</p>
<pre class="calibre28"><code class="calibre23">// Draw a circle
void CCircle::Draw(CDC* pDC)
{
   // Create a pen for this object and initialize it
   CPen aPen;
   CreatePen(aPen);
        
   CPen* pOldPen {pDC-&gt;SelectObject(&amp;aPen)};   // Select the pen
        
   // Select a null brush
   CBrush* pOldBrush {dynamic_cast&lt;CBrush*&gt;(pDC-&gt;SelectStockObject(NULL_BRUSH))};
        
   // Now draw the circle
   pDC-&gt;Ellipse(m_StartPoint.x, m_StartPoint.y,
                m_BottomRight.x, m_BottomRight.y);
        
   pDC-&gt;SelectObject(pOldPen);                // Restore the old pen
   pDC-&gt;SelectObject(pOldBrush);              // Restore the old brush
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="700" id="calibre_link-1162" class="calibre14"></span>After selecting a pen of the appropriate color and a null brush into the device context, you draw the circle by calling the <code class="calibre23">Ellipse()</code> function. The arguments are the coordinates of the corner points of the defining rectangle. An overload of <code class="calibre23">Ellipse()</code> accepts a <code class="calibre23">CRect</code> argument.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">The CCurve Class</h4>
<p class="calibre13">The <code class="calibre23">CCurve</code> class is different from the others in that it needs to deal with a variable number of defining points. A curve is defined by two or more points, and you can store these in an STL container. It won’t be necessary to remove points from a curve, so a <code class="calibre23">vector&lt;CPoint&gt;</code> container is a good candidate. You looked at the <code class="calibre23">vector&lt;T&gt;</code> template in some detail back in Chapter 10. However, before you can complete the <code class="calibre23">CCurve</code> class definition, you need to explore how a curve will be created and drawn by a user.</p>
<section class="toclist">
<h5 class="calibre27">Drawing a Curve</h5>
<p class="calibre13">Drawing a curve is different from drawing a line, a rectangle, or a circle. With these elements, as you move the cursor with the left button down you are creating a succession of different elements that share a common reference point &mdash; the point at which the left mouse button was pressed. This is not the case when you draw a curve, as shown in <a id="calibre_link-132" href="#calibre_link-131" class="calibre3">Figure 14-16</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000067.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-131" href="#calibre_link-132" class="calibre3">FIGURE 14-16</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">When you move the mouse cursor drawing a curve, you’re not creating a sequence of new curves, but extending the same curve. Each new cursor position after the first adds a segment to the curve. Therefore, you must create a <code class="calibre23">CCurve</code> object as soon as you have the two points from the <code class="calibre23">WM_LBUTTONDOWN</code> message and the first <code class="calibre23">WM_MOUSEMOVE</code> message. Points that are defined with subsequent mouse move messages should add segments to the initial <code class="calibre23">CCurve</code> object. To make this possible you can add an <code class="calibre23">AddSegment()</code> function to the <code class="calibre23">CCurve</code> class that will extend a curve.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="701" id="calibre_link-1163" class="calibre14"></span>A further point to consider is how you are to calculate the enclosing rectangle. You can define this by getting the minimum-x and minimum-y pair from all the defining points to establish the upper-left corner of the rectangle, and the maximum-x and maximum-y pair for the bottom right. The easiest way of generating the enclosing rectangle is to compute it initially in the constructor based on the first two points and then re-compute it incrementally in the <code class="calibre23">AddSegment()</code> function as points are added to the curve.</p>
<p class="calibre13">Add an <code class="calibre23">#include</code> directive for the <code class="calibre23">vector</code> header to <code class="calibre23">Curve.h</code>. You can modify the <code class="calibre23">CCurve</code> class definition to the following:</p>
<pre class="calibre28"><code class="calibre23">class CCurve : public CElement
{
public:
  virtual ~CCurve();
  <b class="calibre12">virtual void Draw(CDC* pDC) override;   // Function to display a curve</b>

  <b class="calibre12">// Constructor for a curve object</b>
  <b class="calibre12">CCurve(const CPoint&amp; first, const CPoint&amp; second, COLORREF color);</b>

  <b class="calibre12">void AddSegment(const CPoint&amp; point);   // Add a segment to the curve</b>

<b class="calibre12">protected:</b>
  <b class="calibre12">std::vector&lt;CPoint&gt; m_Points;           // Points defining the curve</b>
  <b class="calibre12">CCurve();                  // Default constructor - should not be used</b>
};</code></pre>
<p class="calibre13">You can add the definition for the constructor in <code class="calibre23">Curve.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">// Constructor for a curve object
CCurve::CCurve(const CPoint&amp; first, const CPoint&amp; second, COLORREF color) :
               CElement {first, color}
 {
   // Store the second point in the vector
   m_Points.push_back(second);
   m_EnclosingRect = CRect {
                (std::min)(first.x, second.x), (std::min)(first.y, second.y),
                (std::max)(first.x, second.x), (std::max)(first.y, second.y)};
   m_EnclosingRect.InflateRect(m_PenWidth, m_PenWidth);
 }</code></pre>
<p class="calibre13">The constructor receives the first two defining points as arguments so it defines a curve with only one segment. The first point is stored in the <code class="calibre23">m_StartPoint</code> member by the <code class="calibre23">CElement</code> constructor. The second point is stored in the vector, <code class="calibre23">m_Points</code>. I’m sure you recall that the <code class="calibre23">push_back()</code> function adds an element to the end of a vector. You use the <code class="calibre23">std::min()</code> and <code class="calibre23">std::max()</code> template functions in the creation of the enclosing rectangle so you’ll need an <code class="calibre23">#include</code> directive for the <code class="calibre23">algorithm</code> header in <code class="calibre23">Curve.cpp</code>.</p>
<p class="calibre13">You can define the <code class="calibre23">Draw()</code> function for a curve like this:</p>
<pre class="calibre28"><code class="calibre23">// Draw a curve
void CCurve::Draw(CDC* pDC)
{
   <span {http://www.idpf.org/2007/ops}type="pagebreak" title="702" id="calibre_link-1164" class="calibre14"></span>// Create a pen for this object and initialize it
   CPen aPen;
   CreatePen(aPen);
        
   CPen* pOldPen {pDC-&gt;SelectObject(&amp;aPen)};  // Select the pen
        
   // Now draw the curve
   pDC-&gt;MoveTo(m_StartPoint);
   for(const auto&amp; point : m_Points)
     pDC-&gt;LineTo(point);
        
   pDC-&gt;SelectObject(pOldPen);                // Restore the old pen
}</code></pre>
<p class="calibre13">The <code class="calibre23">Draw()</code> function has to provide for a curve with an arbitrary number of points. Once the pen has been set up, the first step is to move the current position in the device context to <code class="calibre23">m_StartPoint</code>. Line segments for the curve are drawn in the <code class="calibre23">for</code> loop, one segment for each point in the vector. A <code class="calibre23">LineTo()</code> operation moves the current position to the end of the line it draws, so each function call draws a line from the current position to the next point in the vector. In this way, you draw all the segments that make up the curve.</p>
<p class="calibre13">You can implement the <code class="calibre23">AddSegment()</code> function like this:</p>
<pre class="calibre28"><code class="calibre23">// Add a segment to the curve
void CCurve::AddSegment(const CPoint&amp; point)
{
   m_Points.push_back(point);                // Add the point to the end
        
   // Modify the enclosing rectangle for the new point
   m_EnclosingRect.DeflateRect(m_PenWidth, m_PenWidth);
   m_EnclosingRect = CRect {(std::min)(point.x, m_EnclosingRect.left),
                            (std::min)(point.y, m_EnclosingRect.top),
                            (std::max)(point.x, m_EnclosingRect.right),
                            (std::max)(point.y, m_EnclosingRect.bottom)};
   m_EnclosingRect.InflateRect(m_PenWidth, m_PenWidth);
 }</code></pre>
<p class="calibre13">You add <code class="calibre23">point</code> to the vector and adjust the enclosing rectangle by ensuring the top-left point is the minimum x and y, and the bottom-right is the maximum x and y. The enclosing rectangle for the complete curve is the rectangle corresponding to the minimum x and y of all the defining points for the left-top corner, and the maximum of all the point coordinates for bottom right. You then want to inflate the resulting rectangle by the pen width. For this reason, you must reduce <code class="calibre23">m_EnclosingRect</code> by the pen width before you find the coordinates of the top-left and bottom right-corners. Otherwise you will not end up with the correct rectangle. Calling the <code class="calibre23">DeflateRect()</code> member of <code class="calibre23">CRect</code> does the opposite of <code class="calibre23">InflateRect()</code>, so this is just what you want.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Completing the Mouse Message Handlers</h4>
<p class="calibre13">You can now return to the <code class="calibre23">WM_MOUSEMOVE</code> message handler and fill out the details. You can get to it through selecting <code class="calibre23">CSketcherView</code> in Class View and double-clicking the handler name, <code class="calibre23">OnMouseMove()</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="703" id="calibre_link-1165" class="calibre14"></span>Except when creating a <code class="calibre23">CCurve</code> element, this handler is concerned with drawing a succession of temporary elements as you move the cursor, and the final element is created when you release the mouse button. You can therefore treat the drawing of temporary elements as being entirely local to this function, leaving the final version of an element to be drawn by the <code class="calibre23">OnDraw()</code> member of the view. With this approach, drawing the temporary elements will be reasonably efficient because it won’t involve the <code class="calibre23">OnDraw()</code> member of <code class="calibre23">CSketcherView</code> that draws the entire document.</p>
<p class="calibre13">You can implement this very easily with the help of a <code class="calibre23">CDC</code> class member that is particularly useful in rubber-banding operations: the <code class="calibre23">SetROP2()</code> function.</p>
<section class="toclist">
<h5 class="calibre27">Setting the Drawing Mode</h5>
<p class="calibre13">Calling <code class="calibre23">SetROP2()</code> sets the <i class="calibre15">drawing mode</i> for all subsequent output operations in the device context associated with a <code class="calibre23">CDC</code> object. The “ROP” bit of the function name stands for Raster OPeration, because the setting of drawing modes applies to raster displays. In case you’re wondering what <code class="calibre23">SetROP1()</code> is &mdash; it doesn’t exist. The whole function name stands for Set Raster OPeration to, not Set Raster OPeration 2!</p>
<p class="calibre13">The drawing mode determines how the color of the pen combines with the background color in the window to produce the color of the entity that you will see. You specify the drawing mode with a single argument to the <code class="calibre23">SetROP2()</code> function that can be any of the following values:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">DRAWING MODE</b></th>
<th class="calibre32"><b class="calibre12">EFFECT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_BLACK</code></td>
<td class="calibre32">All drawing is in black.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_WHITE</code></td>
<td class="calibre32">All drawing is in white.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_NOP</code></td>
<td class="calibre32">Drawing operations do nothing.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_NOT</code></td>
<td class="calibre32">Drawing is in the inverse of the screen color. This ensures that the output is always visible because it draws in the inverse color to the background.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_COPYPEN</code></td>
<td class="calibre32">Drawing is in the pen color. This is the default drawing mode if you don’t set a mode.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_NOTCOPYPEN</code></td>
<td class="calibre32">Drawing is in the inverse of the pen color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_MERGEPENNOT</code></td>
<td class="calibre32">Drawing is in the color produced by OR-ing the pen color with the inverse of the background color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_MASKPENNOT</code></td>
<td class="calibre32">Drawing is in the color produced by AND-ing the pen color with the inverse of the background color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_MERGENOTPEN</code></td>
<td class="calibre32">Drawing is in the color produced by OR-ing the background color with the inverse of the pen color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_MASKNOTPEN</code></td>
<td class="calibre32">Drawing is in the color produced by AND-ing the background color with the inverse of the pen color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_MERGEPEN</code></td>
<td class="calibre32">Drawing is in the color produced by OR-ing the background color with the pen color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_NOTMERGEPEN</code></td>
<td class="calibre32">Drawing is in the color that is the inverse of the <code class="calibre23">R2_MERGEPEN</code> color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="704" id="calibre_link-1166" class="calibre14"></span><code class="calibre23">R2_MASKPEN</code></td>
<td class="calibre32">Drawing is in the color produced by AND-ing the background color with the pen color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_NOTMASKPEN</code></td>
<td class="calibre32">Drawing is in the color that is the inverse of the <code class="calibre23">R2_MASKPEN</code> color.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_XORPEN</code></td>
<td class="calibre32">Drawing is in the color produced by exclusive OR-ing the pen and background colors. The result is a color composed of the RGB components that are in the pen and background colors but not in both.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">R2_NOTXORPEN</code></td>
<td class="calibre32">Drawing is in the color that is the inverse of the <code class="calibre23">R2_XORPEN</code> color.</td>
</tr>
</tbody>
</table>
<p class="calibre13">These symbols are predefined values of type <code class="calibre23">int</code>. There are a lot of options here, but the one that can work some magic for us is the last of them, <code class="calibre23">R2_NOTXORPEN</code>.</p>
<p class="calibre13">When you set the mode as <code class="calibre23">R2_NOTXORPEN</code>, the first time you draw on the default white background, the element is drawn normally in the pen color. If you draw the same element overwriting the first, the element disappears. This is because the color for the element as it appears on the screen is produced by exclusive OR-ing the pen color with itself, which results in a white element on a white background. You can see more clearly why this happens by working through an example.</p>
<p class="calibre13">White is formed from equal proportions of the maximum intensities for red, green, and blue, 255,255,255, so each component value has all bits 1. For simplicity I’ll represent this as 1,1,1 &mdash; the three values represent the RGB components of the color. In the same scheme, I’ll define red as 1,0,0 instead of 255,0,0. These combine as follows:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32">&nbsp;</th>
<th class="calibre32"><b class="calibre12">R</b></th>
<th class="calibre32"><b class="calibre12">G</b></th>
<th class="calibre32"><b class="calibre12">B</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Background</b>&mdash;white, the window background color</td>
<td class="calibre32">1</td>
<td class="calibre32">1</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Pen</b>&mdash;red</td>
<td class="calibre32">1</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">XOR-ed</b>&mdash;produces the complement of red</td>
<td class="calibre32">0</td>
<td class="calibre32">1</td>
<td class="calibre32">1</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">NOT XOR</b>&mdash;produces red, the drawing color</td>
<td class="calibre32">1</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
</tr>
</tbody>
</table>
<p class="calibre13">So, the first time you draw a red line on a white background, it comes out red, as the last line in the table indicates. If you now draw the same line a second time, overwriting the existing line, the background pixels you are writing over are red. The resultant drawing color works out as follows:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="705" id="calibre_link-1167" class="calibre14"></span></th>
<th class="calibre32"><b class="calibre12">R</b></th>
<th class="calibre32"><b class="calibre12">G</b></th>
<th class="calibre32"><b class="calibre12">B</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Background</b>&mdash;red, the pixels that you drew last time</td>
<td class="calibre32">1</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Pen</b>&mdash;red</td>
<td class="calibre32">1</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">XOR-ed</b>&mdash;produces black</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
<td class="calibre32">0</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">NOT XOR</b>&mdash;produces white, the window background color</td>
<td class="calibre32">1</td>
<td class="calibre32">1</td>
<td class="calibre32">1</td>
</tr>
</tbody>
</table>
<p class="calibre13">As the last line indicates, the line appears in white, and because the window background is white, the line disappears.</p>
<p class="calibre13">You need to choose the right background color for this technique to work. You should be able to see that drawing with a white pen on a red background is not going to work too well, as the first time you draw something, it is red and, therefore, invisible. The second time, it appears as white. If you draw on a black background, things appear and disappear as on a white background, but they are not drawn in the pen color you choose.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Coding the OnMouseMove() Handler</h5>
<p class="calibre13">You can now add the code to create an element after a mouse move message. Because you are going to draw the element in the handler function, you need to create a device context that you can draw in. The most convenient class to use for this is <code class="calibre23">CClientDC</code>, which is derived from <code class="calibre23">CDC</code>. An object of this type automatically takes care of destroying the device context for you when you are done, so you can create a <code class="calibre23">CClientDC</code> object, use it, and forget it. You can create a <code class="calibre23">CClientDC</code> object by passing a pointer to the window for which you want a device context to the <code class="calibre23">CClientDC</code> constructor. The device context that it creates corresponds to the client area of the window, so if you pass a pointer to the view, you’ll get exactly what you want.</p>
<p class="calibre13">The logic for drawing an element is a little complicated. You can draw a shape using the <code class="calibre23">R2_NOTXORPEN</code> mode as long as the shape is not a curve. When a curve is being created, you don’t want to draw a new curve each time the mouse moves. You just want to extend the curve by adding a new segment. This means you must treat creating a curve as a special case. You also want to delete any previous temporary element, but only when it is not a curve. Here’s how you can implement that:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  // Define a Device Context object for the view
  CClientDC aDC {this};                 // DC is for this view
  if(nFlags &amp; MK_LBUTTON)             // Verify the left button is down
  {
    m_SecondPoint = point;            // Save the current cursor position
    if(m_pTempElement)
    {
      // An element was created previously
      if(ElementType::CURVE == GetDocument()-&gt;GetElementType())   // A curve?
      {  // We are drawing a curve so add a segment to the existing curve
         std::dynamic_pointer_cast&lt;CCurve&gt;(m_pTempElement)-&gt;
AddSegment(m_SecondPoint);
         <span {http://www.idpf.org/2007/ops}type="pagebreak" title="706" id="calibre_link-1168" class="calibre14"></span>m_pTempElement-&gt;Draw(&amp;aDC);     // Now draw it
         return;                           // We are done
      }
      else
      {
        // If we get to here it's not a curve so
        // redraw the old element so it disappears from the view
        aDC.SetROP2(R2_NOTXORPEN);           // Set the drawing mode
        m_pTempElement-&gt;Draw(&amp;aDC);      // Redraw the old element to erase it
      }
    }
 
    // Create a temporary element of the type and color that
    // is recorded in the document object, and draw it
    m_pTempElement = CreateElement();
    m_pTempElement-&gt;Draw(&amp;aDC);
  }
}</code></pre>
<p class="calibre13">The first line of code creates a local <code class="calibre23">CClientDC</code> object. The <code class="calibre23">this</code> pointer that you pass to the constructor identifies the current view object, so the <code class="calibre23">CClientDC</code> object is a device context that corresponds to the client area of the current view. This object has all the drawing functions you need because they are inherited from the <code class="calibre23">CDC</code> class.</p>
<p class="calibre13">A previous temporary element exists if <code class="calibre23">m_pTempElement</code> is not <code class="calibre23">nullptr</code>. You want to do different things depending on whether or not <code class="calibre23">m_pTempElement</code> points to a curve, so you need to check for this. The <code class="calibre23">shared_ptr&lt;T&gt;</code> type supports conversion to type <code class="calibre23">bool</code> so you can use it in an <code class="calibre23">if</code> expression. You call the <code class="calibre23">GetElementType()</code> function for the document object to get the current element type. If the current element type is <code class="calibre23">ElementType::CURVE</code>, you cast <code class="calibre23">m_pTempElement</code> to type <code class="calibre23">shared_ptr&lt;CCurve&gt;</code> so you can call the <code class="calibre23">AddSegment()</code> function for the object to add the next segment to the curve. You must use a special conversion, to convert a smart pointer. This can be  <code class="calibre23">static_pointer_cast, dynamic_pointer_cast</code> or <code class="calibre23">const_pointer_cast</code>, which are equivalent to <code class="calibre23">static_cast, dynamic_cast</code>, and <code class="calibre23">const_cast</code> for ordinary pointers. <code class="calibre23">dynamic_pointer_cast</code>  checks that the cast is valid at runtime. These operations are defined by function templates in the <code class="calibre23">memory</code> header and in the <code class="calibre23">std</code> namespace. Finally, you draw the curve and return. You must add an <code class="calibre23">#include</code> for <code class="calibre23">Curve.h</code> to <code class="calibre23">SketcherView.cpp</code>. You’ll be referring to the other element classes in the view class eventually so you can include the headers for the other three element classes too.</p>
<p class="calibre13">When the current element exists, but is not a curve, you redraw the old element after calling the <code class="calibre23">SetROP2()</code> function of the <code class="calibre23">aDC</code> object to set the mode to <code class="calibre23">R2_NOTXORPEN</code>. This erases the old element on the display. There is no need to reset <code class="calibre23">m_pTempElement</code> because you will replace the pointer it contains after the <code class="calibre23">if</code> statement.</p>
<p class="calibre13">The code after the <code class="calibre23">if</code> statement is executed when there is a temporary element that is not a curve, or when there is no temporary element. In either case you want to create a new element of the current type and color and draw it normally. You create the new element and store its address in <code class="calibre23">m_pTempElement</code> by calling the <code class="calibre23">CreateElement()</code> member of <code class="calibre23">CSketcherView</code>. This replaces the current smart pointer that <code class="calibre23">m_pTempElement</code> contains. In our case, the smart pointer to the previous element will be destroyed along with the element object to which it points. If  <code class="calibre23">m_pTempElement</code> contains <code class="calibre23">nullptr</code>, then that will be replaced by the new smart pointer. Even though our object representing <span {http://www.idpf.org/2007/ops}type="pagebreak" title="707" id="calibre_link-1169" class="calibre14"></span>Sketcher is created on the heap we never need to worry about deleting it; this is automatically taken care of by smart pointers. The code automatically rubber-bands the element being created, so it will appear to be attached to the mouse cursor as it moves.</p>
<p class="calibre13">Using the smart pointer to the new element, you call its <code class="calibre23">Draw()</code> member to get the object to draw itself. The address of the <code class="calibre23">CClientDC</code> object is passed as the argument. Because you defined the <code class="calibre23">Draw()</code> function as <code class="calibre23">virtual</code> in the <code class="calibre23">CElement</code> base class, the function for whatever type of element <code class="calibre23">m_pTempElement</code> is pointing to is automatically selected. The new element is drawn normally with the <code class="calibre23">R2_NOTXORPEN</code> mode, because you are drawing it for the first time on a white background.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Creating an Element</h5>
<p class="calibre13">Add the <code class="calibre23">CreateElement()</code> function declaration as a <code class="calibre23">protected</code> member in the Implementation section of the <code class="calibre23">CSketcherView</code> class:</p>
<pre class="calibre28"><code class="calibre23">class CSketcherView: public CView
{
   // Rest of the class definition as before...
        
   // Implementation
   // Rest of the class definition as before...
        
<b class="calibre12">protected:</b>
  <b class="calibre12">std::shared_ptr&lt;CElement&gt; CreateElement() const;</b> 
  <b class="calibre12">// Create a new element on the heap</b>
        
    // Rest of the class definition as before...
        
};</code></pre>
<p class="calibre13">You can either amend the class definition directly by adding the bolded line, or you can right-click on the class name, <code class="calibre23">CSketcherView</code>, in Class View, select Add <img src="images/000122.png" alt="image" class="calibre25" /> Add Function from the context menu, and add the function through the dialog. The function is <code class="calibre23">protected</code> because it is called only from within the view class.</p>
<p class="calibre13">If you added the declaration to the class definition manually, you’ll need to add the complete definition for the function to the <code class="calibre23">.cpp</code> file. This is as follows:</p>
<pre class="calibre28"><code class="calibre23">// Create an element of the current type
std::shared_ptr&lt;CElement&gt; CSketcherView::CreateElement() const
{
   // Get a pointer to the document for this view
   CSketcherDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);                 // Verify the pointer is good
        
   // Get the current element color
   COLORREF color {static_cast&lt;COLORREF&gt;(pDoc-&gt;GetElementColor())};
 
   // Now select the element using the type stored in the document
   switch(pDoc-&gt;GetElementType())
   {
      <span {http://www.idpf.org/2007/ops}type="pagebreak" title="708" id="calibre_link-1170" class="calibre14"></span>case ElementType::RECTANGLE:
         return std::make_shared&lt;CRectangle&gt;(m_FirstPoint, m_SecondPoint, color);
        
      case ElementType::CIRCLE:
         return std::make_shared&lt;CCircle&gt;(m_FirstPoint, m_SecondPoint, color);
        
      case ElementType::CURVE:
         return std::make_shared&lt;CCurve&gt;(m_FirstPoint, m_SecondPoint, color);
        
      case ElementType::LINE:
         return std::make_shared&lt;CLine&gt;(m_FirstPoint, m_SecondPoint, color);
        
      default:
         // Something's gone wrong
         AfxMessageBox(_T("Bad Element code"), MB_OK);
         AfxAbort();
         return nullptr;
   }
}</code></pre>
<p class="calibre13">You first get a pointer to the document object by calling <code class="calibre23">GetDocument()</code>, as you’ve seen before. For safety, you use the <code class="calibre23">ASSERT_VALID()</code> macro to ensure that a good pointer is returned. In the debug version of your application, this macro calls the <code class="calibre23">AssertValid()</code> member of the object, which is specified as the argument to the macro. This checks the validity of the current object, and if the pointer is <code class="calibre23">nullptr</code> or the object is defective in some way, an error message is displayed. In the release version of your application, the <code class="calibre23">ASSERT_VALID()</code> macro does nothing.</p>
<p class="calibre13">You cannot use the <code class="calibre23">ElementColor</code> enumerator that the <code class="calibre23">GetElementColor()</code> function returns as a color value when you create an element because it’s the wrong type. However, the numerical value of each enumerator is a <code class="calibre23">COLORREF</code> color value so you can cast an enumerator to type <code class="calibre23">COLORREF</code> to get the color value. The <code class="calibre23">switch</code> statement selects the element to be created based on the type returned by <code class="calibre23">GetElementType()</code>. In the unlikely event that the type is not an <code class="calibre23">ElementType</code> enumerator, you display a message box and end the program.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Dealing with WM_LBUTTONUP Messages</h5>
<p class="calibre13">The <code class="calibre23">WM_LBUTTONUP</code> message completes the process of creating an element. The job of this handler is to pass the final version of the element to the document object, and then to clean up the view object data members. You can add an STL container object in the <code class="calibre23">CSketcherDoc</code> class to store elements. You will also need a document class function that you can call when you want to add an element. It’s likely that you will want to delete elements from the document at some point. A <code class="calibre23">vector&lt;T&gt;</code> would be faster but I’ll use a list container here for the experience because you use a vector container to store the points for a curve. Add the following <code class="calibre23">protected</code> data member to <code class="calibre23">CSketcherDoc</code>:</p>
<pre class="calibre28"><code class="calibre23">std::list&lt;std::shared_ptr&lt;CElement&gt;&gt; m_Sketch;     // A list containing the sketch</code></pre>
<p class="calibre13">Sketch elements are created on the heap so you can store smart pointers to elements rather than the elements themselves. Add <code class="calibre23">#include</code> directives for the <code class="calibre23">list</code> and <code class="calibre23">memory</code> headers and <code class="calibre23">Element.h</code> to <span {http://www.idpf.org/2007/ops}type="pagebreak" title="709" id="calibre_link-1171" class="calibre14"></span><code class="calibre23">SketcherDoc.h</code>. When the document object is destroyed, <code class="calibre23">m_Sketch</code> will also be destroyed along with all the elements pointed to by the smart pointers it contains.</p>
<p class="calibre13">Add the following function definitions to the Implementation section of the <code class="calibre23">CSketcherDoc</code> class as <code class="calibre23">public</code> members:</p>
<pre class="calibre28"><code class="calibre23">  // Add a sketch element
  void AddElement(std::shared_ptr&lt;CElement&gt;&amp; pElement)
  {
    m_Sketch.push_back(pElement);
  }
 
  // Delete a sketch element
  void DeleteElement(std::shared_ptr&lt;CElement&gt;&amp; pElement)
  {
    m_Sketch.remove(pElement);
  }</code></pre>
<p class="calibre13">The first function adds the smart pointer for an element that you pass as the argument to the list, <code class="calibre23">m_Sketch</code>. The second removes the pointer from the list, which will also delete the element from the heap. You will implement the UI mechanism for deleting sketch elements in the next chapter.</p>
<p class="calibre13">You can now implement the <code class="calibre23">OnLButtonUp()</code> handler. Add the following lines to the function definition in <code class="calibre23">SketcherView.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonUp(UINT nFlags, CPoint point)
{
  <b class="calibre12">// Make sure there is an element</b>
  <b class="calibre12">if(m_pTempElement)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">// Add the element pointer to the sketch</b>
    <b class="calibre12">GetDocument()-&gt;AddElement(m_pTempElement);</b> 
    <b class="calibre12">InvalidateRect(&amp;m_pTempElement-&gt;GetEnclosingRect());</b>
    <b class="calibre12">m_pTempElement.reset();                // Reset the element pointer</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">The <code class="calibre23">if</code> statement verifies that <code class="calibre23">m_pTempElement</code> is not <code class="calibre23">nullptr</code> before processing it. It’s always possible that the user could press and release the left mouse button without moving the mouse, in which case, no element would have been created. As long as there is an element, the pointer to the element is passed to the document object function that adds it to the sketch. Finally, the <code class="calibre23">m_pTempElement</code> pointer is reset, ready for the next time the user draws an element.</p>
</section>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-352" class="calibre3"></a>DRAWING A SKETCH</h2>
<p class="calibre13">All the elements that make up a sketch are safely stored in the document object. You now need a way to display the sketch in the view. The <code class="calibre23">OnDraw()</code> function in <code class="calibre23">CSketcherView</code> will do this. Obviously, it will need access to the data for a sketch that is owned by the document object, and ideally this should happen without the document object exposing it to external modification. One way to achieve this is for the document object to make <code class="calibre23">const</code> iterators available. The iterator type name <span {http://www.idpf.org/2007/ops}type="pagebreak" title="710" id="calibre_link-1172" class="calibre14"></span>for a sketch is a little long-winded and you can economize on typing by adding a type alias definition to <code class="calibre23">SketcherDoc.h</code> after the <code class="calibre23">#include</code> directives:</p>
<pre class="calibre28"><code class="calibre23">using SketchIterator = std::list&lt;std::shared_ptr&lt;CElement&gt;&gt;::const_iterator;</code></pre>
<p class="calibre13">You can now use <code class="calibre23">SketchIterator</code> to specify the type for a <code class="calibre23">const</code> iterator for the sketch list container. By adding the following functions to the <code class="calibre23">CSketcherDoc</code> class definition you will enable the view object to obtain the iterators it needs to draw a sketch:</p>
<pre class="calibre28"><code class="calibre23">  // Provide a begin iterator for the sketch
  SketchIterator begin() const { return std::begin(m_Sketch);  }
 
  // Provide an end iterator for the sketch
  SketchIterator end() const { return std::end(m_Sketch);  }</code></pre>
<p class="calibre13">These should be <code class="calibre23">public</code>, and you can put them in the Operations section of <code class="calibre23">CSketcherDoc</code>. A <code class="calibre23">const</code> iterator can be incremented and dereferenced but it cannot be used to modify what it points to.</p>
<p class="calibre13">You can use these functions to implement the <code class="calibre23">OnDraw()</code> member of <code class="calibre23">CSketcherView</code>:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnDraw(CDC* pDC)
{
  CSketcherDoc* pDoc = GetDocument();
  ASSERT_VALID(pDoc);
  if (!pDoc)
    return;
 
  // Draw the sketch
  for(auto iter = pDoc-&gt;begin() ; iter != pDoc-&gt;end() ; ++iter)
  for (const auto&amp; pElement : *pDoc) 
  {
    if (pDC-&gt;RectVisible(pElement-&gt;GetEnclosingRect()))
      pElement-&gt;Draw(pDC);
  }
}</code></pre>
<p class="calibre13">Because the document object defines <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> functions that return iterators for the elements in the sketch, we can use the range-based <code class="calibre23">for</code> loop directly with it. You only want to draw an element when it is visible in the client area of the view. Drawing elements that do not appear in the view just consumes processor time to no effect. The <code class="calibre23">RectVisible()</code> member of a <code class="calibre23">CDC</code> object returns <code class="calibre23">TRUE</code> if any part of the rectangle that you pass as the argument is within the client area, otherwise it returns <code class="calibre23">FALSE</code>. Calling this in the <code class="calibre23">if</code> statement ensures that only visible elements are drawn. You draw a sketch element by calling its <code class="calibre23">Draw()</code> member with the pointer to the device context as the argument.</p>
<section class="toclist">
<h3 class="calibre21">Running the Example</h3>
<p class="calibre13">After making sure that you have saved all the source files, build the program. If you haven’t made any mistakes entering the code, you’ll get a clean compile and link, so you can execute the program. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="711" id="calibre_link-1173" class="calibre14"></span>You can draw lines, circles, rectangles, and curves in any of the four colors the program supports. A typical window is shown in <a id="calibre_link-134" href="#calibre_link-133" class="calibre3">Figure 14-17</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000031.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-133" href="#calibre_link-134" class="calibre3">FIGURE 14-17</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Try experimenting with the user interface. Note that you can move the window around and that the elements are drawn automatically if you expose them after they are hidden. However, all is not as it should be. If you try drawing a shape while dragging the cursor outside the client view area, you’ll notice some peculiar effects. Outside the view window, you lose track of the mouse, which stops the rubber-banding mechanism from working while the cursor is not in the client area. What’s going on?</p>
</section>
<section class="toclist">
<h3 class="calibre21">Capturing Mouse Messages</h3>
<p class="calibre13">The problem is caused by Windows sending the mouse messages to the window under the cursor. As soon as the cursor leaves the client area of the application view, the <code class="calibre23">WM_MOUSEMOVE</code> messages are being sent elsewhere. You can fix this with the aid of some inherited members of the <code class="calibre23">CSketcherView</code> class.</p>
<p class="calibre13">The view class inherits the <code class="calibre23">SetCapture()</code> function from <code class="calibre23">CWnd</code>. You call this function to tell Windows that you want your view window to receive all mouse messages until such time as you say otherwise. This is referred to as <i class="calibre15">capturing the mouse</i>. You can stop capturing the mouse by calling another inherited function, <code class="calibre23">ReleaseCapture()</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="712" id="calibre_link-1174" class="calibre14"></span>You can capture the mouse as soon as the left button is pressed by modifying the handler for the <code class="calibre23">WM_LBUTTONDOWN</code> message:</p>
<pre class="calibre28"><code class="calibre23">// Handler for left mouse button down message
void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
   m_FirstPoint = point;           // Record the cursor position
   <b class="calibre12">SetCapture();                   // Capture subsequent mouse messages</b>
}</code></pre>
<p class="calibre13">Now, you must call <code class="calibre23">ReleaseCapture()</code> in the <code class="calibre23">WM_LBUTTONUP</code> handler. If you don’t do this, other programs cannot receive any mouse messages as long as your program continues to run. Of course, you should release the mouse only if you’ve captured it earlier. The <code class="calibre23">GetCapture()</code> function that the view class inherits returns a pointer to the window that has captured the mouse, and this gives you a way of telling whether or not you have captured mouse messages. You just need to add the following to the handler for <code class="calibre23">WM_LBUTTONUP</code>:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonUp(UINT nFlags, CPoint point)
{
  <b class="calibre12">if(this == GetCapture())</b>
    <b class="calibre12">ReleaseCapture();                 // Stop capturing mouse messages</b>
        
  // Make sure there is an element
  if(m_pTempElement)
  {
    GetDocument()-&gt;AddElement(m_pTempElement);
    InvalidateRect(&amp;m_pTempElement-&gt;GetEnclosingRect());
    m_pTempElement.reset();           // Reset the element pointer
  }
}</code></pre>
<p class="calibre13">If the pointer returned by <code class="calibre23">GetCapture()</code> is equal to the pointer <code class="calibre23">this</code>, your view has captured the mouse, so you release it.</p>
<p class="calibre13">The final alteration you should make is to modify the <code class="calibre23">WM_MOUSEMOVE</code> handler so that it deals only with messages that have been captured by the view. You can do this with one small change:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  // Define a Device Context object for the view
  CClientDC aDC {this};                // DC is for this view
 
  <b class="calibre12">// Verify the left button is down and mouse messages are captured</b>
  <b class="calibre12">if((nFlags &amp; MK_LBUTTON) &amp;&amp; (this == GetCapture()))</b>
  {
    // Code as before...
  }
}</code></pre>
<p class="calibre13">The handler now processes the message only if the left button is down and the mouse has been captured by your view window.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="713" id="calibre_link-1175" class="calibre14"></span>If you build Sketcher with these additions you’ll find that the problems that arose earlier when the cursor was dragged off the client area no longer occur.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-353" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">After completing this chapter, you should have a good grasp of how to write message handlers for the mouse, and how to organize drawing operations in your Windows programs. You have seen how using polymorphism with the shape classes makes it possible to operate on any shape in the same way, regardless of its actual type.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Add a menu item and Toolbar button to Sketcher for an ellipse element. Add an element type for ellipses and define a class to support drawing ellipses defined by two points on opposite corners of their enclosing rectangle.</li>
<li class="calibre6">Which functions must you modify to support drawing ellipses? Modify the program to draw ellipses.</li>
<li class="calibre6">Which functions must you modify in the example from the previous exercise so that the first point defines the center of the ellipse, and the current cursor position defines a corner of the enclosing rectangle? Modify the example to work this way. (Hint: look up the <code class="calibre23">CPoint</code> class members in Help.)</li>
<li class="calibre6">Add a new <code class="calibre23">Pen Style</code> menu to the menu bar to allow solid, dashed, dotted, dash-dotted, and dash-dot-dotted lines to be specified.</li>
<li class="calibre6">Which parts of the program need to be modified to support the operation of the menu, and the drawing of elements in the line types listed in the previous exercise?</li>
<li class="calibre6">Implement support for the new menu and drawing all elements in any of the line types.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="714" id="calibre_link-1176" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The client coordinate system</b></td>
<td class="calibre32">By default, Windows addresses the client area of a window using a client coordinate system with the origin in the upper-left corner of the client area. The positive x-direction is from left to right, and the positive y-direction is from top to bottom.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Drawing in the client area</b></td>
<td class="calibre32">You can draw in the client area of a window only by using a device context.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Device contexts</b></td>
<td class="calibre32">A device context provides a range of logical coordinate systems called mapping modes for addressing the client area of a window.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Mapping modes</b></td>
<td class="calibre32">The default origin position for a mapping mode is the upper-left corner of the client area. The default mapping mode is <code class="calibre23">MM_TEXT</code>, which provides coordinates measured in pixels. The positive x-axis runs from left to right in this mode, and the positive y-axis from top to bottom.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Drawing in a window</b></td>
<td class="calibre32">Your program should always draw the permanent contents of the client area of a window in response to a <code class="calibre23">WM_PAINT</code> message, although temporary entities can be drawn at other times. All the drawing for your application document should be controlled from the <code class="calibre23">OnDraw()</code> member function of a view class. This function is called when a <code class="calibre23">WM_PAINT</code> message is received by your application.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Redrawing a window</b></td>
<td class="calibre32">You can identify the part of the client area you want to have redrawn by calling the <code class="calibre23">InvalidateRect()</code> member function of your view class. The area passed as an argument is added by Windows to the total area to be redrawn when the next <code class="calibre23">WM_PAINT</code> message is sent to your application.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Mouse messages</b></td>
<td class="calibre32">Windows sends standard messages to your application for mouse events. You can create handlers to deal with these messages by using the Class Wizard.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Capturing mouse messages</b></td>
<td class="calibre32">You can cause all mouse messages to be routed to your application by calling the <code class="calibre23">SetCapture()</code> function that is inherited in your view class. You must release the mouse when you’re finished with it by calling the <code class="calibre23">ReleaseCapture()</code> function. If you fail to do this, other applications are unable to receive mouse messages.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="715" id="calibre_link-1177" class="calibre14"></span><b class="calibre12">Rubber-banding</b></td>
<td class="calibre32">You can implement rubber-banding during the creation of geometric entities by drawing them in the message handler for mouse movements.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Selecting a drawing mode</b></td>
<td class="calibre32">The <code class="calibre23">SetROP2()</code> member of the <code class="calibre23">CDC</code> class enables you to set drawing modes. Selecting the right drawing mode greatly simplifies rubber-banding operations.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Adding event handlers</b></td>
<td class="calibre32">The Properties window for a GUI component also enables you to add event handler functions automatically.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Casting smart pointers</b></td>
<td class="calibre32">You can cast a smart pointer to another smart pointer type using <code class="calibre23">static_pointer_cast, dynamic_pointer_cast</code>, and <code class="calibre23">const_pointer_cast</code>.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="716" id="calibre_link-1178" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-11">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2328" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="717" id="calibre_link-1179" class="calibre9"></span><span class="chapternumber">Chapter 15</span><br class="calibre10" /><span class="chapternumber">Improving the View</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How to draw and update multiple views</li>
<li class="calibre6">How to implement scrolling in a view</li>
<li class="calibre6">How to create a context menu at the cursor</li>
<li class="calibre6">How to highlight the element nearest the cursor to provide feedback to the user</li>
<li class="calibre6">How to program the mouse to move and delete elements</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 15 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-354" class="calibre3"></a>SKETCHER LIMITATIONS</h2>
<p class="calibre13">There are still some limitations in Sketcher. For instance:</p>
<ol class="calibre5">
<li class="calibre6">You can open another view window for the current sketch by using the Window <img src="images/000122.png" alt="image" class="calibre25" /> New Window menu option. This capability is built into an MDI application. However, if you draw in one window the elements are not drawn in the other window. Elements never appear in windows other than the one in which they were created unless the area they occupy is redrawn for some other reason.</li>
<li class="calibre6">You can draw only in the client area you can see. It would be nice to be able to scroll the view and draw over a bigger area.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="718" id="calibre_link-1180" class="calibre14"></span>Even though the document object can delete an element from the sketch, you have no user interface mechanism for deleting an element. If you make a mistake, you either live with it or start over with a new document.</li>
<li class="calibre6">You can't view a sketch window at different scales. Being able to view a sketch at a larger scale would make it easier to add fine detail.</li>
<li class="calibre6">You can't print a sketch. If you want to show your artistic capabilities to someone, you have to bring your computer along.</li>
<li class="calibre6">You can't save a sketch in a file so it has no permanence at all.</li>
</ol>
<p class="calibre13">These are quite serious deficiencies that limit the usability of the program. You’ll overcome the first three before the end of this chapter. You’ll remove the remaining limitations before the end of the book.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-355" class="calibre3"></a>IMPROVING THE VIEW</h2>
<p class="calibre13">The first item that you can fix is the updating of all the document view windows when an element is drawn. The problem arises because only the view in which you draw an element knows about it. Each view is acting independently of the others, and there is no communication between them. If you can arrange for all the views to be notified when an element is added to the document, they can take the appropriate action.</p>
<section class="toclist">
<h3 class="calibre21">Updating Multiple Views</h3>
<p class="calibre13">The document class contains the <code class="calibre23">UpdateAllViews()</code> function to help with this particular problem. The function provides a means for the document to send a message to all its views. You just need to call it from the <code class="calibre23">AddElement()</code> function in <code class="calibre23">CSketcherDoc</code> that adds a new element:</p>
<pre class="calibre28"><code class="calibre23">  void AddElement(std::shared_ptr&lt;CElement&gt;&amp; pElement)
  {
    m_Sketch.push_back(pElement);
    <b class="calibre12">UpdateAllViews(nullptr, 0, pElement.get());       // Tell all the views</b>
  }</code></pre>
<p class="calibre13">The inherited <code class="calibre23">UpdateAllViews()</code> function is called whenever an element is added to the document. This communicates with the views by calling the <code class="calibre23">OnUpdate()</code> member of each view. The <code class="calibre23">UpdateAllViews()</code> function has three parameters, two of which have default values. The arguments that you can supply are:</p>
<ol class="calibre5">
<li class="calibre6">A pointer to the current view object. This identifies the view for which the <code class="calibre23">OnUpdate()</code> function should not be called. This is a useful feature when the current view is up to date and you have a pointer to it. You could arrange for this if you needed to by adding an extra parameter of type <code class="calibre23">CSketcherView*</code> to <code class="calibre23">AddElement()</code> and passing the <code class="calibre23">this</code> pointer for the view to it when it was called. Another possibility is that you could call <code class="calibre23">UpdateAllViews()</code> from a view object when an element is created. When you specify <code class="calibre23">nullptr</code> as the argument <span {http://www.idpf.org/2007/ops}type="pagebreak" title="719" id="calibre_link-1181" class="calibre14"></span>as in this instance, <code class="calibre23">OnUpdate()</code> will be called for all views. This will be passed on as the first argument in all <code class="calibre23">OnUpdate()</code> function calls.</li>
<li class="calibre6">A <code class="calibre23">long</code> integer value that has a default value of zero. This is intended to provide a hint about the region to be updated. If you supply a value for this, it will be passed as the second argument in the call to the <code class="calibre23">OnUpdate()</code> function for each view object.</li>
<li class="calibre6">A pointer of type <code class="calibre23">CObject*</code> with a default value of <code class="calibre23">nullptr</code>. If you supply this argument, it will be passed as the third argument in the <code class="calibre23">OnUpdate()</code> function call for each view. It should point to an object that provides information about the region to be updated. In our case it should be a pointer to the new element; a smart pointer cannot be used. Calling <code class="calibre23">get()</code> for the smart pointer, <code class="calibre23">pElement</code>, returns the <code class="calibre23">CElement*</code> pointer that <code class="calibre23">pElement</code> contains.</li>
</ol>
<p class="calibre13">To process the information passed to the <code class="calibre23">UpdateAllViews()</code> function, you must add an override for the <code class="calibre23">OnUpdate()</code> member of the view class. You can do this through the Properties window for <code class="calibre23">CSketcherView</code>. Just to remind you, you display the properties for a class by right-clicking the class name in Class View and selecting Properties from the menu. If you click the Overrides button in the Properties window, you’ll be able to find <code class="calibre23">OnUpdate</code> in the list of functions. Click the function name, then the <code class="calibre23">&lt;Add&gt; OnUpdate</code> option that shows in the drop-down list in the adjacent column. You’ll be able to edit the code for the <code class="calibre23">OnUpdate()</code> override you have added in the Editor pane. You only need to add the following highlighted code to the function definition:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">void CSketcherView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)</b>
<b class="calibre12">{</b>
   <b class="calibre12">// Invalidate the area corresponding to the element pointed to</b>
   <b class="calibre12">// by the third argument, otherwise invalidate the whole client area</b>
   <b class="calibre12">if(pHint)</b>
   <b class="calibre12">{</b>
      <b class="calibre12">InvalidateRect(dynamic_cast&lt;CElement*&gt;(pHint)-&gt;GetEnclosingRect());</b>
   <b class="calibre12">}</b>
   <b class="calibre12">else</b>
   <b class="calibre12">{</b>
      <b class="calibre12">InvalidateRect(nullptr);</b>
   <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">Note that you must uncomment the parameter names; otherwise, it won’t compile with the additional code. The three arguments passed to <code class="calibre23">OnUpdate()</code> correspond to the arguments that you passed in the <code class="calibre23">UpdateAllViews()</code> function call. Thus, <code class="calibre23">pHint</code> contains the address of the new element. However, you can’t assume that this is always the case. The <code class="calibre23">OnUpdate()</code> function is also called when a view is first created, but with <code class="calibre23">nullptr</code> for the third argument. Therefore, the function verifies that <code class="calibre23">pHint</code> isn’t <code class="calibre23">nullptr</code> and only then calls <code class="calibre23">GetEnclosingRect()</code> to obtain the rectangle enclosing the element. It invalidates this area in the client area of the view by passing the rectangle to the <code class="calibre23">InvalidateRect()</code> function. This area is redrawn by the <code class="calibre23">OnDraw()</code> function in this view when the next <code class="calibre23">WM_PAINT</code> message is sent to the view. If <code class="calibre23">pHint</code> is <code class="calibre23">nullptr</code>, the whole client area is invalidated.</p>
<p class="calibre13">You might be tempted to consider redrawing the new element in the <code class="calibre23">OnUpdate()</code> function. This isn’t a good idea. You should do permanent drawing only in response to a Windows <code class="calibre23">WM_PAINT</code> message. This means that the <code class="calibre23">OnDraw()</code> function in the view should be the only thing that’s initiating any <span {http://www.idpf.org/2007/ops}type="pagebreak" title="720" id="calibre_link-1182" class="calibre14"></span>drawing operations for document data. This ensures that the view is drawn correctly whenever Windows deems it necessary.</p>
<p class="calibre13">Come to think of it, the views ought to be notified when an element is deleted from the document. You can modify the <code class="calibre23">DeleteElement()</code> member of the document class to take care of it:</p>
<pre class="calibre28"><code class="calibre23">  void DeleteElement(std::shared_ptr&lt;CElement&gt;&amp; pElement)
  {
    <b class="calibre12">m_Sketch.remove(pElement);</b>
    <b class="calibre12">UpdateAllViews(nullptr, 0, pElement.get());    // Tell all the views</b>
  }</code></pre>
<p class="calibre13">Calling <code class="calibre23">remove()</code> for the list removes the element that matches the argument by calling its destructor. This will cause the smart pointer that was in the list to be destroyed. The element to which it points will not be destroyed because there is another <code class="calibre23">shared_ptr</code> referencing it, namely the object that was passed to <code class="calibre23">DeleteElement()</code>. You use this to pass the element pointer to <code class="calibre23">UpdateAllViews()</code>. The smart pointer is passed by reference, so the element will ultimately be destroyed when the smart pointer on the calling site is destroyed.</p>
<p class="calibre13">If you build and execute Sketcher with the new modifications, you should find that you can create multiple views of the document and draw in any of them. All the views get updated to reflect the contents of the document.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Scrolling Views</h3>
<p class="calibre13">Adding scrolling to a view looks remarkably easy at first sight, but the water is, in fact, deeper and murkier than it at first appears. We will jump in anyway. The first step is to change the base class for <code class="calibre23">CSketcherView</code> from <code class="calibre23">CView</code> to <code class="calibre23">CScrollView</code>. This new base class has the scrolling functionality built in, so you can alter the definition of the <code class="calibre23">CSketcherView</code> class to this:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">class CSketcherView : public CScrollView</b>
{
   // Class definition as before...
};</code></pre>
<p class="calibre13">You must also modify two lines of code at the beginning of the <code class="calibre23">SketcherView.cpp</code> file that refer to the base class for <code class="calibre23">CSketcherView</code>. You need to replace <code class="calibre23">CView</code> with <code class="calibre23">CScrollView</code> as the base class:</p>
<pre class="calibre28"><code class="calibre23">IMPLEMENT_DYNCREATE(CSketcherView, CScrollView)
        
BEGIN_MESSAGE_MAP(CSketcherView, CScrollView)</code></pre>
<p class="calibre13">However, this is still not quite enough. The new view class needs to know some things about the area you are drawing on and want to scroll, such as its size and how far the view is to be scrolled when you use the scroller. This information must be supplied before the view is drawn. You can put the code to do this in the <code class="calibre23">OnInitialUpdate()</code> function in the view class because this will be called after the view is attached to the document but before the view is displayed.</p>
<p class="calibre13">You supply the information required for scrolling by calling the <code class="calibre23">SetScrollSizes()</code> function that is inherited from the <code class="calibre23">CScrollView</code> class. The arguments to this function are explained in <a id="calibre_link-13" href="#calibre_link-12" class="calibre3">Figure 15-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000156.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-12" href="#calibre_link-13" class="calibre3">FIGURE 15-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="721" id="calibre_link-1183" class="calibre14"></span>Scrolling a distance of one line occurs when you click on the up or down arrow on the scroll bar; a page scroll occurs when you click the scrollbar itself. You have an opportunity to change the mapping mode here. <code class="calibre23">MM_LOENGLISH</code> would be a good choice for the Sketcher application, but we will first get scrolling working with the <code class="calibre23">MM_TEXT</code> mapping mode because there are still some difficulties to be uncovered.</p>
<p class="calibre13">To add the code to call <code class="calibre23">SetScrollSizes()</code>, you need to override the default version of the <code class="calibre23">OnInitialUpdate()</code> function in the view. You access this in the same way as for the <code class="calibre23">OnUpdate()</code> function override &mdash; through the Properties window for <code class="calibre23">CSketcherView</code>. After you have added the override, add the code to the function where indicated by the comment:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnInitialUpdate()
{
  CScrollView::OnInitialUpdate();
        
  <b class="calibre12">CSize DocSize {20000,20000};                    // The document size</b>

  <b class="calibre12">// Set mapping mode and document size</b>
  <b class="calibre12">SetScrollSizes(MM_TEXT, DocSize, CSize {500,500}, CSize {20,20};</b>
}</code></pre>
<p class="calibre13">This maintains the mapping mode as <code class="calibre23">MM_TEXT</code> and defines the total extent that you can draw on as 20,000 pixels in each direction. It also specifies a page scroll increment as 500 pixels in each direction and a line scroll increment as 20 pixels, because the defaults would be too large.</p>
<p class="calibre13">This is enough to get scrolling working after a fashion. Build Sketcher and execute it with these additions. You’ll be able to draw a few elements and then scroll the view. However, although the window scrolls OK, if you try to draw more elements with the view scrolled, things don’t work as they should. The elements appear in a different position from where you draw them and they’re not displayed properly. What’s going on?</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="722" id="calibre_link-1184" class="calibre14"></span>Logical Coordinates and Client Coordinates</h4>
<p class="calibre13">The problem is because of the coordinate systems you’re using &mdash; and that plural is deliberate. You have been using <i class="calibre15">two</i> coordinate systems in all the examples up to now, although you may not have noticed because they were coincident. When you call a function such as <code class="calibre23">LineTo()</code> for a <code class="calibre23">CDC</code> object it assumes that the arguments you pass to it are <i class="calibre15">logical coordinates</i>. The device context has its own system of logical coordinates. The mapping mode, which is a property of the device context, determines what the unit of measurement is for the coordinates when you draw something.</p>
<p class="calibre13">The coordinate data that you receive along with the mouse messages has nothing to do with the device context or the <code class="calibre23">CDC</code> object &mdash; and outside of a device context, logical coordinates don’t apply. The points passed to the <code class="calibre23">OnLButtonDown()</code> and <code class="calibre23">OnMouseMove()</code> handlers have coordinates that are always in device units &mdash; that is, pixels &mdash; and are measured relative to the upper left corner of the client area. These are referred to as <i class="calibre15">client coordinates</i>. Similarly, when you call <code class="calibre23">InvalidateRect()</code>, the rectangle is assumed to be defined in terms of client coordinates.</p>
<p class="calibre13">In <code class="calibre23">MM_TEXT</code> mode, client coordinates and the logical coordinates in the device context are both in pixels, and so they are the same &mdash; <i class="calibre15">as long as you don’t scroll the window</i>. In all the previous examples, there was no scrolling, so everything worked without any problems. With the latest version of Sketcher, it all works well until you scroll the view, whereupon the logical coordinates origin (the 0,0 point) is moved by the scrolling mechanism, so it’s no longer in the same place as the client coordinates origin. The <i class="calibre15">units</i> for logical coordinates and client coordinates are the same, but the <i class="calibre15">origins</i> for the coordinates systems are different. This situation is illustrated in <a id="calibre_link-15" href="#calibre_link-14" class="calibre3">Figure 15-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000125.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-14" href="#calibre_link-15" class="calibre3">FIGURE 15-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="723" id="calibre_link-1185" class="calibre14"></span>The left side of <a href="#calibre_link-14" class="calibre3">Figure 15-2</a> shows the position in the client area where you draw, and the points that are the mouse cursor positions defining the line. These are recorded in client coordinates. The right side shows where the line is actually drawn. Drawing is in logical coordinates, but you have been using client coordinate values as arguments to the drawing functions. When the view is scrolled, the line appears displaced because the logical origin has been relocated.</p>
<p class="calibre13">This means that you are using the wrong values to define elements in Sketcher. When you invalidate areas of the client area to get them redrawn, the enclosing rectangles you pass to the function are also wrong &mdash; hence, the weird behavior of the program. With other mapping modes, it gets worse. Not only are the units of measurement in the two coordinate systems different, but the <i class="calibre15">y</i>-axes may be in opposite directions!</p>
</section>
<section class="toclist">
<h4 class="calibre22">Dealing with Client Coordinates</h4>
<p class="calibre13">Let’s consider what needs to be done to fix the problem. There are two things you have to address:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">You must convert the client coordinates that you got with mouse messages to logical coordinates before you use them to create elements.</li>
<li class="calibre6">You must convert a bounding rectangle that you created in logical coordinates back to client coordinates if you want to use it in a call to <code class="calibre23">InvalidateRect()</code>.</li>
</ul>
<p class="calibre13">These amount to making sure that you always use logical coordinates with device context functions, and always use client coordinates for other communications about the window. The functions that will do the conversions between client coordinates and logical coordinates are members of a device context object, so you need to obtain a device context whenever you want to convert from logical coordinates to client coordinates or vice versa. The coordinate conversion functions are defined in the <code class="calibre23">CDC</code> class and inherited by <code class="calibre23">CClientDC</code> so you can use an object of this type to do the work.</p>
<p class="calibre13">The revised version of the <code class="calibre23">OnLButtonDown()</code> handler incorporating this is as follows:</p>
<pre class="calibre28"><code class="calibre23">// Handler for left mouse button down message
void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
 
   <b class="calibre12">CClientDC aDC {this};            // Create a device context</b>
   <b class="calibre12">OnPrepareDC(&amp;aDC);               // Get origin adjusted</b>
   <b class="calibre12">aDC.DPtoLP(&amp;point);              // Convert point to logical coordinates</b>
   m_FirstPoint = point;            // Record the cursor position
   SetCapture();                    // Capture subsequent mouse messages
}</code></pre>
<p class="calibre13">You obtain a device context for the current view by creating a <code class="calibre23">CClientDC</code> object and passing the pointer <code class="calibre23">this</code> to the constructor. As you’re using <code class="calibre23">CScrollView</code>, the inherited <code class="calibre23">OnPrepareDC()</code> member function must be called to set the origin for the logical coordinate system in the device context to correspond with the scrolled position. After you have set the origin by this call, you call the <code class="calibre23">DPtoLP()</code> function that converts from Device Points to Logical Points. This converts the <code class="calibre23">point</code> value that was passed to <code class="calibre23">OnLButtonDown()</code> and is in client coordinates to logical coordinates. You then store the point in logical coordinates in <code class="calibre23">m_FirstPoint</code>, ready for creating an element in the <code class="calibre23">OnMouseMove()</code> handler.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="724" id="calibre_link-1186" class="calibre14"></span>The new code for the <code class="calibre23">OnMouseMove()</code> handler is as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  CClientDC aDC {this};              // Device context for the current view
  <b class="calibre12">OnPrepareDC(&amp;aDC);                 // Get origin adjusted</b>
  <b class="calibre12">aDC.DPtoLP(&amp;point);                // Convert point to logical coordinates</b>
 
  // Verify the left button is down and mouse messages captured
  if((nFlags&amp;MK_LBUTTON)&amp;&amp;(this==GetCapture()))
  {
     m_SecondPoint = point;          // Save the current cursor position
 
    // Rest of the function as before...
  }
}</code></pre>
<p class="calibre13">The code for converting <code class="calibre23">point</code> is essentially the same as in the previous handler, and that’s all you need here for the moment. The last function that you must change is easy to overlook: the <code class="calibre23">OnUpdate()</code> function in the view class. This needs to be modified to the following:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
   // Invalidate the area corresponding to the element pointed to
   // if there is one, otherwise invalidate the whole client area 
   if(pHint)
   {
     <b class="calibre12">CClientDC aDC {this};           // Create a device context</b>
     <b class="calibre12">OnPrepareDC(&amp;aDC);              // Get origin adjusted</b>

     <b class="calibre12">// Get the enclosing rectangle and convert to client coordinates</b>
     <b class="calibre12">CRect aRect {dynamic_cast&lt;CElement*&gt;(pHint)-&gt;GetEnclosingRect()};</b>
     <b class="calibre12">aDC.LPtoDP(aRect);</b>
     <b class="calibre12">InvalidateRect(aRect);          // Get the area redrawn</b>
  }
  else
  {
    InvalidateRect(nullptr);         // Invalidate the client area
  }
}</code></pre>
<p class="calibre13">The function now creates a <code class="calibre23">CClientDC</code> object and uses an overloaded version of the <code class="calibre23">LPtoDP()</code> member to convert the enclosing rectangle for the element to client coordinates.</p>
<p class="calibre13">You must do the same thing in <code class="calibre23">OnLButtonUp()</code> when you invalidate the enclosing rectangle for the element:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonUp(UINT nFlags, CPoint point)
{
  if(this == GetCapture())
    ReleaseCapture();                // Stop capturing mouse messages
 
  // Make sure there is an element
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="725" id="calibre_link-1187" class="calibre14"></span>if(m_pTempElement)
  { 
     <b class="calibre12">CRect aRect {m_pTempElement-&gt;GetEnclosingRect()}; // Get enclosing rectangle</b>
    
    <b class="calibre12">GetDocument()-&gt;AddElement(m_pTempElement);   // Add element pointer to sketch</b>
     
     <b class="calibre12">CClientDC aDC {this};                       // Create a device context</b>
     <b class="calibre12">OnPrepareDC(&amp;aDC);                          // Get origin adjusted</b>
     <b class="calibre12">aDC.LPtoDP(aRect);                          // Convert to client coordinates</b>
     <b class="calibre12">InvalidateRect(aRect);                      // Get the area redrawn</b>
    m_pTempElement.reset();                      // Reset pointer to nullptr
   }
}</code></pre>
<p class="calibre13">If you now compile and execute Sketcher with these modifications and are lucky enough not to have introduced any typos, it will work correctly, regardless of the scroller position. If you have a mouse wheel, you can scroll a view using that.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Using MM_LOENGLISH Mapping Mode</h3>
<p class="calibre13">The advantage of using the <code class="calibre23">MM_LOENGLISH</code> mapping mode is that it provides drawings in logical units of 0.01 inches, which ensures that the drawing size is the same on displays at different resolutions. This makes the application much more satisfactory from the user’s point of view.</p>
<p class="calibre13">You can set the mapping mode in the call to <code class="calibre23">SetScrollSizes()</code> made from the <code class="calibre23">OnInitialUpdate()</code> function in the view class. You also need to specify the total drawing area: if you define it as 3,000 by 3,000, this provides a drawing area of 30 inches by 30 inches, which should be adequate. The default scroll distances for a line and a page are satisfactory, so you don’t need to specify those. You can use the Class View to get to the <code class="calibre23">OnInitialUpdate()</code> function and then change it to the following:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnInitialUpdate(void)
{
   CScrollView::OnInitialUpdate();
   
   <b class="calibre12">CSize DocSize {3000,3000};               // Document 30x30ins in MM_LOENGLISH</b>
   <b class="calibre12">SetScrollSizes(MM_LOENGLISH, DocSize);   // Set mapping mode and document size</b>
}</code></pre>
<p class="calibre13">That’s all you need to enable the view to work in <code class="calibre23">MM_LOENGLISH</code>. Note that you are not limited to setting the mapping mode once and for all. You can change the mapping mode in a device context at any time and draw different parts of a view using different mapping modes. A function, <code class="calibre23">SetMapMode()</code>, is used to do this, but I won’t be going into this any further here. Whenever you create a <code class="calibre23">CClientDC</code> object for the view and call <code class="calibre23">OnPrepareDC()</code>, the device context that it owns has the mapping mode you’ve set in the <code class="calibre23">OnInitialUpdate()</code> function. That should do it for the program as it stands. If you build Sketcher, you should have scrolling working, with support for multiple views.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-356" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="726" id="calibre_link-1188" class="calibre18"></span>DELETING AND MOVING ELEMENTS</h2>
<p class="calibre13">Being able to delete shapes is a fundamental requirement in a drawing program. The document object already has the facility for deleting a sketch element but you still have to decide on the user interface mechanism for this. How are you going to select the element you want to delete? Of course, after you decide on a mechanism for selecting an element, this will apply equally well to selecting an element to move it. This suggests that you can treat moving and deleting elements as related problems. But first, let’s consider how you might initiate move and delete operations in the user interface.</p>
<p class="calibre13">A neat way of providing these functions would be to have a <i class="calibre15">context menu</i> popup at the cursor position when you click the right mouse button. You could then include Move and Delete as items on the menu. A pop-up menu that works like this is a very handy facility in lots of situations.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Context menus are also referred to as pop-up menus or as shortcut menus.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">How should the context menu work? The standard way is that the user moves the mouse over a particular element that is displayed and right-clicks it. This selects the element and pops up a menu containing a list of menu items offering actions that can be performed on that element. The element provides the context for the menu. Naturally, different elements can have different context menus. You have seen this in action in the IDE for Visual C++. When you right-click a class name in Class View, you get a menu that applies to the class, and that’s different from the one you get if you right-click a filename in Solution Explorer. You have two contexts to consider in Sketcher. You could right-click with the mouse cursor over a sketch element, or you could right-click when there is no element under the cursor.</p>
<p class="calibre13">How can you implement this functionality in Sketcher? First you need to create two menus, one for when you have an element under the cursor and one for when you don’t. You can check if there’s an element under the cursor when the user clicks the right mouse button. If there <i class="calibre15">is</i> an element under the cursor, you can highlight it by changing its color so that the user knows exactly the element to which the context menu relates.</p>
<p class="calibre13">First, I’ll explain how you can create and display a menu at the mouse cursor position in response to a right-click, then I’ll discuss how you can implement the details of the move and delete operations.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-357" class="calibre3"></a>IMPLEMENTING A CONTEXT MENU</h2>
<p class="calibre13">You need two menus for the context menu: one for when there is an element under the mouse cursor and another for when there isn’t. Change to Resource View and expand the list of resources. Right-click the <code class="calibre23">Menu</code> folder to bring up a context menu &mdash; another demonstration of what you are now trying to create in the Sketcher application. Select Insert Menu to create a new menu resource. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="727" id="calibre_link-1189" class="calibre14"></span>This has a default ID <code class="calibre23">IDR_MENU1</code> assigned, but you can change this. Select the name of the new menu in the Resource View and display the Properties window for the resource by pressing Alt+Enter (this is a shortcut to the View <img src="images/000122.png" alt="image" class="calibre25" /> Other Windows <img src="images/000122.png" alt="image" class="calibre25" /> Properties Window menu item). You can then edit the resource ID in the Properties window by clicking the value for the ID. You could change it to something more suitable, such as <code class="calibre23">IDR_CONTEXT_MENU</code>, in the right column. Note that the name for a menu resource must start with <code class="calibre23">IDR</code>. Pressing the Enter key saves the new name.</p>
<p class="calibre13">The next step is to create a drop-down menu containing Move and Delete as menu items that will apply when an element is under the cursor. The other drop-down menu will contain menu items from the Element and Color menus to allow the current selections to be changed. You can enter a name for the new item on the menu bar in the Editor pane. This can have any old caption because it won’t actually be seen by the user; the caption “element” will be OK. Now you can add the Move and Delete items to this menu. The default IDs of <code class="calibre23">ID_ELEMENT_MOVE</code> and <code class="calibre23">ID_ELEMENT_DELETE</code> will do fine, but you can change them if you want in the Properties window for each item.</p>
<p class="calibre13">Create a second drop-down menu with the menu name “no element”. <a id="calibre_link-17" href="#calibre_link-16" class="calibre3">Figure 15-3</a> shows how the element menu looks with the no element menu added.</p>
<figure class="calibre16">
<img class="center" src="images/000084.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-16" href="#calibre_link-17" class="calibre3">FIGURE 15-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The no element menu is going to contain menu items for the available element types and colors, identical to those on the Element and Color menus. The IDs you use for these items will be the same as the ones for the <code class="calibre23">IDR_SketchTYPE</code> menu items. The handler for a menu item is associated with the menu ID. Messages for menu items with the same ID will call the same handler, so the same handler will be called for a Line menu item regardless of whether the message originates from an item in the main Element menu or from the no element context menu.</p>
<p class="calibre13">There is a shortcut that saves you from having to re-create all these menu items. If you display the <code class="calibre23">IDR_SketchTYPE</code> menu and extend the Element menu, you can select all the menu items by clicking the first item and then clicking the last item while holding down the Shift key. You can then right-click the selection and select Copy from the pop-up or simply press Ctrl+C. If you then return to the <code class="calibre23">IDR_CONTEXT_MENU</code> and right-click the first item on the no element menu, you can insert the complete contents of the Element menu by selecting Paste from the pop-up or by pressing Ctrl+V. The copied menu items will have the same IDs as the originals. To insert a separator before you add the color menu items, right-click the empty menu item and select Insert Separator from the menu. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="728" id="calibre_link-1190" class="calibre14"></span>Add the items from the Color menu to the no element menu after the separator and you’re done. Close the properties box and save the resource file. At the moment, all you have is the definition of the context menus in a resource file. It isn’t connected to the code in the Sketcher program. You now need to associate these menus and their IDs with the view class. You also must create command handlers for the menu items in the pop-up corresponding to the IDs <code class="calibre23">ID_ELEMENT_MOVE</code> and <code class="calibre23">ID_ELEMENT_DELETE</code>.</p>
<p class="calibre13">To choose the appropriate menu to display when the right mouse button is clicked, you’ll need to know whether or not there is an element under the cursor. You can add a protected <code class="calibre23">shared_ptr&lt;CElement&gt;</code> member to the view class to track this:</p>
<pre class="calibre28"><code class="calibre23">std::shared_ptr&lt;CElement&gt; m_pSelected;      // Records element under the cursor</code></pre>
<p class="calibre13">You’ll store the address of the element under the cursor in this member, when there is one; otherwise, it will contain <code class="calibre23">nullptr</code>.</p>
<section class="toclist">
<h3 class="calibre21">Associating a Menu with a Class</h3>
<p class="calibre13">To associate the context menu with the view class, go to the Class View pane and display the Properties window for <code class="calibre23">CSketcherView</code> by right-clicking the class name and selecting Properties from the pop-up. If you click the Messages button in the Properties window, you’ll be able to add a handler for the <code class="calibre23">WM_CONTEXTMENU</code> message by selecting <code class="calibre23">&lt;Add&gt;OnContextMenu</code> from the adjacent cell in the right column. This handler is called when the user right-clicks in the view. The first argument passed to the handler is a pointer to the window in which the user right-clicked, and the second argument is the cursor position in screen coordinates.</p>
<p class="calibre13">Add the following code to the handler:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">void CSketcherView::OnContextMenu(CWnd* pWnd, CPoint point)</b>
{
  <b class="calibre12">CMenu menu;</b>
  <b class="calibre12">menu.LoadMenu(IDR_CONTEXT_MENU);              // Load the context menu</b> 
  <b class="calibre12">CMenu* pContext {menu.GetSubMenu(m_pSelected ? 0 : 1)};</b>         
  <b class="calibre12">ASSERT(pContext != nullptr);                  // Ensure it</b>'<b class="calibre12">s there</b>

  <b class="calibre12">pContext-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,</b>
                                                <b class="calibre12">point.x, point.y, this);</b>
}</code></pre>
<p class="calibre13">Don’t forget to uncomment the parameter names. This handler displays the first menu in the context menu when <code class="calibre23">m_pSelected</code> points to an element, and the second menu when it does not. Calling the <code class="calibre23">LoadMenu()</code> function for the menu object loads the menu resource corresponding to the ID supplied as the argument and attaches it to the <code class="calibre23">CMenu</code> object. The <code class="calibre23">GetSubMenu()</code> function returns a pointer to the context menu corresponding to the integer argument that specifies the position of the context menu in the <code class="calibre23">CMenu</code> object, with 0 being the first, 1 being the second, and so on. After ensuring the pointer returned by <code class="calibre23">GetSubMenu()</code> is not <code class="calibre23">nullptr</code>, you display the context menu by calling <code class="calibre23">TrackPopupMenu()</code>. The <code class="calibre23">ASSERT</code> macro only operates in the debug version of the program. It produces no code in the release version.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="729" id="calibre_link-1191" class="calibre14"></span>The first argument to the <code class="calibre23">TrackPopupMenu()</code> function consists of two flags ORed together. One flag specifies how the pop-up menu should be positioned and can be any of the following values:</p>
<ol class="none">
<li class="calibre6"><code class="calibre23">TPM_CENTERALIGN</code> centers the pop-up horizontally relative to the x-coordinate supplied as the second argument to the function.</li>
<li class="calibre6"><code class="calibre23">TPM_LEFTALIGN</code> positions the pop-up so that the left side of the menu is aligned with the x-coordinate supplied as the second argument to the function.</li>
<li class="calibre6"><code class="calibre23">TPM_RIGHTALIGN</code> positions the pop-up so that the right side of the menu is aligned with the x-coordinate supplied as the second argument to the function.</li>
</ol>
<p class="calibre13">This is just a selection of the options. There are more options available which you can find in the documentation.</p>
<p class="calibre13">The other flag specifies the mouse button and can be either of the following values:</p>
<ol class="none">
<li class="calibre6"><code class="calibre23">TPM_LEFTBUTTON</code> specifies that the pop-up only tracks the left mouse button.</li>
<li class="calibre6"><code class="calibre23">TPM_RIGHTBUTTON</code> specifies that the pop-up tracks either the left or the right mouse button.</li>
</ol>
<p class="calibre13">The next two arguments to <code class="calibre23">TrackPopupMenu()</code>specify the x- and y-coordinates of the context menu in screen coordinates. The y-coordinate determines the position of the top of the menu. The fourth argument specifies the window that owns the menu and that should receive all <code class="calibre23">WM_COMMAND</code> messages from the menu.</p>
<p class="calibre13">Now you can add the handler for the item in the context menu for moving elements. Return to the Resource View and double-click on <code class="calibre23">IDR_CONTEXT_MENU</code>. Right-click the Move menu item and then select Add Event Handler from the menu. It’s a <code class="calibre23">COMMAND</code> handler and you create it in the <code class="calibre23">CSketcherView</code> class. Click the Add and Edit button to create the handler function. You can follow the same procedure to create the handler for the Delete menu item.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Checking Context Menu Items</h3>
<p class="calibre13">You don’t have to do anything for <code class="calibre23">COMMAND</code> events for the no element menu items, as you already have handlers for them in the document class. These will automatically take care of the messages from the pop-up items. However, the menu items are in a separate resource, and the menu items will not get checked to reflect the currently selected element type and color. You can fix this in the <code class="calibre23">OnContextMenu()</code> handler, before the context menu is displayed.</p>
<p class="calibre13">The <code class="calibre23">CMenu</code> class has a <code class="calibre23">CheckMenuItem()</code> member that checks a menu item. This function checks or unchecks any item in the menu. The first argument selects which item in the menu is to be checked or unchecked; the second argument is a combination of two flags, one of which determines how the first argument specifies which item is to be checked, and the other specifies whether the menu item is to be checked or unchecked. Because each flag is a single bit in a <code class="calibre23">UINT</code> value, you combine the two using the bitwise OR. The second argument can contain the flag <code class="calibre23">MF_BYCOMMAND</code> if the first parameter is a menu ID or it can contain the flag <code class="calibre23">MF_BYPOSITION</code> which implies the first argument is an index. You can use the former because you know the element IDs. If the second argument <span {http://www.idpf.org/2007/ops}type="pagebreak" title="730" id="calibre_link-1192" class="calibre14"></span>contains the <code class="calibre23">MF_CHECKED</code> flag, the item will be checked; the <code class="calibre23">MF_UNCHECKED</code> flag indicates the opposite. Here’s how you can implement checking for the no element menu items:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnContextMenu(CWnd* pWnd, CPoint point)
{
  CMenu menu;
  menu.LoadMenu(IDR_CONTEXT_MENU);              // Load the context menu
  <b class="calibre12">CMenu* pContext {};</b>
  <b class="calibre12">if(m_pSelected)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">pContext = menu.GetSubMenu(0);</b>  
  <b class="calibre12">}</b>
  <b class="calibre12">else</b>
  <b class="calibre12">{</b>
    <b class="calibre12">pContext = menu.GetSubMenu(1);</b>  

    <b class="calibre12">// Check color menu items</b>
    <b class="calibre12">ElementColor color {GetDocument()-&gt;GetElementColor()};</b>
    <b class="calibre12">menu.CheckMenuItem(ID_COLOR_BLACK,</b>
        <b class="calibre12">(ElementColor::BLACK == color ? MF_CHECKED : MF_UNCHECKED)| MF_BYCOMMAND);</b>
    <b class="calibre12">menu.CheckMenuItem(ID_COLOR_RED,</b>
          <b class="calibre12">(ElementColor::RED == color ? MF_CHECKED : MF_UNCHECKED)| MF_BYCOMMAND);</b>
    <b class="calibre12">menu.CheckMenuItem(ID_COLOR_GREEN,</b>
        <b class="calibre12">(ElementColor::GREEN == color ? MF_CHECKED : MF_UNCHECKED)| MF_BYCOMMAND);</b>
    <b class="calibre12">menu.CheckMenuItem(ID_COLOR_BLUE,</b>
         <b class="calibre12">(ElementColor::BLUE == color ? MF_CHECKED : MF_UNCHECKED)| MF_BYCOMMAND);</b>

    <b class="calibre12">// Check element menu items</b>
    <b class="calibre12">ElementType type {GetDocument()-&gt;GetElementType()};</b>
    <b class="calibre12">menu.CheckMenuItem(ID_ELEMENT_LINE,</b>
          <b class="calibre12">(ElementType::LINE == type ? MF_CHECKED : MF_UNCHECKED) | MF_BYCOMMAND);</b>
    <b class="calibre12">menu.CheckMenuItem(ID_ELEMENT_RECTANGLE,</b>
      <b class="calibre12">(ElementType::RECTANGLE == type? MF_CHECKED : MF_UNCHECKED) | MF_BYCOMMAND);</b>
    <b class="calibre12">menu.CheckMenuItem(ID_ELEMENT_CIRCLE,</b>
         <b class="calibre12">(ElementType::CIRCLE == type? MF_CHECKED : MF_UNCHECKED) | MF_BYCOMMAND);</b>
    <b class="calibre12">menu.CheckMenuItem(ID_ELEMENT_CURVE,</b>
         <b class="calibre12">(ElementType::CURVE == type? MF_CHECKED : MF_UNCHECKED) | MF_BYCOMMAND);</b>  
  }   
  <b class="calibre12">ASSERT(pContext != nullptr);                  // Ensure it</b>'<b class="calibre12">s there</b>

  <b class="calibre12">pContext-&gt;TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,</b>
                                                <b class="calibre12">point.x, point.y, this);</b>
}</code></pre>
<p class="calibre13">That’s the context menu finished. You need to identify when an element is under the cursor next.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-358" class="calibre3"></a>IDENTIFYING AN ELEMENT UNDER THE CURSOR</h2>
<p class="calibre13">It will be a very simple mechanism for identifying the element under the mouse cursor. A sketch element will be under the cursor whenever the cursor is within the enclosing rectangle for the element. For this to be effective, Sketcher must track whether or not there is an element under the cursor at all times.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="731" id="calibre_link-1193" class="calibre14"></span>You can add code to the <code class="calibre23">OnMouseMove()</code> handler in the <code class="calibre23">CSketcherView</code> class to determine which element is under the cursor. This handler is called every time the mouse cursor moves, so all you have to do is add code to determine whether there’s an element under the current cursor position and set <code class="calibre23">m_pSelected</code> accordingly. The test for whether a particular element is under the cursor is simple: if the cursor position is inside the enclosing rectangle for an element, that element is under the cursor. Here’s how you can modify the <code class="calibre23">OnMouseMove()</code> handler to determine whether there’s an element under the cursor:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  // Define a Device Context object for the view
  CClientDC aDC {this};              // DC is for this view
  OnPrepareDC(&amp;aDC);                 // Get origin adjusted
  aDC.DPtoLP(&amp;point);                // Convert point to logical coordinates
 
  // Verify the left button is down and mouse messages captured
  if((nFlags &amp; MK_LBUTTON) &amp;&amp; (this == GetCapture()))
  {
    // Code as before...
  }
  <b class="calibre12">else</b>
  <b class="calibre12">{ // We are not creating an element, so select an element</b>
    <b class="calibre12">m_pSelected = GetDocument()-&gt;FindElement(point);</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">The new code is one statement that is executed only when you are not creating a new element. The <code class="calibre23">else</code> clause calls the <code class="calibre23">FindElement()</code> function for the document object that you’ll add shortly and stores the smart pointer that is returned in <code class="calibre23">m_pSelected</code>. The <code class="calibre23">FindElement()</code> function has to search the document for the first element that has an enclosing rectangle that encloses <code class="calibre23">point</code>. You can add <code class="calibre23">FindElement()</code> to the <code class="calibre23">CSketcherDoc</code> class definition as a <code class="calibre23">public</code> member and implement it like this:</p>
<pre class="calibre28"><code class="calibre23">// Finds the element under the point
std::shared_ptr&lt;CElement&gt; FindElement(const CPoint&amp; point)const
{
  for(const auto&amp; pElement : m_Sketch)
  {
    if(pElement-&gt;GetEnclosingRect().PtInRect(point))
      return pElement;
  }
  return nullptr;
}</code></pre>
<p class="calibre13">You use a range-based <code class="calibre23">for</code> loop to search the list from the beginning. Because elements are added to the back of the list, the most recently created element will be tested last. The <code class="calibre23">GetEnclosingRect()</code> member of a sketch element object returns its enclosing rectangle. The <code class="calibre23">PtInRect()</code> member of the <code class="calibre23">CRect</code> class returns <code class="calibre23">TRUE</code> if the point you pass as the argument lies within the rectangle, and <code class="calibre23">FALSE</code> otherwise. You use this function to test whether or not <code class="calibre23">point</code> lies within any enclosing rectangle for a sketch element. The function returns the address of the first element for which this is true, or <code class="calibre23">nullptr</code> if no element in the sketch is found. You can now test the context menus.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="732" id="calibre_link-1194" class="calibre24"></span>Exercising the Context Menus</h3>
<p class="calibre13">You have added all the code you need to make the context menus operate, so you can build and execute Sketcher to try them out. When you right-click the mouse a context menu will be displayed. If there are no elements under the cursor, the second context pop-up appears, enabling you to change the element type and color. These options work because they generate exactly the same messages as the main menu options for which you have already written handlers.</p>
<p class="calibre13">If there is an element under the cursor, the first context menu will appear with Move and Delete on it. It won’t do anything at the moment, as you’ve yet to implement the handlers for the messages. Try right-button clicks outside the view window. Messages for these are not passed to the view window in your application, so the pop-up is not displayed.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Highlighting Elements</h3>
<p class="calibre13">Ideally, the user will want to know which element is under the cursor <i class="calibre15">before</i> right-clicking to get the context menu. When you intend to delete an element, you want to be sure which element you are operating on. If there are concentric circles displayed, only one will be selected but you won’t know which. Equally, when you want to use the other context menu &mdash; to change the drawing color for example &mdash; you must be sure no element is under the cursor when you right-click the mouse, otherwise you’ll get the Move/Delete menu displayed. To show which element is under the cursor, you need to highlight it in some way before a right-button click occurs.</p>
<p class="calibre13">You can change the <code class="calibre23">Draw()</code> member function for each element type to accommodate this. You can pass an extra argument to the <code class="calibre23">Draw()</code> function to indicate when the element should be highlighted. If you pass the address of the currently selected element that you save in the <code class="calibre23">m_pSelected</code> member of the view to the <code class="calibre23">Draw()</code> function for an element, you can pass it on to the <code class="calibre23">CreatePen()</code> function, which can compare it to the <code class="calibre23">this</code> pointer to decide the color of the pen.</p>
<p class="calibre13">Highlighting will work in the same way for all element types, so let’s take the <code class="calibre23">CLine</code> member as an example. You can add similar code to each of the classes for the other element types. Before you start changing <code class="calibre23">CLine</code>, you must first amend the definition of the base class <code class="calibre23">CElement</code>:</p>
<pre class="calibre28"><code class="calibre23"> 
<b class="calibre12">static const COLORREF SELECT_COLOR{RGB(255,0,180)};    // Highlight color</b>
 
class CElement : public CObject
{
protected:
  CPoint m_StartPoint;                           // Element position      
  int m_PenWidth;                                // Pen width
  COLORREF m_Color;                              // Color of an element
  CRect m_EnclosingRect;                         // Rectangle enclosing an element

 
public:
  virtual ~CElement();
  <b class="calibre12">// Virtual draw operation</b>
  <b class="calibre12">virtual void Draw(CDC* pDC, std::shared_ptr&lt;CElement&gt; pElement=nullptr) {}</b> 
 
  // Get the element enclosing rectangle 
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="733" id="calibre_link-1195" class="calibre14"></span>const CRect&amp; GetEnclosingRect() const 
  {
    return m_EnclosingRect;
  }
 
protected:
  // Constructors protected so they cannot be called outside the class
  CElement();              
  CElement(const CPoint&amp; start, COLORREF color, int penWidth = 1);
 
  // Create a pen
  <b class="calibre12">void CreatePen(CPen&amp; aPen, std::shared_ptr&lt;CElement&gt; pElement)</b>
  {
    <b class="calibre12">if(!aPen.CreatePen(PS_SOLID, m_PenWidth,</b>
     <b class="calibre12">this == pElement.get() ? SELECT_COLOR : m_Color))</b>
    {
      // Pen creation failed
      AfxMessageBox(_T("Pen creation failed"), MB_OK);
      AfxAbort();
    }
  }
};</code></pre>
<p class="calibre13">You need an <code class="calibre23">#include</code> directive for the <code class="calibre23">memory</code> header in <code class="calibre23">Element.h. SELECT_COLOR</code> is the highlight color for all elements and this is a static constant that is defined and initialized at a global scope. A second parameter has been added to the virtual <code class="calibre23">Draw()</code> function. This is a pointer to an element and it will be used when an element is to be highlighted because it is under the mouse cursor. With the second parameter initialized to <code class="calibre23">nullptr</code>, the function can still be called with just one argument; the second argument will be <code class="calibre23">nullptr</code> by default.</p>
<p class="calibre13">The <code class="calibre23">CreatePen()</code> function also has an additional argument that is a pointer to an element. When <code class="calibre23">pElement</code> contains the address of the current element, the pen is created using the highlight color.</p>
<p class="calibre13">You need to modify the declaration of the <code class="calibre23">Draw()</code> function in each of the definitions for the classes derived from <code class="calibre23">CElement</code> in exactly the same way. For example, you should change the <code class="calibre23">CLine</code> class definition to:</p>
<pre class="calibre28"><code class="calibre23">class CLine :
  public CElement
{
public:
  virtual ~CLine(void); 
  <b class="calibre12">// Function to display a line</b>
  <b class="calibre12">virtual void Draw(CDC* pDC, std::shared_ptr&lt;CElement&gt; pElement=nullptr)</b>
                                                                     <b class="calibre12">override;</b>
 
      // Rest of the class as before...
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="734" id="calibre_link-1196" class="calibre14"></span>The implementations for the <code class="calibre23">Draw()</code> functions for the derived classes also need to be extended in the same way. For the <code class="calibre23">CLine</code> class it is:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">void CLine::Draw(CDC* pDC, std::shared_ptr&lt;CElement&gt; pElement)</b>
{
  // Create a pen for this object and initialize it
  CPen aPen;
  <b class="calibre12">CreatePen(aPen, pElement);</b>
 
  // Rest of the function body as before...
}</code></pre>
<p class="calibre13">This is a very simple change. The second argument to the <code class="calibre23">CreatePen()</code> function call is the <code class="calibre23">pElement</code> smart pointer that is passed as the second argument to the <code class="calibre23">Draw()</code> function.</p>
<p class="calibre13">You have nearly implemented element highlighting. The derived classes of the <code class="calibre23">CElement</code> class are now able to draw themselves as highlighted when required &mdash; you just need a mechanism to cause an element to <i class="calibre15">be</i> selected. So where should you create this? You can determine which element, if any, is under the cursor in the <code class="calibre23">OnMouseMove()</code> handler in the <code class="calibre23">CSketcherView</code> class, so that’s obviously the place to expedite the highlighting.</p>
<p class="calibre13">The amendments to the <code class="calibre23">OnMouseMove()</code> handler are as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  // Define a Device Context object for the view
  CClientDC aDC {this};                    // DC is for this view
  OnPrepareDC(&amp;aDC);                       // Get origin adjusted
  aDC.DPtoLP(&amp;point);                      // Convert point to logical coordinates
 
  // Verify the left button is down and mouse messages captured
  if((nFlags &amp; MK_LBUTTON) &amp;&amp; (this == GetCapture()))
  {
    // Code as before...
  }
  else
  <b class="calibre12">{ // We are not creating an element, so do highlighting</b>
    <b class="calibre12">auto pOldSelected = mp_Selected;                   // Copy previous</b>
    <b class="calibre12">m_pSelected = GetDocument()-&gt;FindElement(point);</b>
    <b class="calibre12">if(m_pSelected != pOldSelected)</b>
    <b class="calibre12">{</b>
      <b class="calibre12">if(m_pSelected)</b>
        <b class="calibre12">GetDocument()-&gt;UpdateAllViews(nullptr, 0, m_pSelected.get());</b>
      <b class="calibre12">if(pOldSelected)</b>
        <b class="calibre12">GetDocument()-&gt;UpdateAllViews(nullptr, 0, pOldSelected.get());</b>
    <b class="calibre12">}</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">You must keep track of any previously highlighted element before you store the address of a new one. If there’s a new element to be highlighted, you must un-highlight the old one. To do this, <span {http://www.idpf.org/2007/ops}type="pagebreak" title="735" id="calibre_link-1197" class="calibre14"></span>you save a copy of <code class="calibre23">m_pSelected</code> in <code class="calibre23">pOldSelected</code> before you check for a selected element. You then store the smart pointer returned by the <code class="calibre23">FindElement()</code> function for the document object in <code class="calibre23">m_pSelected</code>.</p>
<p class="calibre13">If <code class="calibre23">pOldSelected</code> and <code class="calibre23">m_pSelected</code> are equal, then either they both contain the address of the same element or they are both <code class="calibre23">nullptr</code>. If they both contain a valid address, the element will already have been highlighted last time around. If they are both <code class="calibre23">nullptr</code>, nothing is highlighted and nothing needs to be done. Thus, in either case, you do nothing.</p>
<p class="calibre13">Thus, you want to do something only when <code class="calibre23">m_pSelected</code> is not equal to <code class="calibre23">pOldSelected</code>. If <code class="calibre23">m_pSelected</code> is not <code class="calibre23">nullptr</code>, you need to get it redrawn, so you call <code class="calibre23">UpdateAllViews()</code> with the first argument as <code class="calibre23">nullptr</code> to get all views updated, and the third argument as <code class="calibre23">m_pSelected.get()</code>identify the region to be updated. If <code class="calibre23">pOldSelected</code> is also not <code class="calibre23">nullptr</code>, you must un-highlight the old element by updating its area in the same way. The updating of each view will be done by its <code class="calibre23">OnUpdate()</code> member, which will invalidate the rectangle enclosing the element. Only the currently active view will have element highlighting active.</p>
<section class="toclist">
<h4 class="calibre22">Drawing Highlighted Elements</h4>
<p class="calibre13">You still need to arrange that the highlighted element is actually drawn highlighted. Somewhere, the <code class="calibre23">m_pSelected</code> pointer must be passed to the draw function for each element. The only place to do this is in the <code class="calibre23">OnDraw()</code> function for the view object:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnDraw(CDC* pDC)
{
  CSketcherDoc* pDoc = GetDocument();
  ASSERT_VALID(pDoc);
  if (!pDoc)
    return;
        
  // Draw the sketch
  for (const auto&amp; pElement : *pDoc)
  {
    if (pDC-&gt;RectVisible(pElement-&gt;GetEnclosingRect())) // Element visible?
      <b class="calibre12">pElement-&gt;Draw(pDC, m_pSelected);                 // Yes, draw it.</b>
  }
}</code></pre>
<p class="calibre13">You need to change only one line. The second argument to the <code class="calibre23">Draw()</code> function call for an element is the address of the element to be highlighted.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Exercising the Highlights</h4>
<p class="calibre13">This is all that’s required for the highlighting to work all the time. It wasn’t trivial but, on the other hand, it wasn’t terribly difficult. You can build and execute Sketcher to try it out. Any time there is an element under the cursor, the element is drawn in magenta. This makes it obvious which element the context menu is going to act on before you right-click the mouse, and means that you know in advance which context menu will be displayed.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="736" id="calibre_link-1198" class="calibre24"></span>Implementing Move and Delete</h3>
<p class="calibre13">The next step is to provide code in the bodies of the handlers in the view class for the Move and Delete menu items that you added earlier. You can add the code for Delete first because that’s the simpler of the two.</p>
<section class="toclist">
<h4 class="calibre22">Deleting an Element</h4>
<p class="calibre13">The code that you need in the <code class="calibre23">OnElementDelete()</code> handler in the <code class="calibre23">CSketcherView</code> class to delete the currently selected element is simple:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnElementDelete()
{
  <b class="calibre12">if(m_pSelected)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">GetDocument()-&gt;DeleteElement(m_pSelected);         // Delete the element</b>
    <b class="calibre12">m_pSelected.reset();</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">The code to delete an element is executed only if <code class="calibre23">m_pSelected</code> is not <code class="calibre23">nullptr</code>, indicating that there is an element to be deleted. You get a pointer to the document and call the function <code class="calibre23">DeleteElement()</code> for the document object. You have already added this function to <code class="calibre23">CSketcherDoc</code>. When the element has been removed from the document, you call <code class="calibre23">reset()</code> for the smart pointer to change its pointer to <code class="calibre23">nullptr</code>.</p>
<p class="calibre13">That’s all you need in order to delete elements. You should now have a Sketcher program in which you can draw in multiple scrolled views, and delete any of the elements in your sketch from any of the views.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Moving an Element</h4>
<p class="calibre13">Moving the selected element is a bit more involved. The element should move along with the mouse cursor, so you need to add code to the <code class="calibre23">OnMouseMove()</code> method to provide for this behavior. Because this message handler is also used to draw elements, you need a mechanism for indicating when you’re in “move” mode. The easiest way to do this is to have a flag in the view class, which you can call <code class="calibre23">m_MoveMode</code>. You can define it as type <code class="calibre23">bool</code>, with the value <code class="calibre23">false</code> indicating that move mode is not in effect.</p>
<p class="calibre13">You’ll also have to keep track of the cursor during the move, so you can add another data member in the view class for this. You can call it <code class="calibre23">m_CursorPos</code>, and it will be of type <code class="calibre23">CPoint</code>. Another thing you should provide for is the possibility of aborting a move. For this you must remember the position of the cursor when the move operation started, so you can move the element back when necessary. This is another member of type <code class="calibre23">CPoint</code>, and it is called <code class="calibre23">m_FirstPos</code>. Add the three new members to the <code class="calibre23">protected</code> section of the view class:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="737" id="calibre_link-1199" class="calibre14"></span>class CSketcherView: public CScrollView
{
  // Rest of the class as before...
        
protected:
  CPoint m_FirstPoint;         // First point recorded for an element
  CPoint m_SecondPoint;        // Second point recorded for an element
  <b class="calibre12">CPoint m_CursorPos;          // Cursor position</b>
  <b class="calibre12">CPoint m_FirstPos;           // Original position in a move</b>
  std::shared_ptr&lt;CElement&gt; m_pTempElement;
  std::shared_ptr&lt;CElement&gt; m_pSelected;    // Records element under the cursor
  <b class="calibre12">bool m_MoveMode {false};     // Move element flag</b>
 
// Rest of the class as before...
};</code></pre>
<p class="calibre13">The element move process starts when the Move menu item from the context menu is selected. You can add the code to the message handler for the Move menu item to set up the conditions necessary for the operation:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnElementMove()
{
   <b class="calibre12">CClientDC aDC {this};</b>
   <b class="calibre12">OnPrepareDC(&amp;aDC);              // Set up the device context</b>
   <b class="calibre12">GetCursorPos(&amp;m_CursorPos);     // Get cursor position in screen coords</b>
   <b class="calibre12">ScreenToClient(&amp;m_CursorPos);   // Convert to client coords</b>
   <b class="calibre12">aDC.DPtoLP(&amp;m_CursorPos);       // Convert to logical</b>
   <b class="calibre12">m_FirstPos = m_CursorPos;       // Remember first position</b>
   <b class="calibre12">m_MoveMode = true;              // Start move mode</b>
}</code></pre>
<p class="calibre13">You are doing four things in this handler:</p>
<ol class="calibre5">
<li class="calibre6">You get the coordinates of the current mouse cursor position because the move operation starts from this reference point.</li>
<li class="calibre6">You convert the cursor position to logical coordinates because your elements are defined in logical coordinates.</li>
<li class="calibre6">You record the initial cursor position in case the user wants to abort the move later.</li>
<li class="calibre6">You set m_MoveMode to true. This is a flag for the OnMouseMove() handler to recognize move mode.</li>
</ol>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="738" id="calibre_link-1200" class="calibre14"></span>The <code class="calibre23">GetCursorPos()</code> function is a Windows API function that stores the current cursor position in <code class="calibre23">m_CursorPos</code>. Note that you pass a pointer to this function. The cursor position is in screen coordinates (i.e., coordinates measured in pixels relative to the upper-left corner of the screen). All operations with the mouse cursor are in screen coordinates. You want the cursor position in logical coordinates, so you must do the conversion in two steps. The <code class="calibre23">ScreenToClient()</code> function is inherited from <code class="calibre23">CWnd</code> in the view class. It converts a <code class="calibre23">CPoint</code> or <code class="calibre23">CRect</code> argument from screen to client coordinates. You apply the <code class="calibre23">DPtoLP()</code> function member of the <code class="calibre23">aDC</code> object to <code class="calibre23">m_CursorPos</code>, which is now in client coordinates, to convert it to logical coordinates. Now that you have set the move mode flag, you can update the mouse move message handler to deal with moving an element.</p>
<section class="toclist">
<h5 class="calibre27">Modifying the WM_MOUSEMOVE Handler to Move an Element</h5>
<p class="calibre13">Moving an element only occurs when move mode is on and the cursor is being moved. Therefore, all you need in <code class="calibre23">OnMouseMove()</code> is a block of code to handle moving an element that gets executed only when <code class="calibre23">m_MoveMode</code> is <code class="calibre23">true</code>. The new code to do this is as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnMouseMove(UINT nFlags, CPoint point)
{
  CClientDC aDC {this};              // DC is for this view
  OnPrepareDC(&amp;aDC);                 // Get origin adjusted
        
  aDC.DPtoLP(&amp;point);                // Convert point to logical coordinates
 
  <b class="calibre12">// If we are in move mode, move the selected element</b>
  <b class="calibre12">if(m_MoveMode)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">MoveElement(aDC, point);         // Move the element</b>
  <b class="calibre12">}</b>
  <b class="calibre12">else if((nFlags &amp; MK_LBUTTON) &amp;&amp; (this == GetCapture()))</b>  
  {
   // Rest of the mouse move handler as before...
  }
}</code></pre>
<p class="calibre13">This addition doesn’t need much explaining, really, does it? When <code class="calibre23">m_MoveMode</code> is true you’re in move mode so you call the <code class="calibre23">MoveElement()</code> function that does what is necessary for the move. If <code class="calibre23">m_MoveMode</code> is <code class="calibre23">false</code>, everything continues as before. All you have to do now is implement <code class="calibre23">MoveElement()</code>.</p>
<p class="calibre13">Add the declaration for <code class="calibre23">MoveElement()</code> as a <code class="calibre23">protected</code> member of <code class="calibre23">CSketcherView</code> by adding the following at the appropriate point in the class definition:</p>
<pre class="calibre28"><code class="calibre23">  void MoveElement(CClientDC&amp; aDC, const CPoint&amp; point); // Move an element</code></pre>
<p class="calibre13">As always, you can also right-click the class name in Class View to do this. The function needs access to the device context object for the view, <code class="calibre23">aDC</code>, and the current cursor position, <code class="calibre23">point</code>, so both of these are reference parameters. The basic implementation of the function in the <code class="calibre23">SketcherView.cpp</code> file is:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="739" id="calibre_link-1201" class="calibre14"></span>void CSketcherView::MoveElement(CClientDC&amp; aDC, const CPoint&amp; point)
{
  CSize distance {point - m_CursorPos};   // Get move distance
  m_CursorPos = point;                    // Set current point as 1st for
                                          // next time
        
  // If there is an element selected, move it
  if(m_pSelected)
  {
    aDC.SetROP2(R2_NOTXORPEN);
    m_pSelected-&gt;Draw(&amp;aDC, m_pSelected); // Draw element to erase it
    m_pSelected-&gt;Move(distance);          // Now move the element
    m_pSelected-&gt;Draw(&amp;aDC, m_pSelected); // Draw the moved element
  }
}</code></pre>
<p class="calibre13">The distance to move the element that is currently selected is stored locally as a <code class="calibre23">CSize</code> object, <code class="calibre23">distance</code>. The <code class="calibre23">CSize</code> class is designed to represent a relative coordinate position and has two public data members, <code class="calibre23">cx</code> and <code class="calibre23">cy</code>, which correspond to <i class="calibre15">x</i> and <i class="calibre15">y</i> increments. These are calculated as the difference between the current cursor position, stored in <code class="calibre23">point</code>, and the previous cursor position, saved in <code class="calibre23">m_CursorPos</code>. This uses the subtraction operator, which is overloaded in the <code class="calibre23">CPoint</code> class. The version you are using here returns a <code class="calibre23">CSize</code> object, but there is also a version that returns a <code class="calibre23">CPoint</code> object. You can usually operate on <code class="calibre23">CSize</code> and <code class="calibre23">CPoint</code> objects combined. You save the current cursor position in <code class="calibre23">m_CursorPos</code> for use the next time this function is called, which occurs if there is a further mouse move message during the current move operation.</p>
<p class="calibre13">You implement moving an element in the view using the <code class="calibre23">R2_NOTXORPEN</code> drawing mode, because it’s easy and fast. This is exactly the same as what you have been using during the creation of an element. You call <code class="calibre23">Draw()</code> for the selected element in its current color (<code class="calibre23">SELECT_COLOR</code> because it is selected) to reset it to the background color, and then call the <code class="calibre23">Move()</code> member of the element object to relocate it by the distance specified by <code class="calibre23">distance</code>. You’ll add this function to the element classes in a moment. When the element has moved itself, you call its <code class="calibre23">Draw()</code> function once more to display it highlighted at the new position. The color of the element will revert to normal when the move operation ends, because the <code class="calibre23">OnLButtonUp()</code> handler will redraw all the views normally.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Updating Other Views</h4>
<p class="calibre13">There’s something we must not overlook. The view in which you are moving an element may not be the only view. If there are other views, then the element should move in those too. You can call <code class="calibre23">UpdateAllViews()</code> for the document object in <code class="calibre23">MoveElement()</code> and pass <code class="calibre23">this</code> as the first argument so that it doesn’t update the current view. You need to do this before and after you move an element. Here’s how that looks:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::MoveElement(CClientDC&amp; aDC, const CPoint&amp; point)
{
  CSize distance {point - m_CursorPos};   // Get move distance
  m_CursorPos = point;                    // Set current point as 1st for
                                          // next time
        
  // If there is an element selected, move it
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="740" id="calibre_link-1202" class="calibre14"></span>if(m_pSelected)
  {
    <b class="calibre12">CSketcherDoc* pDoc {GetDocument()};                // Get the document pointer</b>

    <b class="calibre12">pDoc-&gt;UpdateAllViews(this, 0L, m_pSelected.get()); // Update all except this</b>
 
    aDC.SetROP2(R2_NOTXORPEN);
    m_pSelected-&gt;Draw(&amp;aDC, m_pSelected);              // Draw element to erase it
    m_pSelected-&gt;Move(distance);                       // Now move the element
    m_pSelected-&gt;Draw(&amp;aDC, m_pSelected);              // Draw the moved element
 
    <b class="calibre12">pDoc-&gt;UpdateAllViews(this, 0 , m_pSelected.get()); // Update all except this</b>
  }
}</code></pre>
<p class="calibre13">By passing <code class="calibre23">m_pSelected</code> as the third argument to <code class="calibre23">UpdateAllViews()</code>, only the region occupied by the element pointed to will be redrawn. The first call to <code class="calibre23">UpdateAllViews()</code> invalidates the area occupied by the element before the move in each of the other views. The second call invalidates the area after the move.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Getting the Elements to Move Themselves</h4>
<p class="calibre13">Add the <code class="calibre23">Move()</code> function as a virtual member of the base class, <code class="calibre23">CElement</code>. Modify the class definition to the following:</p>
<pre class="calibre28"><code class="calibre23">class CElement : public CObject
{
protected:
  CPoint m_StartPoint;                           // Element position      
  int m_PenWidth;                                // Pen width
  COLORREF m_Color;                              // Color of an element
  CRect m_EnclosingRect;                         // Rectangle enclosing an element
 
public:
  virtual ~CElement();
  virtual void Draw(CDC* pDC, std::shared_ptr&lt;CElement&gt; pElement=nullptr) {} 
  <b class="calibre12">virtual void Move(const CSize&amp; aSize){}        // Move an element</b>
        
  // Rest of the class as before...
        
};</code></pre>
<p class="calibre13">As I discussed earlier in relation to the <code class="calibre23">Draw()</code> member, although an implementation of <code class="calibre23">Move()</code> has no meaning here, you can’t make it a pure virtual function because of the requirements of serialization.</p>
<p class="calibre13">You can now add a declaration for the <code class="calibre23">Move()</code> function as a <code class="calibre23">public</code> member of each of the classes derived from <code class="calibre23">CElement</code>. It is the same in each:</p>
<pre class="calibre28"><code class="calibre23">  virtual void Move(const CSize&amp; aSize) override; // Function to move an element</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="741" id="calibre_link-1203" class="calibre14"></span>Next, you can add the implementation of <code class="calibre23">Move()</code> for the <code class="calibre23">CLine</code> class to <code class="calibre23">Line.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">void CLine::Move(const CSize&amp; aSize)
{
  m_StartPoint += aSize;               // Move the start point
  m_EndPoint += aSize;                 // and the end point
  m_EnclosingRect += aSize;            // Move the enclosing rectangle
}</code></pre>
<p class="calibre13">The overloaded <code class="calibre23">+=</code> operators in the <code class="calibre23">CPoint</code> and <code class="calibre23">CRect</code> classes make this easy. They all work with <code class="calibre23">CSize</code> objects, so you just add the relative distance specified by <code class="calibre23">aSize</code> to the start and end points for the line and to the enclosing rectangle.</p>
<p class="calibre13">Moving a <code class="calibre23">CRectangle</code> object is just as easy:</p>
<pre class="calibre28"><code class="calibre23">void CRectangle::Move(const CSize&amp; aSize)
{
  m_StartPoint += aSize;               // Move the start point
  m_BottomRight += aSize;              // Move the bottom right point
  m_EnclosingRect += aSize;            // Move the enclosing rectangle
}</code></pre>
<p class="calibre13">Because the rectangle is defined by the opposite corner points, the code to move it is essentially the same as that for moving a line.</p>
<p class="calibre13">The <code class="calibre23">Move()</code> member of the <code class="calibre23">CCircle</code> class is identical:</p>
<pre class="calibre28"><code class="calibre23">void CCircle::Move(const CSize&amp; aSize)
{
  m_StartPoint += aSize;               // Move the start point
  m_BottomRight += aSize;              // Move the bottom right point
  m_EnclosingRect += aSize;             // Move the enclosing rectangle
}</code></pre>
<p class="calibre13">Moving a <code class="calibre23">CCurve</code> object is a little more complicated, because it’s defined by an arbitrary number of points. You can implement the function as:</p>
<pre class="calibre28"><code class="calibre23">void CCurve::Move(const CSize&amp; aSize)
{
  m_EnclosingRect += aSize;            // Move the rectangle
  m_StartPoint += aSize;               // Move the start point
  // Now move all the other points
  for(auto&amp; p : m_Points)
    p += aSize;
}</code></pre>
<p class="calibre13">There’s still not a lot to it. You first move the enclosing rectangle stored in <code class="calibre23">m_EnclosingRect</code>, using the overloaded <code class="calibre23">+=</code> operator for <code class="calibre23">CRect</code> objects. You then move the first point. You move the remaining points by using a range-based <code class="calibre23">for</code> loop to iterate over the points in the <code class="calibre23">m_Points</code> vector.</p>
</section>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="742" id="calibre_link-1204" class="calibre14"></span>Dropping the Element</h4>
<p class="calibre13">Once you have clicked on the Move menu item, the element under the cursor will move around as you move the mouse. All that remains is to add the capability to drop the element in position once the user has finished moving it, or to abort the whole move. To drop the element in its new position, the user will click the left mouse button, so you can manage this operation in the <code class="calibre23">OnLButtonDown()</code> handler. To abort the operation, the user will click the right mouse button &mdash; so you can add the code to the <code class="calibre23">OnRButtonDown()</code> handler to deal with this.</p>
<p class="calibre13">You can take care of dropping the element in <code class="calibre23">OnLButtonDown()</code> first. You’ll have to provide for this as a special action when move mode is on. The changes are highlighted:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
  CClientDC aDC {this};                // Create a device context
  OnPrepareDC(&amp;aDC);                   // Get origin adjusted
  aDC.DPtoLP(&amp;point);                  // convert point to logical coordinates
        
  <b class="calibre12">if(m_MoveMode)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">// In moving mode, so drop the element</b>
    <b class="calibre12">m_MoveMode = false;                // Kill move mode</b>
    <b class="calibre12">auto pElement(m_pSelected);        // Store selected address</b>
    <b class="calibre12">m_pSelected.reset();               // De-select the element</b>
    <b class="calibre12">GetDocument()-&gt;UpdateAllViews(nullptr, 0,</b>
                                      <b class="calibre12">pElement.get());  // Redraw all the views</b>
  <b class="calibre12">}</b>
  <b class="calibre12">else</b>
  <b class="calibre12">{</b>
    m_FirstPoint = point;              // Record the cursor position
    SetCapture();                      // Capture subsequent mouse messages
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">The code is pretty simple. You first check for move mode. If this is the case, you just set the move mode flag back to <code class="calibre23">false</code>. You save the address of the selected element in a local pointer because you want to use it to identify the area to be redrawn in the views. You then deselect the element and call the document’s <code class="calibre23">UpdateAllViews()</code> function, causing all the views to be redrawn. This is all that’s required because you’ve been moving the element along with the mouse cursor, so it’s already in the right place.</p>
<p class="calibre13">Add a handler for the <code class="calibre23">WM_RBUTTONDOWN</code> message to <code class="calibre23">CSketcherView</code> using the Properties window for the class. The implementation for aborting a move must do two things. It must move the element back to where it was and turn off move mode. You can move the element back in the right-button-down handler, but you must leave switching off move mode to the right-button-up handler to allow the context menu to be suppressed. The code to move the element back is as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnRButtonDown(UINT nFlags, CPoint point)
{
   <b class="calibre12">if(m_MoveMode)</b>
   <b class="calibre12">{</b>
     <b class="calibre12">// In moving mode, so drop element back in original position</b>
     <span {http://www.idpf.org/2007/ops}type="pagebreak" title="743" id="calibre_link-1205" class="calibre14"></span><b class="calibre12">CClientDC aDC {this};</b>
     <b class="calibre12">OnPrepareDC(&amp;aDC);                      // Get origin adjusted</b>
     <b class="calibre12">MoveElement(aDC, m_FirstPos);           // Move element to original position</b>
     <b class="calibre12">m_pSelected.reset();                    // De-select element</b>
     <b class="calibre12">GetDocument()-&gt;UpdateAllViews(nullptr); // Redraw all the views</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">You first create a <code class="calibre23">CClientDC</code> object for use in the <code class="calibre23">MoveElement()</code> function. You then call the <code class="calibre23">MoveElement()</code> function to move the currently selected element the distance from the current cursor position to the original cursor position that we saved in <code class="calibre23">m_FirstPos</code>. After the element has been repositioned, you just deselect the element and get all the views redrawn.</p>
<p class="calibre13">The last thing you must do is switch off move mode in the right-button-up handler so add it and implement it like this:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnRButtonUp(UINT nFlags, CPoint point)
{
  <b class="calibre12">if(m_MoveMode)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">m_MoveMode = false;</b>
  <b class="calibre12">}</b>
  <b class="calibre12">else</b>
  <b class="calibre12">{</b>
      <b class="calibre12">CScrollView::OnRButtonUp(nFlags, point);</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">This switches move mode off if it is on. The default handler was calling the <code class="calibre23">OnContextMenu()</code> handler every time. Now the context menu gets displayed only when it is not move mode.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Exercising the Application</h4>
<p class="calibre13">Everything is now complete for the context pop-ups to work. If you build Sketcher, you can select the element type and color from the context menu when the cursor is not over an element. When it is over an element, you can move or delete that element using the other context menu.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-359" class="calibre3"></a>DEALING WITH MASKED ELEMENTS</h2>
<p class="calibre13">There’s still a limitation that you ought to overcome. If the element you want to move or delete is enclosed by the bounding rectangle of another element that is drawn earlier in sequence, you won’t be able to highlight it because Sketcher always finds the older element first. The older element completely masks the element it encloses. This is a result of the sequence of elements in the list. You add new elements to the back so the elements are ordered in the list from oldest to newest. You could fix this by adding a Send to Back item to the context menu that would move an element to the end of the list.</p>
<p class="calibre13">Add a separator and a menu item to the element menu in the <code class="calibre23">IDR_CONTEXT_MENU</code> resource, as shown in <a id="calibre_link-19" href="#calibre_link-18" class="calibre3">Figure 15-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000147.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-18" href="#calibre_link-19" class="calibre3">FIGURE 15-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="744" id="calibre_link-1206" class="calibre14"></span>The default ID will be <code class="calibre23">ID_ELEMENT_SENDTOBACK</code>, which is fine. You can try a different technique to add the message handler for the new item. You can add the handler for the item to the view class through the Properties window for the <code class="calibre23">CSketcherView</code> class. It’s best to handle it in the view because that’s where you record the selected element. Select the Events toolbar button in the Properties window for the class and double-click the message ID <code class="calibre23">ID_ELEMENT_SENDTOBACK</code>. You’ll then be able to select <code class="calibre23">COMMAND</code> and <code class="calibre23">&lt;Add&gt;OnElementSendtoback</code> in the right column. You can implement the handler as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnElementSendtoback() 
{
  <b class="calibre12">GetDocument()-&gt;SendToBack(m_pSelected);  // Move element to end of list</b>
}</code></pre>
<p class="calibre13">You’ll get the document to do the work by passing the currently selected element pointer to a <code class="calibre23">public</code> function, <code class="calibre23">SendToBack()</code>, that you will implement in the <code class="calibre23">CSketcherDoc</code> class. Add it to the class definition with a <code class="calibre23">void</code> return type and a parameter of type <code class="calibre23">shared_ptr&lt;CElement&gt;&amp;</code>. You can implement this function within the class definition as:</p>
<pre class="calibre28"><code class="calibre23">void SendToBack(std::shared_ptr&lt;<code class="calibre23">CElement&gt;&amp;</code> pElement)
{
  if(pElement)
  {
    m_Sketch.remove(pElement);             // Remove the element from the list
    m_Sketch.push_back(pElement);          // Put it back at the end of the list
  }
}</code></pre>
<p class="calibre13">After checking that the parameter is not <code class="calibre23">nullptr</code>, you remove the element from the list by calling <code class="calibre23">remove()</code>. You add the smart pointer back at the end of the list, using the <code class="calibre23">push_back()</code> function.</p>
<p class="calibre13">With the element moved to the end of the list, it cannot mask any of the others because you search for an element to highlight from the beginning. You will always find one of the other elements first if the applicable enclosing rectangle contains the current cursor position. The Send to Back menu option can always resolve any element masking problem in the view, although you may have to apply it to more than one masking element.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-360" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="745" id="calibre_link-1207" class="calibre18"></span>SUMMARY</h2>
<p class="calibre13">You have improved the view capability in Sketcher in several ways. You’ve added scrolling to the views using the MFC class <code class="calibre23">CScrollView</code>, and you’ve introduced a pop-up at the cursor for moving and deleting elements. You have also implemented an element-highlighting feature to provide the user with feedback during the moving or deleting of elements.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Implement element highlighting so that the line type changes for the element under the cursor as well as the element color.</li>
<li class="calibre6">Change the Sketcher program so that it uses a vector container to store a sketch instead of a list.</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="746" id="calibre_link-1208" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows coordinate systems</b></td>
<td class="calibre32">When you draw in a device context using the MFC, coordinates are in logical units that depend on the mapping mode set. Points in a window that are supplied along with Windows mouse messages are in client coordinates. The two coordinate systems are usually not the same.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Screen coordinates</b></td>
<td class="calibre32">Coordinates that define the position of the cursor are in screen coordinates that are measured in pixels relative to the upper-left corner of the screen.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Converting between coordinate systems</b></td>
<td class="calibre32">Functions to convert between client coordinates and logical coordinates are available in the <code class="calibre23">CDC</code> class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Updating multiple views</b></td>
<td class="calibre32">To get multiple views updated when you change the document contents, you can call the <code class="calibre23">UpdateAllViews()</code> member of the document object. This causes the <code class="calibre23">OnUpdate()</code> member of each view object to be called.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Updating efficiently</b></td>
<td class="calibre32">You can pass information to the <code class="calibre23">UpdateAllViews()</code> function to indicate which area in the view needs to be redrawn. This makes redrawing the views faster.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Creating a context menu</b></td>
<td class="calibre32">You create a context menu as a menu resource. The resource can then be loaded into a <code class="calibre23">CMenu</code> object in the handler function for the context menu event.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Displaying a context menu</b> </td>
<td class="calibre32">You can display a context menu at the cursor position in an MFC application in response to a right mouse button click by implementing the <code class="calibre23">OnContextMenu()</code>handler for a view. The menu is created as a normal pop-up at the cursor position.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-203">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2329" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="747" id="calibre_link-1209" class="calibre9"></span><span class="chapternumber">Chapter 16</span><br class="calibre10" /><span class="chapternumber">Working with Dialogs and Controls</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How to create dialog resources</li>
<li class="calibre6">How to add controls to a dialog</li>
<li class="calibre6">The basic varieties of controls available</li>
<li class="calibre6">How to create a dialog class to manage a dialog</li>
<li class="calibre6">How to program the creation of a dialog box, and how to get information back from the controls in it</li>
<li class="calibre6">What are modal and modeless dialogs</li>
<li class="calibre6">How to implement and use direct data exchange and validation with controls</li>
<li class="calibre6">How to implement view-scaling</li>
<li class="calibre6">How to use the status bar in an application</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 16 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-361" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="748" id="calibre_link-1210" class="calibre18"></span>UNDERSTANDING DIALOGS</h2>
<p class="calibre13">Of course, dialogs are not new to you. Most Windows programs of consequence use dialogs to manage some of their data input. You click a menu item and up pops a <i class="calibre15">dialog</i> with various <i class="calibre15">controls</i> that you use for entering information. Just about everything that appears in a dialog is a control. A dialog is actually a window and each control in a dialog is also a specialized window. Come to think of it, an application window under Microsoft Windows is composed almost entirely of windows within windows.</p>
<p class="calibre13">You need two things to create and display a dialog in an MFC program: the physical appearance of the dialog, which you define as a resource, and a dialog class object that you use to manage the operation of the dialog and its controls. MFC provides the <code class="calibre23">CDialog</code> and <code class="calibre23">CDialogEx</code> classes for you to use once you have defined your dialog resource.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-362" class="calibre3"></a>UNDERSTANDING CONTROLS</h2>
<p class="calibre13">Many different standard controls are available and in most cases there’s flexibility to how they look and operate. Most of them fall into one of the categories shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">CONTROL TYPE</b></th>
<th class="calibre32"><b class="calibre12">WHAT THEY DO</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32">Static controls</td>
<td class="calibre32">These are used to provide titles or descriptive information.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Button controls</td>
<td class="calibre32">Buttons provide a single-click input mechanism. There are basically three flavors of button controls: simple push buttons, radio buttons (of which only one may be in a selected state at any one time), and checkboxes (of which several may be in a selected state at one time).</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Scrollbars</td>
<td class="calibre32">You have already seen scrollbars in Sketcher. Scrollbars are typically used to scroll text or images, either horizontally or vertically, within another control.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">List boxes</td>
<td class="calibre32">These present a list of choices from which one or more selections can be made.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Edit controls</td>
<td class="calibre32">An edit control allows text input or editing of text that is displayed by the control.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">Combo boxes</td>
<td class="calibre32">Combo boxes present a list of choices from which you can select, combined with the option of entering text yourself.</td>
</tr>
</tbody>
</table>
<p class="calibre13">A control may or may not be associated with a class object. Static controls don’t do anything directly, so an associated class object may seem superfluous; however, there’s an MFC class, <code class="calibre23">CStatic</code>, that provides functions to enable you to alter the appearance of static controls. Button controls can also be handled by the dialog object in many cases, but again, MFC provides the <code class="calibre23">CButton</code> class for when you need a class object to manage a control. MFC also provides a full complement of classes to support the other controls. All controls are windows so the MFC classes for controls are all derived from <code class="calibre23">CWnd</code>.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature2">
<h1 class="calibre35"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="749" id="calibre_link-1211" class="calibre9"></span>COMMON CONTROLS</h1>
<p class="calibre20">The set of standard controls supported by the MFC and the Resource editor are called <i class="calibre15">common controls</i>. Common controls include all the controls I have just described, as well as other more complex controls such as the <i class="calibre15">animate control</i>, which can play an AVI (Audio Video Interleaved) file, and the <i class="calibre15">tree control</i>, which can display a hierarchy of items in a tree.</p>
<p class="calibre20">Another useful control in the set of common controls is the <i class="calibre15">spin button</i>. You can use this to increment or decrement values in an associated edit control. To go into all of the possible controls that you might use is beyond the scope of this book, so I’ll just take a few examples (including one that uses a spin button) and show you how to implement them in Sketcher.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-363" class="calibre3"></a>CREATING A DIALOG RESOURCE</h2>
<p class="calibre13">Here’s a concrete example. You could add a dialog to Sketcher to provide a choice of pen widths for drawing elements. This ultimately involves storing and modifying the current pen width in the document, as well as adding capability in the element classes to allow variable pen widths. You’ll deal with all that, though, after you’ve gotten the dialog together.</p>
<p class="calibre13">Display the Resource View, expand the resource tree for Sketcher, and right-click the Dialog folder; then click Insert Dialog from the pop-up to add a new dialog resource to Sketcher. This results in the Dialog Resource editor swinging into action and displaying the dialog in the Editor pane, and the Toolbox showing a list of controls that you can add; if the Toolbox is not displayed, click Toolbox in the right-hand sidebar or press Ctrl+Alt+X.</p>
<p class="calibre13">The dialog has OK and Cancel button controls already in place. Adding more controls to the dialog is simplicity itself: you can just drag the control from the list in the Toolbox window to the position at which you want to place it in the dialog. Alternatively, you can click a control from the list to select it, and then click in the dialog where you want the control to be positioned. When it appears you’ll still be able to move it around to set its exact position, and you’ll also be able to resize it by dragging handles on the boundaries.</p>
<p class="calibre13">The dialog has a default ID assigned, <code class="calibre23">IDD_DIALOG1</code>, but it would be better to have an ID that’s a bit more meaningful. You can edit the ID by right-clicking the dialog name in the Resource View pane and selecting Properties from the pop-up; this displays the properties for the dialog. Change the ID to something that relates to the purpose of the dialog, such as <code class="calibre23">IDD_PENWIDTH_DLG</code>. You can also display the properties for the dialog itself by right-clicking the dialog in the Dialog Editor pane and selecting Properties. Here you can change the Caption property value that appears in the title bar of the dialog to Set Pen Width.</p>
<section class="toclist">
<h3 class="calibre21">Adding Controls to a Dialog</h3>
<p class="calibre13">To provide a mechanism for entering a pen width, you will add controls to the basic dialog that is displayed initially until it looks like the one shown in <a id="calibre_link-205" href="#calibre_link-204" class="calibre3">Figure 16-1</a>. You place a control on the dialog by dragging it with the mouse from the Toolbox to the dialog. The figure shows a grid that you can <span {http://www.idpf.org/2007/ops}type="pagebreak" title="750" id="calibre_link-1212" class="calibre14"></span>use to position controls. If the grid is not displayed, you can select the appropriate toolbar button to display it; the button toggles the grid on and off.</p>
<figure class="calibre16">
<img class="center" src="images/000160.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-204" href="#calibre_link-205" class="calibre3">FIGURE 16-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Alternatively, you can display rules along the side and top of the dialog, which you can use to create guide lines, by clicking the Toggle Guides button. You create a horizontal guide by clicking in the appropriate rule where you want the guide to appear. Controls placed in contact with a guide will be attached to it and move with the guide. You can reposition a guide line by dragging the arrow for it along the rule. You can use one or more guides when positioning a control. You can toggle guides on and off by clicking the Toggle Guides toolbar button.</p>
<p class="calibre13">The dialog shown has six <i class="calibre15">radio buttons</i> that provide the pen width options. These are enclosed within a <i class="calibre15">group box</i> with the caption Pen Widths. The group box serves to enclose the radio buttons and make them operate as a group, for which only one member of the group can be checked at any given time. Each radio button has an appropriate label to identify the pen width that is set when it is selected. There are also the default OK and Cancel buttons that close the dialog. Each of the controls in the dialog has its own set of properties that you can access and modify, just as for the dialog itself. Let’s press on with putting the dialog together.</p>
<p class="calibre13">The next step in the creation of the dialog shown in <a href="#calibre_link-204" class="calibre3">Figure 16-1</a> is to add the group box. As I said, the group box serves to associate the radio buttons in a group from an operational standpoint, and to provide a caption and a boundary for the group of buttons. Where you need more than one set of radio buttons, a means of grouping them is essential if they are to work properly. You can select the button corresponding to the group box from the common controls palette by clicking it; then click the approximate position in the dialog where you want to place the center of the group box. This places a group box of default size onto the dialog. You can then drag the borders of the group box to enlarge it to accommodate the six radio buttons that you add. To set the caption for the group box, type the caption you want while the group box is selected (in this case, type <b class="calibre12">Pen Widths</b>).</p>
<p class="calibre13">The last step is to add the radio buttons. Select the radio button control by clicking it, and then clicking the position in the dialog where you want to place a radio button within the group box. Do the same for all six radio buttons. You can select each button by clicking it; then type in the caption to change it. You can also drag the border of the button to set its size, if necessary. To display the Properties window for a control, select it by right-clicking it; then select Properties from the pop-up. You can change the ID for each radio button in the Properties window for the control, in order to make the ID correspond better to its purpose: <code class="calibre23">IDC_PENWIDTH0</code> for the one-pixel-width pen, <code class="calibre23">IDC_PENWIDTH1</code> for the 0.01-inch-width pen, <code class="calibre23">IDC_PENWIDTH2</code> for the 0.02-inch-pen, and so on.</p>
<p class="calibre13">You can position individual controls by dragging them around with the mouse. You can select a group of controls by selecting successive controls with the Shift key pressed, or by dragging the cursor with the left button pressed to create an enclosing rectangle for a group. To align a group of controls, or to space them evenly horizontally or vertically, select the appropriate button from the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="751" id="calibre_link-1213" class="calibre14"></span>Dialog Editor toolbar. If the Dialog Editor toolbar is not visible, you can show it by right-clicking in the toolbar area and selecting it from the list of toolbars that is displayed. You can also align controls in the dialog by selecting from the Format menu.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Testing the Dialog</h3>
<p class="calibre13">The dialog resource is now complete. You can test it by selecting the toolbar button that appears at the left end of the Dialog Editor toolbar or by pressing Ctrl+T. This displays the dialog with the basic operations of the controls available, so you can try clicking on the radio buttons. When you have a group of radio buttons, only one can be selected at a time. As you select one, any other that was selected is reset. Click either the OK or Cancel button, or even the close icon in the title bar of the dialog, to end the test. After you save the dialog resource, you’re ready to add code to support it.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-364" class="calibre3"></a>PROGRAMMING FOR A DIALOG</h2>
<p class="calibre13">There are two aspects to programming for a dialog: getting it displayed, and handling user interactions with its controls. Before you can display the dialog corresponding to the resource you’ve just created, you must define a dialog class for it. The Class Wizard helps with this.</p>
<section class="toclist">
<h3 class="calibre21">Adding a Dialog Class</h3>
<p class="calibre13">Right-click in the Resource Editor pane for the dialog and then select Add Class from the pop-up to display the Class Wizard dialog. You’ll define a new dialog class derived from the MFC class <code class="calibre23">CDialogEx</code>, so select that class name from the “Base class” drop-down list if it’s not already selected. You can enter the class name as <b class="calibre12">CPenDialog</b>. The Class Wizard dialog should look like <a id="calibre_link-207" href="#calibre_link-206" class="calibre3">Figure 16-2</a>. Click the Finish button to create the new class.</p>
<figure class="calibre16">
<img class="center" src="images/000113.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-206" href="#calibre_link-207" class="calibre3">FIGURE 16-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="752" id="calibre_link-1214" class="calibre14"></span>The <code class="calibre23">CDialogEx</code> class is a window class (derived from <code class="calibre23">CWnd</code>) that’s specifically for displaying and managing dialogs. The dialog resource will be automatically associated with a <code class="calibre23">CPenDialog</code> object because the <code class="calibre23">IDD</code> class member is initialized with the dialog resource ID:</p>
<pre class="calibre28"><code class="calibre23">class CPenDialog : public CDialogEx
{
  DECLARE_DYNAMIC(CPenDialog)
        
public:
  CPenDialog(CWnd* pParent = NULL);   // standard constructor
  virtual ~CPenDialog();
        
// Dialog Data
  <b class="calibre12">enum { IDD = IDD_PENWIDTH_DLG };</b>
        
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        
  DECLARE_MESSAGE_MAP()
};</code></pre>
<p class="calibre13">The boldfaced statement defines <code class="calibre23">IDD</code> as a symbolic name for the dialog ID in the enumeration. Incidentally, using an enumeration used to be the only way to get an initialized data member into a class definition. Another way is to define a static <code class="calibre23">const</code> integral member of the class, so the Class Wizard could have used the following in the class definition:</p>
<pre class="calibre28"><code class="calibre23">static const int IDD = {IDD_PENWIDTH_DLG};</code></pre>
<p class="calibre13">As you saw in Chapter 7, with latest C++ standard supported in Visual C++ you can put an initial value for any regular non-static data member declaration in a class.</p>
<p class="calibre13">Having your own dialog class derived from <code class="calibre23">CDialogEx</code> means that you get all the functionality that that class provides. You can customize the dialog class by adding data members and functions to suit your particular needs. You’ll often handle messages from controls within the dialog class, although you can also choose to handle them in a view or a document class.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Modal and Modeless Dialogs</h3>
<p class="calibre13">There are two types of dialogs, <i class="calibre15">modal</i> and <i class="calibre15">modeless</i>, and they work in completely different ways. While a modal dialog is displayed, all operations in the other windows in the application are suspended until the dialog is closed, usually by the user clicking an OK or Cancel button. With a modeless dialog you can move the focus back and forth between the dialog window and other windows in your application just by clicking them, and you can continue to use the dialog at any time until you close it. The Class Wizard is an example of a modal dialog; the Properties window is a modeless dialog.</p>
<p class="calibre13">You can create a modeless dialog by calling the <code class="calibre23">Create()</code> member of the <code class="calibre23">CDialogEx</code> class in your dialog class constructor. You create a modal dialog by creating an object on the stack from your dialog class and calling its <code class="calibre23">DoModal()</code> function. You will be using only modal dialogs in Sketcher.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="753" id="calibre_link-1215" class="calibre24"></span>Displaying a Dialog</h3>
<p class="calibre13">Where you put the code to display a dialog in your program depends on the application. In Sketcher it will be convenient to add a menu item that results in the pen width dialog being displayed. You can put this item in the <code class="calibre23">IDR_SketchTYPE</code> menu bar. The pen width and the drawing color are both associated with a pen, so you can rename the Color menu as Pen. You do this by clicking the Color menu item in the Resource Editor pane to open its Properties window and changing the <code class="calibre23">Caption</code> property value to <code class="calibre23">&amp;Pen</code>.</p>
<p class="calibre13">When you add the Width menu item to the Pen menu, it would be a good idea to separate it from the colors in the menu. Add a separator after the last color menu item by right-clicking the empty menu item and selecting Insert Separator. You can then enter the new Width... item as the next menu item. The Width... menu item ends with an ellipsis (three periods) to indicate that it displays a dialog; this is a standard Windows convention. Click the menu item to display its properties as in <a id="calibre_link-209" href="#calibre_link-208" class="calibre3">Figure 16-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000066.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-208" href="#calibre_link-209" class="calibre3">FIGURE 16-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The default ID, <code class="calibre23">ID_PEN_WIDTH</code>, is fine, so you don’t need to change that. You can add a status bar prompt for the menu item, and because you’ll add a toolbar button, you can include text for the tooltip as well. Remember, you just put the tooltip text after the status bar prompt text, separated from it by <code class="calibre23">\n</code>. Here, the value for the <code class="calibre23">Prompt</code> property is “Change pen width\nShow pen width options.”</p>
<p class="calibre13">You need to add a toolbar button corresponding to the Width... menu item to the toolbar resource. To add the toolbar button, double-click the <code class="calibre23">IDR_MAINFRAME</code> toolbar resource in Resource View. You can add a toolbar button to represent a pen width. The one shown in <a id="calibre_link-211" href="#calibre_link-210" class="calibre3">Figure 16-4</a> tries to represent a pen drawing a line.</p>
<figure class="calibre16">
<img class="center" src="images/000041.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-210" href="#calibre_link-211" class="calibre3">FIGURE 16-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">To associate the new button with the menu item that you just added, open the Properties box for the button and specify its ID as <code class="calibre23">ID_PEN_WIDTH</code>, the same as that for the menu item.</p>
<section class="toclist">
<h4 class="calibre22"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="754" id="calibre_link-1216" class="calibre14"></span>Displaying the Dialog</h4>
<p class="calibre13">The code to display the dialog goes in the handler for the Pen <img src="images/000122.png" alt="image" class="calibre25" /> Width menu item. So, in which class should you implement this handler? The <code class="calibre23">CSketcherView</code> class is a candidate for dealing with pen widths, but following the logic for dealing with element color and type, it would be sensible to have the pen width selection in the document, so the handler should go in the <code class="calibre23">CSketcherDoc</code> class.</p>
<p class="calibre13">Right-click the Width... menu item in the Resource Editor pane for the <code class="calibre23">IDR_SketchTYPE</code> menu and select Add Event Handler from the pop-up. You can then create a function for the <code class="calibre23">COMMAND</code> message handler corresponding to <code class="calibre23">ID_PEN_WIDTH</code> in the <code class="calibre23">CSketcherDoc</code> class. Now edit this handler and enter the following code:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Handler for the pen width menu item</b>
void CSketcherDoc::OnPenWidth()
{
   <b class="calibre12">CPenDialog aDlg;                    // Create a local dialog object</b>
   <b class="calibre12">aDlg.DoModal();                     // Display the dialog as modal</b>
}</code></pre>
<p class="calibre13">There are just two statements at the moment. The first creates a dialog object that is automatically associated with your dialog resource. The second displays the dialog by calling the <code class="calibre23">DoModal()</code> function for the <code class="calibre23">aDlg</code> object.</p>
<p class="calibre13">Because the handler creates a <code class="calibre23">CPenDialog</code> object, you must add an <code class="calibre23">#include</code> directive for <code class="calibre23">PenDialog.h</code> to the beginning of <code class="calibre23">SketcherDoc.cpp</code>. After you’ve done that, you can build Sketcher and try out the dialog. It should appear when you click the pen-width toolbar button. Of course, if the dialog is to do anything, you still have to add the code to support the operation of the controls; to close the dialog, you can use either of the buttons or the close icon in the title bar.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Code to Close the Dialog</h4>
<p class="calibre13">The OK and Cancel buttons (and the close icon on the title bar) already close the dialog. The handlers to deal with the <code class="calibre23">BN_CLICKED</code> event handlers for the OK and Cancel button controls have been implemented for you in the base class. However, it’s useful to know how the action of closing the dialog is implemented, in case you want to do more before the dialog is closed, or if you are working with a modeless dialog.</p>
<p class="calibre13">The <code class="calibre23">CDialog</code> base class for <code class="calibre23">CDialogEx</code> defines the <code class="calibre23">OnOK()</code> method that is called when you click the default OK button; this has <code class="calibre23">IDOK</code> as its ID. This function closes the dialog and causes the <code class="calibre23">DoModal()</code> method to return the ID of the default OK button, <code class="calibre23">IDOK</code>. The <code class="calibre23">OnCancel()</code> function is called when you click the default Cancel button in the dialog; this closes the dialog and <code class="calibre23">DoModal()</code> returns the button ID, which is <code class="calibre23">IDCANCEL</code>. You can override either or both of these functions in your dialog class to do what you want. You need to make sure that you call the corresponding base class function at the end of your function implementation. You’ll probably remember by now that you can add an override to a class by clicking the Overrides button in the Properties window for the class. For example, you could implement an override for the <code class="calibre23">OnOK()</code> function as follows:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="755" id="calibre_link-1217" class="calibre14"></span>void CPenDialog::OnOK()
{
  // Your code for data validation or other actions...
  CDialogEx::OnOK();                     // Close the dialog
}</code></pre>
<p class="calibre13">In a complicated dialog, you might want to verify that the options selected or the data that has been entered is valid. You could put code here to check the state of the dialog and fix up the data, or even to leave the dialog open if there are problems.</p>
<p class="calibre13">Calling the base class <code class="calibre23">OnOK()</code> function closes the dialog and causes <code class="calibre23">DoModal()</code> to return <code class="calibre23">IDOK</code>. Thus, you can use the value returned from <code class="calibre23">DoModal()</code> to detect when the dialog was closed via the OK button.</p>
<p class="calibre13">As I said, you can override the <code class="calibre23">OnCancel()</code> function in a similar way if you need to do extra cleanup operations before the dialog closes. Be sure to call the base class function at the end of your function implementation.</p>
<p class="calibre13">When you are using a modeless dialog you must implement the <code class="calibre23">OnOK()</code> and <code class="calibre23">OnCancel()</code> function overrides so that they call the inherited <code class="calibre23">DestroyWindow()</code> function to terminate the dialog. In this case you must not call the base class <code class="calibre23">OnOK()</code> or <code class="calibre23">OnCancel()</code> functions because they do not destroy the dialog window, but merely render it invisible.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-365" class="calibre3"></a>SUPPORTING THE DIALOG CONTROLS</h2>
<p class="calibre13">For the pen dialog you’ll store the selected pen width in a data member, <code class="calibre23">m_PenWidth</code>, of the <code class="calibre23">CPenDialog</code> class. You can either add the data member by right-clicking the <code class="calibre23">CPenDialog</code> class name and selecting from the context menu, or you can add it directly to the class definition as follows:</p>
<pre class="calibre28"><code class="calibre23">class CPenDialog : public CDialogEx
{
// Construction
public:
   CPenDialog(CWnd* pParent = NULL);   // standard constructor
   virtual ~CPenDialog();
// Dialog Data
   enum { IDD = IDD_PENWIDTH_DLG };
        
   <b class="calibre12">int m_PenWidth;                     // Record the current pen width</b>
        
// Plus the rest of the class definition....
        
};</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">If you use the context menu for the class to add</i> <code class="calibre23">m_PenWidth</code>, <i class="calibre15">be sure to add a comment to the member variable definition. This is a good habit to get into, even when the member name looks self-explanatory.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="756" id="calibre_link-1218" class="calibre14"></span>You’ll use the <code class="calibre23">m_PenWidth</code> data member to set the radio button corresponding to the current pen width in the document as checked. You’ll also arrange for the pen width that is selected in the dialog to be stored in this member, so that you can retrieve it when the dialog closes. At this point you can initialize <code class="calibre23">m_PenWidth</code> to <code class="calibre23">0</code> in the <code class="calibre23">CPenDialog</code> class constructor:</p>
<pre class="calibre28"><code class="calibre23">CPenDialog::CPenDialog(CWnd* pParent /*=NULL*/)
                <b class="calibre12">: CDialogEx(CPenDialog::IDD, pParent), m_PenWidth {}</b>
{
}</code></pre>
<section class="toclist">
<h3 class="calibre21">Initializing Dialog Controls</h3>
<p class="calibre13">You can initialize the radio buttons by overriding the <code class="calibre23">OnInitDialog()</code> function that is inherited from the <code class="calibre23">CDialog</code> base class. This is called in response to a <code class="calibre23">WM_INITDIALOG</code> message, which is sent during the execution of <code class="calibre23">DoModal()</code> just before the dialog is displayed. You can add the function to the <code class="calibre23">CPenDialog</code> class by selecting <code class="calibre23">OnInitDialog</code> in the list of overrides in the Properties window for the class. The implementation for the new version of <code class="calibre23">OnInitDialog()</code> is:</p>
<pre class="calibre28"><code class="calibre23">BOOL CPenDialog::OnInitDialog()
{
  CDialogEx::OnInitDialog();
 
  <b class="calibre12">// Check the radio button corresponding to the pen width value</b>
  <b class="calibre12">switch(m_PenWidth)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">case 1:</b>
      <b class="calibre12">CheckDlgButton(IDC_PENWIDTH1,BST_CHECKED);</b>
      <b class="calibre12">break;</b>
    <b class="calibre12">case 2:</b>
      <b class="calibre12">CheckDlgButton(IDC_PENWIDTH2,BST_CHECKED);</b>
      <b class="calibre12">break;</b>
    <b class="calibre12">case 3:</b>
      <b class="calibre12">CheckDlgButton(IDC_PENWIDTH3,BST_CHECKED);</b>
      <b class="calibre12">break;</b>
    <b class="calibre12">case 4:</b>
      <b class="calibre12">CheckDlgButton(IDC_PENWIDTH4,BST_CHECKED);</b>
      <b class="calibre12">break;</b>
    <b class="calibre12">case 5:</b>
      <b class="calibre12">CheckDlgButton(IDC_PENWIDTH5,BST_CHECKED);</b>
      <b class="calibre12">break;</b>
    <b class="calibre12">default:</b>
      <b class="calibre12">CheckDlgButton(IDC_PENWIDTH0,BST_CHECKED);</b>
  <b class="calibre12">}</b>
  return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}</code></pre>
<p class="calibre13">You should leave the call to the base class function there because it does some essential setup for the dialog. The <code class="calibre23">switch</code> statement checks one of the radio buttons, depending on the value set in the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="757" id="calibre_link-1219" class="calibre14"></span><code class="calibre23">m_PenWidth</code> data member. This implies that you must arrange to set <code class="calibre23">m_PenWidth</code> to a suitable value before you execute <code class="calibre23">DoModal()</code> because the <code class="calibre23">DoModal()</code> function causes the <code class="calibre23">WM_INITDIALOG</code> message to be sent, resulting in your version of <code class="calibre23">OnInitDialog()</code> being called.</p>
<p class="calibre13">The <code class="calibre23">CheckDlgButton()</code> function is inherited indirectly from <code class="calibre23">CWnd</code>. The first argument identifies the button, and the second argument of type <code class="calibre23">UINT</code> sets its check status. If the second argument is <code class="calibre23">BST_CHECKED</code> it checks the button corresponding to the ID you specify in the first argument. If it’s <code class="calibre23">BST_UNCHECKED,</code> the button is unchecked. This function works with checkboxes and radio buttons.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Handling Radio Button Messages</h3>
<p class="calibre13">After the dialog is displayed, every time you click a radio button a message is generated and sent to the application. You can add handlers to the <code class="calibre23">CPenDialog</code> class to deal with these messages. Return to the dialog resource that you created, right-click each of the radio buttons in turn, and select Add Event Handler from the menu to create a handler for the <code class="calibre23">BN_CLICKED</code> message. <a id="calibre_link-213" href="#calibre_link-212" class="calibre3">Figure 16-5</a> shows the event handler dialog window for the button that has <code class="calibre23">IDC_PENWIDTH0</code> as its ID. Note that I have edited the name of the handler, as the default name was a little cumbersome.</p>
<figure class="calibre16">
<img class="center" src="images/000163.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-212" href="#calibre_link-213" class="calibre3">FIGURE 16-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="758" id="calibre_link-1220" class="calibre14"></span>The implementations of the <code class="calibre23">BN_CLICKED</code> event handlers for all of these radio buttons are similar because each just sets the pen width in the dialog object. As an example, the handler for <code class="calibre23">IDC_PENWIDTH0</code> is as follows:</p>
<pre class="calibre28"><code class="calibre23">void CPenDialog::OnPenwidth0()
{
  <b class="calibre12">m_PenWidth = 0;</b>
}</code></pre>
<p class="calibre13">You need to add the code for all six handlers to the <code class="calibre23">CPenDialog</code> class implementation, setting <code class="calibre23">m_PenWidth</code> to <code class="calibre23">1</code> in <code class="calibre23">OnPenwidth1()</code>, to <code class="calibre23">2</code> in <code class="calibre23">OnPenwidth2()</code>, and so on.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-366" class="calibre3"></a>COMPLETING DIALOG OPERATIONS</h2>
<p class="calibre13">You must now modify the <code class="calibre23">OnPenWidth()</code> handler in <code class="calibre23">CSketcherDoc</code> to make the dialog effective. Add the following code to the function:</p>
<pre class="calibre28"><code class="calibre23">// Handler for the pen width menu item
void CSketcherDoc::OnPenWidth()
{
  CPenDialog aDlg;                     // Create a local dialog object
 
  <b class="calibre12">// Set pen width in the dialog to that in the document</b>
  <b class="calibre12">aDlg.m_PenWidth = m_PenWidth;</b>
  
  <b class="calibre12">if(aDlg.DoModal() == IDOK)</b>             <b class="calibre12">// Display the dialog as modal</b>
    <b class="calibre12">m_PenWidth = aDlg.m_PenWidth;</b>      <b class="calibre12">// When closed with OK, get the pen width</b>
}</code></pre>
<p class="calibre13">The <code class="calibre23">m_PenWidth</code> member of the <code class="calibre23">aDlg</code> object is set to the pen width stored in the <code class="calibre23">m_PenWidth</code> member of the document; you still have to add this member to <code class="calibre23">CSketcherDoc</code>. The <code class="calibre23">DoModal()</code> function call now occurs in the <code class="calibre23">if</code> statement condition, which is <code class="calibre23">true</code> if the <code class="calibre23">DoModal()</code> function returns <code class="calibre23">IDOK</code>. In this case you retrieve the pen width stored in the <code class="calibre23">aDlg</code> object and store it in the <code class="calibre23">m_PenWidth</code> member of the document. If the dialog is closed by the Cancel button, the keyboard escape key, or the close icon, <code class="calibre23">IDOK</code> won’t be returned by <code class="calibre23">DoModal()</code> and the value of <code class="calibre23">m_PenWidth</code> in the document object will not be changed.</p>
<p class="calibre13">Note that even though the dialog is closed when <code class="calibre23">DoModal()</code> returns a value, the <code class="calibre23">aDlg</code> object still exists, so you can call its member functions. The <code class="calibre23">aDlg</code> object is destroyed on return from <code class="calibre23">OnPenWidth()</code>.</p>
<p class="calibre13">All that remains to do to support variable pen widths in your application is to update the affected classes: <code class="calibre23">CSketcherDoc, CElement</code>, and the four element classes derived from <code class="calibre23">CElement</code>.</p>
<section class="toclist">
<h3 class="calibre21">Adding Pen Widths to the Document</h3>
<p class="calibre13">You need to add the <code class="calibre23">m_PenWidth</code> member to the document class, and the <code class="calibre23">GetPenWidth()</code> function to allow external access to the value stored. You should add the following bolded statements to the <code class="calibre23">CSketcherDoc</code> class definition:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="759" id="calibre_link-1221" class="calibre14"></span>class CSketcherDoc : public CDocument
{
// the rest as before...
        
// Operations
public:
// the rest as before...
  <b class="calibre12">int GetPenWidth() const { return m_PenWidth; }</b>   <b class="calibre12">// Get current pen width</b>
 
// the rest as before...
 
protected:
// the rest as before...
  <b class="calibre12">int m_PenWidth {}                               // Current pen width</b>
        
// the rest as before...
};</code></pre>
<p class="calibre13">Because it’s trivial, you can define the <code class="calibre23">GetPenWidth()</code> function in the definition of the class and gain the benefit of it being implicitly <code class="calibre23">inline</code>. You don’t need to add initialization for <code class="calibre23">m_PenWidth</code> to the constructor for <code class="calibre23">CSketcherDoc.</code> The initial value is set in the declaration for the <code class="calibre23">m_PenWidth</code> value in <code class="calibre23">CSketcherDoc</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Adding Pen Widths to the Elements</h3>
<p class="calibre13">You have a little more work in the element classes. You already have a member <code class="calibre23">m_PenWidth</code> in <code class="calibre23">CElement</code> to store the pen width and the constructor has a parameter for a pen width. You must extend each of the derived class constructors to accept a pen width argument and set the member accordingly. The members that create or modify the enclosing rectangle for an element must be altered to deal with a pen width of <code class="calibre23">0</code>.</p>
<p class="calibre13">Each of the constructors for <code class="calibre23">CLine, CRectangle, CCircle</code>, and <code class="calibre23">CCurve</code> must be modified to accept a pen width argument. In the <code class="calibre23">CLine</code> class, the constructor declaration becomes:</p>
<pre class="calibre28"><code class="calibre23">   CLine(const CPoint&amp; start, const CPoint&amp; end, COLORREF aColor, int penWidth);</code></pre>
<p class="calibre13">And the constructor implementation should be modified to this:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">CLine::CLine(const CPoint&amp; start, const CPoint&amp; end,</b>
             <b class="calibre12">COLORREF color, int penWidth) :</b>
               <b class="calibre12">CElement {start, color, penWidth}, m_EndPoint {end}</b>
{
  // Define the enclosing rectangle
  m_EnclosingRect = CRect {start, end};
  m_EnclosingRect.NormalizeRect();
  <b class="calibre12">int width {penWidth == 0 ? 1 : penWidth};</b>   <b class="calibre12">// Inflate rect by at least 1</b>
  <b class="calibre12">m_EnclosingRect.InflateRect(width, width);</b>
}</code></pre>
<p class="calibre13">The enclosing rectangle is now produced by inflating the defining rectangle by at least 1.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="760" id="calibre_link-1222" class="calibre14"></span>The <code class="calibre23">CRectangle</code> constructor implementation is:</p>
<pre class="calibre28"><code class="calibre23">CRectangle::CRectangle (const CPoint&amp; start, const CPoint&amp; end,
                         <b class="calibre12">COLORREF color, int penWidth) :</b> 
                             <b class="calibre12">CElement {start, color, penWidth}</b>
{
  // Normalize the rectangle defining points
  m_StartPoint = CPoint {(std::min)(start.x, end.x)},
                        (std::min)(start.y, end.y)};
  m_BottomRight = CPoint {(std::max)(start.x, end.x)},
                         (std::max)(start.y, end.y)};
 
  // Ensure width and height between the points is at least 2
  if((m_BottomRight.x - m_StartPoint.x) &lt; 2)
    m_BottomRight.x = m_StartPoint.x + 2;
  if((m_BottomRight.y - m_StartPoint.y) &lt; 2)
    m_BottomRight.y = m_StartPoint.y + 2;
 
  // Define the enclosing rectangle
  m_EnclosingRect = CRect {m_StartPoint, m_BottomRight};
  <b class="calibre12">int width{penWidth == 0 ? 1 : penWidth}; // Inflate rect by at least 1</b>
  <b class="calibre12">m_EnclosingRect.InflateRect(width, width);</b>
}</code></pre>
<p class="calibre13">Don’t forget to add the pen width parameter to the constructor declaration in the class definition here and in the other element classes.</p>
<p class="calibre13">The <code class="calibre23">CCircle</code> constructor definition becomes:</p>
<pre class="calibre28"><code class="calibre23">CCircle::CCircle(const CPoint&amp; start, const CPoint&amp; end,
                 <b class="calibre12">COLORREF color, int penWidth) :</b> 
                                   <b class="calibre12">CElement {start, color, penWidth}</b>
{
  // Code as before...
        
  // Define the enclosing rectangle
  m_EnclosingRect = CRect {m_StartPoint.x, m_StartPoint.y,
                          m_BottomRight.x, m_BottomRight.y};
  <b class="calibre12">int width{penWidth == 0 ? 1 : penWidth}; // Inflate rect by at least 1</b>
  <b class="calibre12">m_EnclosingRect.InflateRect(width, width);</b>
}</code></pre>
<p class="calibre13">You must modify the constructor and the <code class="calibre23">AddSegment()</code> member of the <code class="calibre23">CCurve</code> class. Here’s the revised constructor definition:</p>
<pre class="calibre28"><code class="calibre23">CCurve::CCurve(const CPoint&amp; first, const CPoint&amp; second,
               <b class="calibre12">COLORREF color, int penWidth) :</b>
                                      <b class="calibre12">CElement {first, color, penWidth}</b>
{
   // Store the second point in the vector
   m_Points.push_back(second);
   m_EnclosingRect = CRect {
                (std::min)(first.x, second.x),
                <span {http://www.idpf.org/2007/ops}type="pagebreak" title="761" id="calibre_link-1223" class="calibre14"></span>(std::min)(first.y, second.y),
                (std::max)(first.x, second.x),
                (std::max)(first.y, second.y)};
  <b class="calibre12">int width {penWidth == 0 ? 1 : penWidth};       // Inflate rect by at least 1</b>
  <b class="calibre12">m_EnclosingRect.InflateRect(width, width);</b>
}</code></pre>
<p class="calibre13">The <code class="calibre23">AddSegment()</code> member implementation should be changed to:</p>
<pre class="calibre28"><code class="calibre23">void CCurve::AddSegment(const CPoint&amp; point)
{
  m_Points.push_back(point);                     // Add the point to the end
        
  // Modify the enclosing rectangle for the new point
  <b class="calibre12">int width {m_PenWidth == 0 ? 1 : m_PenWidth};   // Deflate rect by at least 1</b>

  <b class="calibre12">m_EnclosingRect.DeflateRect(width, width);</b>
  m_EnclosingRect = CRect {(std::min)(point.x, m_EnclosingRect.left),
                           (std::min)(point.y, m_EnclosingRect.top),
                           (std::max)(point.x, m_EnclosingRect.right),
                           (std::max)(point.y, m_EnclosingRect.bottom)};
  <b class="calibre12">m_EnclosingRect.InflateRect(width, width);</b>
}</code></pre>
<p class="calibre13">That’s got the element classes covered. Now you must alter the rest of Sketcher to use the new element constructors.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Creating Elements in the View</h3>
<p class="calibre13">The last change you need to make is to the <code class="calibre23">CreateElement()</code> member of <code class="calibre23">CSketcherView</code>. Because you have added the pen width as an argument to the constructors for each of the shapes, you must update the calls to the constructors to reflect this. Change the definition of <code class="calibre23">CSketcherView::CreateElement()</code> to the following:</p>
<pre class="calibre28"><code class="calibre23">std::shared_ptr&lt;CElement&gt; CSketcherView::CreateElement() const
{
     // Get a pointer to the document for this view
     CSketcherDoc* pDoc = GetDocument();
     ASSERT_VALID(pDoc);                       // Verify the pointer is good
 
     // Get the current element color
     COLORREF color {static_cast&lt;COLORREF&gt;(pDoc-&gt;GetElementColor())}

     <b class="calibre12">int penWidth{pDoc-&gt;GetPenWidth()};        // Get current pen width</b>
 
     // Now select the element using the type stored in the document
     switch(pDoc-&gt;GetElementType())
     {
        case ElementType::RECTANGLE:
           <b class="calibre12">return std::make_shared&lt;CRectangle&gt;(m_FirstPoint, m_SecondPoint,</b>
                                                      <b class="calibre12">color, penWidth);</b>
        <span {http://www.idpf.org/2007/ops}type="pagebreak" title="762" id="calibre_link-1224" class="calibre14"></span>case ElementType::CIRCLE:
           <b class="calibre12">return std::make_shared&lt;CCircle&gt;(m_FirstPoint, m_SecondPoint,</b>
                                                      <b class="calibre12">color, penWidth);</b>
        case ElementType::CURVE:
           <b class="calibre12">return std::make_shared&lt;CCurve&gt;(m_FirstPoint, m_SecondPoint,</b>
                                                      <b class="calibre12">color, penWidth);</b>
        case ElementType::LINE:
           <b class="calibre12">return std::make_shared&lt;CLine&gt;(m_FirstPoint, m_SecondPoint,</b>
                                                      <b class="calibre12">color, penWidth);</b>
        default:                   // Something's gone wrong
           AfxMessageBox(_T("Bad Element code"), MB_OK);
           AfxAbort();
           return nullptr;
     }
}</code></pre>
<p class="calibre13">Each constructor call now passes the pen width as an argument. This is retrieved from the document with the <code class="calibre23">GetPenWidth()</code> function that you added to the document class.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Exercising the Dialog</h3>
<p class="calibre13">You can now build and run the latest version of Sketcher to see how the pen dialog works out. Selecting the Pen <img src="images/000122.png" alt="image" class="calibre25" /> Width menu option or the associated toolbar button displays the dialog so that you can select the pen width. The screen shown in <a id="calibre_link-215" href="#calibre_link-214" class="calibre3">Figure 16-6</a> is typical of what you might see when the Sketcher program is executing.</p>
<figure class="calibre16">
<img class="center" src="images/000164.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-214" href="#calibre_link-215" class="calibre3">FIGURE 16-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="763" id="calibre_link-1225" class="calibre14"></span>Note that the dialog is a completely separate window. You can drag it around to position it where you want. You can even drag it outside the Sketcher application window.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-367" class="calibre3"></a>USING A SPIN BUTTON CONTROL</h2>
<p class="calibre13">Now you can look at how the spin button can help in Sketcher. The spin button is particularly useful when you want to constrain an input within a given integer range. It’s normally used in association with another control, called a <i class="calibre15">buddy control</i>, that displays the value that the spin button modifies. The associated control is usually an edit control, but it doesn’t have to be.</p>
<p class="calibre13">It would be nice to be able to draw at different viewing scales in Sketcher. If you had a way to change the scale, you could scale up whenever you wanted to fill in the fine detail in your masterpiece, and scale down again when working across the whole vista. You could apply the spin control to managing scaling in a document view. A drawing scale would be a view-specific property, and you would want the element drawing functions to take the current scale of a view into account. Altering the existing code to deal with view-scaling requires rather more work than setting up the control, so first look at how you create a spin button and make it work.</p>
<section class="toclist">
<h3 class="calibre21">Adding a Scale Menu Item and Toolbar Button</h3>
<p class="calibre13">The first step is to provide a means of displaying the scale dialog. Go to Resource View and open the <code class="calibre23">IDR_SketchTYPE</code> menu. You are going to add a Scale menu item to the end of the View menu. Enter the caption for the unused menu item in the View menu as Scale. . . . This item will bring up the scale dialog, so you end the caption with an ellipsis to indicate this. The default ID is <code class="calibre23">ID_VIEW_SCALE</code>. You can add a separator before the new menu item by right-clicking it and selecting Insert Separator. The menu should now look as shown in <a id="calibre_link-217" href="#calibre_link-216" class="calibre3">Figure 16-7</a>. Add a suitable Prompt property value for the menu item.</p>
<figure class="calibre16">
<img class="center" src="images/000142.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-216" href="#calibre_link-217" class="calibre3">FIGURE 16-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You can also add a toolbar button for this menu item with a bitmap image to represent scaling. Make sure that the ID for the button is also set to <code class="calibre23">ID_VIEW_SCALE</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="764" id="calibre_link-1226" class="calibre24"></span>Creating the Spin Button</h3>
<p class="calibre13">You’ve got the menu item; you need a dialog to go with it. In Resource View, add a new dialog by right-clicking the Dialog folder and selecting Insert Dialog. Change the ID for the resource to <code class="calibre23">IDD_SCALE_DLG</code> and the <code class="calibre23">Caption</code> property for the dialog to Set Drawing Scale.</p>
<p class="calibre13">Click the spin control in the Toolbox, and then click on the position in the dialog where you want it to be placed. Next, right-click the spin control to display its properties. Change its ID to something more meaningful than the default, such as <code class="calibre23">IDC_SPIN_SCALE</code>. Now take a look at the properties for the spin button. They are shown in <a id="calibre_link-219" href="#calibre_link-218" class="calibre3">Figure 16-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000032.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-218" href="#calibre_link-219" class="calibre3">FIGURE 16-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The Arrow Keys property is already set to <code class="calibre23">True</code>, enabling you to operate the spin button by using arrow keys on the keyboard. You should also set to <code class="calibre23">True</code> the value for both the <code class="calibre23">Set Buddy Integer</code> property that specifies the buddy control value as an integer, and Auto Buddy that provides for automatic selection of the buddy control. The effect of the latter is that the control selected as the buddy is automatically the previous control defined in the dialog. At the moment this is the Cancel button, which is not exactly ideal, but you’ll see how to change this in a moment. The Alignment property determines how the spin button is displayed in relation to its buddy. You should set this to Right Align so that the spin button is attached to the right edge of its buddy control.</p>
<p class="calibre13">Next, add an edit control at the left side of the spin button by selecting the edit control from the Toolbox pane and clicking in the dialog where you want it positioned. Change the ID for the edit control to <code class="calibre23">IDC_SCALE</code>. You can change its Align Text property value to Center.</p>
<p class="calibre13">To make the contents of the edit control quite clear, you could add a static control just to the left of the edit control in the dialog and enter <b class="calibre12">View Scale:</b> as the caption. You can select all three controls by clicking them while holding down the Shift key. Pressing the F9 function key aligns the controls tidily, or you can use the Format menu.</p>
<section class="toclist">
<h4 class="calibre22">The Controls’ Tab Sequence</h4>
<p class="calibre13">Controls in a dialog have what is called a <i class="calibre15">tab sequence</i>. This is the sequence in which the focus shifts from one control to the next when you press the Tab key, and it is determined initially by the sequence in which you add controls to the dialog. You can see the tab sequence for the current dialog by selecting Format <img src="images/000122.png" alt="image" class="calibre25" /> Tab Order from the main menu, or by pressing Ctrl+D. <a id="calibre_link-221" href="#calibre_link-220" class="calibre3">Figure 16-9</a> shows the tab order required for the spin control to work with its buddy control.</p>
<figure class="calibre16">
<img class="center" src="images/000063.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-220" href="#calibre_link-221" class="calibre3">FIGURE 16-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="765" id="calibre_link-1227" class="calibre14"></span>If the tab order you see is different, you have to change it. You really want the edit control to precede the spin button in the tab sequence, so you need to select the controls by clicking them in the order in which you want them to be numbered: OK button; Cancel button; edit control; spin button; and finally the static control. So, the tab order will be as in <a href="#calibre_link-220" class="calibre3">Figure 16-9</a>. Now the edit control is selected as the buddy to the spin button.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Generating the Scale Dialog Class</h3>
<p class="calibre13">After saving the resource file, you can right-click the dialog in the Resource Editor pane and select Add Class. You’ll then be able to define the new class associated with the dialog resource that you have created. You should name the class <code class="calibre23">CScaleDialog</code> and leave the base class as the default, <code class="calibre23">CDialogEx</code>. Clicking the Finish button adds the class to the Sketcher project.</p>
<p class="calibre13">You need a variable in the dialog class to store the value returned from the edit control, so right-click the <code class="calibre23">CScaleDialog</code> class name in Class View and select Add <img src="images/000122.png" alt="image" class="calibre25" /> Add Variable. The new data member is a special kind, called a <i class="calibre15">control variable</i>, so first check the “Control variable” box in the Add Member Variable Wizard dialog. A control variable is a variable that is to be associated with a control in the dialog. Select <code class="calibre23">IDC_SCALE</code> as the ID from the Control ID drop-down list and Value from the Category list box. Enter the variable name as <code class="calibre23">m_Scale</code>. You’ll be storing an integer scale value, so select <code class="calibre23">int</code> as the variable type. The Add Member Variable Wizard displays edit boxes in which you can enter maximum and minimum values for the variable <code class="calibre23">m_Scale</code>. For our application, a minimum of <code class="calibre23">1</code> and a maximum of <code class="calibre23">8</code> would be good values. Note that this constraint applies only to the edit box with the ID <code class="calibre23">IDC_SCALE</code>; the spin control is independent of it.</p>
<p class="calibre13"><a id="calibre_link-223" href="#calibre_link-222" class="calibre3">Figure 16-10</a> shows how the window for the Add Member Variable Wizard should look when you are done.</p>
<figure class="calibre16">
<img class="center" src="images/000119.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-222" href="#calibre_link-223" class="calibre3">FIGURE 16-10</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="766" id="calibre_link-1228" class="calibre14"></span>When you click the Finish button, the wizard takes care of entering the code necessary to support your new control variable.</p>
<p class="calibre13">You will also need to access the spin control in the dialog class and you can use the Add Member Variable Wizard to create that, too. Right-click <code class="calibre23">CScaleDialog</code> in Class View once again, select Add variable..., and click the Control variable checkbox in the dialog. Leave the Category selection as Control and select <code class="calibre23">IDC_SPIN_SCALE</code> as the control ID: this corresponds to the spin control. The type will be automatically selected as <code class="calibre23">CSpinButtonCtrl</code>. You can now enter the variable name as <code class="calibre23">m_Spin</code>, select protected for the Access value and add a suitable comment. When you click the Finish button, the new variable will be added to the <code class="calibre23">CScaleDialog</code> class.</p>
<p class="calibre13">The class definition you’ll end up with after the wizard has added the new members is as follows:</p>
<pre class="calibre28"><code class="calibre23">class CScaleDialog : public CDialogEx
{
  DECLARE_DYNAMIC(CScaleDialog)
 
public:
  CScaleDialog(CWnd* pParent = NULL);               // standard constructor
  virtual ~CScaleDialog();
 
<b class="calibre12">// Dialog Data</b>
  <b class="calibre12">enum { IDD = IDD_SCALE_DLG };</b>
 
protected:
  <b class="calibre12">virtual void DoDataExchange(CDataExchange* pDX);  // DDX/DDV support</b>
 
  DECLARE_MESSAGE_MAP()
public:
  <b class="calibre12">int m_Scale;</b>                                     <b class="calibre12">// Stores the current view scale</b>
<b class="calibre12">protected:</b>
  <b class="calibre12">CSpinButtonCtrl m_Spin;</b>                          <b class="calibre12">// Spin control for view scale</b>
};</code></pre>
<p class="calibre13">The interesting bits of the class definition are bolded. The class is associated with the dialog resource through the <code class="calibre23">enum</code> statement, initializing <code class="calibre23">IDD</code> with the ID of the resource. It contains the variable <code class="calibre23">m_Scale</code>, which is a <code class="calibre23">public</code> member of the class so you can set and retrieve its value in a <code class="calibre23">CScaleDialog</code> object directly. There’s also some special code in the implementation of the class to deal with the new <code class="calibre23">m_Scale</code> member. The <code class="calibre23">m_Spin</code> variable references the <code class="calibre23">CSpinButtonCtrl</code> object so you can call functions for the spin control.</p>
<section class="toclist">
<h4 class="calibre22">Dialog Data Exchange and Validation</h4>
<p class="calibre13">A virtual function called <code class="calibre23">DoDataExchange()</code> has been included in the class by the Class Wizard. If you look in the <code class="calibre23">ScaleDialog.cpp</code> file, you’ll find that the implementation looks like this:</p>
<pre class="calibre28"><code class="calibre23">void CScaleDialog::DoDataExchange(CDataExchange* pDX)
{
   CDialogEx::DoDataExchange(pDX); 
   DDX_Text(pDX, IDC_SCALE, m_Scale);
   DDV_MinMaxInt(pDX, m_Scale, 1, 8);
   DDX_Control(pDX, IDC_SPIN_SCALE, m_Spin);
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="767" id="calibre_link-1229" class="calibre14"></span>This function is called by the framework to carry out the exchange of data between variables in a dialog and the dialog’s controls. This mechanism is called <i class="calibre15">dialog data exchange</i>, usually abbreviated to <i class="calibre15">DDX</i>. This is a powerful mechanism that can provide automatic transfer of information between a dialog and its controls in most circumstances, thus saving you the effort of programming to get the data yourself, as you did with the radio buttons in the pen width dialog.</p>
<p class="calibre13">DDX handles data transfers between the edit control and the variable <code class="calibre23">m_Scale</code> in the <code class="calibre23">CScaleDialog</code> class. The variable <code class="calibre23">pDX</code> that is passed to the <code class="calibre23">DoDataExchange()</code> function controls the direction in which data is transferred. After the base class <code class="calibre23">DoDataExchange()</code> function is called, the <code class="calibre23">DDX_Text()</code> function is called. The latter moves data between the <code class="calibre23">m_Scale</code> variable and the edit control.</p>
<p class="calibre13">The call to the <code class="calibre23">DDV_MinMaxInt()</code> function verifies that the value transferred is within the limits specified. This mechanism is called <i class="calibre15">dialog data validation</i>, or <i class="calibre15">DDV</i>. The <code class="calibre23">DoDataExchange()</code> function is called automatically before the dialog is displayed to pass the value stored in <code class="calibre23">m_Scale</code> to the edit control. When the dialog is closed with the OK button, it is automatically called again to pass the value in the control back to the variable <code class="calibre23">m_Scale</code> in the dialog object. All this is taken care of for you. You need only to ensure that the right value is stored in <code class="calibre23">m_Scale</code> before the dialog is displayed, and arrange to collect the result when the dialog closes.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Initializing the Dialog</h4>
<p class="calibre13">You’ll use an override of the inherited <code class="calibre23">OnInitDialog()</code> function to initialize the dialog, just as you did for the pen width dialog. This time you’ll use it to set up the spin control. You’ll initialize the <code class="calibre23">m_Scale</code> member a little later when you create the dialog in the message handler for the <code class="calibre23">Scale</code> menu item, because it should be set to the value of the scale that is stored in the view. For now, add an override for the <code class="calibre23">OnInitDialog()</code> function to the <code class="calibre23">CScaleDialog</code> class, using the class properties pane as you did for the previous dialog, and add code to initialize the spin control:</p>
<pre class="calibre28"><code class="calibre23"> 
BOOL CScaleDialog::OnInitDialog()
{
  CDialogEx::OnInitDialog(); 
 
   
  <b class="calibre12">m_Spin.SetRange(1, 8);                     // Set the spin control range</b>
 
  return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}</code></pre>
<p class="calibre13">There is only one line of code to add. This sets the upper and lower limits for the spin button object by calling its <code class="calibre23">SetRange()</code> member. Although you have set the range limits for the edit control, this doesn’t affect the spin control directly. If you don’t limit the values in the spin control here, you allow the spin control to insert values outside the limits in the edit control, and there will be an error message from the edit control. You can demonstrate this by commenting out the statement that calls <code class="calibre23">SetRange()</code> here and trying out Sketcher without it.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="768" id="calibre_link-1230" class="calibre14"></span>If you want to set the buddy control using code, rather than by setting the value of Auto buddy in the spin button’s properties to <code class="calibre23">True</code>, the <code class="calibre23">CSpinButtonCtrl</code> class has a function member to do this. You would add the following statement following the <code class="calibre23">OnInitDialog()</code> call:</p>
<pre class="calibre28"><code class="calibre23">m_Spin.SetBuddy(GetDlgItem(IDC_SCALE));</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can access controls in a dialog programmatically. The</i> <code class="calibre23">GetDlgItem()</code> <i class="calibre15">function is inherited from</i> <code class="calibre23">CWnd</code> <i class="calibre15">via</i> <code class="calibre23">CDialog</code> <i class="calibre15">and</i> <code class="calibre23">CDialogEx</code>, <i class="calibre15">and you can use this member to retrieve the address of any control identified by the ID you pass as the argument. Thus, calling</i> <code class="calibre23">GetDlgItem()</code> <i class="calibre15">with</i> <code class="calibre23">IDC_SPIN_SCALE</code> <i class="calibre15">as the argument would return the address of the spin control. As you saw earlier, a control is just a specialized window, so the pointer returned is of type</i> <code class="calibre23">CWnd*</code>. <i class="calibre15">You have to cast it to the type appropriate to the particular control if you want to call member functions. The type would be</i> <code class="calibre23">CSpinButtonCtrl*</code> <i class="calibre15">in this case.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Displaying the Spin Button</h3>
<p class="calibre13">The dialog is to be displayed when the Scale menu item or its associated toolbar button is selected. Add a <code class="calibre23">COMMAND</code> event handler to <code class="calibre23">CSketcherView</code> corresponding to the <code class="calibre23">ID_VIEW_SCALE</code> event through the Properties window for the class. You can then add code as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnViewScale()
{
  <b class="calibre12">CScaleDialog aDlg;                   // Create a dialog object</b>
  <b class="calibre12">aDlg.m_Scale = m_Scale;              // Pass the view scale to the dialog</b>
  <b class="calibre12">if(aDlg.DoModal() == IDOK)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">m_Scale = aDlg.m_Scale;            // Get the new scale</b>
    <b class="calibre12">InvalidateRect(nullptr);           // Invalidate the whole window</b>
  <b class="calibre12">}</b>
}</code></pre>
<p class="calibre13">You create the dialog as a modal dialog, just as you did with the pen width dialog. Before the dialog is displayed by the <code class="calibre23">DoModal()</code> function call, you store the scale value from the <code class="calibre23">m_Scale</code> member of <code class="calibre23">CSketcherView</code> in the dialog member with the same name; this ensures that the control displays the current scale value when the dialog is displayed. If the dialog is closed with the OK button, you store the new scale from the <code class="calibre23">m_Scale</code> member of the dialog object in the view member with the same name. Because you have changed the view scale, you need to get the view redrawn with the new scale value applied. The call to <code class="calibre23">InvalidateRect()</code> does this. Don’t forget to add an <code class="calibre23">#include</code> directive for <code class="calibre23">ScaleDialog.h</code> to <code class="calibre23">SketcherView.cpp</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="769" id="calibre_link-1231" class="calibre14"></span>Of course, you must not forget to add the <code class="calibre23">m_Scale</code> data member to the definition of <code class="calibre23">CSketcherView</code>, so add the following line at the end of the other <code class="calibre23">protected</code> data members in the class definition:</p>
<pre class="calibre28"><code class="calibre23">  int m_Scale {1};                         // Current view scale</code></pre>
<p class="calibre13">This defines the <code class="calibre23">m_Scale</code> member and initializes it to <code class="calibre23">1</code>. This results in a view always starting out with a scale of 1 to 1. That’s all you need to get the scale dialog and its spin control operational. You can build and run Sketcher to give it a trial spin before you add the code to use a view scale factor in the drawing process.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-368" class="calibre3"></a>USING THE SCALE FACTOR</h2>
<p class="calibre13">Scaling with Windows usually involves using one of the scalable mapping modes, <code class="calibre23">MM_ISOTROPIC</code> or <code class="calibre23">MM_ANISOTROPIC</code>. By using one of these mapping modes you can get Windows to do most of the work. Unfortunately, it’s not as simple as just changing the mapping mode, because neither is supported by <code class="calibre23">CScrollView</code>. If you can get around that, however, you’re home and dry. You’ll use <code class="calibre23">MM_ANISOTROPIC</code> for reasons that you’ll see in a moment, so let’s first understand what’s involved in using this mapping mode.</p>
<section class="toclist">
<h3 class="calibre21">Scalable Mapping Modes</h3>
<p class="calibre13">There are two mapping modes that allow the mapping between logical coordinates and device coordinates to be altered, and these are the <code class="calibre23">MM_ISOTROPIC</code> and <code class="calibre23">MM_ANISOTROPIC</code> modes. The <code class="calibre23">MM_ISOTROPIC</code> mode forces the scaling factor for both the x- and y-axes to be the same, which has the advantage that your circles will always be circles. The disadvantage is that you can’t map a document to fit into a rectangle of a different aspect ratio. The <code class="calibre23">MM_ANISOTROPIC</code> mode, on the other hand, permits scaling of each axis independently. Because it’s the more flexible mode of the two, you’ll use <code class="calibre23">MM_ANISOTROPIC</code> for scaling operations in Sketcher.</p>
<p class="calibre13">Just to remind you:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><i class="calibre15">Logical coordinates</i> (also referred to as page coordinates) are determined by the mapping mode. For example, the <code class="calibre23">MM_LOENGLISH</code> mapping mode has logical coordinates in units of 0.01 inches, with the origin in the upper-left corner of the client area, and the positive y-axis direction running from bottom to top. These are used by the device context drawing functions.</li>
<li class="calibre6"><i class="calibre15">Device coordinates</i> (also referred to as <i class="calibre15">client coordinates</i> in a window) are measured in pixels in the case of a window, with the origin at the upper-left corner of the client area, and with the positive y-axis direction from top to bottom. These are used outside a device context &mdash; for example, for defining the position of the cursor in mouse message handlers.</li>
<li class="calibre6"><i class="calibre15">Screen coordinates</i> are measured in pixels and have the origin at the upper-left corner of the screen, with the positive y-axis direction from top to bottom. These are used for getting or setting the cursor position.</li>
</ul>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="770" id="calibre_link-1232" class="calibre14"></span>The way in which logical coordinates are transformed to device coordinates in the <code class="calibre23">MM_ISOTROPIC</code> and <code class="calibre23">MM_ANISOTROPIC</code> mapping modes is dependent on the following parameters that you can set:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">PARAMETER</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Window Origin</code></td>
<td class="calibre32">The logical coordinates of the upper-left corner of the window. You set this by calling <code class="calibre23">CDC::SetWindowOrg()</code>.<br class="calibre10" />For example, calling <code class="calibre23">SetWindowOrg(50,50)</code>sets the window origin at the point (50,50).</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Window Extent</code></td>
<td class="calibre32">The size of the window specified in logical coordinates. You set this by calling <code class="calibre23">CDC::SetWindowExt()</code>.<br class="calibre10" />For example, calling <code class="calibre23">SetWindowExt(250,350)</code>sets the window extent 250 in the x-direction and 350 in the y-direction.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Viewport Origin</code></td>
<td class="calibre32">The coordinates of the upper-left corner of the window in device coordinates (pixels). You set this by calling <code class="calibre23">CDC::SetViewportOrg()</code>.<br class="calibre10" />For example, calling <code class="calibre23">SetViewportOrg(10,10)</code>sets the viewport origin at the point (10,10).</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Viewport Extent</code></td>
<td class="calibre32">The size of the viewport in device coordinates (pixels). You set this by calling <code class="calibre23">CDC::SetViewportExt()</code>.<br class="calibre10" />For example, calling <code class="calibre23">SetViewportExt(150,150)</code>sets the viewport extent to 150 in both the x-direction and y-direction.</td>
</tr>
</tbody>
</table>
<p class="calibre13">The <i class="calibre15">viewport</i> referred to here has no physical significance by itself; it only has meaning in relation to the window extent. The viewport extent together with the window extent determines how coordinates are transformed from logical coordinates to device coordinates. To put it another way, the <code class="calibre23">SetWindowExt()</code> and <code class="calibre23">SetViewportExt()</code> functions define corresponding rectangles that determine the transformation between logical coordinates and device coordinates. When you call <code class="calibre23">SetWindowExt()</code>, you are defining a rectangle in logical coordinates that corresponds to the rectangle in device coordinates that you define when you call <code class="calibre23">SetViewportExt()</code>.</p>
<p class="calibre13">The formulae used by Windows to convert from logical coordinates to device coordinates are:</p>
<div class="informalequation">
<img class="center" src="images/000154.png" alt="Image" />
</div>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="771" id="calibre_link-1233" class="calibre14"></span>With coordinate systems other than those provided by the <code class="calibre23">MM_ISOTROPIC</code> and <code class="calibre23">MM_ANISOTROPIC</code> mapping modes, the window extent and the viewport extent are fixed by the mapping mode and can’t be changed. Calling <code class="calibre23">SetWindowExt()</code> or <code class="calibre23">SetViewportExt()</code> in the <code class="calibre23">CDC</code> object to change them has no effect, although you can still move the position of (0,0) in your logical reference frame by calling <code class="calibre23">SetWindowOrg()</code> or <code class="calibre23">SetViewportOrg()</code>. However, with the <code class="calibre23">MM_ISOTROPIC</code> or <code class="calibre23">MM_ANISOTROPIC</code> mapping modes, for a given document size that is expressed by the window extent in logical coordinate units, you can adjust the scale at which elements are displayed by setting the viewport extent appropriately. By setting the window and viewport extents, you can get the scaling done automatically.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Setting the Document Size</h3>
<p class="calibre13">You need to define the size of the document in logical units in the document object. You can add a <code class="calibre23">protected</code> data member, <code class="calibre23">m_DocSize</code>, to the <code class="calibre23">CSketcherDoc</code> class definition to store the size of the document implementation of CSketcherDoc() to:</p>
<pre class="calibre28"><code class="calibre23">  CSize m_DocSize {CSize {3000, 3000}};               // Document size</code></pre>
<p class="calibre13">This defines the extent of the document as 3000 logical units in both the x and y directions. <code class="calibre23">CSize</code> is an MFC class that is the equivalent of the Windows <code class="calibre23">SIZE</code> structure. It has public data members <code class="calibre23">cx</code> and <code class="calibre23">cy</code>. The class overloads the <code class="calibre23">+, -, +=, -=, ==,</code> and <code class="calibre23">!=</code> operators so you can add, subtract and compare <code class="calibre23">CSize</code> objects for equality or inequality. The physical extent of a dimension in logical units will be determined by the window extent and the viewport extent that is in effect. Either or both extents can be changed with the scaleable mapping modes, which will alter the physical extent of a given number of logical units. You will want to access the <code class="calibre23">m_DocSize</code> data member from the view class, so add a <code class="calibre23">public</code> function to the <code class="calibre23">CSketcherDoc</code> class definition as follows:</p>
<pre class="calibre28"><code class="calibre23">  CSize GetDocSize() const { return m_DocSize; }    // Retrieve the document size
   </code></pre>
<p class="calibre13">You don’t need to initialize the <code class="calibre23">m_DocSize</code> member in the constructor for the document because an initial value has been specified for it.</p>
<p class="calibre13">You’ll be using notional <code class="calibre23">MM_LOENGLISH</code> coordinates, so a logical unit is 0.01 inches, and the value for the document size gives you an area of 30 inches square to draw on.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Setting the Mapping Mode</h3>
<p class="calibre13">You can set the mapping mode to <code class="calibre23">MM_ANISOTROPIC</code> in an override of the inherited <code class="calibre23">OnPrepareDC()</code> function in the <code class="calibre23">CSketcherView</code> class. This function is always called for any <code class="calibre23">WM_PAINT</code> message that is sent to the view and it allows you to set up the device context to your liking before the <code class="calibre23">OnDraw()</code> member is called. You have to do a little more than just set the mapping mode to get view-scaling working. You must figure out what you should set the viewport extent to, so that the sketch will be drawn at the scale that is set in the view.</p>
<p class="calibre13">You’ll need to create the function override for <code class="calibre23">OnPrepareDC()</code> in <code class="calibre23">CSketcherView</code> before you can add the code. Open the Properties window for the <code class="calibre23">CSketcherView</code> class and click the Overrides button. Add the override by selecting <code class="calibre23">OnPrepareDC</code> from the list and clicking <code class="calibre23">&lt;Add&gt; <span {http://www.idpf.org/2007/ops}type="pagebreak" title="772" id="calibre_link-1234" class="calibre14"></span>OnPrepareDC</code> in the adjacent column. You can now type the code directly into the Editor pane. The implementation of <code class="calibre23">OnPrepareDC()</code> is:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
  CScrollView::OnPrepareDC(pDC, pInfo);
  <b class="calibre12">CSketcherDoc* pDoc {GetDocument()};</b>
  <b class="calibre12">pDC-&gt;SetMapMode(MM_ANISOTROPIC);     // Set the map mode</b>
  <b class="calibre12">CSize DocSize {pDoc-&gt;GetDocSize()};  // Get the document size</b>

  <b class="calibre12">pDC-&gt;SetWindowExt(DocSize);          // Now set the window extent</b>

  <b class="calibre12">// Get the number of pixels per inch in x and y</b>
  <b class="calibre12">int xLogPixels {pDC-&gt;GetDeviceCaps(LOGPIXELSX)};</b>
  <b class="calibre12">int yLogPixels {pDC-&gt;GetDeviceCaps(LOGPIXELSY)};</b>

  <b class="calibre12">// Calculate the viewport extent in x and y for the current scale</b>
  <b class="calibre12">int xExtent {(DocSize.cx*m_Scale*xLogPixels)/100};</b>
  <b class="calibre12">int yExtent {(DocSize.cy*m_Scale*yLogPixels)/100};</b>

  <b class="calibre12">pDC-&gt;SetViewportExt(xExtent,yExtent); // Set viewport extent</b>
}</code></pre>
<p class="calibre13">The implementation of the override of <code class="calibre23">OnPrepareDC()</code> is unusual here in that you have left in the call to <code class="calibre23">CScrollView::OnPrepareDC()</code> and added the modifications after it, rather than where the comment in the default code suggests. If the class was derived from <code class="calibre23">CView</code>, you would replace the call to the base class version because it does nothing, but in the case of <code class="calibre23">CScrollView</code>, this isn’t the case. You need the base class function to set some attributes before you set the mapping mode. Don’t make the mistake of calling the base class function after your code &mdash; if you do, scaling won’t work.</p>
<p class="calibre13">The window extent is set to the document size, which is in logical coordinate units. The <code class="calibre23">CDC</code> member function <code class="calibre23">GetDeviceCaps()</code> supplies information about the device with which the device context is associated. You can get various kinds of information about the device, depending on the argument you pass to the function. Here the arguments <code class="calibre23">LOGPIXELSX</code> and <code class="calibre23">LOGPIXELSY</code> cause the function to return the number of pixels per logical inch in the x- and y-directions, respectively. These values are the number of pixels in 100 units (1 inch) in your logical coordinates.</p>
<p class="calibre13">You use these values to calculate the x- and y-values for the viewport extent for the current scale, which you store in the local variables <code class="calibre23">xExtent</code> and <code class="calibre23">yExtent</code>. The document extent along an axis in logical units, divided by 100, gives the document extent in inches. When you multiply this by the number of logical pixels per inch for the device, you get the number of pixels for the document extent. If you were to use this value as the viewport extent, you would get the elements displayed at a scale of 1 to 1. When the window origin and the viewport origin are both (0,0), the equations for converting between device and logical coordinates are very simple:</p>
<div class="informalequation">
<img class="center" src="images/000036.png" alt="Image" />
</div>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="773" id="calibre_link-1235" class="calibre14"></span>If you multiply the viewport extent values by the view scale, <code class="calibre23">m_Scale</code>, the elements are drawn scaled by a factor of <code class="calibre23">m_Scale</code>. This logic is exactly represented by the expressions for the x- and y-viewport extents in your code. The simplified equations, with the scale included, are as follows:</p>
<div class="informalequation">
<img class="center" src="images/000169.png" alt="Image" />
</div>
<p class="calibre13">You should be able to see from this that a given point (x,y) in device coordinates varies in proportion to the scale value. The coordinates at a scale of three are three times the coordinates at a scale of one. Of course, as well as making elements larger, increasing the scale also moves them away from the origin.</p>
<p class="calibre13">Unfortunately, at the moment scrolling won’t work with scaling, so you need to see what you can do about that.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Implementing Scrolling with Scaling</h3>
<p class="calibre13"><code class="calibre23">CScrollView</code> just won’t work with the <code class="calibre23">MM_ANISOTROPIC</code> mapping mode, so clearly you must use another mapping mode to set up the scrollbars. The easiest way to do this is to use <code class="calibre23">MM_TEXT</code>, because in this case the units of logical coordinates are the same as the client coordinates &mdash; pixels, in other words. All you need to do, then, is figure out how many pixels are equivalent to the logical document extent for the scale at which you are drawing, which is easier than you might think. You can add a function to <code class="calibre23">CSketcherView</code> to take care of the scrollbars and implement it to work out the number of pixels corresponding to the logical document extent. Right-click the <code class="calibre23">CSketcherView</code> class name in Class View and add a <code class="calibre23">public</code> function, <code class="calibre23">ResetScrollSizes()</code>, with a <code class="calibre23">void</code> return type and no parameters. Add the code to the implementation, as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::ResetScrollSizes()
{
  <b class="calibre12">CClientDC aDC {this};</b>
  <b class="calibre12">OnPrepareDC(&amp;aDC);                             // Set up the device context</b>
  <b class="calibre12">CSize DocSize {GetDocument()-&gt;GetDocSize()};   // Get the document size</b>
  <b class="calibre12">aDC.LPtoDP(&amp;DocSize);                          // Get the size in pixels</b>
  <b class="calibre12">SetScrollSizes(MM_TEXT, DocSize);              // Set up the scrollbars</b>
}</code></pre>
<p class="calibre13">After creating a local <code class="calibre23">CClientDC</code> object for the view, you call <code class="calibre23">OnPrepareDC()</code> to set up the <code class="calibre23">MM_ANISOTROPIC</code> mapping mode. Because this takes scaling into account, the <code class="calibre23">LPtoDP()</code> member of the <code class="calibre23">aDC</code> object converts the document size stored in the local variable <code class="calibre23">DocSize</code> to the correct number of pixels for the current logical document size and scale. The total document size in pixels defines how large the scrollbars must be in <code class="calibre23">MM_TEXT</code> mode &mdash; remember, <code class="calibre23">MM_TEXT</code> logical coordinates are in pixels. You can then get the <code class="calibre23">SetScrollSizes()</code> member of <code class="calibre23">CScrollView</code> to set up the scrollbars based on this by specifying <code class="calibre23">MM_TEXT</code> as the mapping mode.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="774" id="calibre_link-1236" class="calibre14"></span>It may seem strange that you can change the mapping mode in this way, but it’s important to keep in mind that the mapping mode is nothing more than a definition of how logical coordinates are to be converted to device coordinates. Whatever mode (and therefore coordinate conversion algorithm) you’ve set up applies to all subsequent device context functions until you change it, and you can change it whenever you want. When you set a new mode, subsequent device context function calls just use the conversion algorithm defined by the new mode. You figure out how big the document is in pixels with <code class="calibre23">MM_ANISOTROPIC</code> because this is the only way you can get the scaling into the process; you then switch to <code class="calibre23">MM_TEXT</code> to set up the scrollbars because you need units for this in pixels for it to work properly. Simple really, when you know how.</p>
<section class="toclist">
<h4 class="calibre22">Setting Up the Scrollbars</h4>
<p class="calibre13">You must set up the scrollbars initially for the view in the <code class="calibre23">OnInitialUpdate()</code> member of <code class="calibre23">CSketcherView</code>. Change the previous implementation of the function to the following:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnInitialUpdate()
{
  <b class="calibre12">ResetScrollSizes();                  // Set up the scrollbars</b>
  <b class="calibre12">CScrollView::OnInitialUpdate();</b>
}</code></pre>
<p class="calibre13">All you do is call the <code class="calibre23">ResetScrollSizes()</code> function that you just added to the view. This takes care of everything &mdash; well, almost. The <code class="calibre23">CScrollView</code> object needs an initial extent to be set in order for <code class="calibre23">OnPrepareDC()</code> to work properly, so you need to add one statement to the <code class="calibre23">CSketcherView</code> constructor:</p>
<pre class="calibre28"><code class="calibre23">CSketcherView::CSketcherView()
{
   <b class="calibre12">SetScrollSizes(MM_TEXT, CSize {};</b>   <b class="calibre12">// Set arbitrary scrollers</b>
}</code></pre>
<p class="calibre13">The additional statement just calls <code class="calibre23">SetScrollSizes()</code> with an arbitrary extent to get the scrollbars initialized before the view is drawn. When the view is drawn for the first time, the <code class="calibre23">ResetScrollSizes()</code> function call in <code class="calibre23">OnInitialUpdate()</code>sets up the scrollbars properly. There is nothing else the view constructor needs to do. All the <code class="calibre23">CPoint</code> members are initialized by default and the <code class="calibre23">m_MoveMode</code> and <code class="calibre23">m_Scale</code> members have initial values specified in the class.</p>
<p class="calibre13">Of course, each time the view scale changes, you need to update the scrollbars before the view is redrawn. This is because changing the view scale has the effect of changing the document extent in device coordinates. You can take care of this in the <code class="calibre23">OnViewScale()</code> handler in the <code class="calibre23">CSketcherView</code> class:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnViewScale()
{
  CScaleDialog aDlg;                   // Create a dialog object
  aDlg.m_Scale = m_Scale;              // Pass the view scale to the dialog
  if(aDlg.DoModal() == IDOK)
  <span {http://www.idpf.org/2007/ops}type="pagebreak" title="775" id="calibre_link-1237" class="calibre14"></span>{
    m_Scale = aDlg.m_Scale;            // Get the new scale
    <b class="calibre12">ResetScrollSizes();                // Adjust scrolling to the new scale</b>
    InvalidateRect(nullptr);           // Invalidate the whole window
  }
}</code></pre>
<p class="calibre13">With the <code class="calibre23">ResetScrollSizes()</code> function, taking care of the scrollbars isn’t complicated. Everything is covered by the one additional line of code.</p>
<p class="calibre13">Now you can build the project and run the application. You’ll see that the scrollbars work just as they should. Note that each view maintains its own scale factor, independently of the other views.</p>
<p class="calibre13">That’s all you need in order to scale the view. You can have multiple scrolled views, all at different scales, and what you draw in one view displays at the appropriate scales in the other views.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-369" class="calibre3"></a>WORKING WITH STATUS BARS</h2>
<p class="calibre13">With each view now being scaled independently, there’s a real need to have some indication of what the current scale in a view window is. A convenient way to do this would be to display the scale in the status bar for each view window. A status bar was created by default in the Sketcher main application window, but not in the view windows. Usually, a status bar appears at the bottom of a window, below the horizontal scrollbar, although you can arrange for it to be at the top of the client area. A status bar is divided into segments called <i class="calibre15">panes</i>; the status bar in the main application window in Sketcher has four panes. The one on the left contains the text “Ready,” and the other three are the areas on the right that are used as indicators to record when Caps Lock, Num Lock, and Scroll Lock are in effect.</p>
<p class="calibre13">It’s possible for you to write to the status bar that the Application Wizard supplied by default, but you need access to the <code class="calibre23">m_wndStatusBar</code> member of the <code class="calibre23">CMainFrame</code> object for the application, as this represents it. It’s a <code class="calibre23">protected</code> member of the class, so you must either add a public member function that you can call from outside the class to modify the status bar, or add a member to return a reference to <code class="calibre23">m_wndStatusBar</code>.</p>
<p class="calibre13">You may well have several views of a sketch, each with its own view scale, so you really want each view window to display its own scale. A good approach would be to give each child window its own status bar. The <code class="calibre23">m_wndStatusBar</code> object in <code class="calibre23">CMainFrame</code> is an instance of the <code class="calibre23">CStatusBar</code> class. You can use the same class to implement your own status bars in the view windows.</p>
<section class="toclist">
<h3 class="calibre21">Adding a Status Bar to a Frame</h3>
<p class="calibre13">The <code class="calibre23">CStatusBar</code> class defines a control bar with multiple panes in which you can display information. The first step to using <code class="calibre23">CStatusBar</code> is to add a data member for the status bar to the definition of <code class="calibre23">CChildFrame</code>, which is the frame window for a view. Add the following declaration to the <code class="calibre23">public</code> section of the class:</p>
<pre class="calibre28"><code class="calibre23">  CStatusBar m_StatusBar;              // Status bar object</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="776" id="calibre_link-1238" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">A status bar should be part of the frame, not part of the view. You don’t want to scroll a status bar or draw over it. It should just remain anchored to the bottom of the window. If you were to add a status bar to the view, it would appear inside the scrollbars and would be scrolled whenever you scrolled the view. Drawing over the part of the view containing the status bar would cause the bar to be redrawn, leading to an annoying flicker. Having the status bar as part of the frame avoids all these problems.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<section class="toclist">
<h4 class="calibre22">Creating Status Bar Panes</h4>
<p class="calibre13">To create panes in a status bar, you call the <code class="calibre23">SetIndicators()</code> function for the status bar object. This function requires two arguments, a <code class="calibre23">const</code> array of indicators of type <code class="calibre23">UINT</code> and the number of elements in the array. Each element in the array is a resource symbol that will be associated with a pane in the status bar, and each resource symbol must have an entry in the <i class="calibre15">resource string table</i> that will define the default text in the pane. The IDs for status panes start with <code class="calibre23">ID_INDICATOR_</code> and there are standard resource symbols, such as <code class="calibre23">ID_INDICATOR_CAPS</code> and <code class="calibre23">ID_INDICATOR_NUM</code>, which are used to identify indicators for the Caps Lock and Num Lock keys, respectively. You can see these in use if you look at the implementation of the <code class="calibre23">OnCreate()</code> function in the <code class="calibre23">CMainFrame</code> class. The standard symbols appear in the MFC string table resource so you should take a look at that. Double-click the <code class="calibre23">String Table</code> resource in Resource View and double-click the String Table entry to display the table. The string table for Sketcher is shown in <a id="calibre_link-225" href="#calibre_link-224" class="calibre3">Figure 16-11</a> as a floating window.</p>
<figure class="calibre16">
<img class="center" src="images/000033.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-224" href="#calibre_link-225" class="calibre3">FIGURE 16-11</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><a href="#calibre_link-224" class="calibre3">Figure 16-11</a> shows string table entries for our menu items. Each entry consists of three parts: the ID, the value for the ID, which is a unique integer value, and the string. If you scroll the string table down, you will find the status pane entries for the application window; the first has the ID <code class="calibre23">ID_INDICATOR_EXT</code>. Incidentally, clicking a column-heading in the string table pane will sort the entries in ascending order of that column.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="777" id="calibre_link-1239" class="calibre14"></span>You can create your own entries in the string table for indicator resource symbols. Right-click any entry in the string table and select New String from the menu. Alternatively, just press the Insert key. If you right-click the new entry and select Properties from the menu, you will be able to change its default ID to <code class="calibre23">ID_INDICATOR_SCALE</code> and the caption to <code class="calibre23">View Scale : 1</code>.</p>
<p class="calibre13">You should initialize the <code class="calibre23">m_StatusBar</code> member before the visible view window is displayed. Using the Properties window for the <code class="calibre23">CChildFrame</code> class, you can add a message handler to the class that will be called in response to the <code class="calibre23">WM_CREATE</code> message that is sent to the application when the window is to be created. Add the following code to the <code class="calibre23">OnCreate()</code> handler:</p>
<pre class="calibre28"><code class="calibre23">int CChildFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
  if(CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
    return -1;
 
  <b class="calibre12">// Create the status bar</b>
  <b class="calibre12">m_StatusBar.Create(this);</b>
  <b class="calibre12">static UINT indicators[] {ID_SEPARATOR, ID_INDICATOR_SCALE};</b>
  <b class="calibre12">m_StatusBar.SetIndicators(indicators, _countof(indicators));</b>
  return 0; 
}</code></pre>
<p class="calibre13">The generated code isn’t bolded. There’s a call to the base class version of <code class="calibre23">OnCreate()</code>, which takes care of creating the definition of the view window. It’s important that you don’t delete this function call; otherwise, the window is not created.</p>
<p class="calibre13">Calling the <code class="calibre23">Create()</code> function for the <code class="calibre23">CStatusBar</code> object creates the status bar. You pass the <code class="calibre23">this</code> pointer for the current <code class="calibre23">CChildFrame</code> object to the <code class="calibre23">Create()</code> function, setting up a connection between the status bar and the window that owns it. The indicators that define the panes in the status bar are typically defined as an array of <code class="calibre23">UINT</code> elements. Here you define <code class="calibre23">indicators</code> as an array that is initialized just with the ID for a separator and the symbol for your status pane. When you want to add more panes to a status bar, you can separate them by including <code class="calibre23">ID_SEPARATOR</code> symbols between your symbols in the <code class="calibre23">indicators</code> array. You call the <code class="calibre23">SetIndicators()</code> function for the status bar object with the address of <code class="calibre23">indicators</code> as the first argument and a count of the number of elements in the array as the second argument. Here, this creates a single pane to the right in the status bar.</p>
<p class="calibre13">When the first pane indicator is <code class="calibre23">ID_SEPARATOR</code>, the pane is automatically stretched to align subsequent panes to the right in the status bar. You can call <code class="calibre23">SetPaneStyle()</code> for a pane referenced by its index in the <code class="calibre23">indicators</code> array to set the pane style. The first argument to <code class="calibre23">SetPaneStyle()</code> is the pane index and the second a <code class="calibre23">UINT</code> value specifying the style or styles to be set. Only one pane can have the <code class="calibre23">SBPS_STRETCH</code> style, which stretches the pane to fill the available space in the status bar. Other styles you can set for a pane are as follows:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SBPS_NORMAL</code></td>
<td class="calibre32">No stretch, borders, or pop-out styles set.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SBPS_POPOUT</code></td>
<td class="calibre32">Border reversed, so text pops out.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SBPS_NOBORDERS</code></td>
<td class="calibre32">No 3D borders.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SBPS_DISABLED</code></td>
<td class="calibre32">No text drawn in the pane.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="778" id="calibre_link-1240" class="calibre14"></span>You just OR the styles together when you want to set more than one style for a pane.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Updating the Status Bar</h4>
<p class="calibre13">If you build and run the code now, the status bars appear, but they show only a scale factor of one, no matter what scale factor is actually being used &mdash; not very useful. This is because there is no mechanism in place for updating the status bar. You need to add code somewhere to change the text in the status bar pane each time a different scale is chosen. The obvious place to do this is in the <code class="calibre23">CSketcherView</code> class because that’s where the current view scale is recorded.</p>
<p class="calibre13">You can update a pane in the status bar by adding an <code class="calibre23">UPDATE_COMMAND_UI</code> handler that is associated with the indicator symbol for the pane. Right-click <code class="calibre23">CSketcherView</code> in Class View, and select Class Wizard from the pop-up. This will display the MFC Class Wizard dialog. As you can see, this enables you to create and edit a whole range of functions in a class and provides an alternative way to access any class member.</p>
<p class="calibre13">If it is not already visible, select the Commands tab in the dialog: this enables you to add command handlers to the class. Select <code class="calibre23">ID_INDICATOR_SCALE</code> in the Object IDs pane; this ID identifies the status bar pane you want to update. Then, select <code class="calibre23">UPDATE_COMMAND_UI</code> in the Messages pane. The dialog should look like <a id="calibre_link-227" href="#calibre_link-226" class="calibre3">Figure 16-12</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000080.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-226" href="#calibre_link-227" class="calibre3">FIGURE 16-12</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="779" id="calibre_link-1241" class="calibre14"></span>Click the Add Handler button to add the command handler to the class. Another dialog will be displayed that gives you the opportunity to change the handler function name to <code class="calibre23">OnUpdateScale</code>, which is a little more concise than the default. You can then click OK to close the dialog, and OK again to close the MFC Class Wizard dialog.</p>
<p class="calibre13">All you need is to complete the definition for the handler that was added, so add the following code to the function in <code class="calibre23">SketcherView.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnUpdateScale(CCmdUI *pCmdUI)
{
    <b class="calibre12">pCmdUI-&gt;Enable();</b> 
    <b class="calibre12">CString scaleStr;</b>
    <b class="calibre12">scaleStr.Format(_T(" View Scale : %d"), m_Scale);</b> 
    <b class="calibre12">pCmdUI-&gt;SetText(scaleStr);</b> 
}</code></pre>
<p class="calibre13">The parameter is a pointer to a <code class="calibre23">CCmdUI</code> object that encapsulates the status bar pane as a command target. You create a <code class="calibre23">CString</code> object and call its <code class="calibre23">Format()</code> function to generate the text string to be displayed in the pane. The first argument to <code class="calibre23">Format()</code> is a format control string in which you can embed conversion specifiers for subsequent arguments. The format string with the embedded specifiers is the same as for the C function, <code class="calibre23">printf()</code>. Each of the subsequent arguments is converted according to the corresponding format specifier in the first argument, so there must be one format specifier in the format string for each argument after the first. Here the <code class="calibre23">%d</code> specifier converts the value of <code class="calibre23">m_Scale</code> to a decimal string, and this is incorporated into the format string. Other common specifiers you can use are <code class="calibre23">%f</code> for floating point values and <code class="calibre23">%s</code> for string values. Calling <code class="calibre23">SetText()</code> for the <code class="calibre23">CCmdUI</code> object sets the string you supply as the argument in the status bar pane. Calling <code class="calibre23">Enable()</code> for the <code class="calibre23">CCmdUI</code> object causes the pane text to be displayed normally because the <code class="calibre23">BOOL</code> parameter has a default value of <code class="calibre23">TRUE</code>. An explicit argument of <code class="calibre23">FALSE</code> would make the pane text grayed out.</p>
<p class="calibre13">That’s all you need for the view status bar. If you build Sketcher again, you should have multiple, scrolled windows, each at different scales, with the scale displayed in the status bar in each view.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-370" class="calibre3"></a>THE CString CLASS</h2>
<p class="calibre13">You used a <code class="calibre23">CString</code> object in the previous section, and there’s more to it than you have seen so far. The <code class="calibre23">CString</code> class provides a convenient and easy-to-use mechanism for handling strings that you can use just about anywhere a string is required. To be more precise, you can use a <code class="calibre23">CString</code> object in place of strings of type <code class="calibre23">const TCHAR*</code>, or of type <code class="calibre23">LPCTSTR</code>, which is a type that comes up in Windows API functions. If you are using the DDX mechanism for strings, then you must use <code class="calibre23">CString</code>, otherwise DDX won’t work.</p>
<p class="calibre13">The <code class="calibre23">CString</code> class provides the overloaded operators shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="780" id="calibre_link-1242" class="calibre14"></span><b class="calibre12">OPERATOR</b></th>
<th class="calibre32"><b class="calibre12">USAGE</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">=</code></td>
<td class="calibre32">Copies one string to another, as in:<br class="calibre10" /><code class="calibre23">str1 = str2;</code><br class="calibre10" /><code class="calibre23">str1 = _T("A normal string");</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">+</code></td>
<td class="calibre32">Concatenates two or more strings, as in:<br class="calibre10" /><code class="calibre23">str1 = str2 + str3 + _T(" more");</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">+=</code></td>
<td class="calibre32">Appends a string to an existing <code class="calibre23">CString</code> object, as in:<br class="calibre10" /><code class="calibre23">str1 += str2</code>;</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">==</code></td>
<td class="calibre32">Compares two strings for equality, as in:<br class="calibre10" /><code class="calibre23">if(str1 == str2) // do something...</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&lt;</code></td>
<td class="calibre32">Tests if one string is less than another.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&lt;=</code></td>
<td class="calibre32">Tests if one string is less than or equal to another.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&gt;</code></td>
<td class="calibre32">Tests if one string is greater than another.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">&gt;=</code></td>
<td class="calibre32">Tests if one string is greater than or equal to another.</td>
</tr>
</tbody>
</table>
<p class="calibre13">The variables <code class="calibre23">str1</code> and <code class="calibre23">str2</code> in the preceding table are <code class="calibre23">CString</code> objects.</p>
<p class="calibre13"><code class="calibre23">CString</code> objects automatically grow as necessary, such as when you add an additional string to the end of an existing object. For example:</p>
<pre class="calibre28"><code class="calibre23">CString str {_T("A fool and your money")};
str += _T(" are soon partners.");</code></pre>
<p class="calibre13">The first statement declares and initializes the object <code class="calibre23">str</code>. The second statement appends an additional string to <code class="calibre23">str</code>, so the length of <code class="calibre23">str</code> automatically increases.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-371" class="calibre3"></a>USING AN EDIT BOX CONTROL</h2>
<p class="calibre13">An edit box control is for managing text entry to an application. You will use an edit box control to add annotations to a sketch in Sketcher. You’ll need a new Sketcher element type, <code class="calibre23">CText</code>, that encapsulates a text string, and a menu item in the Element menu to set <code class="calibre23">TEXT</code> mode for creating elements. Because a text element needs only one reference point, you can create it in the <code class="calibre23">OnLButtonDown()</code> handler in the view class. You’ll add this text capability to Sketcher in the following sequence:</p>
<ol class="calibre5">
<li class="calibre6">Create a dialog resource and its associated class with an edit box control for input.</li>
<li class="calibre6">Add the new menu item.</li>
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="781" id="calibre_link-1243" class="calibre14"></span>Add the code to open the dialog for creating a <code class="calibre23">CText</code> element.</li>
<li class="calibre6">Add support for creating <code class="calibre23">CText</code> elements.</li>
</ol>
<section class="toclist">
<h3 class="calibre21">Creating an Edit Box Resource</h3>
<p class="calibre13">Create a new dialog resource in Resource View by right-clicking the Dialog folder and selecting Insert Dialog. Change the ID for the new dialog to <code class="calibre23">IDD_TEXT_DLG</code>, and the Caption property value for the dialog to Enter Text.</p>
<p class="calibre13">To add an edit box, select the Edit Control icon in the Toolbox pane and click the position in the dialog where you want to place it. You can adjust the size of the edit control by dragging its borders, and you can alter its position in the dialog by dragging the whole thing around. You can display the properties for the edit box by right-clicking it and selecting Properties from the pop-up. You could first change its ID to <code class="calibre23">IDC_EDIT_TEXT</code>, as shown in <a id="calibre_link-229" href="#calibre_link-228" class="calibre3">Figure 16-13</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000039.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-228" href="#calibre_link-229" class="calibre3">FIGURE 16-13</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Some of the properties for this control are of interest at this point. First, select the <code class="calibre23">Multiline</code> property. Setting the value for this as <code class="calibre23">True</code> creates a multiline edit box in which the text you enter can span more than one line. This enables you to enter a long line of text that will still remain visible in its entirety in the edit box. The <code class="calibre23">Align text</code> property determines how the text is to be positioned in the multiline edit box. The value <code class="calibre23">Left</code> is fine here, but you also have the options for <code class="calibre23">Center</code> and <code class="calibre23">Right</code>.</p>
<p class="calibre13">If you were to change the value for the <code class="calibre23">Want return</code> property to <code class="calibre23">True</code>, pressing Enter on the keyboard while entering the text in the control would insert a return character into the text string. This enables you to analyze the string if you want to break it into multiple lines for display. You don’t want this effect, so leave the property value as <code class="calibre23">False</code>. In this state, pressing Enter has the effect of selecting the default control (which is the OK button), which closes the dialog.</p>
<p class="calibre13">If you set the value of the <code class="calibre23">Auto HScroll</code> property to <code class="calibre23">False</code>, there is an automatic spill to the next line in the edit box when you reach the edge of the control while entering text. However, this is just for visibility in the edit box &mdash; it has no effect on the contents of the string. You could also change the value of the <code class="calibre23">Auto VScroll</code> property to <code class="calibre23">True</code> to allow text to continue beyond the number of lines that are visible in the control. If you set the <code class="calibre23">Vertical Scroll</code> property to <code class="calibre23">True</code>, the edit control will be supplied with a scrollbar that will allow you to scroll the text.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="782" id="calibre_link-1244" class="calibre14"></span>When you’ve finished setting the properties for the edit box, close its Properties window. Make sure that the edit box is first in the tab order by selecting the Format <img src="images/000122.png" alt="image" class="calibre25" /> Tab Order menu item or by pressing Ctrl+D. You can then test the dialog by selecting the Test Dialog menu item or by pressing Ctrl+T. The dialog is shown in <a id="calibre_link-231" href="#calibre_link-230" class="calibre3">Figure 16-14</a>. You can even enter text into the dialog in test mode to see how it works. Clicking the OK or Cancel button closes the dialog.</p>
<figure class="calibre16">
<img class="center" src="images/000172.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-230" href="#calibre_link-231" class="calibre3">FIGURE 16-14</a></b></span></p>
</figcaption>
</figure>
</section>
<section class="toclist">
<h3 class="calibre21">Creating the Dialog Class</h3>
<p class="calibre13">After saving the dialog resource, you can create a suitable dialog class corresponding to the resource, which you could call <code class="calibre23">CTextDialog</code>. To do this, right-click the dialog in the Editor pane and select Add Class. The base class should be <code class="calibre23">CDialogEx</code>. Next you can add a control variable to the <code class="calibre23">CTextDialog</code> class by right-clicking the class name in Class View and selecting Add <img src="images/000122.png" alt="image" class="calibre25" /> Add Variable. Select <code class="calibre23">IDC_EDIT_TEXT</code> as the control ID and <code class="calibre23">Value</code> as the category. Call the new variable <code class="calibre23">m_TextString</code> and leave its type as <code class="calibre23">CString</code>. You can also specify a maximum length for it in the <code class="calibre23">Max chars</code> edit box, as shown in <a id="calibre_link-233" href="#calibre_link-232" class="calibre3">Figure 16-15</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000048.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-232" href="#calibre_link-233" class="calibre3">FIGURE 16-15</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="783" id="calibre_link-1245" class="calibre14"></span>A length of 100 is more than adequate for your needs. The variable that you have added here is automatically updated from the data entered into the control by the DDX mechanism. You can click Finish to create the variable in the <code class="calibre23">CTextDialog</code> class, and close the Add Member Variable wizard.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">As I said earlier, the DDX mechanism does not support strings of type</i> <code class="calibre23">std::string</code> <i class="calibre15">so you must use type</i> <code class="calibre23">CString</code> <i class="calibre15">here.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">Adding the Text Menu Item</h3>
<p class="calibre13">Adding a new menu item should be easy by now. You just need to open the menu resource with the ID <code class="calibre23">IDR_SketchTYPE</code> in Resource View by double-clicking it, and add a new menu item, Text, to the Element menu. The default ID, <code class="calibre23">ID_ELEMENT_TEXT</code>, that appears in the Properties window for the item is fine, so you can leave that as it is. You can add a prompt to be displayed on the status bar corresponding to the menu item, and because you’ll also want to add an additional toolbar button corresponding to this menu item, you can add a tooltip to the end of the prompt line, using <code class="calibre23">\n</code> to separate the prompt and the tooltip.</p>
<p class="calibre13">Don’t forget the context menu. You can copy the menu item from <code class="calibre23">IDR_SketchTYPE</code>. Right-click the Text menu item and select Copy from the pop-up. Open the menu <code class="calibre23">IDR_CONTEXT_MENU</code>, right-click the empty item at the bottom of the no element menu, and select Paste. All you need to do then is drag the item to the appropriate position &mdash; above the separator &mdash; and save the resource file.</p>
<p class="calibre13">Add the toolbar button to the <code class="calibre23">IDR_MAINFRAME</code> toolbar and set its ID to the same as that for the menu item, <code class="calibre23">ID_ELEMENT_TEXT</code>. You can drag the new button so that it’s positioned at the end of the block defining the other types of elements. When you’ve saved the resources, you can add an event handler for the new menu item.</p>
<p class="calibre13">You need a new type for <code class="calibre23">CText</code> elements so add a <code class="calibre23">TEXT</code> enumerator to the <code class="calibre23">ElementType</code> enum:</p>
<pre class="calibre28"><code class="calibre23">enum class ElementType{LINE, RECTANGLE, CIRCLE, CURVE, TEXT};</code></pre>
<p class="calibre13">In the Class View pane, right-click <code class="calibre23">CSketcherDoc</code> and display its Properties window. Add a <code class="calibre23">COMMAND</code> handler for the event corresponding to the <code class="calibre23">ID_ELEMENT_TEXT</code> ID and add code to it as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnElementText()
{
  <b class="calibre12">m_Element = ElementType::TEXT;</b>
}</code></pre>
<p class="calibre13">Only one line of code is necessary to set the element type in the document to <code class="calibre23">ElementType::TEXT</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="784" id="calibre_link-1246" class="calibre14"></span>You also need to add a function to check the menu item if it is the current mode, so add an <code class="calibre23">UPDATE_COMMAND_UI</code> handler corresponding to the event for the <code class="calibre23">ID_ELEMENT_TEXT</code> ID, and implement the code for it as follows:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnUpdateElementText(CCmdUI* pCmdUI)
{
  <b class="calibre12">// Set checked if the current element is text</b>
  <b class="calibre12">pCmdUI-&gt;SetCheck(m_Element == ElementType::TEXT);</b>
}</code></pre>
<p class="calibre13">This operates in the same way as the other Element menu items. Of course, you could also have added both of these handlers through the Class Wizard dialog that you display by selecting Class Wizard from the context menu in Class View.</p>
<p class="calibre13">Don’t forget that the context menu needs updating too. Add code to the <code class="calibre23">OnContextMenu()</code> member of <code class="calibre23">CSketcherView</code> to check the Text menu item. The next step is to define the <code class="calibre23">CText</code> class for an element of type <code class="calibre23">TEXT</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Defining a Text Element</h3>
<p class="calibre13">You can derive the <code class="calibre23">CText</code> class from the <code class="calibre23">CElement</code> class as follows:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
#include &lt;memory&gt;
#include "Element.h"
 
// Class defining a text element
class CText : public CElement
{
public:
  // Constructor for a text element
  CText(const CPoint&amp; start, const CPoint&amp; end,
                              const CString&amp; aString, COLORREF color);
 
  virtual void Draw(CDC* pDC,
               std::shared_ptr&lt;CElement&gt; pElement=nullptr) override;    
  virtual void Move(const CSize&amp; aSize) override;  // Move a text element
  virtual ~CText() {}
 
protected:
    CString m_String;                             // Text to be displayed
    CText(){}
};</code></pre>
<p class="calibre13">I added this manually but I’ll leave it to you to decide how you want to do it. This class definition declares the virtual <code class="calibre23">Draw()</code> and <code class="calibre23">Move()</code> functions, as the other element classes do. The data member <code class="calibre23">m_String</code> of type <code class="calibre23">CString</code> stores the text to be displayed.</p>
<p class="calibre13">The <code class="calibre23">CText</code> constructor declaration defines four parameters: the two points defining the rectangle in which the text is to be displayed, the string to be displayed, and the color. The pen width doesn’t apply to text, because the appearance is determined by the font.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="785" id="calibre_link-1247" class="calibre24"></span>Implementing the CText Class</h3>
<p class="calibre13">You have three functions to implement for the <code class="calibre23">CText</code> class:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The constructor for a <code class="calibre23">CText</code> object</li>
<li class="calibre6">The virtual <code class="calibre23">Draw()</code> function to display it</li>
<li class="calibre6">The virtual <code class="calibre23">Move()</code> function to support moving a text object by dragging it with the mouse</li>
</ul>
<p class="calibre13">I added these directly to the <code class="calibre23">Text.cpp</code> file.</p>
<section class="toclist">
<h4 class="calibre22">The CText Constructor</h4>
<p class="calibre13">The constructor for a <code class="calibre23">CText</code> object needs to initialize the class and base class data members:</p>
<pre class="calibre28"><code class="calibre23">// CText constructor
CText::CText(const CPoint&amp; start, const CPoint&amp; end,
             const CString&amp; aString, COLORREF color) :
                                         CElement {start, color}
{
  m_String = aString;                  // Store the string
        
  m_EnclosingRect = CRect {start, end};
  m_EnclosingRect.NormalizeRect();
  m_EnclosingRect.InflateRect(m_PenWidth, m_PenWidth);
}</code></pre>
<p class="calibre13">The base class constructor call stores the <code class="calibre23">start</code> point and the color and initializes the pen width to 1 by default. You calculate the rectangle that will enclose the string when it is displayed from the <code class="calibre23">start</code> and <code class="calibre23">end</code> points.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Creating a Text Element</h4>
<p class="calibre13">If the element type has been set to <code class="calibre23">ElementType::TEXT</code>, a text object should be created at the cursor position whenever you click the left mouse button and enter the text you want to display. You therefore need to display the dialog that permits text to be entered in the <code class="calibre23">OnLButtonDown()</code> handler, but only when the element type is <code class="calibre23">ElementType::TEXT</code>. Add the following code to this handler in the <code class="calibre23">CSketcherView</code> class:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
  CClientDC aDC {this};                               // Create a device context
  OnPrepareDC(&amp;aDC);                                  // Get origin adjusted
  aDC.DPtoLP(&amp;point);                                  // convert point to Logical
  <b class="calibre12">CSketcherDoc* pDoc {GetDocument()};</b>                 <b class="calibre12">// Get a document pointer</b>

  if(m_MoveMode)
  { // In moving mode, so drop the element
    m_MoveMode = false;                               // Kill move mode
    auto pElement(m_pSelected);                      // Store selected address
    m_pSelected.reset();                              // De-select the element
    <span {http://www.idpf.org/2007/ops}type="pagebreak" title="786" id="calibre_link-1248" class="calibre14"></span><b class="calibre12">pDoc-&gt;UpdateAllViews(nullptr, 0, pElement.get());  // Redraw all the views</b>
  }
  <b class="calibre12">else if(pDoc-&gt;GetElementType() == ElementType::TEXT)</b>
  <b class="calibre12">{</b>
    <b class="calibre12">CTextDialog aDlg;</b>
    <b class="calibre12">if(aDlg.DoModal() == IDOK)</b>
    <b class="calibre12">{ // Exit OK so create a text element</b>
      <b class="calibre12">CSize textExtent {aDC.GetOutputTextExtent(aDlg.m_TextString)};</b>
      <b class="calibre12">textExtent.cx *= m_Scale;</b>
      <b class="calibre12">textExtent.cy *= m_Scale;</b>
      <b class="calibre12">std::shared_ptr&lt;CElement&gt; pTextElement</b> 
          <b class="calibre12">{std::make_shared&lt;CText&gt;(point, point + textExtent, aDlg.m_TextString,</b>
                                <b class="calibre12">static_cast&lt;COLORREF&gt;(pDoc-&gt;GetElementColor()))};</b>
      
      <b class="calibre12">pDoc-&gt;AddElement(pTextElement); // Add the element to the document</b>
      <b class="calibre12">pDoc-&gt;UpdateAllViews(nullptr, 0, pTextElement.get());   // Update all views</b>
    <b class="calibre12">}</b>
  <b class="calibre12">}</b>
  else
  {
   m_FirstPoint = point;              // Record the cursor position
   SetCapture();                      // Capture subsequent mouse messages
  }
}</code></pre>
<p class="calibre13">The code to be added is bolded. It creates a <code class="calibre23">CTextDialog</code> object and then opens the dialog using the <code class="calibre23">DoModal()</code> function call. The <code class="calibre23">m_TextString</code> member of <code class="calibre23">aDlg</code> is automatically set to the string entered in the edit box via the DDX mechanism, so you can use this data member to pass the string entered back to the <code class="calibre23">CText</code> constructor if the OK button was used to close the dialog. The color is obtained from the document using the <code class="calibre23">GetElementColor()</code> member that you have used previously.</p>
<p class="calibre13">You need to determine the corners of the rectangle that bounds the text in the client area of the view and this is a bit more complicated than with the geometric elements. The size of the rectangle that will enclose a string when you display it depends on the font used in the device context, as well as the number of characters in the string. You need the help of the device context object to figure this out. The <code class="calibre23">GetOuputTextExtent()</code> member of the <code class="calibre23">CClientDC</code> object, <code class="calibre23">aDC</code>, returns a <code class="calibre23">CSize</code> object that defines what the width and height of the string you pass as the argument will be. This is calculated using characters from the current font for the device context. The dimensions are in logical coordinates, which is just what you need. You store the <code class="calibre23">CSize</code> object that is returned in <code class="calibre23">textExtent</code>.</p>
<p class="calibre13">The drawing scale adds a further complication. The text will be drawn at a given font size that is not affected by the scale. If the current drawing scale is greater than one, you must adjust <code class="calibre23">textExtent</code> in the same proportion, otherwise the enclosing rectangle for the text will not be large enough at lower scales. You do this by multiplying the <code class="calibre23">cx</code> and <code class="calibre23">cy</code> members of <code class="calibre23">textExtent</code> by the scale.</p>
<p class="calibre13">The left-top corner of the rectangle enclosing the string will be <code class="calibre23">point</code>, which is already in logical coordinates. You get the right-bottom corner by adding the dimensions in <code class="calibre23">textExtent</code> to <code class="calibre23">point</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="787" id="calibre_link-1249" class="calibre14"></span>The <code class="calibre23">CText</code> object is created using the <code class="calibre23">make_shared&lt;T&gt;()</code> function because the list in the document stores <code class="calibre23">shared_ptr&lt;CElement&gt;</code> pointers to the elements. You can store a pointer of type <code class="calibre23">shared_ptr&lt;CText&gt;</code> in a <code class="calibre23">shared_ptr&lt;CElement&gt;</code> variable because <code class="calibre23">CText</code> is derived from <code class="calibre23">CElement</code>. You add the new element to the document by calling the <code class="calibre23">AddElement()</code> member of <code class="calibre23">CSketcherDoc</code>, with the pointer to the new text element as an argument. Finally, <code class="calibre23">UpdateAllViews()</code> is called with the first argument <code class="calibre23">nullptr</code>, which specifies that all views are to be updated. Don’t forget that you need <code class="calibre23">#include</code> directives for <code class="calibre23">TextDialog.h</code> and <code class="calibre23">Text.h</code> in <code class="calibre23">SketcherView.cpp</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Drawing a CText Object</h4>
<p class="calibre13">Drawing text in a device context is different from drawing a geometric figure. The implementation of the <code class="calibre23">Draw()</code> function for a <code class="calibre23">CText</code> object is:</p>
<pre class="calibre28"><code class="calibre23">void CText::Draw(CDC* pDC, std::shared_ptr&lt;CElement&gt; pElement)
{
  // Set the text color and output the text
  pDC-&gt;SetTextColor(this == pElement.get() ? SELECT_COLOR : m_Color);
  pDC-&gt;SetBkMode(TRANSPARENT);             // Transparent background for text
  pDC-&gt;ExtTextOut(m_StartPoint.x, m_StartPoint.y, 0,
                                                 nullptr, m_String, nullptr);
}</code></pre>
<p class="calibre13">You don’t need a pen to display text. You have a choice of several functions in the CDC class that output text and in our case the simplest to use is <code class="calibre23">ExtTextOut()</code>. With this function you can specify a rectangle in which the text is to be displayed as well as other options that affect character spacing and the way in which the text is displayed in the rectangle. These are the parameters in sequence for one of the two versions of this function:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">PARAMETER</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int x</code></td>
<td class="calibre32">Logical x-coordinate of the first character in the string.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int y</code></td>
<td class="calibre32">Logical y-coordinate of the first character in the string.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">UINT options</code></td>
<td class="calibre32">Either, neither, or both of the flags:</td>
</tr>
<tr class="calibre31">
<td class="calibre32">&nbsp;</td>
<td class="calibre32"><code class="calibre23">ETO_CLIPPED</code>: string is clipped to <code class="calibre23">pRect</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32">&nbsp;</td>
<td class="calibre32"><code class="calibre23">ETO_OPAQUE</code>: current background color fills <code class="calibre23">pRect</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPCRECT pRect</code></td>
<td class="calibre32">Rectangle that determines the dimensions of the rectangle in which the text is displayed (It’s location is specified by x and y). This can be <code class="calibre23">nullptr</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">const CString&amp; str</code></td>
<td class="calibre32">The string to be displayed.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LPINT widths</code></td>
<td class="calibre32">Pointer to an array of integers specifying distances between characters in the string. <code class="calibre23">nullptr</code> will select default spacing.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="788" id="calibre_link-1250" class="calibre14"></span>We have ignored all these options and just supplied the coordinates of where the text is to be displayed and the <code class="calibre23">CString</code> object that contains the text.</p>
<p class="calibre13">Before calling <code class="calibre23">ExtTextOut()</code>, you specify the text color using the <code class="calibre23">SetTextColor()</code> member function of the <code class="calibre23">CDC</code> object. You also call <code class="calibre23">SetBkMode()</code> to ensure the background to the string is transparent. An <code class="calibre23">OPAQUE</code> argument value would make the background opaque.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Moving a CText Object</h4>
<p class="calibre13">The <code class="calibre23">Move()</code> function for a <code class="calibre23">CText</code> object is simple:</p>
<pre class="calibre28"><code class="calibre23">void CText::Move(const CSize&amp; size)
{
  m_EnclosingRect += size;            // Move the rectangle
  m_StartPoint += size;               // Move the reference point
}</code></pre>
<p class="calibre13">All you need to do is alter the enclosing rectangle by the distance specified in the <code class="calibre23">size</code> parameter and adjust the <code class="calibre23">m_StartPoint</code> member by the same amount.</p>
<p class="calibre13">Because the <code class="calibre23">ExtTextOut ()</code> function for a <code class="calibre23">CDC</code> object doesn’t use a pen, it isn’t affected by setting the drawing mode of the device context. This means that the raster operations (ROP) method that you use to move geometric elements leaves trails behind when applied to text. You used the <code class="calibre23">SetROP2()</code> function to specify the way in which the pen would logically combine with the background. By choosing <code class="calibre23">R2_NOTXORPEN</code> as the drawing mode, you could cause a previously drawn element to disappear by redrawing it. Fonts aren’t drawn with a pen, so it won’t work properly with the text elements.</p>
<p class="calibre13">To fix the trails problem when moving a text element, you can treat it as a special case in the <code class="calibre23">MoveElement()</code> function in <code class="calibre23">CSketcherView</code>. Providing an alternative move mechanism for text elements requires that you can discover when the <code class="calibre23">m_pSelected</code> pointer contains the address of a <code class="calibre23">CText</code> object. The <code class="calibre23">typeid</code> operator that you met back in Chapter 2 can help with this.</p>
<p class="calibre13">By comparing the expression <code class="calibre23">typeid(*(m_pSelected.get()))</code> with <code class="calibre23">typeid(CText)</code>, you can determine whether or not <code class="calibre23">m_pSelected</code> points to a <code class="calibre23">CText</code> object. Here’s how you can update <code class="calibre23">MoveElement()</code> to eliminate the trails when moving text:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::MoveElement(CClientDC&amp; aDC, const CPoint&amp; point)
{
  CSize distance {point - m_CursorPos};                // Get move distance
  m_CursorPos = point;          // Set current point as 1st for next time
 
  // If there is an element selected, move it
  if(m_pSelected)
  {
    CSketcherDoc* pDoc {GetDocument()};                  // Get the document pointer
    pDoc-&gt;UpdateAllViews(this, 0 , m_pSelected.get());
 
    <b class="calibre12">if (typeid(*(m_pSelected.get())) == typeid(CText))</b>
    <b class="calibre12">{ // The element is text so use this method...</b>
      <b class="calibre12">CRect oldRect {m_pSelected-&gt;GetEnclosingRect()};</b>   <b class="calibre12">// Get old bound rect</b>
      <span {http://www.idpf.org/2007/ops}type="pagebreak" title="789" id="calibre_link-1251" class="calibre14"></span><b class="calibre12">aDC.LPtoDP(oldRect);</b>                         <b class="calibre12">// Convert to client coords</b>
      <b class="calibre12">m_pSelected-&gt;Move(distance);</b>                 <b class="calibre12">// Move the element</b>
      <b class="calibre12">InvalidateRect(&amp;oldRect);</b>                  

      <b class="calibre12">UpdateWindow();</b>                              <b class="calibre12">// Redraw immediately</b>
      <b class="calibre12">m_pSelected-&gt;Draw(&amp;aDC,m_pSelected);</b>         <b class="calibre12">// Draw highlighted</b>
    <b class="calibre12">}</b>
    <b class="calibre12">else</b>
    <b class="calibre12">{ // ...it is not text so use the ROP method</b>
      aDC.SetROP2(R2_NOTXORPEN);
      m_pSelected-&gt;Draw(&amp;aDC, m_pSelected);         // Draw the element to erase it
      m_pSelected-&gt;Move(distance);                  // Now move the element
      m_pSelected-&gt;Draw(&amp;aDC, m_pSelected);         // Draw the moved element
    <b class="calibre12">}</b>
    pDoc-&gt;UpdateAllViews(this, 0 , m_pSelected.get());
  }
}</code></pre>
<p class="calibre13">You use the <code class="calibre23">typeid</code> operator to check whether or not <code class="calibre23">m_pSelected</code> points to a <code class="calibre23">CText</code> element. If <code class="calibre23">m_pSelected</code> does not point to a <code class="calibre23">CText</code> element, the code proceeds as before. When <code class="calibre23">m_pSelected</code> does point to a <code class="calibre23">CText</code> element, you obtain the bounding rectangle in the current view for the position of the element before moving it to its new position. You convert the rectangle to client coordinates because that’s what <code class="calibre23">InvalidateRect()</code> expects as an argument. You call <code class="calibre23">InvalidateRect()</code> and <code class="calibre23">UpdateWindow()</code> after the move to erase the element from its old position. Finally, you call <code class="calibre23">Draw()</code> for the text element to draw the element in its new position. The other views are taken care of by the calls to <code class="calibre23">UpdateAllViews()</code> for the document object, as before. You should now be able to produce annotated sketches using multiple scaled and scrolled views, such as the ones shown in <a id="calibre_link-235" href="#calibre_link-234" class="calibre3">Figure 16-16</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000011.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-234" href="#calibre_link-235" class="calibre3">FIGURE 16-16</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="790" id="calibre_link-1252" class="calibre14"></span>You can see that the text does not scale along with the shapes. You could scale the text by adjusting the font size in the device context based on the scale. This would involve creating a font of the appropriate point size based on the scale, and doing this whenever a <code class="calibre23">CText</code> element was drawn or redrawn. However, it’s probably better to leave text elements at the font size with which they were created.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-372" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter you’ve seen several different dialogs using a variety of controls. Although you haven’t created dialogs involving several different controls at once, the mechanism for handling them is the same as what you have seen, because each control can operate independently of the others. Dialogs are a fundamental tool for managing user input in an application. They provide a way for you to manage the input of multiple related items of data. You can easily ensure that an application only receives valid data. Judicious choice of the controls in a dialog can force the user to choose from a specific set of options. You can also check the data after it has been entered in a dialog and prompt the user when it is not valid.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Implement the scale dialog in Sketcher using radio buttons.</li>
<li class="calibre6">Implement the pen width dialog in Sketcher using a list box.</li>
<li class="calibre6">Implement the pen width dialog in Sketcher as a combo box with the drop list type selected as the Type property. (The drop list type allows the user to select from a drop-down list but not to enter alternative entries in the list.)</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="791" id="calibre_link-1253" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Status bars</b></td>
<td class="calibre32">The <code class="calibre23">CStatusBar</code> class encapsulates a status bar that can have multiple panes. You add a status bar to a window by adding it to the frame.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Dialogs</b></td>
<td class="calibre32">A dialog involves two components: a resource defining the dialog window and its controls, and a class that is used to display and manage the dialog. Dialog classes are typically derived from <code class="calibre23">CDialogEx</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Extracting data from a dialog</b></td>
<td class="calibre32">Information can be extracted from controls in a dialog by means of the DDX mechanism. The data can also be validated with the DDV mechanism. To use DDX/DDV you need only to select the Control Variable option for the Add Member Variable wizard to define a variable in the dialog class that is associated with a control. The associated control is identified by its ID.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Modal dialogs</b></td>
<td class="calibre32">A modal dialog retains the focus in the application until the dialog is closed. As long as a modal dialog is displayed, all other windows in an application are inactive.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Modeless dialogs</b></td>
<td class="calibre32">A modeless dialog allows the focus to switch from the dialog to other windows in the application and back again. A modeless dialog can remain displayed as long as the application is executing, if required.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Common controls</b></td>
<td class="calibre32">Common controls are a set of standard Windows controls supported by MFC and the resource editing capabilities of Visual Studio.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Adding controls</b></td>
<td class="calibre32">Although controls are usually associated with a dialog, you can add controls to any window.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Displaying a dialog</b></td>
<td class="calibre32">You can display a dialog as modal by calling its <code class="calibre23">DoModal()</code>function.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Edit boxes</b></td>
<td class="calibre32">An edit box control allows entry of one or more lines of text. The text can be optionally scrolled vertically and/or horizontally.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="792" id="calibre_link-1254" class="calibre14"></span></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-135">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2330" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="793" id="calibre_link-1255" class="calibre9"></span><span class="chapternumber">Chapter 17</span><br class="calibre10" /><span class="chapternumber">Storing and Printing Documents</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How serialization works</li>
<li class="calibre6">How to make objects of a class serializable</li>
<li class="calibre6">The role of a <code class="calibre23">CArchive</code> object in serialization</li>
<li class="calibre6">How to implement serialization in your own classes</li>
<li class="calibre6">How to implement serialization in the Sketcher application</li>
<li class="calibre6">How printing works with MFC</li>
<li class="calibre6">Which view class functions support printing</li>
<li class="calibre6">What a <code class="calibre23">CPrintInfo</code> object contains and how it’s used in the printing process</li>
<li class="calibre6">How to implement multipage printing in Sketcher</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 17 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-373" class="calibre3"></a>UNDERSTANDING SERIALIZATION</h2>
<p class="calibre13">A document in an MFC-based program is not a simple entity &mdash; it’s a class object that can be very complicated. It typically contains a variety of objects, each of which may contain other objects, each of which may contain still more objects and that structure may continue for a number of levels.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="794" id="calibre_link-1256" class="calibre14"></span>You want to be able to save a document in a file, but writing a class object to a file represents something of a problem because it isn’t the same as a basic data item like an integer or a character string. A basic data item consists of a known number of bytes, so to write it to a file only requires that the appropriate number of bytes be written. Conversely, if you know a value of type <code class="calibre23">int</code> was written to a file, to get it back, you just read the appropriate number of bytes.</p>
<p class="calibre13">Writing objects to a file is different. Even if you write all the data members of an object to a file, that’s not enough to be able to get the original object back. Class objects contain members function as well as data members, and all the members, both data and functions, have access specifiers; therefore, to record an object in an external file, the information that is written to the file must contain complete specifications of all the class structures involved. The read process must also be clever enough to synthesize the original objects completely from the data in the file. MFC supports a mechanism called <i class="calibre15">serialization</i> to help you to implement input and output of your class objects with a minimum of time and effort.</p>
<p class="calibre13">The basic idea behind serialization is that any class that’s serializable should take care of storing and retrieving itself. This means that for your classes to be serializable &mdash; in the case of the Sketcher application, this will include the <code class="calibre23">CElement</code> class and the element classes you have derived from it &mdash; they must be able to write themselves to a file. This implies that for a class to be serializable, all the class types that are used to declare data members of the class must be serializable too.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-374" class="calibre3"></a>SERIALIZING A DOCUMENT</h2>
<p class="calibre13">This all sounds rather tricky, but the basic capability for serializing your document was built into the application by the Application Wizard right at the outset. The handlers for the File <img src="images/000122.png" alt="image" class="calibre25" /> Save, File <img src="images/000122.png" alt="image" class="calibre25" /> Save As, and File <img src="images/000122.png" alt="image" class="calibre25" /> Open menu items all assume that you want serialization implemented for your document, and already contain the code to support it. Take a look at the parts of the definition and implementation of <code class="calibre23">CSketcherDoc</code> that relate to creating a document using serialization.</p>
<section class="toclist">
<h3 class="calibre21">Serialization in the Document Class Definition</h3>
<p class="calibre13">The code in the definition of <code class="calibre23">CSketcherDoc</code> that enables serialization of a document object is shown shaded in the following fragment:</p>
<pre class="calibre28"><code class="calibre23">class CSketcherDoc : public CDocument
{
protected: // create from serialization only
   <b class="calibre12">CSketcherDoc();</b>
   <b class="calibre12">DECLARE_DYNCREATE(CSketcherDoc)</b>
        
// Rest of the class...
        
// Overrides
public:
   virtual BOOL OnNewDocument();
   <b class="calibre12">virtual void Serialize(CArchive&amp; ar);</b>
        
// Rest of the class...
        
};</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="795" id="calibre_link-1257" class="calibre14"></span>There are three things here that relate to serializing a document object:</p>
<ol class="calibre5">
<li class="calibre6">The <code class="calibre23">DECLARE_DYNCREATE()</code> macro.</li>
<li class="calibre6">The <code class="calibre23">Serialize()</code> member function.</li>
<li class="calibre6">The default class constructor.</li>
</ol>
<p class="calibre13"><code class="calibre23">DECLARE_DYNCREATE()</code> is a macro that enables objects of the <code class="calibre23">CSketcherDoc</code> class to be created dynamically by the application framework during the serialization input process. It’s matched by a complementary macro, <code class="calibre23">IMPLEMENT_DYNCREATE()</code>, in the class implementation. These macros apply only to classes derived from <code class="calibre23">CObject</code>, but as you will see shortly, they aren’t the only pair of macros that can be used in this context. For any class that you want to serialize, <code class="calibre23">CObject</code> must be a direct or indirect base because it adds the functionality that enables serialization to work. This is why the <code class="calibre23">CElement</code> class was derived from <code class="calibre23">CObject</code>. Almost all MFC classes are derived from <code class="calibre23">CObject</code> and are serializable.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The Hierarchy Chart in the Microsoft Foundation Class Reference for Visual C++ shows those classes, that are not derived from</i> <code class="calibre23">CObject</code>. <i class="calibre15">Note that</i> <code class="calibre23">CArchive</code> <i class="calibre15">is in this list</i>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The <code class="calibre23">CSketcherDoc</code> class definition also includes a declaration for a virtual function <code class="calibre23">Serialize()</code>. Every class that’s serializable must include this function. It’s called to perform both input and output serialization operations on the data members of the class. The object of type <code class="calibre23">CArchive</code> that’s passed as an argument determines whether the operation that is to occur is input or output. You’ll explore this in more detail when considering the implementation of serialization for the document class.</p>
<p class="calibre13">Note that the class explicitly defines a default constructor. This is also essential for serialization to work because the default constructor is used by the framework to synthesize an object when reading it from a file. The synthesized object produced by the no-arg constructor is filled out with the data from the file to set the values of the data members of the object.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Serialization in the Document Class Implementation</h3>
<p class="calibre13">There are two bits of the <code class="calibre23">SketcherDoc.cpp</code> file that relate to serialization. The first is the <code class="calibre23">IMPLEMENT_DYNCREATE()</code> macro that complements the <code class="calibre23">DECLARE_DYNCREATE()</code> macro:</p>
<pre class="calibre28"><code class="calibre23">// SketcherDoc.cpp : implementation of the CSketcherDoc class
//
        
#include "stdafx.h"
// SHARED_HANDLERS can be defined in an ATL project implementing preview, 
// thumbnail and search filter handlers and allows sharing of document code
// with that project.
#ifndef SHARED_HANDLERS
#include "Sketcher.h"
#endif
        
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="796" id="calibre_link-1258" class="calibre14"></span>#include "SketcherDoc.h"
#include "PenDialog.h"
        
#include &lt;propkey.h&gt;
        
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
        
// CSketcherDoc
        
        
<b class="calibre12">IMPLEMENT_DYNCREATE(CSketcherDoc, CDocument)</b>
        
// Message map and the rest of the file...</code></pre>
<p class="calibre13">This macro defines the base class for <code class="calibre23">CSketcherDoc</code> as <code class="calibre23">CDocument</code>. This is required for the proper dynamic creation of a <code class="calibre23">CSketcherDoc</code> object, including members that are inherited.</p>
<section class="toclist">
<h4 class="calibre22">The Serialize() Function</h4>
<p class="calibre13">The class implementation includes the definition of the <code class="calibre23">Serialize()</code> function:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::Serialize(CArchive&amp; ar)
{
   if (ar.IsStoring())
   {
      // TODO: add storing code here
   }
   else
   {
      // TODO: add loading code here
   }
}</code></pre>
<p class="calibre13">This function serializes the data members of the class. The argument to the function, <code class="calibre23">ar</code>, is a reference to an object of the <code class="calibre23">CArchive</code> class. The <code class="calibre23">IsStoring()</code> member of this class object returns <code class="calibre23">TRUE</code> if the operation is to store data members in a file, and <code class="calibre23">FALSE</code> if the operation is to read back data members from a previously stored document.</p>
<p class="calibre13">Because the Application Wizard has no knowledge of what data your document contains, the process of writing and reading this information is up to you, as indicated by the comments. To understand how you do this, let’s look a little more closely at the <code class="calibre23">CArchive</code> class.</p>
</section>
<section class="toclist">
<h4 class="calibre22">The CArchive Class</h4>
<p class="calibre13">The <code class="calibre23">CArchive</code> class is the engine that drives the serialization mechanism. It provides an MFC-based equivalent of the stream operations in C++ that you used for reading from the keyboard and writing to the screen in the console program examples. A <code class="calibre23">CArchive</code> object provides a mechanism for streaming your objects to a file, or recovering them as an input stream, automatically reconstituting the objects of your class in the process.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="797" id="calibre_link-1259" class="calibre14"></span>A <code class="calibre23">CArchive</code> object has a <code class="calibre23">CFile</code> object associated with it that provides disk input/output capability for binary files, and provides the connection to the physical file. Within the serialization process, the <code class="calibre23">CFile</code> object takes care of all the specifics of the file input and output operations, and the <code class="calibre23">CArchive</code> object deals with the logic of structuring the object data to be written, or reconstructing the objects from the information read. You need to worry about the details of the associated <code class="calibre23">CFile</code> object only if you are constructing your own <code class="calibre23">CArchive</code> object. With the document in Sketcher, the framework has already taken care of it and passes the <code class="calibre23">CArchive</code> object that it constructs, <code class="calibre23">ar</code>, to the <code class="calibre23">Serialize()</code> function in <code class="calibre23">CSketcherDoc</code>. You’ll be able to use the same object in each of the <code class="calibre23">Serialize()</code> functions you add to the element classes when you implement serialization for them.</p>
<p class="calibre13">The <code class="calibre23">CArchive</code> class overloads the extraction and insertion operators (<code class="calibre23">&gt;&gt;</code> and <code class="calibre23">&lt;&lt;</code>) for input and output operations, respectively, on objects of classes derived from <code class="calibre23">CObject</code>, plus a range of basic data types. These overloaded operators work with the object types and primitive types shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TYPE</b></th>
<th class="calibre32"><b class="calibre12">DEFINITION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">bool</code></td>
<td class="calibre32">Boolean value, <code class="calibre23">true</code> or <code class="calibre23">false</code></td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">float</code></td>
<td class="calibre32">Standard single precision floating point</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">double</code></td>
<td class="calibre32">Standard double precision floating point</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">BYTE</code></td>
<td class="calibre32">8-bit unsigned integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">char</code></td>
<td class="calibre32">8-bit character</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">wchar_t</code></td>
<td class="calibre32">16-bit character</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">short</code></td>
<td class="calibre32">16-bit signed integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">int</code></td>
<td class="calibre32">32-bit signed integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LONG</code> and <code class="calibre23">long</code></td>
<td class="calibre32">32-bit signed integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">LONGLONG</code></td>
<td class="calibre32">64-bit signed integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">ULONGLONG</code></td>
<td class="calibre32">64-bit unsigned integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">WORD</code></td>
<td class="calibre32">16-bit unsigned integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">DWORD</code> and <code class="calibre23">unsigned int</code></td>
<td class="calibre32">32-bit unsigned integer</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CString</code></td>
<td class="calibre32">A <code class="calibre23">CString</code> object defining a string</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SIZE</code> and <code class="calibre23">CSize</code></td>
<td class="calibre32">An object defining a size as a cx, cy pair</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">POINT</code> and <code class="calibre23">CPoint</code></td>
<td class="calibre32">An object defining a point as an x, y pair</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">RECT</code> and <code class="calibre23">CRect</code></td>
<td class="calibre32">An object defining a rectangle by its upper-left and lower-right corners</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">CObject*</code></td>
<td class="calibre32">Pointer to <code class="calibre23">CObject</code></td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="798" id="calibre_link-1260" class="calibre14"></span>For basic data types in your objects, you use the insertion and extraction operators to serialize the data. To read or write an object of a serializable class that you have derived from <code class="calibre23">CObject</code>, you can either call the <code class="calibre23">Serialize()</code> function for the object, or use the extraction or insertion operator. Whichever way you choose must be used consistently for both input and output, so you should not output an object using the insertion operator and then read it back using the <code class="calibre23">Serialize()</code> function, or vice versa.</p>
<p class="calibre13">Where you don’t know the type of an object when you read it, as in the case of the pointers in the list of elements in our document, for example, you must <i class="calibre15">only</i> use the <code class="calibre23">Serialize()</code> function. This brings the virtual function mechanism into play, so the appropriate <code class="calibre23">Serialize()</code> function for the type of object pointed to is determined at run time.</p>
<p class="calibre13">A <code class="calibre23">CArchive</code> object is constructed either for storing objects or for retrieving objects. The <code class="calibre23">CArchive</code> function <code class="calibre23">IsStoring()</code> returns <code class="calibre23">TRUE</code> if the object is for output, and <code class="calibre23">FALSE</code> if the object is for input. You saw this used in the <code class="calibre23">Serialize()</code> member of <code class="calibre23">CSketcherDoc</code>.</p>
<p class="calibre13">There are many other member functions of the <code class="calibre23">CArchive</code> class that are concerned with the detailed mechanics of the serialization process, but you don’t usually need to know about them to use serialization.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Functionality of CObject-Based Classes</h3>
<p class="calibre13">There are three levels of functionality available in your classes when they’re derived from the MFC class <code class="calibre23">CObject</code>. The level you get in your class is determined by which of three different macros you use in the definition of your class:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">MACRO</b></th>
<th class="calibre32"><b class="calibre12">FUNCTIONALITY</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">DECLARE_DYNAMIC()</code></td>
<td class="calibre32">Support for runtime class information</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">DECLARE_DYNCREATE()</code></td>
<td class="calibre32">Support for runtime class information and dynamic object creation</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">DECLARE_SERIAL()</code></td>
<td class="calibre32">Support for runtime class information, dynamic object creation, and serialization of objects</td>
</tr>
</tbody>
</table>
<p class="calibre13">Each of these macros requires that a complementary macro, named with the prefix <code class="calibre23">IMPLEMENT_</code> instead of <code class="calibre23">DECLARE_</code>, be placed in the file containing the class implementation. As the table indicates, the macros provide progressively more functionality, so I’ll concentrate on the third macro, <code class="calibre23">DECLARE_SERIAL()</code>, because it provides everything that the preceding macros do and more. This is the macro you should use to enable serialization in your own classes. It requires that the macro <code class="calibre23">IMPLEMENT_SERIAL()</code> be added to the file containing the class implementation.</p>
<p class="calibre13">You may be wondering why the document class uses <code class="calibre23">DECLARE_DYNCREATE()</code> and not <code class="calibre23">DECLARE_SERIAL()</code>. The <code class="calibre23">DECLARE_DYNCREATE()</code> macro provides the capability for dynamic creation of the objects of the class in which it appears. The <code class="calibre23">DECLARE_SERIAL()</code> macro provides the capability for serialization of the class, plus the dynamic creation of objects of the class, so it incorporates the effects of <code class="calibre23">DECLARE_DYNCREATE()</code>. Your document class doesn’t need serialization because the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="799" id="calibre_link-1261" class="calibre14"></span>framework only has to synthesize the document object and then restore the values of its data members; however, the data members of a document <i class="calibre15">do</i> need to be serializable, because this is the process used to store and retrieve them.</p>
<section class="toclist">
<h4 class="calibre22">The Macros that Add Serialization to a Class</h4>
<p class="calibre13">With the <code class="calibre23">DECLARE_SERIAL()</code> macro in the definition of your <code class="calibre23">CObject</code>-based class, you get access to the serialization support provided by <code class="calibre23">CObject</code>. This includes special <code class="calibre23">new</code> and <code class="calibre23">delete</code> operators that incorporate memory leak detection in debug mode. You don’t need to do anything to use this because it works automatically. The macro requires the class name to be specified as an argument, so for serialization of the <code class="calibre23">CElement</code> class, you would add the following line to the class definition:</p>
<pre class="calibre28"><code class="calibre23">DECLARE_SERIAL(CElement)</code></pre>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">There’s no semicolon required here because this is a macro, not a C++ statement.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">It doesn’t matter where you put the macro within the class definition, but if you always put it as the first line, you’ll always be able to verify that it’s there, even when the class definition involves a lot of lines of code.</p>
<p class="calibre13">The <code class="calibre23">IMPLEMENT_SERIAL()</code> macro that you place in the implementation file for the class requires three arguments. The first argument is the class name, the second is the name of the direct base class, and the third argument is an unsigned 32-bit integer identifying a <i class="calibre15">schema number</i>, or version number, for your program. This schema number allows the serialization process to guard against problems that can arise if you write objects with one version of a program and read them with another, in which the classes may be different.</p>
<p class="calibre13">For example, you could add the following line to the source file containing the implementation of the <code class="calibre23">CElement</code> class:</p>
<pre class="calibre28"><code class="calibre23">IMPLEMENT_SERIAL(CElement, CObject, 1001)</code></pre>
<p class="calibre13">If you subsequently modify the class definition, you would change the schema number to something different, such as 1002. If the program attempts to read data that was written with a different schema number from that in the currently active program, an exception is thrown. The best place for this macro is as the first line following the <code class="calibre23">#include</code> directives and any initial comments in the <code class="calibre23">.cpp</code> file.</p>
<p class="calibre13">Where <code class="calibre23">CObject</code> is an indirect base class, as in the case of the <code class="calibre23">CLine</code> class for example, each class in the hierarchy must have the serialization macros added for serialization to work in the top-level class. For serialization in <code class="calibre23">CLine</code> to work, the macros must also be added to <code class="calibre23">CElement</code>.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">How Serialization Works</h3>
<p class="calibre13">The overall process of serializing a document is illustrated in a simplified form in <a id="calibre_link-137" href="#calibre_link-136" class="calibre3">Figure 17-1</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000042.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-136" href="#calibre_link-137" class="calibre3">FIGURE 17-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="800" id="calibre_link-1262" class="calibre14"></span>The <code class="calibre23">Serialize()</code> function in the document object calls the <code class="calibre23">Serialize()</code> function (or uses an overloaded insertion operator) for each of its data members. Where a member is a class object, the <code class="calibre23">Serialize()</code> function for that object serializes each of its data members in turn until eventually, basic data types are written to the file. Because most classes in MFC ultimately derive from <code class="calibre23">CObject</code>, they contain serialization support, so you can almost always serialize MFC class objects.</p>
<p class="calibre13">The data that you’ll deal with in the <code class="calibre23">Serialize()</code> member functions of your classes and the application document object are just the data members. The structure of the classes that are involved and any other data necessary to reconstitute your original objects are automatically taken care of by the <code class="calibre23">CArchive</code> object.</p>
<p class="calibre13">Where you derive multiple levels of classes from <code class="calibre23">CObject</code>, the <code class="calibre23">Serialize()</code> function in a class must call the <code class="calibre23">Serialize()</code> member of its direct base class to ensure that the direct base class data members are serialized. Note that serialization doesn’t support multiple inheritance, so there can only be one base class for each class defined in a hierarchy.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="801" id="calibre_link-1263" class="calibre24"></span>How to Implement Serialization for a Class</h3>
<p class="calibre13">From the previous discussion, I can summarize the steps that you need to take to add serialization to a class:</p>
<ol class="calibre5">
<li class="calibre6">Make sure that the class is derived directly or indirectly from <code class="calibre23">CObject</code>.</li>
<li class="calibre6">Add the <code class="calibre23">DECLARE_SERIAL()</code> macro to the class definition (and to the direct base class if the direct base is not <code class="calibre23">CObject</code> or another standard MFC class).</li>
<li class="calibre6">Declare the <code class="calibre23">Serialize()</code> function as a member function of your class.</li>
<li class="calibre6">Add the <code class="calibre23">IMPLEMENT_SERIAL()</code> macro to the file containing the class implementation.</li>
<li class="calibre6">Implement the <code class="calibre23">Serialize()</code> function for your class.</li>
</ol>
<p class="calibre13">Now let’s look at how you can implement serialization for documents in Sketcher.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-375" class="calibre3"></a>APPLYING SERIALIZATION</h2>
<p class="calibre13">To implement serialization in Sketcher, you must implement the <code class="calibre23">Serialize()</code> function in <code class="calibre23">CSketcherDoc</code> so that it deals with all of the data members of that class. You need to add serialization to each of the classes that define objects that may be included in a document. Before you start adding serialization to your classes, you should make some small changes to the program to record when a user changes a sketch document. This isn’t essential, but it is highly desirable because it enables the program to guard against the document being closed without saving changes.</p>
<section class="toclist">
<h3 class="calibre21">Recording Document Changes</h3>
<p class="calibre13">There’s already a mechanism for noting when a document changes. It uses an inherited member of the <code class="calibre23">CSketcherDoc</code> class, <code class="calibre23">SetModifiedFlag()</code>. By calling this function consistently whenever the document changes, you can record the fact that the document has been altered in a data member of the document class object. This causes a prompt to be automatically displayed when you try to exit the application without saving the modified document. The argument to the <code class="calibre23">SetModifiedFlag()</code> function is a value of type <code class="calibre23">BOOL</code>, and the default value is <code class="calibre23">TRUE</code>. When you have occasion to specify that the document was unchanged, you can call this function with the argument <code class="calibre23">FALSE</code>.</p>
<p class="calibre13">At present, there are four occasions when you alter a sketch in the document object:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">When you call the <code class="calibre23">AddElement()</code> member of <code class="calibre23">CSketcherDoc</code> to add a new element.</li>
<li class="calibre6">When you call the <code class="calibre23">DeleteElement()</code> member of <code class="calibre23">CSketcherDoc</code> to delete an element.</li>
<li class="calibre6">When you call <code class="calibre23">SendToBack()</code> for the document object.</li>
<li class="calibre6">When you move an element.</li>
</ul>
<p class="calibre13">You can handle these situations easily. All you need to do is add a call to <code class="calibre23">SetModifiedFlag()</code> to each of the functions involved in these operations. The definition of <code class="calibre23">AddElement()</code> appears in the <code class="calibre23">CSketcherDoc</code> class definition. You can extend this to:</p>
<pre class="calibre28"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="802" id="calibre_link-1264" class="calibre14"></span>void AddElement(std::shared_ptr&lt;CElement&gt;&amp; pElement)  // Add an element to the list
{
  m_Sketch.push_back(pElement); 
  UpdateAllViews(nullptr, 0, pElement.get());        // Tell all the views
  <b class="calibre12">SetModifiedFlag();</b>                                 <b class="calibre12">// Set the modified flag</b>
}</code></pre>
<p class="calibre13">The definition of <code class="calibre23">DeleteElement()</code> is also in the <code class="calibre23">CSketcherDoc</code> definition. You should add one line to it, as follows:</p>
<pre class="calibre28"><code class="calibre23">void DeleteElement(std::shared_ptr&lt;CElement&gt;&amp; pElement) 
{
  m_Sketch.remove(pElement);
  UpdateAllViews(nullptr, 0,  pElement.get());       // Tell all the views
  <b class="calibre12">SetModifiedFlag();</b>                                 <b class="calibre12">// Set the modified flag</b>
}
</code></pre>
<p class="calibre13">The <code class="calibre23">SendToBack()</code> function needs to have the same line added:</p>
<pre class="calibre28"><code class="calibre23">void SendToBack(std::shared_ptr&lt;CElement&gt;&amp; pElement)
{
  if(pElement)
  {
    m_Sketch.remove(pElement);                // Remove the element from the list
    m_Sketch.push_back(pElement);             // Put a copy at the end of the list
    <b class="calibre12">SetModifiedFlag();                        // Set the modified flag</b>
  }
}
</code></pre>
<p class="calibre13">Moving an element occurs in the <code class="calibre23">MoveElement()</code> member of a view object that is called by the handler for the <code class="calibre23">WM_MOUSEMOVE</code> message, but you only change the document when the left mouse button is pressed. If there’s a right-button click, the element is put back to its original position, so you only need to call the <code class="calibre23">SetModifiedFlag()</code> function for the document in the <code class="calibre23">OnLButtonDown()</code> function:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnLButtonDown(UINT nFlags, CPoint point)
{
  CClientDC aDC{this};                                // Create a device context
  OnPrepareDC(&amp;aDC);                                  // Get origin adjusted
  aDC.DPtoLP(&amp;point);                                 // convert point to Logical
  CSketcherDoc* pDoc {GetDocument()};                 // Get a document pointer
        
  if(m_MoveMode)
  { // In moving mode, so drop the element
    m_MoveMode = false;                               // Kill move mode
    auto pElement(m_pSelected);                       // Store selected address
    m_pSelected.reset();                              // De-select the element
    pDoc-&gt;UpdateAllViews(nullptr, 0, pElement.get()); // Redraw all the views
    <b class="calibre12">pDoc-&gt;SetModifiedFlag();                          // Set the modified flag</b>
  }
  // Rest of the function as before...
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="803" id="calibre_link-1265" class="calibre14"></span>You call the inherited <code class="calibre23">GetDocument()</code> member of the view class to get access to a pointer to the document object and then use this pointer to call the <code class="calibre23">SetModifiedFlag()</code> function.</p>
<p class="calibre13">You now have all the places where you change the sketch. The document object also stores the element type, the element color and the pen width, so you need to track when they change too. Here’s how you can update <code class="calibre23">OnColorBlack()</code> for example:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnColorBlack()
{
   m_Color = ElementColor::BLACK;                // Set the drawing color to black
   <b class="calibre12">SetModifiedFlag();                            // Set the modified flag</b>
}</code></pre>
<p class="calibre13">Add the same statement to each of the handlers for the other colors and the element types. The handler for setting the pen width needs to be updated like this:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::OnPenWidth()
{
     CPenDialog aDlg;                     // Create a local dialog object
    aDlg.m_PenWidth = m_PenWidth;         // Set pen width as that in the document
 
    if(aDlg.DoModal() ==<code class="calibre23"></code> IDOK)             // Display the dialog as modal
    {
      m_PenWidth = aDlg.m_PenWidth;       // When closed with OK, get the pen width
     <b class="calibre12">SetModifiedFlag();                   // Set the modified flag</b>
    }
}</code></pre>
<p class="calibre13">If you build and run Sketcher, and modify a document or add elements to it, you’ll now get a prompt to save the document when you exit the program. Of course, the File <img src="images/000122.png" alt="image" class="calibre25" /> Save menu option doesn’t do anything yet except clear the modified flag and save an empty file to disk. You must implement serialization to get the document written to disk, and that’s the next step.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Serializing the Document</h3>
<p class="calibre13">The first step is to implement the <code class="calibre23">Serialize()</code> function for the <code class="calibre23">CSketcherDoc</code> class. Within this function, you must add code to serialize the data members of <code class="calibre23">CSketcherDoc</code>. The data members that you have declared in the class are as follows:</p>
<pre class="calibre28"><code class="calibre23">protected:
  ElementType m_Element{ElementType::LINE };        // Current element type
  ElementColor m_Color{ ElementColor::BLACK };      // Current drawing color
  std::list&lt;std::shared_ptr&lt;CElement&gt;&gt; m_Sketch;    // A list containing the sketch
  int m_PenWidth{};                                 // Current pen width
  CSize m_DocSize { CSize{ 3000, 3000 } };          // Document size</code></pre>
<p class="calibre13">These have to be serialized to allow a <code class="calibre23">CSketcherDoc</code> object to be deserialized. You need to insert the statements to store and retrieve these data members in the <code class="calibre23">Serialize()</code> member of the class. However, there is a slight problem. The <code class="calibre23">list&lt; std::shared_ptr&lt;CElement&gt;&gt;</code> object is not serializable because the template is not derived from <code class="calibre23">CObject</code>. In fact, <i class="calibre15">none</i> of the STL containers are serializeable, so you always have to take care of serializing STL containers yourself.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="804" id="calibre_link-1266" class="calibre14"></span>All is not lost, however. If you can serialize the objects that the pointers in the container point to, you will be able to reconstruct the container when you read it back.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The MFC defines container classes such as</i> <code class="calibre23">CList</code> <i class="calibre15">that are serializable. However, if you used these in Sketcher, you would not learn about how you can make a class serializable.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You can implement serialization for the document object with the following code:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherDoc::Serialize(CArchive&amp; ar)
{
  if (ar.IsStoring())
  {
    ar &lt;&lt; static_cast&lt;COLORREF&gt;(m_Color)        // Store the current color
       &lt;&lt; static_cast&lt;int&gt;(m_Element)           // the element type as an integer
       &lt;&lt; m_PenWidth                            // and the current pen width
       &lt;&lt; m_DocSize;                            // and the current document size
       
    ar &lt;&lt; m_Sketch.size();             // Store the number of elements in the list
 
    // Now store the elements from the list
    for(const auto&amp; pElement : m_Sketch)
      ar &lt;&lt; pElement.get();                     // Store the element pointer
  }
  else
  {
    COLORREF color {};
    int elementType {};
    ar &gt;&gt; color                                 // Retrieve the current color
       &gt;&gt; elementType                           // the element type as an integer
       &gt;&gt; m_PenWidth                            // and the current pen width
       &gt;&gt; m_DocSize;                            // and the current document size
    m_Color = static_cast&lt;ElementColor&gt;(color);
    m_Element = static_cast&lt;ElementType&gt;(elementType);
 
    // Now retrieve all the elements and store in the list
    size_t elementCount {};                     // Count of number of elements
    ar &gt;&gt; elementCount;                         // retrieve the element count
    CElement* pElement;
    for(size_t i {} ; i &lt; elementCount ; ++i)
    {
      ar &gt;&gt; pElement;
      m_Sketch.push_back(std::shared_ptr&lt;CElement&gt;(pElement));
    }
  }
}</code></pre>
<p class="calibre13">For four of the data members, you just use the extraction and insertion operators that are overloaded in the <code class="calibre23">CArchive</code> class. This won’t work for <code class="calibre23">m_Color</code> because the <code class="calibre23">ElementColor</code> type is not <span {http://www.idpf.org/2007/ops}type="pagebreak" title="805" id="calibre_link-1267" class="calibre14"></span>serializable. However, you can cast it to type <code class="calibre23">COLORREF</code>, which is serializable because type <code class="calibre23">COLORREF</code> is the same as type <code class="calibre23">long</code>. The <code class="calibre23">m_Element</code> member is of type <code class="calibre23">ElementType</code>, and the serialization process won’t handle this directly either. However, you can cast it to an integer for serialization, and then just deserialize it as an integer before casting the value back to <code class="calibre23">ElementType</code>.</p>
<p class="calibre13">For the list of elements, <code class="calibre23">m_Sketch</code>, you first store the count of the number of elements in the list because you will need this to be able to read the elements back. You then write the element pointers that are contained in the <code class="calibre23">shared_ptr</code> objects from the list to the archive in the <code class="calibre23">for</code> loop. Something remarkable happens as a result. The serialization mechanism recognizes that the objects pointed to will be required to reconstruct the document, and will take care of writing those to the archive.</p>
<p class="calibre13">The <code class="calibre23">else</code> clause for the <code class="calibre23">if</code> deals with reading the document object back from the archive. You use the extraction operator to retrieve the first four members from the archive in the same sequence that they were written. The color and element type are read into the local integer variables, <code class="calibre23">color</code> and <code class="calibre23">elementType</code>, and then stored in the <code class="calibre23">m_Color</code> and <code class="calibre23">m_Element</code> members as the correct type.</p>
<p class="calibre13">You read the number of elements recorded in the archive and store it locally in <code class="calibre23">elementCount</code>. Finally, you use <code class="calibre23">elementCount</code> to control the <code class="calibre23">for</code> loop that reads the elements back from the archive and stores them in the list. Note that you don’t need to do anything special to take account of the fact that the elements were originally created on the heap. The serialization mechanism takes care of restoring the elements on the heap automatically; all you need to do is pass the pointer for each element to the <code class="calibre23">shared_ptr&lt;CElement&gt;</code> constructor.</p>
<p class="calibre13">In case you are wondering where the <code class="calibre23">list&lt;shared_ptr&lt;CElement&gt;&gt;</code> object comes from when you are deserializing an object, it will be created by the serialization process using the default constructor for the <code class="calibre23">CSketcherDoc</code> class. This is how the basic document object and its uninitialized data members get created. Like magic, isn’t it?</p>
<p class="calibre13">That’s all you need for serializing the document class data members, but serializing elements from the list causes the <code class="calibre23">Serialize()</code> functions for the element classes to be called to store and retrieve the elements themselves, so you also need to implement serialization for those classes.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Serializing the Element Classes</h3>
<p class="calibre13">All the element classes are serializable in principle because their base class, <code class="calibre23">CElement</code>, is derived from <code class="calibre23">CObject</code>. You specified <code class="calibre23">CObject</code> as the base for <code class="calibre23">CElement</code> solely to get support for serialization. Make sure that the default constructor is defined for each of the element classes. The deserialization process requires that this constructor be defined.</p>
<p class="calibre13">You can add support for serialization to each of the element classes by adding the appropriate macros to the class definitions and implementations, and adding the code to the <code class="calibre23">Serialize()</code> member function of each class to serialize its data members. You can start with the base class, <code class="calibre23">CElement</code>, where you need to modify the class definition as follows:</p>
<pre class="calibre28"><code class="calibre23">class CElement: public CObject
{
<b class="calibre12">DECLARE_SERIAL(CElement)</b>
protected:
  CPoint m_StartPoint;                         // Element position      
  int m_PenWidth;                              // Pen width
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="806" id="calibre_link-1268" class="calibre14"></span>  COLORREF m_Color;                              // Color of an element
  CRect m_EnclosingRect;                         // Rectangle enclosing an element
 
public:
  virtual ~CElement();
  virtual void Draw(CDC* pDC, std::shared_ptr&lt;CElement&gt; pElement=nullptr) {} 
  virtual void Move(const CSize&amp; aSize) {}       // Move an element
  <b class="calibre12">virtual void Serialize(CArchive&amp; ar)  override; // Serialize object</b>
 
 
  // Get the element enclosing rectangle 
  const CRect&amp; GetEnclosingRect() const 
  {
    return m_EnclosingRect;
  }
 
protected:
  // Constructors protected so they cannot be called outside the class
  CElement();              
  CElement(const CPoint&amp; start, COLORREF color, int penWidth = 1);
 
  // Create a pen
  void CreatePen(CPen&amp; aPen, std::shared_ptr&lt;CElement&gt; pElement)
  {
  if(!aPen.CreatePen(PS_SOLID, m_PenWidth,
                              (this == pElement.get()) ? SELECT_COLOR : m_Color))
   {
        // Pen creation failed
        AfxMessageBox(_T("Pen creation failed."), MB_OK); 
        AfxAbort();
   }
 }
};</code></pre>
<p class="calibre13">You add the <code class="calibre23">DECLARE_SERIAL()</code> macro and a declaration for the virtual function <code class="calibre23">Serialize()</code>. You already have the default constructor that was created by the Application Wizard. You changed it to <code class="calibre23">protected</code> in the class, although it doesn’t matter what its access specification is as long as it appears explicitly in the class definition. It can be <code class="calibre23">public, protected</code>, or <code class="calibre23">private</code>, and serialization still works. If you forget to include a default constructor in a class, though, you’ll get an error message when the <code class="calibre23">IMPLEMENT_SERIAL()</code> macro is compiled.</p>
<p class="calibre13">You should add the <code class="calibre23">DECLARE_SERIAL()</code> macro to each of the derived classes <code class="calibre23">CLine, CRectangle, CCircle, CCurve</code>, and <code class="calibre23">CText</code>, with the relevant class name as the argument. You should also add an override declaration for the <code class="calibre23">Serialize()</code> function as a <code class="calibre23">public</code> member of each class.</p>
<p class="calibre13">In the file <code class="calibre23">Element.cpp</code>, you must add the following macro at the beginning:</p>
<pre class="calibre28"><code class="calibre23">IMPLEMENT_SERIAL(CElement, CObject, VERSION_NUMBER)</code></pre>
<p class="calibre13">You can define the static constant <code class="calibre23">VERSION_NUMBER</code> in the <code class="calibre23">Element.h</code> file by adding the definition after the other static constant:</p>
<pre class="calibre28"><code class="calibre23">static const UINT VERSION_NUMBER {1001};     // Version number for serialization
</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="807" id="calibre_link-1269" class="calibre14"></span>You can then use the same constant when you add the macro to the <code class="calibre23">.cpp</code> file for each of the other element classes. For instance, for the <code class="calibre23">CLine</code> class you should add the line,</p>
<pre class="calibre28"><code class="calibre23">IMPLEMENT_SERIAL(CLine, CElement, VERSION_NUMBER)</code></pre>
<p class="calibre13">and similarly for the other element classes. When you modify any of the classes relating to the document, all you need to do is change the definition of <code class="calibre23">VERSION_NUMBER</code> in the <code class="calibre23">Element.h</code> file, and the new version number applies in all your <code class="calibre23">Serialize()</code> functions.</p>
<section class="toclist">
<h4 class="calibre22">The Serialize() Functions for the Element Classes</h4>
<p class="calibre13">You can now implement the <code class="calibre23">Serialize()</code> member function for each of the element classes. Start with the <code class="calibre23">CElement</code> class and add the following definition to <code class="calibre23">Element.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">void CElement::Serialize(CArchive&amp; ar)
{
  CObject::Serialize(ar);              // Call the base class function
        
  if (ar.IsStoring())
   { // Writing to the file
     ar &lt;&lt; m_StartPoint                // Element position 
        &lt;&lt; m_PenWidth                  // The pen width
        &lt;&lt; m_Color                     // The element color
        &lt;&lt; m_EnclosingRect;            // The enclosing rectangle
  }
  else
  {  // Reading from the file
     ar &gt;&gt; m_StartPoint                // Element position 
        &gt;&gt; m_PenWidth                  // The pen width
        &gt;&gt; m_Color                     // The element color
        &gt;&gt; m_EnclosingRect;            // The enclosing rectangle
  }
}</code></pre>
<p class="calibre13">This function is of the same form as the one supplied for you in the <code class="calibre23">CSketcherDoc</code> class. All of the data members defined in <code class="calibre23">CElement</code> are supported by the overloaded extraction and insertion operators and so everything is done using those operators. Note that you must call the <code class="calibre23">Serialize()</code> member for the <code class="calibre23">CObject</code> class to ensure that the inherited data members are serialized.</p>
<p class="calibre13">For the <code class="calibre23">CLine</code> class, you can code the function as:</p>
<pre class="calibre28"><code class="calibre23">void CLine::Serialize(CArchive&amp; ar)
{
  CElement::Serialize(ar);             // Call the base class function
        
  if (ar.IsStoring())
  { // Writing to the file
    ar &lt;&lt; m_EndPoint;                  // The end point
  }
  else
  { // Reading from the file
    ar &gt;&gt; m_EndPoint;                  // The end point 
  }
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="808" id="calibre_link-1270" class="calibre14"></span>The data member is supported by the extraction and insertion operators of the <code class="calibre23">CArchive</code> object <code class="calibre23">ar</code>. You call the <code class="calibre23">Serialize()</code> member of the base class <code class="calibre23">CElement</code> to serialize its data members, and this calls the <code class="calibre23">Serialize()</code> member of <code class="calibre23">CObject</code>. You can see how serialization cascades through the class hierarchy.</p>
<p class="calibre13">The <code class="calibre23">Serialize()</code> member of the <code class="calibre23">CRectangle</code> class is simple:</p>
<pre class="calibre28"><code class="calibre23">void CRectangle::Serialize(CArchive&amp; ar)
{
  CElement::Serialize(ar);             // Call the base class function
  if (ar.IsStoring())
  { // Writing to the file
    ar &lt;&lt; m_BottomRight;               // Bottom-right point for the rectangle
  }
  else
  { // Reading from the file
    ar &gt;&gt; m_BottomRight;
  }
}</code></pre>
<p class="calibre13">This calls the direct base class <code class="calibre23">Serialize()</code> function and serializes the bottom-right point for the rectangle.</p>
<p class="calibre13">The function implementation for the <code class="calibre23">CCircle</code> class is identical to that for the <code class="calibre23">CRectangle</code> class:</p>
<pre class="calibre28"><code class="calibre23">void CCircle::Serialize(CArchive&amp; ar)
{
  CElement::Serialize(ar);             // Call the base class function
  if (ar.IsStoring())
  { // Writing to the file
    ar &lt;&lt; m_BottomRight;               // Bottom-right point for the circle 
  }
  else
  { // Reading from the file
    ar &gt;&gt; m_BottomRight;
  }
}</code></pre>
<p class="calibre13">For the <code class="calibre23">CCurve</code> class, you have rather more work to do. The <code class="calibre23">CCurve</code> class uses a <code class="calibre23">vector&lt;CPoint&gt;</code> container to store the defining points, and because this is not directly serializable, you must take care of it yourself. Having serialized the document, this is not going to be terribly difficult. You can code the <code class="calibre23">Serialize()</code> function as follows:</p>
<pre class="calibre28"><code class="calibre23">void CCurve::Serialize(CArchive&amp; ar)
{
  CElement::Serialize(ar);             // Call the base class function
  // Serialize the vector of points
  if (ar.IsStoring())
  {
    ar &lt;&lt; m_Points.size();             // Store the point count
    // Now store the points
    for)const auto&amp; Point : m_Points)
      ar &lt;&lt; point;
  }
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="809" id="calibre_link-1271" class="calibre14"></span>  else
  {
    size_t nPoints {};                 // Stores number of points
    ar &gt;&gt; nPoints;                     // Retrieve the number of points
    // Now retrieve the points
    CPoint point;
    for(size_t i {} i &lt; nPoints; ++i)
    {
      ar &gt;&gt; point;
      m_Points.push_back(point);
    }
  }
}</code></pre>
<p class="calibre13">You first call the base class <code class="calibre23">Serialize()</code> function to deal with serializing the inherited members of the class. The technique for storing the contents of the vector is basically the same as you used for serializing the list for the document. You first write the number of elements in the container to the archive, then the elements themselves. The <code class="calibre23">CPoint</code> class is serializable, so it takes care of itself. Reading the points back is equally straightforward. You just store each object read from the archive in the vector, <code class="calibre23">m_Points</code>, in the <code class="calibre23">for</code> loop. The serialization process uses the no-arg constructor for the <code class="calibre23">CCurve</code> class to create the basic class object, so the <code class="calibre23">vector&lt;CPoint&gt;</code> member is created within this process.</p>
<p class="calibre13">The last class for which you need to add a <code class="calibre23">Serialize()</code> implementation is <code class="calibre23">CText</code>:</p>
<pre class="calibre28"><code class="calibre23">void CText::Serialize(CArchive&amp; ar)
{
  CElement::Serialize(ar);             // Call the base class function
        
  if (ar.IsStoring())
  {
      ar &lt;&lt; m_String;                  // Store the text string
  }
  else
  {
      ar &gt;&gt; m_String;                  // Retrieve the text string
  }
}</code></pre>
<p class="calibre13">After calling the base class function, you serialize the <code class="calibre23">m_String</code> data member using the insertion and extraction operators for <code class="calibre23">ar</code>. Although <code class="calibre23">CString</code> is not derived from <code class="calibre23">CObject</code>, the <code class="calibre23">CString</code> class is still fully supported by <code class="calibre23">CArchive</code> with these overloaded operators.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-376" class="calibre3"></a>EXERCISING SERIALIZATION</h2>
<p class="calibre13">That’s all you have to do to implement the storing and retrieving of documents in the Sketcher program! The Save and Open menu options in the file menu are now fully operational without adding any more code. If you build and run Sketcher after incorporating the changes I’ve discussed in this chapter, you’ll be able to save and restore files and be automatically prompted to save a modified document when you try to close it or exit from the program without saving, as shown in <a id="calibre_link-139" href="#calibre_link-138" class="calibre3">Figure 17-2</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000099.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-138" href="#calibre_link-139" class="calibre3">FIGURE 17-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="810" id="calibre_link-1272" class="calibre14"></span>The prompting works because of the <code class="calibre23">SetModifiedFlag()</code> calls that you added everywhere you updated the document. Assuming you have not saved the file previously, if you click the Yes button in the screen shown in <a href="#calibre_link-138" class="calibre3">Figure 17-2</a>, you’ll see the File <img src="images/000122.png" alt="image" class="calibre25" /> Save As dialog shown in <a id="calibre_link-141" href="#calibre_link-140" class="calibre3">Figure 17-3</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000129.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-140" href="#calibre_link-141" class="calibre3">FIGURE 17-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="811" id="calibre_link-1273" class="calibre14"></span>This is the standard Windows dialog for this menu item. The dialog is fully working, supported by code supplied by the framework. The filename for the document has been generated from that assigned when the document was first opened, and the file extension is automatically defined as <code class="calibre23">.ske</code>. The application now has full support for file operations on documents. Easy, wasn’t it?</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-377" class="calibre3"></a>PRINTING A DOCUMENT</h2>
<p class="calibre13">It’s time to take a look at how you can print a sketch. You already have a basic printing capability implemented in Sketcher, courtesy of the Application Wizard and the framework. The File <img src="images/000122.png" alt="image" class="calibre25" /> Print, File <img src="images/000122.png" alt="image" class="calibre25" /> Print Setup, and File <img src="images/000122.png" alt="image" class="calibre25" /> Print Preview menu items all work. Selecting the File <img src="images/000122.png" alt="image" class="calibre25" /> Print Preview menu item displays a window showing the current Sketcher document on a page, as shown in <a id="calibre_link-143" href="#calibre_link-142" class="calibre3">Figure 17-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000085.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-142" href="#calibre_link-143" class="calibre3">FIGURE 17-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Whatever is in the current document is placed on a single sheet of paper at the current view scale. If the document’s extent is beyond the boundary of the paper, the section of the document off the paper won’t be printed. If you select the Print button, this page is sent to your printer.</p>
<p class="calibre13">As a basic capability that you get for free, it’s quite impressive, but it’s not adequate for our purposes. A typical document in Sketcher may well extend beyond a page, so you would either want to scale the document to fit, or, perhaps more conveniently, print the whole document over as many pages as necessary. You can add your own print processing code to extend the capability of the facilities provided by the framework, but to implement this you first need to understand how printing has been implemented in MFC.</p>
<section class="toclist">
<h3 class="calibre21">The Printing Process</h3>
<p class="calibre13">Printing a document is controlled by the current view. The process is inevitably a bit messy because printing is inherently a messy business, and it potentially involves you in overriding quite a number of inherited functions in your view class. <a id="calibre_link-145" href="#calibre_link-144" class="calibre3">Figure 17-5</a> shows the logic of the process and <span {http://www.idpf.org/2007/ops}type="pagebreak" title="812" id="calibre_link-1274" class="calibre14"></span>the functions involved. It also shows how the sequence of events is controlled by the framework and how printing a document involves calling five inherited members of your view class, which you may need to override. The <code class="calibre23">CDC</code> member functions shown on the left side of the diagram communicate with the printer device driver and are called automatically by the framework.</p>
<figure class="calibre16">
<img class="center" src="images/000043.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-144" href="#calibre_link-145" class="calibre3">FIGURE 17-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The typical role of each of the functions in the current view during a print operation is specified in the notes alongside it. The sequence in which they are called is indicated by the numbers on the arrows. In practice, you don’t need to implement all of these functions, only those that you want to for your particular printing requirements. Typically, you’ll want at least to implement your own versions of <code class="calibre23">OnPreparePrinting(), OnPrepareDC()</code>, and <code class="calibre23">OnPrint()</code>. You’ll see an example of how these functions can be implemented in the context of Sketcher a little later in this chapter.</p>
<p class="calibre13">You write data to a printer in the same way as you write data to the display &mdash; through a device context. The GDI calls that you use to output text or graphics are device-independent, so they work just as well for a printer as they do for a display. The only difference is the physical output device to which the <code class="calibre23">CDC</code> object applies.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="813" id="calibre_link-1275" class="calibre14"></span>The <code class="calibre23">CDC</code> functions in <a href="#calibre_link-144" class="calibre3">Figure 17-5</a> communicate with the device driver for the printer. If the document to be printed requires more than one printed page, the process loops back to call the <code class="calibre23">OnPrepareDC()</code> function for each successive new page, as determined by the <code class="calibre23">EndPage()</code> function. All the functions in your view class that are involved in the printing process are passed a pointer to a <code class="calibre23">CPrintInfo</code> object that provides a link between all the functions that manage the printing process, so let’s take a look at the <code class="calibre23">CPrintInfo</code> class in more detail.</p>
<section class="toclist">
<h4 class="calibre22">The CPrintInfo Class</h4>
<p class="calibre13">A <code class="calibre23">CPrintInfo</code> object has a fundamental role in the printing process because it stores information about the print job being executed and details of its status at any time. It also provides functions for accessing and manipulating this data. This object is the means by which information is passed from one view function to another during printing, and between the framework and your view functions.</p>
<p class="calibre13">A <code class="calibre23">CPrintInfo</code> object is created whenever you select the File <img src="images/000122.png" alt="image" class="calibre25" /> Print or File <img src="images/000122.png" alt="image" class="calibre25" /> Print Preview menu options. It will be used by each of the functions in the current view that are involved in the printing process, and it is automatically deleted when the print operation ends.</p>
<p class="calibre13">All the data members of <code class="calibre23">CPrintInfo</code> are <code class="calibre23">public</code>. The ones we are interested in for printing sketches are shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">MEMBER</b></th>
<th class="calibre32"><b class="calibre12">USAGE</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_pPD</code></td>
<td class="calibre32">A pointer to the <code class="calibre23">CPrintDialog</code> object that displays the Print dialog.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_bDirect</code></td>
<td class="calibre32">This is set to <code class="calibre23">TRUE</code> by the framework if the print operation is to bypass the Print dialog; otherwise, <code class="calibre23">FALSE</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_bPreview</code></td>
<td class="calibre32">A member of type <code class="calibre23">BOOL</code> that has the value <code class="calibre23">TRUE</code> if File <img src="images/000122.png" alt="image" class="calibre25" /> Print Preview was selected; otherwise, <code class="calibre23">FALSE</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_bContinuePrinting</code></td>
<td class="calibre32">A member of type <code class="calibre23">BOOL</code>. If it is <code class="calibre23">TRUE</code>, the framework continues the printing loop shown in the diagram. If it’s <code class="calibre23">FALSE</code>, the printing loop ends. You only need to set this variable if you don’t pass a page count for the print operation to the <code class="calibre23">CPrintInfo</code> object (using the <code class="calibre23">SetMaxPage()</code> member). In this case, you’ll be responsible for signaling when you are finished by setting this variable to <code class="calibre23">FALSE</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_nCurPage</code></td>
<td class="calibre32">A value of type <code class="calibre23">UINT</code> that stores the page number of the current page. Pages are usually numbered starting from 1.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_nNumPreviewPages</code></td>
<td class="calibre32">A value of type <code class="calibre23">UINT</code> that specifies the number of pages displayed in the Print Preview window. This can be 1 or 2.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_lpUserData</code></td>
<td class="calibre32">This is of type <code class="calibre23">LPVOID</code> and stores a pointer to an object that you create. This allows you to create an object to store additional information about the printing operation and associate it with the <code class="calibre23">CPrintInfo</code> object.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="814" id="calibre_link-1276" class="calibre14"></span>m_rectDraw</code></td>
<td class="calibre32">A <code class="calibre23">CRect</code> object that defines the usable area of the page in logical coordinates.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">m_strPageDesc</code></td>
<td class="calibre32">A <code class="calibre23">CString</code> object containing a format string used by the framework to display page numbers during print preview.</td>
</tr>
</tbody>
</table>
<p class="calibre13">A <code class="calibre23">CPrintInfo</code> object has the <code class="calibre23">public</code> member functions shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">FUNCTION</b></th>
<th class="calibre32"><b class="calibre12">DESCRIPTION</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SetMinPage(</code><br class="calibre10" /> <code class="calibre23">    UINT nMinPage)</code></td>
<td class="calibre32">The argument specifies the number of the first page of the document. There is no return value.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SetMaxPage(</code><br class="calibre10" /> <code class="calibre23">    UINT nMaxPage)</code></td>
<td class="calibre32">The argument specifies the number of the last page of the document. There is no return value.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">GetMinPage() const</code></td>
<td class="calibre32">Returns the number of the first page of the document as type <code class="calibre23">UINT</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">GetMaxPage() const</code></td>
<td class="calibre32">Returns the number of the last page of the document as type <code class="calibre23">UINT</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">GetFromPage() const</code></td>
<td class="calibre32">Returns the number of the first page of the document to be printed as type <code class="calibre23">UINT</code>. This value is set through the print dialog.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">GetToPage() const</code></td>
<td class="calibre32">Returns the number of the last page of the document to be printed as type <code class="calibre23">UINT</code>. This value is set through the print dialog.</td>
</tr>
</tbody>
</table>
<p class="calibre13">When you’re printing a document consisting of several pages, you need to figure out how many printed pages the document will occupy, and store this information in the <code class="calibre23">CPrintInfo</code> object to make it available to the framework. You do this in your version of the <code class="calibre23">OnPreparePrinting()</code> member of the current view.</p>
<p class="calibre13">Page numbers are stored as type <code class="calibre23">UINT</code>. To set the number of the first page in the document, you call the <code class="calibre23">SetMinPage()</code> function for the <code class="calibre23">CPrintInfo</code> object, which accepts the page number as the argument. There’s no return value. To set the number of the last page, you call <code class="calibre23">SetMaxPage()</code>. If you later want to retrieve these values, you call the <code class="calibre23">GetMinPage()</code> and <code class="calibre23">GetMaxPage()</code> functions for the <code class="calibre23">CPrintInfo</code> object.</p>
<p class="calibre13">The page numbers that you supply are stored in the <code class="calibre23">CPrintDialog</code> object pointed to by the <code class="calibre23">m_pPD</code> member of the <code class="calibre23">CPrintInfo</code> object and displayed in the dialog that pops up when you select File <img src="images/000122.png" alt="image" class="calibre25" /> Print... from the menu. The user can then specify the numbers of the first and last pages that are to be printed. You can retrieve the page numbers entered by the user by calling the <code class="calibre23">GetFromPage()</code> and <code class="calibre23">GetToPage()</code> members of the <code class="calibre23">CPrintInfo</code> object. In each case, the value returned is of type <code class="calibre23">UINT</code>. The dialog automatically verifies that the numbers of the first and last pages to be printed are within the range you supplied by specifying the minimum and maximum pages of the document.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="815" id="calibre_link-1277" class="calibre14"></span>You now know what functions you can implement in the view class to manage printing for yourself, with the framework doing most of the work. You also know what information is available through the <code class="calibre23">CPrintInfo</code> object that is passed to the functions concerned with printing. You’ll get a much clearer understanding of the detailed mechanics of printing by implementing a basic multipage print capability for Sketcher documents.</p>
</section>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-378" class="calibre3"></a>IMPLEMENTING MULTIPAGE PRINTING</h2>
<p class="calibre13">With the mapping mode in Sketcher set to <code class="calibre23">MM_ANISOTROPIC</code>,  the unit of measure for the elements and the view extent is one hundredth of an inch. With the unit of size being a fixed physical measure, ideally you want to print objects at their actual size.</p>
<p class="calibre13">With the document size specified as 3000 × 3000 units, you can create documents up to 30 inches square, which spreads over quite a few sheets of paper if you fill the whole area. It requires a little more effort to work out the number of pages necessary to print a sketch than with a typical text document because in most instances you’ll need a two-dimensional array of pages to print a complete sketch document.</p>
<p class="calibre13">To avoid overcomplicating the problem, we will assume that you’re printing on a normal sheet of paper (either A4 size or 8 1/2 × 11 inches) and that you are printing in portrait orientation (which means the long edge is vertical). With either paper size, you’ll print the document in a central portion of the paper measuring 7.5 inches × 10 inches. With these assumptions, you don’t need to worry about the actual paper size; you just need to chop the document into 750 × 1000&ndash;unit chunks, where a unit is 0.01 inches. For a document larger than one page, you’ll divide up the document as illustrated in the example in <a id="calibre_link-147" href="#calibre_link-146" class="calibre3">Figure 17-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000004.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-146" href="#calibre_link-147" class="calibre3">FIGURE 17-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="816" id="calibre_link-1278" class="calibre14"></span>As you can see, you’ll be numbering the pages row-wise, so in this case, pages 1 to 4 are in the first row and pages 5 to 8 are in the second.</p>
<section class="toclist">
<h3 class="calibre21">Getting the Overall Document Size</h3>
<p class="calibre13">To figure out how many pages a particular document occupies, you need to know how big the sketch is, and for this, you want the rectangle that encloses everything in the document. You can do this easily by adding a function <code class="calibre23">GetDocExtent()</code> to the document class, <code class="calibre23">CSketcherDoc</code>. Add the following declaration to the <code class="calibre23">public</code> interface for <code class="calibre23">CSketcherDoc</code>:</p>
<pre class="calibre28"><code class="calibre23">CRect GetDocExtent() const;   // Get the bounding rectangle for the whole document</code></pre>
<p class="calibre13">The implementation is no great problem. The code for it is:</p>
<pre class="calibre28"><code class="calibre23">// Get the rectangle enclosing the entire document
CRect CSketcherDoc::GetDocExtent()const
{
  if(m_Sketch.empty())                                   // Check for empty sketch
    return CRect {0,0,1,1};
  CRect docExtent {m_Sketch.front()-&gt;GetEnclosingRect()}; // Initial doc extent
  for(auto&amp; pElement : m_Sketch) 
    docExtent.UnionRect(docExtent, pElement-&gt;GetEnclosingRect());
        
  docExtent.NormalizeRect();
  return docExtent;
}</code></pre>
<p class="calibre13">You can add this function definition to the <code class="calibre23">SketcherDoc.cpp</code> file.</p>
<p class="calibre13">If the sketch is empty, you return a very small <code class="calibre23">CRect</code> object. The initial size of the document extent is the rectangle enclosing the first element in the list. The process then loops through every element in the document, getting the bounding rectangle for each element and combining it with <code class="calibre23">docExtent</code>. The <code class="calibre23">UnionRect()</code> member of the <code class="calibre23">CRect</code> class calculates the smallest rectangle that contains the two rectangles you pass as arguments, and stores that value in the <code class="calibre23">CRect</code> object for which the function is called. Therefore, <code class="calibre23">docExtent</code> keeps increasing in size until all the elements are contained within it.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Storing Print Data</h3>
<p class="calibre13">The <code class="calibre23">OnPreparePrinting()</code> function in the view class is called by the application framework to enable you to initialize the printing process for your document. The basic initialization that’s required is to provide information about how many pages are in the document, which is information that the print dialog will display. You should also store information about the pages that your document requires, so you can use it later in the other view functions involved in the printing process. You can create an object of your own class type in the <code class="calibre23">OnPreparePrinting()</code> member of the view class to  store this information and store a pointer to the object in the <code class="calibre23">CPrintInfo</code> object that the framework makes available. I adopted this approach primarily to show you how this mechanism works; in many cases you’ll find it easier just to store the data in your view object.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="817" id="calibre_link-1279" class="calibre14"></span>You’ll need to store the number of pages running the width of the document, <code class="calibre23">m_nWidths</code>, and the number of rows of pages down the length of the document, <code class="calibre23">m_nLengths</code>. You’ll also store the upper-left corner of the rectangle enclosing the document data as a <code class="calibre23">CPoint</code> object, <code class="calibre23">m_DocRefPoint</code>, because you’ll need this when you work out the position of a page to be printed from its page number. You can store the filename for the document in a <code class="calibre23">CString</code> object, <code class="calibre23">m_DocTitle</code>, so that you can add it as a title to each page. It will also be useful to record the size of the printable area within the page. The definition of the class to accommodate these is:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
        
class CPrintData
{
public:
  UINT printWidth {1000};           // Printable page width - units 0.01 inches
  UINT printLength {1000};          // Printable page length - units 0.01 inches
  UINT m_nWidths;                   // Page count for the width of the document
  UINT m_nLengths;                  // Page count for the length of the document
  CPoint m_DocRefPoint;             // Top-left corner of the document contents
  CString m_DocTitle;               // The name of the document
        
};</code></pre>
<p class="calibre13">The class definition specifies default values for the printable area that corresponds to an A4 page with half-inch margins all round. You can change this to suit your environment, and, of course, you can change the values programmatically in a <code class="calibre23">CPrintData</code> object.</p>
<p class="calibre13">Of course, you could define a constructor for the class and initialize the values of printWidth and printLength there. However, all the data members are public so you can always set their values directly. The CPrintData class is just a vehicle for packaging data items relating to the printing process so there is no necessity for complicating it. Specifying default values for members obviates the need to write constructors and thus simplifies the class definition.</p>
<p class="calibre13">You can add a new header file with the name <code class="calibre23">PrintData.h</code> to the project by right-clicking the Header Files folder in the Solution Explorer pane and then selecting Add <img src="images/000122.png" alt="image" class="calibre25" /> New Item from the pop-up. You can now enter the class definition in the new file. You don’t need an implementation file for this class. Because an object of this class is only going to be used transiently, you don’t need to use <code class="calibre23">CObject</code> as a base or to consider any other complication.</p>
<p class="calibre13">The printing process starts with a call to <code class="calibre23">OnPreparePrinting()</code> so I’ll explore how you should implement that next.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Preparing to Print</h3>
<p class="calibre13">The Application Wizard has already added versions of <code class="calibre23">OnPreparePrinting(), OnBeginPrinting()</code>, and <code class="calibre23">OnEndPrinting()</code> to <code class="calibre23">CSketcherView</code>. The base code provided for <code class="calibre23">OnPreparePrinting()</code> calls <code class="calibre23">DoPreparePrinting()</code> in the <code class="calibre23">return</code> statement, as you can see:</p>
<pre class="calibre28"><code class="calibre23">BOOL CSketcherView::OnPreparePrinting(CPrintInfo* pInfo)
{
   // default preparation
   return DoPreparePrinting(pInfo);
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="818" id="calibre_link-1280" class="calibre14"></span>The <code class="calibre23">DoPreparePrinting()</code> function displays the Print dialog using information about the number of pages to be printed that is defined in the <code class="calibre23">CPrintInfo</code> object. Whenever possible, you should calculate the number of pages to be printed and store it in the <code class="calibre23">CPrintInfo</code> object before this call occurs. Of course, in many circumstances, you may need information from the device context for the printer before you can do this &mdash; when you’re printing a document where the number of pages is going to be affected by the size of the font to be used for example &mdash; in which case it won’t be possible to get the page count before you call <code class="calibre23">DoPreparePrinting()</code>. In these circumstances you can compute the number of pages in the <code class="calibre23">OnBeginPrinting()</code> member, which receives a pointer to the device context as an argument. This function is called by the framework after <code class="calibre23">OnPreparePrinting()</code>, so the information entered in the Print dialog is available. This means that you can also take account of the paper size selected by the user in the Print dialog.</p>
<p class="calibre13">Assuming that the page size is large enough to accommodate a 7.5-inch × 10-inch area to draw the document data, you can calculate the number of pages in <code class="calibre23">OnPreparePrinting()</code>. The code to do this is:</p>
<pre class="calibre28"><code class="calibre23">BOOL CSketcherView::OnPreparePrinting{CPrintInfo* pInfo}
{
  <b class="calibre12">CPrintData* printData {new CPrintData};   // Create a print data object</b>
  <b class="calibre12">CSketcherDoc* pDoc {GetDocument()};       // Get a document pointer</b>
  <b class="calibre12">CRect docExtent {pDoc-&gt;GetDocExtent()};   // Get the whole document area</b>

  <b class="calibre12">printData-&gt;m_DocRefPoint = docExtent.TopLeft();// Save document reference point</b> 
  <b class="calibre12">printData-&gt;m_DocTitle = pDoc-&gt;GetTitle();      // Save the document filename</b>


  <b class="calibre12">// Calculate how many printed page widths are required</b>
  <b class="calibre12">// to accommodate the width of the document</b>
  <b class="calibre12">printData-&gt;m_nWidths = static_cast&lt;UINT&gt;(ceil(</b>
                 <b class="calibre12">static_cast&lt;double&gt;(docExtent.Width())/printData-&gt;printWidth));</b>

  <b class="calibre12">// Calculate how many printed page lengths are required</b>
  <b class="calibre12">// to accommodate the document length</b>
  <b class="calibre12">printData-&gt;m_nLengths = static_cast&lt;UINT&gt;(</b>
            <b class="calibre12">ceil(static_cast&lt;double&gt;(docExtent.Height())/printData-&gt;printLength));</b>

  <b class="calibre12">// Set the first page number as 1 and</b>
  <b class="calibre12">// set the last page number as the total number of pages</b>
  <b class="calibre12">pInfo-&gt;SetMinPage(1);</b>
  <b class="calibre12">pInfo-&gt;SetMaxPage(printData-&gt;m_nWidths*printData-&gt;m_nLengths);</b>
  <b class="calibre12">pInfo-&gt;m_lpUserData = printData;         // Store address of PrintData object</b>
  return DoPreparePrinting(pInfo);
}</code></pre>
<p class="calibre13">You first create a <code class="calibre23">CPrintData</code> object on the heap and store its address locally in the pointer. After getting a pointer to the document, you get the rectangle enclosing all of the elements in the document by calling the function <code class="calibre23">GetDocExtent()</code> that you added to the document class earlier in this chapter. You then store the corner of this rectangle in the <code class="calibre23">m_DocRefPoint</code> member of the <code class="calibre23">CPrintData</code> object, and put the name of the file that contains the document in <code class="calibre23">m_DocTitle</code>.</p>
<p class="calibre13">The next two lines of code calculate the number of pages across the width of the document, and the number of pages required to cover the length. The number of pages to cover the width is computed by dividing the document width by the width of the print area on a page and rounding up to the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="819" id="calibre_link-1281" class="calibre14"></span>next highest integer using the <code class="calibre23">ceil()</code> function that is declared in the <code class="calibre23">cmath</code> header. For example, <code class="calibre23">ceil(2.1)</code> returns <code class="calibre23">3.0, ceil(2.9)</code> also returns <code class="calibre23">3.0</code>, and <code class="calibre23">ceil(-2.1)</code> returns <code class="calibre23">-2.0</code>. A similar calculation to that for the number of pages across the width of a document produces the number to cover the length. The product of these two values is the total number of pages to be printed, and this is the value that you’ll supply for the maximum page number. The last step is to store the address of the <code class="calibre23">CPrintData</code> object in the <code class="calibre23">m_lpUserData</code> member of the <code class="calibre23">pInfo</code> object.</p>
<p class="calibre13">Don’t forget to add an <code class="calibre23">#include</code> directive for <code class="calibre23">PrintData.h</code> to the <code class="calibre23">SketcherView.cpp</code> file.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Cleaning Up after Printing</h3>
<p class="calibre13">Because you created the <code class="calibre23">CPrintData</code> object on the heap, you must ensure that it’s deleted when you’re done with it. You do this by adding code to the <code class="calibre23">OnEndPrinting()</code> function:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">void CSketcherView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* pInfo)</b>
{
   <b class="calibre12">// Delete our print data object</b>
   <b class="calibre12">delete static_cast&lt;CPrintData*&gt;(pInfo-&gt;m_lpUserData);</b>
}</code></pre>
<p class="calibre13">That’s all that’s necessary for this function in the Sketcher program, but in some cases, you’ll need to do more. Your one-time final cleanup should be done here. Make sure that you remove the comment delimiters (/* */) from the second parameter name; otherwise, your function won’t compile. The default implementation comments out the parameter names because you may not need to refer to them in your code. Because you use the <code class="calibre23">pInfo</code> parameter, you must uncomment it; otherwise, the compiler reports it as undefined. You don’t need to add anything to the <code class="calibre23">OnBeginPrinting()</code> function in the Sketcher program, but you’d need to add code to allocate any GDI resources, such as pens, if they were required throughout the printing process. You would then delete these as part of the clean-up process in <code class="calibre23">OnEndPrinting()</code>.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Preparing the Device Context</h3>
<p class="calibre13">At the moment, Sketcher calls <code class="calibre23">OnPrepareDC()</code>for the view object which sets up the mapping mode as <code class="calibre23">MM_ANISOTROPIC</code> to take account of the scaling factor. You must make some additional changes so that the device context is properly prepared in the case of printing:</p>
<pre class="calibre28"><code class="calibre23">void CSketcherView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
  CScrollView::OnPrepareDC(pDC, pInfo);
  CSketcherDoc* pDoc {GetDocument()};
  pDC-&gt;SetMapMode(MM_ANISOTROPIC);           // Set the map mode
  CSize DocSize {pDoc-&gt;GetDocSize()};        // Get the document size
  pDC-&gt;SetWindowExt(DocSize);                // Now set the window extent
        
  // Get the number of pixels per inch in x and y
  int xLogPixels {pDC-&gt;GetDeviceCaps(LOGPIXELSX)};
  int yLogPixels {pDC-&gt;GetDeviceCaps(LOGPIXELSY)};
        
  // Calculate the viewport extent in x and y
  <b class="calibre12">int scale {pDC-&gt;IsPrinting() ? 1 : m_Scale}; // If we are printing, use scale 1</b>
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="820" id="calibre_link-1282" class="calibre14"></span>  <b class="calibre12">int xExtent {(DocSize.cx*scale*xLogPixels)/100};</b>
  <b class="calibre12">int yExtent {(DocSize.cy*scale*yLogPixels)/100};</b>
        
  pDC-&gt;SetViewportExt(xExtent, yExtent);     // Set viewport extent
}</code></pre>
<p class="calibre13">This function is called by the framework for output to the printer as well as to the screen. You should make sure that a scale of 1 is used to set the mapping from logical coordinates to device coordinates when you’re printing. If you left everything as it was, the output would be at the current view scale, but you’d need to take account of the scale when calculating how many pages were required, and how you set the origin for each page.</p>
<p class="calibre13">You determine whether or not you have a printer device context by calling the <code class="calibre23">IsPrinting()</code> member of the current <code class="calibre23">CDC</code> object, which returns <code class="calibre23">TRUE</code> if you are printing. When you have a printer device context you set the scale to 1. Of course, you must change the statements calculating the viewport extent to use the local variable <code class="calibre23">scale</code> rather than the <code class="calibre23">m_Scale</code> member of the view.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Printing the Document</h3>
<p class="calibre13">You write the data to the printer device context in the <code class="calibre23">OnPrint()</code> function. This is called once for each page. You need to add an override for this function to <code class="calibre23">CSketcherView</code>, using the <code class="calibre23">Properties</code> window for the class. Select <code class="calibre23">OnPrint</code> from the list of overrides and then click <code class="calibre23">&lt;Add&gt; OnPrint</code> in the right column.</p>
<p class="calibre13">You can obtain the page number of the page to be printed from the <code class="calibre23">m_nCurPage</code> member of the <code class="calibre23">CPrintInfo</code> object that is passed to the function. You can then use this value to work out the coordinates of the point in the document that corresponds to the upper-left corner of the current page. The way to do this is best understood using an example, so imagine that you are printing page 7 of an 8-page document, as illustrated in <a id="calibre_link-149" href="#calibre_link-148" class="calibre3">Figure 17-7</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000132.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-148" href="#calibre_link-149" class="calibre3">FIGURE 17-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="821" id="calibre_link-1283" class="calibre14"></span>Remember that these are in logical coordinates  and <i class="calibre15">x</i> is positive from left to right and <i class="calibre15">y</i> is increasingly negative from top to bottom. You can get an index to the horizontal position of the page by decrementing the page number by 1 and taking the remainder after dividing by the number of page widths required for the width of the document. Multiplying the result by <code class="calibre23">printWidth</code> produces the <i class="calibre15">x</i>-coordinate of the upper-left corner of the page, relative to the upper-left corner of the rectangle enclosing the elements in the document. Similarly, you can determine the index to the vertical position of the document by dividing the current page number reduced by 1 by the number of page widths required for the horizontal width of the document. By multiplying the result by <code class="calibre23">printLength</code>, you get the relative <i class="calibre15">y</i>-coordinate of the upper-left corner of the page. You can express this in the following statements:</p>
<pre class="calibre28"><code class="calibre23">CPrintData* p {static_cast&lt;CPrintData*&gt;(pInfo-&gt;m_lpUserData)};
int xOrg {p-&gt;m_DocRefPoint.x {static_cast&lt;int&gt;( p-&gt;printWidth*
                                        ((pInfo-&gt;m_nCurPage - 1)%(p-&gt;m_nWidths)))};
int yOrg {p-&gt;m_DocRefPoint.y {static_cast&lt;int&gt;( p-&gt;printLength*
                                         ((pInfo-&gt;m_nCurPage - 1)/(p-&gt;m_nWidths)))};</code></pre>
<p class="calibre13">It would be nice to print the filename of the document at the top of each page and, perhaps, a page number at the bottom, but you want to be sure you don’t print the document data over the filename and page number. You also want to center the printed area on the page. You can do this by moving the origin of the coordinate system in the printer device context <i class="calibre15">after</i> you have printed the filename. This is illustrated in <a id="calibre_link-151" href="#calibre_link-150" class="calibre3">Figure 17-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000076.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-150" href="#calibre_link-151" class="calibre3">FIGURE 17-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="822" id="calibre_link-1284" class="calibre14"></span><a href="#calibre_link-150" class="calibre3">Figure 17-8</a> illustrates the correspondence between the printed page area in the device context and the page to be printed in the reference frame of the document data. The diagram shows the expressions for the offsets from the page origin for the <code class="calibre23">printWidth</code> by <code class="calibre23">printLength</code> area where you are going to print the page. You want to print the information from the document in the dashed area shown on the printed page in <a href="#calibre_link-150" class="calibre3">Figure 17-8</a>, so you need to map the <code class="calibre23">xOrg, yOrg</code> point in the document to the position shown in the printed page, which is displaced from the page origin by the offset values <code class="calibre23">xOffset</code> and <code class="calibre23">yOffset</code>.</p>
<p class="calibre13">By default, the origin in the coordinate system that you use to define elements in the document is mapped to the origin of the device context, but you can change this. The <code class="calibre23">CDC</code> object provides a <code class="calibre23">SetWindowOrg()</code> function for this purpose. This enables you to define a point in the document’s logical coordinate system that you want to correspond to the origin in the device context, in this case the point where (0,0) for the printer output will be. It’s important to save the old origin that’s returned from the <code class="calibre23">SetWindowOrg()</code> function. You must restore the old origin when you’ve finished drawing the current page; otherwise the <code class="calibre23">m_rectDraw</code> member of the <code class="calibre23">CPrintInfo</code> object is not set up correctly when you print the next page.</p>
<p class="calibre13">The point in the document that you want to map to the origin of the page has the coordinates <code class="calibre23">xOrg-xOffset</code>,<code class="calibre23">yOrg-yOffset</code>. This may not be easy to visualize, but remember that by setting the window origin, you’re defining the point that maps to the viewport origin. If you think about it, you should see that the <code class="calibre23">xOrg, yOrg</code> point in the document is where you want it on the page.</p>
<p class="calibre13">The complete code for printing a page of the document is:</p>
<pre class="calibre28"><code class="calibre23"><b class="calibre12">// Print a page of the document</b>
void CSketcherView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
  <b class="calibre12">CPrintData* p{static_cast&lt;CPrintData*&gt;(pInfo-&gt;m_lpUserData)};</b>

  <b class="calibre12">// Output the document filename</b>
  <b class="calibre12">pDC-&gt;SetTextAlign(TA_CENTER);        // Center the following text</b>
  <b class="calibre12">pDC-&gt;TextOut(pInfo-&gt;m_rectDraw.right/2, 20, p-&gt;m_DocTitle);</b>
  <b class="calibre12">CString str;</b> 
  <b class="calibre12">str.Format(_T("Page %u") , pInfo-&gt;m_nCurPage);</b>
  <b class="calibre12">pDC-&gt;TextOut(pInfo-&gt;m_rectDraw.right/2, pInfo-&gt;m_rectDraw.bottom-20, str);</b>
  <b class="calibre12">pDC-&gt;SetTextAlign(TA_LEFT);          // Left justify text</b>

  <b class="calibre12">// Calculate the origin point for the current page</b>
  <b class="calibre12">int xOrg {static_cast&lt;int&gt;(p-&gt;m_DocRefPoint.x +</b> 
                           <b class="calibre12">p-&gt;printWidth*((pInfo-&gt;m_nCurPage - 1)%(p-&gt;m_nWidths)))};</b>

  <b class="calibre12">int yOrg {static_cast&lt;int&gt;( p-&gt;m_DocRefPoint.y +</b>
                          <b class="calibre12">p-&gt;printLength*((pInfo-&gt;m_nCurPage - 1)/(p-&gt;m_nWidths)))};</b>


  <b class="calibre12">// Calculate offsets to center drawing area on page as positive values</b>
  <b class="calibre12">int xOffset {static_cast&lt;int&gt;((pInfo-&gt;m_rectDraw.right - p-&gt;printWidth)/2)};</b>
  <b class="calibre12">int yOffset {static_cast&lt;int&gt;((pInfo-&gt;m_rectDraw.bottom - p-&gt;printLength)/2)};</b>

  <b class="calibre12">// Change window origin to correspond to current page &amp; save old origin</b>
  <b class="calibre12">CPoint OldOrg {pDC-&gt;SetWindowOrg(xOrg - xOffset, yOrg - yOffset)};</b>

  <b class="calibre12">// Define a clip rectangle the size of the printed area</b>
  <b class="calibre12">pDC-&gt;IntersectClipRect(xOrg, yOrg, xOrg + p-&gt;printWidth, yOrg + p-&gt;printLength);</b>

<span {http://www.idpf.org/2007/ops}type="pagebreak" title="823" id="calibre_link-1285" class="calibre14"></span>  <b class="calibre12">OnDraw(pDC);                         // Draw the whole document</b>
  <b class="calibre12">pDC-&gt;SelectClipRgn(nullptr);         // Remove the clip rectangle</b>
  <b class="calibre12">pDC-&gt;SetWindowOrg(OldOrg);           // Restore old window origin</b>
<b class="calibre12">}</b></code></pre>
<p class="calibre13">The first step is to initialize the local pointer, <code class="calibre23">p</code>, with the address of the <code class="calibre23">CPrintData</code> object that is stored in the <code class="calibre23">m_lpUserData</code> member of the object to which <code class="calibre23">pInfo</code> points. You then output the file-name that you squirreled away in the <code class="calibre23">CPrintData</code> object. The <code class="calibre23">SetTextAlign()</code> member function of the <code class="calibre23">CDC</code> object allows you to define the alignment of subsequent text output in relation to the reference point you supply for the text string in the <code class="calibre23">TextOut()</code> function. The alignment is determined by the constant passed as an argument to the function. You have three possibilities for specifying the horizontal alignment of the text, as shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">CONSTANT</b></th>
<th class="calibre32"><b class="calibre12">ALIGNMENT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">TA_LEFT</code></td>
<td class="calibre32">The point is at the left of the bounding rectangle for the text, so the text is to the right of the point specified. This is the default alignment.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">TA_RIGHT</code></td>
<td class="calibre32">The point is at the right of the bounding rectangle for the text, so the text is to the left of the point specified.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">TA_CENTER</code></td>
<td class="calibre32">The point is at the center of the bounding rectangle for the text.</td>
</tr>
</tbody>
</table>
<p class="calibre13">You define the x-coordinate of the filename on the page as half the page width, and the y-coordinate as 20 units, which is 0.2 inches, from the top of the page.</p>
<p class="calibre13">After outputting the name of the document file as centered text, you output the page number centered at the bottom of the page. You use the <code class="calibre23">Format()</code> member of the <code class="calibre23">CString</code> class to format the page number stored in the <code class="calibre23">m_nCurPage</code> member of the <code class="calibre23">CPrintInfo</code> object. This is positioned 20 units up from the bottom of the page. You then reset the text alignment to the default setting, <code class="calibre23">TA_LEFT</code>.</p>
<p class="calibre13">The <code class="calibre23">SetTextAlign()</code> function also allows you to change the position of the text vertically by OR-ing a second flag with the justification flag. The second flag can be any of those shown in the following table.</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">CONSTANT</b></th>
<th class="calibre32"><b class="calibre12">ALIGNMENT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">TA_TOP</code></td>
<td class="calibre32">Aligns the top of the rectangle bounding the text with the point defining the position of the text. This is the default.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">TA_BOTTOM</code></td>
<td class="calibre32">Aligns the bottom of the rectangle bounding the text with the point defining the position of the text.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">TA_BASELINE</code></td>
<td class="calibre32">Aligns the baseline of the font used for the text with the point defining the position of the text.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="824" id="calibre_link-1286" class="calibre14"></span>The next action in <code class="calibre23">OnPrint()</code> uses the method that I discussed for mapping an area of the document to the current page. You get the document drawn on the page by calling the <code class="calibre23">OnDraw()</code> function that is used to display the document in the view. This potentially draws the entire document, but you can restrict what appears on the page by defining a <i class="calibre15">clip rectangle</i>. A clip rectangle encloses a rectangular area in the device context within which output appears. Output is suppressed outside of the clip rectangle. It’s also possible to define irregularly shaped areas for clipping, called <i class="calibre15">regions</i>.</p>
<p class="calibre13">The initial default clipping area defined in the print device context is the page boundary. You define a clip rectangle that corresponds to the <code class="calibre23">printWidth</code> by <code class="calibre23">printLength</code> area centered in the page. This ensures that you draw only in this area and the filename and page number will not be overwritten.</p>
<p class="calibre13">After the current page has been drawn by the <code class="calibre23">OnDraw()</code> function call, you call <code class="calibre23">SelectClipRgn()</code> with a <code class="calibre23">nullptr</code> argument to remove the clip rectangle. If you don’t do this, output of the document title is suppressed on all pages after the first, because it lies outside the clip rectangle that would otherwise remain in effect in the print process until the next time <code class="calibre23">IntersectClipRect()</code> gets called.</p>
<p class="calibre13">Your final action is to call <code class="calibre23">SetWindowOrg()</code> again to restore the window origin to its original location, as discussed earlier in this chapter.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Getting a Printout of the Document</h3>
<p class="calibre13">To get your first printed Sketcher document, you just need to build the project and execute the program (once you’ve fixed any typos). If you try File <img src="images/000122.png" alt="image" class="calibre25" /> Print Preview and click on the Two Page button, you should get something similar to the window shown in <a id="calibre_link-153" href="#calibre_link-152" class="calibre3">Figure 17-9</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000047.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-152" href="#calibre_link-153" class="calibre3">FIGURE 17-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="825" id="calibre_link-1287" class="calibre14"></span>You get print preview functionality completely for free. The framework uses the code that you’ve supplied for the normal multipage printing operation to produce page images in the Print Preview window. What you see in the Print Preview window should be exactly the same as appears on the printed page.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-379" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">In this chapter, you have implemented the capability to store a document on disk in a form that allows you to read it back and reconstruct its constituent objects using the serialization processes supported by MFC. You have also implemented the capability to print sketches in the Sketcher application. If you are comfortable with how serialization and printing work in Sketcher, you should have little difficulty with implementing serialization and printing in any MFC application.</p>
<section class="toclist">
<h3 class="calibre21">EXERCISES</h3>
<ol class="calibre5">
<li class="calibre6">Update the code in the <code class="calibre23">OnPrint()</code> function in Sketcher so that the page number is printed at the bottom of each page of the document in the form “Page <i class="calibre15">n</i> of <i class="calibre15">m</i>,” where <i class="calibre15">n</i> is the current page number and <i class="calibre15">m</i> is the total number of pages.</li>
<li class="calibre6">As a further enhancement to the <code class="calibre23">CText</code> class in Sketcher, change the implementation so that scaling works properly with text. (<i class="calibre15">Hint</i>: Look up the <code class="calibre23">CreatePointFont()</code> function in the online help.)</li>
</ol>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="826" id="calibre_link-1288" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Serialization</b></td>
<td class="calibre32">Serialization is the process of transferring objects to a file. Deserialization reconstructs objects from data in a file.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">MFC Serialization</b></td>
<td class="calibre32">To serialize objects in an MFC application, you must identify the class as serializable. To do this you use the <code class="calibre23">DECLARE_SERIAL()</code>macro in the class definition and the <code class="calibre23">IMPLEMENT_SERIAL()</code>macro in the file containing the class implementation.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Serializable classes in an MFC application</b></td>
<td class="calibre32">For a class to be serializable in an MFC application, it must have <code class="calibre23">CObject</code> as a direct or indirect base class, it must implement a no-arg constructor and implement the <code class="calibre23">Serialize()</code> function as a class member.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Printing with the MFC</b></td>
<td class="calibre32">To provide the ability to print a document in an MFC application, you must implement your versions of the <code class="calibre23">OnPreparePrinting(), OnBeginPrinting(), OnPrepareDC(), OnPrint()</code>, and <code class="calibre23">OnEndPrinting()</code> functions in the document view class.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">The <code class="calibre23">CPrintInfo</code> object</b></td>
<td class="calibre32">A <code class="calibre23">CPrintInfo</code> object is created by the MFC framework to store information about the printing process. You can store the address of your own class object that contains print information in a pointer in the <code class="calibre23">CPrintInfo</code> object.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="bodymatter chapter" class="calibre" id="calibre_link-380">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2331" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="827" id="calibre_link-1289" class="calibre9"></span><span class="chapternumber">Chapter 18</span><br class="calibre10" /><span class="chapternumber">Programming for Windows 8</span></h1>
</header>
<div class="calibre11">
<p class="navlisthead"><b class="calibre12">WHAT YOU WILL LEARN IN THIS CHAPTER:</b></p>
<ul class="chapterfeaturinglist">
<li class="calibre6">How applications written for Windows 8 differ from desktop applications</li>
<li class="calibre6">What XAML is and how you use it</li>
<li class="calibre6">How you create the user interface (UI) for an application targeting Windows 8</li>
<li class="calibre6">The characteristics of the interface to the Windows 8 operating system</li>
<li class="calibre6">How to create a project for Windows 8</li>
<li class="calibre6">How to create the UI for an application graphically</li>
<li class="calibre6">How to modify UI elements in C++ code</li>
<li class="calibre6">How to implement event handling</li>
<li class="calibre6">How you can animate UI elements</li>
</ul>
</div>
<p class="navlisthead"><b class="calibre12">WROX.COM CODE DOWNLOADS FOR THIS CHAPTER</b></p>
<p class="calibre13">You can find the <a href="http://wrox.com" class="calibre3">wrox.com</a> code downloads for this chapter on the Download Code tab at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>. The code is in the Chapter 18 download and individually named according to the names throughout the chapter.</p>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-381" class="calibre3"></a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="828" id="calibre_link-1290" class="calibre18"></span>WINDOWS STORE APPLICATIONS</h2>
<p class="calibre13">Applications written for the Windows 8 UI are called Windows Store apps. There is a great deal of detail involved in a comprehensive explanation of how you program these, certainly more than enough to fill an entire book. Consequently this chapter will just provide you with a start down the path, a toe in the water. After a brief outline of the basics, most of the chapter is devoted to walking you through developing a Windows Store app using C++, so it’s learning by doing.</p>
<p class="calibre13">A Windows Store app is very different from a regular Windows desktop application such as Sketcher. The application context is different, the structure of the code is different, and the way the user interacts with the application is different. This is because Windows Store apps are aimed primarily toward tablets with touch screens, and are distributed through the Microsoft application store. Because of the nature of the target platform, apps run in a sandbox that insulates an application from the environment in which it is executing and limits what it can do. Access to files, network connections, and the hardware are all constrained. You interact with a desktop application through the mouse and the keyboard, whereas you interact with a Windows Store app using gestures through the touch-sensitive screen. When you run a Windows Store app on your PC, mouse clicks result in tap events that arise when you tap a touch screen.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Windows 8 is more user-friendly on a desktop machine if you have two displays. If your graphics card allows it, a second display will make life easier. One display will always show the familiar Windows desktop, and both can show it when you have multiple desktop applications running. It is also very easy to switch between the Windows 8 Start screen and the desktop. The taskbar can be on both displays too.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You must have Visual Studio 2013 installed under Windows 8 to enable its Windows 8 development capabilities. You will also need to obtain a Windows 8 developer license, but this is simple &mdash; and free. Windows desktop applications under Windows 8 still use the Win32 API. Windows Store apps use the Windows Runtime (WinRT), which provides the language-independent sandbox.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Windows Store apps use non-standard extensions to C++. It is possible to write Windows Store apps in standard C++ if you use the WinRT C++ Template Library (WRL). This involves relatively low-level programming with the API and WinRT objects, and is beyond the scope of this book.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">The appearance of a Windows Store app and its behavior are defined separately. You define what an app does in C++. You define its UI in the eXtensible Application Markup Language (XAML). You don’t need to be an expert in XAML to create the UI for an application although a basic understanding of it helps a lot. UI design capabilities are provided by the Design pane that enables you to create a UI in a similar manner to the way you created a dialog in the Sketcher. Creating the UI graphically generates the required XAML and related C++ code automatically. You also get a lot of help from IntelliSense when you need to modify the XAML. You’ll get experience with doing both through the example in this chapter.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="829" id="calibre_link-1291" class="calibre14"></span>The definition of the UI and the operations for a Windows Store app are separate, so in principle the development of the UI in XAML and the coding of the operations in C++ can be separate activities. I say “in principle” because the separation cannot be total. How the C++ code needs to be implemented is very dependent on how the UI is defined in XAML. You can synthesize UI components in code, so in many instances you have a choice as to how a component is created.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-382" class="calibre3"></a>DEVELOPING WINDOWS STORE APPS</h2>
<p class="calibre13">Visual C++ provides specialized facilities for developing Windows Store apps that differ in many respects from what you have used up to now. To get an understanding of the development environment for them you should now create a project for a Windows Store app. You’ll be exploring and working with this project throughout this chapter.</p>
<p class="calibre13">Create a new C++ project by pressing Ctrl+Shift+N. Select the Windows Store option for Visual C++ in the left pane and click on the Blank App (XAML) template. This template creates a project with no UI controls predefined, just a Grid layout element covering the entire page, which is otherwise empty, so you’ll create everything else from scratch later in this chapter. You can give the project the name MemoryTest and choose a folder for the solution if you don’t like the default. Click OK to start the project creation. You’ll need to sign up for a developer license to proceed, if you don’t already have one. Follow the dialog prompts for doing this to allow the project to be created.</p>
<p class="calibre13">Display the Solution Explorer pane. The first thing to note is that there are two <code class="calibre23">.xaml</code> files in the list. <code class="calibre23">App.xaml</code> defines the application and <code class="calibre23">MainPage.xaml</code> defines the UI page. A Windows Store app has one or more pages that define the UI, and each is defined by a separate <code class="calibre23">.xaml</code> file. Double-click <code class="calibre23">MainPage.xaml</code> to display it. Loading Designer, which enables you to create and modify the UI, will take a while the first time. You’ll eventually see two editing panes. The Design pane where you can extend and modify the UI page graphically is at the top, and below is the XAML for what you see at the top. The XAML defines what is displayed in the Design pane. You can work with either the XAML or the Design pane, and changes you make in one will be automatically reflected in the other. Keep this project open because I’ll be referring to it throughout the chapter.</p>
<p class="calibre13">I’ll discuss three topics in a little more detail before developing the <code class="calibre23">MemoryTest</code> project further:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The basics of the Windows Runtime</li>
<li class="calibre6">The C++/CX extensions to Standard C++ and how they relate to the WinRT</li>
<li class="calibre6">The nature of XAML and how it defines UI components</li>
</ul>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-383" class="calibre3"></a>WINDOWS RUNTIME CONCEPTS</h2>
<p class="calibre13">WinRT is an object-oriented API for Windows Store apps. WinRT is language neutral, so you can use it with JavaScript and C# as well as C++. It provides the sandbox, in which Windows Store apps execute, and limits the extent to which they can access the operating system and hardware resources.</p>
<p class="calibre13">WinRT applications use different terminology from what you have seen so far. A method is an alternative term for a member function in C++ parlance so these terms are interchangeable. You have <span {http://www.idpf.org/2007/ops}type="pagebreak" title="830" id="calibre_link-1292" class="calibre14"></span>learned about message handler functions that are called when a Windows message or event occurs in a desktop application. In a Windows Store app, a delegate is a function object that encapsulates a method to be called to handle events of a particular type.</p>
<section class="toclist">
<h3 class="calibre21">WinRT Namespaces</h3>
<p class="calibre13">The classes that define WinRT objects are distributed within a large number of namespaces. To give you an idea of the extent of WinRT, there are well over 100 namespaces, each of which contains several, and in some cases many, class definitions. Classes that represent a particular set of UI components are in the same namespace and generally the namespace name gives you an idea of what it contains. The <code class="calibre23">Windows::UI::Xaml::Controls</code> namespace, for example, contains classes that define controls such as buttons, checkboxes, and list boxes. In general, namespaces that relate to the definition or operation of the UI have names that start with <code class="calibre23">Windows::UI</code>, and those that start with <code class="calibre23">Windows::UI::Xaml</code> relate to XAML types that you use to specify a UI.</p>
<p class="calibre13">You can define your own class types in a Windows Store app. If you define a class for objects that are to be passed to a WinRT component, the class must be within a namespace and must be defined differently from standard C++. I’ll explain how shortly.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">TIP</i></b> <i class="calibre15">You will find it useful to have the reference documentation for the WinRT namespaces displayed in your browser while reading this chapter and when you are developing your own Windows Store apps. At the moment, you can find it at</i> <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211377.aspx" class="calibre3">http://msdn.microsoft.com/en-us/library/windows/apps/br211377.aspx</a>.</p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
<section class="toclist">
<h3 class="calibre21">WinRT Objects</h3>
<p class="calibre13">WinRT is an object-oriented API where the objects are similar to Component Object Model (COM) objects. COM provides a mechanism for defining objects that can be accessed and operated on in different programming languages. A COM object is different from the C++ class objects you have been using up to now. You cannot store a COM object in a variable; you can only store a reference to it. COM objects are reference counted, which means that a record of the number of separate references to an object is maintained. When the reference count for a COM object reaches zero, it will be destroyed and any resources the object owns will be released. This is similar to how <code class="calibre23">std::shared ptr</code> smart pointers work.</p>
<p class="calibre13">If you use naked COM object references, you are responsible to call functions at the appropriate times to keep the reference count correct. However, in WinRT, you are not using naked COM objects; WinRT objects have the management of their reference counts built-in. WinRT objects are created on the heap but you don’t have to worry about deleting them because they take care of their own destruction.</p>
<p class="calibre13">Because they are essentially COM objects, WinRT objects can be complicated to work with using standard C++. To work with COM objects you must understand the interfaces involved and stick to the rules for using them. For this reason, Visual C++ includes a set of Microsoft-specific C++ language extensions that hide the complexity of working with WinRT objects, which makes <span {http://www.idpf.org/2007/ops}type="pagebreak" title="831" id="calibre_link-1293" class="calibre14"></span>your code much easier to write. These language extensions are referred to as C++/CX, from C++ Component Extensions. When you use C++/CX to work with WinRT objects, you can still use all of the standard C++ language and library facilities, including the STL. Any data passed to or received from the WinRT is always in terms of WinRT objects though, and you must always use C++/CX class types to reference them.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-384" class="calibre3"></a>C++ COMPONENT EXTENSIONS (C++/CX)</h2>
<p class="calibre13">All data that you pass to, or receive from, the WinRT must be WinRT objects. You cannot pass objects of standard C++ class types to WinRT components. There are two types of WinRT objects &mdash; value types that have pass-by-value semantics and <code class="calibre23">ref class</code> types that are passed by reference. Data of any of the fundamental C++ types will be converted to a WinRT value type automatically, so you can always use these in your Windows Store apps. <code class="calibre23">ref class</code> (or <code class="calibre23">ref struct</code>) types are the WinRT equivalents of the standard C++ <code class="calibre23">class</code> (or <code class="calibre23">struct</code>) types. All variables of <code class="calibre23">ref class</code> types store references, not objects. C++/CX provides additional language syntax for defining WinRT types and for working with WinRT objects.</p>
<section class="toclist">
<h3 class="calibre21">C++/CX Namespaces</h3>
<p class="calibre13">There are three C++/CX namespaces that contain things you should know about. These are the default namespaces that contain WinRT type definitions:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">The <code class="calibre23">Platform</code> namespace includes value types corresponding to C++ fundamental types.</li>
<li class="calibre6">The <code class="calibre23">Platform::Collections</code> namespace includes container classes for WinRT types.</li>
<li class="calibre6">The <code class="calibre23">Windows::Foundation::Collections</code> namespace provides functions supporting the containers in the <code class="calibre23">Platform::Collections</code> namespace.</li>
</ul>
<p class="calibre13">The <code class="calibre23">Platform</code> namespace contains, among others, the following built-in WinRT types:</p>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TYPE</b></th>
<th class="calibre32"><b class="calibre12">USE</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Object</code></td>
<td class="calibre32">The ultimate base class for all WinRT types. A reference of this type can represent any WinRT type.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">String</code></td>
<td class="calibre32">An immutable Unicode character string. You must use this string type to pass strings to WinRT components.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Boolean</code></td>
<td class="calibre32">A value that is the equivalent of type <code class="calibre23">bool</code>.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">SizeT</code></td>
<td class="calibre32">An unsigned data type that represents the size of an object.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">IntPtr</code></td>
<td class="calibre32">A signed pointer value.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">UIntPtr</code></td>
<td class="calibre32">An unsigned pointer value.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><code class="calibre23">Guid</code></td>
<td class="calibre32">A 16-byte value that represents a globally unique identifier.</td>
</tr>
</tbody>
</table>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="832" id="calibre_link-1294" class="calibre14"></span>Note that <code class="calibre23">Boolean, Guid, SizeT, IntPtr</code>, and <code class="calibre23">UIntPtr</code> are value types and <code class="calibre23">Object</code> and <code class="calibre23">String</code> are ref class types. You are likely to use the <code class="calibre23">String</code> class most often, to represent text. The <code class="calibre23">Platform</code> namespace also includes the <code class="calibre23">Array</code> class that defines a one-dimensional array of object references. You cannot use standard C++ arrays to hold WinRT object references. You cannot define multidimensional arrays with C++/CX.</p>
<p class="calibre13">The containers in the <code class="calibre23">Platform::Collections</code> namespace store WinRT object references. It provides <code class="calibre23">Map</code> and <code class="calibre23">Vector</code> collection class types as well as <code class="calibre23">MapView</code> and <code class="calibre23">VectorView</code> types that provide read-only collections. You’ll be using a <code class="calibre23">Vector</code> in the <code class="calibre23">MemoryTest</code> example.</p>
<p class="calibre13">The <code class="calibre23">Windows::Foundation::Collections</code> namespace defines <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> functions that return iterators for the collection class reference that you pass as the argument. You can use these iterators to apply the functions in the STL <code class="calibre23">algorithm</code> header to a <code class="calibre23">Vector</code> container. You will use these in the <code class="calibre23">MemoryTest</code> example. The namespace also defines a <code class="calibre23">back_inserter()</code> function that returns an iterator you use to insert a value at the end of a collection, and a <code class="calibre23">to_vector()</code> function that returns the contents of a <code class="calibre23">Vector</code> you pass to the function as an STL <code class="calibre23">std::vector</code> object.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Defining WinRT Class Types</h3>
<p class="calibre13">You cannot use standard C++ classes to define objects to use with the WinRT. The C++/CX language extensions provide an easy way to create ref class types and work with WinRT class objects. You define a WinRT class type using the <code class="calibre23">ref class</code> keyword, which indicates that the class is a WinRT type. The class definition in the <code class="calibre23">MainPage.xaml.h</code> file for the <code class="calibre23">MemoryTest</code> application looks like this:</p>
<pre class="calibre28"><code class="calibre23">namespace MemoryTest
{
  /// &lt;summary&gt;
  /// An empty page that can be used on its own or navigated to within a Frame.
  /// &lt;/summary&gt;
  public ref class MainPage sealed
  {
  public:
    MainPage();
  };
}</code></pre>
<p class="calibre13"><code class="calibre23">MainPage</code> is defined as a <code class="calibre23">ref class</code> so a reference to a <code class="calibre23">MainPage</code> object can be passed to or received from a WinRT method. The <code class="calibre23">sealed</code> keyword prevents this class from being used as a base class. The namespace name is the project name. Remember, all WinRT class types must be defined in a namespace.</p>
<p class="calibre13">Here’s how you might define your own ref class type:</p>
<pre class="calibre28"><code class="calibre23">namespace MemoryTest
{
public ref class Card sealed
  {
  public:
    // Public members...
 
  private: 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="833" id="calibre_link-1295" class="calibre14"></span>    // Private members...
 
  protected: 
    // Protected members...
 
  internal:
    // Internal members...
  };
}</code></pre>
<p class="calibre13">Members of a ref class can be standard C++ types and ref class types, but members of standard C++ types can only appear in the <code class="calibre23">internal</code> or <code class="calibre23">private</code> sections of the class.</p>
<p class="calibre13">When a Windows Store app is compiled, information about the ref class types it includes is recorded in a <code class="calibre23">.winmd</code> file as metadata. If you compile the <code class="calibre23">MemoryTest</code> debug configuration, you’ll see the <code class="calibre23">MemoryTest.winmd</code> file in the <code class="calibre23">MemoryTest\Debug\MemoryTest</code> folder for the project. The <code class="calibre23">.winmd</code> file specifies the public and protected interface to the ref class types in the application that can be accessed by other development languages such as C# and JavaScript. Only <code class="calibre23">public</code> ref classes defined in a namespace will appear in metadata. You can use non-public ref class types in your application if you don’t want the class interface to appear in the metadata. <code class="calibre23">ref class</code> members in the <code class="calibre23">internal</code> and <code class="calibre23">private</code> sections of a class are not published in metadata.</p>
<p class="calibre13">All <code class="calibre23">public</code> and <code class="calibre23">protected</code> data members of a ref class type must be defined as properties. They cannot be ordinary data members. A property is a data member that has a privately stored value that you access through public <code class="calibre23">get()</code> and <code class="calibre23">set()</code> methods. You define a property using the <code class="calibre23">property</code> keyword. The names of properties begin with an uppercase letter by convention. Here’s the <code class="calibre23">Card</code> class with two properties defined:</p>
<pre class="calibre28"><code class="calibre23">public ref class Card sealed
{
public:
  property Platform::String^ Type; 
  property Windows::UI::Xaml::Media::SolidColorBrush^ Color;
};</code></pre>
<p class="calibre13">The <code class="calibre23">Type</code> and <code class="calibre23">Color</code> properties are trivial properties, for which the compiler inserts <code class="calibre23">get()</code> or <code class="calibre23">set()</code> method calls automatically when you retrieve or store a value. Thus you access data members that are trivial properties as though they were ordinary public data members. The compiler supplies default implementations of the <code class="calibre23">get()</code> and <code class="calibre23">set()</code> methods for a property that simply retrieve or assign the value. You can define the <code class="calibre23">get()</code> and <code class="calibre23">set()</code> methods for a property explicitly when you need something more than the default behavior. Here’s how you could define the <code class="calibre23">Type</code> property in the <code class="calibre23">Card</code> class with <code class="calibre23">get()</code> and <code class="calibre23">set()</code> methods:</p>
<pre class="calibre28"><code class="calibre23">property Platform::String^ Type
{
  Platform::String^ get() { return m_type;  }
  void set(Platform::String^ newType)  { m_type = newType;  }
}
 
private:
Platform::String^ m_type;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="834" id="calibre_link-1296" class="calibre14"></span>I’ll explain the notation for specifying ref class variables types in the next section. The <code class="calibre23">get()</code> and <code class="calibre23">set()</code> methods here are the same as the defaults that are created by the compiler but they could be more complicated. You can omit the <code class="calibre23">set()</code> method definition and just define a <code class="calibre23">get()</code> method, in which case the property will be read-only.</p>
<p class="calibre13">The C++/CX syntax for defining a class can include the <code class="calibre23">partial</code> keyword. This is used to specify that a class definition is not complete and there is an additional part of the definition elsewhere. The <code class="calibre23">MainPage</code> class that you have seen in the <code class="calibre23">MemoryTest</code> example is not the whole story. The definition you saw earlier complements a partial definition of the same class. You can see the partial definition if you switch to Class View, extend <code class="calibre23">MainPage</code> and then <code class="calibre23">Partial Definitions</code> in the pane by clicking the arrows at the left, then double-click <code class="calibre23">MainPage</code>. The class definition looks like this:</p>
<pre class="calibre28"><code class="calibre23">partial ref class MainPage : 
             public ::Windows::UI::Xaml::Controls::Page, 
             public ::Windows::UI::Xaml::Markup::IComponentConnector
{
public:
    void InitializeComponent();
     virtual void Connect(int connectionId, ::Platform::Object^ target);
 
private:
    bool _contentLoaded;
};</code></pre>
<p class="calibre13">The pane tab showing this code appears in a pane at the extreme right with the tab shaded mauve. The Mauve tab is a “preview” tab (hover the mouse over the tab to see the Preview tooltip). Once you start typing into the document, then the Mauve tab becomes blue and moves to the left. When you change the XAML, the class will be updated. The class here is defined using the <code class="calibre23">partial</code> keyword, and the previous definition that you saw is combined with this to form the complete <code class="calibre23">MainPage</code> class. UI elements that you create using XAML will have corresponding members defined in this class that reference WinRT component objects.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Variables of Ref Class Types</h3>
<p class="calibre13">A variable of a ref class type is called a handle because it stores a reference to an object, not the object itself. A handle is like a smart pointer in standard C++. When you assign the value of one ref class variable to another, the handle is copied, not the object. The only way you can get two identical ref class objects is to create them explicitly. You specify a ref class type for a variable using the class type name followed by <code class="calibre23">^</code>, which is referred to as a hat symbol. Here’s an example of defining a ref class variable:</p>
<pre class="calibre28"><code class="calibre23">SolidColorBrush^ redBrush =
                     ref new SolidColorBrush(Windows::UI::Colors::Red);</code></pre>
<p class="calibre13">This defines <code class="calibre23">redBrush</code> as a handle to a <code class="calibre23">SolidColorBrush</code> object, which is an object that defines a brush that fills an area with a particular color. This <code class="calibre23">ref</code> class definition is in the <code class="calibre23">Windows::UI::Xaml::Media</code> namespace. A WinRT object is created using ref new, and is destroyed automatically when no reference to it exists. If you create a ref class object in a function and the only reference is stored in a local variable, the object will be destroyed when the function returns. <span {http://www.idpf.org/2007/ops}type="pagebreak" title="835" id="calibre_link-1297" class="calibre14"></span>The argument to the <code class="calibre23">SolidColorBrush</code> constructor is a constant member of the <code class="calibre23">Colors</code> class. This class defines a large number of members that represent standard colors.</p>
<p class="calibre13">You can use the <code class="calibre23">auto</code> keyword when creating ref class objects:</p>
<pre class="calibre28"><code class="calibre23">auto redBrush = ref new SolidColorBrush(Windows::UI::Colors::Red);</code></pre>
<p class="calibre13">This does the same as the previous statement.</p>
<p class="calibre13">You could create an array that holds handles to ref class objects like this:</p>
<pre class="calibre28"><code class="calibre23">auto brushes = ref new Platform::Array&lt;SolidColorBrush^&gt;(10);</code></pre>
<p class="calibre13">The <code class="calibre23">brushes</code> array stores 10 handles to <code class="calibre23">SolidColorBrush</code> objects. You specify the element type between the angle brackets following the <code class="calibre23">Array</code> class name. Here it is <code class="calibre23">SolidColorBrush^</code> &mdash; a handle to a <code class="calibre23">SolidColorBrush</code> object.</p>
<p class="calibre13">You can create an array of handles with a set of initializers:</p>
<pre class="calibre28"><code class="calibre23">  Platform::Array&lt;SolidColorBrush^&gt;^ colors = 
                          {redBrush, greenBrush, blueBrush, yellowBrush};</code></pre>
<p class="calibre13">The <code class="calibre23">colors</code> array is a handle to an array that will contain four elements initialized with the <code class="calibre23">SolidColorBrush^</code> handles that appear between the braces. You can omit the <code class="calibre23">=</code> here.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Accessing Members of a Ref Class Object</h3>
<p class="calibre13">You use the <code class="calibre23">-&gt;</code> operator with an object reference to access a member of the object. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">auto brush = ref new Windows::UI::Xaml::Media::SolidColorBrush();
brush-&gt;Color = Windows::UI::Colors::White;</code></pre>
<p class="calibre13">This creates the <code class="calibre23">brush</code> reference to a <code class="calibre23">SolidColorBrush</code> object and sets its <code class="calibre23">Color</code> property to <code class="calibre23">Colors::White</code>. The notation for calling a method for an object is exactly the same as referencing a property &mdash; you just use <code class="calibre23">-&gt;</code> between the handle and the method name.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Event Handlers</h3>
<p class="calibre13">A method that handles events for a UI element is a regular C++ function with a particular signature that will depend on the element type. A typical event handler declaration in a class looks like this:</p>
<pre class="calibre28"><code class="calibre23">void Button_Tapped_1(Platform::Object^ sender, 
                     Windows::UI::Xaml::Input::TappedRoutedEventArgs^ e);</code></pre>
<p class="calibre13">This declaration for a button event handler was created automatically. It executes when the button is tapped on a tablet or when it is clicked with the mouse. The first parameter is the handle to the UI object that originated the event. You need to cast this to the appropriate type before you use it. The second argument provides additional information about the event. Event handlers for UI elements generally have two parameters with the first parameter of type <code class="calibre23">Platform::Object^</code> referencing the object originating the event. The type of the second parameter varies because it is a reference to an object representing the event. Generally, event handlers have a <code class="calibre23">void</code> return type. The address of an event handler is recorded in a delegate, which is an object that has similarities to a function pointer in standard C++.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="836" id="calibre_link-1298" class="calibre14"></span>The delegate type for button tapped events is defined as:</p>
<pre class="calibre28"><code class="calibre23">public delegate void RoutedEventHandler(
Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e);</code></pre>
<p class="calibre13">Any method that has the signature of this delegate can be added to a delegate of this type. The <code class="calibre23">TappedRoutedEventArgs</code> class is derived from <code class="calibre23">RoutedEventArgs</code>, so the <code class="calibre23">Button_Tapped_1()</code> handler function is consistent with this. You won’t need to worry about the intricacies of delegates and event handler functions in this chapter because handler functions for UI component events are defined and registered automatically. All you have to worry about is what the handler function is going to do when it is called.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Casting Ref Class References</h3>
<p class="calibre13">In the previous section you learned that you receive a reference to the object causing an event as type <code class="calibre23">Object^</code> and you must cast this in order to call methods for the type of object it actually is. You can use <code class="calibre23">static_cast</code> with references to WinRT objects, but it is better to use <code class="calibre23">safe_cast&lt;T&gt;</code> where <code class="calibre23">T</code> is the destination type. <code class="calibre23">safe_cast&lt;T&gt;</code> will throw a WinRT compatible exception if the cast fails.</p>
<p class="calibre13">Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">void Button_Tapped_1(Object^ sender, TappedRoutedEventArgs^ e)
{
  Button^ button  = safe_cast&lt;Button^&gt;(sender);
  button-&gt;Background = redBrush;
}</code></pre>
<p class="calibre13">The <code class="calibre23">Button</code> class is in the <code class="calibre23">Windows::UI::Xaml::Controls</code> namespace. The first statement in the handler casts <code class="calibre23">sender</code> to type <code class="calibre23">Button^</code>. The next sets the value of the <code class="calibre23">Background</code> property to <code class="calibre23">redBrush</code>.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-385" class="calibre3"></a>THE EXTENSIBLE APPLICATION MARKUP LANGUAGE (XAML)</h2>
<p class="calibre13">XAML is a language that is defined in the eXtensible Markup Language (XML). XML is a meta-language that is used for defining a wide range of application-specific languages. XAML looks a bit like HTML in that it consists of tags and attributes with embedded text, but don’t be fooled &mdash; XAML is quite different, There are rigid rules for writing XAML correctly; there’s none of the flexibility you have when writing HTML. You use XAML to define a set of elements in a hierarchy that specify the UI for a Windows Store app. The UI for an application consists of one or more pages, and each page is defined by a separate XAML file with the extension <code class="calibre23">.xaml</code>.</p>
<p class="calibre13">The XAML definition for a page includes the controls and their layout. It also associates C++ functions with events that originate from user interaction with the controls in the UI. The XAML definition of a UI component will have an associated C++ class that encapsulates the component and its characteristics. A UI page defined by a <code class="calibre23">.xaml</code> file will have an associated <code class="calibre23">.h</code> file that contains the definition of the class, and an associated <code class="calibre23">.cpp</code> file that contains the class implementation.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="837" id="calibre_link-1299" class="calibre24"></span>XAML Elements</h3>
<p class="calibre13">A XAML file always contains XAML elements arranged in a hierarchy. A XAML element has a type name that is case sensitive. You can define a XAML element by a start tag &mdash; <code class="calibre23">&lt;Grid&gt;</code>, for example &mdash; followed by some optional element content, followed by an end tag &mdash; such as <code class="calibre23">&lt;/Grid&gt;</code>. You can also define an element by a single tag called a start-end tag &mdash; for example, <code class="calibre23">&lt;Grid/&gt;</code>. A tag is always delimited by a pair of angle brackets, &lt;&gt;. All tags contain an element type name that is unique &mdash; <code class="calibre23">Grid</code> in the preceding examples.</p>
<p class="calibre13">In general, an element can contain other elements between its start and end tags. These are called <i class="calibre15">child elements</i> of the enclosing element. The enclosing element is the parent for its child elements. Elements must not overlap so an end tag must always have the same type name as a matching start tag that precedes it, and a child element must be completely enclosed between the start and end tags for its parent. There is always just one root element in a file that encloses all the other elements; specifying more than one root element is not legal XAML.</p>
<p class="calibre13">A XAML element typically has attributes that specify properties for whatever is being defined; the color, dimensions, and orientation of a control, for example.</p>
<p class="calibre13">Here’s a XAML element that defines a button control:</p>
<pre class="calibre28"><code class="calibre23">&lt;Button x:Name="okButton" Background="Blue" Width="150" Click="HandleOK"&gt;
OK
&lt;/Button&gt;</code></pre>
<p class="calibre13">The element type name is <code class="calibre23">Button</code>. This defines a button control that is labeled <code class="calibre23">OK</code>. The label specification appears between the start tag on the first line, and the end tag, <code class="calibre23">&lt;/Button&gt;</code>. The items following the type name in the start tag are attributes that define values for properties for the button control; each attribute definition is separated from the next by a space. The <code class="calibre23">x:Name</code> property value specifies a name that you can use in C++ code to reference the button object. This name must be different from any other names that you assign in this way in the XAML file. The <code class="calibre23">Background</code> property value specifies the background color for the button. <code class="calibre23">Width</code> defines its width in pixels. The <code class="calibre23">Click</code> property value specifies the name of the function in the C++ class associated with the UI page that will be called when the button is clicked. Property values are always specified by a string in XAML.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The name for a control that is specified in the XAML for a UI page will not exist in the C++ code in your project until you save the XAML file, so always save the file before you add code that references objects defined in XAML. After a name is defined, IntelliSense will help you choose the function to call for the object in C++.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">You could define the previous button with a single tag:</p>
<pre class="calibre28"><code class="calibre23">&lt;Button x:Name="okButton" Background="Blue" Width="150"
        Click="HandleOK" Content="OK"/&gt;</code></pre>
<p class="calibre13">This defines the same button control as the preceding example but using a start-end tag. The forward slash preceding the closing angle bracket indicates the end of the start-end tag. The button <span {http://www.idpf.org/2007/ops}type="pagebreak" title="838" id="calibre_link-1300" class="calibre14"></span>label is now defined by the <code class="calibre23">Content</code> property value. The slash preceding the closing angled bracket indicates that this is both a start and an end tag.</p>
<p class="calibre13">Here’s an example of an element with child elements:</p>
<pre class="calibre28"><code class="calibre23">&lt;StackPanel Height="400" Width="900"
            HorizontalAlignment="Left" VerticalAlignment="Top"&gt;
   &lt;Button x:Name="okButton" Background="Blue" Width="150" 
           Click="HandleOK" Content="OK"/&gt;
   &lt;Button x:Name="cancelButton" Background="Blue" Width="150"
           Click="HandleCancel" Content="Cancel"/&gt;
&lt;/StackPanel&gt;</code></pre>
<p class="calibre13">The <code class="calibre23">StackPanel</code> element has two child elements that are buttons. Note how the child elements are indented with respect to the parent. Child elements are indented in this way to make the structure of the XAML easier to see.</p>
<p class="calibre13">When necessary, you can add comments in XAML. A XAML comment looks like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;!-- This is a comment. --&gt;</code></pre>
<p class="calibre13">A XAML comment starts with <code class="calibre23">&lt;!--</code> and ends with <code class="calibre23">--&gt;</code>. You can define a comment spanning several lines:</p>
<pre class="calibre28"><code class="calibre23">&lt;!--
    This is a comment that is spread
    over two lines.
--&gt;</code></pre>
<p class="calibre13">The root element for a page looks like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;Page
    x:Class="MemoryTest.MainPage"
    
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:MemoryTest"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"&gt;
&lt;/Page&gt;</code></pre>
<p class="calibre13">This is the root element for the <code class="calibre23">MainPage</code> in the <code class="calibre23">MemoryTest</code> example. The stuff following <code class="calibre23">Page</code> between the angle brackets in the start tag are properties that identify the page and the set of rules for the XAML in the file. The <code class="calibre23">xmlns</code> property value, for example, identifies the namespace name for the XAML specification. This is just a unique identifier and does not necessarily relate to a real web page. All the elements that define the page must appear between the <code class="calibre23">Page</code> start and end tags.</p>
</section>
<section class="toclist">
<h3 class="calibre21">UI Elements in XAML</h3>
<p class="calibre13">The entities that you can add to the Design pane are in the Toolbox pane, shown in <a id="calibre_link-1399" href="#calibre_link-438" class="calibre3">Figure 18-1</a>. You have a wide range of elements, including controls, elements that define a layout for several controls, and shapes such as ellipses and rectangles. When you add a control to the Design pane, the XAML that defines the control is added to the <code class="calibre23">.xaml</code> file for the page immediately. You can amend <span {http://www.idpf.org/2007/ops}type="pagebreak" title="839" id="calibre_link-1301" class="calibre14"></span>the dimensions and location of the control by interacting with the graphic in the Design pane. This will cause the property values in the XAML for an element to be updated. You can also amend the values of properties in the XAML and the changes will be reflected in the Design pane.</p>
<figure class="calibre16">
<img class="center" src="images/000005.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-438" href="#calibre_link-1399" class="calibre3">FIGURE 18-1</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You can change the properties of an element through the Properties pane. You can see this if you click on the <code class="calibre23">Grid</code> element in the listing for <code class="calibre23">MainPage.xaml</code> in the <code class="calibre23">MemoryTest</code> project to display the Properties pane. It will look like <a id="calibre_link-1400" href="#calibre_link-439" class="calibre3">Figure 18-2</a>, where I have extended the Layout and Appearance properties. If Properties is not showing, just select the element in the Design pane and press Alt+Enter or select from the View <img src="images/000122.png" alt="image" class="calibre25" /> Other Windows menu to display the pane.</p>
<figure class="calibre16">
<img class="center" src="images/000134.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-439" href="#calibre_link-1400" class="calibre3">FIGURE 18-2</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The Properties pane does not necessarily display all the properties that an element has.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="840" id="calibre_link-1302" class="calibre14"></span>Every XAML element has a corresponding WinRT class type. A <code class="calibre23">Button</code> element in XAML is defined by the <code class="calibre23">Button</code> class in the WinRT. For each element in the XAML for a page, there will be a WinRT object created in the application. If you define a value for the <code class="calibre23">x:Name</code> property for a XAML element, there will be a member of the page class that has that name. The member is a handle for the WinRT object.</p>
<p class="calibre13">A WinRT object that defines a UI component typically will be of a derived type. For example, the <code class="calibre23">Ellipse</code> class that is defined in the <code class="calibre23">Windows::UI::Xaml::Shapes</code> namespace has the inheritance hierarchy shown in <a id="calibre_link-1401" href="#calibre_link-440" class="calibre3">Figure 18-3</a>. The Properties pane will show all the properties that are relevant to the definition of an <code class="calibre23">Ellipse</code> element, and many of these are inherited. This does not mean that it shows all the inherited properties.</p>
<figure class="calibre16">
<img class="center" src="images/000088.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-440" href="#calibre_link-1401" class="calibre3">FIGURE 18-3</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">Knowing which properties are inherited is important when you store UI object references of different types in an array that stores base class references. For example, you might want to store shape elements such as <code class="calibre23">Rectangle</code> and <code class="calibre23">Ellipse</code> in an array so you declare the array element type as the base class type, <code class="calibre23">Shape^</code>. The elements inherit many properties such as <code class="calibre23">Fill, Height</code>, and <code class="calibre23">Width</code> from the <code class="calibre23">Shape</code> class, so you can modify the values of these without casting a reference in the array to its actual type.</p>
<p class="calibre13">As I said earlier, changes to the XAML file are reflected in the Design pane. Modifying XAML is not as daunting as it may sound, even if you are not an expert in XAML, because you get a lot of help to get it right from IntelliSense.</p>
<p class="calibre13">The controls in the Toolbox pane do not represent everything that you can define in XAML. There are additional element types such as <code class="calibre23">Polygon</code>, which defines a polygonal shape, and many element properties can be defined by other XAML elements. Clearly, you can only create such elements by adding the XAML for them. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">&lt;Polygon x:Name="triangle" Fill="Red" Points="0,70 70,70 35,0" 
         HorizontalAlignment="Center" VerticalAlignment="Center"
         Height="70" Width="70"/&gt;</code></pre>
<p class="calibre13">This defines a <code class="calibre23">Polygon</code> element that is a triangle filled in red. The vertices are defined by the <code class="calibre23">Points</code> property values. It has a name specified by the <code class="calibre23">x:Name</code> property value so you reference the object for this UI element with <code class="calibre23">triangle</code> in your C++ code. A <code class="calibre23">Polygon</code> element cannot have content, so you can only use a start-end tag to define it. You don’t have to remember this. You will see a warning if you try to insert an element with content that is not permitted.</p>
<p class="calibre13">Elements that can have content can be defined by a start tag and an end tag with the XAML for the content between them. If you don’t need to specify content, you can use just a single start-end tag. Elements that cannot have content must be defined with a single start-end tag. Look at this:</p>
<pre class="calibre28"><code class="calibre23">&lt;Ellipse x:Name="circle" Height="100" Margin="10" Width="100"
         HorizontalAlignment="Center" VerticalAlignment="Center"&gt;
  &lt;Ellipse.Fill&gt;
    &lt;SolidColorBrush x:Name="blueBrush" Color="Blue"/&gt;
  &lt;/Ellipse.Fill&gt;
&lt;/Ellipse&gt;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="841" id="calibre_link-1303" class="calibre14"></span>This defines an <code class="calibre23">Ellipse</code> element with the name <code class="calibre23">circle</code>, so you can use <code class="calibre23">circle</code> to reference the shape in C++. The <code class="calibre23">Margin</code> property specifies the distance between the <code class="calibre23">Ellipse</code> element and the four edges of its parent cell. A single value for the property applies to all four edges so the distance between the ellipse and its parent will be 10 here. You are not limited to a single property value though. When you specify more than one, the values can be separated by spaces or commas. With two values for the <code class="calibre23">Margin</code> property value, the first specifies both left and right margins and the second the top and bottom margins. If you specify four values they are the left, top, right, and bottom margins.</p>
<p class="calibre13">The ellipse will display as a circle with a diameter of 100 that is filled in blue. The color fill for the interior of the shape is specified by a nested <code class="calibre23">Ellipse.Fill</code> element that defines the <code class="calibre23">Fill</code> property value for the <code class="calibre23">Ellipse</code> element. An <code class="calibre23">Ellipse</code> element cannot have independent content, but it can have elements that define its property values. The color value for the <code class="calibre23">Fill</code> property for the <code class="calibre23">Ellipse</code> element is specified by a further nested XAML element of type <code class="calibre23">SolidColorBrush</code>. The <code class="calibre23">Color</code> property value for the <code class="calibre23">SolidColorBrush</code> object is <code class="calibre23">Blue</code>, which is a standard color. The <code class="calibre23">SolidColorBrush</code> element has a name assigned as the value for <code class="calibre23">x:Name</code> so you can reference the brush object in code as <code class="calibre23">blueBrush</code>. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">if(circle-&gt;Fill == blueBrush)
  circle-&gt;Fill = redBrush;</code></pre>
<p class="calibre13">This statement compares the <code class="calibre23">Fill</code> attribute for the <code class="calibre23">circle</code> object to <code class="calibre23">blueBrush</code>. If they match, the <code class="calibre23">Fill</code> property value is changed to another <code class="calibre23">SolidColorBrush</code> object: <code class="calibre23">redBrush</code>.</p>
<p class="calibre13">You could try entering the XAML for the ellipse in the <code class="calibre23">MemoryTest</code> project. Type the XAML immediately before the <code class="calibre23">&lt;/Grid&gt;</code> end tag in the <code class="calibre23">MainPage.xaml</code> file. You’ll see the blue circle displayed in the Design pane. You can delete the XAML afterwards and the circle will disappear from the Design pane.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Attached Properties</h3>
<p class="calibre13">When you set property values in XAML, you are setting values for the property members of the WinRT object that defines the element. A XAML element can also have attached properties. An attached property allows a child element to set a value for a property belonging to a parent element. A child references a property belonging to a parent by qualifying the property name with the type name for the parent. The value for an attached property can be specified as a property in a child or as another child element. Here’s an example of using an attached property:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Margin="0,0,10,0"&gt;
   &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="100*"/&gt;
      &lt;RowDefinition Height="100*"/&gt;
   &lt;/Grid.RowDefinitions&gt;
   &lt;Grid.ColumnDefinitions&gt;
      &lt;ColumnDefinition Width="75*"/&gt;
      &lt;ColumnDefinition Width="75*"/&gt;
   &lt;/Grid.ColumnDefinitions&gt;
   &lt;Rectangle Height="70" Width="70" Grid.Row="0" Grid.Column="0"/&gt;
   &lt;Rectangle Height="70" Width="70" Grid.Row="0" Grid.Column="1"/&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="842" id="calibre_link-1304" class="calibre14"></span>The <code class="calibre23">Grid.Row</code> and <code class="calibre23">Grid.Column</code> specifications in the <code class="calibre23">Rectangle</code> elements are attached properties. They specify values for the <code class="calibre23">Row</code> and <code class="calibre23">Column</code> properties in the parent <code class="calibre23">Grid</code> element and define where the <code class="calibre23">Rectangle</code> elements are to be located in the grid.</p>
<p class="calibre13">A code snippet in the previous section shows an attached property specified by a child element:</p>
<pre class="calibre28"><code class="calibre23">&lt;Ellipse Height="100" Margin="10" Width="100"
         HorizontalAlignment="Center" VerticalAlignment="Center"&gt;
  &lt;Ellipse.Fill&gt;
    &lt;SolidColorBrush x:Name="blueBrush" Color="Blue"/&gt;
  &lt;/Ellipse.Fill&gt;
&lt;/Ellipse&gt;</code></pre>
<p class="calibre13">The <code class="calibre23">Ellipse.Fill</code> child element specifies the <code class="calibre23">Fill</code> property for the parent <code class="calibre23">Ellipse</code> element.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Parents and Children</h3>
<p class="calibre13">A parent element knows its children and a child element knows its parent. Elements that have <code class="calibre23">Windows::UI::Xaml::FrameworkElement</code> as a base inherit the <code class="calibre23">Parent</code> property, which has a value that is a reference to the parent object. The parent reference is of type <code class="calibre23">DependencyObject^</code>, which is a base for the <code class="calibre23">UIElement</code> class that is defined in the <code class="calibre23">Windows::UI::Xaml</code> namespace. Thus you will need a way to figure out what the actual parent type is when you want to work with it in your code.</p>
<p class="calibre13">Elements that can have children have <code class="calibre23">Windows::UI::Xaml::Controls::Panel</code> as a base, from which they inherit the <code class="calibre23">Children</code> property. <code class="calibre23">Children</code> has a value that defines a collection of child elements. The value is a reference to an object of type <code class="calibre23">UIElementCollection</code> that is defined in the <code class="calibre23">Windows::UI::Xaml::Controls</code> namespace. The references to the child elements are stored in the collection as type <code class="calibre23">UIElement</code>. You can use the <code class="calibre23">Children</code> property value to access the child elements in your code without having to specify individual names in XAML. You’ll see how you access and use a collection of child elements in the <code class="calibre23">MemoryTest</code> example.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Control Elements</h3>
<p class="calibre13">There are many control elements, as you will have seen in the Toolbox pane that is shown in <a href="#calibre_link-438" class="calibre3">Figure 18-1</a>. Most of these are contained in the <code class="calibre23">Windows::UI::Xaml::Controls</code> namespace, but types that define shapes are in the <code class="calibre23">Windows::UI::Xaml::Shapes</code> namespace. As you might expect, several of these are functionally very similar to controls for a desktop application, and these include <code class="calibre23">Button, CheckBox, ComboBox, ListBox</code>, and <code class="calibre23">TextBox</code> elements. The <code class="calibre23">Rectangle</code> element defines a rectangle that can be optionally filled and it has a similar set of properties to an <code class="calibre23">Ellipse</code> element; a <code class="calibre23">Rectangle</code> element also has additional properties over an <code class="calibre23">Ellipse</code> such as <code class="calibre23">RadiusX</code> and <code class="calibre23">RadiusY</code> that specify how the corners are to be rounded.</p>
<p class="calibre13">The <code class="calibre23">FlipView</code> control is interesting. It can flip sequentially through the items in a collection under the control of your code. The items can be anything; text or images, for example. The collection of items can be a static set, or items can be added programmatically. This control also has built-in animation capability.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="843" id="calibre_link-1305" class="calibre24"></span>Layout Elements</h3>
<p class="calibre13">The principle layout elements that control how control elements are arranged on a UI page are <code class="calibre23">Grid</code> and <code class="calibre23">StackPanel</code> from the <code class="calibre23">Windows::UI::Xaml::Controls</code> namespace. They each arrange elements in a different way. A <code class="calibre23">Grid</code> provides a rectangular grid of cells in which you can place elements, whereas a <code class="calibre23">StackPanel</code> provides a linear stack of elements that can be horizontal or vertical. The <code class="calibre23">Grid</code> element is perhaps the most frequently used layout control. You would typically have at least one <code class="calibre23">Grid</code> in a UI page covering the entire page area, as in the case of the default blank page in the <code class="calibre23">MemoryTest</code> project. This provides a primary arrangement to which you add other elements. A <code class="calibre23">Grid</code> element can have one or more rows and columns, and you can reference individual rows or columns by an index, where index values start from zero. You identify a particular <code class="calibre23">Grid</code> cell by a row index plus a column index, and you locate a control in a grid cell by specifying a row index and a column index for it. <code class="calibre23">Grid</code> cells can contain elements of any type, including <code class="calibre23">Grid</code> and <code class="calibre23">StackPanel</code> elements, and you can place several elements in a cell so they are superimposed. Child elements in a grid can span several grid cells. You’ll be working with grids in the <code class="calibre23">MemoryTest</code> example.</p>
<p class="calibre13">A <code class="calibre23">Canvas</code> element can contain multiple UI elements as children that are located relative to the left side and top of the <code class="calibre23">Canvas</code> element. This means that you have complete freedom as to how the child elements are arranged. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">&lt;Canvas Background="Azure" Height="200" Width="200"&gt;
   &lt;Rectangle Fill="Blue" Canvas.Left="20" Canvas.Top="5"
              Height="70" Width="70"/&gt;
   &lt;Ellipse Fill="Red" Canvas.Left="100" Canvas.Top="100"
            Height="30" Width="70"/&gt;
&lt;/Canvas&gt;</code></pre>
<p class="calibre13"><code class="calibre23">Left</code> and <code class="calibre23">Top</code> are attached properties so they are qualified by the parent name in the child elements. The values are in pixels here.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Handling Events for UI Elements</h3>
<p class="calibre13">A UI element has properties that identify its event handlers. Each type of event will have a unique property. For example, the <code class="calibre23">Tapped</code> property value defines the handler for the event that arises when an element is tapped on a touch screen or clicked in the desktop environment. The majority of event properties for an element are inherited. Most UI elements have the <code class="calibre23">UIElement</code> class that is in the <code class="calibre23">Windows::UI::Xaml</code> namespace as a base class. <code class="calibre23">UIElement</code> has many properties for events, including the following:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><code class="calibre23">PointerEntered</code></li>
<li class="calibre6"><code class="calibre23">PointerExited</code></li>
<li class="calibre6"><code class="calibre23">PointerMoved</code></li>
<li class="calibre6"><code class="calibre23">PointerPressed</code></li>
<li class="calibre6"><code class="calibre23">Tapped</code></li>
<li class="calibre6"><code class="calibre23">DoubledTapped</code></li>
<li class="calibre6"><code class="calibre23">RightTapped</code></li>
</ul>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="844" id="calibre_link-1306" class="calibre14"></span>This is a subset of the event properties in <code class="calibre23">UIElement</code>. All elements derived from this class will inherit all the event properties it defines. The names are self-explanatory. When you want to handle an event, you specify the name of the event handler as the property value. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">&lt;Rectangle Tapped="Rectangle_Tapped" Fill="Blue" Height="50" Width="100"/&gt;</code></pre>
<p class="calibre13">When the rectangle defined by this element is tapped or clicked, the <code class="calibre23">Rectangle_Tapped()</code> function will be called. You can specify any name you like for the handler. You can use the Properties pane to define an event handler instead of modifying the XAML directly. This will set the value for the selected property and create the definition for the handler in the class that defines the page containing the UI element. You’ll see how this works in the context of the <code class="calibre23">MemoryTest</code> example.</p>
<p class="calibre13">When you write the name for a handler as a property value directly in a XAML element, you can right-click the name and select Go To Definition to go to its code. If the event handler doesn’t exist, Visual Studio will create it for you and navigate to the code it has created.</p>
<p class="calibre13">Elements have properties that control whether or not particular events are enabled for an element. This allows you to define a handler for a particular event and then control whether or not the events actually occur by setting a property value. The <code class="calibre23">IsTapEnabled</code> and <code class="calibre23">IsDoubleTapEnabled</code> properties can have values <code class="calibre23">"true"</code> or <code class="calibre23">"false"</code> that determine whether the <code class="calibre23">Tapped</code> or <code class="calibre23">DoubleTapped</code> events are enabled.</p>
<p class="calibre13">Whether or not an element is visible is determined by the value of its <code class="calibre23">Visibility</code> property. The value can be <code class="calibre23">"Visible"</code> or <code class="calibre23">"Collapsed"</code>, the latter being invisible. The possible values for the <code class="calibre23">Visibility</code> property are defined by the <code class="calibre23">Visibility</code> enum class in the <code class="calibre23">Windows::UI::Xaml</code> namespace. You need to know this when you are controlling the visibility of an element in code.</p>
<p class="calibre13">You can also control the transparency of an element by setting its <code class="calibre23">Opacity</code> property value. The value can be from 0 to 1.0, where 0 is completely transparent and 1.0 is completely opaque.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-386" class="calibre3"></a>CREATING A WINDOWS STORE APP</h2>
<p class="calibre13">You are now going to develop the <code class="calibre23">MemoryTest</code> project into a working program. You will use a diverse range of controls just for the experience rather than for implementing the application in the most elegant way. Of course, this means that the example will not be as consistent in its design as it should be, but it will show you how to work with several of the controls you have available. The approach I’ll describe will give you the experience of using the UI Designer pane to create the UI for the example as well as extending and modifying the XAML to expand it. Again, this is not the ideal approach in practice, but it’s a good way to try out various possibilities.</p>
<p class="calibre13">The application will implement a memory testing game. It will display a set of 24 cards that are face down initially. The 24 cards consist of 12 matching pairs. The face of each card will be a circle, a square, or a triangle, colored red, green, blue, or yellow, so there are 12 different cards. To play the game you turn up two cards by clicking or tapping them. If the pair match in shape and color they remain turned up. If they don’t match you click either card to turn it back over. Ideally you need to memorize what the cards were. You win the game when you have found all matching pairs.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="845" id="calibre_link-1307" class="calibre24"></span>Application Files</h3>
<p class="calibre13">If you look at the Solution Explorer pane, you’ll see two <code class="calibre23">.xaml</code> files. <code class="calibre23">App.xaml</code> defines the application object and <code class="calibre23">MainPage.xaml</code> defines the main page of the UI. In general, there will be a XAML file for each UI page. The <code class="calibre23">MemoryTest</code> game will need only one page.</p>
<p class="calibre13">If you extend the <code class="calibre23">MainPage.xaml</code> entry by clicking the arrow that appears on the left, you’ll see there are two source files, <code class="calibre23">MainPage.xaml.h</code> that contains the <code class="calibre23">MainPage</code> class definition for the main page, and <code class="calibre23">MainPage.xaml.cpp</code> that contains the class implementation. Your modifications to the code can be in either of these files. You will be adding to both files in the example. The <code class="calibre23">MainPage</code> class is a ref class so it defines a WinRT object. The class is specified with the <code class="calibre23">sealed</code> keyword, so you cannot derive another class from it.</p>
<p class="calibre13">The <code class="calibre23">MainPage</code> class definition in <code class="calibre23">MainPage.xaml.h</code> is not complete. None of the details of the UI are defined. There’s another file, <code class="calibre23">MainPage.g.h</code>, which defines the rest of the class. This file doesn’t appear in the Solution Explorer pane because you must not modify it. The contents are created for you from the XAML for the main page.</p>
<p class="calibre13">The <code class="calibre23">Package.appxmanifest</code> file defines properties that apply when the application is deployed. If you double-click the filename in the Solution Explorer pane you’ll see a dialog pane where you can set the path for the logo for the application and specify its orientation as well as other characteristics. The default images for the application are shown in the Assets list in the Solution Explorer pane. You would typically define your own image files for these. You can set permissions for the application on the Capabilities tab that determine what hardware and other resources the application is able to access. I won’t be going into details of how you modify any of the settings in this file. The first development task for the application is to design and specify the UI for the game in XAML.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Defining the User Interface</h3>
<p class="calibre13">First you must decide the broad layout of the application page &mdash; what goes where. You have complete flexibility here, so my choice is arbitrary and undoubtedly not the best. I decided on the arrangement shown in <a id="calibre_link-1402" href="#calibre_link-441" class="calibre3">Figure 18-4</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000051.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-441" href="#calibre_link-1402" class="calibre3">FIGURE 18-4</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="846" id="calibre_link-1308" class="calibre14"></span>The application title is the full width of the top of the UI and the 4 × 6 arrangement of cards will be in the rectangular area below the title and to the right. Controls for the game will be in a column at the left, and an information or message area will be at the bottom. You can now add rows and columns to the page grid to provide for this arrangement.</p>
<p class="calibre13">Double-click <code class="calibre23">MainPage.xaml</code> to display the XAML and the Design pane. You can select any element to be current by clicking it in the Design pane or clicking its XAML, so select the main page grid. Its properties are displayed in the Properties pane. If you move the cursor just above the upper edge of the grid you will see a vertical orange line appear that divides the grid into two columns. The line follows the cursor as you move it and you select a position by clicking it. You can add horizontal lines that divide the grid into rows with the same procedure with the mouse cursor on the vertical grid boundaries. Add two horizontal dividers and one vertical divider so the grid has the three rows and two columns shown in <a id="calibre_link-1403" href="#calibre_link-442" class="calibre3">Figure 18-5</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000010.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-442" href="#calibre_link-1403" class="calibre3">FIGURE 18-5</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">You can specify how the dimensions of a row or column are measured. If you hover the cursor over any of the column dimensions that are along the top of the grid, you’ll see a pop-up appear. When you click the down arrow in the pop-up, you’ll see the menu in <a id="calibre_link-1404" href="#calibre_link-443" class="calibre3">Figure 18-6</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000137.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-443" href="#calibre_link-1404" class="calibre3">FIGURE 18-6</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">The top three menu items set the way the dimensions are measured and have the following meanings:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="847" id="calibre_link-1309" class="calibre14"></span><b class="calibre12">Star:</b> A <code class="calibre23">*</code> dimension means that measurements are relative. If your grid has two columns with widths specified as <code class="calibre23">"4*"</code> and <code class="calibre23">"6*"</code>, the first column will occupy 40% of the overall width and the second column 60%. Three columns with widths, <code class="calibre23">"2*", "3*"</code>, and <code class="calibre23">"5*"</code> will occupy 20%, 30%, and 50% of the total grid width. <code class="calibre23">"1*"</code> is implied for a lone <code class="calibre23">"*"</code>. With * specification of dimensions for grid rows and columns, the dimensions of the columns and rows will resize proportionately when you resize the grid.</li>
<li class="calibre6"><b class="calibre12">Pixel:</b> This means measurements are absolute in pixels, although such dimensions may be adjusted when the UI is rendered.</li>
<li class="calibre6"><b class="calibre12">Auto:</b> You can use this to make a dimension occupy the available space, whatever it is. For example, with two columns you could specify the first in pixels: <code class="calibre23">"150"</code> for example. If you specify the second column width as <code class="calibre23">"Auto"</code>, the second column will occupy the remaining grid width.</li>
</ul>
<p class="calibre13">You can modify the option for the dimension for each row and column either by selecting from the pop-up menu for each dimension, or you can just use appropriate values for the <code class="calibre23">Height</code> and <code class="calibre23">Width</code> properties for the rows and columns in the XAML, as you’ll see. You should not hard-code fixed dimensions for your UI elements. By using Star or Auto specifications, you allow your application to adapt to the screen size on which it is executing.</p>
<p class="calibre13">Grid rows are defined in XAML by a <code class="calibre23">Grid.RowDefinitions</code> element that has a nested <code class="calibre23">RowDefinition</code> element for each row, and the grid columns are defined in a similar way. You can amend the row heights and column widths in the grid by modifying the <code class="calibre23">Height</code> and <code class="calibre23">Width</code> property values for the <code class="calibre23">RowDefinition</code> and <code class="calibre23">ColumnDefinition</code> elements in the XAML. I changed the widths of the columns and the heights of the rows to the values shown in <a href="#calibre_link-442" class="calibre3">Figure 18-5</a> so you should try that too. The XAML for my grid now looks like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="160"/&gt;
        &lt;RowDefinition Height="*"/&gt;
        &lt;RowDefinition Height="170"/&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="350"/&gt;
        &lt;ColumnDefinition Width="*"/&gt;
    &lt;/Grid.ColumnDefinitions&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">You can add a UI element to any cell of a grid and that includes another grid. An element can also occupy several cells in a row or column. When you add an element in the Design pane, the element is added as a child of the currently selected element. You must always make sure that the correct element is selected for the parent of a new element. You can select an element by clicking it in the Design pane, or by clicking its type name in the XAML.</p>
<p class="calibre13">You’ll add an element to display the title that will occupy the whole of the top row. You can reference grid rows and columns by index values starting from 0 and I’ll refer to a particular grid cell in the text as (<code class="calibre23">row_Index, column_Index</code>), so cell (2,1) is the second cell in the third row.</p>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="848" id="calibre_link-1310" class="calibre24"></span>Creating the Title</h3>
<p class="calibre13">You can add a child <code class="calibre23">Grid</code> element to the existing grid to provide a background for the application title. Click Toolbox on the right of the Visual Studio application window to display it. If it is not shown, you can display it by pressing Ctrl+Alt+X. Click Grid in the list. Click on the boundary between cells in the top row of the current grid to add the new <code class="calibre23">Grid</code> element to that row, move it so it lies within the top row of the original grid. You can now edit the XAML for the new grid by deleting all the properties except for <code class="calibre23">Grid.ColumnSpan="2"</code>. Place the cursor immediately before the <code class="calibre23">/&gt;</code> at the end of the new grid element and enter a space followed by <code class="calibre23">Background</code>. IntelliSense will prompt with a list so you can select from the list instead of entering the entire property name. Type <code class="calibre23">B</code> between the double quotes to see the list of colors &mdash; I chose <code class="calibre23">Bisque</code> because it sounds rather nice. The new property value, <code class="calibre23">Background="Bisque"</code>, sets the background color for the element. The XAML for the new grid element should be:</p>
<pre class="calibre28"><code class="calibre23"> &lt;!-- The title for the game --&gt;
 &lt;Grid Grid.ColumnSpan="2" Background="Bisque"/&gt;</code></pre>
<p class="calibre13">The first line is a comment that I added. The new grid should now fill the top row of the original grid and have a nice background color. The value for the <code class="calibre23">Grid.ColumnSpan</code> attached property specifies that the grid covers two columns of the parent. There are no dimensions specified so they are determined by the size of the top row of the parent grid.</p>
<p class="calibre13">To enter a new property value in the XAML for an element, just enter a space in the element where you want to place the property and type the first few letters of the property name. IntelliSense will display a list of property names that you can select from by using the arrow keys, as <a id="calibre_link-1405" href="#calibre_link-444" class="calibre3">Figure 18-7</a> shows this.</p>
<figure class="calibre16">
<img class="center" src="images/000091.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-444" href="#calibre_link-1405" class="calibre3">FIGURE 18-7</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="849" id="calibre_link-1311" class="calibre14"></span>Pressing Enter with a selection highlighted will create the property. When the value is from a predefined set, IntelliSense will prompt for that too.</p>
<p class="calibre13">You’ll use a <code class="calibre23">RichTextBlock</code> element to display the title text, just to introduce this element. This is a powerful element for presenting text, but you’ll use it in a simple way. It can display several blocks of text each defined by a <code class="calibre23">Paragraph</code> child element that can have its own font specification and alignment. Make sure the new grid is selected by clicking its XAML element. Click <code class="calibre23">RichTextBlock</code> in the Toolbox pane and then click inside the <code class="calibre23">Grid</code> element. The new element will contain a <code class="calibre23">Paragraph</code> element as a child; if you need more of these you can add them to the XAML manually. Edit the <code class="calibre23">RichTextBlock</code> XAML and its child so that it looks like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;RichTextBlock FontFamily="Freestyle Script" FontWeight="Bold"
               FontSize="90" TextAlignment="Center" Foreground="Red"
               VerticalAlignment="Center"&gt;
   &lt;Paragraph&gt;
      &lt;Run Text="Test Your Memory!"/&gt;
   &lt;/Paragraph&gt;
&lt;/RichTextBlock&gt;</code></pre>
<p class="calibre13">The <code class="calibre23">FontFamily</code> property value identifies the font. I chose <code class="calibre23">"Freestyle Script"</code> as a fun font for the application tile. I also set the <code class="calibre23">FontWeight</code> property value to <code class="calibre23">"Bold"</code>. The <code class="calibre23">FontSize</code> property value is <code class="calibre23">"90"</code> so you have a sizeable title. The <code class="calibre23">TextAlignment</code> property value is <code class="calibre23">"Center"</code> and the <code class="calibre23">Foreground</code> property value is <code class="calibre23">"Red"</code> so the text will be centered and in red. The <code class="calibre23">VerticalAlignment</code> property value determines how the <code class="calibre23">RichTextBlock</code> element is aligned in its parent. The <code class="calibre23">Run child</code> element for the <code class="calibre23">Paragraph</code> element defines a block of formatted or unformatted text. You could write the <code class="calibre23">Run</code> element as:</p>
<pre class="calibre28"><code class="calibre23">&lt;Run&gt;Test Your Memory!&lt;/Run&gt;</code></pre>
<p class="calibre13">The complete XAML for the title should now look something like:</p>
<pre class="calibre28"><code class="calibre23">&lt;!-- The title for the game --&gt;
&lt;Grid Grid.ColumnSpan="2" Background="Bisque"&gt;
   &lt;RichTextBlock FontFamily="Freestyle Script" FontWeight="Bold"
                  FontSize="90" TextAlignment="Center" Foreground="Red"
                  VerticalAlignment="Center"&gt;
      &lt;Paragraph&gt;
         &lt;Run Text="Test Your Memory!"/&gt;
      &lt;/Paragraph&gt;
   &lt;/RichTextBlock&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">I added a comment at the beginning of the block of XAML to identify it. You’ll add something to cells (1,0) and (2,0) of the base grid next.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Adding Game Controls</h3>
<p class="calibre13">You will add just two game control buttons. There’s space for more if you want to develop the game further. One button will be a <code class="calibre23">Start</code> button to reset the game with a new random deal of the cards and the other will display instructions on how to play the game. You’ll add the functionality for these later.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="850" id="calibre_link-1312" class="calibre14"></span>First select the base grid and add a child <code class="calibre23">Grid</code> element from the Toolbox to cell (1,0). Add a horizontal divider so the grid has two equal height rows and a single column. Adjust the properties so the XAML is:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Grid.Row="1" Grid.RowSpan="2" Background="Bisque"
      Margin="0,10,0,0"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="1*" /&gt;
        &lt;RowDefinition Height="1*" /&gt;
    &lt;/Grid.RowDefinitions&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">The grid background color is the same as that for the grid holding the title. With the grid row height property values as <code class="calibre23">"1*"</code>, the rows will be of equal height and will adjust automatically to fit the space in the parent grid.</p>
<p class="calibre13">Now add a button from the Toolbox in the top cell of the new <code class="calibre23">Grid</code> element, with the <code class="calibre23">Content</code> value as <code class="calibre23">"Start"</code>. Adjust the properties in the XAML for the button so it is:</p>
<pre class="calibre28"><code class="calibre23">&lt;Button Grid.Row="0" Content="Start" FontSize="32" Foreground="Red"
        Background="Gray" BorderBrush="Black" Height="90" Width="150"
        HorizontalAlignment="Center" VerticalAlignment="Center"/&gt;</code></pre>
<p class="calibre13">The background is gray and the border is drawn in black. The button height and width are as you see. The <code class="calibre23">HorizontalAlignment</code> and <code class="calibre23">VerticalAlignment</code> property values determine how the button is positioned in relation to its container, the top row of the grid.</p>
<p class="calibre13">You are going to implement more UI function with the second button and to allow for this to be added later, you can place the button in a <code class="calibre23">StackPanel</code> element that sits in the second row of the grid. After making sure the grid that holds the game controls is selected, click <code class="calibre23">StackPanel</code> in the Toolbox pane and click cell (1,0) of the grid. Edit the XAML for the <code class="calibre23">StackPanel</code> to:</p>
<pre class="calibre28"><code class="calibre23">&lt;StackPanel x:Name="ButtonPanel" Grid.Row="1"/&gt;</code></pre>
<p class="calibre13">The <code class="calibre23">x:Name</code> property value specifies the name by which you can refer to the <code class="calibre23">StackPanel</code> object in code.</p>
<p class="calibre13">Add a button in the bottom cell with the <code class="calibre23">Content</code> value <code class="calibre23">"How to Play"</code>. Make it the same height and width as the Start button. You can make the value of the <code class="calibre23">Background</code> property for both buttons <code class="calibre23">"Gray"</code>, and the <code class="calibre23">BorderBrush</code> property value <code class="calibre23">"Black"</code>. The <code class="calibre23">FontSize</code> property value for the bottom button can be <code class="calibre23">"20"</code>. My XAML for the game controls now looks like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;!-- Game controls--&gt;
&lt;Grid Grid.Row="1" Grid.RowSpan="2" Background="Bisque" Margin="0,10,0,0"&gt;
   &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="1*" /&gt;
      &lt;RowDefinition Height="1*" /&gt;
   &lt;/Grid.RowDefinitions&gt;
   &lt;Button Grid.Row="0" Content="Start" FontSize="32" Foreground="Red"
          Background="Gray" BorderBrush="Black" Height="90" Width="150"
          HorizontalAlignment="Center" VerticalAlignment="Center"/&gt;
   &lt;StackPanel x:Name="ButtonPanel" Grid.Row="1"&gt;
      &lt;Button Content="How to Play" FontSize="20" Foreground="Red"
             Background="Gray" BorderBrush="Black" Height="90" Width="150"
             HorizontalAlignment="Center"/&gt;
   &lt;/StackPanel&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="851" id="calibre_link-1313" class="calibre14"></span>To the left of the XAML, you’ll see a vertical line with a minus sign on the same line as a parent element. Clicking the minus will collapse the XAML into a single line. Clicking the plus sign for a collapsed parent element restores it. This is very helpful when you are working with a lot of XAML, as you’ll see later.</p>
<p class="calibre13">You can add another child <code class="calibre23">Grid</code> element with the name <code class="calibre23">"messageArea"</code> to cover grid cell (2,1) of the top level grid and make the <code class="calibre23">Background</code> property value <code class="calibre23">"Bisque"</code>. My XAML for this is:</p>
<pre class="calibre28"><code class="calibre23">&lt;!-- Message area --&gt;
&lt;Grid x:Name="messageArea" Grid.Column="1" Grid.Row="2" Margin="10,0,0,0"
     Background="Bisque"/&gt;</code></pre>
<p class="calibre13">You’ll place some elements in this grid later. You’ll be able to access the grid in code using its handle, <code class="calibre23">messageArea</code>. The <code class="calibre23">Margin</code> property value here specifies four values so the left margin will be 10 and the other three will be 0.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Creating a Grid to Contain the Cards</h3>
<p class="calibre13">You are going to place another grid inside cell (1,1) of the existing grid that will contain the cards. Click <code class="calibre23">Grid</code> in the list in the Toolbox pane and then click cell (1,1) of the existing grid. This will display the grid element in the Design pane and add its definition to <code class="calibre23">MainPage.xaml</code>. Add five column dividers and three row dividers evenly spaced so the grid has four rows of six cells. You can then edit the XAML for the new grid to the following:</p>
<pre class="calibre28"><code class="calibre23">&lt;!-- Grid holding the cards --&gt;
&lt;Grid x:Name="cardGrid" Grid.Row="1" Grid.Column="1" Margin="32"&gt;
  &lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="4*"/&gt;
    &lt;RowDefinition Height="4*"/&gt;
    &lt;RowDefinition Height="4*"/&gt;
    &lt;RowDefinition Height="4*"/&gt;
  &lt;/Grid.RowDefinitions&gt;
  &lt;Grid.ColumnDefinitions&gt;
    &lt;ColumnDefinition Width="6*"/&gt;
    &lt;ColumnDefinition Width="6*"/&gt;
    &lt;ColumnDefinition Width="6*"/&gt;
    &lt;ColumnDefinition Width="6*"/&gt;
    &lt;ColumnDefinition Width="6*"/&gt;
    &lt;ColumnDefinition Width="6*"/&gt;
  &lt;/Grid.ColumnDefinitions&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">Now you have a grid defined to hold the cards; the next step is to decide how a card will be represented.</p>
<section class="toclist">
<h4 class="calibre22">Defining a Card</h4>
<p class="calibre13">A card has two sides. The front will show one of three shapes filled in one of four colors. The back will just show the string <code class="calibre23">"???"</code>. There are many ways you could represent a card. For example, you could define the front and back of each card as separate elements, each with a suitable child. This would mean 48 elements for the complete pack of cards. Alternatively, you could define the front of a card as an element containing the three possible shapes, and the back as another with a child <span {http://www.idpf.org/2007/ops}type="pagebreak" title="852" id="calibre_link-1314" class="calibre14"></span>to display the string. I decided on yet another approach. I’ll explain where we are headed. This will make it easier for you to understand the steps that follow.</p>
<p class="calibre13">Each grid cell will display either the front or the back of a card. As I said, the front of a card can contain a circle, a square, or a triangle in any of four colors: red, green, blue, or yellow. A card back will be the string <code class="calibre23">"???"</code>. To make this possible, you can locate instances of all three shape elements &mdash; <code class="calibre23">Ellipse, Rectangle</code>, and <code class="calibre23">Polygon</code>, plus a <code class="calibre23">TextBlock</code> for the card back, inside a <code class="calibre23">Grid</code> element that will determine their sizes. This <code class="calibre23">Grid</code> element will be placed in another <code class="calibre23">Grid</code> element sitting in a cell of the card grid that will provide the background color for both the front and back of the cards. Thus a single card is a <code class="calibre23">Grid</code> element containing a <code class="calibre23">Grid</code> element that contains three shape elements and a <code class="calibre23">TextBlock</code>. If you place one of these nested <code class="calibre23">Grid</code> elements with its children in each cell of <code class="calibre23">cardGrid</code>, you can display the front or back of any card by judiciously setting the <code class="calibre23">Visibility</code> property for the child elements of the grid element for the card. You can start by creating the elements that define the card for cell (0,0) of <code class="calibre23">cardGrid</code>.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Creating a Card</h4>
<p class="calibre13">Create the <code class="calibre23">Grid</code> element in <code class="calibre23">cardGrid</code> cell (0,0) by selecting <code class="calibre23">cardGrid</code>, clicking the <code class="calibre23">Grid</code> control in the Toolbox pane list, then clicking the <code class="calibre23">cardGrid</code> cell (0,0). Edit the XAML to the following:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Grid.Row="0" Grid.Column="0" Background="Azure" Margin="5"/&gt;</code></pre>
<p class="calibre13">The value of the <code class="calibre23">Background</code> property is <code class="calibre23">"Azure"</code>, which will be the color of the background for the front and back of a card. If you want the background to be different between the front and the back, you can set the <code class="calibre23">Background</code> property value programmatically, depending on which side of the card was showing. The <code class="calibre23">Margin</code> property value will create a boundary of 5 pixels between the edge of each card and the <code class="calibre23">cardGrid</code> cell it occupies. This element will be visible at all times because it represents the background for both the front and the back of a card.</p>
<p class="calibre13">Make sure the grid that you just added is selected and place another <code class="calibre23">Grid</code> element from the Toolbox in it. This will contain the shapes and the <code class="calibre23">TextBlock</code> element and determine the size of them. Edit its properties to the following:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Margin="10" Width="50" Height="50"/&gt;</code></pre>
<p class="calibre13">This has margins of 10 pixels all around and has a height and width of 50 which will determine that the child elements will have a height and width of 50 pixels.</p>
<p class="calibre13">Now you can add the shapes that define the front of a card and the <code class="calibre23">TextBlock</code> that defines the back to this inner <code class="calibre23">Grid</code> element.</p>
<section class="toclist">
<h5 class="calibre27">Creating a Square</h5>
<p class="calibre13">You can define a square with the <code class="calibre23">Rectangle</code> XAML element. The corresponding WinRT <code class="calibre23">Rectangle</code> class is defined along with other shapes in the <code class="calibre23">Windows::UI::Xaml::Shapes</code> namespace. Add a <code class="calibre23">Rectangle</code> element from the Toolbox pane to the interior of the <code class="calibre23">Grid</code> element that you just added. You’ll see that the XAML for the <code class="calibre23">Grid</code> element now has a start and end tag and the <code class="calibre23">Rectangle</code> element appears between them. Edit the XAML for the <code class="calibre23">Rectangle</code> element to the following:</p>
<pre class="calibre28"><code class="calibre23">&lt;Rectangle Fill="Blue" Stroke="Black" Tapped="Shape_Tapped"/&gt;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="853" id="calibre_link-1315" class="calibre14"></span>This will define a square because the parent <code class="calibre23">Grid</code> element forces the dimensions of the <code class="calibre23">Rectangle</code> element to be 50. The border is black and the fill color is blue. It doesn’t matter what color you set here because you will change it programmatically when you decide which card will be placed in each cell of <code class="calibre23">cardGrid</code>. The value for the <code class="calibre23">Tapped</code> property is the name of the handler function to be called for <code class="calibre23">Tapped</code> events on the rectangle. It doesn’t exist yet but you’ll create it a bit later in this chapter. A <code class="calibre23">Tapped</code> event occurs when an element is tapped on a touch screen or clicked with the mouse. The same handler will service <code class="calibre23">Tapped</code> events for all elements that appear on the fronts of all the cards.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Creating a Circle</h5>
<p class="calibre13">The XAML for a circle will be almost identical to that for a square, so I think you can add the element directly, immediately after the XAML for the rectangle:</p>
<pre class="calibre28"><code class="calibre23">&lt;Ellipse Fill="Red" Stroke="Black" Tapped="Shape_Tapped"/&gt;</code></pre>
<p class="calibre13">The only differences are the element name and the fill color. The <code class="calibre23">Ellipse</code> element defines a circle because the size will be determined by the parent <code class="calibre23">Grid</code> element to be 50 × 50 pixels. You’ll be setting the fill color programmatically, as with the rectangle.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Creating a Triangle</h5>
<p class="calibre13">There’s no control in the Toolbox that defines a triangle. You have to enter XAML to create a triangle. You’ll use a <code class="calibre23">Polygon</code> element, which defines a closed polygon by a series of points with as many vertices as you like. A triangle is defined by three points, and you define the coordinates of the points in the value for the <code class="calibre23">Points</code> property. The points are defined by a string containing a series of integer coordinates separated by spaces or commas. Obviously there must be an even number of coordinates in the string because each point is defined by an x,y pair. The coordinate system has its origin at the top left of the element area with positive x running from left to right and positive y from top to bottom, just like a window. Add a <code class="calibre23">Polygon</code> element to the <code class="calibre23">Grid</code> element, following the <code class="calibre23">Ellipse</code> element. The XAML should be like this:</p>
<pre class="calibre28"><code class="calibre23"> &lt;Polygon Fill="Green" Points="0,50 50,50 25,0"
          HorizontalAlignment="Center" VerticalAlignment="Center"
          Stroke="Black" Tapped="Shape_Tapped" /&gt;</code></pre>
<p class="calibre13">The element properties can be in any order, so if yours are in a different sequence it doesn’t matter. I have used commas to separate x and y in a pair and spaces between coordinate pairs for the <code class="calibre23">Polygon</code> element. You could use all spaces or all commas as separators if you wish. If you want an inverted triangle you could define the value of the <code class="calibre23">Points</code> property as <code class="calibre23">"0,0 50,0 25,50"</code>. The <code class="calibre23">Stroke</code> property value specifies the color for the outline of the polygon.</p>
</section>
<section class="toclist">
<h5 class="calibre27">Creating the Card Back</h5>
<p class="calibre13">The back of a card will be represented by a <code class="calibre23">TextBlock</code> element so select that in the Toolbox pane and place it in the <code class="calibre23">Grid</code> element that contains the shapes. You can then edit the <code class="calibre23">TextBlock</code> XAML element to the following:</p>
<pre class="calibre28"><code class="calibre23">&lt;TextBlock TextWrapping="Wrap" Text="???" Foreground="Black" FontSize="32"
           FontWeight="Bold" 
           VerticalAlignment="Center" HorizontalAlignment="Center"
           Tapped="Cardback_Tapped"/&gt;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="854" id="calibre_link-1316" class="calibre14"></span>The text that will be displayed is specified by the <code class="calibre23">Text</code> property value. The <code class="calibre23">Foreground</code> property value determines the color for the text. The font size and weight are defined by the <code class="calibre23">FontSize</code> and <code class="calibre23">FontWeight</code> property values. There are other <code class="calibre23">TextBlock</code> properties that define the font characteristics such as <code class="calibre23">FontStyle</code> and <code class="calibre23">FontFamily</code>, but I’ll leave you to explore those possibilities.</p>
<p class="calibre13">The complete XAML for the card in cell (0,0) in <code class="calibre23">cardGrid</code> should be like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Grid.Row="0" Grid.Column="0" Background="Azure" Margin="5"&gt;
   &lt;Grid Margin="10" Width="50" Height="50"&gt;
      &lt;Rectangle Fill="Blue" Stroke="Black" Tapped="Shape_Tapped" /&gt;
      &lt;Ellipse Fill="Red" Stroke="Black" Tapped="Shape_Tapped" /&gt;
      &lt;Polygon Fill="Green" Points="0,50 50,50 25,0"
               HorizontalAlignment="Center" VerticalAlignment="Center"
               Stroke="Black" Tapped="Shape_Tapped" /&gt;
      &lt;TextBlock TextWrapping="Wrap" Text="???" Foreground="Black"
               FontSize="32" FontWeight="Bold" 
               VerticalAlignment="Center" HorizontalAlignment="Center"
               Tapped="Cardback_Tapped" /&gt;
   &lt;/Grid&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">Save the file. It’s a good idea to save the project files when you make changes. With the UI for one card created, the rest of the cards will be a piece of cake.</p>
</section>
</section>
<section class="toclist">
<h4 class="calibre22">Adding Event Handling</h4>
<p class="calibre13">You haven’t finished the UI yet so it may seem premature to start talking about event handlers for the cards, but because there are only two, and these will be the same for every card, you might as well add them now. You will want to respond to <code class="calibre23">Tapped</code> events from each of the shape elements and the <code class="calibre23">TextBlock</code> element that represents the card back. You won’t respond to events on the <code class="calibre23">Grid</code> elements in the <code class="calibre23">cardGrid</code> cells, so they are essentially inert.</p>
<p class="calibre13">Let’s start with the square on a card. In the XAML for the <code class="calibre23">Rectangle</code> element, right-click the value of the <code class="calibre23">Tapped</code> property and select Go To Definition from the context menu. Alternatively, just press F12 with the cursor in the <code class="calibre23">Tapped</code> property value. The <code class="calibre23">MainPage.xaml.cpp</code> file contents will be displayed and you’ll see that an implementation for the <code class="calibre23">Shape_Tapped()</code> handler has been added. Return to the XAML and repeat the process for the property value for the <code class="calibre23">Tapped</code> handler in the <code class="calibre23">TextBlock</code> element. You have added all the handlers you need for the cards and you’ll add the code for these later. Easy, wasn’t it?</p>
<p class="calibre13">It would be nice to highlight the card that is touched or is under the mouse cursor when the game is played. One way to do this is to implement handlers for the <code class="calibre23">PointerEntered</code> and <code class="calibre23">PointerExited</code> events for the <code class="calibre23">Grid</code> element that defines the background color for a card as azure. You’ll be able to implement these handlers so the background color changes as the cursor enters and exits the area occupied by the element. You can do this via the Properties pane, just for the experience.</p>
<p class="calibre13">Click the <code class="calibre23">Grid</code> element with the azure color and display the <code class="calibre23">Properties</code> pane for it. Display the event handlers for the element by clicking the rightmost button at the top of the Properties pane (there’s a tooltip displayed when you hover the cursor over the button). Enter <code class="calibre23">Card_Entered</code> <span {http://www.idpf.org/2007/ops}type="pagebreak" title="855" id="calibre_link-1317" class="calibre14"></span>as the value for the <code class="calibre23">PointerEntered</code> property and press Enter. This will create the handler implementation and display it. Return to the XAML and repeat the process for the <code class="calibre23">PointerExited</code> event. The value for the <code class="calibre23">PointerExited</code> event can be <code class="calibre23">Card_Exited</code>. You’ll code these handlers to deal with any card.</p>
<p class="calibre13">You can now define the other card positions in the UI.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Creating All the Cards</h4>
<p class="calibre13">You have 23 more cards to create in the UI. When you have completed these you’ll appreciate the ability to collapse the XAML for parent elements. Repeating the preceding process 23 times would be very tedious indeed, but fortunately there’s a shortcut.</p>
<p class="calibre13">The contents of <code class="calibre23">cardGrid</code> cell (1,0) will be exactly the same as that for grid cell (0,0), apart from the value of the <code class="calibre23">Grid.Row</code> attached property in the <code class="calibre23">Grid</code> element that defines the background color, which will be <code class="calibre23">"1"</code>. Thus you can create the contents of <code class="calibre23">cardGrid</code> cell (1,0) by copying the <code class="calibre23">Grid</code> XAML element, including its child elements, and setting the value of <code class="calibre23">Grid.Row</code> to <code class="calibre23">"1"</code>. The new <code class="calibre23">Grid</code> element will be:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid Grid.Row="1" Grid.Column="0" Background="Azure" Margin="5"
      PointerEntered="Card_Entered" PointerExited="Card_Exited"&gt;
   &lt;Grid Margin="10" Width="50" Height="50"&gt;
      &lt;!--
      ... Rectangle, Ellipse, Polygon and TextBlock elements as before...
      --&gt;
   &lt;/Grid&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">The child elements stay exactly the same. The <code class="calibre23">Shape_Tapped()</code>handler will be called for the <code class="calibre23">Tapped</code> event for all shapes, and <code class="calibre23">Tapped</code> events originating from any of the <code class="calibre23">TextBlock</code> elements representing card backs will be handled by the <code class="calibre23">Cardback_Tapped()</code> function. The <code class="calibre23">Card_Entered()</code> and <code class="calibre23">Card_Exited()</code> handler functions will process events from both <code class="calibre23">Grid</code> elements.</p>
<p class="calibre13">Of course, you can create the XAML for <code class="calibre23">cardGrid</code> cells (2,0) and (3,0) in exactly the same way; just change the values of the <code class="calibre23">Grid.Row</code> property for these to <code class="calibre23">"2"</code> and <code class="calibre23">"3"</code>. When you have completed that you’ll see the entire first column of the grid is populated with cards in the Design pane.</p>
<p class="calibre13">The XAML for the cards in column two of <code class="calibre23">cardGrid</code> will be the same as the XAML for column one, except that the <code class="calibre23">Grid.Column</code> attached property value in the <code class="calibre23">Grid</code> elements will be <code class="calibre23">"1"</code>. Therefore, you can create the XAML for column two by duplicating the four <code class="calibre23">Grid</code> elements that define column one cards, and setting the <code class="calibre23">Grid.Column</code> attached property value for each <code class="calibre23">Grid</code> element in the new set to <code class="calibre23">"1"</code>. I’m sure you’ll be able to deduce how to fill the remaining columns of <code class="calibre23">cardGrid</code>. When you are done, there should be 24 <code class="calibre23">Grid</code> elements, each with the same children, and 24 identical cards in the Design pane. You should be able to compile and execute <code class="calibre23">MemoryTest</code> now and see how the UI looks. By default, the app will execute directly in your Windows 8 environment. You can execute it in the Simulator, which is much more helpful. Just select Simulator instead of Local Machine in the drop-down on the toolbar. The application window in the simulator will look like <a id="calibre_link-1406" href="#calibre_link-445" class="calibre3">Figure 18-8</a>.</p>
<figure class="calibre16">
<img class="center" src="images/000053.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-445" href="#calibre_link-1406" class="calibre3">FIGURE 18-8</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="856" id="calibre_link-1318" class="calibre14"></span>Hovering the cursor over the buttons on the right of the simulator window will tell you what they do. To terminate the simulator, just right-click the simulator window icon in the Windows taskbar and click Close.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Visual Studio has advanced features that allow you to define resources you can use as templates in your XAML. This would allow you to define the nature of a card once in a resource and use the resource to define each card in the UI. This means that if you later needed to change the cards, you would only have to change the resource but a discussion of resource templates is outside the scope of this book.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
</section>
</section>
<section class="toclist">
<h3 class="calibre21">Implementing Game Operations</h3>
<p class="calibre13">You need to put the framework in place in the <code class="calibre23">MainPage</code> class to make the game work as you want. You will need a few additional data members as well as a number of additional functions. You can do this manually or use the capabilities in Class View you are familiar with. I’ll assume in the text that you’ll add the code directly to the <code class="calibre23">.h</code> or <code class="calibre23">.cpp</code> file for the <code class="calibre23">MainPage</code> class, but you can use Class View facilities if you prefer.</p>
<p class="calibre13">First you must decide what you want to do and how it’s going to work. The elements in each <code class="calibre23">cardGrid</code> cell must be set up so that they represent a particular card. For this you need access to the <code class="calibre23">Grid</code> element in each cell, the <code class="calibre23">Grid</code> element that that contains, and its child shape and <code class="calibre23">TextBlock</code> elements that define the front and back of each card. You’ll be referencing the elements that define a card often so you won’t want to extract them every time. None of them have names, so you must find and store references to them somehow.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="857" id="calibre_link-1319" class="calibre14"></span>You can access child elements through the value of the <code class="calibre23">Children</code> property for a parent. The <code class="calibre23">Children</code> property value for <code class="calibre23">cardGrid</code> is a collection of its child elements, and these are the <code class="calibre23">Grid</code> elements in the cells that provide the background color for the cards. You can extract references to these objects from the collection recorded as the value of the <code class="calibre23">Children</code> property for <code class="calibre23">cardGrid</code>. You can then extract the child element for each of these in a similar way, which will be a reference to the <code class="calibre23">Grid</code> element containing the shapes and the <code class="calibre23">TextBlock</code>. If you store the references that you extract, you can use them later without repeating the extraction process. Arrays are the best choice to store them because there will be 24 of each type.</p>
<p class="calibre13">You will need the following member functions in the <code class="calibre23">MainPage</code> class:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">A <code class="calibre23">SetUpUIState()</code> member function that will set up the arrays that store references to the child elements in <code class="calibre23">cardGrid</code> and set their initial state.</li>
<li class="calibre6">An <code class="calibre23">InitializeCardPack()</code> member function to create a pack of 24 cards. It will be easiest to keep the definition of a pack of cards separate from the XAML elements that represent the cards in the UI. This means you’ll also need to define a <code class="calibre23">Card</code> class to represent a card.</li>
<li class="calibre6">An <code class="calibre23">InitializeGame()</code> member function that will set up a new game with cards randomly shuffled.</li>
<li class="calibre6">There are several discrete operations you need in the <code class="calibre23">MainPage</code> class that each will require a member function.</li>
</ul>
<p class="calibre13">You will probably need some helper methods to accommodate code that is repeated. The <code class="calibre23">MainPage</code> constructor will have to be extended to initialize your own data members. You also have to implement all the event handlers. There’s a way to go yet! Before you start extending the <code class="calibre23">MainPage</code> class, let’s get the definition of the <code class="calibre23">Card</code> class out of the way.</p>
<section class="toclist">
<h4 class="calibre22">Defining the Card Class</h4>
<p class="calibre13">A card is defined by the type and color of the shape on the front of the card plus the <code class="calibre23">TextBlock</code> object that defines the back. You can define this class as a ref class type for the experience. Add a header file to the <code class="calibre23">MemoryTest</code> project with the name <code class="calibre23">Card.h</code>. You can press Ctrl+Shift+A to open the dialog to do this. You can add the basic definition for the class as:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
namespace MemoryTest
{
  ref class Card
  {
    // Members to be defined...
  };
}</code></pre>
<p class="calibre13">The class must be defined within the project namespace, <code class="calibre23">MemoryTest</code>. You could define it as <code class="calibre23">public</code> to get it into the <code class="calibre23">.winmd</code> file but you don’t need to.</p>
<p class="calibre13">You will use <code class="calibre23">Card</code> objects in two ways. First, the specification for a particular card with a given shape type and color will be a <code class="calibre23">Card</code> object. Second, a card in a particular grid cell of <code class="calibre23">cardGrid</code> will also be a <code class="calibre23">Card</code> object. Thus, an array of 24 <code class="calibre23">Card</code> objects can define the shuffled pack of cards and also identify the objects in the UI corresponding to those cards.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="858" id="calibre_link-1320" class="calibre14"></span>A <code class="calibre23">Card</code> object will record the shape, its type, and its color. You can store the shape type as a handle to a <code class="calibre23">String</code> object that is the name of the class type for the shape: <code class="calibre23">"Ellipse", "Rectangle"</code>, or <code class="calibre23">"Polygon"</code>. You can store the color as a handle to a <code class="calibre23">SolidColorBrush</code> object. This is a good choice because the <code class="calibre23">Background</code> property value for a shape is of type <code class="calibre23">Brush^</code>, and <code class="calibre23">Brush</code> is the base class for <code class="calibre23">SolidColorBrush</code>. The specific shape object for a card will be one of the three types of shapes, so you can store this as a handle to the base class type for shapes, which is type <code class="calibre23">Shape^</code>. The <code class="calibre23">Shape</code> class is defined in the <code class="calibre23">Windows::UI::Xaml::Shapes</code> namespace. The handle to the element that is the back of a card can be a handle to a <code class="calibre23">Windows::UI::Xaml::Controls::TextBlock</code> object. If you make these <code class="calibre23">public</code> properties of the class, they will be easy to access. Here’s the complete <code class="calibre23">Card</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">#pragma once
namespace MemoryTest
{
  public ref class Card sealed
  {
  public:
    Card() {}
 
   // Copy constructor 
   Card(Card^ card)
    { 
      Type = card-&gt;Type;
      Color = card-&gt;Color;
      Shape = card-&gt;Shape;
      Back = card-&gt;Back;
    }
 
  public:
    property Platform::String^ Type;                           // Shape type
    property Windows::UI::Xaml::Media::SolidColorBrush^ Color; // Color
    property Windows::UI::Xaml::Shapes::Shape^ Shape;          // Shape handle
    property Windows::UI::Xaml::Controls::TextBlock^ Back;     // Card back
  };
}</code></pre>
<p class="calibre13">The class must be specified as <code class="calibre23">sealed</code> because it defines public constructors. If you don’t define it as <code class="calibre23">sealed</code>, the code will not compile. You don’t need to define any member functions beyond the default constructor and the copy constructor. You will need the copy constructor to create pairs of identical cards.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Adding Data Members to the MainPage Class</h4>
<p class="calibre13">You can make all the members you add to the <code class="calibre23">MainPage</code> class <code class="calibre23">private</code>. The first data member to add will store the number of cards:</p>
<pre class="calibre28"><code class="calibre23">size_t cardCount;                          // The number of cards</code></pre>
<p class="calibre13">You’ll initialize this in the <code class="calibre23">MainPage</code> constructor. Next you can add arrays to store the handles to the shapes in <code class="calibre23">cardGrid</code> to the <code class="calibre23">MainPage</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">Platform::Array&lt;Windows::UI::Xaml::Controls::Grid^&gt;^ grids;
Platform::Array&lt;Windows::UI::Xaml::Shapes::Ellipse^&gt;^ circles; 
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="859" id="calibre_link-1321" class="calibre14"></span>Platform::Array&lt;Windows::UI::Xaml::Shapes::Rectangle^&gt;^ squares;
Platform::Array&lt;Windows::UI::Xaml::Shapes::Polygon^&gt;^ triangles;
Platform::Array&lt;Windows::UI::Xaml::Controls::TextBlock^&gt;^ cardBacks;</code></pre>
<p class="calibre13">These arrays will each have <code class="calibre23">cardCount</code> elements.</p>
<p class="calibre13">You will also need an array of <code class="calibre23">Card</code> objects:</p>
<pre class="calibre28"><code class="calibre23">    Platform::Array&lt;Card^&gt;^ cardPack;                  // The pack of cards</code></pre>
<p class="calibre13">You’ll need an <code class="calibre23">#include</code> directive for <code class="calibre23">Card.h</code> in <code class="calibre23">MainPage.xaml.h</code>. You can create the <code class="calibre23">cardPack</code> array in the <code class="calibre23">MainPage</code> constructor with <code class="calibre23">cardCount</code> elements, each storing a handle to a <code class="calibre23">Card</code> object. You’ll be shuffling the handles in this array for each new game because it is the deck of cards for the game.</p>
<p class="calibre13">You can add members that are handles to <code class="calibre23">String</code> objects that will store the type names for the child elements in <code class="calibre23">cardGrid</code>:</p>
<pre class="calibre28"><code class="calibre23">// Type names for card elements
Platform::String^ typeCircle;
Platform::String^ typeSquare;
Platform::String^ typeTriangle;</code></pre>
<p class="calibre13">These also must be initialized in the <code class="calibre23">MainPage</code> constructor. You will be able to determine the precise type name for an object referenced by a <code class="calibre23">Shape^</code> handle by comparing it to these members. You’ll need more data members when you implement the event handlers, but that will suffice for now.</p>
</section>
<section class="toclist">
<h4 class="calibre22">Adding Member Functions</h4>
<p class="calibre13">You can add the three member functions identified earlier:</p>
<pre class="calibre28"><code class="calibre23">private:
  // Game functions
  void InitializeCardPack(); // Initialize cardPack to two of each card
  void SetUpUIState();       // Initialize the child elements of cardGrid
  void InitializeGame();     // Set up a game with a shuffled cardPack</code></pre>
<p class="calibre13">If you put empty definitions for these functions in <code class="calibre23">MainPage.xaml.cpp</code>, the application will be compilable:</p>
<pre class="calibre28"><code class="calibre23">// Initialize the pack of cards so it contains 12 different pairs
void MainPage::InitializeCardPack()
{
  // Code to be added here...
}
 
// Set up the initial UI state and stores elements in grid cell order 
void MainPage::SetUpUIState()
{
  // Code to be added here...
}
 
// Shuffle the cards and deal
void MainPage::InitializeGame()
{
  // Code to be added here...
}</code></pre>
<p class="calibre13">The basic initialization for the game will be done in the <code class="calibre23">MainPage</code> constructor, so let’s look at that next.</p>
</section>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="860" id="calibre_link-1322" class="calibre24"></span>Initialize the MainPage Object</h3>
<p class="calibre13">All the basic initialization for the game will be done in the <code class="calibre23">MainPage</code> class constructor. The default implementation includes a call to the <code class="calibre23">InitializeComponent()</code> function that sets up the UI components. Be sure to put any code that references UI component objects after this function call. You can amend the constructor definition to the following:</p>
<pre class="calibre28"><code class="calibre23">MainPage::MainPage()
{
  InitializeComponent();
 
  // cardCount is number of rows x number of columns in cardGrid
  cardCount = 
          cardGrid-&gt;ColumnDefinitions-&gt;Size*cardGrid-&gt;RowDefinitions-&gt;Size;
 
  // Initialize type names for card elements
  typeCircle = Ellipse::typeid-&gt;FullName;
  typeSquare = Rectangle::typeid-&gt;FullName;
  typeTriangle = Polygon::typeid-&gt;FullName;
 
  // Create arrays to store element handles for the cards
  // Each type is in a separate array and will be stored in card sequence
  circles = ref new Array&lt;Ellipse^&gt;(cardCount);
  triangles = ref new Array&lt;Polygon^&gt;(cardCount);
  squares = ref new Array&lt;Rectangle^&gt;(cardCount);
  cardBacks = ref new Array&lt;TextBlock^&gt;(cardCount);
  grids = ref new Array&lt;Grid^&gt;(cardCount);
  InitializeCardPack();
  SetUpUIState();
  InitializeGame();
}</code></pre>
<p class="calibre13">You initialize <code class="calibre23">cardCount</code> to the number of cells in <code class="calibre23">cardGrid</code>, as the product of the numbers of rows and columns. Next, you initialize the members that store the type names for the shapes. The expression <code class="calibre23">Ellipse::typeid</code> results in a handle of type <code class="calibre23">Platform::Type</code> that identifies the <code class="calibre23">Ellipse</code> type. The <code class="calibre23">FullName</code> property value for a <code class="calibre23">Type</code> object is a handle to a <code class="calibre23">String</code> object containing the type name. Every WinRT object inherits the <code class="calibre23">GetType()</code> function from the <code class="calibre23">Object</code> base class, which returns a handle to the <code class="calibre23">Type</code> object for the object. Thus you obtain the actual type name for a shape object referenced through a <code class="calibre23">Shape^</code> handle by calling its inherited <code class="calibre23">GetType()</code> member and accessing the <code class="calibre23">FullName</code> property value of the object that it returns.</p>
<p class="calibre13">The arrays that hold handles for the <code class="calibre23">Grid</code> objects in <code class="calibre23">cardGrid</code> and the child elements of the <code class="calibre23">Grid</code> objects each have <code class="calibre23">cardCount</code> elements. After the basic data initialization in the constructor, you call the three new member functions to initialize the card pack, set up the states of the UI elements, and initialize the game with a shuffled card pack.</p>
<p class="calibre13">To use the shape type names without qualifying them with the namespace name, you need to add the following <code class="calibre23">using</code> directive to <code class="calibre23">MainPage.xaml.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">using namespace Windows::UI::Xaml::Shapes;</code></pre>
</section>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="861" id="calibre_link-1323" class="calibre24"></span>Initializing the Card Pack</h3>
<p class="calibre13">You are going to create <code class="calibre23">cardCount Card</code> objects and store the handles in the <code class="calibre23">cardPack</code> array. There must be 12 pairs of identical <code class="calibre23">Card</code> objects. The 12 different cards comprise cards with three different shapes in each of four different colors. You can create these by iterating over the four colors in a loop, and over the three shape types in an inner loop. Here’s how that looks:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::InitializeCardPack()
{
  // Create arrays of the shape types and colors
  Array&lt;String^&gt;^ shapeTypes {typeCircle, typeSquare, typeTriangle};
  Array&lt;SolidColorBrush^&gt;^ colors {
                      ref new SolidColorBrush(Windows::UI::Colors::Red),
                      ref new SolidColorBrush(Windows::UI::Colors::Green),
                      ref new SolidColorBrush(Windows::UI::Colors::Blue),
                      ref new SolidColorBrush(Windows::UI::Colors::Yellow)
                                  };
  // Initialize the card pack
  cardPack = ref new Array&lt;Card^&gt;(cardCount);
  size_t packIndex {};                         // Index to cardPack array
  Card^ card;
  for(auto color : colors)
  {
    for(auto shapeType : shapeTypes)
    {
      card = ref new Card();                   // Create a card...
      card-&gt;Type = shapeType;                  // with the current type...
      card-&gt;Color = color;                     // ... and color
      card-&gt;Shape = nullptr;                   // we will find the shape...
      card-&gt;Back = nullptr;                    // ...and back later.
      cardPack[packIndex++] = card;               // Store the card and...
      cardPack[packIndex++] = ref new Card(card); // ...a copy in the pack.
    }
  }
}</code></pre>
<p class="calibre13">You first create arrays holding the possible colors and shape types. You initialize the elements in the <code class="calibre23">cardPack</code> array with two copies of each <code class="calibre23">Card</code> representing a card with a given shape of a particular color. After executing this function, the <code class="calibre23">cardPack</code> array will contain the pack of 24 cards arranged in sequence. They will need to be shuffled for a game.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Setting Up the Child Elements of cardGrid</h3>
<p class="calibre13">The <code class="calibre23">SetUpUIState()</code> method will set the elements in each cell of <code class="calibre23">cardGrid</code> so only the back of the card is visible. This implies setting the child shape elements for each cell in <code class="calibre23">cardGrid</code> as not visible. Whether or not an element is visible is determined by its <code class="calibre23">Visibility</code> property value. This can be <code class="calibre23">Visible</code> or <code class="calibre23">Collapsed</code>, where these values are defined by the <code class="calibre23">Visibility</code> enum class in the <code class="calibre23">Windows::UI::Xaml</code> namespace.</p>
<p class="calibre13">The method will store the handles to the <code class="calibre23">Grid</code> elements that are children of <code class="calibre23">cardGrid</code> in the <code class="calibre23">grids</code> array and store the handles to the shapes that are children of each <code class="calibre23">Grid</code> child in the array of the <span {http://www.idpf.org/2007/ops}type="pagebreak" title="862" id="calibre_link-1324" class="calibre14"></span>appropriate shape type. The child elements that are <code class="calibre23">TextBlock</code> handles are stored in the <code class="calibre23">cardBacks</code> array. The elements in the arrays that store handles to shapes, card backs, and grids need to be in the same order as their occurrence in <code class="calibre23">cardGrid</code>. Here’s the code:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::SetUpUIState()
{
  // Handle to the collection of grids in cardGrid
  auto elements = cardGrid-&gt;Children;                   
  
  size_t index {};                 // Index to shape arrays
  size_t rowLength(cardGrid-&gt;ColumnDefinitions-&gt;Size);// Length of a grid row
 
  // Iterate over the child elements to cardGrid and store 
  // the Grid^ handles in the grids array in sequence
  for(UIElement^ element : elements) 
  {
    String^ elementType = element-&gt;GetType()-&gt;FullName; // Get element type
    if(Grid::typeid-&gt;FullName == elementType)           // Make sure it's a Grid
    {
      auto grid = safe_cast&lt;Grid^&gt;(element); 
      auto row = cardGrid-&gt;GetRow(grid);                // Get the grid row 
      auto column = cardGrid-&gt;GetColumn(grid);          // and column location. 
      index = row*rowLength + column;                   // Index for row/column
      grids[index] = grid;                              // Save the grid
      // A grid in each cell contains another grid as child.
      // We know that's always the case so get the child-grid:
      grid = safe_cast&lt;Grid^&gt;(grid-&gt;Children-&gt;GetAt(0));
      auto shapes = grid-&gt;Children;                      // Get the child shapes
      // Iterate over the child elements to the current Grid and store
      // the shape element handles in the array for their type in sequence
      for(UIElement^ element : shapes)
      {
        elementType = element-&gt;GetType()-&gt;FullName;     // Get element type
     
        // Store a circle in circles array &amp; do the same for the other elements
        // Only card backs will be visible - all other shapes collapsed.
        if(typeCircle == elementType)
        {
          circles[index] = safe_cast&lt;Ellipse^&gt;(element);
          element-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
        }
        else if(typeSquare == elementType)
        {
          squares[index] = safe_cast&lt;Rectangle^&gt;(element);
          element-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
        }
        else if(typeTriangle == elementType)
        {
         triangles[index] = safe_cast&lt;Polygon^&gt;(element);
          element-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
        }
        else if(TextBlock::typeid-&gt;FullName == elementType)
        {
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="863" id="calibre_link-1325" class="calibre14"></span>          cardBacks[index] = safe_cast&lt;TextBlock^&gt;(element);
          element-&gt;Visibility = Windows::UI::Xaml::Visibility::Visible;
        }
      }
    }
  }
}</code></pre>
<p class="calibre13">To access the child elements of a parent you obtain a handle to the collection of child elements from the value of its <code class="calibre23">Children</code> property. You then iterate over the elements in this collection and cast the <code class="calibre23">UIElement^</code> handles to the type of element actually stored. With child elements of <code class="calibre23">cardGrid</code> it’s easy because the handles are all of type <code class="calibre23">Grid^</code> and each of these has a <code class="calibre23">Grid</code> child. With child elements of these <code class="calibre23">Grid</code> objects, you have to do a little work to determine the type.</p>
<p class="calibre13">The outer range-based <code class="calibre23">for</code> loop iterates over the collection of <code class="calibre23">Grid</code> child elements in <code class="calibre23">cardGrid</code>. The <code class="calibre23">GetRow()</code> and <code class="calibre23">GetColumn()</code> functions for a <code class="calibre23">Grid</code> object return the row and column index respectively, for the child element referenced by the handle you pass as the argument. For each inner <code class="calibre23">Grid</code> element, you iterate over the collection of its child elements. By comparing the type name of each child with the shape type names, you are able to determine the type of element referenced by the handle and thus store the handle in the appropriate array. The conversion of child handles is done using <code class="calibre23">safe_cast</code>, which throws an exception if the cast is not valid, so you’ll know when something goes wrong.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Initializing the Game</h3>
<p class="calibre13">The game play involves turning up two cards to see if they match. You will need to record the two cards that are turned up, the count of pairs found, and the handles to the <code class="calibre23">Card</code> objects in pairs that have been found. Add the following <code class="calibre23">private</code> members to the <code class="calibre23">MainPage</code> class:</p>
<pre class="calibre28"><code class="calibre23">// Game records
Card^  card1Up;                                   // 1st card turned up
Card^  card2Up;                                   // 2nd card turned up
size_t pairCount;                                 // Number of pairs found
Platform::Collections::Vector&lt;Card^&gt;^ pairsFound; // Cards in pairs found</code></pre>
<p class="calibre13"><code class="calibre23">card1Up</code> and <code class="calibre23">card2Up</code> store handles to the cards turned up. <code class="calibre23">pairCount</code> records the number of pairs found and when this reaches 12, the game is over. <code class="calibre23">pairsFound</code> is a collection that records handles to the <code class="calibre23">Card</code> objects in the pairs. You’ll use this to manage what cards can cause events.</p>
<p class="calibre13">You can initialize these members in the constructor:</p>
<pre class="calibre28"><code class="calibre23">MainPage::MainPage() : card1Up {}, card2Up {}, pairCount {}
{
  InitializeComponent();
  // cardCount is number of rows x number of columns in cardGrid
  cardCount =
         cardGrid-&gt;ColumnDefinitions-&gt;Size*cardGrid-&gt;RowDefinitions-&gt;Size;
  pairsFound = ref new Platform::Collections::Vector&lt;Card^&gt;(cardCount);
 
  // Code as before...
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="864" id="calibre_link-1326" class="calibre14"></span>Initializing the game involves shuffling the cards. Add a <code class="calibre23">private</code> member function to do this, <code class="calibre23">ShuffleCards()</code>, to the <code class="calibre23">MainPage</code> class definition:</p>
<pre class="calibre28"><code class="calibre23">void ShuffleCards();                      // Shuffle the cards</code></pre>
<p class="calibre13">You can add an empty definition to <code class="calibre23">MainPage.xaml.cpp</code> that you’ll complete in the next section:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::ShuffleCards()
{
  // Code to be added later...
}</code></pre>
<p class="calibre13">The <code class="calibre23">InitializeGame()</code> function must shuffle the cards in <code class="calibre23">cardPack</code>, then set up the elements in <code class="calibre23">cardGrid</code> to reflect the order of the cards in <code class="calibre23">cardPack</code>. It must also ensure that the UI elements just display the card backs. Here’s the code to do that:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::InitializeGame()
{
  card1Up = card2Up = nullptr;                        // No cards up
  pairCount = 0;                                      // No pairs found
  pairsFound-&gt;Clear();                                // Clear pairs record
  // Null the handles to UI elements
  for(auto card : cardPack)
  {
    card-&gt;Shape = nullptr;
    card-&gt;Back = nullptr;
  }
  ShuffleCards();                                     // Shuffle cardPack
 
  // Set the shapes in the Grid elements to represent the cards dealt
  for(size_t i {}; i &lt; cardCount; ++i)
  {
    cardPack[i]-&gt;Back = cardBacks[i];
    if(cardPack[i]-&gt;Type == typeCircle)
    {
      circles[i]-&gt;Fill = cardPack[i]-&gt;Color;
      cardPack[i]-&gt;Shape = circles[i];
    } 
    else if(cardPack[i]-&gt;Type == typeSquare)
    {
      squares[i]-&gt;Fill = cardPack[i]-&gt;Color;
      cardPack[i]-&gt;Shape = squares[i];
    }
    else if(cardPack[i]-&gt;Type == typeTriangle)
    {
      triangles[i]-&gt;Fill = cardPack[i]-&gt;Color;
      cardPack[i]-&gt;Shape = triangles[i];
    }
    cardPack[i]-&gt;Shape-&gt;IsTapEnabled = true;
 
    // Set up UI to show card backs &amp; enable events
    cardBacks[i]-&gt;Visibility = Windows::UI::Xaml::Visibility::Visible;
    cardBacks[i]-&gt;IsTapEnabled = true;
    // Ensure background grids are hit test visible &amp; opaque
    grids[i]-&gt;IsHitTestVisible = true;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="865" id="calibre_link-1327" class="calibre14"></span>    grids[i]-&gt;Opacity = 1;
    // Ensure all shapes are invisible &amp; opaque
    circles[i]-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
    squares[i]-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
    triangles[i]-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
    circles[i]-&gt;Opacity = 1;
    squares[i]-&gt;Opacity = 1;
    triangles[i]-&gt;Opacity = 1;
  }
}</code></pre>
<p class="calibre13">After the game records have been reset, the first loop nulls the handles to shapes and card backs in the <code class="calibre23">Card</code> objects. The second loop sets the <code class="calibre23">Shape</code> property value of each <code class="calibre23">Card</code> object to a handle to the appropriate shape from one of the arrays storing shapes. It also sets the <code class="calibre23">Back</code> property value to a handle for the corresponding card back element. The loop also resets grids, card backs, and shapes to their initial state. An <code class="calibre23">Opacity</code> property of 1 is completely opaque. Setting the <code class="calibre23">IsHitTestVisible</code> property value for an element to <code class="calibre23">true</code> allows hit testing to work in the area of the element. This means that the clicking or tapping of the element can be detected. Setting the value to <code class="calibre23">false</code> would inhibit events resulting from clicking or tapping the element or its child elements.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Shuffling the Cards</h3>
<p class="calibre13">You can use the <code class="calibre23">random_shuffle()</code> function that is defined in the STL algorithm header with elements stored in a Platform::Array object. There are two versions of the function. The simple version takes two arguments that are iterators specifying the first and one-past-the-last items in the sequence to be shuffled. To get the begin and end iterators for the array of cards, you must use the special versions of <code class="calibre23">begin()</code> and <code class="calibre23">end()</code> from the <code class="calibre23">Windows::Foundations::Collections</code> namespace.</p>
<p class="calibre13">By default, <code class="calibre23">random_shuffle()</code> uses an internal random number generator seeded with a fixed value so you will always get the same sequence of shuffled card decks. This can be useful for testing, but it’s not what we want. However, you can provide a function object that represents a random number generator as the third argument to <code class="calibre23">random_shuffle()</code>. The function object you supply must accept a single argument, <code class="calibre23">n</code>, and return a random value from 0 to <code class="calibre23">n-1</code> inclusive.</p>
<p class="calibre13">I mentioned in Chapter 10 that the <code class="calibre23">random</code> header provides a wide range of random number generators, one of which we can use to create a random number generator to use with <code class="calibre23">random_shuffle()</code>. You can define an <code class="calibre23">std::uniform_int_distribution</code> class object that represents a uniform distribution of random integers within a specified inclusive range. In a uniform distribution each value is equally likely. You can define an object for integers from 1 to <code class="calibre23">n</code> inclusive like this:</p>
<pre class="calibre28"><code class="calibre23">size_t n {52};
std::uniform_int_distribution&lt;int&gt; distribution(1, n);</code></pre>
<p class="calibre13"><code class="calibre23">distribution</code> is a functor so to obtain a random value from the distribution that it represents, you call its <code class="calibre23">operator()()</code> member function with a random number generator as the argument. Here’s an example:</p>
<pre class="calibre28"><code class="calibre23">std::random_device gen;                     // Random number source
size_t value {distribution(gen)};           // Random value from 1 to n</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="866" id="calibre_link-1328" class="calibre14"></span>You met the <code class="calibre23">random_device</code> type back in Chapter 10. An object of this type is a functor that generates random values in the range from 1 to 232. The <code class="calibre23">gen</code> object that is passed to the <code class="calibre23">distribution</code> functor ensures that a random selection from the uniform distribution of integers is returned each time it is called.</p>
<p class="calibre13">We can use a <code class="calibre23">uniform_int_distribution</code> object in a lambda expression that we can pass to the <code class="calibre23">random_shuffle()</code> function as the random number generator for sorting the cards.</p>
<p class="calibre13">You can implement the <code class="calibre23">ShuffleCards()</code>function to produce a shuffled deck like this:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::ShuffleCards()
{
  std::random_device gen;                   // Random number source
  std::random_shuffle(begin(cardPack), end(cardPack), 
    [&amp;gen](size_t n) {
                    std::uniform_int_distribution&lt;int&gt; distribution(1, n);
                    return distribution(gen)-1;  });
}</code></pre>
<p class="calibre13">This shuffles the <code class="calibre23">Card</code> object references in the <code class="calibre23">cardPack</code> array. It uses the <code class="calibre23">begin()</code> and <code class="calibre23">end()</code>functions to create iterators for the <code class="calibre23">cardPack</code> array that you pass to <code class="calibre23">random_shuffle()</code>. The third argument is a lambda expression with a single parameter <code class="calibre23">n</code> that returns a value in the range 0 to <code class="calibre23">n-1</code> inclusive, which is exactly what the <code class="calibre23">random_shuffle()</code> function requires to replace the default random number generator. The random value that the <code class="calibre23">distribution</code> functor returns is in the range 1 to <code class="calibre23">n</code>. Subtracting 1 produces a value in the range that we want, from 0 to <code class="calibre23">n-1</code>.</p>
<p class="calibre13">Add the following directives to <code class="calibre23">MainPage.xaml.cpp</code>:</p>
<pre class="calibre28"><code class="calibre23">#include &lt;algorithm&gt;
#include &lt;random&gt;</code></pre>
<p class="calibre13">The <code class="calibre23">algorithm</code> header is for <code class="calibre23">random_shuffle()</code>and the <code class="calibre23">random</code> header provides the <code class="calibre23">random_device</code> and <code class="calibre23">uniform_int_distribution</code> types.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Highlighting the UI Cards</h3>
<p class="calibre13">You can highlight a card when the mouse cursor is over it by implementing the <code class="calibre23">Card_Entered()</code> and <code class="calibre23">Card_Exited()</code> handlers. You can highlight a card simply by changing its color, which means changing the <code class="calibre23">Background</code> property value for the <code class="calibre23">Grid</code> object that caused the event in the <code class="calibre23">Card_Entered()</code> handler:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Card_Entered(Platform::Object^ sender,
                Windows::UI::Xaml::Input::PointerRoutedEventArgs^ e)
{
  safe_cast&lt;Grid^&gt;(sender)-&gt;Background = steelBrush;
}</code></pre>
<p class="calibre13">You know that <code class="calibre23">sender</code> must be a handle to a <code class="calibre23">Grid</code> object so you cast it to type <code class="calibre23">Grid^</code>. You set the value of the <code class="calibre23">Background</code> property to the color provided by a <code class="calibre23">SolidColorBrush</code> object that is referenced by <code class="calibre23">steelBrush</code>. You can add this handle and a handle to a <code class="calibre23">SolidColorBrush</code> of the original color as a class member to avoid creating an object each time the handler is called.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="867" id="calibre_link-1329" class="calibre14"></span>Add the following to the <code class="calibre23">MainPage</code> class as <code class="calibre23">private</code> members:</p>
<pre class="calibre28"><code class="calibre23">Windows::UI::Xaml::Media::SolidColorBrush^ steelBrush;  // Card highlighted
Windows::UI::Xaml::Media::SolidColorBrush^ azureBrush;  // Card normal</code></pre>
<p class="calibre13">You can initialize these in the <code class="calibre23">MainPage</code> constructor:</p>
<pre class="calibre28"><code class="calibre23">MainPage::MainPage()  : card1Up {}, card2Up {}, pairCount {}
{
  InitializeComponent();
  // Brushes for card colors
  steelBrush = ref new SolidColorBrush(Windows::UI::Colors::SteelBlue);
  azureBrush = ref new SolidColorBrush(Windows::UI::Colors::Azure);
 
  // Rest of the code as before...
}</code></pre>
<p class="calibre13">A card will be returned to its original color by the <code class="calibre23">Card_Exited()</code> handler:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Card_Exited(Platform::Object^ sender,
            Windows::UI::Xaml::Input::PointerRoutedEventArgs^ e)
{
  safe_cast&lt;Grid^&gt;(sender)-&gt;Background = azureBrush;
}</code></pre>
<p class="calibre13">If you recompile and execute the application, you should be able to see card highlighting in action.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Handling Card Back Events</h3>
<p class="calibre13">Clicking the back of a card turns over the card. This is handled by the <code class="calibre23">Cardback_Tapped()</code> member of <code class="calibre23">MainPage</code>. If it is the first card turned over, the card is recorded in <code class="calibre23">card1Up</code> and the member function is done. If another card is already turned over, which is signaled by <code class="calibre23">card1Up</code> being non-null, then the card originating the current event is the second card. In this case the function must check if the cards are the same. If they are, a pair has been found, so the function will update <code class="calibre23">pairCount</code> and disable events for these cards. It will also store the handles to the cards in the <code class="calibre23">pairsFound</code> vector. It will also fade the cards a bit to show they are no longer in the game.</p>
<p class="calibre13">If they are not the same, the player must click either upturned card to turn them both back over, before trying for another pair. To ensure this happens, the function will disable events for all the other cards, which will be those showing the backs. When the front of either of the two cards is clicked, the <code class="calibre23">Shape_Tapped()</code> handler will be called, which should turn over both cards to show the backs and restore events to all the other cards.</p>
<p class="calibre13">Here’s how the code for <code class="calibre23">Cardback_Tapped()</code> looks to do that:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Cardback_Tapped(Platform::Object^ sender,
                      Windows::UI::Xaml::Input::TappedRoutedEventArgs^ e)
{ // There may be 0 or 1 cards already turned over
  // If there is 1, the card handle will be in card1Up
  TextBlock^ cardBack = safe_cast&lt;TextBlock^&gt;(sender); // Always a card back handle
  cardBack-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed; // Hide the back
  // Find the card for the back so the shape can be made visible
  Card^ theCard;
  for(auto card : cardPack)
  {
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="868" id="calibre_link-1330" class="calibre14"></span>    if(cardBack == card-&gt;Back)
    { // We have found the card so show the front
      card-&gt;Shape-&gt;Visibility = Windows::UI::Xaml::Visibility::Visible;
      theCard = card;
      break;
    }
  }
  if(!card1Up)
  {
    card1Up = theCard;
  }
  else
  {
    card2Up = theCard;
    if(card1Up-&gt;type == card2Up-&gt;type &amp;&amp; card1Up-&gt;Color == card2Up-&gt;Color)
    { // We have a pair!
      pairsFound-&gt;Append(card1Up);
      pairsFound-&gt;Append(card2Up);
      DisableCard(card1Up);
      DisableCard(card2Up);
      card1Up = card2Up = nullptr;
      if(++pairCount == cardCount/2)
        GameOver();
    }
    else
    { // Two cards up but no pair so we now want a Tapped event on either
      // Disable Tapped event for card backs and PointerEntered 
      // and PointerExited events for other cards
      for(size_t i {}; i &lt; cardBacks-&gt;Length; ++i)
      {
        if(cardBacks[i] == card1Up-&gt;Back || cardBacks[i] == card2Up-&gt;Back)
          continue;
        cardBacks[i]-&gt;IsTapEnabled = false;
        grids[i]-&gt;IsHitTestVisible = false;
      }
    }
  } 
}</code></pre>
<p class="calibre13">Turning a card over involves hiding the back and showing the front. The card back that originated the event is hidden by setting its <code class="calibre23">Visibility</code> property to <code class="calibre23">Collapsed</code>. The function then searches <code class="calibre23">cardPack</code> to find the <code class="calibre23">Card</code> object with this back. It shows the front of this card by setting the <code class="calibre23">Visibility</code> property value for the shape to <code class="calibre23">Visible</code>. It then checks for one or two cards up and proceeds as I described at the beginning of this section. If <code class="calibre23">pairCount</code> reaches half the number of cards in the pack, all pairs have been found, so the <code class="calibre23">GameOver()</code> function is called to end the game. Add this function as a <code class="calibre23">private</code> member of the <code class="calibre23">MainPage</code> class:</p>
<pre class="calibre28"><code class="calibre23">void GameOver();</code></pre>
<p class="calibre13">Add a skeleton implementation to the <code class="calibre23">.cpp</code> file:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::GameOver()
{
  // Code to be added later...
}</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="869" id="calibre_link-1331" class="calibre14"></span>The <code class="calibre23">Cardback_Tapped()</code> function calls a helper function, <code class="calibre23">DisableCardUp()</code>, so add the following as a <code class="calibre23">private</code> member of the <code class="calibre23">MainPage</code> class:</p>
<pre class="calibre28"><code class="calibre23">void DisableCard(Card^ card);</code></pre>
<p class="calibre13">The implementation in <code class="calibre23">MainPage.xaml.cpp</code> will be:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::DisableCard(Card^ card)
{
  card-&gt;Shape-&gt;IsTapEnabled = false;      // Disable Tapped event...
  card-&gt;Shape-&gt;Opacity = 0.5;
 
  // Get the parent Grid for shape
  auto grid = safe_cast&lt;Grid^&gt;(card-&gt;Shape-&gt;Parent);
  grid = safe_cast&lt;Grid^&gt;(grid-&gt;Parent);
  grid-&gt;IsHitTestVisible = false;         // Disable hit test
  grid-&gt;Background = azureBrush;          // Make sure of color
}</code></pre>
<p class="calibre13">This disables the <code class="calibre23">Tapped</code> event for the <code class="calibre23">Card</code> object referenced by the argument and sets its <code class="calibre23">Opacity</code> property value to <code class="calibre23">0.5</code>, which will make it semi-transparent. It’s possible that the background color could be the highlight color so this is set to the normal color to make sure it is that.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Handling Shape Events</h3>
<p class="calibre13">When a <code class="calibre23">Tapped</code> event for a <code class="calibre23">Shape</code> object occurs, there must be at least one card face up because the event could not occur otherwise, and there may be two cards face up. If there’s just one, the <code class="calibre23">Tapped</code> event handler should just turn the card face down, which allows the player to change his mind about the first selection. If there are two cards face up, they represent a failed pair selection so <code class="calibre23">Tapped</code> events from the backs of the other cards will be disabled. Thus for two cards up, the handler must turn the cards over and then enable <code class="calibre23">Tapped</code> events for all the backs that are not pairs.</p>
<p class="calibre13">Here’s the code for <code class="calibre23">Shape_Tapped()</code>:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Shape_Tapped(Platform::Object^ sender,
                        Windows::UI::Xaml::Input::TappedRoutedEventArgs^ e)
{
  // With this event there is always at least one card up but could be two.
  // If only one card is up, the handle is in card1Up
  Shape^ shape = safe_cast&lt;Shape^&gt;(sender);
  if(card1Up &amp;&amp; card2Up)
  {  // Two cards up so turn over both cards
    card1Up-&gt;Shape-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
    card1Up-&gt;Back-&gt;Visibility = Windows::UI::Xaml::Visibility::Visible;
    card2Up-&gt;Shape-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed;
    card2Up-&gt;Back-&gt;Visibility = Windows::UI::Xaml::Visibility::Visible;
 
    // Enable events for all card backs and background grids
    for(size_t i {}; i &lt; cardBacks-&gt;Length; ++i)
    {
      if(IsFound(cardBacks[i]))
        continue;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="870" id="calibre_link-1332" class="calibre14"></span>      cardBacks[i]-&gt;IsTapEnabled = true;
      grids[i]-&gt;IsHitTestVisible = true;
    }
    card1Up = card2Up = nullptr;  // Reset both handles to cards up
  }
  else
  {  // only one card up and it was clicked so turn over the card
    card1Up-&gt;Shape-&gt;Visibility = Windows::UI::Xaml::Visibility::Collapsed; 
    card1Up-&gt;Back-&gt;Visibility = Windows::UI::Xaml::Visibility::Visible;
    card1Up = nullptr;
  }
}</code></pre>
<p class="calibre13">This calls a helper function, <code class="calibre23">IsFound()</code>, that checks whether a card back belongs to a card in a previously found pair. Add the following to the <code class="calibre23">MainPage</code> class, in a <code class="calibre23">private</code> section as always:</p>
<pre class="calibre28"><code class="calibre23">bool IsFound(Windows::UI::Xaml::Controls::TextBlock^ back);</code></pre>
<p class="calibre13">The implementation of the function is:</p>
<pre class="calibre28"><code class="calibre23">bool MainPage::IsFound(TextBlock^ back)
{
  for(auto cardFound : pairsFound)
  {
    if(cardFound  &amp;&amp; cardFound-&gt;Back == back) return true;
  }
  return false;
}</code></pre>
<p class="calibre13">This iterates over the cards in the <code class="calibre23">pairsFound</code> vector. When the <code class="calibre23">back</code> property value for a card matches the argument, the function returns <code class="calibre23">true</code>. If no card is found, <code class="calibre23">false</code> is returned. At this point you should be able to try out the game. Nothing happens when you find all the pairs and you can’t start a new game yet.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Recognizing a Win</h3>
<p class="calibre13"><code class="calibre23">GameOver()</code>is called when all pairs have been found. The success should be acknowledged in some way. You could display a message in the message area that recognizes the win. Return to <code class="calibre23">MainPage.xaml</code>. Add a <code class="calibre23">RichTextBlock</code> control to the <code class="calibre23">messageArea Grid</code> element at the bottom of the game grid. You can specify the text using a <code class="calibre23">Paragraph</code> element, as you did with the game title. The XAML for the <code class="calibre23">messageArea</code> element should now be:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid x:Name="messageArea" Grid.Column="1" Grid.Row="2" Margin="10,0,0,0" 
        Background="Bisque"&gt;
  &lt;RichTextBlock x:Name="winMessage" Opacity="0" FontFamily="Freestyle Script"
        FontWeight="Bold" FontSize="90" TextAlignment="Center" Foreground="Red"&gt;
     &lt;Paragraph&gt;
       &lt;Run Text="YOU WIN!!!"/&gt;
     &lt;/Paragraph&gt;
  &lt;/RichTextBlock&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="871" id="calibre_link-1333" class="calibre14"></span>Note that the <code class="calibre23">Opacity</code> property value for the <code class="calibre23">RichTextBlock</code> element is 0, so the text will not be visible. The <code class="calibre23">GameOver()</code> function that is called when all pairs have been found can display the content for the <code class="calibre23">winMessage</code> element by setting the value for its <code class="calibre23">Opacity</code> property to <code class="calibre23">1.0</code>:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::GameOver()
{
  winMessage-&gt;Opacity = 1.0;                       // Show the win message
}</code></pre>
<p class="calibre13">There may be other messages in the message area so it would be a good idea to provision for hiding any other messages that appear there. You could do this by adding a <code class="calibre23">private</code> helper function to the <code class="calibre23">MainPage</code> class, which you could implement like this:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::HideMessages()
{
  auto messageCollection = messageArea-&gt;Children;
  for(UIElement^ element : messageCollection)
  {
    element-&gt;Opacity = 0;
  }
}</code></pre>
<p class="calibre13">This function obtains the collection of child elements for the <code class="calibre23">Grid</code> element, <code class="calibre23">messageArea</code>. This is defined in the <code class="calibre23">FrameworkElement</code> class that is derived from <code class="calibre23">UIElement</code>. It iterates over all the child elements in the collection, setting the <code class="calibre23">Opacity</code> property value for each to 0.</p>
<p class="calibre13">You can call this helper function in <code class="calibre23">GameOver()</code>:</p>
<pre class="calibre28"><code class="calibre23">void MainPage::GameOver()
{
  HideMessages();                               // Hide any other messages
  winMessage-&gt;Opacity = 1.0;                    // Show the win message
}</code></pre>
<p class="calibre13">When you find all the pairs, the win message will magically appear.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Handling Game Control Button Events</h3>
<p class="calibre13">The two <code class="calibre23">Button</code> elements in the <code class="calibre23">Grid</code> element at the left of the card grid are game controls. Add <code class="calibre23">Tapped</code> event handlers for these with the names <code class="calibre23">Start_Tapped</code> and <code class="calibre23">Show_How_Tapped</code> through the Properties pane for each.</p>
<p class="calibre13">Let’s implement the Start button handler first. When the Start button event occurs, the game should be reset to its initial state with all messages hidden and a new game started with the cards shuffled. This is not too taxing:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Start_Tapped(Platform::Object^ sender,
Windows::UI::Xaml::Input::TappedRoutedEventArgs^ e)
{
  HideMessages();                                        // Clear the message area
  InitializeGame();                                      // Reset the game
}</code></pre>
<p class="calibre13">You have already done the work necessary. Calling <code class="calibre23">HideMessages()</code> clears the message area and <code class="calibre23">InitializeGame()</code> sets up the cards and elements in <code class="calibre23">cardGrid</code> for a new game.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="872" id="calibre_link-1334" class="calibre14"></span>The <code class="calibre23">Show_How_Tapped()</code> handler just needs to display the instructions in the message area. The first step is to add another <code class="calibre23">RichTextBlock</code> element as a child of the <code class="calibre23">messageArea</code> grid. You can do this in the Design pane. Be sure that you add the <code class="calibre23">RichTextBlock</code> element to the <code class="calibre23">Grid</code> element, and not as a child of the <code class="calibre23">RichTextBlock</code> element for the win message. You can specify the content with <code class="calibre23">Paragraph</code> elements, like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;RichTextBlock x:Name="playMessage" Opacity="0" Margin="10 0 0 0"&gt;
   &lt;Paragraph FontFamily="Verdana" FontSize="30" FontWeight="Bold"
              Foreground="Green"&gt;
     &lt;Run Text="How to Play:"/&gt;
   &lt;/Paragraph&gt;
  &lt;Paragraph FontFamily="Verdana" FontSize="20" FontWeight="Normal"
             Foreground="Black"&gt;
     &lt;Run Text="The idea is to find all the pairs of matching cards "/&gt;
     &lt;Run Text="by turning up two at a time."/&gt;
  &lt;/Paragraph&gt;
  &lt;Paragraph FontFamily="Verdana" FontSize="20" FontWeight="Normal"
                                                         Foreground="Black"&gt;
     &lt;Run Text="If you find a pair, they will fade "/&gt;
     &lt;Run Text="and you can try for another pair."/&gt;
  &lt;/Paragraph&gt;
  &lt;Paragraph FontFamily="Verdana" FontSize="20" FontWeight="Normal"
                                                         Foreground="Black"&gt;
     &lt;Run Text=
      "If two cards don't match, click either to turn them back over."/&gt;
  &lt;/Paragraph&gt;
  &lt;Paragraph FontFamily="Verdana" FontSize="20" FontWeight="Normal"
             Foreground="Black"&gt;
     &lt;Run Text="Click the Start button for a new game."/&gt;
  &lt;/Paragraph&gt;
&lt;/RichTextBlock&gt;</code></pre>
<p class="calibre13">These elements are placed just before the end tag for the <code class="calibre23">messageArea Grid</code> element. The <code class="calibre23">Margin</code> property value will inset the text in the <code class="calibre23">Paragraph</code> elements from the left edge of the grid. You can see from this that you can set individual text characteristics for each <code class="calibre23">Paragraph</code> element. The first has a <code class="calibre23">FontSize</code> property value of <code class="calibre23">"30"</code> while the other elements display the text in a 20-point font. You can set any of the text properties individually in each <code class="calibre23">Paragraph</code> element, including the text color. Each <code class="calibre23">Paragraph</code> element starts a new line. If the content for a <code class="calibre23">Paragraph</code> element does not fit on a single line within the width of the parent, the content will spill automatically. The <code class="calibre23">Opacity</code> property for the <code class="calibre23">RichTextBlock</code> element is <code class="calibre23">"0"</code>, so it will not be visible initially. When the <code class="calibre23">FontFamily</code> property value is the same for all <code class="calibre23">Paragraph</code> child elements as it is here, you could set it as the value for the <code class="calibre23">FontFamily</code> property for the parent <code class="calibre23">RichTextBlock</code> element. You could then omit the property specification from the child <code class="calibre23">Paragraph</code> elements.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You must not split the string for the value of a</i> <code class="calibre23">Text</code> <i class="calibre15">property in a</i> <code class="calibre23">Run</code> <i class="calibre15">element over two or more lines but you can put the text in several</i> <code class="calibre23">Run</code> <i class="calibre15">elements as in the preceding code.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="873" id="calibre_link-1335" class="calibre14"></span>You need to display the <code class="calibre23">playMessage</code> element when the <code class="calibre23">Show_How_Tapped()</code> event handler is called:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Show_How_Tapped(Platform::Object^ sender,
                           
Windows::UI::Xaml::Input::TappedRoutedEventArgs^ e)
{
  HideMessages();                                     // Clear the message area
  playMessage-&gt;Opacity = 1;                           // Show the instructions
}</code></pre>
<p class="calibre13">You should now have a fully working game. <a id="calibre_link-1407" href="#calibre_link-446" class="calibre3">Figure 18-9</a> shows the game in progress.</p>
<figure class="calibre16">
<img class="center" src="images/000013.jpg" alt="image" />
<figcaption class="calibre17">
<p class="calibre13"><span class="figurelabel"><b class="calibre12"><a id="calibre_link-446" href="#calibre_link-1407" class="calibre3">FIGURE 18-9</a></b></span></p>
</figcaption>
</figure>
<p class="calibre13">A <code class="calibre23">Height</code> or <code class="calibre23">Width</code> property value for an element is not necessarily the value you specify. It may be adjusted during the rendering process and your value is treated as a suggested value that may be modified to suit the context. The <code class="calibre23">ActualHeight</code> and <code class="calibre23">ActualWidth</code> properties for an element are its rendered height and width. You can see this happening if you adjust the size of the simulator window; you can drag a corner using the mouse. All the elements in the app will adjust in size.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-387" class="calibre3"></a>SCALING UI ELEMENTS</h2>
<p class="calibre13">The <code class="calibre23">Loaded</code> event for the <code class="calibre23">Page</code> root element occurs when the complete page has been created and the UI elements have been rendered; it is also called if the application is resized. The outer <code class="calibre23">Grid</code> that is the parent of the <code class="calibre23">Grid</code> elements for cards will vary its size according to the context. Its <code class="calibre23">ActualHeight</code> and <code class="calibre23">ActualWidth</code> property values will have been determined when the <code class="calibre23">Loaded</code> event handler is called.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="874" id="calibre_link-1336" class="calibre14"></span>Each card is a <code class="calibre23">Grid</code> element of the background color that has a square child <code class="calibre23">Grid</code> element for the contents of the card. The dimensions of the outer <code class="calibre23">Grid</code> element for a card is determined automatically from <code class="calibre23">cardGrid</code>. You could define the height and width of each inner <code class="calibre23">Grid</code> element for a card in terms of the <code class="calibre23">ActualHeight</code> and <code class="calibre23">ActualWidth</code> property values of the outer <code class="calibre23">Grid</code> element. You could therefore calculate the dimensions of the square <code class="calibre23">Grid</code> elements that contain the shapes in a handler for the <code class="calibre23">Loaded</code> event for the <code class="calibre23">Page</code> root element.</p>
<p class="calibre13">Add the <code class="calibre23">Loaded</code> property to the XAML for the <code class="calibre23">Page</code> element with the value as <code class="calibre23">"Page_Loaded"</code>, like this:</p>
<pre class="calibre28"><code class="calibre23">&lt;Page
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:MemoryTest"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    x:Class="MemoryTest.MainPage"
    
    mc:Ignorable="d"
    Loaded="Page_Loaded"&gt;
        &lt;!-- All the UI elements --&gt;
&lt;/Page&gt;</code></pre>
<p class="calibre13">With the cursor in the handler name, press F12 to go to the code. You can implement the handler like this:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Page_Loaded(Platform::Object^ sender,
                                       Windows::UI::Xaml::RoutedEventArgs^ e)
{
  // Scale all card shapes so they squarely fit their grid cells.
  // Iterate over all children of the cardGrid grid.
  for (size_t i {}; i &lt; cardGrid-&gt;Children-&gt;Size; ++i)
  {
    // Get the small grid in each cell.
    Grid^ grid = safe_cast&lt;Grid^&gt;(cardGrid-&gt;Children-&gt;GetAt(i));
 
   // Get the small grid inside the small grid.
    Grid^ childGrid = safe_cast&lt;Grid^&gt;(grid-&gt;Children-&gt;GetAt(0));
 
    // Calculate the scaling factor to keep everything square.
    double scale = 1.0;
    if (grid-&gt;ActualWidth &gt;= grid-&gt;ActualHeight)
    { // Landscape mode
      scale = 0.8*grid-&gt;ActualHeight / childGrid-&gt;ActualHeight;
    }
    else
    { // Portrait mode
      scale = 0.8*grid-&gt;ActualWidth / childGrid-&gt;ActualWidth;
    }
 
    // Apply scaling factor.
    auto scaleTransform = ref new ScaleTransform();
    scaleTransform-&gt;ScaleX = scale;
    scaleTransform-&gt;ScaleY = scale;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="875" id="calibre_link-1337" class="calibre14"></span>    childGrid-&gt;RenderTransformOrigin = Point(0.5, 0.5);     // Center of object
    childGrid-&gt;RenderTransform = scaleTransform;
  }
}</code></pre>
<p class="calibre13">This iterates over all the children of <code class="calibre23">cardGrid</code> that are the outer <code class="calibre23">Grid</code> elements. The scaling for the inner <code class="calibre23">Grid</code> element that houses the shapes needs to be different, depending on whether the game is displayed in landscape or portrait orientation.  You define the height and width of the inner to be 80% of the ratio of the outer and inner <code class="calibre23">Grid</code> heights in landscape, or the ratio of the widths in portrait orientation. Scaling is achieved using a <code class="calibre23">ScaleTransform</code> object. The <code class="calibre23">ScaleTransform</code> class is defined in the <code class="calibre23">Windows::UI::Xaml::Media</code> namespace. The <code class="calibre23">ScaleX</code> and <code class="calibre23">ScaleY</code> property values specify a scaling factor to be applied in the x and y directions. You apply the scaling transform by defining the <code class="calibre23">RenderTransform</code> property value for <code class="calibre23">childGrid</code> to be the <code class="calibre23">ScaleTransform</code> object that you created. The <code class="calibre23">RenderTransform</code> property value specifies a transformation that is to be applied when <code class="calibre23">childGrid</code> is rendered along with its children. The transform is applied relative to the origin that is specified by the <code class="calibre23">RenderTransformOrigin</code> property value, where a value of 0,0 is the top-left corner of the element and 1,1 is the bottom-right corner.</p>
<p class="calibre13">The <code class="calibre23">RenderTransform</code> property is inherited from <code class="calibre23">UIElement</code>, so you can define a transform for any element type that has <code class="calibre23">UIElement</code> as a base and the transform will be applied to the element as well as any child elements when it is rendered. The transform can do other things to an element. Setting <code class="calibre23">ScaleX</code> to -1 for instance will flip the element about the render transform origin. If you try the game again and rotate to portrait mode it doesn’t look good. You can improve this by changing the value of the <code class="calibre23">Width</code> property for the left column to 200:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid.ColumnDefinitions&gt;
    &lt;ColumnDefinition Width="200"/&gt;
    &lt;ColumnDefinition Width="*"/&gt;
&lt;/Grid.ColumnDefinitions&gt;</code></pre>
<p class="calibre13">Of course there’s huge potential for enhancing the game further. I’ll finish by introducing one more thing you can do in a Windows Store app.</p>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-388" class="calibre3"></a>TRANSITIONS</h2>
<p class="calibre13">Transitions are elements that provide the capability for animation of UI elements. The WinRT types for transition elements are in the <code class="calibre23">Windows::UI::Xaml::Media::Animation</code> namespace. I’ll just introduce you to a couple of animations in <code class="calibre23">MemoryTest</code>.</p>
<section class="toclist">
<h3 class="calibre21">Application Startup Transitions</h3>
<p class="calibre13">The <code class="calibre23">EntranceThemeTransition</code> element provides animation for controls when they are first displayed. When you apply it to an element with children such as <code class="calibre23">cardGrid</code>, the child elements will appear in sequence, rather than all together. This makes the initial presentation of the game window more pleasing. Here’s how you can implement an <code class="calibre23">EntranceThemeTransition</code> for <code class="calibre23">cardGrid</code> child elements:</p>
<pre class="calibre28"><code class="calibre23">&lt;Grid x:Name="cardGrid" Grid.Row="1" Grid.Column="1" Margin="32"&gt;
   &lt;Grid.RowDefinitions&gt;
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="876" id="calibre_link-1338" class="calibre14"></span>       &lt;!-- Elements defining the rows... --&gt;
   &lt;/Grid.RowDefinitions&gt;
 
   &lt;Grid.ColumnDefinitions&gt;
       &lt;!-- Elements defining the columns... --&gt;
   &lt;/Grid.ColumnDefinitions&gt;
 
   &lt;!-- Animate the display of the cards --&gt;
   &lt;Grid.ChildrenTransitions&gt;
       &lt;TransitionCollection&gt;
           &lt;EntranceThemeTransition/&gt;
       &lt;/TransitionCollection&gt;
   &lt;/Grid.ChildrenTransitions&gt;
 
   &lt;!-- Child elements defining the cards... --&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13"><code class="calibre23">Grid.ChildrenTransitions</code> is an attached property for a <code class="calibre23">Grid</code> element that is inherited from the <code class="calibre23">Panel</code> class. It has a property value of type <code class="calibre23">TransitionCollection</code> that represents a collection of one or more transitions. Transitions are objects that have <code class="calibre23">Transition</code> as a base class. The <code class="calibre23">Transition</code> class is in the <code class="calibre23">Windows::UI::Xaml::Media::Animation</code> namespace. There is just one element in the <code class="calibre23">TransitionCollection</code> for <code class="calibre23">cardGrid</code> and that is an <code class="calibre23">EntranceThemeTransition</code>. This transition does what you see for elements when they are first displayed. With these additional elements in <code class="calibre23">cardGrid</code>, the cards will animate into view in sequence when the application starts. You can apply this to any element or set of elements to get this behavior when the application is first displayed.</p>
</section>
<section class="toclist">
<h3 class="calibre21">Storyboard Animations</h3>
<p class="calibre13">I hope the second transition I’ll introduce will open the door to you exploring more possibilities. I’ll apply this transition to the button that shows how to play the game. This is much more complicated than the <code class="calibre23">cardGrid</code> transition because it introduces several elements involved in defining transitions. The transition applies to a transform for the button in the <code class="calibre23">StackPanel</code> element in the game controls grid. The <code class="calibre23">Button</code> element with the <code class="calibre23">Content</code> value <code class="calibre23">"How to Play"</code> will have a child element that specifies the transform. The XAML for the button is now this:</p>
<pre class="calibre28"><code class="calibre23">&lt;Button Content="How to Play" FontSize="20" Foreground="Red"
        Background="Gray" BorderBrush="Black" Height="90" Width="150"
        HorizontalAlignment="Center" Tapped="Show_How_Tapped"&gt;
 
   &lt;!-- This defines a transform that applies to the button --&gt;
   &lt;Button.RenderTransform&gt;
      &lt;RotateTransform x:Name="buttonRotate" /&gt;
   &lt;/Button.RenderTransform&gt;
 
&lt;/Button&gt;</code></pre>
<p class="calibre13"><code class="calibre23">Button.RenderTransform</code> is an attached property that has a value of type <code class="calibre23">RotateTransform</code> here. The content can be of any type that has <code class="calibre23">Transform</code> as a base, which includes <code class="calibre23">ScaleTransform, SkewTransform</code>, or <code class="calibre23">TranslateTransform</code>. A transform element can be subject to an animation that operates on a property of the transform. In the case of the <code class="calibre23">RotateTransform</code>, you are going to animate the <code class="calibre23">Angle</code> property value, which is the angle through which the element to which the transform applies &mdash; the button in this case &mdash; is rotated.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="877" id="calibre_link-1339" class="calibre14"></span>The mechanism for animating the <code class="calibre23">Angle</code> property value for the <code class="calibre23">RotateTransform</code> that is applied to the button will be provided by a <code class="calibre23">Storyboard</code> element that controls one or more animations that are specified by its children. You’ll define the <code class="calibre23">StoryBoard</code> element as a resource for the <code class="calibre23">StackPanel</code> parent of the button. It will be a child of a <code class="calibre23">StackPanel.Resource</code> element, which is an attached property of the <code class="calibre23">StackPanel</code> element.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">The</i> <code class="calibre23">Resource</code> <i class="calibre15">element that is an attached property value for the</i> <code class="calibre23">StackPanel</code> <i class="calibre15">element is local, but you can also define resources at a global level for your application.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">A <code class="calibre23">StoryBoard</code> element has child elements that each define an animation. A <code class="calibre23">StoryBoard</code> element can control the start time and duration of the animations that are its children through its <code class="calibre23">Duration</code> and <code class="calibre23">BeginTime</code> property values, and the child elements can also specify these properties independently. You are going to keep it very simple and just apply one animation. This will be a <code class="calibre23">DoubleAnimation</code> element that can animate any property value of type <code class="calibre23">double</code>. This animation varies the value to which it applies linearly between two limits. You specify the range by the <code class="calibre23">From</code> and <code class="calibre23">To</code> property values for the <code class="calibre23">DoubleAnimation</code> element. You specify the time over which the variation will occur by its <code class="calibre23">Duration</code> property value, which is of the form <code class="calibre23">"hh:mm:ss[.fractional seconds]"</code> where <code class="calibre23">hh</code> is from 0 to 23 hours, <code class="calibre23">mm</code> is from 0 to 59 minutes, and <code class="calibre23">ss</code> is from 0 to 59 seconds and you can optionally specify fractions of a second. You specify the <code class="calibre23">BeginTime</code> value in the same way. The <code class="calibre23">BeginTime</code> property value is the delay before the animation starts.</p>
<p class="calibre13">Here’s the complete set of XAML for the <code class="calibre23">Grid</code> element that contains the buttons, including the animation:</p>
<pre class="calibre28"><code class="calibre23">&lt;!-- Game controls--&gt;
&lt;Grid Grid.Row="1" Grid.RowSpan="2" Background="Bisque" Margin="0,10,0,0"&gt;
   &lt;Grid.RowDefinitions&gt;
      &lt;RowDefinition Height="1*" /&gt;
      &lt;RowDefinition Height="1*" /&gt;
   &lt;/Grid.RowDefinitions&gt;
 
   &lt;Button Grid.Row="0" Content="Start" FontSize="32" Foreground="Red"
           Background="Gray" BorderBrush="Black" Height="90" Width="150"
           HorizontalAlignment="Center" VerticalAlignment="Center"
           Tapped="Start_Tapped"/&gt;
 
   &lt;StackPanel x:Name="ButtonPanel" Grid.Row="1"&gt;
 
   &lt;!-- This Child element contains resources that can be used in the panel
     --&gt;
      &lt;StackPanel.Resources&gt;
        &lt;!-- This defines one or more animations as a resource.
             The value for x:Name is the name you use in C++ to start
             the animation. 
         --&gt;
 
        &lt;Storyboard x:Name="playButtonTurn"&gt;
           &lt;!-- This defines an animation that will start 5 seconds after
                the animation is initiated. The animation and its reverse
                will each last 3 seconds.
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="878" id="calibre_link-1340" class="calibre14"></span>            --&gt;
           &lt;DoubleAnimation From="1" To="90"
                            Duration="00:00:3" BeginTime="00:00:5"
                            Storyboard.TargetName="buttonRotate"
                            Storyboard.TargetProperty="Angle"
                            AutoReverse="True"&gt;
 
        &lt;!-- The easing function determines how the animation operates.
             This particular easing function defines an elastic animation
             by its springiness and the number of oscillations.
         --&gt;
              &lt;DoubleAnimation.EasingFunction&gt;
               &lt;!-- This function specifies how the Angle property value
                    changes.
                --&gt;
                &lt;ElasticEase Oscillations="5" Springiness="1" 
                             EasingMode="EaseOut"/&gt;
              &lt;/DoubleAnimation.EasingFunction&gt;
 
           &lt;/DoubleAnimation&gt;
        &lt;/Storyboard&gt;
      &lt;/StackPanel.Resources&gt;
 
      &lt;Button Content="How to Play" FontSize="20" Foreground="Red"
              Background="Gray" BorderBrush="Black" Height="90" Width="150"
              HorizontalAlignment="Center" Tapped="Show_How_Tapped"&gt;
 
         &lt;!-- This defines a transform that applies to the button --&gt;
           &lt;Button.RenderTransform&gt;
              &lt;RotateTransform x:Name="buttonRotate" /&gt;
           &lt;/Button.RenderTransform&gt;
 
     &lt;/Button&gt;
   &lt;/StackPanel&gt;
&lt;/Grid&gt;</code></pre>
<p class="calibre13">You start the animation in C++ by calling the <code class="calibre23">Begin()</code> function for the <code class="calibre23">StoryBoard</code> object that you can reference through its handle, <code class="calibre23">playButtonTurn</code>. The value of the <code class="calibre23">StoryBoard.TargetName</code> attached property in the <code class="calibre23">DoubleAnimation</code> element identifies the transform to which the child animation applies. This is the name for the <code class="calibre23">RotateTransform</code> for the button. The <code class="calibre23">From</code> and <code class="calibre23">To</code> property values in the <code class="calibre23">DoubleAnimation</code> element specify the range over which the <code class="calibre23">Angle</code> property for the <code class="calibre23">RotateTransform</code> will be varied. Here it’s from 1 to 90 degrees. The <code class="calibre23">Angle</code> property is identified by the value of the <code class="calibre23">StoryBoard.TargetProperty</code> attached property. Specifying <code class="calibre23">AutoReverse</code> as <code class="calibre23">"True"</code> for the <code class="calibre23">DoubleAnimation</code> element causes the animation to execute first forward, then in reverse. The <code class="calibre23">Duration</code> property value applies to both.</p>
<p class="calibre13">The algorithm the <code class="calibre23">DoubleAnimation</code> applies to a property is defined by an easing function. There are several elements that define easing functions and the corresponding WinRT types are in the <code class="calibre23">Windows::UI::Xaml::Media::Animation</code> namespace. My choice is <code class="calibre23">ElasticEase</code>. This has a <code class="calibre23">Springiness</code> property that determines the springiness of the animation. The larger the value for this, the more elastic the animation is. The <code class="calibre23">Oscillations</code> property value is the number of oscillations in the animation. Other easing functions include <code class="calibre23">BounceEase, CubicEase, QuarticEase, QuinticEase</code>, and <code class="calibre23">SineEase</code>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="879" id="calibre_link-1341" class="calibre14"></span>You can initiate the animation when the How to Play button is clicked:</p>
<pre class="calibre28"><code class="calibre23">void MemoryTest::MainPage::Show_How_Tapped(Platform::Object^ sender,
                                Windows::UI::Xaml::Input::TappedRoutedEventArgs^ e)
{
  HideMessages();                                     // Clear the message area
  playButtonTurn-&gt;Begin();                            // Start the animation
  playMessage-&gt;Opacity = 1;                           // Show the instructions
}</code></pre>
<p class="calibre13">If you have entered the XAML and code correctly, you should see an interesting effect 5 seconds after you click the button.</p>
</section>
</section>
<section class="toclist">
<h2 class="calibre4"><a id="calibre_link-389" class="calibre3"></a>SUMMARY</h2>
<p class="calibre13">As I said at the beginning, this chapter is a very brief introduction to programming Windows Store apps. I have had to omit a lot of detail and pick what I think are the features that you need to understand at the outset. My objective with this chapter has been to show that while developing a Windows Store app is not trivial, it’s not that difficult. There’s a lot of code involved &mdash; inevitably with Windows &mdash; but when you break it down it’s easy to manage. I hope I have given you enough of an insight to delve deeper into writing Windows Store apps.</p>
<section class="toclist">
<h3 class="calibre21"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="880" id="calibre_link-1342" class="calibre24"></span>WHAT YOU LEARNED IN THIS CHAPTER</h3>
<table class="calibre29">
<tbody class="calibre30">
<tr class="calibre31">
<th class="calibre32"><b class="calibre12">TOPIC</b></th>
<th class="calibre32"><b class="calibre12">CONCEPT</b></th>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows Store apps</b></td>
<td class="calibre32">A Windows Store app is targeted at tablets or desktop PCs running Windows 8 and executes in a sandbox that limits access to resources in the environment.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">Windows Runtime (WinRT)</b></td>
<td class="calibre32">WinRT is the Windows API for Windows Store apps. It is an object-oriented API that is language neutral, and WinRT objects are COM objects. WinRT objects are reference counted.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">C++/CX</b></td>
<td class="calibre32">C++/CX is a set of Microsoft-specific extensions to standard C++ that make it easier to work with the WinRT. C++/CX includes the ability to define class types that are compatible with WinRT, and to define handle types that store handles to ref class objects.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">XAML</b></td>
<td class="calibre32">XAML is a language for specifying the user interface in a Windows Store app. When an application is compiled, code is generated that creates the UI elements defined by the XAML.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">XAML elements</b></td>
<td class="calibre32">A XAML element is defined by a start tag and an end tag or by a start-end tag. A XAML element can contain other elements called child elements. Start and end tags for XAML elements must not overlap. The start and end tags for a child element must both be between the start and end tags of the parent.</td>
</tr>
<tr class="calibre31">
<td class="calibre32"><b class="calibre12">XAML files</b></td>
<td class="calibre32">A XAML file comprises a set of nested XAML elements with a single root element. Each page in the UI for a Windows Store app is defined by a separate XAML file.</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-1380">
<section class="toclist" {http://www.idpf.org/2007/ops}type="titlepage">
<header class="calibre7">
<h1 class="booktitle"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="v" id="calibre_link-447" class="calibre36"></span>IVOR HORTON’S BEGINNING Visual C++® 2013</h1>
</header>
<p class="calibre13">&nbsp;</p>
<div class="calibre11">
<div class="bookauthor">
<p class="authorname">Ivor Horton</p>
</div>
</div>
<p class="calibre13">&nbsp;</p>
<p class="calibre13">&nbsp;</p>
<p class="calibre13">&nbsp;</p>
<div class="publisherwordmark">
<figure class="floatleft"><img src="images/000143.gif" alt="Wiley Logo" class="calibre25" /></figure>
</div>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-99">
<section class="copyright" {http://www.idpf.org/2007/ops}type="copyright-page">
<p class="copyright1"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="vi" id="calibre_link-448" class="calibre37"></span><span class="copyrightbooktitle">Ivor Horton’s Beginning Visual C++® 2013</span></p>
<p class="copyright1">Published by</p>
<p class="copyright1">John Wiley &amp; Sons, Inc.</p>
<p class="copyright1">10475 Crosspoint Boulevard</p>
<p class="copyright1">Indianapolis, IN 46256</p>
<p class="copyright1"><a href="http://www.wiley.com" class="calibre3">www.wiley.com</a></p>
<p class="copyright1">Copyright © 2014 by Ivor Horton</p>
<p class="copyright1">Published by John Wiley &amp; Sons, Inc., Indianapolis, Indiana</p>
<p class="copyright1">Published simultaneously in Canada</p>
<p class="copyright1">ISBN: 978-1-118-84571-4</p>
<p class="copyright1">ISBN: 978-1-118-84568-4 (ebk)</p>
<p class="copyright1">ISBN: 978-1-118-84577-6 (ebk)</p>
<p class="copyright1">No part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted under Sections 107 or 108 of the 1976 United States Copyright Act, without either the prior written permission of the Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright Clearance Center, 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978) 646-8600. Requests to the Publisher for permission should be addressed to the Permissions Department, John Wiley &amp; Sons, Inc., 111 River Street, Hoboken, NJ  07030, (201) 748-6011, fax (201) 748-6008, or online at <a href="http://www.wiley.com/go/permissions" class="calibre3">http://www.wiley.com/go/permissions</a>.</p>
<p class="copyright1"><span class="copyrightbooktitle">Limit of Liability/Disclaimer of Warranty:</span> The publisher and the author make no representations or warranties with respect to the accuracy or completeness of the contents of this work and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. No warranty may be created or extended by sales or promotional materials. The advice and strategies contained herein may not be suitable for every situation. This work is sold with the understanding that the publisher is not engaged in rendering legal, accounting, or other professional services. If professional assistance is required, the services of a competent professional person should be sought. Neither the publisher nor the author shall be liable for damages arising herefrom. The fact that an organization or Web site is referred to in this work as a citation and/or a potential source of further information does not mean that the author or the publisher endorses the information the organization or Web site may provide or recommendations it may make. Further, readers should be aware that Internet Web sites listed in this work may have changed or disappeared between when this work was written and when it is read.</p>
<p class="copyright1">For general information on our other products and services please contact our Customer Care Department within the United States at (877) 762-2974, outside the United States at (317) 572-3993 or fax (317) 572-4002.</p>
<p class="copyright1">Wiley publishes in a variety of print and electronic formats and by print-on-demand. Some material included with standard print versions of this book may not be included in e-books or in print-on-demand. If this book refers to media such as a CD or DVD that is not included in the version you purchased, you may download this material at <a href="http://booksupport.wiley.com" class="calibre3">http://booksupport.wiley.com</a>. For more information about Wiley products, visit <a href="http://www.wiley.com" class="calibre3">www.wiley.com</a>.</p>
<p class="copyright1"><span class="copyrightbooktitle">Library of Congress Control Number:</span> 2014930412</p>
<p class="copyright1"><span class="copyrightbooktitle">Trademarks:</span> Wiley, the Wrox logo, Programmer to Programmer, and related trade dress are trademarks or registered trademarks of John Wiley &amp; Sons, Inc. and/or its affiliates, in the United States and other countries, and may not be used without written permission. Visual C++ is a registered trademark of Microsoft Corporation. All other trademarks are the property of their respective owners. John Wiley &amp; Sons, Inc., is not associated with any product or vendor mentioned in this book.</p>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-1">
<section class="toclist" {http://www.idpf.org/2007/ops}type="dedication">
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="vii" id="calibre_link-449" class="calibre14"></span><i class="calibre15">This book is for my dear wife, Eve.</i><span {http://www.idpf.org/2007/ops}type="pagebreak" title="viii" id="calibre_link-450" class="calibre14"></span></p>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-188">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="ix" id="calibre_link-451" class="calibre9"></span><a id="calibre_link-2332" class="calibre3"></a>ABOUT THE AUTHOR</h1>
</header>
<p class="calibre13"><b class="calibre12">Ivor Horton</b> graduated as a mathematician and was lured into information technology by promises of great rewards for very little work. In spite of the reality usually being a great deal of work for relatively modest rewards, he has continued to work with computers to the present day. He has been engaged at various times in programming, systems design, consultancy, and the management and implementation of projects of considerable complexity.</p>
<p class="calibre13">Horton has many years of experience in the design and implementation of computer systems applied to engineering design and manufacturing operations in a variety of industries. He has considerable experience in developing occasionally useful applications in a wide variety of programming languages, and in teaching primarily scientists and engineers to do likewise. He has been writing books on programming for several years, and his currently published works include tutorials on C, C++, and Java. At the present time, when he is not writing programming books or providing advice to others, he spends his time fishing, traveling, and enjoying life in general.</p>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-1398">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-2333" class="calibre3"></a>ABOUT THE TECHNICAL EDITORS</h1>
</header>
<p class="calibre13"><b class="calibre12">Giovanni Dicanio</b> is a Microsoft Visual C++ MVP, computer programmer, and Pluralsight author. His computer programming experience dates back to the glorious Commodore 64 and Commodore Amiga 500 golden days. He started with C=64 BASIC, then moved to assembly, Pascal, C, C++, Java, and C#. Giovanni wrote computer programming articles on C++, MFC, OpenGL, and other programming subjects in Italian computer magazines. He contributed code to some open-source projects as well, including a mathematical expression parser written in C++ for one of the first versions of QCAD. Giovanni’s programming experience includes Windows programming using C++, Win32, COM, and ATL. His favorite programming languages are C and C++.</p>
<p class="calibre13">He has recently started cultivating an interest for mobile platforms and embedded systems.</p>
<p class="calibre13">He can be contacted via e-mail at <a href="mailto:giovanni.dicanio@gmail.com" class="calibre3">giovanni.dicanio@gmail.com</a>.</p>
<p class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="x" id="calibre_link-452" class="calibre14"></span><b class="calibre12">Marc Gregoire</b> is a software engineer from Belgium. He graduated from the University of Leuven, Belgium, with a degree in “Burgerlijk ingenieur in de computer wetenschappen” (equivalent to Master of Science in engineering in computer science). The year after, he received the cum laude degree of master in artificial intelligence at the same university. After his studies, Marc started working for a software consultancy company called Ordina Belgium. As a consultant, he worked for Siemens and Nokia Siemens Networks on critical 2G and 3G software running on Solaris for telecom operators. This required working in international teams stretching from South America and the United States to EMEA and Asia. Now, Marc is working for Nikon Metrology on 3D laser scanning software.</p>
<p class="calibre13">His main expertise is C/C++, and specifically Microsoft VC++ and the MFC framework. He has experience in developing C++ programs running 24x7 on Windows and Linux platforms; for example, KNX/EIB home automation software. Next to C/C++, Marc also likes C# and uses PHP for creating web pages.</p>
<p class="calibre13">Since April 2007, he received the yearly Microsoft MVP (Most Valuable Professional) award for his Visual C++ expertise.</p>
<p class="calibre13">Marc is the founder of the Belgian C++ Users Group (<a href="http://www.becpp.org" class="calibre3">www.becpp.org</a>), author of <i class="calibre15">Professional</i> C++, Wrox, 2011 (ISBN 978-047-0-93244-9) and a member on the CodeGuru forum (as Marc G). He maintains a blog on <a href="http://www.nuonsoft.com/blog/" class="calibre3">www.nuonsoft.com/blog/</a>.</p>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-189">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="xi" id="calibre_link-453" class="calibre9"></span><a id="calibre_link-2334" class="calibre3"></a>CREDITS</h1>
</header>
<p class="creditstitle"><b class="calibre12">Executive Editor</b></p>
<p class="calibre20">Robert Elliott</p>
<p class="creditstitle"><b class="calibre12">Project Editors</b></p>
<p class="calibre20">Sydney Jones Argenta</p>
<p class="calibre20">Edward Connor</p>
<p class="creditstitle"><b class="calibre12">Technical Editors</b></p>
<p class="calibre20">Giovani Dicanio</p>
<p class="calibre20">Marc Gregoire</p>
<p class="creditstitle"><b class="calibre12">Production Editor</b></p>
<p class="calibre20">Christine Mugnolo</p>
<p class="creditstitle"><b class="calibre12">Copy Editor</b></p>
<p class="calibre20">Charlotte Kughen</p>
<p class="creditstitle"><b class="calibre12">Manager of Content Development and Assembly</b></p>
<p class="calibre20">Mary Beth Wakefield</p>
<p class="creditstitle"><b class="calibre12">Director of Community Marketing</b></p>
<p class="calibre20">David Mayhew</p>
<p class="creditstitle"><b class="calibre12">Marketing Manager</b></p>
<p class="calibre20">Ashley Zurcher</p>
<p class="creditstitle"><b class="calibre12">Business Manager</b></p>
<p class="calibre20">Amy Knies</p>
<p class="creditstitle"><b class="calibre12">Vice President and Executive Group Publisher</b></p>
<p class="calibre20">Richard Swadley</p>
<p class="creditstitle"><b class="calibre12">Associate Publisher</b></p>
<p class="calibre20">Jim Minatel</p>
<p class="creditstitle"><b class="calibre12">Project Coordinator, Cover</b></p>
<p class="calibre20">Todd Klemme</p>
<p class="creditstitle"><b class="calibre12">Proofreader</b></p>
<p class="calibre20">Sarah Kaikini, Word One New York</p>
<p class="creditstitle"><b class="calibre12">Indexer</b></p>
<p class="calibre20">Johnna VanHoose Dinse</p>
<p class="creditstitle"><b class="calibre12">Cover Designer</b></p>
<p class="calibre20">Wiley</p>
<p class="creditstitle"><b class="calibre12">Cover Image</b></p>
<p class="calibre20">©<a href="http://iStockphoto.com/xyno" class="calibre3">iStockphoto.com/xyno</a><span {http://www.idpf.org/2007/ops}type="pagebreak" title="xii" id="calibre_link-454" class="calibre14"></span></p>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-69">
<section class="toclist">
<header class="calibre7">
<h1 class="calibre8"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="xiii" id="calibre_link-455" class="calibre9"></span><a id="calibre_link-2335" class="calibre3"></a>ACKNOWLEDGMENTS</h1>
</header>
<p class="calibre13"><b class="calibre12">The Author</b> is only one member of the large team of people necessary to get a book into print. I’d like to thank the John Wiley &amp; Sons and Wrox Press editorial and production teams for their help and support throughout.</p>
<p class="calibre13">I would particularly like to thank my technical editors, Marc Gregoire and Giovanni Dicanio, for doing such a fantastic job of reviewing the text and checking out all the code fragments and examples. Their many constructive comments and suggestions have undoubtedly made the book a much better tutorial.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="xiv" id="calibre_link-456" class="calibre14"></span></p>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="frontmatter" class="calibre" id="calibre_link-0">
<section class="toclist" {http://www.idpf.org/2007/ops}type="introduction">
<header class="calibre7">
<h1 class="calibre8"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="xxxiii" id="calibre_link-457" class="calibre9"></span><a id="calibre_link-2336" class="calibre3"></a>INTRODUCTION</h1>
</header>
<p class="calibre13"><b class="calibre12">Welcome to</b> <i class="calibre15">Ivor Horton’s Beginning Visual C++ 2013</i>. With this book, you can become an effective C++ programmer using Microsoft’s latest application-development system, Visual Studio Professional 2013. I aim to teach you the C++ programming language, and then how to apply C++ in the development of your own Windows applications. Along the way, you will also learn about many of the exciting new capabilities introduced by this latest version of Visual C++.</p>
<p class="calibre13">Visual C++ 2013 comes with the Microsoft development environment Visual Studio Professional 2013. When I refer to Visual C++ in the rest of the book, I mean the Visual C++ 2013 capability that comes as part of Visual Studio Professional 2013. Note that the Visual Studio Express 2013 Edition <i class="calibre15">does not</i> provide sufficient facilities for this book. None of the examples in Chapters 11 through 18 can be created with Visual Studio Express 2013.</p>
<section class="toclist">
<div class="calibre38"></div><h2 class="calibre4">WHO THIS BOOK IS FOR</h2>
<p class="calibre13">This book is for anyone who wants to learn how to write C++ applications for Microsoft Windows using Visual C++. I make no assumptions about prior knowledge of any programming language, so there are no prerequisites other than some aptitude for programming and sufficient enthusiasm and commitment for learning C++. This tutorial is for you if:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">You are a newcomer to programming and sufficiently keen to jump into the deep end with C++. To be successful, you need to have at least a rough idea of how your computer works.</li>
<li class="calibre6">You have a little experience of programming in some other language, such as BASIC, and you want to learn C++ and develop practical Microsoft Windows programming skills.</li>
<li class="calibre6">You have some experience in C or C++, but not in a Microsoft Windows context and want to extend your skills to program for the Windows environment using the latest tools and technologies.</li>
</ul>
</section>
<section class="toclist">
<div class="calibre38"></div><h2 class="calibre4">WHAT THIS BOOK COVERS</h2>
<p class="calibre13">The first part of the book teaches you the essentials of C++ programming using Visual Studio Professional 2013 through a detailed, step-by-step tutorial. You’ll learn the syntax and use of the C++ language and gain experience and confidence in applying it in a practical context through working examples. You’ll find complete code for the examples that demonstrate virtually all aspects of C++. There are also exercises that you can use to test your knowledge, with solutions available for download if you get stuck.</p>
<p class="calibre13">The language tutorial also introduces and demonstrates the use of the C++ standard library facilities you are most likely to need. You’ll add to your knowledge of the standard libraries incrementally as you <span {http://www.idpf.org/2007/ops}type="pagebreak" title="xxxiv" id="calibre_link-458" class="calibre14"></span>progress through the C++ language. You’ll also learn about the powerful tools provided by the Standard Template Library (STL).</p>
<p class="calibre13">When you are confident in applying C++, you move on to Windows programming. You will learn how to develop Windows desktop applications using the Microsoft Foundation Classes (MFC) by creating a substantial working application of more than 2,000 lines of code. You develop the application over several chapters, utilizing a broad range of user interface capabilities provided by the MFC. You also learn the essentials of programming applications targeting tablets running Windows 8. You learn about creating an application with the Windows 8 Modern interface by incrementally developing a working example of a game.</p>
</section>
<section class="toclist">
<div class="calibre38"></div><h2 class="calibre4">HOW THIS BOOK IS STRUCTURED</h2>
<p class="calibre13">The book is structured so that as far as possible, each chapter builds on what you have learned in previous chapters:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">Chapter 1 introduces you to the basic concepts you need to understand for programming in C++ and the main ideas embodied in the Visual C++ development environment. It describes how you use Visual C++ to create the various kinds of applications you’ll learn about in the rest of the book.</li>
<li class="calibre6">Chapters 2 through 9 teach you the C++ language. You start with simple procedural program examples and progress to learning about classes and object-oriented programming.</li>
<li class="calibre6">Chapter 10 teaches you how you use the Standard Template Library (STL). The STL is a powerful and extensive set of tools for organizing and manipulating data in your C++ programs. The STL is application-neutral, so you can apply it in a wide range of contexts.</li>
<li class="calibre6">Chapter 11 discusses how Microsoft Windows desktop applications are structured and describes and demonstrates the essential elements that are present in every desktop application written for the Windows operating system. The chapter explains through elementary examples how Windows applications work, and you’ll create programs that use C++ with the Windows API and with the MFC.</li>
<li class="calibre6">Chapters 12 through 17 teach you Windows desktop application programming. You learn to write Windows applications using the MFC for building a GUI. You’ll be creating and using common controls to build the graphical user interface for your application, and you’ll learn how to handle the events that result from user interactions with your program. In addition to the techniques you learn for building a GUI, the application you develop will show you how to handle printing and how your application can work with files.</li>
<li class="calibre6">Chapter 18 introduces the fundamental ideas involved in writing applications for Windows 8. You’ll develop a fully working application that uses the Windows 8 Modern user interface.</li>
</ul>
<p class="calibre13">All chapters include working examples that demonstrate the programming techniques discussed. Every chapter concludes with a summary of the key points that were covered, and most chapters <span {http://www.idpf.org/2007/ops}type="pagebreak" title="xxxv" id="calibre_link-459" class="calibre14"></span>include a set of exercises at the end that you can attempt, to apply what you have learned. Solutions to all the exercises, and all the code from the examples in the book are available for download from the publisher’s website.</p>
</section>
<section class="toclist">
<h2 class="calibre4">WHAT YOU NEED TO USE THIS BOOK</h2>
<p class="calibre13">There are several versions of Visual Studio 2013, and they each have a different range of capabilities. This book assumes you have the Visual Studio Professional 2013 Edition (or a superior edition) installed. To put it another way, any of the paid versions of Visual Studio 2013 are okay. There are lower cost student versions of these available if you are in full-time education. None of the free Express editions will suffice.</p>
<p class="calibre13">All the examples in Chapters 1 through 17 will work if you have Visual Studio installed with Windows 7 or Windows 8. To work with Chapter 18, your version of Visual Studio must be installed in a Windows 8 environment.</p>
<p class="calibre13">The examples in Chapters 2 through 10 can be created and executed with the Visual Studio Express 2013 for Windows Desktop, but none of the examples in Chapters 11 through 18 can.</p>
</section>
<section class="toclist">
<h2 class="calibre4">CONVENTIONS</h2>
<p class="calibre13">To help you get the most from the text and keep track of what’s happening, we’ve used a number of conventions throughout the book.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature1">
<h3 class="calibre26">TRY IT OUT</h3>
<p class="calibre20">The <i class="calibre15">Try It Out</i> is an exercise you should work through, following the text in the book.</p>
<ol class="calibre5">
<li class="calibre6">They usually consist of a set of steps.</li>
<li class="calibre6">Each step has a number.</li>
<li class="calibre6">Follow the steps through with your copy of the program.</li>
</ol>
<section class="toclist">
<h4 class="calibre22"><i class="calibre15">How It Works</i></h4>
<p class="calibre20">After each <i class="calibre15">Try It Out</i>, the code you’ve typed will be explained in detail.</p>
</section>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">WARNING</i></b> <i class="calibre15">Boxes like this one hold important, not-to-be-forgotten information that is directly relevant to the surrounding text.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><span {http://www.idpf.org/2007/ops}type="pagebreak" title="xxxvi" id="calibre_link-460" class="calibre14"></span><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Notes, tips, hints, tricks, and asides to the current discussion are offset and placed in italics like this.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">As for styles in the text:</p>
<ul class="chapterfeaturinglist">
<li class="calibre6">We <i class="calibre15">highlight</i> new terms and important words when we introduce them.</li>
<li class="calibre6">We show keyboard strokes like this: Ctrl+A.</li>
<li class="calibre6">We show filenames, URLs, and code within the text like so: <code class="calibre23">persistence.properties</code>.</li>
<li class="calibre6">We present code in two different ways:</li>
</ul>
<pre class="calibre28"><code class="calibre23">We use a monofont type with no highlighting for most code examples.
<b class="calibre12">We use bold highlighting to emphasize code that is of particular importance in the present context.</b></code></pre>
</section>
<section class="toclist">
<h2 class="calibre4">SOURCE CODE</h2>
<p class="calibre13">You should type in the code for all the examples yourself; this greatly helps memory and the learning process.  However, you can download all the source code files for examples in the book, so if you can’t work out why your code doesn’t work, you’ll have some available that does. The code downloads for the examples are located at <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a> on the Download Code tab.</p>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">Because many books have similar titles, you may find it easiest to search by ISBN; this book’s ISBN is 978-1-118-84571-4.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Once you download the code, just decompress it with your favorite compression tool. Alternately, you can go to the main Wrox code download page at <a href="http://www.wrox.com/dynamic/books/download.aspx" class="calibre3">www.wrox.com/dynamic/books/download.aspx</a> to see the code available for this book and all other Wrox books.</p>
</section>
<section class="toclist">
<h2 class="calibre4">EXERCISES</h2>
<p class="calibre13">Many of the chapters have a set of exercises for you to test your knowledge. I encourage you to try all of these. If you get stuck you can download solutions to all of these exercises from <a href="http://www.wrox.com/go/beginningvisualc" class="calibre3">www.wrox.com/go/beginningvisualc</a>.</p>
</section>
<section class="toclist">
<h2 class="calibre4">ERRATA</h2>
<p class="calibre13">We make every effort to ensure that there are no errors in the text or in the code. However, no one is perfect, and mistakes do occur. If you find an error in one of our books, like a spelling mistake or faulty piece of code, we would be very grateful for your feedback. By sending in errata, you may save <span {http://www.idpf.org/2007/ops}type="pagebreak" title="xxxvii" id="calibre_link-461" class="calibre14"></span>another reader hours of frustration, and at the same time, you will be helping us provide even higher quality information.</p>
<p class="calibre13">To find the errata page for this book, go to <a href="http://www.wrox.com" class="calibre3">http://www.wrox.com</a> and locate the title using the Search box or one of the title lists. Then, on the book’s detail page, click the Book Errata link. On this page, you can view all errata that has been submitted for this book and posted by Wrox editors. A complete book list, including links to each book’s errata, is also available at <a href="http://www.wrox.com/misc-pages/booklist.shtml" class="calibre3">www.wrox.com/misc-pages/booklist.shtml</a>.</p>
<p class="calibre13">If you don’t spot “your” error on the Book Errata page, go to <a href="http://www.wrox.com/contact/techsupport.shtml" class="calibre3">www.wrox.com/contact/techsupport.shtml</a> and complete the form there to send us the error you have found. We’ll check the information and, if appropriate, post a message to the book’s errata page and fix the problem in subsequent editions of the book.</p>
</section>
<section class="toclist">
<h2 class="calibre4">P2P.WROX.COM</h2>
<p class="calibre13">For author and peer discussion, join the P2P forums at <a href="http://p2p.wrox.com" class="calibre3">p2p.wrox.com</a>. The forums are a web-based system for you to post messages relating to Wrox books and related technologies and interact with other readers and technology users. The forums offer a subscription feature to e-mail you topics of interest of your choosing when new posts are made to the forums. Wrox authors, editors, other industry experts, and your fellow readers are present on these forums.</p>
<p class="calibre13">At <a href="http://p2p.wrox.com" class="calibre3">http://p2p.wrox.com</a>, you will find a number of different forums that will help you, not only as you read this book, but also as you develop your own applications. To join the forums, just follow these steps:</p>
<ol class="calibre5">
<li class="calibre6">Go to <a href="http://p2p.wrox.com" class="calibre3">p2p.wrox.com</a> and click the Register link.</li>
<li class="calibre6">Read the terms of use and click Agree.</li>
<li class="calibre6">Complete the required information to join, as well as any optional information you wish to provide, and click Submit.</li>
<li class="calibre6">You will receive an e-mail with information describing how to verify your account and complete the joining process.</li>
</ol>
<aside {http://www.idpf.org/2007/ops}type="sidebar" class="calibre11">
<div class="top"><hr class="calibre19" /></div>
<section class="feature">
<p class="calibre20"><b class="calibre12"><i class="calibre15">NOTE</i></b> <i class="calibre15">You can read messages in the forums without joining P2P, but in order to post your own messages, you must join.</i></p>
<div class="top"><hr class="calibre19" /></div>
</section>
</aside>
<p class="calibre13">Once you join, you can post new messages and respond to messages other users post. You can read messages at any time on the web. If you would like to have new messages from a particular forum e-mailed to you, click the Subscribe to this Forum icon by the forum name in the forum listing.</p>
<p class="calibre13">For more information about how to use the Wrox P2P, be sure to read the P2P FAQs for answers to questions about how the forum software works, as well as many common questions specific to P2P and Wrox books. To read the FAQs, click the FAQ link on any P2P page.<span {http://www.idpf.org/2007/ops}type="pagebreak" title="xxxviii" id="calibre_link-462" class="calibre14"></span></p>
</section>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="backmatter" class="calibre" id="calibre_link-390">
<section class="toclist">
<figure class="calibre16">
<span {http://www.idpf.org/2007/ops}type="pagebreak" title="918" id="calibre_link-1343" class="calibre14"></span><span {http://www.idpf.org/2007/ops}type="pagebreak" title="919" id="calibre_link-1344" class="calibre14"></span><span {http://www.idpf.org/2007/ops}type="pagebreak" title="920" id="calibre_link-1345" class="calibre14"></span><span {http://www.idpf.org/2007/ops}type="pagebreak" title="921" id="calibre_link-1346" class="calibre14"></span><span {http://www.idpf.org/2007/ops}type="pagebreak" title="922" id="calibre_link-1347" class="calibre14"></span>
<img class="center" src="images/000171.jpg" alt="image" />
</figure>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="backmatter" class="calibre" id="calibre_link-45">
<section class="toclist">
<figure class="calibre16">
<img class="center" src="images/000057.jpg" alt="image" />
</figure>
</section>
</div>


<div {http://www.idpf.org/2007/ops}type="backmatter" class="calibre" id="calibre_link-1362">
<section class="toclist" {http://www.idpf.org/2007/ops}type="notice">
<header class="calibre7">
<h1 class="calibre8"><a id="calibre_link-391" class="calibre3"></a>WILEY END USER LICENSE AGREEMENT</h1>
</header>
<section class="toclist">
<p class="calibre13">Go to <a href="http://www.wiley.com/go/eula" class="calibre3">www.wiley.com/go/eula</a> to access Wiley’s ebook EULA.</p>
</section>
</section>
</div>


</body></html>